{
  "1": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); ++i) {\n        int complement = target - nums[i];\n        if (map.count(complement)) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {}; // or throw an exception\n}\n\nint main() {\n    std::vector<int> nums1 = {2, 7, 11, 15};\n    int target1 = 9;\n    auto result1 = twoSum(nums1, target1);\n    if (result1.empty()) {\n        std::cout << \"No solution found\" << std::endl;\n    } else {\n        std::cout << \"Indices: \" << result1[0] << \", \" << result1[1] << std::endl;\n    }\n\n    std::vector<int> nums2 = {3, 2, 4};\n    int target2 = 6;\n    auto result2 = twoSum(nums2, target2);\n    if (result2.empty()) {\n        std::cout << \"No solution found\" << std::endl;\n    } else {\n        std::cout << \"Indices: \" << result2[0] << \", \" << result2[1] << std::endl;\n    }\n\n    std::vector<int> nums3 = {1, 9, 5};\n    int target3 = 10;\n    auto result3 = twoSum(nums3, target3);\n    if (result3.empty()) {\n        std::cout << \"No solution found\" << std::endl;\n    } else {\n        std::cout << \"Indices: \" << result3[0] << \", \" << result3[1] << std::endl;\n    }\n\n    return 0;\n}\n```",
  "2": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n    ListNode dummyHead(0);\n    ListNode* p = &dummyHead;\n    int carry = 0;\n\n    while (l1 || l2 || carry) {\n        int sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\n        carry = sum / 10;\n        p->next = new ListNode(sum % 10);\n        p = p->next;\n\n        if (l1) l1 = l1->next;\n        if (l2) l2 = l2->next;\n    }\n\n    return dummyHead.next;\n}\n\nint main() {\n    // Test Case 1:\n    ListNode* l1 = new ListNode(2);\n    l1->next = new ListNode(4);\n    l1->next->next = new ListNode(3);\n\n    ListNode* l2 = new ListNode(5);\n    l2->next = new ListNode(6);\n    l2->next->next = new ListNode(4);\n\n    ListNode* result = addTwoNumbers(l1, l2);\n    while (result) {\n        cout << result->val << \" \";\n        result = result->next;\n    }\n    cout << endl;\n\n    // Test Case 2:\n    l1 = nullptr;\n    l2 = new ListNode(5);\n\n    result = addTwoNumbers(l1, l2);\n    while (result) {\n        cout << result->val << \" \";\n        result = result->next;\n    }\n    cout << endl;\n\n    // Test Case 3:\n    l1 = new ListNode(9);\n    l1->next = new ListNode(9);\n    l1->next->next = new ListNode(9);\n\n    l2 = new ListNode(1);\n\n    result = addTwoNumbers(l1, l2);\n    while (result) {\n        cout << result->val << \" \";\n        result = result->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "3": "```\n#include <iostream>\n#include <unordered_set>\n\nint lengthOfLongestSubstring(std::string s) {\n    int n = s.size();\n    int ans = 0;\n    int i = 0, j = 0;\n    std::unordered_set<char> set;\n    \n    while (j < n) {\n        if (!set.count(s[j]))\n            set.insert(s[j]);\n        else {\n            ans = std::max(ans, j - i);\n            set.erase(s[i++]);\n        }\n        j++;\n    }\n    \n    return std::max(ans, j - i);\n}\n\nint main() {\n    std::cout << \"Case 1: \" << lengthOfLongestSubstring(\"abcabcbb\") << \"\\n\";\n    std::cout << \"Case 2: \" << lengthOfLongestSubstring(\"bbbbb\") << \"\\n\";\n    std::cout << \"Case 3: \" << lengthOfLongestSubstring(\"abcbefgde\") << \"\\n\";\n    return 0;\n}",
  "5": "```\n#include <iostream>\n#include <string>\n\nstd::string longestPalindrome(std::string s) {\n    int start = 0, end = 0;\n    for (int i = 0; i < s.length(); i++) {\n        // odd length palindrome\n        start = i;\n        end = i;\n        while (start >= 0 && end < s.length() && s[start] == s[end]) {\n            start--;\n            end++;\n        }\n        \n        // even length palindrome\n        start = i;\n        end = i + 1;\n        while (start >= 0 && end < s.length() && s[start] == s[end]) {\n            start--;\n            end++;\n        }\n        \n        if (end - start > end - start) {\n            start = 0;\n            end = 0;\n        } else {\n            start = i + 1;\n            end = i;\n        }\n    }\n    \n    return s.substr(start, end - start + 1);\n}\n\nint main() {\n    std::cout << longestPalindrome(\"babad\") << std::endl; // \"bab\"\n    std::cout << longestPalindrome(\"cbbd\") << std::endl;   // \"bb\"\n    std::cout << longestPalindrome(\"a\") << std::endl;       // \"a\"\n    \n    return 0;\n}\n```",
  "4": "```\n#include <iostream>\n#include <vector>\n\ndouble findMedianSortedArrays(std::vector<int>& nums1, std::vector<int>& nums2) {\n    if (nums1.size() > nums2.size()) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n\n    int x = nums1.size();\n    int y = nums2.size();\n\n    int low = 0;\n    int high = x;\n\n    while (low <= high) {\n        int partitionX = (low + high) / 2;\n        int partitionY = (x + y + 1) / 2 - partitionX;\n\n        int maxLeftX = (partitionX == 0) ? INT_MIN : nums1[partitionX - 1];\n        int minRightX = (partitionX == x) ? INT_MAX : nums1[partitionX];\n\n        int maxLeftY = (partitionY == 0) ? INT_MIN : nums2[partitionY - 1];\n        int minRightY = (partitionY == y) ? INT_MAX : nums2[partitionY];\n\n        if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n            if ((x + y) % 2 == 0) {\n                return ((double)max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2;\n            } else {\n                return (double)max(maxLeftX, maxLeftY);\n            }\n        } else if (maxLeftX > minRightY) {\n            high = partitionX - 1;\n        } else {\n            low = partitionX + 1;\n        }\n    }\n\n    return 0.0;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 3};\n    std::vector<int> nums2 = {};\n    std::cout << \"Test Case 1: Expected Median = 1.000000, Actual Median = \" << findMedianSortedArrays(nums1, nums2) << std::endl;\n\n    std::vector<int> nums3 = {1, 2};\n    std::vector<int> nums4 = {3};\n    std::cout << \"Test Case 2: Expected Median = 2.000000, Actual Median = \" << findMedianSortedArrays(nums3, nums4) << std::endl;\n\n    std::vector<int> nums5 = {1, 1};\n    std::vector<int> nums6 = {1, 1};\n    std::cout << \"Test Case 3: Expected Median = 1.000000, Actual Median = \" << findMedianSortedArrays(nums5, nums6) << std::endl;\n\n    return 0;\n}\n```",
  "6": "```\n#include <iostream>\n#include <string>\n\nstd::string convert(const std::string& s, int numRows) {\n    if (numRows == 1 || s.empty()) return s;\n\n    std::string result;\n    for (int i = 0; i < numRows; ++i) {\n        for (int j = i; j < s.size(); j += numRows * 2 - 1) {\n            if (j + numRows - i >= s.size()) break;\n            result += s[j];\n            if (i != 0 && i != numRows - 1) {\n                if (j % (numRows * 2 - 2) == numRows - 1 - i)\n                    result += s[j + numRows - i];\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << convert(\"PAYPALISHARM\", 3) << std::endl; \n    // Expected Output: \"PAHNAPLSIIGYRA\"\n\n    std::cout << \"Test Case 2: \" << convert(\"a\", 1) << std::endl;\n    // Expected Output: \"a\"\n\n    std::cout << \"Test Case 3: \" << convert(\"abcdefg\", 2) << std::endl;\n    // Expected Output: \"acegbdf\"\n\n    return 0;\n}\n```",
  "7": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int reverse(int x) {\n        long res = 0;\n        while(x != 0) {\n            res = res * 10 + x % 10;\n            x /= 10;\n        }\n        if(res > INT_MAX || res < INT_MIN)\n            return 0;\n        return (int)res;\n    }\n};\n\nint main() {\n    Solution sol;\n    \n    cout << \"Test case 1: \" << sol.reverse(123) << endl;  // Output: 321\n    cout << \"Test case 2: \" << sol.reverse(-123) << endl;  // Output: -321\n    cout << \"Test case 3: \" << sol.reverse(1000000013) << endl;  // Output: 0\n\n    return 0;\n}\n```",
  "9": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        if (x < 0) return false;\n        int rev = 0;\n        int original = x;\n        while(x != 0) {\n            int pop = x % 10;\n            rev = rev * 10 + pop;\n            x /= 10;\n        }\n        return rev == original;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1: Positive palindrome\n    cout << \"Test case 1: \" << (s.isPalindrome(121) ? \"Pass\" : \"Fail\") << endl;\n\n    // Test case 2: Negative number\n    cout << \"Test case 2: \" << (s.isPalindrome(-121) ? \"Fail\" : \"Pass\") << endl;\n\n    // Test case 3: Non-palindrome\n    cout << \"Test case 3: \" << (s.isPalindrome(12345) ? \"Fail\" : \"Pass\") << endl;\n    \n    return 0;\n}\n```",
  "8": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    int myAtoi(std::string str) {\n        bool isNegative = false;\n        long long result = 0;\n\n        // Remove leading whitespaces\n        while (!str.empty() && isspace(str[0]))\n            str.erase(0, 1);\n\n        if (str.empty())\n            return 0;\n\n        // Check for negative sign\n        if (str[0] == '-') {\n            isNegative = true;\n            str.erase(0, 1);\n        } else if (str[0] == '+')\n            str.erase(0, 1);\n\n        // Process digits\n        for (char c : str) {\n            if (!isdigit(c))\n                break;\n\n            result *= 10;\n            result += c - '0';\n\n            // Check for overflow\n            if ((result > INT_MAX && !isNegative) || (result > LONG_MAX / 2 && isNegative))\n                return isNegative ? INT_MIN : INT_MAX;\n        }\n\n        return isNegative ? -(int)result : (int)result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1: Positive integer\n    std::cout << \"Test case 1: '123' => \" << solution.myAtoi(\"123\") << std::endl; // Output: 123\n\n    // Test case 2: Negative integer\n    std::cout << \"Test case 2: '-123' => \" << solution.myAtoi(\"-123\") << std::endl; // Output: -123\n\n    // Test case 3: Invalid input with non-digit characters\n    std::cout << \"Test case 3: '123abc' => \" << solution.myAtoi(\"123abc\") << std::endl; // Output: 123\n\n    return 0;\n}\n```",
  "10": "```\n#include <iostream>\n#include <string>\n\nbool isMatch(const std::string& s, const std::string& p) {\n    // Your logic here\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test Case 1: \" << isMatch(\"aa\", \"a\") << std::endl; // Expected: false\n    std::cout << \"Test Case 2: \" << isMatch(\"aa\", \"a*\") << std::endl; // Expected: true\n    std::cout << \"Test Case 3: \" << isMatch(\"mississippi\", \"mis*is*p*.\") << std::endl; // Expected: true\n    return 0;\n}\n```",
  "11": "```\n#include <iostream>\n#include <vector>\n\nint maxArea(std::vector<int>& height) {\n    int maxArea = 0;\n    int left = 0, right = height.size() - 1;\n\n    while (left < right) {\n        int h = std::min(height[left], height[right]);\n        int w = right - left;\n        int currArea = h * w;\n        maxArea = std::max(maxArea, currArea);\n\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return maxArea;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> height1 = {1,8,6,2,5,4,8,3,7};\n    int result1 = maxArea(height1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<int> height2 = {1,1};\n    int result2 = maxArea(height2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<int> height3 = {4,2,0,3,2,5};\n    int result3 = maxArea(height3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "12": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string intToRoman(int num) {\n        const std::vector<std::pair<int, std::string>> roman = {{1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"},\n                                                                 {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"},\n                                                                 {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}};\n        std::string result;\n        for (const auto& pair : roman) {\n            while (num >= pair.first) {\n                num -= pair.first;\n                result += pair.second;\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    int num1 = 3;\n    std::cout << \"Integer to Roman: \" << solution.intToRoman(num1) << std::endl;\n\n    int num2 = 4;\n    std::cout << \"Integer to Roman: \" << solution.intToRoman(num2) << std::endl;\n\n    int num3 = 9;\n    std::cout << \"Integer to Roman: \" << solution.intToRoman(num3) << std::endl;\n    \n    return 0;\n}\n```",
  "13": "```\n#include <iostream>\n#include <string>\n\nint romanToInt(std::string s) {\n    int sum = 0;\n    std::map<char, int> romanMap {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};\n    \n    for (int i = 0; i < s.length(); i++) {\n        if (i + 1 < s.length()) {\n            if (romanMap[s[i]] >= romanMap[s[i+1]]) {\n                sum += romanMap[s[i]];\n            } else {\n                sum -= romanMap[s[i]];\n            }\n        } else {\n            sum += romanMap[s[i]];\n        }\n    }\n    \n    return sum;\n}\n\nint main() {\n    std::cout << romanToInt(\"III\") << std::endl; // Expected output: 3\n    std::cout << romanToInt(\"IV\") << std::endl;   // Expected output: 4\n    std::cout << romanToInt(\"IX\") << std::endl;   // Expected output: 9\n    \n    return 0;\n}\n```",
  "14": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        if (strs.empty()) return \"\";\n        string prefix = strs[0];\n        for (int i = 1; i < strs.size(); i++) {\n            while (strs[i].find(prefix) != 0) {\n                prefix = prefix.substr(0, prefix.length() - 1);\n                if (prefix.empty()) return \"\";\n            }\n        }\n        return prefix;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> strs1 = {\"flower\",\"flow\",\"flight\"};\n    cout << \"Test case 1: \" << solution.longestCommonPrefix(strs1) << endl; // Output: \"fl\"\n\n    vector<string> strs2 = {\"\"};\n    cout << \"Test case 2: \" << solution.longestCommonPrefix(strs2) << endl; // Output: \"\"\n\n    vector<string> strs3 = {\"dog\",\"racecar\",\"car\"};\n    cout << \"Test case 3: \" << solution.longestCommonPrefix(strs3) << endl; // Output: \"c\"\n\n    return 0;\n}\n```",
  "15": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int>> threeSum(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> result;\n    \n    for (int i = 0; i < nums.size() - 2; ++i) {\n        if (i > 0 && nums[i] == nums[i-1]) continue;\n        \n        int j = i + 1, k = nums.size() - 1;\n        while (j < k) {\n            int sum = nums[i] + nums[j] + nums[k];\n            if (sum < 0) {\n                ++j;\n            } else if (sum > 0) {\n                --k;\n            } else {\n                result.push_back({nums[i], nums[j], nums[k]});\n                while (j < k && nums[j] == nums[j+1]) ++j;\n                while (j < k && nums[k] == nums[k-1]) --k;\n                ++j; --k;\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    int testCases = 3;\n\n    // Test Case 1\n    std::vector<int> testCase1{-1,0,1,-1,-6};\n    std::vector<std::vector<int>> expected1{{-1,-1,1},{-1,0,1}};\n    if (threeSum(testCase1) != expected1)\n        return -1;\n\n    // Test Case 2\n    std::vector<int> testCase2{0,1,1};\n    std::vector<std::vector<int>> expected2{};\n    if (threeSum(testCase2) != expected2)\n        return -1;\n\n    // Test Case 3\n    std::vector<int> testCase3{0,0,0};\n    std::vector<std::vector<int>> expected3{{0,0,0}};\n    if (threeSum(testCase3) != expected3)\n        return -1;\n\n    std::cout << \"Test Cases Passed!\" << std::endl;\n    return 0;\n}\n```",
  "16": "```\n#include <iostream>\n#include <vector>\n\nint threeSumClosest(std::vector<int>& nums, int target) {\n    std::sort(nums.begin(), nums.end());\n    int closest = nums[0] + nums[1] + nums[2];\n    for (int i = 0; i < nums.size() - 2; ++i) {\n        int left = i + 1;\n        int right = nums.size() - 1;\n        while (left < right) {\n            int sum = nums[i] + nums[left] + nums[right];\n            if (std::abs(sum - target) < std::abs(closest - target)) {\n                closest = sum;\n            }\n            if (sum < target) {\n                ++left;\n            } else if (sum > target) {\n                --right;\n            } else {\n                return target;\n            }\n        }\n    }\n    return closest;\n}\n\nint main() {\n    std::vector<int> nums1({-1, 2, 1, -4});\n    int target1 = 1;\n    std::cout << \"Test case 1: \" << threeSumClosest(nums1, target1) << std::endl;\n\n    std::vector<int> nums2({1, 2, -5, -4, -7});\n    int target2 = -2;\n    std::cout << \"Test case 2: \" << threeSumClosest(nums2, target2) << std::endl;\n\n    std::vector<int> nums3({0, 0, 0});\n    int target3 = 1;\n    std::cout << \"Test case 3: \" << threeSumClosest(nums3, target3) << std::endl;\n\n    return 0;\n}",
  "17": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<std::string> letterCombinations(string digits) {\n        if (digits.empty()) return {};\n\n        std::vector<std::string> ans;\n        std::vector<char> mapping {\"0\", \"1\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\n\n        std::function<void(int, std::string)> backtrack = [&](int pos, std::string path) {\n            if (pos == digits.size()) ans.push_back(path);\n            else {\n                for (char c : mapping[digits[pos] - '0' - 1]) {\n                    backtrack(pos + 1, path + c);\n                }\n            }\n        };\n\n        backtrack(0, \"\");\n        return ans;\n    }\n};\n\nint main() {\n    Solution s;\n\n    std::vector<std::string> res = s.letterCombinations(\"23\");\n    for (const auto& str : res) {\n        std::cout << str << std::endl;\n    }\n\n    res.clear();\n    res = s.letterCombinations(\"\");\n    if (res.empty()) {\n        std::cout << \"Empty result\" << std::endl;\n    } else {\n        for (const auto& str : res) {\n            std::cout << str << std::endl;\n        }\n    }\n\n    res.clear();\n    res = s.letterCombinations(\"2\");\n    for (const auto& str : res) {\n        std::cout << str << std::endl;\n    }\n\n    return 0;\n}\n```",
  "18": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int>> fourSum(std::vector<int>& nums, int target) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> result;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n        \n        for (int j = i + 1; j < nums.size(); j++) {\n            if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n            \n            int left = j + 1, right = nums.size() - 1;\n            while (left < right) {\n                int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if (sum < target) {\n                    left++;\n                } else if (sum > target) {\n                    right--;\n                } else {\n                    result.push_back({nums[i], nums[j], nums[left], nums[right]});\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    left++; right--;\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 0, -1, 0, -2, 2};\n    int target1 = 0;\n    auto res1 = fourSum(nums1, target1);\n    for (auto& r : res1) {\n        for (int i : r) std::cout << i << \" \";\n        std::cout << std::endl;\n    }\n    \n    nums1 = {2, 2, 2, 2, 2};\n    target1 = 8;\n    res1.clear();\n    res1 = fourSum(nums1, target1);\n    for (auto& r : res1) {\n        for (int i : r) std::cout << i << \" \";\n        std::cout << std::endl;\n    }\n    \n    nums1 = {0, 0, 0};\n    target1 = 1;\n    res1.clear();\n    res1 = fourSum(nums1, target1);\n    for (auto& r : res1) {\n        for (int i : r) std::cout << i << \" \";\n        std::cout << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "19": "```\n#include <iostream>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nvoid removeNthFromEnd(ListNode** head, int n) {\n    if (*head == NULL || n <= 0) return;\n\n    ListNode* oneStep = *head;\n    for (int i = 0; i < n; i++) {\n        oneStep = oneStep->next;\n    }\n\n    if (oneStep == NULL) {\n        *head = (*head)->next;\n        return;\n    }\n\n    ListNode* twoStep = *head;\n    while (oneStep != NULL) {\n        oneStep = oneStep->next;\n        twoStep = twoStep->next;\n    }\n    twoStep->next = twoStep->next->next;\n}\n\nint main() {\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(4);\n    head1->next->next->next->next = new ListNode(5);\n\n    removeNthFromEnd(&head1, 2);\n\n    while (head1 != NULL) {\n        std::cout << head1->val << \" \";\n        head1 = head1->next;\n    }\n    std::cout << std::endl;\n\n    ListNode* head2 = new ListNode(1);\n    head2->next = new ListNode(2);\n\n    removeNthFromEnd(&head2, 1);\n\n    while (head2 != NULL) {\n        std::cout << head2->val << \" \";\n        head2 = head2->next;\n    }\n    std::cout << std::endl;\n\n    ListNode* head3 = new ListNode(1);\n    head3->next = new ListNode(2);\n    head3->next->next = new ListNode(3);\n\n    removeNthFromEnd(&head3, 3);\n\n    while (head3 != NULL) {\n        std::cout << head3->val << \" \";\n        head3 = head3->next;\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
  "20": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nbool isValid(std::string s) {\n    std::stack<char> stack;\n    for (char c : s) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) return false;\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << (isValid(\"()\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 2: \" << (isValid(\"()(()))\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 3: \" << (isValid(\")\")) ? \"Pass\" : \"Fail\") << std::endl;\n\n    return 0;\n}\n```",
  "22": "```\n#include <iostream>\n#include <vector>\n\nvoid generateParenthesis(std::vector<std::string>& result, int left, int right, int maxLen, std::string current) {\n    if (maxLen == current.length()) {\n        result.push_back(current);\n        return;\n    }\n    if (left < right) {\n        if (left < maxLen) {\n            generateParenthesis(result, left + 1, right, maxLen, current + \"(\");\n        }\n        if (right < maxLen) {\n            generateParenthesis(result, left, right + 1, maxLen, current + \")\");\n        }\n    } else if (left == right && left < maxLen - 1) {\n        if (left < maxLen - 1) {\n            generateParenthesis(result, left + 1, right + 1, maxLen, current + \"()\");\n        }\n    }\n}\n\nint main() {\n    std::vector<std::string> result;\n    generateParenthesis(result, 0, 0, 3, \"\");\n    for (const auto& s : result) {\n        std::cout << s << std::endl;\n    }\n\n    std::cout << std::endl;\n\n    generateParenthesis(result, 0, 0, 2, \"\");\n    for (const auto& s : result) {\n        std::cout << s << std::endl;\n    }\n\n    std::cout << std::endl;\n\n    generateParenthesis(result, 1, 1, 3, \"\");\n    for (const auto& s : result) {\n        std::cout << s << std::endl;\n    }\n}\n```",
  "21": "```\n#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\n    if (!l1) return l2;\n    if (!l2) return l1;\n    \n    if (l1->val < l2->val) {\n        l1->next = mergeTwoLists(l1->next, l2);\n        return l1;\n    } else {\n        l2->next = mergeTwoLists(l1, l2->next);\n        return l2;\n    }\n}\n\nint main() {\n    ListNode* node1 = new ListNode(1);\n    node1->next = new ListNode(3);\n    node1->next->next = new ListNode(5);\n\n    ListNode* node2 = new ListNode(2);\n    node2->next = new ListNode(4);\n    node2->next->next = new ListNode(6);\n\n    ListNode* result1 = mergeTwoLists(node1, node2);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    ListNode* node3 = new ListNode(0);\n    node3->next = new ListNode(3);\n\n    ListNode* node4 = new ListNode(2);\n    node4->next = new ListNode(5);\n    node4->next->next = new ListNode(8);\n\n    ListNode* result2 = mergeTwoLists(node3, node4);\n    while (result2) {\n        cout << result2->val << \" \";\n        result2 = result2->next;\n    }\n    cout << endl;\n\n    ListNode* node5 = new ListNode(1);\n    node5->next = new ListNode(1);\n\n    ListNode* node6 = new ListNode(3);\n    node6->next = new ListNode(4);\n\n    ListNode* result3 = mergeTwoLists(node5, node6);\n    while (result3) {\n        cout << result3->val << \" \";\n        result3 = result3->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "23": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nstd::vector<int> mergeKLists(std::vector<ListNode*>& lists) {\n    std::priority_queue<ListNode*, std::vector<ListNode*>, decltype(&ListNode::val)> pq(ListNode::val);\n    \n    for (auto list : lists) {\n        if (list) {\n            pq.push(list);\n        }\n    }\n    \n    ListNode dummy(0), *tail = &dummy;\n    while (!pq.empty()) {\n        auto node = pq.top();\n        pq.pop();\n        \n        tail->next = new ListNode(node->val);\n        tail = tail->next;\n        \n        if (node->next) {\n            pq.push(node->next);\n        }\n    }\n    \n    return std::vector<int>();\n}\n\nint main() {\n    // Test case 1\n    ListNode* head1 = new ListNode(1, new ListNode(4, new ListNode(5)));\n    ListNode* head2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n    ListNode* head3 = new ListNode(2, new ListNode(6));\n    std::vector<ListNode*> lists = {head1, head2, head3};\n    std::vector<int> result;\n    for (auto node : mergeKLists(lists)) {\n        result.push_back(node);\n    }\n    std::cout << \"Test case 1: \";\n    for (int i = 0; i < result.size(); ++i) {\n        if (i > 0) {\n            std::cout << \" -> \";\n        }\n        std::cout << result[i];\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    head1 = new ListNode(0, new ListNode(3));\n    head2 = new ListNode(4);\n    lists.clear();\n    lists.push_back(head1);\n    lists.push_back(head2);\n    result.clear();\n    for (auto node : mergeKLists(lists)) {\n        result.push_back(node);\n    }\n    std::cout << \"Test case 2: \";\n    for (int i = 0; i < result.size(); ++i) {\n        if (i > 0) {\n            std::cout << \" -> \";\n        }\n        std::cout << result[i];\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    head1 = new ListNode(5);\n    head2 = new ListNode(1, new ListNode(3));\n    lists.clear();\n    lists.push_back(head1);\n    lists.push_back(head2);\n    result.clear();\n    for (auto node : mergeKLists(lists)) {\n        result.push_back(node);\n    }\n    std::cout << \"Test case 3: \";\n    for (int i = 0; i < result.size(); ++i) {\n        if (i > 0) {\n            std::cout << \" -> \";\n        }\n        std::cout << result[i];\n    }\n    std::cout << std::endl;\n}\n```",
  "24": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == NULL || head->next == NULL)\n            return head;\n\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    ListNode* node5 = new ListNode(5);\n    ListNode* node4 = new ListNode(4);\n    node4->next = node5;\n    ListNode* node3 = new ListNode(3);\n    node3->next = node4;\n    ListNode* node2 = new ListNode(2);\n    node2->next = node3;\n    ListNode* head1 = new ListNode(1);\n    head1->next = node2;\n    ListNode* result1 = solution.swapPairs(head1);\n\n    cout << \"Test case 1: \";\n    while (result1 != NULL) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test case 2\n    node5 = new ListNode(3);\n    node4 = new ListNode(2);\n    node4->next = node5;\n    node3 = new ListNode(1);\n    node3->next = node4;\n    head1 = NULL;\n    result1 = solution.swapPairs(head1);\n\n    cout << \"Test case 2: \";\n    while (result1 != NULL) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test case 3\n    node5 = new ListNode(0);\n    node4 = new ListNode(-1);\n    node4->next = node5;\n    node3 = NULL;\n    head1 = node4;\n    result1 = solution.swapPairs(head1);\n\n    cout << \"Test case 3: \";\n    while (result1 != NULL) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "26": "```\n#include <iostream>\n#include <vector>\n\nint removeDuplicates(std::vector<int>& nums) {\n    if (nums.size() == 0) return 0;\n    \n    int i = 1, j = 1;\n    while (j < nums.size()) {\n        if (nums[j] != nums[j - 1]) {\n            nums[i] = nums[j];\n            i++;\n        }\n        j++;\n    }\n    \n    return i;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 1, 2};\n    int res1 = removeDuplicates(nums1);\n    for (int i = 0; i < res1; i++) {\n        std::cout << nums1[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums2 = {1, 1, 1, 2, 3};\n    int res2 = removeDuplicates(nums2);\n    for (int i = 0; i < res2; i++) {\n        std::cout << nums2[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums3 = {1, 1, 1, 1, 2, 3};\n    int res3 = removeDuplicates(nums3);\n    for (int i = 0; i < res3; i++) {\n        std::cout << nums3[i] << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "25": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if (!head || k == 1) return head;\n\n        ListNode* prev = NULL;\n        ListNode* curr = head;\n        ListNode* next = NULL;\n        for (int i = 0; i < k && curr != NULL; i++) {\n            next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n\n        if (curr != NULL) {\n            head->next = reverseKGroup(curr, k);\n        } else {\n            return prev;\n        }\n        return head;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    ListNode* node1 = new ListNode(1);\n    ListNode* node2 = new ListNode(2);\n    ListNode* node3 = new ListNode(3);\n    ListNode* node4 = new ListNode(4);\n    ListNode* node5 = new ListNode(5);\n\n    node1->next = node2;\n    node2->next = node3;\n    node3->next = node4;\n    node4->next = node5;\n\n    ListNode* result = solution.reverseKGroup(node1, 2);\n    while (result != NULL) {\n        cout << result->val << \" \";\n        result = result->next;\n    }\n    cout << endl;\n\n    // Test case 2\n    node1 = new ListNode(1);\n    node2 = new ListNode(2);\n    node3 = new ListNode(3);\n    node4 = new ListNode(4);\n    node5 = new ListNode(5);\n\n    node1->next = node2;\n    node2->next = node3;\n    node3->next = node4;\n    node4->next = node5;\n\n    result = solution.reverseKGroup(node1, 3);\n    while (result != NULL) {\n        cout << result->val << \" \";\n        result = result->next;\n    }\n    cout << endl;\n\n    // Test case 3\n    node1 = new ListNode(1);\n    node2 = new ListNode(2);\n\n    node1->next = node2;\n\n    result = solution.reverseKGroup(node1, 1);\n    while (result != NULL) {\n        cout << result->val << \" \";\n        result = result->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "27": "```\n#include <iostream>\n#include <vector>\n\nint removeElement(std::vector<int>& nums, int val) {\n    if (nums.empty()) return 0;\n\n    int i = 0;\n    for (int j = 0; j < nums.size(); j++) {\n        if (nums[j] != val) {\n            nums[i++] = nums[j];\n        }\n    }\n\n    return i;\n}\n\nint main() {\n    std::vector<int> nums1 = {3, 2, 2, 3};\n    int val1 = 3;\n    int result1 = removeElement(nums1, val1);\n    if (result1 == 2) {\n        for (int num : nums1) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed.\" << std::endl;\n    }\n\n    std::vector<int> nums2 = {0, 1, 2, 2, 3, 0, 4, 2};\n    int val2 = 2;\n    int result2 = removeElement(nums2, val2);\n    if (result2 == 5) {\n        for (int num : nums2) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed.\" << std::endl;\n    }\n\n    std::vector<int> nums3 = {1};\n    int val3 = 1;\n    int result3 = removeElement(nums3, val3);\n    if (result3 == 1) {\n        for (int num : nums3) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "28": "```\n#include <iostream>\n#include <string>\n\nint strStr(const std::string& haystack, const std::string& needle) {\n    if (needle.empty()) {\n        return 0;\n    }\n    for (size_t i = 0; i <= haystack.size() - needle.size(); ++i) {\n        bool found = true;\n        for (size_t j = 0; j < needle.size(); ++j) {\n            if (haystack[i + j] != needle[j]) {\n                found = false;\n                break;\n            }\n        }\n        if (found) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    std::cout << strStr(\"hello\", \"ll\") << std::endl; // Expected output: 2\n    std::cout << strStr(\"aaaaa\", \"bba\") << std::endl; // Expected output: 3\n    std::cout << strStr(\"\", \"\") << std::endl; // Expected output: 0\n    return 0;\n}",
  "29": "```\n#include <iostream>\n#include <cassert>\n\nint divide(int dividend, int divisor) {\n    // Handle the special case where the divisor is zero\n    if (divisor == 0) {\n        throw std::runtime_error(\"Division by zero\");\n    }\n\n    // Determine the sign of the result\n    bool negative = ((dividend < 0) ^ (divisor < 0));\n\n    long long dvd = labs(dividend);\n    long long dvs = labs(divisor);\n\n    int res = 0;\n    do {\n        long long temp = dvs;\n        long long m = dvd;\n\n        // Find the number of times 'temp' can fit into 'm'\n        while (m >= temp) {\n            m -= temp;\n            res++;\n        }\n    } while (m > 0);\n\n    return negative ? -res : res;\n}\n\nint main() {\n    try {\n        std::cout << \"Test case 1: \" << divide(10, 3) << std::endl;  // Expected output: 3\n        std::cout << \"Test case 2: \" << divide(-22, 11) << std::endl;  // Expected output: -2\n        std::cout << \"Test case 3: \" << divide(7, -1) << std::endl;  // Expected output: -7\n\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}\n```",
  "30": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        if (s.empty() || words.empty()) return {};\n        int wordLen = words[0].size();\n        int len = wordLen * words.size();\n        vector<int> res;\n        \n        for (int i = 0; i <= s.size() - len; i++) {\n            unordered_map<string, int> map;\n            for (int j = 0; j < words.size(); j++) {\n                string tmp = s.substr(i + j * wordLen, wordLen);\n                if (!words[j].equals(tmp)) break;\n                map[tmp]++;\n                if (j == words.size() - 1) res.push_back(i);\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s = \"barfoofoo\";\n    vector<string> words = {\"foo\", \"bar\"};\n    vector<int> result1 = solution.findSubstring(s, words);\n    for (int i : result1) cout << i << endl;\n    cout << endl;\n\n    // Test case 2\n    s = \"wordgoodgood\";\n    words = {\"word\", \"good\", \"good\"};\n    vector<int> result2 = solution.findSubstring(s, words);\n    for (int i : result2) cout << i << endl;\n    cout << endl;\n\n    // Test case 3\n    s = \"a\";\n    words = {\"a\", \"b\"};\n    vector<int> result3 = solution.findSubstring(s, words);\n    for (int i : result3) cout << i << endl;\n    \n    return 0;\n}\n```",
  "31": "```\n#include <iostream>\n#include <vector>\n\nvoid nextPermutation(std::vector<int>& nums) {\n    int i = nums.size() - 2;\n    while (i >= 0 && nums[i] >= nums[i + 1]) {\n        i--;\n    }\n    if (i >= 0) {\n        int j = nums.size() - 1;\n        while (j > i && nums[j] <= nums[i]) {\n            j--;\n        }\n        std::swap(nums[i], nums[j]);\n    }\n    if (i < 0) {\n        std::reverse(nums.begin() + i + 1, nums.end());\n    }\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 3};\n    nextPermutation(nums1);\n    for (int num : nums1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums2 = {3, 2, 1};\n    nextPermutation(nums2);\n    for (int num : nums2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums3 = {4, 5, 6, 7};\n    nextPermutation(nums3);\n    for (int num : nums3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}\n```",
  "32": "```\n#include <iostream>\n#include <string>\n\nint longestValidParentheses(std::string s) {\n    int maxLen = 0;\n    int left = 0;\n    int right = 0;\n\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == '(')\n            left++;\n        else\n            right++;\n\n        if (i >= 1 && s[i] == ')' && s[i - 1] == '(') {\n            left -= 2;\n            right = 0;\n        }\n\n        if (left == right && left > maxLen) {\n            maxLen = left;\n        }\n    }\n\n    for (int i = s.length() - 1; i >= 0; i--) {\n        if (s[i] == ')')\n            left++;\n        else\n            right++;\n\n        if (i < s.length() - 1 && s[i] == '(' && s[i + 1] == ')') {\n            left -= 2;\n            right = 0;\n        }\n\n        if (left == right && left > maxLen) {\n            maxLen = left;\n        }\n    }\n\n    return maxLen * 2;\n}\n\nint main() {\n    std::cout << longestValidParentheses(\"(()\") << std::endl; // Expected: 2\n    std::cout << longestValidParentheses(\"())((\") << std::endl; // Expected: 4\n    std::cout << longestValidParentheses(\"((()))\") << std::endl; // Expected: 6\n\n    return 0;\n}\n```",
  "33": "```\n#include <iostream>\n#include <vector>\n\nint search(std::vector<int>& nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target)\n            return mid;\n\n        if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid])\n                right = mid - 1;\n            else\n                left = mid + 1;\n        } else {\n            if (nums[mid] < target && target <= nums[right])\n                left = mid + 1;\n            else\n                right = mid - 1;\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    std::vector<int> nums1 = {4, 5, 6, 7, 0, 1, 2};\n    int target1 = 0;\n    int result1 = search(nums1, target1);\n    std::cout << \"Test Case 1: \" << (result1 != -1 ? \"Found at index \" + std::to_string(result1) : \"Not found\") << std::endl;\n\n    std::vector<int> nums2 = {3, 5, 1};\n    int target2 = 5;\n    int result2 = search(nums2, target2);\n    std::cout << \"Test Case 2: \" << (result2 != -1 ? \"Found at index \" + std::to_string(result2) : \"Not found\") << std::endl;\n\n    std::vector<int> nums3 = {1};\n    int target3 = 0;\n    int result3 = search(nums3, target3);\n    std::cout << \"Test Case 3: \" << (result3 != -1 ? \"Found at index \" + std::to_string(result3) : \"Not found\") << std::endl;\n\n    return 0;\n}",
  "34": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int left = binarySearch(nums, target);\n        if (left == -1) return {-1, -1};\n        \n        int right = binarySearch(nums, target + 1) - 1;\n        \n        return {left, right};\n    }\n    \n    int binarySearch(vector<int>& nums, int target) {\n        int left = 0, right = nums.size() - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> nums1 = {5,7,7,8,8,10};\n    int target1 = 8;\n    cout << \"Test Case 1: \";\n    for (auto& num : solution.searchRange(nums1, target1)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> nums2 = {1,3};\n    int target2 = 3;\n    cout << \"Test Case 2: \";\n    for (auto& num : solution.searchRange(nums2, target2)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> nums3 = [0];\n    int target3 = 0;\n    cout << \"Test Case 3: \";\n    for (auto& num : solution.searchRange(nums3, target3)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "35": "```\n#include <iostream>\n#include <vector>\n\nint searchInsert(std::vector<int>& nums, int target) {\n    if (nums.empty()) return 0;\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) return mid;\n        else if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return left;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 3, 5, 6};\n    int target1 = 5; \n    int result1 = searchInsert(nums1, target1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> nums2 = {1, 3, 5, 6};\n    int target2 = 7;\n    int result2 = searchInsert(nums2, target2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> nums3 = [0, 1];\n    int target3 = 0; \n    int result3 = searchInsert(nums3, target3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "36": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        for (int i = 0; i < 9; i++) {\n            vector<bool> row(9, true);\n            vector<bool> col(9, true);\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] != '.' && !row[j - i % 3]) return false;\n                if (board[i][j] != '.' && !col[j]) return false;\n                if (board[i][j] == board[(i/3)*3 + j%3][0]) return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<char>> board1 = {\n        {'5','1','7','6','0','9','8','3','2'},\n        {'6','0','1','9','5','4','2','8','3'},\n        {'4','9','6','7','8','3','0','2','1'},\n        {'2','8','4','1','9','7','5','6','0'},\n        {'9','7','1','3','2','4','6','8','5'},\n        {'7','6','0','4','1','3','9','5','2'},\n        {'1','2','5','9','8','6','3','4','7'},\n        {'8','4','3','2','5','1','6','7','9'},\n        {'6','9','2','8','3','4','1','5','0'}\n    };\n    cout << (solution.isValidSudoku(board1) ? \"Valid Sudoku\" : \"Invalid Sudoku\") << endl;\n\n    // Test Case 2\n    vector<vector<char>> board2 = {\n        {'.' , '.' , '.' , '.' , '.' , '.' , '.' , '.' , '.'},\n        {'.', '8', '.', '.', '.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.', '.', '.', '.', '.'},\n        {'.', '.', '3', '.', '.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.', '.', '.', '.', '.'},\n        {'8', '.', '.', '.', '.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.', '.', '.', '.', '.'},\n        {'.', '.', '.', '.', '.', '.', '.', '.', '8'}\n    };\n    cout << (solution.isValidSudoku(board2) ? \"Valid Sudoku\" : \"Invalid Sudoku\") << endl;\n\n    // Test Case 3\n    vector<vector<char>> board3 = {\n        {'5','1','7','6','0','9','8','3','.'},\n        {'.', '9', '.', '.', '.' , '4', '2', '8', '3'},\n        {'.', '.', '.', '7', '8', '3', '0', '2', '1'},\n        {'2', '8', '.', '1', '9', '7', '5', '6', '.'},\n        {'.', '7', '1', '3', '2', '4', '6', '8', '5'},\n        {'7', '6', '.', '4', '1', '3', '9', '5', '2'},\n        {'.', '2', '5', '9', '8', '6', '3', '4', '7'},\n        {'8', '4', '3', '2', '5', '1', '6', '7', '.'},\n        {'.', '9', '2', '8', '3', '.', '1', '5', '0'}\n    };\n    cout << (solution.isValidSudoku(board3) ? \"Valid Sudoku\" : \"Invalid Sudoku\") << endl;\n\n    return 0;\n}\n```",
  "38": "```\n#include <iostream>\n#include <string>\n\nstd::string countAndSay(int n) {\n    if (n == 1) return \"1\";\n    std::string res = countAndSay(n - 1);\n    int i = 0, j;\n    while ((j = res.find_first_of(\"0123456789\")) != std::string::npos) {\n        int count = 1;\n        while (j + 1 < res.size() && res[j] == res[j+1]) {\n            ++j;\n            ++count;\n        }\n        if (count > 1)\n            res.replace(i, j - i + 1, std::to_string(count) + res.substr(i, j - i));\n        else\n            res.insert(i++, 1, res[j]);\n    }\n    return res;\n}\n\nint main() {\n    std::cout << countAndSay(1) << std::endl; // \"1\"\n    std::cout << countAndSay(4) << std::endl; // \"1211\"\n    std::cout << countAndSay(6) << std::endl; // \"111221\"\n\n    return 0;\n}\n```",
  "37": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isValid(vector<vector<int>>& board, int row, int col) {\n        for (int i = 0; i < 9; i++) {\n            if (board[row][i] == col + 1)\n                return false;\n        }\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == col + 1)\n                return false;\n        }\n        int startRow = row - row % 3;\n        int startCol = col - col % 3;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[startRow + i][startCol + j] == col + 1)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    void solveSudoku(vector<vector<int>>& board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == 0) {\n                    for (int k = 1; k <= 9; k++) {\n                        if (isValid(board, i, j)) {\n                            board[i][j] = k;\n                            solveSudoku(board);\n                            if (!board[i][j])\n                                return;\n                        }\n                    }\n                    board[i][j] = 0;\n                    return;\n                }\n            }\n        }\n    }\n\n    bool solve(vector<vector<int>>& board) {\n        solveSudoku(board);\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == 0)\n                    return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> board1 = {\n        {5,3,4,6,7,8,9,1,2},\n        {6,7,8,9,1,2,3,4,5},\n        {1,9,8,3,4,5,6,7,2},\n        {8,5,9,7,6,3,2,1,4},\n        {4,2,6,8,5,1,7,3,9},\n        {7,1,3,4,2,9,8,5,6},\n        {9,6,1,5,3,4,2,8,7},\n        {2,8,4,1,6,7,5,9,3},\n        {3,4,5,2,8,9,1,6,7}\n    };\n    if (solution.solve(board1)) {\n        for (const auto& row : board1) {\n            for (int val : row) {\n                cout << val << \" \";\n            }\n            cout << endl;\n        }\n    } else {\n        cout << \"No solution exists.\" << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> board2 = {\n        {0,1,0},\n        {2,3,4},\n        {5,6,7}\n    };\n    if (solution.solve(board2)) {\n        for (const auto& row : board2) {\n            for (int val : row) {\n                cout << val << \" \";\n            }\n            cout << endl;\n        }\n    } else {\n        cout << \"No solution exists.\" << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> board3 = {\n        {0,0,0},\n        {8,9,7},\n        {6,5,4}\n    };\n    if (solution.solve(board3)) {\n        for (const auto& row : board3) {\n            for (int val : row) {\n                cout << val << \" \";\n            }\n            cout << endl;\n        }\n    } else {\n        cout << \"No solution exists.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "39": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<std::vector<int>> combinationSum(std::vector<int>& candidates, int target) {\n        std::sort(candidates.begin(), candidates.end());\n        std::vector<std::vector<int>> result;\n        findCombinations(result, std::vector<int>(), candidates, target);\n        return result;\n    }\n\nprivate:\n    void findCombinations(std::vector<std::vector<int>>& combinations, std::vector<int>& currentCombination, const std::vector<int>& candidates, int remaining) {\n        if (remaining == 0) {\n            combinations.push_back(currentCombination);\n            return;\n        }\n        for (int i = 0; i < candidates.size(); ++i) {\n            if (i > 0 && candidates[i] == candidates[i - 1]) continue;\n            if (candidates[i] > remaining) break;\n            currentCombination.push_back(candidates[i]);\n            findCombinations(combinations, currentCombination, std::vector<int>(candidates.begin() + i, candidates.end()), remaining - candidates[i]);\n            currentCombination.pop_back();\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    int target = 2;\n    std::vector<int> candidates1 = {2};\n    std::vector<std::vector<int>> result1 = solution.combinationSum(candidates1, target);\n    for (const auto& combination : result1) {\n        for (int num : combination) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    target = 4;\n    std::vector<int> candidates2 = {2, 3, 6, 7};\n    std::vector<std::vector<int>> result2 = solution.combinationSum(candidates2, target);\n    for (const auto& combination : result2) {\n        for (int num : combination) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    target = 9;\n    std::vector<int> candidates3 = {1, 2, 3, 4};\n    std::vector<std::vector<int>> result3 = solution.combinationSum(candidates3, target);\n    for (const auto& combination : result3) {\n        for (int num : combination) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "40": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        sort(candidates.begin(), candidates.end());\n        vector<vector<int>> result;\n        backtracking(result, vector<int>(), candidates, 0, target);\n        return result;\n    }\n\n    void backtracking(vector<vector<int>>& result, vector<int>& path, const vector<int>& candidates, int start, int remain) {\n        if (remain < 0) {\n            return;\n        }\n        else if (remain == 0) {\n            result.push_back(path);\n            return;\n        }\n        for (int i = start; i < candidates.size(); i++) {\n            if (i > start && candidates[i] == candidates[i - 1]) {\n                continue;\n            }\n            if (candidates[i] > remain) {\n                break;\n            }\n            path.push_back(candidates[i]);\n            backtracking(result, path, candidates, i + 1, remain - candidates[i]);\n            path.pop_back();\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> candidates1 = {10, 1, 2, 7, 6, 1};\n    int target1 = 8;\n    cout << \"Test Case 1: \";\n    for (const auto& combination : solution(combinationSum2(candidates1, target1))) {\n        for (int num : combination) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<int> candidates2 = {0, 0};\n    int target2 = 2;\n    cout << \"\\nTest Case 2: \";\n    for (const auto& combination : solution(combinationSum2(candidates2, target2))) {\n        for (int num : combination) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<int> candidates3 = {1, 2};\n    int target3 = 3;\n    cout << \"\\nTest Case 3: \";\n    for (const auto& combination : solution(combinationSum2(candidates3, target3))) {\n        for (int num : combination) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "41": "```\n#include <iostream>\n#include <vector>\n\nint firstMissingPositive(std::vector<int>& nums) {\n    int n = nums.size();\n    for (int i = 0; i < n; ++i) {\n        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n            std::swap(nums[i], nums[nums[i] - 1]);\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != i + 1) {\n            return i + 1;\n        }\n    }\n\n    return n + 1;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 0};\n    int result1 = firstMissingPositive(nums1);\n    std::cout << \"Test Case 1: \" << result1 << std::endl;\n\n    std::vector<int> nums2 = {3, 4, -1, 1};\n    int result2 = firstMissingPositive(nums2);\n    std::cout << \"Test Case 2: \" << result2 << std::endl;\n\n    std::vector<int> nums3 = {7, 8, 9, 11, 12];\n    int result3 = firstMissingPositive(nums3);\n    std::cout << \"Test Case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "42": "```\n#include <iostream>\n#include <vector>\n\nint trap(std::vector<int>& height) {\n    int n = height.size();\n    if (n == 0) return 0;\n\n    int leftMax = 0, rightMax = 0, water = 0;\n    int left = 0, right = n - 1;\n\n    while (left <= right) {\n        if (height[left] < height[right]) {\n            if (height[left] >= leftMax)\n                leftMax = height[left];\n            else\n                water += leftMax - height[left];\n            left++;\n        } else {\n            if (height[right] >= rightMax)\n                rightMax = height[right];\n            else\n                water += rightMax - height[right];\n            right--;\n        }\n    }\n\n    return water;\n}\n\nint main() {\n    // Test case 1:\n    std::vector<int> height1 = {0,1,0,2,1,0,1,3,2,1,2,1};\n    std::cout << \"Trapped rainwater in test case 1: \" << trap(height1) << std::endl;\n\n    // Test case 2:\n    std::vector<int> height2 = {4,2,0,3,2,5};\n    std::cout << \"Trapped rainwater in test case 2: \" << trap(height2) << std::endl;\n\n    // Test case 3:\n    std::vector<int> height3 = {1,8,6,2,5,4,8,3,7};\n    std::cout << \"Trapped rainwater in test case 3: \" << trap(height3) << std::endl;\n\n    return 0;\n}",
  "43": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string multiply(std::string num1, std::string num2) {\n        int m = num1.length(), n = num2.length();\n        std::string res(m + n, '0');\n        \n        for (int i = m - 1; i >= 0; --i)\n            for (int j = n - 1; j >= 0; --j) {\n                int mul = (num1[i] - '0') * (num2[j] - '0');\n                int pos = i + j;\n                \n                while (mul > 0) {\n                    res[pos] += mul % 10;\n                    mul /= 10;\n                    pos++;\n                }\n            }\n        \n        while (res.length() > 1 && res.back() == '0')\n            res.pop_back();\n        \n        if (res.empty())\n            return \"0\";\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << solution.multiply(\"2\", \"3\") << std::endl; // output: \"6\"\n    std::cout << solution.multiply(\"123\", \"456\") << std::endl; // output: \"56088\"\n    std::cout << solution.multiply(\"0\", \"10\") << std::endl; // output: \"0\"\n\n    return 0;\n}\n```",
  "44": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        if (p.empty()) return s.empty();\n        \n        bool firstMatch = (!s.empty() && (s[0] == p[0] || p[0] == '.'));\n\n        if (p.length() >= 2 && p[1] == '*') {\n            return (isMatch(s, p.substr(2)) || (firstMatch && isMatch(s.substr(1), p)));\n        } else {\n            return firstMatch && isMatch(s.substr(1), p.substr(1));\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << solution.isMatch(\"aa\", \"a\") << endl;  // false\n    cout << solution.isMatch(\"aa\", \"a*\") << endl; // true\n    cout << solution.isMatch(\"cb\", \"?a\") << endl;  // true\n    \n    return 0;\n}\n```",
  "45": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int jump(vector<int>& nums) {\n        int n = nums.size();\n        if (n <= 1) return n;\n        \n        vector<int> dp(n, -1);\n        dp[0] = 0;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i && j + nums[j] >= i; j++) {\n                if (dp[j] != -1) {\n                    dp[i] = max(dp[i], min(i, j + nums[j]) - j);\n                }\n            }\n        }\n        \n        return dp[n-1];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> test1 = {2,3,1,1,4};\n    cout << \"Test case 1: \" << solution.jump(test1) << endl; // Output: 2\n    \n    // Test case 2\n    vector<int> test2 = {2,1,1,1,0};\n    cout << \"Test case 2: \" << solution.jump(test2) << endl; // Output: 2\n    \n    // Test case 3\n    vector<int> test3 = {0};\n    cout << \"Test case 3: \" << solution.jump(test3) << endl; // Output: 0\n    \n    return 0;\n}\n```",
  "46": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> result;\n        backtrack(result, {}, nums);\n        return result;\n    }\n    \nprivate:\n    void backtrack(vector<vector<int>>& result, vector<int>& path, vector<int>& nums) {\n        if (path.size() == nums.size()) {\n            result.push_back(path);\n            return;\n        }\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (find(path.begin(), path.end(), nums[i]) != path.end()) continue;\n            \n            path.push_back(nums[i]);\n            backtrack(result, path, nums);\n            path.pop_back();\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> nums1 = {1, 2, 3};\n    vector<vector<int>> result1 = solution.permute(nums1);\n    for (const auto& perm : result1) {\n        for (int num : perm) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n    \n    // Test case 2\n    vector<int> nums2 = {0, 1};\n    vector<vector<int>> result2 = solution.permute(nums2);\n    for (const auto& perm : result2) {\n        for (int num : perm) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n    \n    // Test case 3\n    vector<int> nums3 = {1};\n    vector<vector<int>> result3 = solution.permute(nums3);\n    for (const auto& perm : result3) {\n        for (int num : perm) {\n            cout << num << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n```",
  "47": "```\n#include <iostream>\n#include <vector>\n\nvoid backtrack(std::vector<int>& nums, std::vector<std::vector<int>>& result, int start) {\n    if (start == nums.size() - 1)\n        result.push_back(nums);\n    else {\n        for (int i = start; i < nums.size(); i++) {\n            if (i > start && nums[i] == nums[start])\n                continue;\n            std::swap(nums[i], nums[start]);\n            backtrack(nums, result, start + 1);\n            std::swap(nums[i], nums[start]);\n        }\n    }\n}\n\nstd::vector<std::vector<int>> permuteUnique(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> result;\n    backtrack(nums, result, 0);\n    return result;\n}\n\nint main() {\n    int testCases = 3;\n    \n    // Test Case 1\n    std::vector<int> testCase1 = {1, 1, 2};\n    std::vector<std::vector<int>> result1 = permuteUnique(testCase1);\n    for (const auto& permutation : result1) {\n        for (int num : permutation)\n            std::cout << num << \" \";\n        std::cout << \"\\n\";\n    }\n    \n    // Test Case 2\n    std::vector<int> testCase2 = {3, 3, 1, 3};\n    std::vector<std::vector<int>> result2 = permuteUnique(testCase2);\n    for (const auto& permutation : result2) {\n        for (int num : permutation)\n            std::cout << num << \" \";\n        std::cout << \"\\n\";\n    }\n    \n    // Test Case 3\n    std::vector<int> testCase3 = {1, 2};\n    std::vector<std::vector<int>> result3 = permuteUnique(testCase3);\n    for (const auto& permutation : result3) {\n        for (int num : permutation)\n            std::cout << num << \" \";\n        std::cout << \"\\n\";\n    }\n    \n    return 0;\n}\n```",
  "48": "```\n#include <iostream>\n#include <vector>\n\nvoid rotate(std::vector<std::vector<int>>& matrix) {\n    int n = matrix.size();\n    for (int i = 0; i < n / 2; ++i) {\n        for (int j = i; j < n - i - 1; ++j) {\n            int temp = matrix[i][j];\n            matrix[i][j] = matrix[n - 1 - j][i];\n            matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j];\n            matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i];\n            matrix[j][n - 1 - i] = temp;\n        }\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix1 = {{1, 2}, {3, 4}};\n    rotate(matrix1);\n    for (const auto& row : matrix1) {\n        for (int num : row) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    std::vector<std::vector<int>> matrix2 = {{5, 6, 7}, {8, 9, 10}, {11, 12, 13}};\n    rotate(matrix2);\n    for (const auto& row : matrix2) {\n        for (int num : row) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    std::vector<std::vector<int>> matrix3 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    rotate(matrix3);\n    for (const auto& row : matrix3) {\n        for (int num : row) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```",
  "49": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> anagrams;\n        for (const string& s : strs) {\n            string sorted = s;\n            sort(sorted.begin(), sorted.end());\n            anagrams[sorted].push_back(s);\n        }\n        return vector<vector<string>>(anagrams.begin(), anagrams.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> strs1 = {\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"};\n    vector<vector<string>> result1 = solution.groupAnagrams(strs1);\n    for (const auto& anagram : result1) {\n        cout << \"[\";\n        for (const auto& s : anagram) {\n            cout << \"\\\"\" << s << \"\\\" \";\n        }\n        cout << \"]\" << endl;\n    }\n\n    // Test case 2\n    vector<string> strs2 = {\"a\"};\n    vector<vector<string>> result2 = solution.groupAnagrams(strs2);\n    for (const auto& anagram : result2) {\n        cout << \"[\";\n        for (const auto& s : anagram) {\n            cout << \"\\\"\" << s << \"\\\" \";\n        }\n        cout << \"]\" << endl;\n    }\n\n    // Test case 3\n    vector<string> strs3 = {\"\", \"\", \"\"};\n    vector<vector<string>> result3 = solution.groupAnagrams(strs3);\n    for (const auto& anagram : result3) {\n        cout << \"[\";\n        for (const auto& s : anagram) {\n            cout << \"\\\"\" << s << \"\\\" \";\n        }\n        cout << \"]\" << endl;\n    }\n\n    return 0;\n}\n```",
  "50": "```\n#include <iostream>\nusing namespace std;\n\ndouble myPow(double x, int n) {\n    if (n == 0) return 1;\n    if (n < 0) return 1 / myPow(x, -n);\n    if (n % 2)\n        return x * myPow(x, n-1);\n    else\n        return myPow(x*x, n/2);\n}\n\nint main() {\n    cout << fixed << setprecision(5);\n    cout << \"Test case 1: \" << myPow(2.0, 3) << endl; // Expected output: 8.00000\n    cout << \"Test case 2: \" << myPow(4.0, -2) << endl; // Expected output: 0.06250\n    cout << \"Test case 3: \" << myPow(5.0, 1) << endl; // Expected output: 5.00000\n    return 0;\n}\n```",
  "51": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        vector<vector<string>> res;\n        vector<string> board(n, string(n, '.'));\n\n        function<void(int)> backtrack = [&](int row) {\n            if (row == n) {\n                res.push_back(vector<string>(board));\n                return;\n            }\n\n            for (int col = 0; col < n; ++col) {\n                bool isValid = true;\n\n                for (int i = 0; i < row; ++i) {\n                    int preRowCol = -1, curRowCol = -1;\n                    for (int j = 0; j < n; ++j) {\n                        if (board[i][j] == '.') preRowCol = i;\n                        else curRowCol = i;\n\n                        if (preRowCol != -1 && curRowCol != -1 &&\n                            abs(curRowCol - row) == abs(preRowCol - i)) {\n                            isValid = false; break;\n                        }\n                    }\n\n                    if (!isValid) break;\n                }\n\n                if (isValid) {\n                    for (int j = 0; j < n; ++j)\n                        board[row][j] = (col == j) ? 'Q' : '.';\n\n                    backtrack(row + 1);\n                }\n            }\n        };\n\n        backtrack(0);\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1: N = 4\n    vector<vector<string>> result1 = solution.solveNQueens(4);\n    for (const auto& row : result1[0]) {\n        cout << row << endl;\n    }\n\n    // Test case 2: N = 3\n    vector<vector<string>> result2 = solution.solveNQueens(3);\n    for (const auto& row : result2[0]) {\n        cout << row << endl;\n    }\n\n    // Test case 3: N = 1\n    vector<vector<string>> result3 = solution.solveNQueens(1);\n    for (const auto& row : result3[0]) {\n        cout << row << endl;\n    }\n}\n```",
  "52": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int totalNQueens(int n) {\n        int count = 0;\n        std::vector<std::vector<int>> board(n, std::vector<int>(n, 0));\n        for (int i = 0; i < n; i++) {\n            placeQueen(board, i, 0);\n            if (isSafe(board)) {\n                count++;\n            }\n            clearBoard(board);\n        }\n        return count;\n    }\n\nprivate:\n    bool isSafe(std::vector<std::vector<int>>& board) {\n        int n = board.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == 1) {\n                    // Check left and right\n                    for (int k = i - 1; k >= 0; k--) {\n                        if (board[k][j] == 1) return false;\n                    }\n                    for (int k = i + 1; k < n; k++) {\n                        if (board[k][j] == 1) return false;\n                    }\n                    // Check up and down\n                    for (int k = j - 1; k >= 0; k--) {\n                        if (board[i][k] == 1) return false;\n                    }\n                    for (int k = j + 1; k < n; k++) {\n                        if (board[i][k] == 1) return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    void placeQueen(std::vector<std::vector<int>>& board, int i, int j) {\n        board[i][j] = 1;\n    }\n\n    void clearBoard(std::vector<std::vector<int>>& board) {\n        for (int i = 0; i < board.size(); i++) {\n            for (int j = 0; j < board.size(); j++) {\n                board[i][j] = 0;\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int n1 = 4;\n    std::cout << \"For N = \" << n1 << \": \" << solution.totalNQueens(n1) << std::endl;\n\n    int n2 = 3;\n    std::cout << \"For N = \" << n2 << \": \" << solution.totalNQueens(n2) << std::endl;\n\n    int n3 = 5;\n    std::cout << \"For N = \" << n3 << \": \" << solution.totalNQueens(n3) << std::endl;\n\n    return 0;\n}",
  "53": "```\n#include <iostream>\n#include <vector>\n\nint maxSubArray(std::vector<int>& nums) {\n    int maxSum = nums[0];\n    int currSum = nums[0];\n\n    for (int i = 1; i < nums.size(); i++) {\n        if (currSum <= 0) {\n            currSum = nums[i];\n        } else {\n            currSum += nums[i];\n        }\n        maxSum = std::max(maxSum, currSum);\n    }\n\n    return maxSum;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1{-2,1,-3,4,-1};\n    int result1 = maxSubArray(test1);\n    if (result1 == 6) {\n        std::cout << \"Test case 1 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed: expected 6, got \" << result1 << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> test2{0,-3,-2,8,-4};\n    int result2 = maxSubArray(test2);\n    if (result2 == 8) {\n        std::cout << \"Test case 2 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed: expected 8, got \" << result2 << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> test3{1};\n    int result3 = maxSubArray(test3);\n    if (result3 == 1) {\n        std::cout << \"Test case 3 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed: expected 1, got \" << result3 << std::endl;\n    }\n\n    return 0;\n}",
  "54": "```\n#include <iostream>\n#include <vector>\n\nvoid printMatrix(const std::vector<std::vector<int>>& matrix) {\n    for (const auto& row : matrix) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nstd::vector<int> spiralOrder(std::vector<std::vector<int>>& matrix) {\n    int R = matrix.size();\n    if (R == 0) return {};\n    int C = matrix[0].size();\n    vector<vector<int>> result(R * C, 0);\n    int index = 0;\n    int top = 0, bottom = R - 1, left = 0, right = C - 1;\n\n    while (top <= bottom && left <= right) {\n        for (int i = left; i <= right; ++i)\n            result[index++] = matrix[top][i];\n\n        top++;\n\n        for (int i = top; i <= bottom; ++i)\n            result[index++] = matrix[i][right];\n\n        right--;\n\n        if (top <= bottom) {\n            for (int i = right; i >= left; --i)\n                result[index++] = matrix[bottom][i];\n\n            bottom--;\n        }\n\n        if (left <= right) {\n            for (int i = bottom; i > top - 1; --i)\n                result[index++] = matrix[i][left];\n\n            left++;\n        }\n    }\n\n    return vector<int>(result.begin(), result.end());\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    std::cout << \"Matrix 1: \";\n    printMatrix(spiralOrder(matrix1));\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> matrix2 = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n    std::cout << \"Matrix 2: \";\n    printMatrix(spiralOrder(matrix2));\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> matrix3 = {{1}};\n    std::cout << \"Matrix 3: \";\n    printMatrix(spiralOrder(matrix3));\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "55": "```\n#include <iostream>\n#include <vector>\n\nbool canJump(std::vector<int>& nums) {\n    int maxReach = 0;\n    for (int i = 0; i <= maxReach; i++) {\n        if (i > maxReach) return false;\n        maxReach = std::max(maxReach, i + nums[i]);\n    }\n    return true;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {2,3,1,1,4};\n    std::cout << \"Test 1: \" << (canJump(test1) ? \"Pass\" : \"Fail\") << std::endl;\n\n    // Test case 2\n    std::vector<int> test2 = {3,2,1,0,4};\n    std::cout << \"Test 2: \" << (canJump(test2) ? \"Pass\" : \"Fail\") << std::endl;\n\n    // Test case 3\n    std::vector<int> test3 = {2,5,0,0,4,1,2,2,1};\n    std::cout << \"Test 3: \" << (canJump(test3) ? \"Pass\" : \"Fail\") << std::endl;\n\n    return 0;\n}\n```",
  "56": "```\n#include <iostream>\n#include <vector>\n\nstruct Interval {\n    int start;\n    int end;\n};\n\nbool compareIntervals(const Interval& i1, const Interval& i2) {\n    return (i1.start < i2.start);\n}\n\nvoid mergeIntervals(std::vector<Interval>& intervals) {\n    if(intervals.size() <= 1)\n        return;\n\n    std::sort(intervals.begin(), intervals.end(), compareIntervals);\n\n    for(size_t i = 0; i < intervals.size(); ++i) {\n        if(i > 0 && intervals[i].start <= intervals[i-1].end) {\n            intervals[i-1].end = max(intervals[i-1].end, intervals[i].end);\n            intervals.erase(intervals.begin()+i);\n            --i;\n        }\n    }\n}\n\nint main() {\n    std::vector<Interval> intervals = {{1,3},{2,6},{8,10},{5,7},{6,8}};\n    mergeIntervals(intervals);\n\n    for(const auto& interval : intervals) {\n        std::cout << \"(\" << interval.start << \", \" << interval.end << \") \";\n    }\n    std::cout << \"\\n\";\n\n    intervals = {{1,4},{4,5}};\n    mergeIntervals(intervals);\n    \n    for(const auto& interval : intervals) {\n        std::cout << \"(\" << interval.start << \", \" << interval.end << \") \";\n    }\n    std::cout << \"\\n\";\n\n    intervals = {{0,3},{2,6},{8,10},{5,7},{6,8},{1,4}};\n    mergeIntervals(intervals);\n\n    for(const auto& interval : intervals) {\n        std::cout << \"(\" << interval.start << \", \" << interval.end << \") \";\n    }\n    std::cout << \"\\n\";\n\n    return 0;\n}\n```",
  "58": "```\n#include <iostream>\n#include <string>\n\nint lengthOfLastWord(std::string s) {\n    int len = s.size();\n    while (len > 0 && s[len - 1] == ' ') {\n        len--;\n    }\n    while (len > 0 && s[len - 1] != ' ') {\n        len--;\n    }\n    return len;\n}\n\nint main() {\n    std::cout << lengthOfLastWord(\"Hello World\") << std::endl; // Output: 5\n    std::cout << lengthOfLastWord(\"   fly me   to   the moon  \") << std::endl; // Output: 4\n    std::cout << lengthOfLastWord(\"luffy is still joy of coding \"); // Output: 6\n\n    return 0;\n}\n```",
  "57": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>> result;\n        int start = newInterval[0];\n        int end = newInterval[1];\n\n        for (int i = 0; i < intervals.size(); i++) {\n            if (intervals[i][1] < start) {\n                result.insert(result.end(), intervals.begin(), intervals.end());\n                break;\n            }\n            else if (end < intervals[i][0]) {\n                result.push_back(newInterval);\n                break;\n            }\n            else {\n                newInterval[0] = min(start, intervals[i][0]);\n                end = max(end, intervals[i][1]);\n            }\n        }\n\n        while (intervals.size() > 0 && intervals[0][0] <= start) {\n            if (end < intervals[0][1]) {\n                start = min(start, intervals[0][0]);\n                end = max(end, intervals[0][1]);\n                intervals.erase(intervals.begin());\n            }\n            else {\n                break;\n            }\n        }\n\n        result.push_back({start, end});\n        result.insert(result.end(), intervals.begin(), intervals.end());\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> intervals1 = {{1, 3}, {6, 9}};\n    vector<int> newInterval1 = {2, 5};\n    vector<vector<int>> result1 = solution.insert(intervals1, newInterval1);\n    for (const auto& interval : result1) {\n        cout << \"[\" << interval[0] << \", \" << interval[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> intervals2 = {{1, 2}, {3, 5}, {6, 7}, {8, 10}, {12, 16}};\n    vector<int> newInterval2 = {4, 8};\n    vector<vector<int>> result2 = solution.insert(intervals2, newInterval2);\n    for (const auto& interval : result2) {\n        cout << \"[\" << interval[0] << \", \" << interval[1] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> intervals3 = {{1, 5}};\n    vector<int> newInterval3 = {2, 3};\n    vector<vector<int>> result3 = solution.insert(intervals3, newInterval3);\n    for (const auto& interval : result3) {\n        cout << \"[\" << interval[0] << \", \" << interval[1] << \"] \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "60": "```\n#include <iostream>\n#include <vector>\n\nstd::string generateParenthesis(int n) {\n    if (n == 0) return \"\";\n    std::vector<std::string> ans;\n    ans.push_back(\"(\" + generateParenthesis(n - 1) + \")\");\n    for (int i = 0; i < n - 1; ++i)\n        ans.insert(ans.end(), generateParenthesis(i), generateParenthesis(n - 1 - i));\n    return *ans.begin();\n}\n\nint main() {\n    int testCases[] = {3, 4, 2};\n    for (int testCase : testCases) {\n        std::cout << \"Permutation sequence for \" << testCase << \": \" << generateParenthesis(testCase) << std::endl;\n    }\n    return 0;\n}\n```",
  "59": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int>> generateMatrix(int n) {\n    std::vector<std::vector<int>> matrix(n, std::vector<int>(n));\n    int top = 0, bottom = n - 1, left = 0, right = n - 1, dir = 0;\n    while (top <= bottom && left <= right) {\n        if (dir == 0) {\n            for (int i = left; i <= right; i++) {\n                matrix[top][i] = top * n + i;\n            }\n            top++;\n        } else if (dir == 1) {\n            for (int i = top; i <= bottom; i++) {\n                matrix[i][right] = (top + i - top) * n + right;\n            }\n            right--;\n        } else if (dir == 2) {\n            for (int i = right; i >= left; i--) {\n                matrix[bottom][i] = (top + bottom - top) * n + i;\n            }\n            bottom--;\n        } else {\n            for (int i = bottom; i > top; i--) {\n                matrix[i][left] = (top + i - top) * n + left;\n            }\n            left++;\n        }\n        if (dir == 0 || dir == 2) dir = 1;\n        else dir = 3;\n    }\n    return matrix;\n}\n\nint main() {\n    std::cout << \"Test Case 1:\" << std::endl;\n    int n1 = 3;\n    for (const auto& row : generateMatrix(n1)) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    std::cout << \"\\nTest Case 2:\" << std::endl;\n    int n2 = 4;\n    for (const auto& row : generateMatrix(n2)) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    std::cout << \"\\nTest Case 3:\" << std::endl;\n    int n3 = 5;\n    for (const auto& row : generateMatrix(n3)) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```",
  "61": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* rotateRight(ListNode* head, int k) {\n    if (!head || !head->next || k == 0)\n        return head;\n    \n    ListNode* newTail = head;\n    for (int i = 0; i < k - 1; ++i) {\n        newTail = newTail->next;\n        if (!newTail->next)\n            break;\n    }\n    \n    ListNode* newHead = newTail->next;\n    newTail->next = NULL;\n    \n    ListNode* curr = newHead;\n    while (curr->next)\n        curr = curr->next;\n    \n    curr->next = head;\n    return newHead;\n}\n\nint main() {\n    // Test case 1\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(4);\n    head1->next->next->next->next = new ListNode(5);\n\n    int k1 = 2;\n    ListNode* result1 = rotateRight(head1, k1);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test case 2\n    head1 = new ListNode(0);\n    head1->next = new ListNode(1);\n    head1->next->next = new ListNode(2);\n\n    int k2 = 4;\n    result1 = rotateRight(head1, k2);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test case 3\n    head1 = new ListNode(1);\n\n    int k3 = 5;\n    result1 = rotateRight(head1, k3);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "62": "```\n#include <iostream>\n#include <vector>\n\nint uniquePaths(int m, int n) {\n    std::vector<std::vector<int>> dp(m, std::vector<int>(n, 0));\n    for (int i = 1; i < m; ++i) {\n        dp[i][0] = 1;\n    }\n    for (int j = 1; j < n; ++j) {\n        dp[0][j] = 1;\n    }\n    for (int i = 1; i < m; ++i) {\n        for (int j = 1; j < n; ++j) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    return dp[m - 1][n - 1];\n}\n\nint main() {\n    std::cout << \"Test case 1: uniquePaths(3, 7) = \" << uniquePaths(3, 7) << std::endl;\n    std::cout << \"Test case 2: uniquePaths(3, 2) = \" << uniquePaths(3, 2) << std::endl;\n    std::cout << \"Test case 3: uniquePaths(1, 4) = \" << uniquePaths(1, 4) << std::endl;\n    return 0;\n}\n```",
  "64": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int m = grid.size();\n        if (m == 0) return 0;\n        int n = grid[0].size();\n\n        for (int i = 1; i < n; ++i) {\n            grid[0][i] += grid[0][i - 1];\n        }\n        for (int i = 1; i < m; ++i) {\n            grid[i][0] += grid[i - 1][0];\n        }\n\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1]);\n            }\n        }\n\n        return grid[m - 1][n - 1];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> grid1 = {{1,3,1},{1,5,1},{4,2,1}};\n    cout << \"Test case 1: \" << solution.minPathSum(grid1) << endl; \n\n    // Test case 2\n    vector<vector<int>> grid2 = {{2,3,3},{4,2,1},{6,7,3}};\n    cout << \"Test case 2: \" << solution.minPathSum(grid2) << endl; \n\n    // Test case 3\n    vector<vector<int>> grid3 = {{0,0,0},{0,15,0},{0,0,2}};\n    cout << \"Test case 3: \" << solution.minPathSum(grid3) << endl; \n}\n```",
  "63": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(std::vector<std::vector<int>>& obstacleGrid) {\n        int m = obstacleGrid.size();\n        if (m == 0) return 0;\n        int n = obstacleGrid[0].size();\n        \n        std::vector<std::vector<int>> dp(m, std::vector<int>(n));\n        \n        for (int i = 0; i < m; i++) {\n            if (obstacleGrid[i][0] == 1) break;\n            dp[i][0] = 1;\n        }\n        \n        for (int j = 0; j < n; j++) {\n            if (obstacleGrid[0][j] == 1) break;\n            dp[0][j] = 1;\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (obstacleGrid[i][j] == 1) continue;\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        \n        return dp[m - 1][n - 1];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::vector<int>> grid1 = {{0,0},{0,1}};\n    std::cout << \"Test case 1: \" << solution.uniquePathsWithObstacles(grid1) << std::endl; // Expected output: 1\n\n    std::vector<std::vector<int>> grid2 = {{0,0,0},{0,1,0},{0,0,0}};\n    std::cout << \"Test case 2: \" << solution.uniquePathsWithObstacles(grid2) << std::endl; // Expected output: 2\n\n    std::vector<std::vector<int>> grid3 = {{0,0,0,0},{1,0,0,0},{0,0,1,0},{0,0,0,2}};\n    std::cout << \"Test case 3: \" << solution.uniquePathsWithObstacles(grid3) << std::endl; // Expected output: 6\n\n    return 0;\n}\n```",
  "65": "```\n#include <iostream>\n#include <string>\n\nbool isNumber(const std::string& s) {\n    // Your solution here\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << (isNumber(\"0\") ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test case 2: \" << (isNumber(\"0.5\") ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test case 3: \" << (isNumber(\"123e+4\") ? \"True\" : \"False\") << std::endl;\n    return 0;\n}\n```",
  "66": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        for(int i = digits.size() - 1; i >= 0; --i){\n            if(digits[i] + 1 <= 9){\n                digits[i]++;\n                return digits;\n            } else {\n                digits[i] = 0;\n            }\n        }\n        vector<int> result(1, 1);\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> test1 = {1,2,3};\n    vector<int> expected1 = {1,2,4};\n    if(solution.plusOne(test1) != expected1){\n        cout << \"Test case 1 failed.\" << endl;\n    } else {\n        cout << \"Test case 1 passed.\" << endl;\n    }\n\n    vector<int> test2 = {4,3,2,9};\n    vector<int> expected2 = {4,3,3,0};\n    if(solution.plusOne(test2) != expected2){\n        cout << \"Test case 2 failed.\" << endl;\n    } else {\n        cout << \"Test case 2 passed.\" << endl;\n    }\n\n    vector<int> test3 = {9,9,9};\n    vector<int> expected3 = {1,0,0,0};\n    if(solution.plusOne(test3) != expected3){\n        cout << \"Test case 3 failed.\" << endl;\n    } else {\n        cout << \"Test case 3 passed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "67": "```\n#include <iostream>\n#include <string>\n\nstd::string addBinary(std::string a, std::string b) {\n    int i = a.size() - 1, j = b.size() - 1;\n    std::string result;\n    \n    while(i >= 0 || j >= 0) {\n        int sum = (i >= 0 ? a[i--] - '0' : 0);\n        sum += (j >= 0 ? b[j--] - '0' : 0);\n        \n        if(sum & 1)\n            result.push_back('1');\n        else\n            result.push_back('0');\n        \n        int carry = sum >> 1;\n        while(carry) {\n            if(i >= 0 && a[i] - '0' == 1)\n                i--;\n            if(j >= 0 && b[j] - '0' == 1)\n                j--;\n            \n            if(i >= 0 || j >= 0) {\n                sum = (i >= 0 ? a[i--] - '0' : 0);\n                sum += (j >= 0 ? b[j--] - '0' : 0);\n                \n                if(sum & 1)\n                    result.push_back('1');\n                else\n                    result.push_back('0');\n                \n                carry = sum >> 1;\n            }\n            else {\n                result.push_back('1');\n                break;\n            }\n        }\n    }\n    \n    reverse(result.begin(), result.end());\n    return result.empty() ? \"0\" : result[0] == '1' ? result.substr(1) : result;\n}\n\nint main() {\n    std::cout << addBinary(\"11\", \"1\") << std::endl;  // Output: 100\n    std::cout << addBinary(\"1010\", \"1100\") << std::endl;  // Output: 10010\n    std::cout << addBinary(\"1111\", \"1111\") << std::endl;  // Output: 11110\n    \n    return 0;\n}\n```",
  "68": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> justifyText(vector<string>& words, int maxWidth) {\n        vector<string> result;\n        int currLen = 0;\n        string currStr = \"\";\n        for (const auto& word : words) {\n            if (currLen + word.length() > maxWidth) {\n                while (currStr.size() < maxWidth) {\n                    char c = ' ';\n                    if (currStr.empty()) {\n                        c = word[0];\n                    }\n                    currStr += c;\n                }\n                result.push_back(currStr);\n                currStr = \"\";\n                currLen = 0;\n            }\n            currStr += word + \" \";\n            currLen += word.length() + 1;\n        }\n        if (!currStr.empty()) {\n            while (currStr.size() < maxWidth) {\n                char c = ' ';\n                if (currStr.empty()) {\n                    c = words[words.size()-1][0];\n                }\n                currStr += c;\n            }\n            result.push_back(currStr);\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<string> words1 = {\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"};\n    string expectedOutput1 = \"This    is    an example  of text justificatio\";\n    for (const auto& result : solution.justifyText(words1, 16)) {\n        cout << result << endl;\n        if (result == expectedOutput1) {\n            break;\n        }\n    }\n\n    vector<string> words2 = {\"Look\", \"for\", \"help\", \"with\", \"more\"};\n    string expectedOutput2 = \"Look     for   help  with more\";\n    for (const auto& result : solution.justifyText(words2, 14)) {\n        cout << result << endl;\n        if (result == expectedOutput2) {\n            break;\n        }\n    }\n\n    vector<string> words3 = {\"Words\", \"and\", \"worlds\"};\n    string expectedOutput3 = \"Words      and     worlds\";\n    for (const auto& result : solution.justifyText(words3, 7)) {\n        cout << result << endl;\n        if (result == expectedOutput3) {\n            break;\n        }\n    }\n\n    return 0;\n}\n```",
  "69": "```\n#include <iostream>\n#include <cmath>\n\nint mySqrt(int x) {\n    if (x == 0) return 0;\n    \n    int left = 1, right = x;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        long long sqMid = 1LL * mid * mid;\n        \n        if (sqMid == x) return mid;\n        if (sqMid > x) right = mid - 1;\n        else left = mid + 1;\n    }\n    \n    return right;\n}\n\nint main() {\n    std::cout << mySqrt(4) << std::endl; // Expected: 2\n    std::cout << mySqrt(8) << std::endl; // Expected: 2\n    std::cout << mySqrt(25) << std::endl; // Expected: 5\n    \n    return 0;\n}",
  "70": "```\n#include <iostream>\n#include <vector>\n\nint climbStairs(int n) {\n    if (n <= 2) return n;\n    std::vector<int> dp(n + 1, 0);\n    dp[1] = 1;\n    dp[2] = 2;\n    for (int i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    return dp[n];\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << climbStairs(2) << std::endl;\n    std::cout << \"Test case 2: \" << climbStairs(3) << std::endl;\n    std::cout << \"Test case 3: \" << climbStairs(4) << std::endl;\n    return 0;\n}\n```",
  "71": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::string simplifyPath(std::string path) {\n        std::stack<std::string> stack;\n        std::vector<std::string> components = split(path, '/');\n        for (const auto& component : components) {\n            if (component == \"..\") {\n                if (!stack.empty()) {\n                    stack.pop();\n                }\n            } else if (component != \".\" && !component.empty()) {\n                stack.push(component);\n            }\n        }\n        std::string result;\n        while (!stack.empty()) {\n            result = \"/\" + stack.top() + result;\n            stack.pop();\n        }\n        return result.length() == 0 ? \"/\" : result;\n    }\n\nprivate:\n    std::vector<std::string> split(const std::string& str, char ch) {\n        std::vector<std::string> tokens;\n        size_t pos = 0;\n        while ((pos = str.find(ch)) != std::string::npos) {\n            tokens.push_back(str.substr(0, pos));\n            str.erase(0, pos + 1);\n        }\n        if (!str.empty()) {\n            tokens.push_back(str);\n        }\n        return tokens;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::cout << \"Test case 1: \" << solution.simplifyPath(\"/a/./b/../../c/\") << std::endl;  // Output: /c\n\n    // Test case 2\n    std::cout << \"Test case 2: \" << solution.simplifyPath(\"/home//foo/\") << std::endl;  // Output: /home/foo\n\n    // Test case 3\n    std::cout << \"Test case 3: \" << solution.simplifyPath(\"/a/../../b/../c//\") << std::endl;  // Output: /c\n\n    return 0;\n}\n```",
  "72": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));\n        \n        for (int i = 0; i <= word1.size(); i++) {\n            for (int j = 0; j <= word2.size(); j++) {\n                if (i == 0) dp[i][j] = j;\n                else if (j == 0) dp[i][j] = i;\n                else if (word1[i - 1] == word2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;\n                }\n            }\n        }\n        \n        return dp[word1.size()][word2.size()];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string word1 = \"horse\";\n    string word2 = \"ros\";\n    cout << \"Test case 1: The edit distance is \" << solution.minDistance(word1, word2) << endl;\n\n    // Test case 2\n    word1 = \"intention\";\n    word2 = \"execution\";\n    cout << \"Test case 2: The edit distance is \" << solution.minDistance(word1, word2) << endl;\n\n    // Test case 3\n    word1 = \"\";\n    word2 = \"hello\";\n    cout << \"Test case 3: The edit distance is \" << solution.minDistance(word1, word2) << endl;\n\n    return 0;\n}\n```",
  "73": "```\n#include <iostream>\n#include <vector>\n\nvoid setZeroes(std::vector<std::vector<int>>& matrix) {\n    int m = matrix.size();\n    int n = matrix[0].size();\n\n    std::vector<bool> rows(m, false);\n    std::vector<bool> cols(n, false);\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (matrix[i][j] == 0) {\n                rows[i] = true;\n                cols[j] = true;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (rows[i] || cols[j]) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix1 = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\n    setZeroes(matrix1);\n    for (auto &row : matrix1) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> matrix2 = {{0, 0}, {1, 1}};\n    setZeroes(matrix2);\n    for (auto &row : matrix2) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> matrix3 = {{1, 0, 1}, {0, 1, 0}, {1, 0, 1}};\n    setZeroes(matrix3);\n    for (auto &row : matrix3) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "74": "```\n#include <iostream>\n#include <vector>\n\nbool searchMatrix(std::vector<std::vector<int>>& matrix, int target) {\n    if (matrix.empty() || matrix[0].empty()) return false;\n\n    int rows = matrix.size(), cols = matrix[0].size();\n    int startRow = 0, endRow = rows - 1;\n    int startCol = 0, endCol = cols - 1;\n\n    while (startRow <= endRow && startCol <= endCol) {\n        if (matrix[startRow][endCol] == target)\n            return true;\n        if (matrix[startRow][endCol] > target) {\n            endCol--;\n        } else {\n            if (matrix[startRow + 1][startCol] > target) {\n                for (int i = startCol; i <= endCol; i++) {\n                    if (matrix[startRow][i] == target)\n                        return true;\n                }\n                return false;\n            }\n            startRow++;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix1{{1, 3, 5, 7}, {10, 11, 16, 20},\n                                           {23, 30, 40, 50}};\n    int target1 = 3;    \n    if (searchMatrix(matrix1, target1)) {\n        std::cout << \"Target found in matrix.\" << std::endl;\n    } else {\n        std::cout << \"Target not found in matrix.\" << std::endl;\n    }\n\n    std::vector<std::vector<int>> matrix2{{1, 2}, {3, 4}};\n    int target2 = 5;    \n    if (searchMatrix(matrix2, target2)) {\n        std::cout << \"Target found in matrix.\" << std::endl;\n    } else {\n        std::cout << \"Target not found in matrix.\" << std::endl;\n    }\n\n    std::vector<std::vector<int>> matrix3{{1}};\n    int target3 = 0;    \n    if (searchMatrix(matrix3, target3)) {\n        std::cout << \"Target found in matrix.\" << std::endl;\n    } else {\n        std::cout << \"Target not found in matrix.\" << std::endl;\n    }\n\n    return 0;\n}",
  "75": "```\n#include <iostream>\n#include <vector>\n\nvoid sortColors(std::vector<int>& nums) {\n    int low = 0;\n    int mid = 0;\n    int high = nums.size() - 1;\n\n    while (mid <= high) {\n        switch (nums[mid]) {\n            case 0:\n                std::swap(nums[low], nums[mid]);\n                low++;\n                mid++;\n                break;\n            case 1:\n                mid++;\n                break;\n            case 2:\n                std::swap(nums[mid], nums[high]);\n                high--;\n                break;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> test1 = {0, 1};\n    std::vector<int> test2 = {2, 0, 2, 1, 1, 0};\n    std::vector<int> test3 = {2, 0, 1};\n\n    sortColors(test1);\n    for (int num : test1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    sortColors(test2);\n    for (int num : test2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    sortColors(test3);\n    for (int num : test3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "76": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        if (t.empty()) return \"\";\n        \n        int tLen = t.length();\n        int left = 0;\n        int minLen = INT_MAX;\n        string result = \"\";\n        \n        unordered_map<char, int> need;\n        unordered_map<char, int> window;\n        \n        for (char c : t) {\n            need[c]++;\n        }\n        \n        int formed = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            char c = s[right];\n            window[c]++;\n            \n            if (need.count(c) && window[c] == need[c]) {\n                formed++;\n            }\n            \n            while (right >= left && formed == tLen) {\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1;\n                    result = s.substr(left, minLen);\n                }\n                \n                char d = s[left++];\n                window[d]--;\n                \n                if (need.count(d) && window[d] < need[d]) {\n                    formed--;\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    string s1 = \"ABCBDAB\";\n    string t1 = \"BCC\";\n    cout << solution.minWindow(s1, t1) << endl;  // Output: \"BCB\"\n\n    string s2 = \"AAWEKMWXIT\";\n    string t2 = \"WEK\";\n    cout << solution.minWindow(s2, t2) << endl;  // Output: \"Wek\"\n\n    string s3 = \"bba\";\n    string t3 = \"ba\";\n    cout << solution.minWindow(s3, t3) << endl;  // Output: \"ba\"\n\n    return 0;\n}\n```",
  "77": "```\n#include <iostream>\n#include <vector>\n\nvoid backtrack(int start, std::vector<int>& current, std::vector<std::vector<int>>& result, int k, int n) {\n    if (current.size() == k) {\n        result.push_back(current);\n        return;\n    }\n    for (int i = start; i <= n; ++i) {\n        current.push_back(i);\n        backtrack(i + 1, current, result, k, n);\n        current.pop_back();\n    }\n}\n\nstd::vector<std::vector<int>> combine(int n, int k) {\n    std::vector<std::vector<int>> result;\n    std::vector<int> current;\n    backtrack(1, current, result, k, n);\n    return result;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << std::endl;\n    for (const auto& combination : combine(4, 2)) {\n        for (int num : combination) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    std::cout << \"\\nTest Case 2: \" << std::endl;\n    for (const auto& combination : combine(3, 1)) {\n        for (int num : combination) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    std::cout << \"\\nTest Case 3: \" << std::endl;\n    for (const auto& combination : combine(10, 5)) {\n        for (int num : combination) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```",
  "78": "```\n#include <iostream>\n#include <vector>\n\nvoid backtrack(std::vector<int>& result, std::vector<std::vector<int>>& allResult, int start, std::vector<int>& nums) {\n    for (int i = start; i < nums.size(); i++) {\n        result.push_back(nums[i]);\n        allResult.push_back(result);\n        backtrack(result, allResult, i + 1, nums);\n        result.pop_back();\n    }\n}\n\nstd::vector<std::vector<int>> subsets(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> allResult;\n    allResult.push_back({});\n\n    for (int i = 0; i < nums.size(); i++) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n        backtrack({}, allResult, i, nums);\n    }\n\n    return allResult;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 3};\n    std::cout << \"Test Case 1:\\n\";\n    for (const auto& subset : subsets(nums1)) {\n        for (int num : subset) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<int> nums2 = {0};\n    std::cout << \"\\nTest Case 2:\\n\";\n    for (const auto& subset : subsets(nums2)) {\n        for (int num : subset) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<int> nums3 = {1, 2};\n    std::cout << \"\\nTest Case 3:\\n\";\n    for (const auto& subset : subsets(nums3)) {\n        for (int num : subset) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "80": "```\n#include <iostream>\n#include <vector>\n\nint removeDuplicates(std::vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    int i = 0, j = 1;\n    while (j < nums.size()) {\n        if (nums[j] != nums[i]) {\n            i++;\n            nums[i] = nums[j];\n        }\n        j++;\n    }\n    \n    return i + 1;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 1, 2};\n    int result1 = removeDuplicates(nums1);\n    for (int i = 0; i < result1; i++) {\n        std::cout << nums1[i] << \" \";\n    }\n    std::cout << std::endl;\n    \n    std::vector<int> nums2 = {1, 1, 1, 2, 3};\n    int result2 = removeDuplicates(nums2);\n    for (int i = 0; i < result2; i++) {\n        std::cout << nums2[i] << \" \";\n    }\n    std::cout << std::endl;\n    \n    std::vector<int> nums3 = {1, 1, 2, 2, 2, 3};\n    int result3 = removeDuplicates(nums3);\n    for (int i = 0; i < result3; i++) {\n        std::cout << nums3[i] << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```",
  "79": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size();\n        if (m == 0) return false;\n        int n = board[0].size();\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dfs(board, word, i, j, 0)) return true;\n            }\n        }\n\n        return false;\n    }\n\nprivate:\n    bool dfs(vector<vector<char>>& board, string& word, int x, int y, int pos) {\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size()) return false;\n\n        if (pos == word.length()) return true;\n\n        char c = board[x][y];\n        if (c != word[pos]) return false;\n\n        char temp = board[x][y];\n        board[x][y] = ' ';\n\n        for (int k = 0; k < 8; ++k) {\n            int newX = x + dx[k], newY = y + dy[k];\n            if (newX >= 0 && newX < board.size() && newY >= 0 && newY < board[0].size()) {\n                if (dfs(board, word, newX, newY, pos + 1)) return true;\n            }\n        }\n\n        board[x][y] = temp;\n\n        return false;\n    }\n\npublic:\n    vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1},\n                                         {-1, -1}, {-1, 1}, {1, -1}, {1, 1}};\n\nprivate:\n    vector<string> words = {\"ABC\", \"DEF\", \"GHI\"};\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<char>> board1 = {{'A', 'B', 'C', 'E'}, {'S', 'F', 'C', 'D'}, {'E', 'H', 'G', 'I'}};\n    cout << \"Test case 1: \";\n    if (solution.exist(board1, \"ABC\")) {\n        cout << \"True\" << endl;\n    } else {\n        cout << \"False\" << endl;\n    }\n\n    // Test case 2\n    vector<vector<char>> board2 = {{'E', 'A', 'S', 'B'}, {'C', 'D', 'F', 'G'}, {'I', 'H', 'O', 'T'}};\n    cout << \"Test case 2: \";\n    if (solution.exist(board2, \"SEE\")) {\n        cout << \"True\" << endl;\n    } else {\n        cout << \"False\" << endl;\n    }\n\n    // Test case 3\n    vector<vector<char>> board3 = {{'L', 'O', 'W'}, {'J', 'A', 'V'}, {'I', 'M', 'S'}};\n    cout << \"Test case 3: \";\n    if (solution.exist(board3, \"LO\")) {\n        cout << \"True\" << endl;\n    } else {\n        cout << \"False\" << endl;\n    }\n\n    return 0;\n}\n```",
  "81": "```\n#include <iostream>\n#include <vector>\n\nint search(std::vector<int>& nums) {\n    int left = 0;\n    int right = nums.size() - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            return mid;\n        }\n\n        if (nums[left] <= nums[mid]) {\n            if (nums[left] <= target && target < nums[mid]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        } else {\n            if (nums[mid] < target && target <= nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    std::vector<int> nums1 = {2,5,6,0,0,1,2};\n    int target1 = 3;\n    std::cout << \"Test case 1: \" << search(nums1) << std::endl;\n\n    std::vector<int> nums2 = {2,5,6,0,0,1,2};\n    int target2 = 5;\n    std::cout << \"Test case 2: \" << search(nums2) << std::endl;\n\n    std::vector<int> nums3 = {1,3};\n    int target3 = 3;\n    std::cout << \"Test case 3: \" << search(nums3) << std::endl;\n\n    return 0;\n}\n```",
  "82": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if (head == NULL || head->next == NULL)\n            return head;\n\n        ListNode* curr = head;\n        while (curr != NULL && curr->next != NULL) {\n            if (curr->val == curr->next->val) {\n                ListNode* temp = curr->next;\n                while (temp != NULL && temp->val == curr->val) {\n                    temp = temp->next;\n                }\n                curr->next = temp;\n            } else {\n                curr = curr->next;\n            }\n        }\n\n        return head;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1:\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(3);\n    head1->next->next->next->next = new ListNode(4);\n\n    head1 = solution.deleteDuplicates(head1);\n\n    // Test Case 2:\n    ListNode* head2 = new ListNode(1);\n    head2->next = new ListNode(1);\n    head2->next->next = new ListNode(1);\n\n    head2 = solution.deleteDuplicates(head2);\n\n    // Test Case 3:\n    ListNode* head3 = new ListNode(1);\n    head3->next = new ListNode(2);\n\n    head3 = solution.deleteDuplicates(head3);\n\n    return 0;\n}\n```",
  "83": "```\n#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* deleteDuplicates(ListNode* head) {\n    if (head == NULL || head->next == NULL)\n        return head;\n\n    ListNode* curr = head;\n    while (curr != NULL && curr->next != NULL) {\n        if (curr->val == curr->next->val) {\n            ListNode* temp = curr->next;\n            curr->next = curr->next->next;\n            delete temp;\n        } else {\n            curr = curr->next;\n        }\n    }\n\n    return head;\n}\n\nint main() {\n    // Test Case 1:\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(1);\n    head1->next->next = new ListNode(3);\n\n    ListNode* head1_copy = deleteDuplicates(head1);\n    while (head1_copy != NULL) {\n        cout << head1_copy->val << \" \";\n        head1_copy = head1_copy->next;\n    }\n    cout << endl;\n\n    // Test Case 2:\n    head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n\n    head1_copy = deleteDuplicates(head1);\n    while (head1_copy != NULL) {\n        cout << head1_copy->val << \" \";\n        head1_copy = head1_copy->next;\n    }\n    cout << endl;\n\n    // Test Case 3:\n    head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(2);\n\n    head1_copy = deleteDuplicates(head1);\n    while (head1_copy != NULL) {\n        cout << head1_copy->val << \" \";\n        head1_copy = head1_copy->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "84": "```\n#include <iostream>\n#include <vector>\n\nint largestRectangleArea(std::vector<int>& heights) {\n    if (heights.empty()) return 0;\n\n    int maxArea = 0;\n    std::vector<int> indices(heights.size());\n    for (int i = 0; i < heights.size(); ++i) {\n        indices[i] = i;\n    }\n\n    for (int i = 0; i < heights.size() - 1; ++i) {\n        if (heights[i] >= heights[i + 1]) {\n            indices[i] = indices[i + 1];\n        }\n    }\n\n    int left, right;\n    for (int i = 0; i < heights.size(); ) {\n        left = i;\n        while (i + 1 < heights.size() && heights[indices[i]] >= heights[indices[i + 1]]) {\n            ++i;\n        }\n        right = i;\n        maxArea = std::max(maxArea, heights[indices[left]] * (right - left));\n    }\n\n    return maxArea;\n}\n\nint main() {\n    {\n        std::vector<int> heights = {2};\n        int result = largestRectangleArea(heights);\n        if (result != 2) {\n            std::cout << \"Test case 1 failed: expected \" << 2 << \", got \" << result << std::endl;\n            return 1;\n        }\n    }\n\n    {\n        std::vector<int> heights = {2, 3};\n        int result = largestRectangleArea(heights);\n        if (result != 4) {\n            std::cout << \"Test case 2 failed: expected \" << 4 << \", got \" << result << std::endl;\n            return 1;\n        }\n    }\n\n    {\n        std::vector<int> heights = {5, 6, 10};\n        int result = largestRectangleArea(heights);\n        if (result != 20) {\n            std::cout << \"Test case 3 failed: expected \" << 20 << \", got \" << result << std::endl;\n            return 1;\n        }\n    }\n\n    std::cout << \"All test cases passed.\" << std::endl;\n    return 0;\n}\n```",
  "85": "```\n#include <iostream>\n#include <vector>\n\nint maximalRectangle(std::vector<char>& matrix) {\n    if (matrix.empty()) return 0;\n    \n    int m = matrix.size();\n    int n = matrix[0].size();\n    std::vector<int> height(n, 0);\n    int maxArea = 0;\n\n    for (int i = 0; i < m; ++i) {\n        int start = 0, end = 0;\n        for (int j = 0; j < n; ++j) {\n            if (matrix[i][j] == '1') {\n                height[j]++;\n                end = j;\n            } else {\n                start = j + 1;\n                height[j] = 0;\n            }\n        }\n\n        for (int j = 0; j < n; ++j) {\n            maxArea = std::max(maxArea, minArea(height, j));\n        }\n    }\n\n    return maxArea;\n}\n\nint minArea(const std::vector<int>& height, int x) {\n    int area = 0;\n    for (int i = 0; i < height.size(); ++i) {\n        if (height[i] > height[x]) break;\n        area += height[i];\n    }\n    return area;\n}\n\nint main() {\n    std::vector<char> matrix1 = {'1','0','1','0','0'};\n    std::cout << \"Test case 1: \" << maximalRectangle(matrix1) << std::endl;\n\n    std::vector<char> matrix2 = {'0','1'};\n    std::cout << \"Test case 2: \" << maximalRectangle(matrix2) << std::endl;\n\n    std::vector<char> matrix3 = {'1','0','1','1','0','1','1'};\n    std::cout << \"Test case 3: \" << maximalRectangle(matrix3) << std::endl;\n    \n    return 0;\n}\n```",
  "87": "```\n#include <iostream>\n#include <string>\n\nbool isScramble(std::string s1, std::string s2) {\n    // your solution goes here\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test case 1: \" << (isScramble(\"abc\", \"cab\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 2: \" << (isScramble(\"aacc\", \"ccac\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 3: \" << (isScramble(\"aabbc\", \"ccbba\") ? \"Pass\" : \"Fail\") << std::endl;\n    return 0;\n}\n```",
  "86": "```\n#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* partition(ListNode* head, int x) {\n    if (head == NULL)\n        return NULL;\n\n    ListNode* beforeStart = NULL;\n    ListNode* afterStart = NULL;\n    ListNode* beforeEnd = NULL;\n    ListNode* afterEnd = NULL;\n\n    while (head != NULL) {\n        if (head->val < x) {\n            if (beforeStart == NULL) {\n                beforeStart = head;\n                beforeEnd = beforeStart;\n            } else {\n                beforeEnd->next = head;\n                beforeEnd = beforeEnd->next;\n            }\n        } else {\n            if (afterStart == NULL) {\n                afterStart = head;\n                afterEnd = afterStart;\n            } else {\n                afterEnd->next = head;\n                afterEnd = afterEnd->next;\n            }\n        }\n        head = head->next;\n    }\n\n    if (beforeStart != NULL && afterStart != NULL) {\n        beforeEnd->next = afterStart;\n        afterEnd->next = NULL;\n    } else {\n        return beforeStart == NULL ? afterStart : beforeStart;\n    }\n\n    return beforeStart;\n}\n\nint main() {\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(4);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(2);\n    head1->next->next->next->next = new ListNode(5);\n    head1->next->next->next->next->next = new ListNode(2);\n\n    ListNode* res1 = partition(head1, 3);\n    while (res1 != NULL) {\n        cout << res1->val << \" \";\n        res1 = res1->next;\n    }\n    cout << endl;\n\n    ListNode* head2 = new ListNode(1);\n    head2->next = new ListNode(2);\n    head2->next->next = new ListNode(3);\n\n    ListNode* res2 = partition(head2, 2);\n    while (res2 != NULL) {\n        cout << res2->val << \" \";\n        res2 = res2->next;\n    }\n    cout << endl;\n\n    ListNode* head3 = new ListNode(1);\n    head3->next = new ListNode(1);\n\n    ListNode* res3 = partition(head3, 1);\n    while (res3 != NULL) {\n        cout << res3->val << \" \";\n        res3 = res3->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "89": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<std::string> grayCode(int n) {\n        std::vector<std::string> result;\n        for (int i = 0; i <= n; i++) {\n            if (i > 0) {\n                for (int j = n; j > i; j--) {\n                    result.push_back(std::to_string((1 << j) + (1 << (j - 1))));\n                }\n            } else {\n                result.push_back(\"0\");\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::string> test1 = solution.grayCode(2);\n    for (const auto& gray : test1) {\n        std::cout << gray << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::string> test2 = solution.grayCode(3);\n    for (const auto& gray : test2) {\n        std::cout << gray << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::string> test3 = solution.grayCode(4);\n    for (const auto& gray : test3) {\n        std::cout << gray << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "88": "```\n#include <iostream>\n#include <vector>\n\nvoid merge(std::vector<int>& nums1, int m, std::vector<int>& nums2, int n) {\n    int i = m - 1;\n    int j = n - 1;\n    int k = m + n - 1;\n\n    while (i >= 0 && j >= 0) {\n        if (nums1[i] > nums2[j]) {\n            nums1[k--] = nums1[i--];\n        } else {\n            nums1[k--] = nums2[j--];\n        }\n    }\n\n    while (j >= 0) {\n        nums1[k--] = nums2[j--];\n    }\n}\n\nint main() {\n    std::vector<int> nums1_1 = {1, 2, 3, 0, 0, 0};\n    int m1 = 3;\n    std::vector<int> nums2_1 = {2, 5, 6};\n    int n1 = 3;\n\n    merge(nums1_1, m1, nums2_1, n1);\n\n    for (int num : nums1_1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums1_2 = {0};\n    int m2 = 0;\n    std::vector<int> nums2_2 = {1, 2];\n    int n2 = 2;\n\n    merge(nums1_2, m2, nums2_2, n2);\n\n    for (int num : nums1_2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums1_3 = {1, 2, 3, 4, 5};\n    int m3 = 5;\n    std::vector<int> nums2_3 = {6};\n    int n3 = 1;\n\n    merge(nums1_3, m3, nums2_3, n3);\n\n    for (int num : nums1_3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n```",
  "91": "```\n#include <iostream>\n#include <vector>\n\nint numDecodings(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        if (s[i - 1] != '0') {\n            dp[i] += dp[i - 1];\n        }\n        if (i >= 2 && s.substr(i - 2, 2) <= \"26\") {\n            dp[i] += dp[i - 2];\n        }\n    }\n    return dp[n];\n}\n\nint main() {\n    std::cout << numDecodings(\"1\") << std::endl;  // Output: 1\n    std::cout << numDecodings(\"6\") << std::endl;   // Output: 2\n    std::cout << numDecodings(\"12\") << std::endl;  // Output: 2\n    return 0;\n}\n```",
  "90": "```\n#include <iostream>\n#include <vector>\n\nvoid backtrack(std::vector<int>& nums, int start, std::vector<std::vector<int>>& result, std::vector<int>& subset) {\n    for (int i = start; i < nums.size(); ++i) {\n        subset.push_back(nums[i]);\n        result.push_back(subset);\n        backtrack(nums, i + 1, result, subset);\n        subset.pop_back();\n    }\n}\n\nstd::vector<std::vector<int>> subsetsWithDup(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    std::vector<std::vector<int>> result;\n    std::vector<int> subset;\n    backtrack(nums, 0, result, subset);\n    return result;\n}\n\nint main() {\n    int testNum = 3;\n\n    switch (testNum) {\n        case 1: {\n            std::vector<int> nums1 = {2, 2};\n            auto subsets = subsetsWithDup(nums1);\n\n            for (const auto& subset : subsets) {\n                for (int num : subset) {\n                    std::cout << num << \" \";\n                }\n                std::cout << \"\\n\";\n            }\n\n            break;\n        }\n        case 2: {\n            std::vector<int> nums2 = {0};\n            auto subsets2 = subsetsWithDup(nums2);\n\n            for (const auto& subset : subsets2) {\n                for (int num : subset) {\n                    std::cout << num << \" \";\n                }\n                std::cout << \"\\n\";\n            }\n\n            break;\n        }\n        case 3: {\n            std::vector<int> nums3 = {1, 2, 2};\n            auto subsets3 = subsetsWithDup(nums3);\n\n            for (const auto& subset : subsets3) {\n                for (int num : subset) {\n                    std::cout << num << \" \";\n                }\n                std::cout << \"\\n\";\n            }\n\n            break;\n        }\n    }\n\n    return 0;\n}\n```",
  "93": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        vector<string> result;\n        backtrack(s, \"\", 0, result);\n        return result;\n    }\n\nprivate:\n    void backtrack(string s, string path, int pos, vector<string>& result) {\n        if (path.size() > 3 || pos >= s.size()) {\n            return;\n        }\n        if (pos == s.size()) {\n            result.push_back(path.substr(0));\n            return;\n        }\n        for (int i = 1; i <= 3 && pos + i <= s.size(); ++i) {\n            string segment = s.substr(pos, i);\n            if (segment.size() > 1 && segment[0] == '0') break;\n            if (stoi(segment) <= 255) {\n                backtrack(s, path + segment + \".\", pos + i, result);\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> res = solution.restoreIpAddresses(\"25525511135\");\n    for (const auto& str : res) {\n        cout << str << endl;\n    }\n\n    res = solution.restoreIpAddresses(\"101023\");\n    for (const auto& str : res) {\n        cout << str << endl;\n    }\n\n    res = solution.restoreIpAddresses(\"12345678901\");\n    for (const auto& str : res) {\n        cout << str << endl;\n    }\n\n    return 0;\n}\n```",
  "92": "```\n#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* reverseBetween(ListNode* head, int left, int right) {\n    if (!head || left >= right) return head;\n\n    ListNode* prev = NULL;\n    ListNode* curr = head;\n    ListNode* tail = NULL;\n\n    for (int i = 1; i < left; i++) {\n        prev = curr;\n        curr = curr->next;\n    }\n\n    for (int i = 0; i < right - left; i++) {\n        tail = curr;\n        curr = curr->next;\n    }\n\n    ListNode* newTail = curr;\n    while (curr->next) {\n        curr = curr->next;\n    }\n    curr->next = NULL;\n\n    if (prev) prev->next = newTail;\n    else head = newTail;\n\n    return head;\n}\n\nint main() {\n    // Test case 1\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(4);\n    head1->next->next->next->next = new ListNode(5);\n\n    head1 = reverseBetween(head1, 2, 4);\n    for (ListNode* node = head1; node != NULL; node = node->next) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    ListNode* head2 = new ListNode(1);\n    head2->next = new ListNode(2);\n\n    head2 = reverseBetween(head2, 1, 2);\n    for (ListNode* node = head2; node != NULL; node = node->next) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    ListNode* head3 = new ListNode(1);\n\n    head3 = reverseBetween(head3, 1, 1);\n    for (ListNode* node = head3; node != NULL; node = node->next) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "94": "```\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        stack<TreeNode*> s;\n        while (root || !s.empty()) {\n            while (root) {\n                s.push(root);\n                root = root->left;\n            }\n            root = s.top();\n            s.pop();\n            result.push_back(root->val);\n            root = root->right;\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    cout << \"Test case 1: \";\n    for (int num : solution.inorderTraversal(root1)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(0);\n    root2->right = new TreeNode(2);\n    cout << \"Test case 2: \";\n    for (int num : solution.inorderTraversal(root2)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    TreeNode* root3 = nullptr;\n    cout << \"Test case 3: \";\n    for (int num : solution.inorderTraversal(root3)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
  "95": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        if (n == 0) return {};\n\n        return solve(1, n);\n    }\n\n    vector<TreeNode*> solve(int start, int end) {\n        vector<TreeNode*> res;\n        if (start > end) return {nullptr};\n\n        for (int i = start; i <= end; ++i) {\n            vector<TreeNode*> lefts = solve(start, i - 1);\n            vector<TreeNode*> rights = solve(i + 1, end);\n\n            for (TreeNode* left : lefts) {\n                for (TreeNode* right : rights) {\n                    TreeNode* node = new TreeNode(i);\n                    node->left = left;\n                    node->right = right;\n\n                    res.push_back(node);\n                }\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<TreeNode*> trees1 = solution.generateTrees(3);\n    for (TreeNode* tree : trees1) {\n        // Print or do something with the tree\n    }\n    \n    vector<TreeNode*> trees2 = solution.generateTrees(1);\n    for (TreeNode* tree : trees2) {\n        // Print or do something with the tree\n    }\n    \n    vector<TreeNode*> trees3 = solution.generateTrees(0);\n    if (!trees3.empty()) {\n        // Something went wrong, no empty list expected\n    }\n    \n    return 0;\n}\n```",
  "96": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numFactoredBinaryTrees(int n) {\n        if(n == 1) return 1;\n        long res = 0, curr = 0, total = 0;\n        for(long i = 1; i * i <= n; i++) {\n            if(n % (i * i) == 0) {\n                int x = n / (i * i);\n                long y = i, z = x;\n                while(y && z && (y % 2 == 0 || z % 2 == 0)) {\n                    y /= 2; \n                    z /= 2;\n                }\n                if((y == 1 || y % 4 == 3) && (z == 1 || z % 4 == 3))\n                    res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n    int n1 = 2;\n    int n2 = 4;\n    int n3 = 5;\n\n    cout << \"numFactoredBinaryTrees(\" << n1 << \") = \" << solution.numFactoredBinaryTrees(n1) << endl;\n    cout << \"numFactoredBinaryTrees(\" << n2 << \") = \" << solution.numFactoredBinaryTrees(n2) << endl;\n    cout << \"numFactoredBinaryTrees(\" << n3 << \") = \" << solution.numFactoredBinaryTrees(n3) << endl;\n\n    return 0;\n}\n```",
  "98": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root, long long min = LONG_MIN, long long max = LONG_MAX) {\n        if (!root) return true;\n\n        if (root->val >= max || root->val <= min)\n            return false;\n\n        return isValidBST(root->left, min, root->val) &&\n               isValidBST(root->right, root->val, max);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1: Valid Binary Search Tree\n    TreeNode* test1Root = new TreeNode(2);\n    test1Root->left = new TreeNode(1);\n    test1Root->right = new TreeNode(3);\n    cout << \"Test Case 1: \" << (solution.isValidBST(test1Root) ? \"True\" : \"False\") << endl;\n\n    // Test Case 2: Invalid Binary Search Tree (has duplicate values)\n    TreeNode* test2Root = new TreeNode(5);\n    test2Root->left = new TreeNode(3);\n    test2Root->right = new TreeNode(6);\n    cout << \"Test Case 2: \" << (solution.isValidBST(test2Root) ? \"True\" : \"False\") << endl;\n\n    // Test Case 3: Invalid Binary Search Tree (has values not in increasing order)\n    TreeNode* test3Root = new TreeNode(5);\n    test3Root->left = new TreeNode(7);\n    test3Root->right = new TreeNode(2);\n    cout << \"Test Case 3: \" << (solution.isValidBST(test3Root) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}",
  "97": "```\n#include <iostream>\n#include <vector>\n\nbool isInterleave(std::string s1, std::string s2, std::string s3) {\n    if ((s1.length() + s2.length()) != s3.length())\n        return false;\n    \n    bool dp[s1.length() + 1][s2.length() + 1];\n    for (int i = 0; i <= s1.length(); i++)\n        for (int j = 0; j <= s2.length(); j++)\n            dp[i][j] = false;\n    \n    dp[0][0] = true;\n    \n    for (int i = 1; i <= s1.length(); i++) {\n        dp[i][0] = dp[i-1][0] && (s1[i-1] == s3[i-1]);\n    }\n    \n    for (int j = 1; j <= s2.length(); j++) {\n        dp[0][j] = dp[0][j-1] && (s2[j-1] == s3[j-1]);\n    }\n    \n    for (int i = 1; i <= s1.length(); i++) {\n        for (int j = 1; j <= s2.length(); j++) {\n            if ((dp[i-1][j] && s1[i-1] == s3[i+j-1]) || \n                (dp[i][j-1] && s2[j-1] == s3[i+j-1]))\n                dp[i][j] = true;\n        }\n    }\n    \n    return dp[s1.length()][s2.length()];\n}\n\nint main() {\n    std::cout << std::boolalpha << isInterleave(\"aabcc\", \"dbbdc\", \"aadbbcbc\") << std::endl; //true\n    std::cout << std::boolalpha << isInterleave(\"aabcc\", \"dbbcd\", \"aadbbbdc\") << std::endl; //false\n    std::cout << std::boolalpha << isInterleave(\"a\", \"b\", \"aaab\") << std::endl; //true\n\n    return 0;\n}\n```",
  "100": "```\n#include <iostream>\n#include \"TreeNode.h\"\n\nbool isSameTree(TreeNode* p, TreeNode* q) {\n    if (!p && !q) return true;\n    if (p && q && p->val == q->val) \n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    return false;\n}\n\nint main() {\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(3);\n\n    std::cout << (isSameTree(root1, root2) ? \"True\" : \"False\") << std::endl;\n\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(4);\n\n    TreeNode* root4 = new TreeNode(1);\n    root4->left = new TreeNode(3);\n    root4->right = new TreeNode(4);\n\n    std::cout << (isSameTree(root3, root4) ? \"True\" : \"False\") << std::endl;\n\n    TreeNode* root5 = new TreeNode(1);\n    root5->left = new TreeNode(2);\n\n    TreeNode* root6 = new TreeNode(1);\n    root6->right = new TreeNode(2);\n\n    std::cout << (isSameTree(root5, root6) ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n\n```",
  "99": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvoid recoverTree(TreeNode* root, TreeNode** wrong, TreeNode** correct) {\n    if (!root) return;\n\n    TreeNode* prev = NULL;\n    TreeNode* first = NULL;\n    TreeNode* second = NULL;\n    \n    for (TreeNode* node = root; node; ) {\n        if (!node->left) {\n            if (prev && prev->val > node->val) {\n                if (!first) first = prev;\n                second = node;\n            }\n            prev = node;\n            node = NULL;\n        } else {\n            TreeNode* next = node->left;\n            node->left = NULL;\n            node = next;\n        }\n    }\n\n    *wrong = first;\n    *correct = second;\n}\n\nvoid printTree(TreeNode* root) {\n    if (!root) return;\n\n    std::cout << root->val << \" \";\n    printTree(root->left);\n    printTree(root->right);\n}\n\nint main() {\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(2);\n\n    recoverTree(root1, &root1->left, &root1->right);\n\n    printTree(root1);\n    std::cout << std::endl;\n\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(4);\n    root2->left->left = new TreeNode(3);\n\n    recoverTree(root2, &root2->left->left, &root2->left);\n\n    printTree(root2);\n    std::cout << std::endl;\n\n    TreeNode* root3 = new TreeNode(1);\n    root3->right = new TreeNode(3);\n    root3->right->left = new TreeNode(2);\n\n    recoverTree(root3, &root3->right->left, &root3->right);\n\n    printTree(root3);\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "101": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if (root == nullptr)\n            return true;\n        \n        return isMirror(root->left, root->right);\n    }\n    \n    bool isMirror(TreeNode* t1, TreeNode* t2) {\n        if (t1 == nullptr && t2 == nullptr)\n            return true;\n        \n        if (t1 == nullptr || t2 == nullptr)\n            return false;\n        \n        return (t1->val == t2->val) && \n               isMirror(t1->right, t2->left) && \n               isMirror(t1->left, t2->right);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(2);\n    root1->left->left = new TreeNode(3);\n    root1->left->right = new TreeNode(4);\n    root1->right->left = new TreeNode(4);\n    root1->right->right = new TreeNode(3);\n\n    cout << \"Test Case 1: \" << (solution.isSymmetric(root1) ? \"True\" : \"False\") << endl;\n\n    // Test Case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(2);\n\n    cout << \"Test Case 2: \" << (solution.isSymmetric(root2) ? \"True\" : \"False\") << endl;\n\n    // Test Case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(1);\n    root3->right = new TreeNode(1);\n\n    cout << \"Test Case 3: \" << (solution.isSymmetric(root3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "102": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        if (root == NULL)\n            return {};\n\n        queue<TreeNode*> q;\n        vector<vector<int>> res;\n        q.push(root);\n\n        while (!q.empty()) {\n            int levelSize = q.size();\n            vector<int> currLevel;\n\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n\n                currLevel.push_back(node->val);\n\n                if (node->left)\n                    q.push(node->left);\n                if (node->right)\n                    q.push(node->right);\n            }\n\n            res.insert(res.begin(), currLevel);\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(9);\n    root1->right = new TreeNode(20);\n    root1->right->left = new TreeNode(15);\n    root1->right->right = new TreeNode(7);\n\n    vector<vector<int>> res1 = solution.levelOrderBottom(root1);\n    for (const auto& level : res1) {\n        for (int val : level)\n            cout << val << \" \";\n        cout << endl;\n    }\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(3);\n\n    vector<vector<int>> res2 = solution.levelOrderBottom(root2);\n    for (const auto& level : res2) {\n        for (int val : level)\n            cout << val << \" \";\n        cout << endl;\n    }\n\n    // Test case 3\n    TreeNode* root3 = NULL;\n\n    vector<vector<int>> res3 = solution.levelOrderBottom(root3);\n    for (const auto& level : res3) {\n        for (int val : level)\n            cout << val << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "104": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\n    }\n};\n\nint main() {\n    TreeNode* root = new TreeNode(3);\n    root->left = new TreeNode(9);\n    root->right = new TreeNode(20);\n    root->right->left = new TreeNode(15);\n    root->right->right = new TreeNode(7);\n\n    Solution solution;\n    int result1 = solution.maxDepth(root);\n    cout << \"Test case 1: \" << result1 << endl; // Output: 3\n\n    root = nullptr;\n\n    result1 = solution.maxDepth(root);\n    cout << \"Test case 2: \" << result1 << endl; // Output: 0\n\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(6);\n\n    result1 = solution.maxDepth(root2);\n    cout << \"Test case 3: \" << result1 << endl; // Output: 3\n\n    return 0;\n}\n```",
  "103": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        if (!root) return {};\n        \n        vector<vector<int>> result;\n        queue<pair<TreeNode*, int>> q;\n        q.push({root, 0});\n        \n        bool isReversed = false;\n        \n        while (!q.empty()) {\n            int n = q.size();\n            vector<int> level;\n            \n            for (int i = 0; i < n; i++) {\n                auto [node, index] = q.front(); q.pop();\n                \n                if (isReversed) level.push_back(node->val);\n                else level.insert(level.begin(), node->val);\n                \n                if (node->left) q.push({node->left, index + 1});\n                if (node->right) q.push({node->right, index + 1});\n            }\n            \n            result.push_back(level);\n            isReversed = !isReversed;\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(9);\n    root1->right = new TreeNode(20);\n    root1->right->left = new TreeNode(15);\n    root1->right->right = new TreeNode(7);\n    \n    vector<vector<int>> result1 = solution.zigzagLevelOrder(root1);\n    for (const auto& level : result1) {\n        for (int val : level) cout << val << \" \";\n        cout << endl;\n    }\n    \n    // Test Case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(4);\n    root2->right = new TreeNode(5);\n    root2->left->left = new TreeNode(3);\n    root2->left->right = new TreeNode(2);\n    \n    vector<vector<int>> result2 = solution.zigzagLevelOrder(root2);\n    for (const auto& level : result2) {\n        for (int val : level) cout << val << \" \";\n        cout << endl;\n    }\n    \n    // Test Case 3\n    TreeNode* root3 = new TreeNode(5);\n    root3->left = new TreeNode(4);\n    root3->right = new TreeNode(10);\n    root3->left->left = new TreeNode(1);\n    root3->left->right = new TreeNode(2);\n    \n    vector<vector<int>> result3 = solution.zigzagLevelOrder(root3);\n    for (const auto& level : result3) {\n        for (int val : level) cout << val << \" \";\n        cout << endl;\n    }\n    \n    return 0;\n}\n```",
  "105": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if (preorder.empty()) return NULL;\n\n        int rootIndex = find(inorder.begin(), inorder.end(), preorder[0]) - inorder.begin();\n        TreeNode* root = new TreeNode(preorder[0]);\n        root->left = buildTree(vector<int>(preorder.begin() + 1, preorder.begin() + rootIndex - inorder.begin() + 1),\n                                vector<int>(inorder.begin(), inorder.begin() + rootIndex));\n        root->right = buildTree(vector<int>(preorder.begin() + rootIndex - inorder.begin() + 1, preorder.end()),\n                                 vector<int>(inorder.begin() + rootIndex, inorder.end()));\n        return root;\n    }\n\n    int find(vector<int>::iterator start, vector<int>::iterator end, int target) {\n        for (auto it = start; it != end; ++it) {\n            if (*it == target) return distance(start, it);\n        }\n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<int> preorder1 = {3,9,20,15,7};\n    vector<int> inorder1 = {9,3,15,20,7};\n    TreeNode* root1 = solution.buildTree(preorder1, inorder1);\n    cout << \"Test case 1: \";\n    if (root1) {\n        // Print the tree\n        queue<TreeNode*> q;\n        q.push(root1);\n        while (!q.empty()) {\n            TreeNode* node = q.front();\n            q.pop();\n            cout << node->val << \" \";\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n    } else {\n        cout << \"NULL\";\n    }\n    cout << endl;\n\n    // Test case 2:\n    vector<int> preorder2 = {1,2};\n    vector<int> inorder2 = {1,2};\n    TreeNode* root2 = solution.buildTree(preorder2, inorder2);\n    cout << \"Test case 2: \";\n    if (root2) {\n        queue<TreeNode*> q;\n        q.push(root2);\n        while (!q.empty()) {\n            TreeNode* node = q.front();\n            q.pop();\n            cout << node->val << \" \";\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n    } else {\n        cout << \"NULL\";\n    }\n    cout << endl;\n\n    // Test case 3:\n    vector<int> preorder3 = {1};\n    vector<int> inorder3 = {1};\n    TreeNode* root3 = solution.buildTree(preorder3, inorder3);\n    cout << \"Test case 3: \";\n    if (root3) {\n        queue<TreeNode*> q;\n        q.push(root3);\n        while (!q.empty()) {\n            TreeNode* node = q.front();\n            q.pop();\n            cout << node->val << \" \";\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n    } else {\n        cout << \"NULL\";\n    }\n    cout << endl;\n\n    return 0;\n}",
  "106": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        if (inorder.empty()) return NULL;\n\n        TreeNode* root = new TreeNode(postorder.back());\n        postorder.pop_back();\n\n        int idx = find(inorder.begin(), inorder.end(), root->val) - inorder.begin();\n        inorder.erase(inorder.begin() + idx);\n\n        root->right = buildTree(inorder, postorder);\n        root->left  = buildTree(inorder, postorder);\n\n        return root;\n    }\n\n    TreeNode* find(vector<int>::iterator& begin, vector<int>::iterator& end, int val) {\n        for (auto it = begin; it != end; ++it)\n            if (*it == val) return &(*it);\n        return nullptr;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> inorder1 = {9,3,15,20,7};\n    vector<int> postorder1 = {9,15,7,20,3};\n    TreeNode* tree1 = solution.buildTree(inorder1, postorder1);\n    //print tree here\n\n    // Test Case 2\n    vector<int> inorder2 = {1,4,6,8,10,11,13,14,15};\n    vector<int> postorder2 = {15,14,13,11,10,8,6,4,1};\n    TreeNode* tree2 = solution.buildTree(inorder2, postorder2);\n    //print tree here\n\n    // Test Case 3\n    vector<int> inorder3 = {1};\n    vector<int> postorder3 = {1};\n    TreeNode* tree3 = solution.buildTree(inorder3, postorder3);\n    //print tree here\n\n    return 0;\n}",
  "108": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(int* nums, int numSize) {\n        if (numSize == 0) return NULL;\n\n        int mid = numSize / 2;\n        TreeNode* node = new TreeNode(nums[mid]);\n        node->left = sortedArrayToBST(nums, mid);\n        node->right = sortedArrayToBST(nums + mid + 1, numSize - mid - 1);\n        return node;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int test_case1[] = {-10,-3,0,5,9};\n    TreeNode* result1 = solution.sortedArrayToBST(test_case1, 5);\n    // Print the binary tree\n    cout << \"Test Case 1: \";\n    printTree(result1);\n\n    int test_case2[] = {0};\n    TreeNode* result2 = solution.sortedArrayToBST(test_case2, 1);\n    // Print the binary tree\n    cout << \"\\nTest Case 2: \";\n    printTree(result2);\n\n    int test_case3[] = {-10,-5,0,5,15};\n    TreeNode* result3 = solution.sortedArrayToBST(test_case3, 5);\n    // Print the binary tree\n    cout << \"\\nTest Case 3: \";\n    printTree(result3);\n\n    return 0;\n}\n\nvoid printTree(TreeNode* node) {\n    if (node == NULL) return;\n\n    printTree(node->left);\n    cout << node->val << \" \";\n    printTree(node->right);\n}\n```",
  "107": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nstd::vector<std::vector<int>> levelOrderBottom(TreeNode* root) {\n    std::vector<std::vector<int>> result;\n    if (!root) return result;\n\n    std::queue<TreeNode*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        int levelSize = q.size();\n        std::vector<int> levelVec;\n        for (int i = 0; i < levelSize; ++i) {\n            TreeNode* node = q.front(); q.pop();\n            levelVec.push_back(node->val);\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n        }\n        result.insert(result.begin(), levelVec);\n    }\n\n    return result;\n}\n\nint main() {\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(9);\n    root1->right = new TreeNode(20);\n    root1->right->left = new TreeNode(15);\n    root1->right->right = new TreeNode(7);\n\n    std::vector<std::vector<int>> result1 = levelOrderBottom(root1);\n    for (const auto& level : result1) {\n        for (int val : level) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(4);\n    root2->right = new TreeNode(5);\n\n    std::vector<std::vector<int>> result2 = levelOrderBottom(root2);\n    for (const auto& level : result2) {\n        for (int val : level) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    TreeNode* root3 = nullptr;\n\n    std::vector<std::vector<int>> result3 = levelOrderBottom(root3);\n    for (const auto& level : result3) {\n        for (int val : level) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "110": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        if (root == NULL)\n            return true;\n        \n        if (abs(getHeight(root->left) - getHeight(root->right)) > 1)\n            return false;\n        \n        return isBalanced(root->left) && isBalanced(root->right);\n    }\n    \n    int getHeight(TreeNode* node) {\n        if (node == NULL)\n            return 0;\n        \n        return max(getHeight(node->left), getHeight(node->right)) + 1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(9);\n    root1->right = new TreeNode(20);\n    root1->right->left = new TreeNode(15);\n    root1->right->right = new TreeNode(7);\n\n    cout << \"Test case 1: \" << (solution.isBalanced(root1) ? \"True\" : \"False\") << endl;\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(2);\n    root2->left->left = new TreeNode(3);\n    root2->left->right = new TreeNode(3);\n    root2->right->left = new TreeNode(3);\n    root2->right->right = new TreeNode(3);\n\n    cout << \"Test case 2: \" << (solution.isBalanced(root2) ? \"True\" : \"False\") << endl;\n\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(2);\n    root3->left->left = new TreeNode(3);\n\n    cout << \"Test case 3: \" << (solution.isBalanced(root3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "109": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == NULL) return NULL;\n        int length = 0;\n        ListNode* p = head;\n        while (p != NULL) {\n            length++;\n            p = p->next;\n        }\n        return sortedListToBST(head, length);\n    }\n\n    TreeNode* sortedListToBST(ListNode* head, int length) {\n        if (length == 0) return NULL;\n\n        int mid = length / 2;\n        ListNode* end = head;\n        for (int i = 0; i < mid; i++) {\n            end = end->next;\n        }\n\n        TreeNode* root = new TreeNode(end->val);\n        root->left = sortedListToBST(head, mid);\n        root->right = sortedListToBST(end->next, length - mid - 1);\n\n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    ListNode *head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    TreeNode* result1 = solution.sortedListToBST(head1);\n    \n    cout << \"Test Case 1: \";\n    printTree(result1);\n    cout << endl;\n    \n    ListNode *head2 = new ListNode(-5);\n    head2->next = new ListNode(0);\n    head2->next->next = new ListNode(3);\n    head2->next->next->next = new ListNode(6);\n    TreeNode* result2 = solution.sortedListToBST(head2);\n    \n    cout << \"Test Case 2: \";\n    printTree(result2);\n    cout << endl;\n    \n    ListNode *head3 = new ListNode(0);\n    head3->next = new ListNode(1);\n    head3->next->next = new ListNode(2);\n    TreeNode* result3 = solution.sortedListToBST(head3);\n    \n    cout << \"Test Case 3: \";\n    printTree(result3);\n    cout << endl;\n    \n    return 0;\n}\n\nvoid printTree(TreeNode* root) {\n    if (root == NULL) return;\n\n    printTree(root->left);\n    cout << root->val << \" \";\n    printTree(root->right);\n}\n```",
  "111": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        if (root == NULL) return 0;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        int depth = 1;\n\n        while (!q.empty()) {\n            int levelSize = q.size();\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* currentNode = q.front();\n                q.pop();\n                \n                if (currentNode->left == NULL && currentNode->right == NULL)\n                    return depth;\n                \n                if (currentNode->left) q.push(currentNode->left);\n                if (currentNode->right) q.push(currentNode->right);\n            }\n            depth++;\n        }\n\n        return 0;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1:\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(9);\n    root1->right = new TreeNode(20);\n    root1->right->left = new TreeNode(15);\n    root1->right->right = new TreeNode(7);\n\n    cout << \"Test Case 1: \" << solution.minDepth(root1) << endl;\n\n    // Test Case 2:\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(6);\n\n    cout << \"Test Case 2: \" << solution.minDepth(root2) << endl;\n\n    // Test Case 3:\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n\n    cout << \"Test Case 3: \" << solution.minDepth(root3) << endl;\n\n    return 0;\n}\n```",
  "112": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum) {\n        if (root == NULL)\n            return false;\n\n        sum -= root->val;\n        if (root->left == NULL && root->right == NULL)\n            return sum == 0;\n\n        return hasPathSum(root->left, sum) || hasPathSum(root->right, sum);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    TreeNode* root = new TreeNode(5);\n    root->left = new TreeNode(4);\n    root->right = new TreeNode(8);\n    root->left->left = new TreeNode(11);\n    root->left->left->left = new TreeNode(7);\n    root->left->left->right = new TreeNode(2);\n    root->right->left = new TreeNode(13);\n    root->right->right = new TreeNode(4);\n    root->right->right->left = new TreeNode(5);\n    root->right->right->right = new TreeNode(1);\n\n    cout << \"Test Case 1: \" << (solution.hasPathSum(root, 22) ? \"True\" : \"False\") << endl;\n    \n    // Test Case 2\n    root = NULL;\n\n    cout << \"Test Case 2: \" << (solution.hasPathSum(root, 0) ? \"True\" : \"False\") << endl;\n    \n    // Test Case 3\n    root = new TreeNode(1);\n    root->left = new TreeNode(2);\n\n    cout << \"Test Case 3: \" << (solution.hasPathSum(root, 1) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}",
  "113": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int pathSum(TreeNode* root, int targetSum) {\n        if (root == nullptr) return 0;\n        vector<int> sum = {targetSum};\n        return dfs(root, sum, 0);\n    }\n\n    int dfs(TreeNode* node, vector<int>& sum, int curSum) {\n        if (node == nullptr) return 0;\n        int newSum = curSum + node->val;\n        sum.push_back(newSum);\n\n        if (newSum == node->val) return countPaths(node, sum);\n        \n        int left = dfs(node->left, sum, newSum);\n        int right = dfs(node->right, sum, newSum);\n        sum.pop_back();\n        return left + right;\n    }\n\n    int countPaths(TreeNode* node, vector<int>& sum) {\n        if (node == nullptr) return 0;\n        int res = 0;\n        for (int i = 0; i < sum.size(); i++) {\n            if (sum[i] == node->val) res++;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(4);\n    root1->right = new TreeNode(8);\n    root1->left->left = new TreeNode(11);\n    root1->left->left->left = new TreeNode(7);\n    root1->left->left->right = new TreeNode(2);\n    root1->right->left = new TreeNode(13);\n    root1->right->right = new TreeNode(4);\n    root1->right->right->left = new TreeNode(5);\n    root1->right->right->right = new TreeNode(1);\n\n    cout << solution.pathSum(root1, 22) << endl; // Output: 3\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(4);\n    root2->right = new TreeNode(5);\n    root2->left->left = new TreeNode(11);\n    root2->left->left->left = new TreeNode(7);\n    root2->left->left->right = new TreeNode(2);\n\n    cout << solution.pathSum(root2, 11) << endl; // Output: 3\n\n    TreeNode* root3 = new TreeNode(5);\n    root3->right = new TreeNode(4);\n    root3->right->left = new TreeNode(7);\n    root3->right->right = new TreeNode(1);\n\n    cout << solution.pathSum(root3, 11) << endl; // Output: 2\n\n    return 0;\n}\n```",
  "114": "```\n#include <iostream>\n#include \"ListNode.h\"\n\nvoid flatten(TreeNode* root) {\n    if (root == nullptr) return;\n    \n    while (root->right != nullptr || root->left != nullptr) {\n        TreeNode* nextRight = root->right;\n        TreeNode* left = root->left;\n        \n        root->right = left;\n        root->left = nullptr;\n        \n        TreeNode* current = left;\n        while (current->right != nullptr) {\n            current = current->right;\n        }\n        current->right = nextRight;\n        \n        root = nextRight;\n    }\n}\n\nint main() {\n    TreeNode* node1 = new TreeNode(1);\n    TreeNode* node2 = new TreeNode(2);\n    TreeNode* node3 = new TreeNode(5);\n    TreeNode* node4 = new TreeNode(3);\n    TreeNode* node5 = new TreeNode(4);\n    TreeNode* node6 = new TreeNode(6);\n\n    node1->left = node2;\n    node1->right = node3;\n    node2->left = node4;\n    node2->right = node5;\n    node5->left = node6;\n\n    TreeNode* head = nullptr;\n    flatten(node1);\n    \n    // Test Case 1\n    {\n        head = new ListNode(1);\n        head->next = new ListNode(2);\n        head->next->next = new ListNode(3);\n\n        if (head != nullptr) {\n            while (head->next != nullptr) {\n                std::cout << head->val << \" \";\n            }\n            std::cout << std::endl;\n        }\n\n        delete head;\n    }\n\n    // Test Case 2\n    {\n        head = new ListNode(1);\n        head->next = new ListNode(2);\n\n        if (head != nullptr) {\n            while (head->next != nullptr) {\n                std::cout << head->val << \" \";\n            }\n            std::cout << std::endl;\n        }\n\n        delete head;\n    }\n\n    // Test Case 3\n    {\n        head = new ListNode(1);\n        head->next = new ListNode(2);\n        head->next->next = new ListNode(3);\n\n        if (head != nullptr) {\n            while (head->next != nullptr) {\n                std::cout << head->val << \" \";\n            }\n            std::cout << std::endl;\n        }\n\n        delete head;\n    }\n\n    return 0;\n}\n\n```",
  "115": "```\n#include <iostream>\n#include <vector>\n\nint numDistinct(const std::string& s, const std::string& t) {\n    int m = s.size();\n    int n = t.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n\n    for (int i = 0; i <= m; ++i) {\n        if (i == 0)\n            dp[i][0] = 1;\n        else\n            dp[i][0] = dp[i - 1][0];\n        for (int j = 0; j <= n; ++j) {\n            if (j == 0)\n                dp[i][j] = i == 0 ? 1 : 0;\n            else {\n                if (s[i - 1] == t[j - 1])\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                else\n                    dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    std::cout << numDistinct(\"rabbbit\", \"rabbit\") << std::endl; // Output: 3\n    std::cout << numDistinct(\"babgbag\", \"bag\") << std::endl; // Output: 4\n    std::cout << numDistinct(\"bcad\", \"bad\") << std::endl; // Output: 2\n\n    return 0;\n}\n```",
  "116": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode *next;\n};\n\nclass Solution {\npublic:\n    void connect(TreeNode* root) {\n        if (!root)\n            return;\n\n        queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            int levelSize = q.size();\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* current = q.front();\n                q.pop();\n\n                if (i < levelSize - 1)\n                    current->next = q.front();\n\n                if (current->left)\n                    q.push(current->left);\n                if (current->right)\n                    q.push(current->right);\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->left->left = new TreeNode(4);\n    root1->left->right = new TreeNode(5);\n    solution.connect(root1);\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(3);\n    root2->right->left = new TreeNode(4);\n    root2->right->right = new TreeNode(5);\n    solution.connect(root2);\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(3);\n    root3->right->left = new TreeNode(4);\n    root3->right->right = new TreeNode(5);\n    root3->right->right->left = new TreeNode(6);\n    solution.connect(root3);\n\n    return 0;\n}\n```",
  "118": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int>> generate(int numRows) {\n    std::vector<std::vector<int>> triangle;\n    for (int i = 1; i <= numRows; ++i) {\n        std::vector<int> row(i, 1);\n        if (!triangle.empty()) {\n            auto prevRow = triangle.back();\n            for (int j = 1; j < i; ++j) {\n                row[j] = prevRow[j - 1] + prevRow[j];\n            }\n        }\n        triangle.push_back(row);\n    }\n    return triangle;\n}\n\nint main() {\n    int numRows1 = 3;\n    std::vector<std::vector<int>> result1 = generate(numRows1);\n    for (const auto& row : result1) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    int numRows2 = 5;\n    std::vector<std::vector<int>> result2 = generate(numRows2);\n    for (const auto& row : result2) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    int numRows3 = 1;\n    std::vector<std::vector<int>> result3 = generate(numRows3);\n    for (const auto& row : result3) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "117": "```\n#include <iostream>\n#include \"Solution.h\"\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    Node* root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->left->left = new Node(4);\n    root->left->right = new Node(5);\n    root->right->left = new Node(6);\n    root->right->right = new Node(7);\n    \n    solution.connect(root);\n    \n    // Print the connected nodes\n    std::cout << \"Test Case 1: \";\n    printLevelOrder(root);\n    std::cout << std::endl;\n    \n    // Test Case 2\n    root = new Node(1);\n    root->left = new Node(2);\n    \n    solution.connect(root);\n    \n    // Print the connected nodes\n    std::cout << \"Test Case 2: \";\n    printLevelOrder(root);\n    std::cout << std::endl;\n    \n    // Test Case 3\n    root = new Node(1);\n    root->left = new Node(2);\n    root->right = new Node(3);\n    root->left->left = new Node(4);\n    \n    solution.connect(root);\n    \n    // Print the connected nodes\n    std::cout << \"Test Case 3: \";\n    printLevelOrder(root);\n    std::cout << std::endl;\n    \n    return 0;\n}\n\nvoid printLevelOrder(Node* root) {\n    if (root == nullptr) {\n        return;\n    }\n    \n    std::queue<Node*> q;\n    q.push(root);\n    \n    while (!q.empty()) {\n        Node* node = q.front();\n        q.pop();\n        \n        std::cout << node->val << \" \";\n        \n        if (node->left != nullptr) {\n            q.push(node->left);\n        }\n        if (node->right != nullptr) {\n            q.push(node->right);\n        }\n    }\n    \n    std::cout << std::endl;\n}\n```",
  "119": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> getRow(int rowIndex) {\n    std::vector<std::vector<int>> triangle = {{1}};\n\n    for (int i = 1; i <= rowIndex; ++i) {\n        std::vector<int> row;\n        row.push_back(1);\n        for (int j = 0; j < i - 1; ++j) {\n            row.push_back(triangle[i-1][j] + triangle[i-1][j+1]);\n        }\n        row.push_back(1);\n        triangle.push_back(row);\n    }\n\n    return triangle[rowIndex];\n}\n\nint main() {\n    std::cout << \"Test case 1: rowIndex = 3\" << std::endl;\n    for (int num : getRow(3)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"Test case 2: rowIndex = 0\" << std::endl;\n    for (int num : getRow(0)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"Test case 3: rowIndex = 4\" << std::endl;\n    for (int num : getRow(4)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
  "120": "```\n#include <iostream>\n#include <vector>\n\nint minimumTotal(std::vector<std::vector<int>>& triangle) {\n    for (int i = 1; i < triangle.size(); ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (j == 0) {\n                triangle[i][j] += triangle[i - 1][0];\n            } else if (j == i) {\n                triangle[i][j] += triangle[i - 1][i - 1];\n            } else {\n                triangle[i][j] += std::min(triangle[i - 1][j], triangle[i - 1][j - 1]);\n            }\n        }\n    }\n    int minTotal = INT_MAX;\n    for (int i = 0; i < triangle.back().size(); ++i) {\n        if (triangle.back()[i] < minTotal) {\n            minTotal = triangle.back()[i];\n        }\n    }\n    return minTotal;\n}\n\nint main() {\n    std::vector<std::vector<int>> test1{{2}, {3, 4}, {6, 5, 7}, {4, 1, 8, 3}};\n    std::cout << \"Test case 1: \" << minimumTotal(test1) << std::endl;\n\n    std::vector<std::vector<int>> test2{{-10} };\n    std::cout << \"Test case 2: \" << minimumTotal(test2) << std::endl;\n\n    std::vector<std::vector<int>> test3{{1}, {2, 3}, {4, 5, 6}};\n    std::cout << \"Test case 3: \" << minimumTotal(test3) << std::endl;\n\n    return 0;\n}\n```",
  "121": "```\n#include <iostream>\n#include <vector>\n\nint maxProfit(std::vector<int>& prices) {\n    int minPrice = prices[0];\n    int maxProfit = 0;\n    for (int i = 1; i < prices.size(); i++) {\n        if (prices[i] < minPrice) {\n            minPrice = prices[i];\n        } else if (prices[i] - minPrice > maxProfit) {\n            maxProfit = prices[i] - minPrice;\n        }\n    }\n    return maxProfit;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> prices1 = {7, 1, 5, 3, 6, 4};\n    int result1 = maxProfit(prices1);\n    std::cout << \"Best time to buy and sell stock for prices 1: \" << result1 << \"\\n\";\n\n    // Test case 2\n    std::vector<int> prices2 = {7, 6, 4, 3, 2};\n    int result2 = maxProfit(prices2);\n    std::cout << \"Best time to buy and sell stock for prices 2: \" << result2 << \"\\n\";\n\n    // Test case 3\n    std::vector<int> prices3 = {1, 2, 3, 4, 5};\n    int result3 = maxProfit(prices3);\n    std::cout << \"Best time to buy and sell stock for prices 3: \" << result3 << \"\\n\";\n    \n    return 0;\n}\n```",
  "122": "```\n#include <iostream>\n#include <vector>\n\nint maxProfit(std::vector<int>& prices) {\n    int total = 0;\n    for (int i = 1; i < prices.size(); ++i) {\n        if (prices[i] > prices[i - 1]) {\n            total += prices[i] - prices[i - 1];\n        }\n    }\n    return total;\n}\n\nint main() {\n    std::vector<int> prices1 = {7,1,5,3,6,4};\n    int result1 = maxProfit(prices1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> prices2 = {1,2,3,4,5};\n    int result2 = maxProfit(prices2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> prices3 = {7,6,5,4,3,2,1};\n    int result3 = maxProfit(prices3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "123": "```\n#include <iostream>\n#include <vector>\n\nint maxProfit(std::vector<int>& prices) {\n    int n = prices.size();\n    if (n < 2) return 0;\n    \n    int buy1 = -prices[0];\n    int sell1 = 0;\n    int buy2 = -prices[0];\n    int sell2 = 0;\n    \n    for (int i = 1; i < n; i++) {\n        buy1 = std::max(buy1, -prices[i]);\n        sell1 = std::max(sell1, buy1 + prices[i]);\n        buy2 = std::max(buy2, sell1 - prices[i]);\n        sell2 = std::max(sell2, buy2 + prices[i]);\n    }\n    \n    return sell2;\n}\n\nint main() {\n    std::vector<int> prices1 = {3, 3, 5, 0, 0, 3, 1, 4};\n    std::cout << \"Test case 1: \" << maxProfit(prices1) << std::endl;\n\n    std::vector<int> prices2 = {1, 2};\n    std::cout << \"Test case 2: \" << maxProfit(prices2) << std::endl;\n\n    std::vector<int> prices3 = {5, 6, 7, 8, 9};\n    std::cout << \"Test case 3: \" << maxProfit(prices3) << std::endl;\n    \n    return 0;\n}\n```",
  "125": "```\n#include <iostream>\n#include <string>\n\nbool isPalindrome(std::string s) {\n    int left = 0;\n    int right = s.size() - 1;\n\n    while (left < right) {\n        if (!std::isalnum(s[left])) {\n            left++;\n            continue;\n        }\n        if (!std::isalnum(s[right])) {\n            right--;\n            continue;\n        }\n\n        if (std::tolower((unsigned char)s[left]) != std::tolower((unsigned char)s[right]))\n            return false;\n\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test case 1: \" << isPalindrome(\"A man a plan a canal Panama\") << std::endl;\n    std::cout << \"Test case 2: \" << isPalindrome(\"Not a palindrome\") << std::endl;\n    std::cout << \"Test case 3: \" << isPalindrome(\"Madam\") << std::endl;\n\n    return 0;\n}\n```",
  "124": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        if (root == NULL) return 0;\n        \n        int res = INT_MIN;\n        int sum = helper(root, NULL);\n        res = max(res, sum);\n        return res;\n    }\n    \n    int helper(TreeNode* node, TreeNode* parent) {\n        if (node == NULL) return 0;\n        \n        int leftSum = (parent->val + node->val > 0) ? parent->val + node->val : 0;\n        int rightSum = (leftSum > node->val && node->right != NULL) ? leftSum : 0;\n        \n        return max(leftSum, rightSum) + node->val;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    cout << \"Test Case 1: \" << solution.maxPathSum(root1) << endl; // Output: 6\n\n    TreeNode* root2 = new TreeNode(-10);\n    root2->left = new TreeNode(9);\n    root2->right = new TreeNode(20);\n    root2->right->left = new TreeNode(15);\n    root2->right->right = new TreeNode(7);\n    cout << \"Test Case 2: \" << solution.maxPathSum(root2) << endl; // Output: 42\n\n    TreeNode* root3 = new TreeNode(-10);\n    root3->left = new TreeNode(9);\n    root3->right = new TreeNode(-20);\n    cout << \"Test Case 3: \" << solution.maxPathSum(root3) << endl; // Output: -1\n\n    return 0;\n}\n```",
  "127": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        if (wordList.size() == 0) return {};\n        \n        unordered_set<string> dict(wordList.begin(), wordList.end());\n        queue<pair<string, int>> q;\n        unordered_set<string> visited;\n        vector<string> res;\n\n        q.push({beginWord, 1});\n        visited.insert(beginWord);\n\n        while (!q.empty()) {\n            string cur = q.front().first;\n            int len = q.front().second;\n            q.pop();\n\n            if (cur == endWord) {\n                res.push_back(cur);\n                return res;\n            }\n\n            for (int i = 0; i < cur.size(); ++i) {\n                char c1 = cur[i];\n                for (char c2 = 'a'; c2 <= 'z'; ++c2) {\n                    if (c2 == c1) continue;\n\n                    string next = cur;\n                    next[i] = c2;\n                    if (dict.count(next)) {\n                        if (!visited.count(next)) {\n                            q.push({next, len + 1});\n                            visited.insert(next);\n                        }\n                    }\n                }\n            }\n        }\n\n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> wordList1 = {\"hit\",\"hot\",\"dot\",\"dog\",\"lot\",\"log\"};\n    vector<string> wordList2 = {\"start\", \"end\", \"pres\", \"prey\", \"prye\", \"prop\", \"prol\"};\n    vector<string> wordList3 = {\"a\", \"b\", \"c\", \"d\"};\n\n    cout << \"Test Case 1: \";\n    vector<string> res1 = solution.ladderLength(\"hit\", \"cog\", wordList1);\n    for (string s : res1) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test Case 2: \";\n    vector<string> res2 = solution.ladderLength(\"start\", \"end\", wordList2);\n    for (string s : res2) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test Case 3: \";\n    vector<string> res3 = solution.ladderLength(\"a\", \"c\", wordList3);\n    for (string s : res3) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
  "126": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        unordered_map<string, vector<string>> graph;\n        for (const auto& word : wordList) {\n            for (int i = 0; i < word.size(); ++i) {\n                string newWord = word.substr(0, i) + '*' + word.substr(i + 1);\n                graph[newWord].push_back(word);\n            }\n        }\n\n        queue<pair<string, int>> q;\n        q.push({beginWord, 1});\n        unordered_set<string> visited;\n        vector<vector<string>> results;\n\n        while (!q.empty()) {\n            string current = q.front().first;\n            int step = q.front().second;\n            q.pop();\n\n            if (current == endWord) {\n                results.push_back(vector<string>(1, current));\n                continue;\n            }\n\n            for (int i = 0; i < current.size(); ++i) {\n                string newWord = current.substr(0, i) + '*' + current.substr(i + 1);\n                if (graph.find(newWord) != graph.end()) {\n                    for (const auto& word : graph[newWord]) {\n                        if (!visited.count(word)) {\n                            visited.insert(word);\n                            q.push({word, step + 1});\n                        }\n                    }\n                }\n            }\n        }\n\n        return results;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> wordList1 = {\"start\", \"paws\", \"notes\", \"stent\", \"tears\"};\n    string beginWord1 = \"start\";\n    string endWord1 = \"tears\";\n    vector<vector<string>> result1 = solution.ladderLength(beginWord1, endWord1, wordList1);\n    for (const auto& ladder : result1) {\n        for (const auto& word : ladder) {\n            cout << word << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<string> wordList2 = {\"hit\", \"mit\", \"mat\", \"pat\"};\n    string beginWord2 = \"hit\";\n    string endWord2 = \"bat\";\n    vector<vector<string>> result2 = solution.ladderLength(beginWord2, endWord2, wordList2);\n    for (const auto& ladder : result2) {\n        for (const auto& word : ladder) {\n            cout << word << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<string> wordList3 = {\"a\", \"b\", \"c\"};\n    string beginWord3 = \"a\";\n    string endWord3 = \"c\";\n    vector<vector<string>> result3 = solution.ladderLength(beginWord3, endWord3, wordList3);\n    for (const auto& ladder : result3) {\n        for (const auto& word : ladder) {\n            cout << word << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "128": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int longestConsecutive(std::vector<int>& nums) {\n        if (nums.empty()) return 0;\n        \n        std::unordered_map<int, bool> numExists;\n        for (int num : nums) {\n            numExists[num] = true;\n        }\n        \n        int longestStreak = 0;\n        for (int num : numExists) {\n            if (!numExists[num - 1] && numExists.find(num + 1) == numExists.end()) { // Found the start of a sequence\n                int currentNum = num;\n                int currentStreak = 1;\n                \n                while (numExists.find(currentNum + 1) != numExists.end()) {\n                    currentNum += 1;\n                    currentStreak += 1;\n                }\n                \n                longestStreak = std::max(longestStreak, currentStreak);\n            }\n        }\n        \n        return longestStreak;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> test1 = {0,3,7,2,5,8,4,6,1};\n    std::cout << \"Test Case 1: \" << solution.longestConsecutive(test1) << std::endl;\n    \n    // Test case 2\n    std::vector<int> test2 = {};\n    std::cout << \"Test Case 2: \" << solution.longestConsecutive(test2) << std::endl;\n\n    // Test case 3\n    std::vector<int> test3 = {1,2,3,4,5};\n    std::cout << \"Test Case 3: \" << solution.longestConsecutive(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "129": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return dfs(root, 0);\n    }\n    \n    int dfs(TreeNode* node, int currentSum) {\n        if (!node)\n            return 0;\n        \n        int sum = currentSum * 10 + node->val;\n        \n        if (!node->left && !node->right)\n            return sum;\n        \n        return sum + dfs(node->left, sum) + dfs(node->right, sum);\n    }\n};\n\nint main() {\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(4);\n    root1->right = new TreeNode(8);\n    root1->left->left = new TreeNode(11);\n    root1->left->left->left = new TreeNode(2);\n\n    Solution solution;\n    cout << \"Test Case 1: \" << solution.sumNumbers(root1) << endl; // Output: 25\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(4);\n    root2->right = new TreeNode(5);\n    root2->right->left = new TreeNode(1);\n\n    cout << \"Test Case 2: \" << solution.sumNumbers(root2) << endl; // Output: 6\n\n    TreeNode* root3 = new TreeNode(0);\n\n    cout << \"Test Case 3: \" << solution.sumNumbers(root3) << endl; // Output: 0\n\n    return 0;\n}\n```",
  "131": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::vector<std::string>> partition(std::string s) {\n    std::vector<std::vector<std::string>> result;\n    std::function<void(size_t, int)> backtrack = [&](size_t start, int pos) {\n        if (pos == s.size()) {\n            result.push_back({});\n            return;\n        }\n        for (int i = pos; i < s.size(); ++i) {\n            if (s.substr(pos, i - pos + 1).compare(\n                std::to_string(std::stoi(s.substr(pos, i - pos + 1))) == 0 ? \"\" : std::string(s.substr(pos, i - pos + 1)))) {\n                backtrack(i + 1, i);\n                result.back().push_back(s.substr(pos, i - pos + 1));\n            }\n        }\n    };\n    backtrack(0, 0);\n    return result;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \";\n    std::vector<std::vector<std::string>> result = partition(\"aab\");\n    for (const auto& vec : result) {\n        for (const auto& str : vec) {\n            std::cout << str << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    std::cout << \"Test Case 2: \";\n    result = partition(\"a\");\n    for (const auto& vec : result) {\n        for (const auto& str : vec) {\n            std::cout << str << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    std::cout << \"Test Case 3: \";\n    result = partition(\"aba\");\n    for (const auto& vec : result) {\n        for (const auto& str : vec) {\n            std::cout << str << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}",
  "132": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCut(string s) {\n        int n = s.size();\n        vector<int> cut(n, n-1);\n        for (int i = 0; i < n; ++i) {\n            if (s[i] == s[n-i-1]) {\n                if (i == 0 || s[i] != s[n-i-2])\n                    cut[i] = i;\n                else\n                    cut[i] = cut[i-1];\n            }\n        }\n        return cut.back();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    string test1 = \"aba\";\n    cout << \"Expected: 0, Got: \" << solution.minCut(test1) << endl;\n    \n    // Test case 2:\n    string test2 = \"aab\";\n    cout << \"Expected: 1, Got: \" << solution.minCut(test2) << endl;\n\n    // Test case 3:\n    string test3 = \"a\";\n    cout << \"Expected: 0, Got: \" << solution.minCut(test3) << endl;\n    \n    return 0;\n}\n```",
  "130": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        if (board.empty()) return;\n        \n        int m = board.size();\n        int n = board[0].size();\n        \n        for (int i = 0; i < m; ++i) {\n            dfs(board, i, 0);\n            dfs(board, i, n - 1);\n        }\n        \n        for (int j = 0; j < n; ++j) {\n            dfs(board, 0, j);\n            dfs(board, m - 1, j);\n        }\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (board[i][j] == 'O') board[i][j] = 'X';\n                else if (board[i][j] == 'X') board[i][j] = 'O';\n            }\n        }\n    }\n    \n    void dfs(vector<vector<char>>& board, int i, int j) {\n        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != 'O') return;\n        \n        board[i][j] = 'N';\n        \n        dfs(board, i - 1, j);\n        dfs(board, i + 1, j);\n        dfs(board, i, j - 1);\n        dfs(board, i, j + 1);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<vector<char>> board1 = {{'O','O','O','O','X','X'},\n                                    {'O','O','O','O','X','X'},\n                                    {'O','O','O','O','X','X'},\n                                    {'O','O','O','O','X','X'}};\n    solution.solve(board1);\n    for (const auto& row : board1) {\n        for (char c : row) cout << c << \" \";\n        cout << endl;\n    }\n    \n    // Test Case 2\n    vector<vector<char>> board2 = {{'O','O','O','O'},\n                                    {'O','X','O','O'},\n                                    {'O','O','O','O'}};\n    solution.solve(board2);\n    for (const auto& row : board2) {\n        for (char c : row) cout << c << \" \";\n        cout << endl;\n    }\n    \n    // Test Case 3\n    vector<vector<char>> board3 = {{'X'},\n                                    {'X','O','O'},\n                                    {'X','O','O'}};\n    solution.solve(board3);\n    for (const auto& row : board3) {\n        for (char c : row) cout << c << \" \";\n        cout << endl;\n    }\n    \n    return 0;\n}\n```",
  "134": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n        int totalGas = 0;\n        int totalCost = 0;\n        int start = 0;\n        int tank = 0;\n\n        for (int i = 0; i < gas.size(); i++) {\n            totalGas += gas[i];\n            totalCost += cost[i];\n            tank += gas[i] - cost[i];\n\n            if (tank < 0) {\n                start = i + 1;\n                tank = 0;\n            }\n        }\n\n        return (totalGas >= totalCost) ? start : -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> gas1 = {1,2,3};\n    vector<int> cost1 = {4,5,6};\n    cout << solution.canCompleteCircuit(gas1, cost1) << endl;  // Expected output: -1\n\n    // Test case 2\n    vector<int> gas2 = {7,8};\n    vector<int> cost2 = {0,8};\n    cout << solution.canCompleteCircuit(gas2, cost2) << endl;  // Expected output: 4\n\n    // Test case 3\n    vector<int> gas3 = {1,2,3,4,5};\n    vector<int> cost3 = {3,4,3,4,3};\n    cout << solution.canCompleteCircuit(gas3, cost3) << endl;  // Expected output: 4\n\n    return 0;\n}\n```",
  "133": "```\n#include <iostream>\n#include <vector>\n#include <list>\n\nusing namespace std;\n\n// Definition for undirected graph node\nstruct UndirectedGraphNode {\n    int val;\n    vector<UndirectedGraphNode*> neighbors;\n    UndirectedGraphNode(int x) : val(x) {}\n};\n\nclass Solution {\npublic:\n    UndirectedGraphNode* cloneGraph(UndirectedGraphNode* node) {\n        if (node == NULL)\n            return NULL;\n\n        unordered_map<int, UndirectedGraphNode*> oldToNew;\n        queue<UndirectedGraphNode*> q;\n        q.push(node);\n\n        while (!q.empty()) {\n            UndirectedGraphNode* curr = q.front();\n            q.pop();\n\n            if (oldToNew.find(curr->val) == oldToNew.end()) {\n                UndirectedGraphNode* newCurr = new UndirectedGraphNode(curr->val);\n                oldToNew[curr->val] = newCurr;\n                for (UndirectedGraphNode* neighbor : curr->neighbors) {\n                    q.push(neighbor);\n                    newCurr->neighbors.push_back(oldToNew[neighbor->val]);\n                }\n            }\n        }\n\n        return oldToNew[node->val];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    UndirectedGraphNode* node1 = new UndirectedGraphNode(1);\n    UndirectedGraphNode* node2 = new UndirectedGraphNode(2);\n    UndirectedGraphNode* node3 = new UndirectedGraphNode(3);\n\n    node1->neighbors.push_back(node2);\n    node2->neighbors.push_back(node1);\n    node2->neighbors.push_back(node3);\n    node3->neighbors.push_back(node2);\n\n    UndirectedGraphNode* clonedNode1 = solution.cloneGraph(node1);\n    cout << \"Test case 1: \";\n    for (UndirectedGraphNode* neighbor : clonedNode1->neighbors) {\n        cout << neighbor->val << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    node1 = new UndirectedGraphNode(4);\n    node2 = new UndirectedGraphNode(5);\n\n    node1->neighbors.push_back(node2);\n    node2->neighbors.push_back(node1);\n\n    clonedNode1 = solution.cloneGraph(node1);\n    cout << \"Test case 2: \";\n    for (UndirectedGraphNode* neighbor : clonedNode1->neighbors) {\n        cout << neighbor->val << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    node1 = new UndirectedGraphNode(6);\n\n    clonedNode1 = solution.cloneGraph(node1);\n    cout << \"Test case 3: \";\n    for (UndirectedGraphNode* neighbor : clonedNode1->neighbors) {\n        cout << neighbor->val << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "136": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int result = 0;\n        for (int num : nums) {\n            result ^= num;\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> test1 = {2, 2, 3};\n    cout << \"Test Case 1: \" << solution.singleNumber(test1) << endl;\n\n    // Test Case 2\n    vector<int> test2 = {0, 1, 1};\n    cout << \"Test Case 2: \" << solution.singleNumber(test2) << endl;\n\n    // Test Case 3\n    vector<int> test3 = {4, 2, 2, 1, 3};\n    cout << \"Test Case 3: \" << solution.singleNumber(test3) << endl;\n\n    return 0;\n}\n```",
  "135": "```\n#include <iostream>\n#include <vector>\n\nint candy(std::vector<int>& ratings) {\n    int n = ratings.size();\n    std::vector<int> candies(n, 1);\n    \n    for (int i = 1; i < n; ++i) {\n        if (ratings[i] > ratings[i - 1]) {\n            candies[i] = candies[i - 1] + 1;\n        }\n    }\n    \n    for (int i = n - 2; i >= 0; --i) {\n        if (ratings[i] > ratings[i + 1]) {\n            candies[i] = std::max(candies[i], candies[i + 1] + 1);\n        }\n    }\n    \n    int totalCandy = 0;\n    for (int candy : candies) {\n        totalCandy += candy;\n    }\n    \n    return totalCandy;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> ratings1 = {1, 0, 2};\n    std::cout << \"Test case 1: \" << candy(ratings1) << std::endl;\n\n    // Test case 2\n    std::vector<int> ratings2 = {1, 3, 2, 3, 1};\n    std::cout << \"Test case 2: \" << candy(ratings2) << std::endl;\n\n    // Test case 3\n    std::vector<int> ratings3 = {2, 8, 7, 3, 1};\n    std::cout << \"Test case 3: \" << candy(ratings3) << std::endl;\n    \n    return 0;\n}\n```",
  "137": "```\n#include <iostream>\n#include <vector>\n\nint singleNumber(std::vector<int>& nums) {\n    int ones = 0;\n    int twos = 0;\n\n    for (int num : nums) {\n        ones = (ones ^ num) & (~twos);\n        twos = (ones & num) | (twos & ~num);\n    }\n\n    return ones;\n}\n\nint main() {\n    std::vector<int> test1 = {2, 2, 3};\n    std::cout << singleNumber(test1) << std::endl;\n\n    std::vector<int> test2 = {0, 1, 1};\n    std::cout << singleNumber(test2) << std::endl;\n\n    std::vector<int> test3 = {1};\n    std::cout << singleNumber(test3) << std::endl;\n\n    return 0;\n}\n```",
  "139": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        int n = s.length();\n        vector<bool> dp(n+1, false);\n        for (int i=0; i<=n; i++) {\n            for (int j=0; j<i; j++) {\n                if (wordDict.size() && find(wordDict.begin(), wordDict.end(), s.substr(j)) != wordDict.end()) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<string> wordDict1 = {\"apple\", \"pen\"};\n    cout << (solution.wordBreak(\"applepen\", wordDict1) ? \"True\" : \"False\") << endl;  // Expected: True\n\n    // Test Case 2\n    vector<string> wordDict2 = {\"leet\", \"code\"};\n    cout << (solution.wordBreak(\"leetcode\", wordDict2) ? \"True\" : \"False\") << endl;  // Expected: True\n\n    // Test Case 3\n    vector<string> wordDict3 = {\"un\", \"given\"};\n    cout << (solution.wordBreak(\"ungiven\", wordDict3) ? \"True\" : \"False\") << endl;  // Expected: False\n\n    return 0;\n}\n```",
  "138": "```\n#include <iostream>\n#include <unordered_map>\n\n// Definition for a Node.\nstruct Node {\n    int val;\n    Node* next;\n    Node* random;\n\n    Node(int _val) : val(_val), next(NULL), random(NULL) {}\n};\n\nNode* copyRandomList(Node* head) {\n    if (!head) return NULL;\n\n    Node* current = head;\n    while (current) {\n        Node* newNode = new Node(current->val);\n        newNode->next = current->next;\n        newNode->random = current->random;\n\n        current->next = newNode;\n        current = newNode->next;\n    }\n\n    current = head;\n    while (current) {\n        if (current->random) {\n            current->next->random = current->random->next;\n        }\n        current = current->next->next;\n    }\n\n    Node* newHead = head->next;\n    Node* original = head;\n    Node* copy = newHead;\n\n    while (original && copy) {\n        if (copy->random) {\n            copy->random = copy->random->next;\n        }\n        original = original->next;\n        copy = copy->next;\n    }\n\n    return newHead;\n}\n\nint main() {\n    // Test Case 1:\n    Node* head1 = new Node(7);\n    head1->next = new Node(14);\n    head1->next->random = head1;\n    head1->next->next = new Node(5);\n    head1->next->next->random = head1->next;\n\n    head1 = copyRandomList(head1);\n\n    // Test Case 2:\n    Node* head2 = new Node(3);\n    head2->next = new Node(2);\n    head2->next->random = head2;\n    head2->next->next = new Node(1);\n\n    head2 = copyRandomList(head2);\n\n    // Test Case 3:\n    Node* head3 = NULL;\n\n    head3 = copyRandomList(head3);\n\n    return 0;\n}",
  "140": "```\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> wordBreak(string s, vector<string>& wordDict) {\n        int n = s.size();\n        bool dp[n];\n        memset(dp, false, sizeof(dp));\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= i; ++j) {\n                if (wordDict.size() && find(wordDict.begin(), wordDict.end(), s.substr(j)) != wordDict.end()) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        vector<string> res;\n        string path;\n        for (int i = 0; i < n; ++i) {\n            if (!dp[i]) {\n                break;\n            }\n            int j = s.find(\" \", i);\n            if (j == -1) {\n                res.push_back(s.substr(i));\n            } else {\n                res.push_back(s.substr(i, j - i));\n                wordBreakHelper(s, i + 1, j, wordDict, path, res);\n            }\n        }\n\n        return res;\n    }\n\n    void wordBreakHelper(string& s, int start, int end, vector<string>& wordDict, string& path, vector<string>& res) {\n        if (start >= end) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = start; i < end; ++i) {\n            bool flag = false;\n            for (auto &word: wordDict) {\n                if (s.substr(start, i - start + 1) == word) {\n                    flag = true;\n                    break;\n                }\n            }\n            if (!flag) continue;\n\n            int j = s.find(\" \", i);\n            if (j == -1) {\n                res.push_back(path + \" \" + s.substr(i));\n            } else {\n                res.push_back(path + \" \" + s.substr(i, j - i));\n                wordBreakHelper(s, j + 1, end, wordDict, path + \" \" + s.substr(i), res);\n            }\n        }\n    }\n\n};\n\nint main() {\n    Solution solution;\n    vector<string> dict = {\"apple\", \"pen\"};\n    vector<string> result1 = solution.wordBreak(\"applepen\", dict);\n    for (auto &word: result1) {\n        cout << word << endl;\n    }\n\n    vector<string> dict2 = {\"cats\",\"dogs\",\"sand\",\"sun\",\"dance\",\"walk\",\"cat\",\"dog\"};\n    vector<string> result2 = solution.wordBreak(\"catsanddog\", dict2);\n    for (auto &word: result2) {\n        cout << word << endl;\n    }\n\n    vector<string> dict3 = {\"a\",\"aaa\"};\n    vector<string> result3 = solution.wordBreak(\"aaaaaa\", dict3);\n    for (auto &word: result3) {\n        cout << word << endl;\n    }\n}\n```",
  "141": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nbool hasCycle(ListNode *head) {\n    if (head == NULL || head->next == NULL)\n        return false;\n\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n\n        if (slow == fast)\n            return true;\n    }\n\n    return false;\n}\n\nint main() {\n    // Test case 1: A cycle\n    ListNode* head1 = new ListNode(3);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(0);\n    head1->next->next->next = head1; // Create a cycle\n\n    if (hasCycle(head1))\n        cout << \"Test case 1: The linked list has a cycle.\" << endl;\n    else\n        cout << \"Test case 1: The linked list does not have a cycle.\" << endl;\n\n    delete head1;\n\n    // Test case 2: No cycle\n    head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n\n    if (hasCycle(head1))\n        cout << \"Test case 2: The linked list has a cycle.\" << endl;\n    else\n        cout << \"Test case 2: The linked list does not have a cycle.\" << endl;\n\n    delete head1;\n\n    // Test case 3: A cycle with only one node\n    head1 = new ListNode(5);\n    head1->next = head1; // Create a cycle\n\n    if (hasCycle(head1))\n        cout << \"Test case 3: The linked list has a cycle.\" << endl;\n    else\n        cout << \"Test case 3: The linked list does not have a cycle.\" << endl;\n\n    delete head1;\n\n    return 0;\n}\n```",
  "142": "```\n#include <iostream>\n#include <vector>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* detectCycle(ListNode* head) {\n    if (head == NULL || head->next == NULL) return NULL;\n\n    ListNode* slow = head;\n    ListNode* fast = head;\n\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n\n        if (slow == fast) break;\n    }\n\n    if (fast == NULL || fast->next == NULL) return NULL;\n\n    slow = head;\n    while (slow != fast) {\n        slow = slow->next;\n        fast = fast->next;\n    }\n\n    return fast;\n}\n\nint main() {\n    ListNode* node1 = new ListNode(3);\n    ListNode* node2 = new ListNode(2);\n    ListNode* node3 = new ListNode(0);\n    ListNode* node4 = new ListNode(-4);\n\n    node1->next = node2;\n    node2->next = node3;\n    node3->next = node4;\n\n    node4->next = node2;  // create a cycle\n\n    ListNode* res = detectCycle(node1);\n    if (res != NULL) {\n        std::cout << \"Detected cycle at node with value: \" << res->val << std::endl;\n    } else {\n        std::cout << \"No cycle found\" << std::endl;\n    }\n\n    delete node1; delete node2; delete node3; delete node4;\n\n    // Test case 2\n    node1 = new ListNode(1);\n    node2 = new ListNode(2);\n\n    node1->next = node2;\n\n    res = detectCycle(node1);\n    if (res != NULL) {\n        std::cout << \"Detected cycle at node with value: \" << res->val << std::endl;\n    } else {\n        std::cout << \"No cycle found\" << std::endl;\n    }\n\n    delete node1; delete node2;\n\n    // Test case 3\n    node1 = new ListNode(1);\n    node2 = new ListNode(2);\n\n    node1->next = node2;\n    node2->next = node1;  // create a cycle\n\n    res = detectCycle(node1);\n    if (res != NULL) {\n        std::cout << \"Detected cycle at node with value: \" << res->val << std::endl;\n    } else {\n        std::cout << \"No cycle found\" << std::endl;\n    }\n\n    delete node1; delete node2;\n\n    return 0;\n}\n```",
  "143": "```\n#include <iostream>\n#include <vector>\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nvoid reorderList(ListNode* head) {\n    // Write your code here. Note that this is just an example solution and may not work correctly.\n    if (!head || !head->next) return;\n\n    ListNode* slow = head, *fast = head;\n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    fast = slow->next;\n    slow->next = NULL;\n\n    ListNode* prev = nullptr, *curr = head;\n    while (curr) {\n        ListNode* nextTemp = curr->next;\n        curr->next = prev;\n        prev = curr;\n        curr = nextTemp;\n    }\n\n    curr = head;\n    int i = 1;\n    while (curr && fast) {\n        if (i % 2 == 0) {\n            slow = slow->next;\n        } else {\n            ListNode* nextTemp = curr->next;\n            curr->next = fast;\n            fast = nextTemp;\n        }\n        i++;\n        curr = curr->next;\n    }\n\n    if (fast) {\n        slow->next = fast;\n    }\n}\n\nint main() {\n    {\n        // Test 1:\n        ListNode* head = new ListNode(1);\n        head->next = new ListNode(2);\n        head->next->next = new ListNode(3);\n\n        reorderList(head);\n\n        for (ListNode* curr = head; curr; curr = curr->next) {\n            std::cout << curr->val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    {\n        // Test 2:\n        head = new ListNode(1);\n        head->next = new ListNode(5);\n        head->next->next = new ListNode(9);\n\n        reorderList(head);\n\n        for (ListNode* curr = head; curr; curr = curr->next) {\n            std::cout << curr->val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    {\n        // Test 3:\n        head = new ListNode(4);\n        head->next = new ListNode(2);\n\n        reorderList(head);\n\n        for (ListNode* curr = head; curr; curr = curr->next) {\n            std::cout << curr->val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```",
  "144": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode* root) {\n        vector<int> result;\n        if (root == NULL) return result;\n\n        stack<TreeNode*> st;\n        st.push(root);\n\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            st.pop();\n            result.push_back(node->val);\n            \n            if (node->right) st.push(node->right);\n            if (node->left)  st.push(node->left);\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(2);\n    vector<int> result1 = solution.preorderTraversal(root1);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(0);\n    root2->right = new TreeNode(1);\n    vector<int> result2 = solution.preorderTraversal(root2);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    TreeNode* root3 = NULL;\n    vector<int> result3 = solution.preorderTraversal(root3);\n    for (int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "145": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    std::vector<int> postorderTraversal(TreeNode* root) {\n        std::vector<int> result;\n        if (root == NULL) return result;\n\n        std::stack<TreeNode*> stack;\n        stack.push(root);\n\n        while (!stack.empty()) {\n            TreeNode* node = stack.top();\n            stack.pop();\n\n            if (node->left != NULL) stack.push(node->left);\n            if (node->right != NULL) stack.push(node->right);\n            result.push_back(node->val);\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(3);\n    root->left->left = new TreeNode(4);\n    root->left->right = new TreeNode(5);\n\n    std::vector<int> expected1 = {4, 5, 2, 3, 1};\n    auto result1 = solution.postorderTraversal(root);\n    for (int i : result1) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    root = new TreeNode(1);\n    root->left = new TreeNode(2);\n\n    expected1 = {2, 1};\n    auto result2 = solution.postorderTraversal(root);\n    for (int i : result2) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    root = NULL;\n\n    expected1 = {};\n    auto result3 = solution.postorderTraversal(root);\n    for (int i : result3) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "146": "```\n#include <iostream>\n#include <list>\n\nusing namespace std;\n\nclass Node {\npublic:\n    int key;\n    int value;\n    Node* prev;\n    Node* next;\n};\n\nclass LRUCache {\nprivate:\n    list<Node*> nodeList;\n    unordered_map<int, Node*> cacheMap;\n    int capacity;\n    \npublic:\n    LRUCache(int capacity) : capacity(capacity) {}\n    \n    void put(int key, int value) {\n        if (cacheMap.find(key) != cacheMap.end()) {\n            Node* node = cacheMap[key];\n            node->value = value;\n            nodeList.erase(nodeList.begin() + distance(nodeList.begin(), node));\n            nodeList.push_front(node);\n            return;\n        }\n        \n        Node* node = new Node();\n        node->key = key;\n        node->value = value;\n        node->prev = nullptr;\n        node->next = (nodeList.empty()) ? nullptr : nodeList.front();\n        \n        if (!nodeList.empty()) {\n            node->next->prev = node;\n        }\n        node->next = nullptr;\n        cacheMap[key] = node;\n        \n        if (nodeList.size() > capacity) {\n            Node* lruNode = nodeList.back();\n            cacheMap.erase(lruNode->key);\n            delete lruNode;\n            nodeList.pop_back();\n        } else {\n            nodeList.push_front(node);\n        }\n    }\n    \n    int get(int key) {\n        if (cacheMap.find(key) == cacheMap.end()) return -1;\n        \n        Node* node = cacheMap[key];\n        nodeList.erase(nodeList.begin() + distance(nodeList.begin(), node));\n        node->prev->next = node->next;\n        if (!node->next) {\n            node->next = nullptr;\n            node->prev = nullptr;\n        } else {\n            node->next->prev = node->prev;\n            node->prev->next = node->next;\n        }\n        \n        nodeList.push_front(node);\n        \n        return node->value;\n    }\n};\n\nint main() {\n    LRUCache cache(2);\n\n    cache.put(1, 1);\n    cache.put(2, 2);\n    cout << \"Get 1: \" << cache.get(1) << endl; // returns 1\n    cache.put(3, 3); \n    cout << \"Get 2: \" << cache.get(2) << endl; // returns 2\n    cout << \"Get 3: \" << cache.get(3) << endl; // returns 3\n    cache.put(4, 4);\n    cout << \"Get 1: \" << cache.get(1) << endl; // returns -1 (not found)\n    cout << \"Get 3: \" << cache.get(3) << endl; // returns 3\n\n    return 0;\n}\n```",
  "147": "```\n#include <iostream>\n#include <vector>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n};\n\nclass Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        if (!head) return head;\n\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* cur = head;\n        while (cur) {\n            ListNode* prev = dummyHead;\n            while (prev->next && prev->next->val < cur->val) {\n                prev = prev->next;\n            }\n            ListNode* nextNode = cur->next;\n            cur->next = prev->next;\n            prev->next = cur;\n            cur = nextNode;\n        }\n\n        return dummyHead->next;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    ListNode* head1 = new ListNode(3);\n    head1->next = new ListNode(4);\n    head1->next->next = new ListNode(5);\n    std::cout << \"Test Case 1: \";\n    for (ListNode* cur = solution.insertionSortList(head1); cur; cur = cur->next) {\n        std::cout << cur->val << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    std::cout << \"Test Case 2: \";\n    for (ListNode* cur = solution.insertionSortList(head1); cur; cur = cur->next) {\n        std::cout << cur->val << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    head1 = new ListNode(5);\n    head1->next = new ListNode(4);\n    head1->next->next = new ListNode(2);\n    head1->next->next->next = new ListNode(1);\n    std::cout << \"Test Case 3: \";\n    for (ListNode* cur = solution.insertionSortList(head1); cur; cur = cur->next) {\n        std::cout << cur->val << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
  "148": "```\n#include <iostream>\n#include <vector>\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nvoid mergeSort(ListNode** headRef, int n) {\n    if (*headRef == NULL || (**headRef).next == NULL)\n        return;\n\n    ListNode* prev = NULL;\n    ListNode* slow = *headRef;\n    ListNode* fast = *headRef;\n\n    while (fast != NULL && fast->next != NULL) {\n        prev = slow;\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    prev->next = NULL;\n\n    mergeSort(&(*headRef), n / 2);\n    mergeSort(&(slow), n - n / 2);\n\n    *headRef = merge(listToVec(headRef, n), listToVec(&(slow + 1), n - n / 2));\n}\n\nListNode* merge(ListNode** head1, ListNode** head2) {\n    ListNode* result = NULL;\n    if ((*head1)->val <= (*head2)->val) {\n        result = *head1;\n        *head1 = (*head1)->next;\n    } else {\n        result = *head2;\n        *head2 = (*head2)->next;\n    }\n\n    ListNode* current = result;\n\n    while (*head1 != NULL && *head2 != NULL) {\n        if ((*head1)->val <= (*head2)->val) {\n            current->next = *head1;\n            *head1 = (*head1)->next;\n        } else {\n            current->next = *head2;\n            *head2 = (*head2)->next;\n        }\n        current = current->next;\n    }\n\n    current->next = *head1 ? *head1 : *head2;\n\n    return result;\n}\n\nstd::vector<int> listToVec(ListNode** head, int n) {\n    std::vector<int> vec;\n    for (int i = 0; i < n; i++) {\n        vec.push_back((*head)->val);\n        (*head) = (*head)->next;\n    }\n    return vec;\n}\n\nvoid printList(ListNode* head, int n) {\n    for (int i = 0; i < n; i++) {\n        std::cout << head->val << \" \";\n        head = head->next;\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    ListNode* head1 = new ListNode(4);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(1);\n\n    mergeSort(&head1, 3);\n\n    printList(head1, 3);\n\n    head1 = nullptr;\n\n    head1 = new ListNode(-1);\n    head1->next = new ListNode(5);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(2);\n\n    mergeSort(&head1, 4);\n\n    printList(head1, 4);\n\n    head1 = nullptr;\n\n    head1 = new ListNode(3);\n    head1->next = new ListNode(5);\n    head1->next->next = new ListNode(-2);\n\n    mergeSort(&head1, 3);\n\n    printList(head1, 3);\n\n    return 0;\n}",
  "149": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint maxPoints(vector<vector<int>>& points) {\n    int n = points.size();\n    if (n <= 2) return n;\n\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        unordered_map<string, int> slopeCount;\n        int samePoint = 1;\n        for (int j = i + 1; j < n; j++) {\n            if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {\n                samePoint++;\n                continue;\n            }\n            string slope = get_slope(points[i], points[j]);\n            slopeCount[slope]++;\n        }\n        res = max(res, samePoint);\n        for (const auto& p : slopeCount) {\n            res = max(res, p.second + samePoint);\n        }\n    }\n    return res;\n}\n\nstring get_slope(vector<int>& p1, vector<int>& p2) {\n    int dx = p2[0] - p1[0];\n    int dy = p2[1] - p1[1];\n    if (dx == 0 && dy == 0) return \"inf\";\n    if (dx == 0) return \"0\";\n    return to_string(dy / gcd(dx, dy));\n}\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint main() {\n    vector<vector<int>> points1{{1,1},{2,2},{3,3}};\n    cout << \"Test case 1: \" << maxPoints(points1) << endl;\n\n    vector<vector<int>> points2{{0,0},{1,1},{2,2}};\n    cout << \"Test case 2: \" << maxPoints(points2) << endl;\n\n    vector<vector<int>> points3{{0,0},{5,5},{10,10}};\n    cout << \"Test case 3: \" << maxPoints(points3) << endl;\n    return 0;\n}\n```",
  "151": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nvoid reverseWordsInString(string& s) {\n    int left = 0;\n    for (int right = 0; right <= s.size(); right++) {\n        if (right == s.size() || s[right] == ' ') {\n            reverse(s.begin() + left, s.begin() + right);\n            left = right + 1;\n        }\n    }\n}\n\nint main() {\n    string s1 = \"God is Power\";\n    reverseWordsInString(s1);\n    cout << s1 << endl;\n\n    string s2 = \"hello world\";\n    reverseWordsInString(s2);\n    cout << s2 << endl;\n\n    string s3 = \"   Hello  World  \";\n    reverseWordsInString(s3);\n    cout << s3 << endl;\n    \n    return 0;\n}\n```",
  "150": "```\n#include <iostream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint evalRPN(vector<string>& tokens) {\n    stack<int> s;\n    for (const string& token : tokens) {\n        if (token == \"+\") {\n            int b = s.top(); s.pop();\n            int a = s.top(); s.pop();\n            s.push(a + b);\n        } else if (token == \"-\") {\n            int b = s.top(); s.pop();\n            int a = s.top(); s.pop();\n            s.push(a - b);\n        } else if (token == \"*\") {\n            int b = s.top(); s.pop();\n            int a = s.top(); s.pop();\n            s.push(a * b);\n        } else if (token == \"/\") {\n            int b = s.top(); s.pop();\n            int a = s.top(); s.pop();\n            s.push(a / b);\n        } else {\n            s.push(stoi(token));\n        }\n    }\n    return s.top();\n}\n\nint main() {\n    vector<string> tokens1 = {\"2\", \"1\", \"+\", \"3\"};\n    cout << evalRPN(tokens1) << endl;  // Output: 5\n\n    vector<string> tokens2 = {\"4\", \"13\", \"5\", \"/\", \"+\"};\n    cout << evalRPN(tokens2) << endl;  // Output: 6\n\n    vector<string> tokens3 = {\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"};\n    cout << evalRPN(tokens3) << endl;  // Output: 22\n    return 0;\n}\n```",
  "152": "```\n#include <iostream>\n#include <vector>\n\nint maxProduct(std::vector<int>& nums) {\n    int maxSoFar = nums[0];\n    int minSoFar = nums[0];\n    int result = nums[0];\n\n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] < 1) {\n            int temp = minSoFar;\n            minSoFar = maxSoFar;\n            maxSoFar = temp;\n        }\n\n        maxSoFar = std::max(nums[i], maxSoFar * nums[i]);\n        minSoFar = std::min(nums[i], minSoFar * nums[i]);\n\n        result = std::max(result, maxSoFar);\n    }\n\n    return result;\n}\n\nint main() {\n    int test1[] = {-2, 0, -1};\n    std::vector<int> v1(test1, test1 + sizeof(test1) / sizeof(test1[0]));\n    std::cout << \"Test case 1: \" << maxProduct(v1) << std::endl;\n\n    int test2[] = {2,3,-2,4};\n    std::vector<int> v2(test2, test2 + sizeof(test2) / sizeof(test2[0]));\n    std::cout << \"Test case 2: \" << maxProduct(v2) << std::endl;\n\n    int test3[] = [1,5,0,2,-3];\n    std::vector<int> v3(test3, test3 + sizeof(test3) / sizeof(test3[0]));\n    std::cout << \"Test case 3: \" << maxProduct(v3) << std::endl;\n\n    return 0;\n}",
  "153": "```\n#include <iostream>\n#include <vector>\n\nint findMin(std::vector<int>& nums) {\n    int left = 0;\n    int right = nums.size() - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else if (nums[mid] < nums[right]) {\n            right = mid;\n        } else {\n            right--;\n        }\n    }\n\n    return nums[left];\n}\n\nint main() {\n    std::vector<int> test1({3,4,5,1,2});\n    std::cout << \"Test 1: \" << findMin(test1) << std::endl;\n\n    std::vector<int> test2({2,1});\n    std::cout << \"Test 2: \" << findMin(test2) << std::endl;\n\n    std::vector<int> test3({4,5,6,7,0,1,2});\n    std::cout << \"Test 3: \" << findMin(test3) << std::endl;\n\n    return 0;\n}\n```",
  "154": "```\n#include <iostream>\n#include <vector>\n\nint findMin(std::vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n    \n    while (left < right) {\n        if (nums[left] <= nums[right]) {\n            right--;\n        } else {\n            return nums[left];\n        }\n    }\n    \n    return nums[0];\n}\n\nint main() {\n    std::vector<int> test1({1,3,5});\n    std::cout << \"Test 1: \" << findMin(test1) << std::endl;\n    \n    std::vector<int> test2({2,2,2,1,3,4,5});\n    std::cout << \"Test 2: \" << findMin(test2) << std::endl;\n    \n    std::vector<int> test3({4,5,6,7,0,1,2});\n    std::cout << \"Test 3: \" << findMin(test3) << std::endl;\n\n    return 0;\n}\n```",
  "155": "```\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nclass MinStack {\npublic:\n    void push(int x) {\n        stack.push(x);\n        if (minStack.empty() || x <= minStack.top()) {\n            minStack.push(x);\n        }\n    }\n\n    void pop() {\n        if (!stack.empty()) {\n            int top = stack.top();\n            stack.pop();\n            if (top == minStack.top()) {\n                minStack.pop();\n            }\n        }\n    }\n\n    int top() {\n        return stack.top();\n    }\n\n    int getMin() {\n        return minStack.top();\n    }\n\nprivate:\n    stack<int> stack;\n    stack<int> minStack;\n};\n\nint main() {\n    MinStack ms;\n\n    // Test case 1: Push and pop a few elements\n    ms.push(10);\n    ms.push(20);\n    cout << \"Min value: \" << ms.getMin() << endl; // Output: 10\n    ms.pop();\n    cout << \"Min value: \" << ms.getMin() << endl; // Output: 10\n    ms.push(5);\n    cout << \"Min value: \" << ms.getMin() << endl; // Output: 5\n\n    // Test case 2: Push a few more elements and pop everything\n    ms.push(25);\n    ms.push(15);\n    ms.push(30);\n    while (!ms.stack.empty()) {\n        ms.pop();\n    }\n    cout << \"Min value: \" << ms.getMin() << endl; // Output: -1 (stack is empty)\n\n    // Test case 3: Push a few more elements and pop everything\n    ms.push(40);\n    ms.push(35);\n    while (!ms.stack.empty()) {\n        ms.pop();\n    }\n    cout << \"Min value: \" << ms.getMin() << endl; // Output: -1 (stack is empty)\n\n    return 0;\n}\n```",
  "156": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* upsideDown(TreeNode* root) {\n    if (!root || !root->left) return root;\n\n    TreeNode* newRoot = root->left;\n    root->left = root->right;\n    root->right = newRoot->right;\n    newRoot->right = root;\n\n    return newRoot;\n}\n\nint main() {\n    // Test 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->left->left = new TreeNode(4);\n    root1->left->right = new TreeNode(5);\n\n    TreeNode* result1 = upsideDown(root1);\n    std::cout << \"Test 1: \";\n    printTree(result1); // Expected output: [4, 2, 5, 3, 1]\n\n    // Test 2\n    root1 = nullptr;\n\n    result1 = upsideDown(root1);\n    std::cout << \"Test 2: \";\n    printTree(result1); // Expected output: []\n\n    // Test 3\n    root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n\n    result1 = upsideDown(root1);\n    std::cout << \"Test 3: \";\n    printTree(result1); // Expected output: [2, 1]\n\n    return 0;\n}\n\nvoid printTree(TreeNode* root) {\n    if (root == nullptr) return;\n\n    printTree(root->left);\n    std::cout << root->val << \" \";\n    printTree(root->right);\n}\n```",
  "157": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int read4(char *buf) {\n        // implement this function\n    }\n};\n\nint main() {\n    Solution solution;\n    char buf[1001];\n    \n    int n = 7; // number of characters to read\n    \n    for(int i=0; i<n; i++) {\n        while(read4(buf)<4){\n            // do nothing\n        }\n    }\n    \n    std::cout << \"Test case 1: \";\n    for(int i=0; i<n; i++) {\n        if(i>=7) break;\n        printf(\"%c\", buf[i]);\n    }printf(\"\\n\");\n    \n    n = 3; // number of characters to read\n    for(int i=0; i<n; i++) {\n        while(read4(buf)<4){\n            // do nothing\n        }\n    }\n    \n    std::cout << \"Test case 2: \";\n    for(int i=0; i<n; i++) {\n        if(i>=3) break;\n        printf(\"%c\", buf[i]);\n    }printf(\"\\n\");\n    \n    n = 10; // number of characters to read\n    for(int i=0; i<n; i++) {\n        while(read4(buf)<4){\n            // do nothing\n        }\n    }\n    \n    std::cout << \"Test case 3: \";\n    for(int i=0; i<n; i++) {\n        if(i>=10) break;\n        printf(\"%c\", buf[i]);\n    }printf(\"\\n\");\n    \n    return 0;\n}\n```",
  "158": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int read4(char *buf) {\n        // implement your solution here\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    char buffer[10001]; // Read4 will not read more than 4000 characters at a time, so we use an array of size 10001.\n    cout << \"Test Case 1: \" << solution.readBuffer(\"abcde\", buffer) << endl; \n    cout << \"Test Case 2: \" << solution.readBuffer(\"Hello World!\", buffer) << endl;\n    cout << \"Test Case 3: \" << solution.readBuffer(\"Hello, world!\", buffer) << endl;\n\n    return 0;\n}\n\n```",
  "159": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int lengthOfLongestSubstringTwoDistinct(string s) {\n        int n = s.length();\n        int ans = 0, i = 0;\n        unordered_map<char, int> mp;\n        for (int j = 0; j < n; j++) {\n            while (mp.size() > 2 && i <= j)\n                if (--mp[s[i++]] == 0) mp.erase(s[i - 1]);\n            mp[s[j]]++;\n            ans = max(ans, j - i + 1);\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution sol;\n    cout << \"Test case 1: s = \\\"abc\\\"\\n\";\n    cout << \"Expected output: 3\\n\";\n    cout << \"Actual output: \" << sol.lengthOfLongestSubstringTwoDistinct(\"abc\") << \"\\n\" << endl;\n\n    cout << \"Test case 2: s = \\\"aaabbbccc\\\"\\n\";\n    cout << \"Expected output: 7\\n\";\n    cout << \"Actual output: \" << sol.lengthOfLongestSubstringTwoDistinct(\"aaabbbccc\") << \"\\n\" << endl;\n\n    cout << \"Test case 3: s = \\\"abcdefghijklmnopqrstuvwxyz\\\"\\n\";\n    cout << \"Expected output: 26\\n\";\n    cout << \"Actual output: \" << sol.lengthOfLongestSubstringTwoDistinct(\"abcdefghijklmnopqrstuvwxyz\") << \"\\n\" << endl;\n}",
  "161": "```\n#include <iostream>\n#include <vector>\n\nbool isOneEditDistance(const std::string& s1, const std::string& s2) {\n    int m = s1.size();\n    int n = s2.size();\n\n    if (m > n) {\n        std::swap(m, n);\n        std::swap(s1, s2);\n    }\n\n    for (int i = 0; i < m && i < n; ++i) {\n        if (s1[i] != s2[i]) {\n            return s1.substr(i) == s2.substr(n) || s1.substr(i + 1) == s2;\n        }\n    }\n\n    return std::abs(m - n) <= 1;\n}\n\nint main() {\n    std::vector<std::pair<std::string, bool>> testCases = {\n        {\"\", \"0\"}, {\"a\", \"b\"}, {\"ab\", \"ac\"}\n    };\n\n    for (const auto& testCase : testCases) {\n        if (isOneEditDistance(testCase.first, testCase.second)) {\n            std::cout << \"Test case passed: \" << testCase.first << \", \" << testCase.second << std::endl;\n        } else {\n            std::cout << \"Test case failed: \" << testCase.first << \", \" << testCase.second << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "160": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n        if (!headA || !headB)\n            return NULL;\n\n        int lenA = 0, lenB = 0;\n        ListNode *tempA = headA, *tempB = headB;\n\n        // calculate the length of linked list A and B\n        while (tempA) {\n            lenA++;\n            tempA = tempA->next;\n        }\n        while (tempB) {\n            lenB++;\n            tempB = tempB->next;\n        }\n\n        // move pointer A to the end - lenB positions from start\n        for (int i = 0; i < lenA - lenB; i++)\n            headA = headA->next;\n\n        // move pointer B to the end - lenA positions from start\n        for (int i = 0; i < lenB - lenA; i++)\n            headB = headB->next;\n\n        // when the pointers meet, they are at the intersection node\n        while (headA && headB) {\n            if (headA == headB)\n                return headA;\n            headA = headA->next;\n            headB = headB->next;\n        }\n        \n        return NULL;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    ListNode* node1 = new ListNode(8);\n    ListNode* node2 = new ListNode(4);\n    ListNode* node3 = new ListNode(5);\n    ListNode* node4 = new ListNode(0);\n\n    node1->next = node2;\n    node2->next = node3;\n    node3->next = node4;\n\n    ListNode* headA = node1;\n    ListNode* headB = node4;\n\n    ListNode* result = solution.getIntersectionNode(headA, headB);\n    cout << \"Test case 1: \";\n    if (result) {\n        cout << \"Intersection found: \" << result->val << endl;\n    } else {\n        cout << \"No intersection found\" << endl;\n    }\n\n    // Test case 2:\n    node1 = new ListNode(2);\n    node2 = new ListNode(6);\n    node3 = new ListNode(5);\n    node4 = new ListNode(1);\n\n    node1->next = node2;\n    node2->next = node3;\n    node3->next = node4;\n\n    headA = node1;\n    headB = node4;\n\n    result = solution.getIntersectionNode(headA, headB);\n    cout << \"Test case 2: \";\n    if (result) {\n        cout << \"Intersection found: \" << result->val << endl;\n    } else {\n        cout << \"No intersection found\" << endl;\n    }\n\n    // Test case 3:\n    node1 = new ListNode(4);\n    node2 = new ListNode(1);\n\n    headA = node1;\n    headB = node2;\n\n    result = solution.getIntersectionNode(headA, headB);\n    cout << \"Test case 3: \";\n    if (result) {\n        cout << \"Intersection found: \" << result->val << endl;\n    } else {\n        cout << \"No intersection found\" << endl;\n    }\n\n    return 0;\n}\n\n```",
  "162": "```\n#include <iostream>\n#include <vector>\n\nint findPeakElement(std::vector<int>& nums) {\n    int left = 0, right = nums.size() - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] < nums[mid + 1]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n\nint main() {\n    std::vector<int> test1 = {1, 2, 3, 1};\n    std::cout << \"Test case 1: \" << findPeakElement(test1) << std::endl;\n\n    std::vector<int> test2 = {1, 2, 1, 3, 5, 6, 4};\n    std::cout << \"Test case 2: \" << findPeakElement(test2) << std::endl;\n\n    std::vector<int> test3 = {0, 2, 1};\n    std::cout << \"Test case 3: \" << findPeakElement(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "163": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<std::string> findMissingRanges(std::vector<int>& nums) {\n    std::vector<std::string> result;\n    if (nums.size() == 0) {\n        return {\"[]\"};\n    }\n\n    for (int i = 0; i < nums.size(); i++) {\n        int start = nums[i];\n        while ((i + 1 < nums.size()) && (nums[i + 1] <= start)) {\n            i++;\n            start = nums[i];\n        }\n        if (start > nums[0]) {\n            result.push_back({\"\" + std::to_string(nums[0]) + \"->\" + std::to_string(start - 1)});\n        }\n        while ((i + 1 < nums.size()) && (nums[i + 1] <= start)) {\n            i++;\n        }\n        if ((i + 1) < nums.size()) {\n            result.push_back({\"\" + std::to_string(start + 1) + \"->\" + std::to_string(nums[i])});\n        } else {\n            result.push_back({\"\" + std::to_string(start + 1) + \"}\"]);\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int nums1[] = {0,1,3,4,6};\n    std::vector<int> nums2(nums1, nums1+5);\n    for (const auto& missingRange : findMissingRanges(nums2)) {\n        std::cout << \"missing range: \" << missingRange << std::endl;\n    }\n\n    int nums3[] = {8,10,15,17};\n    std::vector<int> nums4(nums3, nums3+5);\n    for (const auto& missingRange : findMissingRanges(nums4)) {\n        std::cout << \"missing range: \" << missingRange << std::endl;\n    }\n\n    int nums5[] = {0};\n    std::vector<int> nums6(nums5, nums5+1);\n    for (const auto& missingRange : findMissingRanges(nums6)) {\n        std::cout << \"missing range: \" << missingRange << std::endl;\n    }\n\n    return 0;\n}\n```",
  "164": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumGap(vector<int>& nums) {\n        if(nums.size() < 2)\n            return 0;\n        \n        int n = nums.size();\n        vector<int> minn(n, INT_MAX);\n        vector<int> maxn(n, INT_MIN);\n        \n        for(int i=0; i<n; i++){\n            minn[i] = min(minn[i], (int)nums[i]);\n            maxn[i] = max(maxn[i], nums[i]);\n        }\n        \n        for(int i=1; i<=n-1; i+=2){\n            int j = i+1;\n            while(j<n && nums[j]<=maxn[i]){\n                minn[j] = min(minn[j], nums[j]);\n                maxn[j] = max(maxn[j], nums[j]);\n                j++;\n            }\n        }\n        \n        int res = 0;\n        for(int i=0; i<n-1; i++){\n            if(maxn[i] < minn[i+1]){\n                res = max(res, minn[i+1]-maxn[i]);\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> nums1({3,6,7,19});\n    cout << \"Test case 1: \" << solution.maximumGap(nums1) << endl;\n\n    vector<int> nums2({0,4,8,10});\n    cout << \"Test case 2: \" << solution.maximumGap(nums2) << endl;\n\n    vector<int> nums3({1,5,3,24,45,38});\n    cout << \"Test case 3: \" << solution.maximumGap(nums3) << endl;\n    return 0;\n}\n```",
  "165": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool compareVersion(std::vector<std::string>& version1, std::vector<std::string>& version2) {\n    int i = 0, j = 0;\n    \n    while (i < version1.size() || j < version2.size()) {\n        while (i < version1.size() && !version1[i].compare(0, \"*\", \"\")) i++;\n        while (j < version2.size() && !version2[j].compare(0, \"*\", \"\")) j++;\n        \n        if (!version1[i].compare(0, version2[j].size(), version2[j])) {\n            if (i == version1.size()) return false;\n            i++;\n        } else if (!version2[j].compare(0, version1[i].size(), version1[i])) {\n            if (j == version2.size()) return true;\n            j++;\n        } else if (version1[i] > version2[j]) {\n            return true;\n        } else {\n            i++;\n            j++;\n        }\n    }\n    \n    return false;\n}\n\nint main() {\n    std::vector<std::string> v1 = {\"1\", \"1\", \"6\"};\n    std::vector<std::string> v2 = {\"1\", \"1\", \"5\"};\n    std::cout << (compareVersion(v1, v2) ? \"Greater\" : \"Less\") << std::endl;\n\n    v1 = {\"0\", \"5\", \"2\", \"3\"};\n    v2 = {\"2\", \"5\"};\n    std::cout << (compareVersion(v1, v2) ? \"Greater\" : \"Less\") << std::endl;\n\n    v1 = {\"1\", \"7\", \"3\", \"4\", \"8\"};\n    v2 = {\"1\", \"6\", \"5\", \"9\", \"2\", \"3\"};\n    std::cout << (compareVersion(v1, v2) ? \"Greater\" : \"Less\") << std::endl;\n\n    return 0;\n}\n```",
  "166": "```\n#include <iostream>\n#include <string>\n\nstd::string fractionToDecimal(int numerator, int denominator) {\n    long num = numerator;\n    long denom = denominator;\n    \n    if (num == 0) return \"0\";\n    if ((num > 0) ^ (denom > 0)) return \"-\" + fractionToDecimal(-num, -denom);\n    \n    std::string result = \"\";\n    int remainder = (int)(num % denom);\n    \n    if (!remainder) {\n        result += \"0\";\n        num /= denom;\n    }\n    \n    while (num) {\n        remainder *= 10;\n        int temp = num * 10;\n        \n        while ((temp >= denom) && (temp - denom)) {\n            temp -= denom;\n            result += '9';\n        }\n        \n        if (!temp) break;\n        else if (remainder == denom) {\n            result += \"(\" + fractionToDecimal(temp, denom) + \")\";\n            return result;\n        } else {\n            result += \".\" + std::to_string(remainder/denom);\n            num = temp;\n            remainder %= denom;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    std::cout << fractionToDecimal(2, 1) << std::endl; // Output: \"2\"\n    std::cout << fractionToDecimal(0, 1) << std::endl; // Output: \"0\"\n    std::cout << fractionToDecimal(49, 6) << std::endl; // Output: \"8.166666666666667\"\n    \n    return 0;\n}",
  "167": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int left = 0;\n        int right = numbers.size() - 1;\n        \n        while (left <= right) {\n            int sum = numbers[left] + numbers[right];\n            \n            if (sum == target)\n                return {numbers[left], numbers[right]};\n            else if (sum < target)\n                left++;\n            else\n                right--;\n        }\n        \n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<int> nums1 = {-5, -3, 2, -2};\n    int target1 = -8;\n    cout << \"Test case 1: \";\n    for (auto num : solution.twoSum(nums1, target1))\n        cout << num << \" \";\n    cout << endl;\n    \n    vector<int> nums2 = [0, 4, 3, 0];\n    int target2 = 0;\n    cout << \"Test case 2: \";\n    for (auto num : solution.twoSum(nums2, target2))\n        cout << num << \" \";\n    cout << endl;\n    \n    vector<int> nums3 = {1, 2};\n    int target3 = 3;\n    cout << \"Test case 3: \";\n    for (auto num : solution.twoSum(nums3, target3))\n        cout << num << \" \";\n    cout << endl;\n    \n    return 0;\n}\n```",
  "168": "```\n#include <iostream>\n#include <string>\n\nstd::string columnTitle(int n) {\n    std::string result = \"\";\n    while (n > 0) {\n        int remainder = n % 26;\n        if (remainder == 0) {\n            remainder = 26;\n            n--;\n        }\n        result = (char)(64 + remainder) + result;\n        n /= 26;\n    }\n    return result;\n}\n\nint main() {\n    std::cout << columnTitle(1) << std::endl; // \"A\"\n    std::cout << columnTitle(28) << std::endl; // \"AB\"\n    std::cout << columnTitle(701) << std::endl; // \"ZY\"\n    return 0;\n}\n```",
  "169": "```\n#include <iostream>\n#include <vector>\n\nint majorityElement(std::vector<int>& nums) {\n    int count = 0;\n    int candidate = 0;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> nums1 = {2, 2, 1, 1, 1, 2, 2};\n    int result1 = majorityElement(nums1);\n    if (result1 == 2) {\n        std::cout << \"Test case 1: Pass\\n\";\n    } else {\n        std::cout << \"Test case 1: Fail\\n\";\n    }\n\n    // Test case 2\n    std::vector<int> nums2 = {3, 2, 3};\n    int result2 = majorityElement(nums2);\n    if (result2 == 3) {\n        std::cout << \"Test case 2: Pass\\n\";\n    } else {\n        std::cout << \"Test case 2: Fail\\n\";\n    }\n\n    // Test case 3\n    std::vector<int> nums3 = {1, 2};\n    int result3 = majorityElement(nums3);\n    if (result3 == 1) {\n        std::cout << \"Test case 3: Pass\\n\";\n    } else {\n        std::cout << \"Test case 3: Fail\\n\";\n    }\n\n    return 0;\n}\n```",
  "170": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass TwoSumIII {\npublic:\n    void add(int num) {\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] + num == 0) {\n                indices.push_back({i, nums.size()});\n                return;\n            }\n        }\n        nums.push_back(num);\n    }\n\n    bool find(int target) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = 0; j < indices.size(); j++) {\n                if (nums[i] + (target - nums[indices[j][0]]) == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\nprivate:\n    vector<int> nums;\n    vector<pair<int, int>> indices;\n};\n\nint main() {\n    TwoSumIII twoSum;\n\n    // Test case 1\n    twoSum.add(-1);\n    twoSum.add(0);\n    twoSum.add(1);\n    cout << (twoSum.find(0) ? \"True\" : \"False\") << endl;  // Output: True\n\n    // Test case 2\n    twoSum.add(-5);\n    twoSum.add(-4);\n    twoSum.add(3);\n    twoSum.add(-2);\n    cout << (twoSum.find(-1) ? \"True\" : \"False\") << endl;  // Output: True\n\n    // Test case 3\n    twoSum.add(0);\n    twoSum.add(0);\n    twoSum.add(0);\n    cout << (twoSum.find(0) ? \"True\" : \"False\") << endl;  // Output: True\n\n    return 0;\n}\n```",
  "171": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int columnNumber(string s) {\n        int res = 0;\n        for (char c : s) {\n            res *= 26;\n            if (c >= 'A' && c <= 'Z')\n                res += c - 'A' + 1;\n            else\n                res += c - 'a' + 1;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << solution.columnNumber(\"A\") << endl; // Expected output: 1\n    cout << \"Test case 2: \" << solution.columnNumber(\"AB\") << endl; // Expected output: 28\n    cout << \"Test case 3: \" << solution.columnNumber(\"ZY\") << endl; // Expected output: 701\n\n    return 0;\n}\n```",
  "172": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findFactorialTrailingZeroes(int n) {\n        int count = 0;\n        for (int i = 5; n / i >= 1; i *= 5)\n            count += n / i;\n        return count;\n    }\n};\n\nint main() {\n    Solution sol;\n    \n    cout << \"Test case 1: \" << sol.findFactorialTrailingZeroes(3) << endl; // Expected output: 0\n    cout << \"Test case 2: \" << sol.findFactorialTrailingZeroes(4) << endl; // Expected output: 1\n    cout << \"Test case 3: \" << sol.findFactorialTrailingZeroes(10) << endl; // Expected output: 2\n    \n    return 0;\n}\n```",
  "174": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumUnits(vector<vector<int>>& boxCount) {\n        int res = 0;\n        for (const auto& v : boxCount) {\n            for (int i = 0; i < v.size(); ++i) {\n                res += v[i] * min(i + 1, v[0]);\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> boxCount1 = {{1,3}, {2,3}, {3,1}};\n    cout << \"Test case 1: \" << solution.maximumUnits(boxCount1) << endl; \n\n    // Test case 2\n    vector<vector<int>> boxCount2 = {{5,10}, {10,6}, {8,9}};\n    cout << \"Test case 2: \" << solution.maximumUnits(boxCount2) << endl;\n\n    // Test case 3\n    vector<vector<int>> boxCount3 = {{1,1}, {3,5}, {4,3}, {7,2}};\n    cout << \"Test case 3: \" << solution.maximumUnits(boxCount3) << endl;\n\n    return 0;\n}\n```",
  "173": "```\n#include <iostream>\n#include <stack>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass BSTIterator {\npublic:\n    BSTIterator(TreeNode* root) {\n        stack<TreeNode*> st;\n        pushLeft(root, st);\n    }\n\n    int next() {\n        while (!st.empty()) {\n            TreeNode* node = st.top();\n            st.pop();\n            return node->val;\n        }\n        return -1; // not found\n    }\n\n    bool hasNext() {\n        return !st.empty();\n    }\n\nprivate:\n    void pushLeft(TreeNode* node, std::stack<TreeNode*>& st) {\n        while (node) {\n            st.push(node);\n            node = node->left;\n        }\n    }\n};\n\nint main() {\n    TreeNode* root1 = new TreeNode(2);\n    root1->right = new TreeNode(5);\n    root1->right->right = new TreeNode(7);\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(4);\n\n    TreeNode* root3 = nullptr; // empty tree\n\n    BSTIterator iter1(root1);\n    for (int i = 0; i < 3; ++i) {\n        std::cout << iter1.next() << \" \";\n    }\n    std::cout << std::endl;\n\n    BSTIterator iter2(root2);\n    for (int i = 0; i < 4; ++i) {\n        std::cout << iter2.next() << \" \";\n    }\n    std::cout << std::endl;\n\n    BSTIterator iter3(root3);\n    while (iter3.hasNext()) {\n        std::cout << iter3.next() << \" \";\n    }\n    std::cout << std::endl;\n}\n```",
  "175": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Record {\n    int id;\n    std::string name;\n};\n\nint main() {\n    // Test case 1\n    {\n        std::vector<Record> table1 = {{1, \"John\"}, {2, \"Jane\"}};\n        std::vector<Record> table2 = {{1, \"Johnny\"}, {3, \"Jim\"}};\n        \n        for (const auto& record : combineTables(table1, table2)) {\n            std::cout << \"ID: \" << record.id << \", Name: \" << record.name << std::endl;\n        }\n    }\n\n    // Test case 2\n    {\n        std::vector<Record> table1 = {{1, \"Alice\"}, {2, \"Bob\"}};\n        std::vector<Record> table2 = {{1, \"Ally\"}, {3, \"Barb\"}};\n        \n        for (const auto& record : combineTables(table1, table2)) {\n            std::cout << \"ID: \" << record.id << \", Name: \" << record.name << std::endl;\n        }\n    }\n\n    // Test case 3\n    {\n        std::vector<Record> table1 = {{1, \"Charlie\"}, {2, \"Daisy\"}};\n        std::vector<Record> table2 = {{1, \"Chet\"}, {3, \"Donna\"}};\n        \n        for (const auto& record : combineTables(table1, table2)) {\n            std::cout << \"ID: \" << record.id << \", Name: \" << record.name << std::endl;\n        }\n    }\n\n    return 0;\n}\n\nstd::vector<Record> combineTables(const std::vector<Record>& table1, const std::vector<Record>& table2) {\n    // Your logic to combine the two tables\n    std::vector<Record> combinedTable = table1;\n    for (const auto& record : table2) {\n        bool found = false;\n        for (auto& existingRecord : combinedTable) {\n            if (existingRecord.id == record.id) {\n                existingRecord.name = record.name;\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            combinedTable.push_back(record);\n        }\n    }\n    return combinedTable;\n}\n```",
  "176": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nstruct Employee {\n    std::string id;\n    int salary;\n};\n\nstd::vector<std::string> secondHighestSalary(std::vector<Employee>& employees) {\n    if (employees.size() < 2) return {};\n\n    int highest = 0, secondHighest = -1;\n\n    for (const auto& employee : employees) {\n        if (employee.salary > highest) {\n            secondHighest = highest;\n            highest = employee.salary;\n        } else if (employee.salary < highest && employee.salary > secondHighest) {\n            secondHighest = employee.salary;\n        }\n    }\n\n    std::vector<std::string> result;\n    for (const auto& employee : employees) {\n        if (employee.salary == secondHighest) {\n            result.push_back(employee.id);\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    Employee employees[] = {\n        {\"1\", 1000000}, {\"2\", 2000000}, {\"3\", 500000}\n    };\n    std::vector<Employee> employeesVec(employees, employees + sizeof(employees) / sizeof(employees[0]));\n\n    std::cout << \"Test Case 1: \";\n    for (const auto& id : secondHighestSalary(employeesVec)) {\n        std::cout << id << \" \";\n    }\n    std::cout << std::endl;\n\n    employeesVec = {\n        {\"1\", 2000000}, {\"2\", 1000000}, {\"3\", 500000}\n    };\n\n    std::cout << \"Test Case 2: \";\n    for (const auto& id : secondHighestSalary(employeesVec)) {\n        std::cout << id << \" \";\n    }\n    std::cout << std::endl;\n\n    employeesVec = {\n        {\"1\", 2000000}, {\"2\", 500000}, {\"3\", 1000000}\n    };\n\n    std::cout << \"Test Case 3: \";\n    for (const auto& id : secondHighestSalary(employeesVec)) {\n        std::cout << id << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "177": "```\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int nthHighestSalary(vector<vector<int>>& salaries, int n) {\n        set<int> uniqueSalaries;\n        for (const auto& salary : salaries) {\n            uniqueSalaries.insert(salary[1]);\n        }\n        \n        vector<int> sortedUniqueSalaries(uniqueSalaries.begin(), uniqueSalaries.end());\n        sort(sortedUniqueSalaries.rbegin(), sortedUniqueSalaries.rend());\n        \n        return sortedUniqueSalaries[n-1];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> salaries1 = {{1,1000000},{2,2000000}};\n    int result1 = solution.nthHighestSalary(salaries1, 1);\n    cout << \"Test case 1: Expected 1000000, got \" << result1 << endl;\n\n    // Test case 2\n    vector<vector<int>> salaries2 = {{1,1000000},{2,2000000},{3,3000000}};\n    int result2 = solution.nthHighestSalary(salaries2, 2);\n    cout << \"Test case 2: Expected 2000000, got \" << result2 << endl;\n\n    // Test case 3\n    vector<vector<int>> salaries3 = {{1,1000000},{2,2000000},{3,3000000},{4,4000000}};\n    int result3 = solution.nthHighestSalary(salaries3, 3);\n    cout << \"Test case 3: Expected 3000000, got \" << result3 << endl;\n\n    return 0;\n}\n```",
  "178": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<std::string> findRelativeRanks(std::vector<int>& score) {\n        std::vector<std::pair<int, int>> pairs;\n        for (int i = 0; i < score.size(); i++) {\n            pairs.push_back({score[i], i});\n        }\n        std::sort(pairs.begin(), pairs.end());\n        \n        std::vector<std::string> res(score.size());\n        for (int i = 0; i < score.size(); i++) {\n            if (i == 0) {\n                res[pairs[i].second] = \"Gold Medal\";\n            } else if (i == 1) {\n                res[pairs[i].second] = \"Silver Medal\";\n            } else if (i == 2) {\n                res[pairs[i].second] = \"Bronze Medal\";\n            } else {\n                res[pairs[i].second] = std::to_string(i + 1);\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> score1 = {5, 4, 8, 5, 11};\n    auto result1 = solution.findRelativeRanks(score1);\n    for (const auto& str : result1) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<int> score2 = {2, 20, 3};\n    auto result2 = solution.findRelativeRanks(score2);\n    for (const auto& str : result2) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<int> score3 = {0, 0, 0};\n    auto result3 = solution.findRelativeRanks(score3);\n    for (const auto& str : result3) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "179": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string largestNumber(std::vector<std::string>& nums) {\n    std::vector<std::string> result;\n    for (const auto& num : nums) {\n        while (!result.empty() && result.back().size() <= num.size()) {\n            if (result.back().compare(0, num.size(), num) < 0) {\n                break;\n            }\n            result.pop_back();\n        }\n        result.push_back(num);\n    }\n    std::string res = \"\";\n    for (const auto& num : result) {\n        res += num;\n    }\n    return res.length() == 1 ? \"0\" : res;\n}\n\nint main() {\n    {\n        std::vector<std::string> nums = {\"3\", \"6\", \"9\"};\n        std::cout << largestNumber(nums) << std::endl; // expected output: \"963\"\n    }\n\n    {\n        std::vector<std::string> nums = {\"1\", \"2\", \"3\"};\n        std::cout << largestNumber(nums) << std::endl; // expected output: \"321\"\n    }\n\n    {\n        std::vector<std::string> nums = {\"4\", \"5\", \"6\", \"7\", \"8\", \"9\"};\n        std::cout << largestNumber(nums) << std::endl; // expected output: \"987654\"\n    }\n    return 0;\n}\n```",
  "180": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> findConsecutive(int n) {\n        vector<vector<int>> res;\n        for (int i = 1; ; i++) {\n            int x = i * (i + 1) / 2;\n            if (x > n) break;\n            res.push_back({x, i});\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n1 = 9;\n    vector<vector<int>> result1 = solution.findConsecutive(n1);\n    for (const auto& pair : result1) {\n        cout << \"Consecutive numbers from 1 to \" << pair[1] << \": \";\n        for (int i = pair[0]; i < pair[0] + pair[1]; i++) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    int n2 = 15;\n    vector<vector<int>> result2 = solution.findConsecutive(n2);\n    for (const auto& pair : result2) {\n        cout << \"Consecutive numbers from 1 to \" << pair[1] << \": \";\n        for (int i = pair[0]; i < pair[0] + pair[1]; i++) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    int n3 = 20;\n    vector<vector<int>> result3 = solution.findConsecutive(n3);\n    for (const auto& pair : result3) {\n        cout << \"Consecutive numbers from 1 to \" << pair[1] << \": \";\n        for (int i = pair[0]; i < pair[0] + pair[1]; i++) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "181": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Employee {\n    std::string name;\n    int salary;\n};\n\nbool compareEmployees(const Employee& e1, const Employee& e2) {\n    return e1.salary > e2.salary;\n}\n\nint main() {\n    // Test case 1\n    std::vector<Employee> employees = {{\"Joe\", 100}, {\"John\", 150}, {\"Mary\", 120}};\n    for (auto employee : employees) {\n        if (employee.name == \"John\") {\n            continue;  // Skip John's salary comparison\n        }\n        for (int i = 0; i < employees.size(); i++) {\n            if (i != employees.size() - 1 && employees[i].salary > employees[i + 1].salary) {\n                std::cout << \"Error: Employees Earning More Than Their Managers not met\" << std::endl;\n                return 1;\n            }\n        }\n    }\n\n    // Test case 2\n    employees = {{\"Alice\", 80}, {\"Bob\", 90}, {\"Charlie\", 70}};\n    for (auto employee : employees) {\n        if (employee.name == \"Bob\") {\n            continue;  // Skip Bob's salary comparison\n        }\n        for (int i = 0; i < employees.size(); i++) {\n            if (i != employees.size() - 1 && employees[i].salary > employees[i + 1].salary) {\n                std::cout << \"Error: Employees Earning More Than Their Managers not met\" << std::endl;\n                return 1;\n            }\n        }\n    }\n\n    // Test case 3\n    employees = {{\"Eve\", 100}, {\"Frank\", 90}, {\"Gina\", 110}};\n    for (auto employee : employees) {\n        if (employee.name == \"Frank\") {\n            continue;  // Skip Frank's salary comparison\n        }\n        for (int i = 0; i < employees.size(); i++) {\n            if (i != employees.size() - 1 && employees[i].salary > employees[i + 1].salary) {\n                std::cout << \"Error: Employees Earning More Than Their Managers not met\" << std::endl;\n                return 1;\n            }\n        }\n    }\n\n    std::cout << \"All test cases passed.\" << std::endl;\n\n    return 0;\n}\n```",
  "182": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> findDuplicates(std::vector<std::pair<std::string, int>>& emails) {\n    std::vector<std::string> duplicates;\n    std::unordered_map<std::string, int> emailCount;\n\n    for (const auto& email : emails) {\n        if (emailCount.find(email.first) != emailCount.end()) {\n            emailCount[email.first]++;\n        } else {\n            emailCount[email.first] = 1;\n        }\n    }\n\n    for (const auto& pair : emailCount) {\n        if (pair.second > 1) {\n            duplicates.push_back(pair.first);\n        }\n    }\n\n    return duplicates;\n}\n\nint main() {\n    std::vector<std::pair<std::string, int>> emails;\n\n    // Test Case 1\n    emails = {{\"john@example.com\", 1}, {\"jane@example.com\", 2}, {\"john@example.com\", 3}};\n    auto result = findDuplicates(emails);\n    for (const auto& email : result) {\n        std::cout << \"Duplicate Email: \" << email << std::endl;\n    }\n\n    // Test Case 2\n    emails.clear();\n    emails = {{\"jane@example.com\", 1}, {\"jane@example.com\", 1}};\n    result = findDuplicates(emails);\n    for (const auto& email : result) {\n        std::cout << \"Duplicate Email: \" << email << std::endl;\n    }\n\n    // Test Case 3\n    emails.clear();\n    emails = {{\"jane@example.com\", 1}, {\"john@example.com\", 1}};\n    result = findDuplicates(emails);\n    for (const auto& email : result) {\n        std::cout << \"Duplicate Email: \" << email << std::endl;\n    }\n\n    return 0;\n}\n```",
  "183": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> findCustomersWhoNeverOrder(std::vector<std::vector<std::string>>& orders) {\n    std::vector<std::string> customers;\n    for (const auto& order : orders) {\n        if (!order.empty()) {\n            customers.push_back(order[0]);\n        }\n    }\n\n    for (const auto& customer : customers) {\n        bool found = false;\n        for (const auto& order : orders) {\n            if (!order.empty() && order[0] == customer) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            customers.erase(std::remove(customers.begin(), customers.end(), customer), customers.end());\n        }\n    }\n\n    return customers;\n}\n\nint main() {\n    std::vector<std::vector<std::string>> orders1 = {{\"John\", \"Pizza\"}, {\"Jane\", \"Burger\"}, {\"Joe\", \"Sushi\"}};\n    std::vector<std::string> expected1 = {\"John\", \"Jane\", \"Joe\"};\n    std::vector<std::string> result1 = findCustomersWhoNeverOrder(orders1);\n    for (const auto& customer : result1) {\n        if (std::find(expected1.begin(), expected1.end(), customer) == expected1.end()) {\n            std::cout << \"Test case 1 failed.\" << std::endl;\n            return 1;\n        }\n    }\n    std::cout << \"Test case 1 passed.\" << std::endl;\n\n    std::vector<std::vector<std::string>> orders2 = {{\"Alice\", \"Pizza\"}, {\"Bob\", \"Burger\"}};\n    std::vector<std::string> expected2 = {\"Alice\", \"Bob\"};\n    std::vector<std::string> result2 = findCustomersWhoNeverOrder(orders2);\n    for (const auto& customer : result2) {\n        if (std::find(expected2.begin(), expected2.end(), customer) == expected2.end()) {\n            std::cout << \"Test case 2 failed.\" << std::endl;\n            return 1;\n        }\n    }\n    std::cout << \"Test case 2 passed.\" << std::endl;\n\n    std::vector<std::vector<std::string>> orders3 = {{\"Charlie\", \"\"}, {\"David\", \"\"}};\n    std::vector<std::string> expected3 = {};\n    std::vector<std::string> result3 = findCustomersWhoNeverOrder(orders3);\n    for (const auto& customer : result3) {\n        if (std::find(expected3.begin(), expected3.end(), customer) == expected3.end()) {\n            std::cout << \"Test case 3 failed.\" << std::endl;\n            return 1;\n        }\n    }\n    std::cout << \"Test case 3 passed.\" << std::endl;\n\n    return 0;\n}\n```",
  "184": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Employee {\n    std::string department;\n    int salary;\n};\n\nint getHighestSalary(const std::vector<Employee>& employees, const std::string& department) {\n    int highest = -1;\n    for (const auto& employee : employees) {\n        if (employee.department == department && employee.salary > highest) {\n            highest = employee.salary;\n        }\n    }\n    return highest;\n}\n\nint main() {\n    // Test case 1\n    std::vector<Employee> employees1 = {{\"Sales\", 10000}, {\"Marketing\", 20000}, {\"IT\", 30000}};\n    int result1 = getHighestSalary(employees1, \"IT\");\n    if (result1 == 30000) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed.\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<Employee> employees2 = {{\"Sales\", 10000}, {\"Marketing\", 20000}, {\"IT\", 25000}};\n    int result2 = getHighestSalary(employees2, \"Sales\");\n    if (result2 == -1) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed.\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<Employee> employees3 = {{\"Sales\", 10000}, {\"Marketing\", 20000}, {\"IT\", 10000}};\n    int result3 = getHighestSalary(employees3, \"Marketing\");\n    if (result3 == 20000) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "186": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nvoid reverseWordsInString(std::vector<std::string>& s) {\n    int left = 0;\n    for (int right = 0; right <= s.size(); ++right) {\n        if (right == s.size() || s[right] == ' ') {\n            std::reverse(s.begin() + left, s.begin() + right);\n            left = right + 1;\n        }\n    }\n}\n\nint main() {\n    std::vector<std::string> testCases[] = {\n        {\"hello world\", \"world hello\"},\n        {\"sdfghjkl zxcvbnm\", \"zxcvbnm sdfghjkl\"},\n        {\"test test\", \"test test\"}\n    };\n\n    for (const auto& testCase : testCases) {\n        std::vector<std::string> result;\n        for (const auto& word : testCase) {\n            char* cstr = const_cast<char*>(word.c_str());\n            size_t len = strlen(cstr);\n            char* buffer = new char[len + 1];\n            strcpy(buffer, cstr);\n            for (int i = 0; i < len / 2; ++i) {\n                char temp = buffer[i];\n                buffer[i] = buffer[len - i - 1];\n                buffer[len - i - 1] = temp;\n            }\n            result.push_back(buffer);\n            delete[] buffer;\n        }\n\n        std::cout << \"Original: \";\n        for (const auto& word : testCase) {\n            std::cout << word << \" \";\n        }\n        std::cout << std::endl;\n\n        std::cout << \"Reversed: \";\n        for (const auto& word : result) {\n            std::cout << word << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```",
  "185": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstruct Employee {\n    std::string department;\n    int salary;\n};\n\nclass Solution {\npublic:\n    std::vector<std::string> topThreeSalaries(std::vector<Employee>& employees) {\n        std::unordered_map<std::string, int> salaries;\n        \n        for (const auto& employee : employees) {\n            salaries[employee.department] = std::max(salaries.count(employee.department) ? salaries[employee.department] : 0, employee.salary);\n        }\n        \n        std::vector<std::string> result;\n        for (int i = 0; i < 3 && !salaries.empty(); ++i) {\n            auto it = --salaries.end();\n            result.push_back(it->first);\n            salaries.erase(it);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<Employee> employees1 = {{\"Sales\", 1000}, {\"Marketing\", 2000}, {\"Sales\", 1500}, {\"IT\", 2500}};\n    for (const auto& employee : solution.topThreeSalaries(employees1)) {\n        std::cout << employee << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<Employee> employees2 = {{\"HR\", 500}, {\"Finance\", 1000}, {\"HR\", 600}, {\"Sales\", 1500}, {\"IT\", 2500}};\n    for (const auto& employee : solution.topThreeSalaries(employees2)) {\n        std::cout << employee << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<Employee> employees3 = {{\"Sales\", 100}, {\"Marketing\", 200}, {\"IT\", 300}};\n    for (const auto& employee : solution.topThreeSalaries(employees3)) {\n        std::cout << employee << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "187": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findRepeatedDnaSequences(string s) {\n        int n = s.length();\n        unordered_map<string, int> seen;\n        unordered_map<string, int> repeats;\n        for (int i = 0; i <= n - 10; ++i) {\n            string t = s.substr(i, 10);\n            if (seen[t] == 1) {\n                repeats[t]++;\n            } else {\n                seen[t] = 1;\n            }\n        }\n        vector<string> ans;\n        for (auto& p : repeats) {\n            if (p.second > 1) {\n                ans.push_back(p.first);\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s = \"AAAAACCCCCAAAAAA\";\n    vector<string> result1 = solution.findRepeatedDnaSequences(s);\n    for (string str : result1) {\n        cout << str << endl;\n    }\n\n    // Test case 2\n    s = \"ABAABABABC\";\n    vector<string> result2 = solution.findRepeatedDnaSequences(s);\n    for (string str : result2) {\n        cout << str << endl;\n    }\n\n    // Test case 3\n    s = \"ATTCCGGAAGTTACGTCTATCCCAGTCAATTAAGTGAAAGCTBGG\";\n    vector<string> result3 = solution.findRepeatedDnaSequences(s);\n    for (string str : result3) {\n        cout << str << endl;\n    }\n\n    return 0;\n}\n```",
  "188": "```\n#include <iostream>\n#include <vector>\n\nint maxProfit(std::vector<int>& prices) {\n    if (prices.size() <= 1) return 0;\n    \n    int n = prices.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(2, 0));\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < 2; ++j) {\n            if (i == 0) {\n                dp[i][j] = 0;\n            } else {\n                int buy = max(dp[i-1][1], -prices[i]);\n                dp[i][j] = (j == 0) ? max(dp[i-1][j], prices[i] + buy) : max(dp[i-1][j], 0);\n            }\n        }\n    }\n    \n    return dp[n-1][1];\n}\n\nint main() {\n    std::vector<int> prices1 = {2,1,4};\n    std::cout << \"Test Case 1: \" << maxProfit(prices1) << std::endl;\n    \n    std::vector<int> prices2 = {3,5,10,7,9};\n    std::cout << \"Test Case 2: \" << maxProfit(prices2) << std::endl;\n    \n    std::vector<int> prices3 = {4,2,1,3};\n    std::cout << \"Test Case 3: \" << maxProfit(prices3) << std::endl;\n\n    return 0;\n}\n```",
  "189": "```\n#include <iostream>\n#include <vector>\n\nvoid rotate(std::vector<int>& nums, int k) {\n    if (nums.empty()) return;\n    k = k % nums.size();\n    std::reverse(nums.begin(), nums.end());\n    std::vector<int> rotated = {nums[(nums.size() - k) % nums.size()], nums[0], nums[1], nums[2], ... , nums[k-1]};\n}\n\nint main() {\n    int testCases[] = {3, 5, 7};\n    for (int testCase : testCases) {\n        std::vector<int> nums = {1, 2, 3, 4, 5, 6, 7};\n        rotate(nums, testCase);\n        for (int num : nums) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n```",
  "190": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    unsigned int reverseBits(unsigned int n) {\n        unsigned int result = 0;\n        for (int i = 0; i < 32; i++) {\n            result = (result << 1) | (n & 1);\n            n >>= 1;\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << hex << solution.reverseBits(0) << endl; // Output: 0\n    cout << \"Test case 2: \" << hex << solution.reverseBits(8) << endl; // Output: ffffffff\n    cout << \"Test case 3: \" << hex << solution.reverseBits(347793447997616) << endl; // Output: d6d62078f7ec68ef\n\n    return 0;\n}\n```",
  "191": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int hammingWeight(int n) {\n        int count = 0;\n        while (n) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test Case 1: \" << solution.hammingWeight(9) << endl; // Expected output: 4\n    cout << \"Test Case 2: \" << solution.hammingWeight(10) << endl; // Expected output: 1\n    cout << \"Test Case 3: \" << solution.hammingWeight(128) << endl; // Expected output: 1\n\n    return 0;\n}\n```",
  "192": "```\n#include <iostream>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nmap<string, int> wordFrequency(map<string, int>& wordCount) {\n    map<string, int> result;\n    for (auto& pair : wordCount) {\n        string word = pair.first;\n        int count = pair.second;\n        if (result.find(word) != result.end()) {\n            result[word] += count;\n        } else {\n            result[word] = count;\n        }\n    }\n    return result;\n}\n\nint main() {\n    map<string, int> test1 = {{\"apple\", 3}, {\"banana\", 2}, {\"apple\", 1}};\n    map<string, int> result1 = wordFrequency(test1);\n    for (auto& pair : result1) {\n        cout << \"Word: \" << pair.first << \", Count: \" << pair.second << endl;\n    }\n\n    map<string, int> test2 = {{\"hello\", 5}, {\"world\", 3}};\n    map<string, int> result2 = wordFrequency(test2);\n    for (auto& pair : result2) {\n        cout << \"Word: \" << pair.first << \", Count: \" << pair.second << endl;\n    }\n\n    map<string, int> test3 = {{\"this\", 1}, {\"is\", 2}, {\"a\", 3}, {\"test\", 4}};\n    map<string, int> result3 = wordFrequency(test3);\n    for (auto& pair : result3) {\n        cout << \"Word: \" << pair.first << \", Count: \" << pair.second << endl;\n    }\n\n    return 0;\n}\n```",
  "193": "```\n#include <iostream>\n#include <string>\n\nbool isValidPhoneNumber(const std::string& phoneNumber) {\n    if (phoneNumber.length() != 12) return false;\n    for (char c : phoneNumber) {\n        if (!isalnum(c)) return false;\n        if (c == '1' && phoneNumber[0] != '1') return false;\n    }\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test Case 1: \" << isValidPhoneNumber(\"123-4567\") << std::endl;\n    std::cout << \"Test Case 2: \" << isValidPhoneNumber(\"123.456.7890\") << std::endl;\n    std::cout << \"Test Case 3: \" << isValidPhoneNumber(\"1234567890\") << std::endl;\n    return 0;\n}",
  "195": "```\n#include <iostream>\n#include <fstream>\n#include <string>\n\nclass TenthLine {\npublic:\n    std::string findTenthLine(const std::string& filename) {\n        std::ifstream file(filename);\n        int lineNumber = 0;\n        std::string line;\n        \n        while (std::getline(file, line)) {\n            if (++lineNumber == 10)\n                return line;\n        }\n        \n        return \"\";\n    }\n};\n\nint main() {\n    TenthLine tenthLine;\n\n    // Test Case 1\n    std::cout << \"Test Case 1: \" << tenthLine.findTenthLine(\"testcase1.txt\") << std::endl;\n\n    // Test Case 2\n    std::cout << \"Test Case 2: \" << tenthLine.findTenthLine(\"testcase2.txt\") << std::endl;\n\n    // Test Case 3\n    std::cout << \"Test Case 3: \" << tenthLine.findTenthLine(\"testcase3.txt\") << std::endl;\n\n    return 0;\n}\n```",
  "194": "```\n#include <iostream>\n#include <fstream>\n#include <sstream>\n\nvoid transposeFile(const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Error opening file.\" << std::endl;\n        return;\n    }\n\n    std::stringstream buffer;\n    std::string line;\n\n    while (std::getline(file, line)) {\n        for (int i = 0; i < line.size(); i++) {\n            if (i % 2 == 1) {\n                char temp = line[i];\n                line[i] = line[i - 1];\n                line[i - 1] = temp;\n            }\n        }\n        buffer << line << std::endl;\n    }\n\n    file.close();\n\n    std::ofstream output(filename);\n    if (!output.is_open()) {\n        std::cerr << \"Error opening file for writing.\" << std::endl;\n        return;\n    }\n\n    output << buffer.str();\n    output.close();\n}\n\nint main() {\n    transposeFile(\"test1.txt\");\n    transposeFile(\"test2.txt\");\n    transposeFile(\"test3.txt\");\n\n    return 0;\n}\n```",
  "196": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> deleteDuplicate Emails(vector<string>& emails) {\n        set<string> uniqueEmails;\n        vector<string> result;\n        \n        for (const string& email : emails) {\n            if (uniqueEmails.insert(email).second) {\n                result.push_back(email);\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> test1 = {\"mary@example.com\", \"john@example.com\", \"mary@example.com\"};\n    vector<string> expected1 = {\"john@example.com\", \"mary@example.com\"};\n    if (solution.deleteDuplicateEmails(test1) != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n        return -1;\n    }\n\n    // Test case 2\n    vector<string> test2 = {};\n    vector<string> expected2 = {};\n    if (solution.deleteDuplicateEmails(test2) != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n        return -1;\n    }\n\n    // Test case 3\n    vector<string> test3 = {\"john@example.com\", \"mary@example.com\"};\n    vector<string> expected3 = {\"john@example.com\", \"mary@example.com\"};\n    if (solution.deleteDuplicateEmails(test3) != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n        return -1;\n    }\n\n    cout << \"All test cases passed.\" << endl;\n    return 0;\n}\n```",
  "197": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint findRisingTemp(const std::vector<std::vector<int>>& stations) {\n    int maxStations = 0;\n    for (const auto& station : stations) {\n        if (station[1] > station[2]) {\n            maxStations++;\n        }\n    }\n    return maxStations;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::vector<int>> stations1 = {{73, 67, 23}, {24, 7, 32}, {18, 11, 12}};\n    int result1 = findRisingTemp(stations1);\n    if (result1 == 2) {\n        std::cout << \"Test Case 1: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1: Failed\" << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<std::vector<int>> stations2 = {{73, 67, 23}, {24, 7, 32}};\n    int result2 = findRisingTemp(stations2);\n    if (result2 == 1) {\n        std::cout << \"Test Case 2: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2: Failed\" << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<std::vector<int>> stations3 = {{73, 67, 23}};\n    int result3 = findRisingTemp(stations3);\n    if (result3 == 0) {\n        std::cout << \"Test Case 3: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3: Failed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "198": "```\n#include <iostream>\n#include <vector>\n\nint rob(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    if (n == 1) return nums[0];\n\n    std::vector<int> dp(n, 0);\n    dp[0] = nums[0];\n    dp[1] = std::max(nums[0], nums[1]);\n\n    for (int i = 2; i < n; ++i) {\n        dp[i] = std::max(dp[i-1], dp[i-2] + nums[i]);\n    }\n\n    return dp[n-1];\n}\n\nint main() {\n    {\n        std::vector<int> nums = {2,7,9,3,5};\n        int result = rob(nums);\n        if (result == 12) {\n            std::cout << \"Test case 1 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 1 failed. Expected: 12, got: \" << result << \".\" << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> nums = {2};\n        int result = rob(nums);\n        if (result == 2) {\n            std::cout << \"Test case 2 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 2 failed. Expected: 2, got: \" << result << \".\" << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> nums = {1,5};\n        int result = rob(nums);\n        if (result == 6) {\n            std::cout << \"Test case 3 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 3 failed. Expected: 6, got: \" << result << \".\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "199": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    std::vector<int> rightSideView(TreeNode* root) {\n        if (!root)\n            return {};\n\n        std::vector<int> result;\n        helper(root, 0, result);\n\n        return result;\n    }\n\nprivate:\n    void helper(TreeNode* node, int depth, std::vector<int>& result) {\n        if (!node)\n            return;\n\n        if (depth == result.size())\n            result.push_back(node->val);\n\n        if (node->right)\n            helper(node->right, depth + 1, result);\n        if (node->left)\n            helper(node->left, depth + 1, result);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->right->left = new TreeNode(5);\n    root1->right->right = new TreeNode(4);\n\n    std::vector<int> result1 = solution.rightSideView(root1);\n    for (int i : result1) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->right = new TreeNode(3);\n\n    std::vector<int> result2 = solution.rightSideView(root2);\n    for (int i : result2) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    TreeNode* root3 = NULL;\n\n    std::vector<int> result3 = solution.rightSideView(root3);\n\n    for (int i : result3) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "201": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int rangeBitwiseAnd(int m, int n) {\n        int shift = 0;\n        while (m != n) {\n            m >>= 1;\n            n >>= 1;\n            shift++;\n        }\n        return m << shift;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.rangeBitwiseAnd(5, 7) << endl; // Output: 4\n    cout << \"Test Case 2: \" << solution.rangeBitwiseAnd(0, 1) << endl; // Output: 0\n    cout << \"Test Case 3: \" << solution.rangeBitwiseAnd(2147483647, 2147483648 - 1) << endl; // Output: 1073741823\n\n    return 0;\n}\n```",
  "200": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        if (grid.empty()) return 0;\n        int count = 0;\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[0].size(); ++j) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    void dfs(vector<vector<char>>& grid, int x, int y) {\n        if (x < 0 || x >= grid.size() || y < 0 || y >= grid[0].size() || grid[x][y] != '1') \n            return;\n        grid[x][y] = '0';\n        dfs(grid, x + 1, y);\n        dfs(grid, x - 1, y);\n        dfs(grid, x, y + 1);\n        dfs(grid, x, y - 1);\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<vector<char>> grid1 = {{'1','1','0','0','0'},{'1','1','0','0','0'},{'0','0','1','0','0'},{'0','0','0','1','1'}};\n    cout << \"Number of Islands: \" << solution.numIslands(grid1) << endl;\n\n    vector<vector<char>> grid2 = {{'1','1'},{'1','1'}};\n    cout << \"Number of Islands: \" << solution.numIslands(grid2) << endl;\n\n    vector<vector<char>> grid3 = {{'0'},{'0'},{'0'},{'0'},{'0'},{'0'}};\n    cout << \"Number of Islands: \" << solution.numIslands(grid3) << endl;\n    \n    return 0;\n}\n```",
  "202": "```\n#include <iostream>\n#include <string>\n\nbool isHappy(int n) {\n    std::set<int> seen;\n    while (n != 1 && !seen.count(n)) {\n        seen.insert(n);\n        int sum = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            sum += digit * digit;\n            n /= 10;\n        }\n        n = sum;\n    }\n    return n == 1;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << (isHappy(19) ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test Case 2: \" << (isHappy(2) ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test Case 3: \" << (isHappy(13) ? \"True\" : \"False\") << std::endl;\n    return 0;\n}\n```",
  "204": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        if (n <= 2)\n            return 0;\n        \n        bool isPrime = true;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        \n        return isPrime ? 1 : 0;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    cout << s.countPrimes(10) << endl; // Output: 4\n    cout << s.countPrimes(15) << endl; // Output: 8\n    cout << s.countPrimes(20) << endl; // Output: 8\n    \n    return 0;\n}\n```",
  "203": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        if (!head) return NULL;\n        head = new ListNode(0);\n        head->next = removeElements(head->next, val);\n        while (head->next && head->next->val == val) {\n            ListNode* temp = head->next;\n            head->next = head->next->next;\n            delete temp;\n        }\n        return head->next;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(4);\n    head1->next->next->next->next = new ListNode(5);\n    int val1 = 2;\n    ListNode* result1 = solution.removeElements(head1, val1);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test case 2\n    ListNode* head2 = new ListNode(1);\n    head2->next = new ListNode(2);\n    int val2 = 1;\n    ListNode* result2 = solution.removeElements(head2, val2);\n    while (result2) {\n        cout << result2->val << \" \";\n        result2 = result2->next;\n    }\n    cout << endl;\n\n    // Test case 3\n    ListNode* head3 = new ListNode(1);\n    int val3 = 1;\n    ListNode* result3 = solution.removeElements(head3, val3);\n    while (result3) {\n        cout << result3->val << \" \";\n        result3 = result3->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "205": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nbool isIsomorphic(std::string s, std::string t) {\n    if (s.size() != t.size()) return false;\n\n    std::unordered_map<char, char> s_to_t, t_to_s;\n    for (int i = 0; i < s.size(); i++) {\n        if ((s_to_t.find(s[i]) == s_to_t.end() && t_to_s.find(t[i]) == t_to_s.end()) ||\n            (s_to_t[s[i]] != t[i] || t_to_s[t[i]] != s[i])) return false;\n        s_to_t[s[i]] = t[i];\n        t_to_s[t[i]] = s[i];\n    }\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << isIsomorphic(\"egg\", \"add\") << std::endl; // True\n    std::cout << isIsomorphic(\"foo\", \"bar\") << std::endl; // False\n    std::cout << isIsomorphic(\"paper\", \"title\") << std::endl; // True\n    return 0;\n}\n```",
  "206": "```\n#include <iostream>\n#include \"ListNode.h\"\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr != nullptr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1: Single Node\n    ListNode* head1 = new ListNode(1);\n    std::cout << \"Test Case 1: \";\n    if (solution.reverseList(head1) == nullptr || head1->next != nullptr) {\n        std::cout << \"Failed\" << std::endl;\n    } else {\n        std::cout << \"Passed\" << std::endl;\n    }\n\n    // Test Case 2: Two Nodes\n    ListNode* head2 = new ListNode(1);\n    head2->next = new ListNode(2);\n    std::cout << \"Test Case 2: \";\n    if (solution.reverseList(head2) != nullptr && solution.reverseList(head2)->val == 2 &&\n        solution.reverseList(head2)->next != nullptr && solution.reverseList(head2)->next->val == 1) {\n        std::cout << \"Passed\" << std::endl;\n    } else {\n        std::cout << \"Failed\" << std::endl;\n    }\n\n    // Test Case 3: Multi-Node\n    ListNode* head3 = new ListNode(1);\n    head3->next = new ListNode(2);\n    head3->next->next = new ListNode(3);\n    head3->next->next->next = new ListNode(4);\n    std::cout << \"Test Case 3: \";\n    if (solution.reverseList(head3) != nullptr && solution.reverseList(head3)->val == 4 &&\n        solution.reverseList(head3)->next != nullptr && solution.reverseList(head3)->next->val == 3 &&\n        solution.reverseList(head3)->next->next != nullptr && solution.reverseList(head3)->next->next->val == 2) {\n        std::cout << \"Passed\" << std::endl;\n    } else {\n        std::cout << \"Failed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "207": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int n = numCourses;\n        vector<int> count(n);\n        vector<vector<int>> graph(n);\n\n        for (int i = 0; i < prerequisites.size(); i++) {\n            graph[prerequisites[i][1]].push_back(prerequisites[i][0]);\n            count[prerequisites[i][0]]++;\n        }\n\n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (count[i] == 0) q.push(i);\n        }\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            for (int i : graph[node]) {\n                count[i]--;\n                if (count[i] == 0) q.push(i);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (count[i] > 0) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int numCourses1 = 2;\n    vector<vector<int>> prerequisites1 = {{1, 0}};\n    cout << \"Test case 1: \" << (solution.canFinish(numCourses1, prerequisites1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    int numCourses2 = 3;\n    vector<vector<int>> prerequisites2 = {{1, 0}, {0, 2}};\n    cout << \"Test case 2: \" << (solution.canFinish(numCourses2, prerequisites2) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    int numCourses3 = 4;\n    vector<vector<int>> prerequisites3 = {{1, 0}, {2, 1}};\n    cout << \"Test case 3: \" << (solution.canFinish(numCourses3, prerequisites3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "209": "```\n#include <iostream>\n#include <vector>\n\nint minSubArrayLen(int target, std::vector<int>& nums) {\n    int n = nums.size();\n    int left = 0, right = 0, sum = 0, ans = INT_MAX;\n    \n    while (right < n) {\n        sum += nums[right];\n        \n        while (sum >= target) {\n            ans = std::min(ans, right - left + 1);\n            sum -= nums[left++];\n        }\n        right++;\n    }\n    return ans == INT_MAX ? 0 : ans;\n}\n\nint main() {\n    std::vector<int> test1 = {2,3,1,2,4};\n    int result1 = minSubArrayLen(7, test1);\n    std::cout << \"Test 1: \" << (result1 ? \"Pass\" : \"Fail\") << std::endl;\n\n    std::vector<int> test2 = {0,8,2,7,5,1};\n    int result2 = minSubArrayLen(14, test2);\n    std::cout << \"Test 2: \" << (result2 ? \"Pass\" : \"Fail\") << std::endl;\n\n    std::vector<int> test3 = {1};\n    int result3 = minSubArrayLen(1, test3);\n    std::cout << \"Test 3: \" << (result3 ? \"Pass\" : \"Fail\") << std::endl;\n\n    return 0;\n}\n```",
  "208": "```\n#include <iostream>\nusing namespace std;\n\nclass Trie {\nprivate:\n    struct Node {\n        char ch;\n        bool isEndOfWord;\n        Node* children[26] = {nullptr};\n    };\n\npublic:\n    Trie() {\n        root = new Node();\n    }\n\n    void insert(string word) {\n        Node* cur = root;\n        for (char c : word) {\n            if (!cur->children[c - 'a']) {\n                cur->children[c - 'a'] = new Node();\n            }\n            cur = cur->children[c - 'a'];\n        }\n        cur->isEndOfWord = true;\n    }\n\n    bool search(string word) {\n        Node* cur = root;\n        for (char c : word) {\n            if (!cur->children[c - 'a']) {\n                return false;\n            }\n            cur = cur->children[c - 'a'];\n        }\n        return cur->isEndOfWord;\n    }\n\nprivate:\n    Node* root;\n};\n\nint main() {\n    Trie trie;\n\n    trie.insert(\"apple\");\n    trie.insert(\"app\");\n\n    cout << trie.search(\"apple\") << endl;  // true\n    cout << trie.search(\"app\") << endl;     // true\n    cout << trie.search(\"ap\") << endl;      // false\n\n    return 0;\n}\n```",
  "210": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        int n = numCourses;\n        vector<int> graph[n];\n        vector<int> degree(n, 0);\n        \n        for (const auto& edge : prerequisites) {\n            int u = edge[1], v = edge[0];\n            graph[u].push_back(v);\n            degree[v]++;\n        }\n        \n        queue<int> q;\n        for (int i = 0; i < n; ++i)\n            if (!degree[i])\n                q.push(i);\n        \n        vector<int> res;\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            res.push_back(u);\n            \n            for (const auto& v : graph[u]) {\n                --degree[v];\n                if (--v == 0)\n                    q.push(v);\n            }\n        }\n        \n        return degree[0] ? vector<int>() : res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int numCourses1 = 2;\n    vector<vector<int>> prerequisites1 = {{1,0}};\n    cout << \"[\";\n    for (const auto& course: solution.findOrder(numCourses1, prerequisites1)) {\n        cout << course << \" \";\n    }\n    cout << \"]\" << endl; // [0 1]\n\n    int numCourses2 = 4;\n    vector<vector<int>> prerequisites2 = {{1,0},{2,1}};\n    cout << \"[\";\n    for (const auto& course: solution.findOrder(numCourses2, prerequisites2)) {\n        cout << course << \" \";\n    }\n    cout << \"]\" << endl; // [0 2 3]\n\n    int numCourses3 = 3;\n    vector<vector<int>> prerequisites3 = {{1,0},{1,2},{2,0}};\n    cout << \"[\";\n    for (const auto& course: solution.findOrder(numCourses3, prerequisites3)) {\n        cout << course << \" \";\n    }\n    cout << \"]\" << endl; // []",
  "211": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nclass WordDictionary {\npublic:\n    WordDictionary() {}\n\n    void addWord(string word) {\n        root = new TrieNode();\n        for (char c : word) {\n            if (!root->next.count(c)) {\n                root->next[c] = new TrieNode();\n            }\n            root = root->next[c];\n        }\n        root->isEndOfWord = true;\n    }\n\n    bool search(string word) {\n        return dfs(root, 0, word);\n    }\n\nprivate:\n    struct TrieNode {\n        unordered_map<char, TrieNode*> next;\n        bool isEndOfWord;\n    };\n\n    TrieNode* root;\n\n    bool dfs(TrieNode* node, int index, string& word) {\n        if (index == word.size()) {\n            return node->isEndOfWord;\n        }\n        if (word[index] != '.') {\n            char c = word[index];\n            if (!node->next.count(c)) {\n                return false;\n            }\n            node = node->next[c];\n            index++;\n        } else {\n            for (auto& p : node->next) {\n                if (dfs(p.second, index + 1, word)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return dfs(node, index + 1, word);\n    }\n};\n\nint main() {\n    WordDictionary wd;\n    wd.addWord(\"bad\");\n    wd.addWord(\"b..\");\n    std::cout << (wd.search(\"ba\") ? \"true\" : \"false\") << std::endl; // true\n    std::cout << (wd.search(\"b.\") ? \"true\" : \"false\") << std::endl; // true\n    std::cout << (wd.search(\"badc\") ? \"true\" : \"false\") << std::endl; // false\n    return 0;\n}",
  "212": "```\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        // your code here\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<vector<char>> board1 = {{'o','a','a','n'},{'e','t','a','e'},{'i','h','k','r'},{'i','f','l','v'}};\n    vector<string> words1 = {\"eat\", \"taa\", \"han\"};\n    vector<string> result1 = solution.findWords(board1, words1);\n    // Print the result\n    for (string word : result1) {\n        cout << word << endl;\n    }\n    \n    // Test Case 2\n    vector<vector<char>> board2 = {{'s','o','l','u'},{'t','a','r','e'},{'h','n','i','m'}};\n    vector<string> words2 = {\"lunt\", \"tar\", \"hint\"};\n    vector<string> result2 = solution.findWords(board2, words2);\n    // Print the result\n    for (string word : result2) {\n        cout << word << endl;\n    }\n    \n    // Test Case 3\n    vector<vector<char>> board3 = {{'a','e'},{'e','i'}};\n    vector<string> words3 = {\"ae\", \"ei\"};\n    vector<string> result3 = solution.findWords(board3, words3);\n    // Print the result\n    for (string word : result3) {\n        cout << word << endl;\n    }\n    \n    return 0;\n}\n```",
  "213": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if(nums.size() == 1)\n            return nums[0];\n        \n        int res = 0;\n        vector<int> dp(nums.size());\n        dp[0] = nums[0];\n        if(nums.size() > 1) {\n            dp[1] = max(nums[0], nums[1]);\n        }\n        \n        for(int i = 2; i < nums.size(); i++) {\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i]);\n        }\n        \n        return dp.back();\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1\n    vector<int> test1 = {2,7,9,3,5};\n    cout << \"Test case 1: \" << s.rob(test1) << endl;  // Expected output: 12\n\n    // Test case 2\n    vector<int> test2 = {0,0};\n    cout << \"Test case 2: \" << s.rob(test2) << endl;   // Expected output: 0\n\n    // Test case 3\n    vector<int> test3 = {1,5,7,9,10};\n    cout << \"Test case 3: \" << s.rob(test3) << endl;    // Expected output: 15\n    \n    return 0;\n}\n```",
  "215": "```\n#include <iostream>\n#include <vector>\n\nint findKthLargest(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end());\n    return nums[nums.size() - k];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> nums1 = {3,2,1,5,6,4};\n    int k1 = 2;\n    std::cout << \"Kth largest element in \" << nums1 << \" is \" << findKthLargest(nums1, k1) << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {5,7,9};\n    int k2 = 3;\n    std::cout << \"Kth largest element in \" << nums2 << \" is \" << findKthLargest(nums2, k2) << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {1,2,3};\n    int k3 = 1;\n    std::cout << \"Kth largest element in \" << nums3 << \" is \" << findKthLargest(nums3, k3) << std::endl;\n\n    return 0;\n}\n```",
  "214": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int n = s.length();\n        if(n <= 1)\n            return s;\n        string rev = s.substr(0, n-1);\n        reverse(rev.begin(), rev.end());\n        string full = rev + s;\n        for(int i=0; i<n; i++) {\n            if(match(full, s, i))\n                return rev.substr(n-i) + s;\n        }\n        return \"\";\n    }\n\n    bool match(const string& str1, const string& str2, int pos) {\n        for(int i=0; i<str2.length(); i++) {\n            if(str1[i+pos] != str2[i])\n                return false;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.shortestPalindrome(\"a\") << endl;  // \"a\"\n    cout << solution.shortestPalindrome(\"abacaba\") << endl;  // \"abadbacaba\"\n    cout << solution.shortestPalindrome(\"abc\") << endl;  // \"cbaabc\"\n    return 0;\n}\n```",
  "217": "```\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nbool containsDuplicate(std::vector<int>& nums) {\n    std::unordered_set<int> set(nums.begin(), nums.end());\n    return set.size() != nums.size();\n}\n\nint main() {\n    std::vector<int> test1 = {1, 2, 3, 4};\n    std::cout << \"Test case 1: \" << (containsDuplicate(test1) ? \"Contains duplicate\" : \"No duplicate\") << std::endl;\n\n    std::vector<int> test2 = {1, 1, 2, 3};\n    std::cout << \"Test case 2: \" << (containsDuplicate(test2) ? \"Contains duplicate\" : \"No duplicate\") << std::endl;\n\n    std::vector<int> test3 = {1, 2, 3, 4, 5};\n    std::cout << \"Test case 3: \" << (containsDuplicate(test3) ? \"Contains duplicate\" : \"No duplicate\") << std::endl;\n\n    return 0;\n}",
  "216": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int>> combinationSum3(int k, int n) {\n    std::vector<std::vector<int>> res;\n    if (k <= 0 || n <= 0) return res;\n\n    std::vector<int> path;\n    backtrack(res, path, 1, n, k);\n    return res;\n}\n\nvoid backtrack(std::vector<std::vector<int>>& res, std::vector<int>& path, int start, int n, int k) {\n    if (path.size() == k) {\n        if (n == 0) res.push_back(path);\n        return;\n    }\n\n    for (int i = start; i <= n && i * (k - path.size()) <= n; i++) {\n        if (i > n / (k - path.size())) break;\n\n        path.push_back(i);\n        backtrack(res, path, i + 1, n - i, k);\n        path.pop_back();\n    }\n}\n\nint main() {\n    int k1 = 3;\n    int n1 = 27;\n    for (const auto& comb : combinationSum3(k1, n1)) {\n        for (const auto num : comb) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    k1 = 3;\n    int n2 = 9;\n    for (const auto& comb : combinationSum3(k1, n2)) {\n        for (const auto num : comb) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    k1 = 4;\n    int n3 = 13;\n    for (const auto& comb : combinationSum3(k1, n3)) {\n        for (const auto num : comb) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "218": "```\n#include <iostream>\n#include <vector>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nbool comparePoints(const Point& p1, const Point& p2) {\n    return p1.y > p2.y;\n}\n\nint maxBuildingHeight(std::vector<Point>& buildings) {\n    // Your code here\n}\n\nint main() {\n    std::vector<Point> buildings = {{8, 3}, {10, 5}, {25, 11}};\n    int result = maxBuildingHeight(buildings);\n    std::cout << \"Maximum height: \" << result << std::endl;\n\n    buildings = {{0, 2}, {2, 5}};\n    result = maxBuildingHeight(buildings);\n    std::cout << \"Maximum height: \" << result << std::endl;\n\n    buildings = {{1, 3}, {6, 10}};\n    result = maxBuildingHeight(buildings);\n    std::cout << \"Maximum height: \" << result << std::endl;\n}\n```",
  "219": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_map<int, int> map;\n        for (int i = 0; i < nums.size(); i++) {\n            if (map.count(nums[i]) > 0 && i - map[nums[i]] <= k) {\n                return true;\n            }\n            map[nums[i]] = i;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> nums1 = {1, 2, 3, 1};\n    cout << (solution.containsNearbyDuplicate(nums1, 3) ? \"True\" : \"False\") << endl;\n\n    vector<int> nums2 = {1, 2, 3, 4, 5};\n    cout << (solution.containsNearbyDuplicate(nums2, 0) ? \"True\" : \"False\") << endl;\n\n    vector<int> nums3 = [1, 2, 3, 1, 2];\n    cout << (solution.containsNearbyDuplicate(nums3, 4) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "220": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n        if (k == 0) return false;\n        unordered_map<int, int> mp;\n        for (int i = 0; i < nums.size(); i++) {\n            if (i > k) mp.erase(mp.begin());\n            if (mp.upper_bound(nums[i] + t) != mp.end() || mp.lower_bound(nums[i] - t) != mp.begin()) return true;\n            mp[nums[i]] = i;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> nums1 = {1,3};\n    int k1 = 3, t1 = 1;\n    cout << (solution.containsNearbyAlmostDuplicate(nums1, k1, t1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    vector<int> nums2 = [4,7,10];\n    int k2 = 3, t2 = 3;\n    cout << (solution.containsNearbyAlmostDuplicate(nums2, k2, t2) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    vector<int> nums3 = {1,5,9,1,5,9};\n    int k3 = 2, t3 = 2;\n    cout << (solution.containsNearbyAlmostDuplicate(nums3, k3, t3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "221": "```\n#include <iostream>\n#include <vector>\n\nint maximalSquare(std::vector<std::vector<char>>& matrix) {\n    if (matrix.empty()) return 0;\n    \n    int m = matrix.size();\n    int n = matrix[0].size();\n    \n    std::vector<std::vector<int>> dp(m, std::vector<int>(n, 0));\n    int maxSide = 0;\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i == 0 || j == 0) || matrix[i][j] == '0') {\n                dp[i][j] = (matrix[i][j] == '1') ? 1 : 0;\n            } else {\n                dp[i][j] = std::min({dp[i-1][j], dp[i][j-1], dp[i-1][j-1]}) + 1;\n            }\n            \n            maxSide = std::max(maxSide, dp[i][j]);\n        }\n    }\n    \n    return maxSide * maxSide;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<char>> matrix1 = {{'1', '0', '1', '0', '0'},\n                                               {'1', '0', '1', '1', '1'},\n                                               {'1', '1', '1', '1', '1'},\n                                               {'1', '0', '0', '1', '0'}};\n    std::cout << \"Test case 1: \" << maximalSquare(matrix1) << std::endl;\n\n    // Test case 2\n    std::vector<std::vector<char>> matrix2 = {{'0', '1'},\n                                               {'1', '0'}};\n    std::cout << \"Test case 2: \" << maximalSquare(matrix2) << std::endl;\n\n    // Test case 3\n    std::vector<std::vector<char>> matrix3 = {{'1', '1', '1', '1', '1'},\n                                               {'1', '1', '1', '1', '1'},\n                                               {'1', '1', '1', '1', '1'}};\n    std::cout << \"Test case 3: \" << maximalSquare(matrix3) << std::endl;\n\n    return 0;\n}\n```",
  "222": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countCompleteTreeNodes(TreeNode* root) {\n        if (root == NULL)\n            return 0;\n        \n        if (root->left == NULL && root->right == NULL)\n            return 1;\n        \n        int left = 0, right = 0;\n        if (root->left != NULL) \n            left = 1 + countCompleteTreeNodes(root->left);\n        if (root->right != NULL) \n            right = 1 + countCompleteTreeNodes(root->right);\n        \n        return left + right - (left > 0 && right > 0);\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->right->left = new TreeNode(4);\n    root1->right->right = new TreeNode(5);\n    cout << s.countCompleteTreeNodes(root1) << endl;  // Output: 5\n    \n    // Test case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(3);\n    cout << s.countCompleteTreeNodes(root2) << endl;  // Output: 3\n    \n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    cout << s.countCompleteTreeNodes(root3) << endl;  // Output: 1\n    \n    return 0;\n}\n```",
  "223": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int calculateArea(int len1, int width1, int len2, int width2) {\n        return abs(len1 - len2) * max(width1, width2);\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test case 1: \" << solution.calculateArea(4, 3, 8, 10) << endl; // expected output: 20\n    cout << \"Test case 2: \" << solution.calculateArea(5, 6, 2, 7) << endl; // expected output: 12\n    cout << \"Test case 3: \" << solution.calculateArea(1, 8, 10, 9) << endl; // expected output: 72\n    return 0;\n}\n```",
  "224": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int calculate(string s) {\n        stack<int> signs;\n        int res = 0, sign = 1;\n        for (int i = 0; i < s.size(); ++i) {\n            if (isdigit(s[i])) {\n                int num = 0;\n                while (i < s.size() && isdigit(s[i])) {\n                    num = num * 10 + (s[i] - '0');\n                    i++;\n                }\n                res += sign * num;\n            } else if (s[i] == '+') {\n                sign = 1;\n            } else if (s[i] == '-') {\n                sign = -1;\n            } else if (s[i] == '(') {\n                signs.push(sign);\n                sign = 1;\n            } else if (s[i] == ')') {\n                int lastSign = signs.top(); \n                signs.pop();\n                res += sign * lastSign;\n                sign = 0;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.calculate(\"1 + 1\") << endl; // Expected output: 2\n    cout << solution.calculate(\"6 - 3 + 2\") << endl; // Expected output: 5\n    cout << solution.calculate(\"(1 + 1)\") << endl; // Expected output: 2\n    return 0;\n}\n```",
  "225": "```\n#include <queue>\n#include <stack>\n#include <iostream>\n\nclass MyStack {\npublic:\n    MyStack() {}\n\n    void push(int x) {\n        queue1.push(x);\n    }\n\n    int pop() {\n        if (queue2.empty()) {\n            while (queue1.size() > 1) {\n                queue2.push(queue1.front());\n                queue1.pop();\n            }\n            return queue1.front();\n        } else {\n            int temp = queue2.front();\n            queue2.pop();\n            return temp;\n        }\n    }\n\nprivate:\n    std::queue<int> queue1;\n    std::queue<int> queue2;\n};\n\nint main() {\n    MyStack stack;\n\n    // Test Case 1: Push and Pop\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n\n    std::cout << \"Popped element: \" << stack.pop() << std::endl; // Should print 3\n    std::cout << \"Popped element: \" << stack.pop() << std::endl; // Should print 2\n    std::cout << \"Popped element: \" << stack.pop() << std::endl; // Should print 1\n\n    // Test Case 2: Empty Stack and Push Again\n    while (!stack.empty()) {\n        stack.pop();\n    }\n\n    stack.push(4);\n    stack.push(5);\n\n    std::cout << \"Popped element: \" << stack.pop() << std::endl; // Should print 5\n    std::cout << \"Popped element: \" << stack.pop() << std::endl; // Should print 4\n\n    // Test Case 3: Large Number of Pushes and Pops\n    for (int i = 0; i < 10000; i++) {\n        stack.push(i);\n    }\n\n    for (int i = 9999; i >= 0; i--) {\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n    }\n}\n```",
  "227": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int calculate(string s) {\n        stack<int> nums;\n        stack<char> ops;\n        int num = 0, res = 0;\n        char op = '+';\n\n        for (int i = 0; i < s.size(); ++i) {\n            if (isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0');\n            } else if (s[i] == '(') {\n                nums.push(num);\n                res += operation(op);\n                op = '+';\n                num = 0;\n            } else if (s[i] == ')') {\n                res += operation(op);\n                num = 0;\n            } else if (s[i] in \"+-*/\") {\n                while (!ops.empty() && ops.top() != '(') {\n                    res += operation(ops.top());\n                    ops.pop();\n                }\n                ops.push(s[i]);\n            }\n        }\n\n        while (!ops.empty()) {\n            res += operation(ops.top());\n            ops.pop();\n        }\n        res += operation(op);\n\n        return res;\n    }\n\n    int operation(char op) {\n        int a = nums.top(); nums.pop();\n        int b = nums.top(); nums.pop();\n\n        switch (op) {\n            case '+': return b + a;\n            case '-': return b - a;\n            case '*': return b * a;\n            case '/': return b / a;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.calculate(\"1+1\") << endl;  // 2\n    cout << solution.calculate(\"6-3+2\") << endl;  // 5\n    cout << solution.calculate(\"(1+(4+5+2)-3)+(1-(14+7)+7)\") << endl;  // 12\n\n    return 0;\n}\n```",
  "226": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* invertTree(TreeNode* root) {\n    if (root == NULL) {\n        return root;\n    }\n    std::swap(root->left, root->right);\n    invertTree(root->left);\n    invertTree(root->right);\n    return root;\n}\n\nint main() {\n    TreeNode* tree1 = new TreeNode(4);\n    tree1->left = new TreeNode(2);\n    tree1->right = new TreeNode(7);\n    tree1->left->left = new TreeNode(1);\n    tree1->left->right = new TreeNode(3);\n    tree1->right->left = new TreeNode(6);\n    tree1->right->right = new TreeNode(9);\n\n    TreeNode* root1 = invertTree(tree1);\n    std::cout << \"Test Case 1: \";\n    printTree(root1);\n    deleteTree(root1);\n\n    TreeNode* tree2 = new TreeNode(2);\n    tree2->left = new TreeNode(1);\n    tree2->right = new TreeNode(3);\n\n    TreeNode* root2 = invertTree(tree2);\n    std::cout << \"Test Case 2: \";\n    printTree(root2);\n    deleteTree(root2);\n\n    TreeNode* tree3 = new TreeNode(NULL);\n\n    TreeNode* root3 = invertTree(tree3);\n    std::cout << \"Test Case 3: \";\n    printTree(root3);\n    deleteTree(root3);\n}\n\nvoid printTree(TreeNode* node) {\n    if (node == NULL) {\n        return;\n    }\n    std::cout << node->val << \" \";\n    printTree(node->left);\n    printTree(node->right);\n}\n\nvoid deleteTree(TreeNode* node) {\n    if (node == NULL) {\n        return;\n    }\n    deleteTree(node->left);\n    deleteTree(node->right);\n    delete node;\n}\n```",
  "229": "```\n#include <iostream>\n#include <vector>\n\nint majorityElement(std::vector<int>& nums) {\n    int count = 0;\n    int candidate = -1;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n            count = 1;\n        } else if (num == candidate) {\n            count++;\n        } else {\n            count--;\n        }\n    }\n\n    count = 0;\n    for (int num : nums) {\n        if (num == candidate) {\n            count++;\n        }\n    }\n\n    return candidate;\n}\n\nint main() {\n    std::vector<int> test1 = {2, 2, 1, 1, 1, 2, 2};\n    std::cout << \"Test Case 1: \" << majorityElement(test1) << std::endl;\n\n    std::vector<int> test2 = {3, 3, 4, 2, 3};\n    std::cout << \"Test Case 2: \" << majorityElement(test2) << std::endl;\n\n    std::vector<int> test3 = {5};\n    std::cout << \"Test Case 3: \" << majorityElement(test3) << std::endl;\n\n    return 0;\n}\n```",
  "228": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<std::string> summaryRanges(std::vector<int>& nums) {\n        std::vector<std::string> result;\n        int start = 0, end = 0;\n\n        for (int i = 1; i <= nums.size(); i++) {\n            if (i == nums.size() || nums[i] > nums[i - 1]) {\n                if (end - start > 0) {\n                    result.push_back(std::to_string(nums[start]) + ((end - start > 1) ? \"->\" : \"\") + std::to_string(nums[end]));\n                } else {\n                    result.push_back(std::to_string(nums[start]));\n                }\n                start = i;\n                end = i;\n            } else {\n                end = i;\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> nums1 = {0,2,4,6,1};\n    for (const auto& str : solution.summaryRanges(nums1)) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {0,1,2,3,4,5];\n    for (const auto& str : solution.summaryRanges(nums2)) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {8,0,1,3,6,10};\n    for (const auto& str : solution.summaryRanges(nums3)) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
  "231": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        if (n <= 0) return false;\n        return ((n & (n - 1)) == 0);\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n    \n    cout << \"Test case 1: \" << (solution.isPowerOfTwo(16) ? \"Pass\" : \"Fail\") << endl; \n    cout << \"Test case 2: \" << (solution.isPowerOfTwo(-8) ? \"Pass\" : \"Fail\") << endl; \n    cout << \"Test case 3: \" << (solution.isPowerOfTwo(5) ? \"Pass\" : \"Fail\") << endl; \n\n    return 0;\n}\n```",
  "230": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        vector<int> res;\n        dfs(root, k, res);\n        return res[k-1];\n    }\n\n    void dfs(TreeNode* node, int k, vector<int>& res) {\n        if (node == nullptr) return;\n\n        dfs(node->right, k, res);\n        res.push_back(node->val);\n        if (res.size() == k) return;\n        dfs(node->left, k, res);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(4);\n    root1->left->left = new TreeNode(2);\n\n    cout << solution.kthSmallest(root1, 5) << endl;  // Output: 4\n\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(6);\n    root2->left->left = new TreeNode(2);\n    root2->left->right = new TreeNode(4);\n\n    cout << solution.kthSmallest(root2, 3) << endl;  // Output: 3\n\n    TreeNode* root3 = new TreeNode(7);\n    root3->left = new TreeNode(5);\n    root3->right = new TreeNode(9);\n    root3->left->left = new TreeNode(4);\n\n    cout << solution.kthSmallest(root3, 2) << endl;  // Output: 5\n\n    return 0;\n}\n```",
  "233": "```\n#include <iostream>\n#include <string>\n\nlong long countDigitOne(int n) {\n    int threes = 0;\n    for (int i = 1; i <= n; i *= 10) {\n        int onesCount = 0;\n        for (int j = i; j <= n; j += i) {\n            int number = j;\n            int ones = 0;\n            while (number > 0) {\n                if ((number % 10) == 1)\n                    ones++;\n                number /= 10;\n            }\n            threes += ones;\n        }\n    }\n    return threes;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << countDigitOne(13) << std::endl; \n    std::cout << \"Test Case 2: \" << countDigitOne(250) << std::endl; \n    std::cout << \"Test Case 3: \" << countDigitOne(10000000) << std::endl;\n    return 0;\n}\n```",
  "232": "```\n#include <iostream>\n#include <stack>\n\nclass MyQueue {\npublic:\n    stack<int> s1;\n    stack<int> s2;\n\n    void push(int x) {\n        s2.push(x);\n        while (!s1.empty()) {\n            s2.push(s1.top());\n            s1.pop();\n        }\n        std::swap(s1, s2);\n    }\n\n    int pop() {\n        if (s1.empty()) return -1;\n        int res = s1.top();\n        s1.pop();\n        return res;\n    }\n\n    bool empty() {\n        return s1.empty();\n    }\n};\n\nint main() {\n    MyQueue q;\n\n    // Test Case 1: Single element in the queue\n    q.push(5);\n    assert(q.pop() == 5 && \"Expected pop to be 5 but got \" << q.pop());\n\n    // Test Case 2: Multiple elements in the queue\n    for (int i = 1; i <= 3; i++) {\n        q.push(i);\n    }\n    int expected[] = {1, 2, 3};\n    for (int i = 0; i < 3; i++) {\n        assert(q.pop() == expected[i] && \"Expected pop to be \" << expected[i] << \" but got \" << q.pop());\n    }\n\n    // Test Case 3: Queue becomes empty after popping all elements\n    while (!q.empty()) {\n        (void)q.pop();\n    }\n    assert(q.empty() && \"Expected the queue to be empty\");\n\n    return 0;\n}\n```",
  "234": "```\n#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nbool isPalindrome(ListNode* head) {\n    if (head == NULL)\n        return true;\n\n    // Find the end of first half and reverse second half.\n    ListNode* slow = head, *fast = head;\n    while (fast->next && fast->next->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    ListNode* newTail = slow->next;\n    slow->next = NULL;\n\n    // Check whether first half and second half are palindrome.\n    while (newTail != NULL) {\n        if (head->val != newTail->val)\n            return false;\n        head = head->next;\n        newTail = newTail->next;\n    }\n\n    return true;\n}\n\nint main() {\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    cout << \"Test case 1: \" << (isPalindrome(head1) ? \"PASS\" : \"FAIL\") << endl;\n\n    ListNode* head2 = new ListNode(1);\n    head2->next = new ListNode(1);\n    cout << \"Test case 2: \" << (isPalindrome(head2) ? \"PASS\" : \"FAIL\") << endl;\n\n    ListNode* head3 = new ListNode(1);\n    head3->next = new ListNode(2);\n    head3->next->next = new ListNode(1);\n    cout << \"Test case 3: \" << (isPalindrome(head3) ? \"PASS\" : \"FAIL\") << endl;\n    \n    return 0;\n}\n```",
  "235": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == NULL || root == p || root == q)\n            return root;\n\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\n\n        if (left && right)\n            return root;\n        else if (left)\n            return left;\n        else\n            return right;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    TreeNode* root = new TreeNode(6);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(8);\n    root->left->left = new TreeNode(0);\n    root->left->right = new TreeNode(4);\n    root->right->left = new TreeNode(7);\n    root->right->right = new TreeNode(9);\n\n    TreeNode* p = root->left;\n    TreeNode* q = root->right;\n    TreeNode* result = solution.lowestCommonAncestor(root, p, q);\n    cout << \"Lowest Common Ancestor for test case 1: \" << result->val << endl;\n\n    // Test case 2:\n    root = new TreeNode(4);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(7);\n\n    p = root->left;\n    q = root->right;\n    result = solution.lowestCommonAncestor(root, p, q);\n    cout << \"Lowest Common Ancestor for test case 2: \" << result->val << endl;\n\n    // Test case 3:\n    root = new TreeNode(1);\n    root->left = new TreeNode(0);\n\n    p = root;\n    q = root->left;\n    result = solution.lowestCommonAncestor(root, p, q);\n    cout << \"Lowest Common Ancestor for test case 3: \" << result->val << endl;\n\n    return 0;\n}\n```",
  "237": "```\n#include <iostream>\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* deleteNode(ListNode* head, int val) {\n        if (head == NULL || head->val != val) return head;\n        ListNode* temp = head;\n        head = head->next;\n        delete temp;\n        return head;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    ListNode* head1 = new ListNode(5);\n    head1->next = new ListNode(1);\n    head1->next->next = new ListNode(9);\n    cout << \"Test case 1: \";\n    if (solution.deleteNode(head1, 5) && solution.deleteNode(head1, 1) && head1->val == 9) {\n        cout << \"Pass\" << endl;\n    } else {\n        cout << \"Fail\" << endl;\n    }\n\n    // Test case 2\n    ListNode* head2 = new ListNode(4);\n    head2->next = new ListNode(3);\n    head2->next->next = new ListNode(2);\n    head2->next->next->next = new ListNode(1);\n    cout << \"Test case 2: \";\n    if (solution.deleteNode(head2, 2) && solution.deleteNode(head2, 4) && head2->val == 3) {\n        cout << \"Pass\" << endl;\n    } else {\n        cout << \"Fail\" << endl;\n    }\n\n    // Test case 3\n    ListNode* head3 = new ListNode(1);\n    cout << \"Test case 3: \";\n    if (solution.deleteNode(head3, 1) == NULL) {\n        cout << \"Pass\" << endl;\n    } else {\n        cout << \"Fail\" << endl;\n    }\n\n    return 0;\n}\n```",
  "236": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == NULL || root == p || root == q)\n            return root;\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        if (left != NULL)\n            return left;\n        return lowestCommonAncestor(root->right, p, q);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(5);\n    root1->right = new TreeNode(1);\n    root1->left->left = new TreeNode(6);\n    root1->left->right = new TreeNode(2);\n    root1->right->left = new TreeNode(0);\n    root1->right->right = new TreeNode(8);\n    root1->left->left->left = new TreeNode(4);\n    root1->left->left->right = new TreeNode(7);\n    TreeNode* p1 = root1->left->left;\n    TreeNode* q1 = root1->left->right;\n    TreeNode* result1 = solution.lowestCommonAncestor(root1, p1, q1);\n    cout << \"Test Case 1: \" << result1->val << endl;\n\n    // Test Case 2\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(6);\n    root2->left->left = new TreeNode(2);\n    root2->left->right = new TreeNode(4);\n    TreeNode* p2 = root2->left;\n    TreeNode* q2 = root2->right;\n    TreeNode* result2 = solution.lowestCommonAncestor(root2, p2, q2);\n    cout << \"Test Case 2: \" << result2->val << endl;\n\n    // Test Case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(3);\n    root3->left->left = new TreeNode(4);\n    root3->left->right = new TreeNode(5);\n    TreeNode* p3 = root3->left;\n    TreeNode* q3 = root3->right;\n    TreeNode* result3 = solution.lowestCommonAncestor(root3, p3, q3);\n    cout << \"Test Case 3: \" << result3->val << endl;\n\n    return 0;\n}\n```",
  "238": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> productExceptSelf(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> res(n, 1);\n\n    for (int i = 1; i < n; i++) {\n        res[i] = res[i - 1] * nums[i - 1];\n    }\n\n    int right = 1;\n    for (int i = n - 2; i >= 0; i--) {\n        right *= nums[i + 1];\n        res[i] *= right;\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 2, 3, 4};\n    std::cout << \"[\";\n    for (auto x : productExceptSelf(test1)) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"]\";\n\n    std::cout << \"\\n\\n\";\n\n    std::vector<int> test2 = {0, 0, 0};\n    std::cout << \"[\";\n    for (auto x : productExceptSelf(test2)) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"]\";\n\n    std::cout << \"\\n\\n\";\n\n    std::vector<int> test3 = {1, 5, 10};\n    std::cout << \"[\";\n    for (auto x : productExceptSelf(test3)) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"]\";\n\n    return 0;\n}\n```",
  "239": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nint maxSlidingWindow(std::vector<int>& nums, int k) {\n    if (nums.empty() || k <= 0) return -1;\n\n    std::priority_queue<int> maxHeap;\n    for (int i = 0; i < k; i++) {\n        maxHeap.push(nums[i]);\n    }\n    int res = maxHeap.top();\n    maxHeap.pop();\n\n    for (int i = k; i < nums.size(); i++) {\n        if (nums[i] > maxHeap.top()) {\n            maxHeap.pop();\n            maxHeap.push(nums[i]);\n        }\n        res = maxHeap.top();\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 3, -1, 5, 4, -2};\n    std::cout << \"Test case 1: \" << maxSlidingWindow(nums1, 3) << std::endl;\n\n    std::vector<int> nums2 = {1, 2, 3, 4, 5};\n    std::cout << \"Test case 2: \" << maxSlidingWindow(nums2, 1) << std::endl;\n\n    std::vector<int> nums3 = {-7, -8, 9, 10, -6, -5, 0, -9};\n    std::cout << \"Test case 3: \" << maxSlidingWindow(nums3, 5) << std::endl;\n\n    return 0;\n}",
  "241": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> diffWaysDP(string input) {\n        if (input.length() == 0) return {\"\"};\n        vector<string> res;\n        int n = input.length();\n        for (int i = 1; i <= n - 1; ++i) {\n            string left = diffWaysDP(input.substr(0, i));\n            string right = diffWaysDP(input.substr(i));\n            for (string l : left) {\n                for (string r : right) {\n                    res.push_back(\"(\" + l + \")\" + r);\n                    res.push_back(l + \"(\" + r + \")\");\n                    if (!l.empty() && !r.empty()) {\n                        res.push_back(l + r);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    string input = \"2*3-4*5\";\n    vector<string> result = solution.diffWaysDP(input);\n    for (string s : result) {\n        cout << s << endl;\n    }\n    \n    // Test case 2\n    input = \"(1+1)\";\n    result = solution.diffWaysDP(input);\n    for (string s : result) {\n        cout << s << endl;\n    }\n    \n    // Test case 3\n    input = \"0*0\";\n    result = solution.diffWaysDP(input);\n    for (string s : result) {\n        cout << s << endl;\n    }\n    \n    return 0;\n}\n```",
  "240": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        if (matrix.empty() || matrix[0].empty()) return false;\n        \n        int rows = matrix.size();\n        int cols = matrix[0].size();\n        int startRow = 0;\n        int endRow = rows - 1;\n        \n        while (startRow <= endRow) {\n            int midRow = startRow + (endRow - startRow) / 2;\n            if (matrix[midRow][0] == target) return true;\n            \n            if (matrix[midRow][0] < target) {\n                startRow = midRow + 1;\n            } else {\n                endRow = midRow - 1;\n            }\n        }\n        \n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> matrix1 = {{1,4,7},{11,13,17},{23,27,33}};\n    cout << (solution.searchMatrix(matrix1, 5) ? \"Found\" : \"Not Found\") << endl;\n\n    vector<vector<int>> matrix2 = {{-5};\n                                 {1, -3};\n                                 {4, 0, 4}};\n    cout << (solution.searchMatrix(matrix2, 9) ? \"Found\" : \"Not Found\") << endl;\n\n    vector<vector<int>> matrix3 = {{1,3,5},{6,7,8}};\n    cout << (solution.searchMatrix(matrix3, 7) ? \"Found\" : \"Not Found\") << endl;\n    \n    return 0;\n}\n```",
  "242": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nbool isAnagram(std::string s1, std::string s2) {\n    if (s1.length() != s2.length()) return false;\n    \n    std::vector<int> count(256, 0);\n    for (char c : s1) count[c]++;\n    for (char c : s2) count[c]--;\n    \n    for (int i = 0; i < 256; i++) {\n        if (count[i] != 0) return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << isAnagram(\"anagram\", \"nagaram\") << std::endl;\n    std::cout << isAnagram(\"listen\", \"silent\") << std::endl;\n    std::cout << isAnagram(\"hello\", \"world\") << std::endl;\n    \n    return 0;\n}\n```",
  "243": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint shortestWordDistance(std::vector<std::string>& words, std::string word1, std::string word2) {\n    int res = INT_MAX;\n    for (int i = 0; i < words.size(); ++i) {\n        if (words[i] == word1 || words[i] == word2) {\n            int left = i, right = i;\n            if (words[i] == word1) {\n                while (left > 0 && words[left - 1] != word2) --left;\n                right = i;\n                while (++right < words.size() && words[right] != word2) ;\n            } else {\n                while (left > 0 && words[left - 1] != word1) --left;\n                right = i;\n                while (++right < words.size() && words[right] != word1) ;\n            }\n            res = std::min(res, right - left);\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<std::string> words1 = {\"Practice\", \"Makes\", \"Perfect\", \"Practice\"};\n    std::cout << \"Test case 1: \" << shortestWordDistance(words1, \"Practice\", \"Makes\") << std::endl;\n\n    std::vector<std::string> words2 = {\"Program\", \"In\", \"Java\", \"Itself\", \"Is\", \"A\", \"Little\"};\n    std::cout << \"Test case 2: \" << shortestWordDistance(words2, \"In\", \"A\") << std::endl;\n\n    std::vector<std::string> words3 = {\"Hello\", \"From\", \"Java\", \"World\", \"In\", \"C++\", \"Programming\"};\n    std::cout << \"Test case 3: \" << shortestWordDistance(words3, \"Java\", \"C++\") << std::endl;\n    return 0;\n}\n```",
  "244": "```\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestWordDistance(vector<string>& words, string word1, string word2) {\n        int result = INT_MAX;\n        int index1 = -1, index2 = -1;\n        \n        for(int i=0; i<words.size(); i++) {\n            if(words[i] == word1)\n                index1 = i;\n            else if(words[i] == word2) {\n                if(index1 != -1)\n                    result = min(result, i-index1);\n                index2 = i;\n            }\n        }\n        \n        return (index1 < index2) ? index2 - index1 : result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<string> words1 = {\"Practice\", \"Makes\", \"Perfect\", \"Practice\"};\n    cout << \"Shortest distance for test case 1: \" << solution.shortestWordDistance(words1, \"Practice\", \"Perfect\") << endl;\n    \n    // Test case 2:\n    vector<string> words2 = {\"A\", \"B\", \"C\", \"D\", \"E\", \"Z\"};\n    cout << \"Shortest distance for test case 2: \" << solution.shortestWordDistance(words2, \"A\", \"C\") << endl;\n    \n    // Test case 3:\n    vector<string> words3 = {\"Hello\", \"World\", \"How\", \"Are\", \"You\"};\n    cout << \"Shortest distance for test case 3: \" << solution.shortestWordDistance(words3, \"Hello\", \"Are\") << endl;\n\n    return 0;\n}\n```",
  "245": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestWordDistance(vector<string>& words, string word1, string word2) {\n        int res = INT_MAX;\n        for (int i = 0; i < words.size(); ++i) {\n            if (words[i] == word1 || words[i] == word2) {\n                for (int j = i - 1; j >= 0 && (words[j] != word1 || words[j] != word2); --j) {\n                    if (words[j] == word1 && words[i] == word2)\n                        res = min(res, i - j);\n                    else if ((words[j] == word1 && words[i] == word1) || (words[j] == word2 && words[i] == word2))\n                        continue;\n                    else\n                        res = min(res, i - j);\n                }\n                for (int j = i + 1; j < words.size() && (words[j] != word1 || words[j] != word2); ++j) {\n                    if (words[j] == word1 && words[i] == word2)\n                        res = min(res, j - i);\n                    else if ((words[j] == word1 && words[i] == word1) || (words[j] == word2 && words[i] == word2))\n                        continue;\n                    else\n                        res = min(res, j - i);\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1:\n    vector<string> words1 = {\"apple\", \"banana\", \"orange\", \"banana\", \"grape\"};\n    string word11 = \"banana\";\n    string word12 = \"apple\";\n    cout << \"Test Case 1: \" << solution.shortestWordDistance(words1, word11, word12) << endl;\n\n    // Test Case 2:\n    vector<string> words2 = {\"erase\", \"wooden\", \"wooden\", \"erase\"};\n    string word21 = \"erase\";\n    string word22 = \"wooden\";\n    cout << \"Test Case 2: \" << solution.shortestWordDistance(words2, word21, word22) << endl;\n\n    // Test Case 3:\n    vector<string> words3 = {\"apple\", \"banana\", \"banana\", \"grape\", \"orange\"};\n    string word31 = \"apple\";\n    string word32 = \"banana\";\n    cout << \"Test Case 3: \" << solution.shortestWordDistance(words3, word31, word32) << endl;\n\n    return 0;\n}\n```",
  "246": "```\n#include <iostream>\n#include <string>\n\nbool isStrobogrammatic(const std::string& s) {\n    if (s.empty()) return true;\n\n    std::unordered_map<char, char> mapping = {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'8', '8'}, {'9', '6'}};\n\n    int left = 0, right = s.length() - 1;\n    while (left < right) {\n        if (mapping.count(s[left]) == 0 || mapping[s[left]] != s[right]) return false;\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\nint main() {\n    std::cout << isStrobogrammatic(\"9\") << std::endl; // Test case 1: Expected output: 1\n    std::cout << isStrobogrammatic(\"69\") << std::endl; // Test case 2: Expected output: 1\n    std::cout << isStrobogrammatic(\"1680\") << std::endl; // Test case 3: Expected output: 1\n\n    return 0;\n}\n```",
  "247": "```\n#include <iostream>\n#include <vector>\n\nbool isStrobogrammatic(const std::string& s) {\n    std::map<char, char> mapping = {{'0', '0'}, {'1', '1'}, {'8', '8'}, {'6', '9'}, {'9', '6'}};\n    int left = 0, right = s.length() - 1;\n    \n    while (left < right) {\n        if (mapping.find(s[left]) == mapping.end()) return false;\n        if (mapping.find(s[right]) == mapping.end()) return false;\n        \n        char c1 = s[left];\n        char c2 = s[right];\n        \n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << (isStrobogrammatic(\"0\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 2: \" << (isStrobogrammatic(\"111\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 3: \" << (isStrobogrammatic(\"69\") ? \"Pass\" : \"Fail\") << std::endl;\n\n    return 0;\n}\n```",
  "248": "```\n#include <iostream>\n#include <vector>\n\nbool isStrobogrammatic(const std::string& num) {\n    std::map<char, char> mapping = {{'0', '0'}, {'1', '1'}, {'6', '9'}, {'9', '6'}, {'8', '8'}};\n    int left = 0, right = num.length() - 1;\n    \n    while (left <= right) {\n        if (num[left] != mapping.count('0') ? num[left] : '0' \n            && num[right] != mapping.at(num[left])) {\n            return false;\n        }\n        \n        left++;\n        right--;\n    }\n    \n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Is 1219 strobogrammatic? \" << isStrobogrammatic(\"1219\") << std::endl;\n    std::cout << \"Is 6868 strobogrammatic? \" << isStrobogrammatic(\"6868\") << std::endl;\n    std::cout << \"Is 1169 strobogrammatic? \" << isStrobogrammatic(\"1169\") << std::endl;\n    \n    return 0;\n}\n```",
  "249": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> groupStrings(vector<string>& strings) {\n        unordered_map<string, vector<string>> mp;\n        for (string s : strings) {\n            string t = \"\";\n            for (char c : s) {\n                t += (c + 1); // shift each character by 1\n            }\n            mp[t].push_back(s);\n        }\n        vector<vector<string>> res;\n        for (auto& p : mp) {\n            res.push_back(p.second);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> strings = {\"abc\", \"bcd\", \"xyz\"};\n    vector<vector<string>> result1 = solution.groupStrings(strings);\n    for (const auto& group : result1) {\n        cout << \"[\";\n        for (const auto& s : group) {\n            cout << \"\\\"\" << s << \"\\\", \";\n        }\n        cout << \"]\\n\";\n    }\n\n    strings = {\"wsup\", \"bsul\", \"utsaw\"};\n    vector<vector<string>> result2 = solution.groupStrings(strings);\n    for (const auto& group : result2) {\n        cout << \"[\";\n        for (const auto& s : group) {\n            cout << \"\\\"\" << s << \"\\\", \";\n        }\n        cout << \"]\\n\";\n    }\n\n    strings = {\"a\", \"aa\", \"aaa\"};\n    vector<vector<string>> result3 = solution.groupStrings(strings);\n    for (const auto& group : result3) {\n        cout << \"[\";\n        for (const auto& s : group) {\n            cout << \"\\\"\" << s << \"\\\", \";\n        }\n        cout << \"]\\n\";\n    }\n\n    return 0;\n}\n```",
  "250": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int countUnivalues(TreeNode* root) {\n        if (root == nullptr) return 0;\n        \n        int sameLeft = (root->left == nullptr || (root->left)->val == root->val) ? 1 : countUnivalues(root->left);\n        int sameRight = (root->right == nullptr || (root->right)->val == root->val) ? 1 : countUnivalues(root->right);\n        \n        return sameLeft + sameRight;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1:\n    TreeNode* test1Root = new TreeNode(1);\n    test1Root->left = new TreeNode(1);\n    test1Root->right = new TreeNode(1);\n    cout << \"Test Case 1: \" << solution.countUnivalues(test1Root) << endl; // Output: 3\n\n    // Test Case 2:\n    TreeNode* test2Root = new TreeNode(4);\n    test2Root->left = new TreeNode(2);\n    test2Root->right = new TreeNode(6);\n    cout << \"Test Case 2: \" << solution.countUnivalues(test2Root) << endl; // Output: 0\n\n    // Test Case 3:\n    TreeNode* test3Root = new TreeNode(5);\n    test3Root->left = new TreeNode(5);\n    test3Root->right = new TreeNode(5);\n    cout << \"Test Case 3: \" << solution.countUnivalues(test3Root) << endl; // Output: 3\n\n    return 0;\n}\n```",
  "251": "```\n#include <iostream>\n#include <vector>\n\nclass Vector2D {\npublic:\n    Vector2D(std::vector<std::vector<int>>& vec) : vec_(vec), index_(0, 0) {}\n    \n    int next() {\n        while (index_.first >= vec_[index_.second].size()) {\n            index_.first = 0;\n            ++index_.second;\n            if (index_.second == vec_.size()) return -1; // end of vector\n        }\n        return vec_[index_.second][index_.first++];\n    }\n    \nprivate:\n    std::vector<std::vector<int>>& vec_;\n    int index_[2];\n};\n\nint main() {\n    std::vector<std::vector<int>> vec1 = {{1, 2}, {3}};\n    Vector2D v1(vec1);\n    for (int i = 0; i < 5; ++i) {\n        if ((val := v1.next()) == -1) break;\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n    \n    std::vector<std::vector<int>> vec2 = {{1, 2}, {3, 4}};\n    Vector2D v2(vec2);\n    for (int i = 0; i < 5; ++i) {\n        if ((val := v2.next()) == -1) break;\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n    \n    std::vector<std::vector<int>> vec3 = {{1, 2, 3}, {4, 5}};\n    Vector2D v3(vec3);\n    for (int i = 0; i < 6; ++i) {\n        if ((val := v3.next()) == -1) break;\n        std::cout << val << \" \";\n    }\n    std::cout << \"\\n\";\n    \n    return 0;\n}\n```",
  "252": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool canAttendMeetings(std::vector<std::pair<int, int>>& intervals) {\n    std::sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\n        return a.first < b.first;\n    });\n\n    for (int i = 0; i < intervals.size() - 1; ++i) {\n        if (intervals[i].second > intervals[i + 1].first) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::pair<int, int>> meetings1 = {{0, 30}, {5, 10}, {15, 20}};\n    std::cout << (canAttendMeetings(meetings1) ? \"Yes\" : \"No\") << std::endl;\n\n    std::vector<std::pair<int, int>> meetings2 = {{7, 10}, {2, 4}};\n    std::cout << (canAttendMeetings(meetings2) ? \"Yes\" : \"No\") << std::endl;\n\n    std::vector<std::pair<int, int>> meetings3 = {{1, 4}, {2, 5}, {7, 9}};\n    std::cout << (canAttendMeetings(meetings3) ? \"Yes\" : \"No\") << std::endl;\n\n    return 0;\n}\n```",
  "253": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMeetingRooms(vector<vector<int>>& intervals) {\n        if (intervals.empty()) return 0;\n        \n        vector<pair<int, int>> rooms(intervals.size());\n        for (int i = 0; i < intervals.size(); ++i)\n            rooms[i] = {intervals[i][0], 1};\n        for (int i = 0; i < intervals.size(); ++i)\n            rooms[i].second = intervals[i].length();\n        \n        sort(rooms.begin(), rooms.end());\n        int maxRooms = 0, currentRooms = 0;\n        for (const auto& room : rooms) {\n            if (!room.second) continue;\n            if (currentRooms > maxRooms) maxRooms = currentRooms;\n            ++currentRooms;\n        }\n        return maxRooms + 1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> intervals1 = {{0,30},{5,10},{15,20}};\n    cout << \"Test case 1: \" << solution.minMeetingRooms(intervals1) << endl; \n\n    // Test case 2\n    vector<vector<int>> intervals2 = {{7,10},{2,4}};\n    cout << \"Test case 2: \" << solution.minMeetingRooms(intervals2) << endl;\n\n    // Test case 3\n    vector<vector<int>> intervals3 = {{0,30},{1,29}, {2,28}, {3,27}, {4,26}, {5,25}, {6,24}};\n    cout << \"Test case 3: \" << solution.minMeetingRooms(intervals3) << endl;\n\n    return 0;\n}\n```",
  "254": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> getFactors(int n) {\n        vector<vector<int>> res;\n        for (int i = 2; i <= n; ++i) {\n            if (n % i == 0) {\n                int j = n / i;\n                while (j > i && n % j != 0) {\n                    --j;\n                }\n                if (j >= i) {\n                    res.push_back({i, j});\n                }\n                for (; j >= i; --j) {\n                    if (n % j == 0) {\n                        int k = n / j;\n                        while (k > j && n % k != 0) {\n                            --k;\n                        }\n                        if (k >= j) {\n                            res.push_back({j, k});\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<int>> result1 = solution.getFactors(12);\n    for (const auto& factor : result1) {\n        cout << \"Factors: \" << factor[0] << \", \" << factor[1] << endl;\n    }\n    \n    vector<vector<int>> result2 = solution.getFactors(37);\n    for (const auto& factor : result2) {\n        cout << \"Factors: \" << factor[0] << \", \" << factor[1] << endl;\n    }\n    \n    vector<vector<int>> result3 = solution.getFactors(220);\n    for (const auto& factor : result3) {\n        cout << \"Factors: \" << factor[0] << \", \" << factor[1] << endl;\n    }\n\n    return 0;\n}\n```",
  "255": "```\n#include <iostream>\n#include <vector>\n\nbool isValidPreorder(std::vector<int>& preorder) {\n    if (preorder.empty()) return true;\n    int root = preorder[0];\n    int i = 1;\n    for (int x : preorder) {\n        if (x < root) {\n            return false;\n        }\n        while (i < preorder.size() && preorder[i] < root) {\n            i++;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> test1 = {5, 2, 5};\n    std::cout << \"Test case 1: \" << (isValidPreorder(test1) ? \"Valid\" : \"Invalid\") << std::endl;\n\n    std::vector<int> test2 = {5, 2, 6, 1, 3};\n    std::cout << \"Test case 2: \" << (isValidPreorder(test2) ? \"Valid\" : \"Invalid\") << std::endl;\n\n    std::vector<int> test3 = {1, 1};\n    std::cout << \"Test case 3: \" << (isValidPreorder(test3) ? \"Valid\" : \"Invalid\") << std::endl;\n}\n```",
  "256": "```\n#include <iostream>\n#include <vector>\n\nint minCost(std::vector<std::vector<int>>& costs) {\n    int n = costs.size();\n    std::vector<int> dp(n);\n    dp[0] = costs[0][0];\n    \n    for (int i = 1; i < n; i++) {\n        int prevMin = dp[i - 1];\n        dp[i] = std::min({dp[i - 1], dp[i - 1] + costs[i][0], dp[i - 1] + costs[i][1]});\n    }\n    \n    return dp.back();\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::vector<int>> costs1 = {{17,2,17},{16,16,5},{14,7,15},{10,4,3}};\n    std::cout << \"Test Case 1: \" << minCost(costs1) << std::endl;\n\n    // Test Case 2\n    std::vector<std::vector<int>> costs2 = {{1,2,3},{100,2,0},{1,2,1},{1,3,2}};\n    std::cout << \"Test Case 2: \" << minCost(costs2) << std::endl;\n\n    // Test Case 3\n    std::vector<std::vector<int>> costs3 = {{21,50,100},{47,12,94},{62,40,30}};\n    std::cout << \"Test Case 3: \" << minCost(costs3) << std::endl;\n    \n    return 0;\n}\n```",
  "258": "```\n#include <iostream>\n#include <cmath>\n\nint addDigits(int num) {\n    while (num > 9) {\n        num = 0;\n        int sum = 0;\n        while (num != 0) {\n            num = num % 10;\n            sum += num;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << addDigits(38) << std::endl; // Expected output: 2\n    std::cout << \"Test Case 2: \" << addDigits(9) << std::endl; // Expected output: 9\n    std::cout << \"Test Case 3: \" << addDigits(27) << std::endl; // Expected output: 9\n\n    return 0;\n}\n```",
  "257": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    string tree2str(TreeNode* t) {\n        if (!t) return \"\";\n        if (!t->left && !t->right) return to_string(t->val);\n        return to_string(t->val) + \"(\" + tree2str(t->left) + \")\" + \"(\" + tree2str(t->right) + \")\";\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    TreeNode* testTree1 = new TreeNode(1);\n    testTree1->left = new TreeNode(4);\n    testTree1->right = new TreeNode(5);\n    cout << \"Test case 1: \" << solution.tree2str(testTree1) << endl;\n    \n    // Test case 2\n    TreeNode* testTree2 = new TreeNode(1);\n    testTree2->left = new TreeNode(2);\n    testTree2->right = new TreeNode(3);\n    cout << \"Test case 2: \" << solution.tree2str(testTree2) << endl;\n    \n    // Test case 3\n    TreeNode* testTree3 = new TreeNode(1);\n    testTree3->left = new TreeNode(2);\n    testTree3->right = new TreeNode(4);\n    testTree3->right->left = new TreeNode(5);\n    cout << \"Test case 3: \" << solution.tree2str(testTree3) << endl;\n    \n    return 0;\n}\n```",
  "259": "```\n#include <iostream>\n#include <vector>\n\nint threeSumSmaller(std::vector<int>& nums, int target) {\n    std::sort(nums.begin(), nums.end());\n    int res = 0;\n    for (int i = 0; i < nums.size() - 2; ++i) {\n        int left = i + 1, right = nums.size() - 1;\n        while (left < right) {\n            int curr_sum = nums[i] + nums[left] + nums[right];\n            if (curr_sum >= target) {\n                --right;\n            } else {\n                res += right - left;\n                ++left;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2};\n    int target1 = 3;\n    std::cout << \"Test case 1: \" << threeSumSmaller(nums1, target1) << std::endl;\n\n    std::vector<int> nums2 = {-2, 0, 1, 3, -5, 2, -1};\n    int target2 = 1;\n    std::cout << \"Test case 2: \" << threeSumSmaller(nums2, target2) << std::endl;\n\n    std::vector<int> nums3 = [-1, 0, 10, 12];\n    int target3 = -1;\n    std::cout << \"Test case 3: \" << threeSumSmaller(nums3, target3) << std::endl;\n\n    return 0;\n}\n```",
  "260": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int singleNumberIII(int n) {\n        int res = 0;\n        for (int i = 30; i >= 1; i--) {\n            if ((n >> i & 1) == 1) {\n                res |= 1 << i;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    int n = 2;\n    cout << \"Test Case 1: Single Number is \" << solution.singleNumberIII(n) << endl;\n\n    // Test Case 2\n    n = 5;\n    cout << \"Test Case 2: Single Number is \" << solution.singleNumberIII(n) << endl;\n\n    // Test Case 3\n    n = 7;\n    cout << \"Test Case 3: Single Number is \" << solution.singleNumberIII(n) << endl;\n\n    return 0;\n}\n```",
  "262": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numTriples(int n) {\n        return (n * (n - 1) * (n - 2)) / 6;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test Case 1: \" << solution.numTriples(5) << endl; // Expected output: 10\n    cout << \"Test Case 2: \" << solution.numTriples(3) << endl; // Expected output: 3\n    cout << \"Test Case 3: \" << solution.numTriples(1) << endl; // Expected output: 0\n    \n    return 0;\n}\n```",
  "261": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool validTree(int n, vector<vector<int>>& edges) {\n        if (n == 0) return true;\n        if (edges.size() != n - 1) return false;\n\n        vector<int> parent(n);\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n\n        for (const auto& edge : edges) {\n            int u = edge[0], v = edge[1];\n            if (find(parent, u) == find(parent, v))\n                return false;\n            unionFind(parent, u, v);\n        }\n\n        return true;\n    }\n\nprivate:\n    int find(vector<int>& parent, int x) {\n        return parent[x] == x ? x : parent[parent[x]] = find(parent, parent[x]);\n    }\n\n    void unionFind(vector<int>& parent, int u, int v) {\n        parent[find(parent, u)] = find(parent, v);\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<vector<int>> edges1 = {{0, 1}, {1, 2}, {2, 3}};\n    cout << (solution.validTree(4, edges1) ? \"True\" : \"False\") << endl;\n\n    vector<vector<int>> edges2 = {{0, 1}, {1, 2}};\n    cout << (solution.validTree(3, edges2) ? \"True\" : \"False\") << endl;\n\n    vector<vector<int>> edges3 = {{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}};\n    cout << (solution.validTree(7, edges3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "263": "```\n#include <iostream>\n#include <vector>\n\nbool isUgly(int n) {\n    if (n <= 0) return false;\n    while (n % 2 == 0) n /= 2;\n    while (n % 3 == 0) n /= 3;\n    while (n % 5 == 0) n /= 5;\n    return n == 1;\n}\n\nint main() {\n    std::vector<int> testCases = {6, 8, 14};\n    for (const auto& testCase : testCases) {\n        if (isUgly(testCase)) {\n            std::cout << \"The number \" << testCase << \" is an ugly number.\" << std::endl;\n        } else {\n            std::cout << \"The number \" << testCase << \" is not an ugly number.\" << std::endl;\n        }\n    }\n    return 0;\n}\n```",
  "264": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<long long> ugly;\n        ugly.push_back(1);\n        priority_queue<long long> pq;\n        pq.push(1);\n        \n        while (!pq.empty()) {\n            long long temp = pq.top();\n            pq.pop();\n            \n            if (temp * 2 > ugly.back()) {\n                ugly.push_back(temp * 2);\n                pq.push(temp * 2);\n            }\n            if (temp * 3 > ugly.back()) {\n                ugly.push_back(temp * 3);\n                pq.push(temp * 3);\n            }\n            if (temp * 5 > ugly.back()) {\n                ugly.push_back(temp * 5);\n                pq.push(temp * 5);\n            }\n            \n            if (ugly.size() == n) break;\n        }\n        \n        return ugly[ugly.size()-1];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.nthUglyNumber(10) << endl; // Output: 12\n    cout << \"Test Case 2: \" << solution.nthUglyNumber(1) << endl; // Output: 1\n    cout << \"Test Case 3: \" << solution.nthUglyNumber(4) << endl; // Output: 6\n\n    return 0;\n}\n```",
  "265": "```\n#include <iostream>\n#include <vector>\n\nint minCostII(std::vector<std::vector<int>>& costs) {\n    int n = costs.size();\n    if (n == 0) return 0;\n    \n    int prevMin = costs[0][0];\n    for (int i = 1; i < n; ++i) {\n        int currMin = prevMin;\n        prevMin = costs[i].front();\n        for (int j = 1; j <= i; ++j) {\n            if (costs[i][j] + std::min(currMin, prevMin) < costs[i][0]) {\n                costs[i][0] = costs[i][j] + std::min(currMin, prevMin);\n            }\n        }\n    }\n    \n    return costs[n - 1][0];\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> costs1 = {{14,2,11},{11,14,5},{4,3,16},{1,12,2},{9,13,7}};\n    std::cout << \"Test case 1: \" << minCostII(costs1) << std::endl;\n    \n    // Test case 2\n    std::vector<std::vector<int>> costs2 = {{3,10},{11,5},{9,8}};\n    std::cout << \"Test case 2: \" << minCostII(costs2) << std::endl;\n    \n    // Test case 3\n    std::vector<std::vector<int>> costs3 = {{1,2,6},{4,7,9},{11,12,13}};\n    std::cout << \"Test case 3: \" << minCostII(costs3) << std::endl;\n    \n    return 0;\n}\n```",
  "266": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nbool canPermutePalindrome(std::string s) {\n    std::unordered_map<char, int> count;\n    for (char c : s) {\n        if (count.find(c) == count.end()) {\n            count[c] = 1;\n        } else {\n            count[c]++;\n        }\n    }\n    \n    int oddCount = 0;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        if (it->second % 2 != 0) {\n            oddCount++;\n            if (oddCount > 1) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    std::cout << canPermutePalindrome(\"carp\") << std::endl; // Expected: true\n    std::cout << canPermutePalindrome(\"abc\") << std::endl; // Expected: false\n    std::cout << canPermutePalindrome(\"a\") << std::endl; // Expected: true\n\n    return 0;\n}",
  "268": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMissingNumber(vector<int>& nums) {\n        long n = nums.size();\n        int totalSum = (n * (n + 1)) / 2;\n        int actualSum = 0;\n        for(int i = 0; i < n; i++) {\n            actualSum += nums[i];\n        }\n        return totalSum - actualSum;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> test1 = {3, 0, 1};\n    cout << \"Test Case 1: \" << solution.findMissingNumber(test1) << endl; // Expected output: 2\n\n    vector<int> test2 = {0, 1};\n    cout << \"Test Case 2: \" << solution.findMissingNumber(test2) << endl; // Expected output: 2\n\n    vector<int> test3 = {9, 8, 7, 6, 5, 4, 3, 2, 0, 1};\n    cout << \"Test Case 3: \" << solution.findMissingNumber(test3) << endl; // Expected output: 10\n\n    return 0;\n}\n```",
  "267": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> generatePalindromes(scalar s) {\n        vector<string> result;\n        int len = s.size();\n        string str = s;\n        sort(str.begin(), str.end());\n        \n        do {\n            string palindrome = \"\";\n            bool isOdd = (len % 2);\n            \n            for(int i = 0; i < len/2; ++i) {\n                if(i == 0 && isOdd)\n                    palindrome += str[i];\n                else\n                    palindrome += str[i] + str[len - i - 1];\n            }\n            \n            result.push_back(palindrome);\n        } while(next_permutation(str.begin(), str.end()));\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s = \"aabb\";\n    vector<string> expected = {\"aabba\", \"abaab\", \"baaab\"};\n    vector<string> result = solution.generatePalindromes(s);\n    for (const auto &p : result) {\n        cout << p << endl;\n    }\n    cout << \"Test case 1: \" << (result == expected ? \"Pass\" : \"Fail\") << endl;\n\n    // Test case 2\n    s = \"abc\";\n    expected = {\"abccba\", \"bacccbA\"};\n    result = solution.generatePalindromes(s);\n    for (const auto &p : result) {\n        cout << p << endl;\n    }\n    cout << \"Test case 2: \" << (result == expected ? \"Pass\" : \"Fail\") << endl;\n\n    // Test case 3\n    s = \"\";\n    expected = {};\n    result = solution.generatePalindromes(s);\n    for (const auto &p : result) {\n        cout << p << endl;\n    }\n    cout << \"Test case 3: \" << (result == expected ? \"Pass\" : \"Fail\") << endl;\n\n    return 0;\n}\n```",
  "269": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string alienOrder(vector<string>& words) {\n        int n = words.size();\n        vector<vector<int>> graph(26, vector<int>());\n        vector<int> inDeg(26, 0);\n\n        for (int i = 0; i < n - 1; ++i) {\n            string w1 = words[i], w2 = words[i + 1];\n            int len1 = w1.size(), len2 = w2.size();\n            for (int j = 0; j < min(len1, len2); ++j) {\n                if (w1[j] != w2[j]) {\n                    graph[w1[j] - 'a'].push_back(w2[j] - 'a');\n                    inDeg[w2[j] - 'a']++;\n                    break;\n                }\n            }\n        }\n\n        string res = \"\";\n        for (int i = 0; i < 26; ++i) {\n            if (inDeg[i] == 0) {\n                res += (char)(i + 'a');\n                inDeg[i]--;\n                for (int j = 0; j < graph[i].size(); ++j) {\n                    int next = graph[i][j];\n                    inDeg[next]--;\n                    if (inDeg[next] == 0) {\n                        res += (char)(next + 'a');\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<string> words1 = {\"w\",\"wa\",\"wo\",\"woo\",\"wood\"};\n    cout << \"Test case 1: \" << solution.alienOrder(words1) << endl; // Output: \"woo\"\n    \n    // Test case 2\n    vector<string> words2 = {\"kthixua\",\"kthixup\",\"qkthxxu\",\"kthxuxa\"};\n    cout << \"Test case 2: \" << solution.alienOrder(words2) << endl; // Output: \"ab\"\n    \n    // Test case 3\n    vector<string> words3 = {\"hello\",\"leetcode\"};\n    cout << \"Test case 3: \" << solution.alienOrder(words3) << endl; // Output: \"\"\n    \n    return 0;\n}\n```",
  "270": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nint closestValue(TreeNode* root, double target) {\n    int res = root->val;\n    while (root) {\n        if (abs(target - root->val) < abs(target - res)) {\n            res = root->val;\n        }\n        root = (target < root->val) ? root->left : root->right;\n    }\n    return res;\n}\n\nint main() {\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(6);\n\n    std::cout << \"Test Case 1: Closest value in binary search tree is \" << closestValue(root1, 4.328) << std::endl;\n    std::cout << \"Expected output: 5\" << std::endl;\n\n    TreeNode* root2 = new TreeNode(8);\n    root2->left = new TreeNode(7);\n    root2->right = new TreeNode(9);\n\n    std::cout << \"Test Case 2: Closest value in binary search tree is \" << closestValue(root2, 5.5) << std::endl;\n    std::cout << \"Expected output: 8\" << std::endl;\n\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(0);\n    root3->right = new TreeNode(2);\n\n    std::cout << \"Test Case 3: Closest value in binary search tree is \" << closestValue(root3, 2.6) << std::endl;\n    std::cout << \"Expected output: 1\" << std::endl;\n\n    return 0;\n}\n```",
  "271": "```\n#include <iostream>\n#include <string>\n\nclass Codec {\npublic:\n    std::string encode(std::string s) {\n        return \"#\" + s;\n    }\n\n    std::string decode(std::string s) {\n        size_t pos = 0;\n        std::string res;\n        while (pos < s.length()) {\n            size_t i = s.find(\"#\", pos);\n            if (i == std::string::npos) break;\n            res += s.substr(pos, i - pos);\n            pos = i + 1;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Codec codec;\n    {\n        std::cout << \"Test Case 1: \";\n        std::string s = \"Hello\";\n        std::cout << codec.encode(s) << \"\\n\"; // Output: #Hello\n        std::cout << codec.decode(codec.encode(s)) << \"\\n\"; // Output: Hello\n    }\n    {\n        std::cout << \"Test Case 2: \";\n        std::string s = \"abc123\";\n        std::cout << codec.encode(s) << \"\\n\"; // Output: #abc123\n        std::cout << codec.decode(codec.encode(s)) << \"\\n\"; // Output: abc123\n    }\n    {\n        std::cout << \"Test Case 3: \";\n        std::string s = \"\";\n        std::cout << codec.encode(s) << \"\\n\"; // Output: #\n        std::cout << codec.decode(codec.encode(s)) << \"\\n\"; // Output:\n    }\n    return 0;\n}\n```",
  "272": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<int> closestValues(TreeNode* root, double target) {\n        vector<int> res;\n        TreeNode* cur = root;\n        while (cur != nullptr) {\n            if (abs(cur->val - target) <= 1e-9) return vector<int>({cur->val});\n            if (target < cur->val) cur = cur->left;\n            else cur = cur->right;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(2);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(3);\n    vector<int> res1 = solution.closestValues(root1, 2.1093845);\n    for (int i : res1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(4);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(5);\n    vector<int> res2 = solution.closestValues(root2, 3.8);\n    for (int i : res2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(-1);\n    root3->right = new TreeNode(2);\n    vector<int> res3 = solution.closestValues(root3, -0.5);\n    for (int i : res3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
  "274": "```\n#include <iostream>\n#include <vector>\n\nint hIndex(std::vector<int>& citations) {\n    int n = citations.size();\n    std::sort(citations.begin(), citations.end());\n    for (int i = n - 1; i >= 0; --i) {\n        if (citations[i] < (n - i)) return n - i - 1;\n    }\n    return n;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> citations1 = {3, 0, 6, 1, 5};\n    int result1 = hIndex(citations1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<int> citations2 = {1, 3, 6};\n    int result2 = hIndex(citations2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<int> citations3 = {25, 17, 14, 15, 23, 21, 10};\n    int result3 = hIndex(citations3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "273": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        std::string result;\n        int neg = 0;\n        if ((neg = (num < 0))) {\n            num = -num;\n            result += \"Negative \";\n        }\n        int onesPlace = num % 10;\n        int tensPlace = (num / 10) % 10;\n        int hundredsPlace = num / 100;\n        \n        // Add the hundreds place\n        if (hundredsPlace > 0) {\n            result += hundredsToWords(hundredsPlace);\n            result += \" Hundred\";\n            if (tensPlace > 0 || onesPlace > 0) {\n                result += \" \";\n            }\n        }\n        \n        // Add the tens and ones places\n        switch (tensPlace) {\n            case 1:\n                if (onesPlace > 0) {\n                    result += \" Ten\";\n                } else {\n                    result += \" Ten\";\n                }\n                break;\n            case 2:\n                result += \" Twenty\";\n                break;\n            case 3:\n                result += \" Thirty\";\n                break;\n            case 4:\n                result += \" Forty\";\n                break;\n            case 5:\n                if (onesPlace > 0) {\n                    result += \" Fifty\";\n                } else {\n                    result += \" Fifty\";\n                }\n                break;\n            case 6:\n                result += \" Sixty\";\n                break;\n            case 7:\n                result += \" Seventy\";\n                break;\n            case 8:\n                result += \" Eighty\";\n                break;\n            case 9:\n                result += \" Ninety\";\n                break;\n        }\n        \n        // Add the ones place\n        if (onesPlace > 0) {\n            switch (onesPlace) {\n                case 1:\n                    result += \" One\";\n                    break;\n                case 2:\n                    result += \" Two\";\n                    break;\n                case 3:\n                    result += \" Three\";\n                    break;\n                case 4:\n                    result += \" Four\";\n                    break;\n                case 5:\n                    result += \" Five\";\n                    break;\n                case 6:\n                    result += \" Six\";\n                    break;\n                case 7:\n                    result += \" Seven\";\n                    break;\n                case 8:\n                    result += \" Eight\";\n                    break;\n                case 9:\n                    result += \" Nine\";\n                    break;\n            }\n        }\n        \n        return result;\n    }\n    \n    std::string hundredsToWords(int num) {\n        switch (num) {\n            case 1:\n                return \"One Hundred\";\n            case 2:\n                return \"Two Hundred\";\n            case 3:\n                return \"Three Hundred\";\n            case 4:\n                return \"Four Hundred\";\n            case 5:\n                return \"Five Hundred\";\n            default:\n                return numberToWords(num) + \" Hundred\";\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::cout << solution.numberToWords(123) << std::endl; // Should print: One Hundred Twenty Three\n    std::cout << solution.numberToWords(-123) << std::endl; // Should print: Negative One Hundred Twenty Three\n    std::cout << solution.numberToWords(1000000) << std::endl; // Should print: One Million\n    \n    return 0;\n}",
  "275": "```\n#include <iostream>\n#include <vector>\n\nint hIndex(std::vector<int>& citations) {\n    int n = citations.size();\n    for (int i = n - 1; i >= 0; --i) {\n        if (citations[i] < i + 1)\n            return i;\n    }\n    return n;\n}\n\nint main() {\n    std::vector<int> citations1 = {3, 0, 6, 1, 5};\n    std::cout << \"Test case 1: \" << hIndex(citations1) << std::endl;\n\n    std::vector<int> citations2 = {1, 2, 100};\n    std::cout << \"Test case 2: \" << hIndex(citations2) << std::endl;\n\n    std::vector<int> citations3 = {0, 1};\n    std::cout << \"Test case 3: \" << hIndex(citations3) << std::endl;\n}\n```",
  "276": "```\n#include <iostream>\nusing namespace std;\n\nint numWays(int n, int k) {\n    if (n == 0) return 1;\n    if (n == 1) return k;\n    \n    int dp[n+1];\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = k * dp[i-1];\n        if (i > 1)\n            dp[i] += dp[i-2];\n    }\n    \n    return dp[n];\n}\n\nint main() {\n    cout << numWays(3, 2) << endl;  // Output: 6\n    cout << numWays(7, 4) << endl;  // Output: 132\n    cout << numWays(1, 10) << endl;  // Output: 10\n\n    return 0;\n}\n```",
  "278": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left = 1;\n        int right = n;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (isBadVersion(mid)) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return left;\n    }\n};\n\nbool isBadVersion(int version) {\n    // Your code here\n    return false; // replace this with your bad version function\n}\n\nint main() {\n    Solution solution;\n\n    int n1 = 2;\n    cout << \"First bad version in [\" << 0 << \", \" << n1 - 1 << \"] is \" << solution.firstBadVersion(n1) << endl;\n\n    int n2 = 5;\n    cout << \"First bad version in [\" << 0 << \", \" << n2 - 1 << \"] is \" << solution.firstBadVersion(n2) << endl;\n\n    int n3 = 10;\n    cout << \"First bad version in [\" << 0 << \", \" << n3 - 1 << \"] is \" << solution.firstBadVersion(n3) << endl;\n\n    return 0;\n}\n\n```",
  "277": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findCelebrity(int n) {\n        int celebrity = 0;\n        for (int i = 1; i < n; i++) {\n            if (knows(celebrity, i)) {\n                celebrity = i;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (i != celebrity && (knows(i, celebrity) || !knownBy(celebrity, i))) {\n                return -1;\n            }\n        }\n        return celebrity;\n    }\n\n    bool knows(int m, int n) {\n        // Assume this function is implemented correctly\n    }\n\n    bool knownBy(int m, int n) {\n        // Assume this function is implemented correctly\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test Case 1: \" << solution.findCelebrity(3) << endl; // Output: 0\n    cout << \"Test Case 2: \" << solution.findCelebrity(4) << endl; // Output: -1\n    cout << \"Test Case 3: \" << solution.findCelebrity(5) << endl; // Output: 2\n\n    return 0;\n}\n```",
  "279": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSquares(int n) {\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j * j <= i; ++j) {\n                if (i - j * j >= 0 && dp[i - j * j] + 1 < dp[i]) {\n                    dp[i] = dp[i - j * j] + 1;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.numSquares(12) << endl; // Output: 3\n    cout << \"Test case 2: \" << solution.numSquares(13) << endl; // Output: 2\n    cout << \"Test case 3: \" << solution.numSquares(10) << endl; // Output: 1\n\n    return 0;\n}\n```",
  "280": "```\n#include <iostream>\n#include <vector>\n\nvoid wiggleSort(std::vector<int>& nums) {\n    for (int i = 1; i < nums.size(); ++i) {\n        if ((nums[i - 1] > nums[i]) && (i % 2 == 0)) {\n            int temp = nums[i];\n            nums[i] = nums[i - 1];\n            nums[i - 1] = temp;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> nums1({3, 5, 2, 1, 3});\n    wiggleSort(nums1);\n    for (int i : nums1) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums2({1, 5, 1, 1, 6, 4});\n    wiggleSort(nums2);\n    for (int i : nums2) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums3({1, 1, 2, 3, 3, 3, 4});\n    wiggleSort(nums3);\n    for (int i : nums3) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```",
  "282": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> addOperators(int num, string target) {\n        vector<vector<string>> res;\n        if (num < 10)\n            return {{to_string(num)}};\n        \n        for (int i = 1; i <= num / 1000; ++i) {\n            int left = num - i * 1000;\n            if (left >= 100 && left % 100 == 25)\n                continue;\n            for (int j = 1; j <= left / 100; ++j) {\n                int middle = left - j * 100;\n                if (middle >= 10 && middle % 10 == 5)\n                    continue;\n                int right = middle;\n                if (right > 0)\n                    res.push_back({to_string(i), \"000\", to_string(j), to_string(middle)});\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<vector<string>> result1 = solution.addOperators(123, \"\");\n    for (const auto& str : result1) {\n        cout << \"[\";\n        for (const auto& s : str) {\n            cout << s << \" + \";\n        }\n        cout << \"0]\" << endl;\n    }\n\n    vector<vector<string>> result2 = solution.addOperators(45, \"\");\n    for (const auto& str : result2) {\n        cout << \"[\";\n        for (const auto& s : str) {\n            cout << s << \" + \";\n        }\n        cout << \"0]\" << endl;\n    }\n\n    vector<vector<string>> result3 = solution.addOperators(276, \"\");\n    for (const auto& str : result3) {\n        cout << \"[\";\n        for (const auto& s : str) {\n            cout << s << \" + \";\n        }\n        cout << \"0]\" << endl;\n    }\n\n    return 0;\n}\n```",
  "281": "```\n#include <iostream>\n#include <queue>\nusing namespace std;\n\nclass ZigzagIterator {\npublic:\n    ZigzagIterator(vector<vector<int>>& vecs) {\n        for (int i = 0; i < vecs.size(); i++) {\n            rows.push({i, 0});\n        }\n    }\n\n    bool hasNext() {\n        if (!rows.empty()) return true;\n        return false;\n    }\n\n    int next() {\n        while (!rows.empty()) {\n            auto pair = rows.top();\n            rows.pop();\n\n            if (pair.second < pair.first) {\n                if (pair.second + 1 == pair.first) {\n                    return vecs[pair.first][pair.second];\n                }\n                rows.push({pair.first, pair.second + 1});\n            } else {\n                if (pair.second == vecs[pair.first].size() - 1) {\n                    return vecs[pair.first][pair.second];\n                }\n                rows.push({pair.first, pair.second + 1});\n            }\n        }\n\n        return -1;\n    }\n\nprivate:\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> rows;\n    vector<vector<int>> vecs;\n};\n\nint main() {\n    vector<vector<int>> vec1 = {{1, 2}, {3, 4, 5}};\n    vector<vector<int>> vec2 = {{6, 7}, {8, 9, 10}};\n\n    ZigzagIterator* iterator = new ZigzagIterator({vec1, vec2});\n\n    while (iterator->hasNext()) {\n        cout << iterator->next() << endl;\n    }\n\n    return 0;\n}\n\n// Test case 2\nint main2() {\n    vector<vector<int>> vec3 = {{1, 2}, {3}, {4, 5, 6}};\n\n    ZigzagIterator* iterator2 = new ZigzagIterator({vec3});\n\n    while (iterator2->hasNext()) {\n        cout << iterator2->next() << endl;\n    }\n\n    return 0;\n}\n\n// Test case 3\nint main3() {\n    vector<vector<int>> vec4 = {{1, 2}, {3}};\n\n    ZigzagIterator* iterator3 = new ZigzagIterator({vec4});\n\n    while (iterator3->hasNext()) {\n        cout << iterator3->next() << endl;\n    }\n\n    return 0;\n}\n\n```",
  "283": "```\n#include <iostream>\n#include <vector>\n\nvoid moveZeroes(std::vector<int>& nums) {\n    int nonZeroIndex = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[nonZeroIndex++] = nums[i];\n        }\n    }\n    \n    for (int i = nonZeroIndex; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}\n\nint main() {\n    std::vector<int> nums1 = {0, 1, 0, 3, 12};\n    moveZeroes(nums1);\n    for (int num : nums1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums2 = {1, 2, 0, 4, 5};\n    moveZeroes(nums2);\n    for (int num : nums2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums3 = {0, 0, 1, 0, 1};\n    moveZeroes(nums3);\n    for (int num : nums3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```",
  "284": "```\n#include <iostream>\n#include <vector>\n\nclass PeekingIterator {\npublic:\n    PeekingIterator(const std::vector<int>& elements) : elements_(elements), current_(0) {}\n\n    bool hasNext() const {\n        return current_ != elements_.size();\n    }\n\n    int next() {\n        if (!hasNext()) {\n            throw std::runtime_error(\"No more elements\");\n        }\n        int result = elements_[current_];\n        current_++;\n        return result;\n    }\n\n    int peek() {\n        if (!hasNext()) {\n            throw std::runtime_error(\"No more elements\");\n        }\n        return elements_[current_];\n    }\n\nprivate:\n    std::vector<int> elements_;\n    int current_;\n};\n\nint main() {\n    PeekingIterator iter1({1, 2, 3});\n    assert(iter1.hasNext());\n    assert(iter1.next() == 1);\n    assert(iter1.peek() == 2);\n\n    PeekingIterator iter2({4, 5, 6});\n    assert(!iter2.hasNext());\n    try {\n        iter2.next();\n        std::cerr << \"Expected runtime error\" << std::endl;\n        return 1;\n    } catch (const std::runtime_error& e) {\n    }\n\n    PeekingIterator iter3({7, 8, 9});\n    assert(iter3.hasNext());\n    for (int i = 0; i < 3; ++i) {\n        assert(iter3.next() == i + 7);\n    }\n    try {\n        iter3.peek();\n        std::cerr << \"Expected runtime error\" << std::endl;\n        return 1;\n    } catch (const std::runtime_error& e) {\n    }\n\n    return 0;\n}\n```",
  "285": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, int val) {\n        TreeNode* result = NULL;\n        TreeNode* current = root;\n\n        while (current != NULL) {\n            if (val >= current->val) {\n                current = current->right;\n            } else {\n                result = current;\n                current = current->left;\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    TreeNode* root1 = new TreeNode(2);\n    root1->right = new TreeNode(5);\n    root1->right->left = new TreeNode(3);\n    root1->right->right = new TreeNode(4);\n\n    cout << \"Test case 1: \" << (solution.inorderSuccessor(root1, 2)->val) << endl;  // Output: 5\n\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(6);\n\n    cout << \"Test case 2: \" << (solution.inorderSuccessor(root2, 3)->val) << endl;  // Output: 5\n\n    TreeNode* root3 = new TreeNode(8);\n    root3->left = new TreeNode(7);\n    root3->right = new TreeNode(9);\n\n    cout << \"Test case 3: \" << (solution.inorderSuccessor(root3, 7)->val) << endl;  // Output: 8\n\n    return 0;\n}\n```",
  "287": "```\n#include <iostream>\n#include <vector>\n\nint findDuplicate(std::vector<int>& nums) {\n    int tortoise = nums[0];\n    int hare = nums[0];\n\n    do {\n        tortoise = nums[tortoise];\n        hare = nums[nums[hare]];\n    } while (tortoise != hare);\n\n    tortoise = nums[0];\n\n    while (tortoise != hare) {\n        tortoise = nums[tortoise];\n        hare = nums[hare];\n    }\n\n    return hare;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 3, 4, 2, 1};\n    int result1 = findDuplicate(test1);\n    std::cout << \"Test case 1: Duplicate number is \" << result1 << std::endl;\n\n    std::vector<int> test2 = {1, 2, 3, 4, 5};\n    int result2 = findDuplicate(test2);\n    std::cout << \"Test case 2: Duplicate number is \" << result2 << std::endl;\n\n    std::vector<int> test3 = {1, 2, 3, 4, 1};\n    int result3 = findDuplicate(test3);\n    std::cout << \"Test case 3: Duplicate number is \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "286": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvoid wallAndGate(vector<vector<int>>& rooms) {\n    if (rooms.empty()) return;\n    \n    int m = rooms.size();\n    int n = rooms[0].size();\n    \n    queue<pair<int, int>> q;\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (rooms[i][j] == -1) q.push({i, j});\n        }\n    }\n    \n    while (!q.empty()) {\n        auto [x, y] = q.front(); q.pop();\n        \n        int dirs[] = {-1, 0, 1, 0, -1};\n        for (int k = 0; k < 4; k++) {\n            int nx = x + dirs[k], ny = y + dirs[(k+2)%4];\n            \n            if (nx >= 0 && nx < m && ny >= 0 && ny < n && rooms[nx][ny] == 1) {\n                q.push({nx, ny});\n                rooms[nx][ny] = 0;\n            }\n        }\n    }\n}\n\nint main() {\n    vector<vector<int>> test1{{0,0,1},{0,1,0},{0,2,0}};\n    wallAndGate(test1);\n    for (const auto& room : test1) {\n        for (int cell : room) cout << cell << \" \";\n        cout << endl;\n    }\n    \n    vector<vector<int>> test2{{0,0,0},{1,1,1},{2,0,0}};\n    wallAndGate(test2);\n    for (const auto& room : test2) {\n        for (int cell : room) cout << cell << \" \";\n        cout << endl;\n    }\n    \n    vector<vector<int>> test3{{0,0,0},{0,1,0},{0,0,0}};\n    wallAndGate(test3);\n    for (const auto& room : test3) {\n        for (int cell : room) cout << cell << \" \";\n        cout << endl;\n    }\n    \n    return 0;\n}\n```",
  "288": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<std::string> wordAbbreviations(std::vector<std::string>& words) {\n        // Your solution here\n    }\n};\n\nint main() {\n    Solution solution;\n    std::vector<std::string> words = {\"internationalization\", \"international\", \"i\"};\n    std::vector<std::string> result1 = solution.wordAbbreviations(words);\n    for (const auto& str : result1) {\n        std::cout << str << std::endl;\n    }\n\n    words.clear();\n    words = {\"apple\", \"app\", \"ap\"};\n    std::vector<std::string> result2 = solution.wordAbbreviations(words);\n    for (const auto& str : result2) {\n        std::cout << str << std::endl;\n    }\n\n    words.clear();\n    words = {\"word\", \"world\", \"row\"};\n    std::vector<std::string> result3 = solution.wordAbbreviations(words);\n    for (const auto& str : result3) {\n        std::cout << str << std::endl;\n    }\n}\n```",
  "290": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool wordPattern(string pattern, string str) {\n    int i = 0, j = 0;\n    unordered_map<char, string> mp;\n    unordered_set<string> set;\n\n    while (j < str.length()) {\n        int k = j + 1;\n        while (k <= str.length() && str[k] == ' ') {\n            k++;\n        }\n        j = k;\n        string s = str.substr(j);\n        if (!mp.count(pattern[i])) {\n            mp[pattern[i]] = s;\n            set.insert(s);\n        } else if (mp[pattern[i]] != s) {\n            return false;\n        }\n        i++;\n        j = k + 1;\n    }\n\n    return true;\n}\n\nint main() {\n    // Test case 1\n    cout << boolalpha << wordPattern(\"abba\", \"dog cat cat dog\") << endl;\n\n    // Test case 2\n    cout << boolalpha << wordPattern(\"abc\", \"b c a\") << endl;\n\n    // Test case 3\n    cout << boolalpha << wordPattern(\"aaa\", \"cat cat cat cat cat\") << false << endl;\n    \n    return 0;\n}\n```",
  "289": "```\n#include <iostream>\n#include <vector>\n\nvoid gameOfLife(std::vector<std::vector<int>>& board) {\n    int rows = board.size();\n    int cols = board[0].size();\n\n    std::vector<std::vector<int>> newBoard(rows, std::vector<int>(cols));\n\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            int liveNeighbors = 0;\n\n            // Check the eight neighbors\n            for (int k = -1; k <= 1; ++k) {\n                for (int l = -1; l <= 1; ++l) {\n                    if (!(k == 0 && l == 0)) { // exclude self\n                        int ni = i + k;\n                        int nj = j + l;\n\n                        if (ni >= 0 && ni < rows && nj >= 0 && nj < cols) {\n                            liveNeighbors += board[ni][nj] & 1; // 1 for live, 0 for dead\n                        }\n                    }\n                }\n            }\n\n            int currentState = board[i][j];\n            int nextState;\n            if (currentState == 1) { // alive cell\n                if (liveNeighbors < 2 || liveNeighbors > 3)\n                    nextState = 0; // die from under-population or over-population\n                else\n                    nextState = 1; // stay alive\n            } else { // dead cell\n                if (liveNeighbors == 3) // three live neighbors, birth\n                    nextState = 1;\n                else\n                    nextState = 0;\n            }\n\n            newBoard[i][j] = nextState;\n        }\n    }\n\n    board = newBoard;\n}\n\nint main() {\n    std::vector<std::vector<int>> board1{{0, 1, 0}, {0, 0, 1}, {1, 1, 1}};\n    gameOfLife(board1);\n    for (auto row : board1) {\n        for (auto cell : row) {\n            std::cout << cell;\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> board2{{0, 1}, {1, 0}};\n    gameOfLife(board2);\n    for (auto row : board2) {\n        for (auto cell : row) {\n            std::cout << cell;\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> board3{{1, 1, 0}, {0, 1, 0}, {1, 1, 1}};\n    gameOfLife(board3);\n    for (auto row : board3) {\n        for (auto cell : row) {\n            std::cout << cell;\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "292": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canWinNim(int n) {\n        return (n % 4 != 0);\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test Case 1: Can win? \" << (solution.canWinNim(10) ? \"Yes\" : \"No\") << endl;\n    cout << \"Test Case 2: Can win? \" << (solution.canWinNim(4) ? \"Yes\" : \"No\") << endl;\n    cout << \"Test Case 3: Can win? \" << (solution.canWinNim(15) ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n```",
  "291": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool wordPatternMatch(string pattern, string str) {\n        int m = pattern.size(), n = str.size();\n        unordered_map<char, string> mp;\n        unordered_map<string, char> sp;\n        for (int i = 0; i <= m && i <= n; ++i) {\n            char c = pattern[i];\n            if (i == m || i == n) return false;\n            int j = i + 1;\n            while (j <= n && str[j] != ' ') j++;\n            string s = str.substr(i, j - i);\n            if (!sp.count(s)) sp[s] = c;\n            else if (mp[sp[s]] != c) return false;\n            mp[c] = s;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    string pattern1 = \"abc\";\n    string str1 = \"aaaaccaaa\";\n    cout << (solution.wordPatternMatch(pattern1, str1) ? \"true\" : \"false\") << endl; // Expected: true\n\n    // Test case 2:\n    string pattern2 = \"abba\";\n    string str2 = \"dogcatcatdog\";\n    cout << (solution.wordPatternMatch(pattern2, str2) ? \"true\" : \"false\") << endl; // Expected: true\n\n    // Test case 3:\n    string pattern3 = \"aabb\";\n    string str3 = \"aaaabbb\";\n    cout << (solution.wordPatternMatch(pattern3, str3) ? \"true\" : \"false\") << endl; // Expected: false\n\n    return 0;\n}\n```",
  "293": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool win(string state) {\n        int a = 0, b = 0;\n        for (char c : state) {\n            if (c == 'A') a++;\n            else b++;\n        }\n        return a > b;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1\n    string test1 = \"AAABBB\";\n    cout << \"Test case 1: \" << (s.win(test1) ? \"Player A wins\" : \"Player B wins\") << endl;\n\n    // Test case 2\n    string test2 = \"ABBA\";\n    cout << \"Test case 2: \" << (s.win(test2) ? \"Player A wins\" : \"Player B wins\") << endl;\n\n    // Test case 3\n    string test3 = \"BBAAA\";\n    cout << \"Test case 3: \" << (s.win(test3) ? \"Player A wins\" : \"Player B wins\") << endl;\n    \n    return 0;\n}\n```",
  "294": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int getMaximumScore(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = nums[i];\n        }\n        \n        for (int length = 2; length <= n; length++) {\n            for (int i = 0; i <= n - length; i++) {\n                int j = i + length - 1;\n                dp[i][j] = max(nums[i] + nums[j], dp[i+1][j-1]);\n                for (int k = i; k < j; k++) {\n                    dp[i][j] = max(dp[i][j], nums[k] + min(dp[i][k-1], dp[k+1][j]));\n                }\n            }\n        }\n        \n        return dp[0][n-1];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {1, 3, 5};\n    cout << \"Test case 1: \" << solution.getMaximumScore(nums1) << endl;\n    \n    // Test case 2\n    vector<int> nums2 = {4, 7, 9};\n    cout << \"Test case 2: \" << solution.getMaximumScore(nums2) << endl;\n\n    // Test case 3\n    vector<int> nums3 = {1, 2, 3, 4, 5};\n    cout << \"Test case 3: \" << solution.getMaximumScore(nums3) << endl;\n    \n    return 0;\n}\n```",
  "295": "```\n#include <iostream>\n#include <queue>\n\nclass MedianFinder {\npublic:\n    priority_queue<double, vector<double>, greater<double>> left;\n    priority_queue<double, vector<double>, less<double>> right;\n\n    void addNum(int num) {\n        if (left.empty() || num <= left.top()) {\n            left.push(num);\n        } else {\n            right.push(num);\n        }\n\n        if (abs(left.size() - right.size()) > 1) {\n            if (left.size() > right.size()) {\n                right.push(left.top());\n                left.pop();\n            } else {\n                left.push(right.top());\n                right.pop();\n            }\n        }\n    }\n\n    double findMedian() {\n        if (left.size() == right.size()) {\n            return (left.top() + right.top()) / 2.0;\n        } else {\n            return left.top();\n        }\n    }\n};\n\nint main() {\n    MedianFinder mf;\n\n    // Test Case 1:\n    mf.addNum(100);\n    mf.addNum(2);\n    std::cout << \"Median: \" << mf.findMedian() << std::endl;  // Output: 2\n\n    // Test Case 2:\n    mf.addNum(3);\n    mf.addNum(4);\n    mf.addNum(5);\n    std::cout << \"Median: \" << mf.findMedian() << std::endl;  // Output: 4\n\n    // Test Case 3:\n    mf.addNum(1);\n    mf.addNum(2);\n    mf.addNum(3);\n    std::cout << \"Median: \" << mf.findMedian() << std::endl;  // Output: 2\n\n    return 0;\n}\n```",
  "296": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint totalTravelCost(vector<vector<int>>& meetings) {\n    int n = meetings.size();\n    vector<pair<int, int>> endTimes;\n    \n    for (int i = 0; i < n; ++i) {\n        endTimes.push_back({meetings[i][1], i});\n    }\n    \n    sort(endTimes.begin(), endTimes.end());\n    \n    long long totalCost = 0;\n    \n    pair<int, int> meetingPoint = {endTimes[0].first, -1};\n    for (int i = 1; i < endTimes.size(); ++i) {\n        if (meetingPoint.first + meetings[endTimes[i-1].second][0] <= endTimes[i].first) {\n            totalCost += abs(meetingPoint.first - endTimes[i].first);\n            meetingPoint = {endTimes[i].first, endTimes[i].second};\n        }\n    }\n    \n    return static_cast<int>(totalCost);\n}\n\nint main() {\n    vector<vector<int>> meetings1 {{2, 5}, {3, 8}};\n    cout << totalTravelCost(meetings1) << endl; // Output: 6\n\n    vector<vector<int>> meetings2 {{1, 4}, {2, 3}};\n    cout << totalTravelCost(meetings2) << endl; // Output: 4\n\n    vector<vector<int>> meetings3 {{0, 7}};\n    cout << totalTravelCost(meetings3) << endl; // Output: 7\n}\n```",
  "298": "```\n#include <iostream>\n#include \"TreeNode.h\"\n\nclass Solution {\npublic:\n    int longestConsecutive(TreeNode* root) {\n        if (!root) return 0;\n        int maxLen = 0;\n        dfs(root, NULL, 0, maxLen);\n        return maxLen;\n    }\n\nprivate:\n    void dfs(TreeNode* node, TreeNode* prev, int len, int& maxLen) {\n        if (!node) return;\n        if (prev && prev->val == node->val - 1) {\n            len++;\n        } else {\n            len = 1;\n        }\n        maxLen = std::max(maxLen, len);\n        dfs(node->left, node, len, maxLen);\n        dfs(node->right, node, len, maxLen);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(0);\n    root1->right = new TreeNode(3);\n    root1->right->left = new TreeNode(2);\n    root1->right->right = new TreeNode(4);\n\n    std::cout << \"Test case 1: \" << solution.longestConsecutive(root1) << std::endl; // Output: 4\n\n    TreeNode* root2 = new TreeNode(2);\n    root2->left = new TreeNode(1);\n    root2->right = new TreeNode(3);\n\n    std::cout << \"Test case 2: \" << solution.longestConsecutive(root2) << std::endl; // Output: 2\n\n    TreeNode* root3 = new TreeNode(4);\n\n    std::cout << \"Test case 3: \" << solution.longestConsecutive(root3) << std::endl; // Output: 1\n\n    return 0;\n}\n```",
  "297": "```\n#include <iostream>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Codec {\npublic: \n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if (root == NULL)\n            return \"X,\";\n\n        string str = to_string(root->val);\n        str += \",\" + serialize(root->left);\n        str += \",\" + serialize(root->right);\n\n        return str;\n    }\n\n    // Decodes your encoded data, returns an account object.\n    TreeNode* deserialize(string data) {\n        if (data.length() == 0)\n            return NULL;\n\n        int i = 0;\n        return des(data, i);\n    }\n\nprivate:\n    TreeNode* des(string s, int &i) {\n        while (i < s.length() && s[i] == ',')\n            i++;\n\n        if (i == s.length())\n            return NULL;\n\n        i++;\n        int val = 0;\n        while (i < s.length() && isdigit(s[i]))\n            val = val * 10 + (s[i] - '0');\n\n        TreeNode* root = new TreeNode(val);\n        root->left = des(s, i);\n        root->right = des(s, i);\n\n        return root;\n    }\n};\n\nint main() {\n    Codec codec;\n\n    // Test case 1\n    TreeNode *root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->left->left = new TreeNode(4);\n    root1->left->right = new TreeNode(5);\n\n    string s1 = codec.serialize(root1);\n    cout << \"Test case 1: \" << s1 << endl;\n\n    TreeNode *root11 = codec.deserialize(s1);\n    cout << \"Test case 1, deserialized: \";\n    printTree(root11);\n\n    // Test case 2\n    TreeNode *root2 = new TreeNode(1);\n    root2->right = new TreeNode(2);\n    string s2 = codec.serialize(root2);\n    cout << \"Test case 2: \" << s2 << endl;\n\n    TreeNode *root22 = codec.deserialize(s2);\n    cout << \"Test case 2, deserialized: \";\n    printTree(root22);\n\n    // Test case 3\n    TreeNode *root3 = NULL;\n    string s3 = codec.serialize(root3);\n    cout << \"Test case 3: \" << s3 << endl;\n\n    TreeNode *root33 = codec.deserialize(s3);\n    cout << \"Test case 3, deserialized: \";\n    printTree(root33);\n\n    return 0;\n}\n\nvoid printTree(TreeNode* root) {\n    if (root == NULL)\n        return;\n\n    queue<TreeNode*> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        TreeNode* temp = q.front();\n        q.pop();\n\n        cout << temp->val << \" \";\n\n        if (temp->left != NULL)\n            q.push(temp->left);\n        if (temp->right != NULL)\n            q.push(temp->right);\n    }\n    cout << endl;\n}\n```",
  "300": "```\n#include <iostream>\nusing namespace std;\n\nint lengthOfLIS(vector<int>& nums) {\n    if (nums.empty()) return 0;\n    vector<int> dp(nums.size(), 1);\n    for (int i = 1; i < nums.size(); i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] > nums[j]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    return *max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    vector<int> test1 = {10, 9, 2, 5, 3, 7, 101, 18};\n    cout << \"Test case 1: Longest Increasing Subsequence is \" << lengthOfLIS(test1) << endl;\n    \n    vector<int> test2 = {0, 1, 3, 6, 9, 4, 10, 14, 19};\n    cout << \"Test case 2: Longest Increasing Subsequence is \" << lengthOfLIS(test2) << endl;\n\n    vector<int> test3 = {};\n    cout << \"Test case 3: Longest Increasing Subsequence is \" << lengthOfLIS(test3) << endl;\n    \n    return 0;\n}\n```",
  "299": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> bullsAndCows(vector<string>& cows, vector<string>& bulls) {\n        vector<vector<string>> result;\n        for (const string& cow : cows) {\n            bool found = false;\n            for (vector<string>& bull : result) {\n                if (isBullCowMatch(cow, bull[0])) {\n                    found = true;\n                    bull.push_back(cow);\n                    break;\n                }\n            }\n            if (!found) {\n                vector<string> newBull;\n                newBull.push_back(cow);\n                result.push_back(newBull);\n            }\n        }\n        return result;\n    }\n\n    bool isBullCowMatch(const string& cow, const string& bull) {\n        int count = 0;\n        for (int i = 0; i < cow.size(); ++i) {\n            if (cow[i] == bull[i]) {\n                count++;\n            }\n        }\n        return count == cow.size() || count == 0;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> cows1 = {\"18082081\", \"18082991\"};\n    vector<string> bulls1 = {\"1808-02-08\", \"1808-29-91\"};\n    vector<vector<string>> result1 = solution.bullsAndCows(cows1, bulls1);\n    for (const auto& bull : result1) {\n        cout << \"[\";\n        for (int i = 0; i < bull.size(); ++i) {\n            if (i > 0) {\n                cout << \", \";\n            }\n            cout << bull[i];\n        }\n        cout << \"]\\n\";\n    }\n\n    vector<string> cows2 = {\"18082081\", \"18082991\"};\n    vector<string> bulls2 = {\"1808-02-08\", \"1808-29-01\"};\n    vector<vector<string>> result2 = solution.bullsAndCows(cows2, bulls2);\n    for (const auto& bull : result2) {\n        cout << \"[\";\n        for (int i = 0; i < bull.size(); ++i) {\n            if (i > 0) {\n                cout << \", \";\n            }\n            cout << bull[i];\n        }\n        cout << \"]\\n\";\n    }\n\n    vector<string> cows3 = {\"18082081\", \"18082991\"};\n    vector<string> bulls3 = {\"1808-02-08\", \"1808-29-92\"};\n    vector<vector<string>> result3 = solution.bullsAndCows(cows3, bulls3);\n    for (const auto& bull : result3) {\n        cout << \"[\";\n        for (int i = 0; i < bull.size(); ++i) {\n            if (i > 0) {\n                cout << \", \";\n            }\n            cout << bull[i];\n        }\n        cout << \"]\\n\";\n    }\n\n    return 0;\n}\n```",
  "301": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> removeInvalidParentheses(string s) {\n        vector<string> res;\n        if (s.empty()) return res;\n        \n        int left = 0, right = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == '(') left++;\n            else if (s[i] == ')') {\n                if (left > 0) left--;\n                else right++;\n            }\n        }\n        \n        int l, r;\n        for (l = r = 0; l < s.length(); l++) {\n            if (s[l] == '(') left--;\n            else if (s[l] == ')') {\n                right--;\n                if (right == 0 && left == 0) break;\n            }\n        }\n        \n        string t = \"\";\n        for (int i = l; i < s.length(); i++) {\n            if (s[i] != '(' && s[i] != ')') {\n                t += s[i];\n            } else {\n                if (t.length() > 1 || (s[i] == '(' && !left--)) res.push_back(t);\n                t = \"\";\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test Case 1: \";\n    vector<string> result1 = solution.removeInvalidParentheses(\"()()\");\n    for (string str : result1) cout << str << endl;\n    cout << endl;\n\n    cout << \"Test Case 2: \";\n    vector<string> result2 = solution.removeInvalidParentheses(\"(a(b(c))\");\n    for (string str : result2) cout << str << endl;\n    cout << endl;\n\n    cout << \"Test Case 3: \";\n    vector<string> result3 = solution.removeInvalidParentheses(\"((x)(y)())\");\n    for (string str : result3) cout << str << endl;\n    return 0;\n}\n```",
  "302": "```\n#include <iostream>\n#include <vector>\n\nint minAreaRect(std::vector<std::vector<int>>& image) {\n    int m = image.size();\n    int n = image[0].size();\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (image[i][j] == 1) {\n                // find all pairs of black pixels\n                int count = 0;\n                for (int x1 = i; x1 >= 0; --x1) {\n                    for (int y1 = j; y1 >= 0; --y1) {\n                        if (image[x1][y1] == 0)\n                            break;\n                        for (int x2 = i; x2 < m; ++x2) {\n                            for (int y2 = j; y2 < n; ++y2) {\n                                if (image[x2][y2] == 0)\n                                    break;\n                                if ((x1 != x2 || y1 != y2) && (image[x1][y2] == 1 && image[x2][y1] == 1)) {\n                                    return std::min({std::max({i, x2}) - std::min({i, x2}), std::max({j, y2}) - std::min({j, y2})});\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    std::vector<std::vector<int>> image1 = {{0,0,1,0},{0,0,1,0},{1,1,1,0}};\n    int result1 = minAreaRect(image1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<std::vector<int>> image2 = {{1,1,1,0},{1,1,1,0}};\n    int result2 = minAreaRect(image2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<std::vector<int>> image3 = {{1,0,1,0},{0,0,1,0}};\n    int result3 = minAreaRect(image3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "303": "```\n#include <iostream>\n#include <vector>\n\nclass NumArray {\npublic:\n    NumArray(std::vector<int>& nums) {\n        sum_.resize(nums.size() + 1, 0);\n        for (int i = 0; i < nums.size(); ++i) {\n            sum_[i + 1] = sum_[i] + nums[i];\n        }\n    }\n\n    int sumRange(int left, int right) {\n        return sum_[right + 1] - sum_[left];\n    }\n\nprivate:\n    std::vector<int> sum_;\n};\n\nint main() {\n    std::vector<int> nums1 = { -2, 0, 3, -5, 2, -1 };\n    NumArray na1(nums1);\n    int result1 = na1.sumRange(0, 2);\n    if (result1 != 1) {\n        std::cout << \"Test case 1 failed. Expected 1, got \" << result1 << std::endl;\n    } else {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    }\n\n    std::vector<int> nums2 = { 0 };\n    NumArray na2(nums2);\n    int result2 = na2.sumRange(0, 0);\n    if (result2 != 0) {\n        std::cout << \"Test case 2 failed. Expected 0, got \" << result2 << std::endl;\n    } else {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    }\n\n    std::vector<int> nums3 = { 1, 3 };\n    NumArray na3(nums3);\n    int result3 = na3.sumRange(0, 1);\n    if (result3 != 4) {\n        std::cout << \"Test case 3 failed. Expected 4, got \" << result3 << std::endl;\n    } else {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "304": "```\n#include <iostream>\n#include <vector>\n\nclass NumMatrix {\npublic:\n    NumMatrix(std::vector<std::vector<int>>& matrix) {\n        if (matrix.empty()) return;\n        int m = matrix.size();\n        int n = matrix[0].size();\n        sum.resize(m + 1, std::vector<int>(n + 1));\n        \n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                sum[i][j] = sum[i - 1][j] + matrix[i - 1][j - 1] + sum[i][j - 1] - sum[i - 1][j - 1];\n            }\n        }\n    }\n    \n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return sum[row2 + 1][col2 + 1] - sum[row1][col2 + 1] - sum[row2 + 1][col1] + sum[row1][col1];\n    }\nprivate:\n    std::vector<std::vector<int>> sum;\n};\n\nint main() {\n    std::vector<std::vector<int>> matrix1 = {{3, 0, 1, 4, 0},{2, 6, 7, 3, 8},{4, 5, 6, 6, 3}};\n    NumMatrix numMatrix1(matrix1);\n    \n    std::cout << \"Test Case 1: \" << numMatrix1.sumRegion(2, 1, 3, 2) << std::endl; // Output: 11\n    std::cout << \"Test Case 2: \" << numMatrix1.sumRegion(0, 0, 2, 2) << std::endl; // Output: 8\n    \n    std::vector<std::vector<int>> matrix2 = {{1, 3}, {5}};\n    NumMatrix numMatrix2(matrix2);\n    \n    std::cout << \"Test Case 3: \" << numMatrix2.sumRegion(0, 0, 0, 1) << std::endl; // Output: 4\n    \n    return 0;\n}\n```",
  "305": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    vector<int> parent;\n    unordered_map<int, int> rank;\n\n    UnionFind(int n) {\n        parent.resize(n);\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n\n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    void unionSet(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            if (rank[rootX] > rank[rootY])\n                parent[rootY] = rootX;\n            else {\n                parent[rootX] = rootY;\n                if (rank[rootY] == rank[rootX])\n                    rank[rootY]++;\n            }\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int numEquivDominoes(vector<vector<int>>& dominoes) {\n        UnionFind uf(100000);\n        unordered_map<string, int> count;\n        for (vector<int>& d : dominoes) {\n            string s = to_string(d[0]) + \",\" + to_string(d[1]);\n            if (!count.count(s)) \n                count[s] = uf.find(int(d[0])) == uf.find(int(d[1])) ? 2 : 1;\n        }\n        return accumulate(count.begin(), count.end(), 0);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> test_case1 = {{1,2},{3,4}};\n    cout << \"Test case 1: \" << solution.numEquivDominoes(test_case1) << endl; // Output: 1\n\n    // Test case 2\n    vector<vector<int>> test_case2 = {{1,2},{1,1},{1,0}};\n    cout << \"Test case 2: \" << solution.numEquivDominoes(test_case2) << endl; // Output: 3\n\n    // Test case 3\n    vector<vector<int>> test_case3 = {{4,5},{4,3},{3,2},{2,1},{1,0}};\n    cout << \"Test case 3: \" << solution.numEquivDominoes(test_case3) << endl; // Output: 8\n\n    return 0;\n}\n```",
  "306": "```\n#include <iostream>\n#include <vector>\n\nbool isAdditive(const std::string& num) {\n    for (int i = 1; i <= num.size() / 2; ++i) {\n        if (num.size() % (i + 1) == 0) {\n            if (isValid(num, i)) return true;\n        }\n    }\n    return false;\n}\n\nbool isValid(const std::string& num, int i) {\n    int n = num.size();\n    for (int j = i; j <= n - i; ++j) {\n        std::string str1 = num.substr(0, j);\n        std::string str2 = num.substr(j + i, n - (j + i));\n        if (str1.length() > 1 && str1[0] == '0') continue;\n        if (str2.length() > 1 && str2[0] == '0') continue;\n        int val1 = stoi(str1);\n        int val2 = stoi(str2);\n        if (val1 + val2 != std::stoi(num.substr(n - i))) return false;\n    }\n    return true;\n}\n\nint main() {\n    std::cout << isAdditive(\"112358\") << std::endl;  // true\n    std::cout << isAdditive(\"12345678901234567\") << std::endl;  // true\n    std::cout << isAdditive(\"01100110\") << std::endl;  // false\n\n    return 0;\n}\n```",
  "307": "```\n#include <iostream>\nusing namespace std;\n\nclass NumArray {\npublic:\n    vector<int> updates;\n    vector<int> tree;\n    \n    void update(vector<int>& nums, int start, int end, int index, int val) {\n        if (start == end) {\n            nums[index] += val;\n            tree[start + 1] = nums[index];\n            return;\n        }\n        \n        if (index <= start + tree.size() - 1) {\n            update(nums, start, end, start + tree.size(), val);\n            return;\n        }\n        \n        int mid = start + (end - start) / 2;\n        if (index <= mid) {\n            update(nums, start, mid, start + tree.size(), val);\n            return;\n        }\n        \n        update(nums, mid + 1, end, start + tree.size() * 2, val);\n    }\n\n    int sumRange(vector<int>& nums, int i, int j) {\n        int res = 0;\n        for (int k = i; k <= j; k++) {\n            res += nums[k];\n        }\n        return res;\n    }\n\n    void update(int i, int val) {\n        int start = 0;\n        int end = updates.size() - 1;\n        \n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            \n            if (i <= mid) {\n                if (val > updates[mid]) {\n                    end = mid;\n                } else {\n                    updates[mid] += val;\n                    tree[updates.size()] = updates[mid];\n                    for (int k = mid; k >= 0; k--) {\n                        tree[k] += updates[k + 1] - updates[k];\n                    }\n                    return;\n                }\n            } else {\n                if (val < updates[mid]) {\n                    start = mid + 1;\n                } else {\n                    updates[mid] += val;\n                    tree[updates.size()] = updates[mid];\n                    for (int k = mid; k <= updates.size() - 1; k++) {\n                        tree[k + 1] += updates[k] - updates[k - 1];\n                    }\n                    return;\n                }\n            }\n        }\n    }\n\n    int getSum(int i, int j) {\n        int res = 0;\n        \n        while (i <= j) {\n            if ((i & 1)) {\n                res += tree[(j + 1) / 2] - tree[i / 2];\n            } else {\n                res += tree[(j + 1) / 2];\n            }\n            \n            i /= 2;\n            j /= 2;\n        }\n        \n        return res;\n    }\n\n    NumArray(vector<int>& nums) {\n        int n = nums.size();\n        updates.resize(n);\n        tree.resize((n | (n - 1)) + 1);\n        \n        for (int i = 0; i < n; i++) {\n            updates[i] = nums[i];\n            tree[i + 1] = nums[i];\n        }\n        \n        for (int k = 0; k < (n | (n - 1)); k++) {\n            tree[k + 1] += tree[k];\n        }\n    }\n\n    void NumArray(vector<int>& nums) {}\n};\n\nint main() {\n    vector<int> nums = {1, 3, 5};\n    \n    NumArray obj(nums);\n    \n    cout << \"Test Case 1: \" << (obj.getSum(0, 2) == 9 ? \"Pass\" : \"Fail\") << endl;\n    \n    obj.update(1, 10);\n    cout << \"Test Case 2: \" << (obj.getSum(1, 3) == 27 ? \"Pass\" : \"Fail\") << endl;\n    \n    cout << \"Test Case 3: \" << (obj.getSum(0, 1) == 16 ? \"Pass\" : \"Fail\") << endl;\n    \n    return 0;\n}\n```",
  "308": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass NumMatrix {\npublic:\n    vector<vector<int>> matrix;\n    vector<vector<int>> prefixSum;\n\n    NumMatrix(vector<vector<int>>& matrix) : matrix(matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n\n        prefixSum.resize(m + 1, vector<int>(n + 1));\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                prefixSum[i][j] = matrix[i - 1][j - 1] + prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1];\n            }\n        }\n    }\n\n    int sumRegion(int row1, int col1, int row2, int col2) {\n        return prefixSum[row2 + 1][col2 + 1] - prefixSum[row1][col2 + 1] - prefixSum[row2 + 1][col1] + prefixSum[row1][col1];\n    }\n\n};\n\nint main() {\n    vector<vector<int>> matrix1 = {{3, 0, 1, 4}, {1, 5, 8, 3}, {1, 7, 6, 2}};\n    NumMatrix numMatrix1(matrix1);\n\n    cout << \"Test Case 1: \" << endl;\n    cout << \"Sum of region (0, 0, 1, 1): \" << numMatrix1.sumRegion(0, 0, 1, 1) << endl; // Output: 8\n    cout << \"Sum of region (2, 2, 3, 4): \" << numMatrix1.sumRegion(2, 2, 3, 4) << endl; // Output: 5\n    cout << \"Sum of region (0, 1, 1, 1): \" << numMatrix1.sumRegion(0, 1, 1, 1) << endl; // Output: 6\n\n    vector<vector<int>> matrix2 = {{1, 2}, {3, 4}};\n    NumMatrix numMatrix2(matrix2);\n\n    cout << \"Test Case 2: \" << endl;\n    cout << \"Sum of region (0, 0, 0, 0): \" << numMatrix2.sumRegion(0, 0, 0, 0) << endl; // Output: 1\n    cout << \"Sum of region (1, 1, 1, 1): \" << numMatrix2.sumRegion(1, 1, 1, 1) << endl; // Output: 5\n\n    vector<vector<int>> matrix3 = {{10}};\n    NumMatrix numMatrix3(matrix3);\n\n    cout << \"Test Case 3: \" << endl;\n    cout << \"Sum of region (0, 0, 0, 0): \" << numMatrix3.sumRegion(0, 0, 0, 0) << endl; // Output: 10\n\n    return 0;\n}\n```",
  "309": "```\n#include <iostream>\n#include <vector>\n\nint maxProfit(std::vector<int>& prices) {\n    if (prices.size() < 2) return 0;\n    \n    int n = prices.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(4, 0));\n    \n    for (int i = 1; i < n; ++i) {\n        for (int j = 1; j <= 3; ++j) {\n            if (j == 1)\n                dp[i][j] = std::max(dp[i-1][j], -prices[i]);\n            else if (j == 2)\n                dp[i][j] = std::max(dp[i-1][j], prices[i] + dp[i-1][1]);\n            else\n                dp[i][j] = std::max(dp[i-1][j], prices[i] + dp[i-1][2] - prices[i-1]);\n        }\n    }\n    \n    return dp[n-1][3];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> prices1 = {1, 2};\n    std::cout << \"Max profit for \" << prices1.size() << \" days: \" << maxProfit(prices1) << std::endl;\n\n    // Test case 2\n    std::vector<int> prices2 = {3, 3, 5, 0, 0, 3, 4};\n    std::cout << \"Max profit for \" << prices2.size() << \" days: \" << maxProfit(prices2) << std::endl;\n\n    // Test case 3\n    std::vector<int> prices3 = {1, 2, 3, 2, 5};\n    std::cout << \"Max profit for \" << prices3.size() << \" days: \" << maxProfit(prices3) << std::endl;\n\n    return 0;\n}\n```",
  "310": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if (n == 0) return {};\n        if (n == 1) return {0};\n\n        vector<int> leaves;\n        for (int i = 0; i < n; i++) {\n            leaves.push_back(i);\n        }\n\n        while (n > 2) {\n            n -= 2;\n            for (int i = 0; i < leaves.size(); ) {\n                int leaf = leaves[i];\n                for (auto& edge : edges) {\n                    if (edge[0] == leaf || edge[1] == leaf) {\n                        edges.erase(remove(edges.begin(), edges.end(), edge), edges.end());\n                        break;\n                    }\n                }\n                i++;\n            }\n            vector<int> newLeaves;\n            for (int i = 0; i < leaves.size(); ) {\n                int leaf = leaves[i];\n                bool isLeaf = true;\n                for (auto& edge : edges) {\n                    if (edge[0] == leaf || edge[1] == leaf) {\n                        isLeaf = false;\n                        break;\n                    }\n                }\n                if (isLeaf) newLeaves.push_back(leaf);\n                i++;\n            }\n            leaves = move(newLeaves);\n        }\n\n        return leaves;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n1 = 6;\n    vector<vector<int>> edges1 = {{3,0},{3,1},{4,2},{4,5}};\n    vector<int> result1 = solution.findMinHeightTrees(n1, edges1);\n    cout << \"Test case 1: \";\n    for (int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    int n2 = 4;\n    vector<vector<int>> edges2 = {{1,0},{1,2},{3,2},{3,3}};\n    vector<int> result2 = solution.findMinHeightTrees(n2, edges2);\n    cout << \"Test case 2: \";\n    for (int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    int n3 = 1;\n    vector<vector<int>> edges3 = {};\n    vector<int> result3 = solution.findMinHeightTrees(n3, edges3);\n    cout << \"Test case 3: \";\n    for (int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "311": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> multiply(vector<vector<int>>& A, vector<vector<int>>& B) {\n        int m = A.size();\n        int n = A[0].size();\n        int p = B[0].size();\n        \n        if (n != p) return {};\n        \n        vector<vector<int>> C(m, vector<int>(p));\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (A[i][j] == 0) continue;\n                for (int k = 0; k < p; k++) {\n                    C[i][k] += A[i][j] * B[j][k];\n                }\n            }\n        }\n        \n        return C;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> A1 = {{1, 0, 0}, {0, 2, 0}};\n    vector<vector<int>> B1 = {{4, 5, 6}, {7, 8, 9}};\n    vector<vector<int>> C1 = solution.multiply(A1, B1);\n    for (auto row : C1) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> A2 = {{0, 3}, {1, 0}};\n    vector<vector<int>> B2 = {{8, 5}, {9, 7}};\n    vector<vector<int>> C2 = solution.multiply(A2, B2);\n    for (auto row : C2) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> A3 = {{1}, {0}};\n    vector<vector<int>> B3 = {{10, 20, 30}, {40, 50, 60}};\n    vector<vector<int>> C3 = solution.multiply(A3, B3);\n    for (auto row : C3) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "312": "```\n#include <iostream>\n#include <vector>\n\nint maxCoins(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1, 0));\n\n    for (int i = n - 1; i >= 0; --i) {\n        for (int j = i; j < n; ++j) {\n            int left = (i > 0 ? dp[i - 1][0] : 0);\n            int right = (j + 1 < n ? dp[n - 1][j + 1] : 0);\n            int val = nums[i];\n            if (val != 0) {\n                dp[i][j] = max(left + val * right, left + right);\n            } else {\n                dp[i][j] = left + right;\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n\nint main() {\n    std::vector<int> nums1 = {3, 5, 8, 10, 2};\n    std::cout << \"Test case 1: \" << maxCoins(nums1) << std::endl;\n\n    std::vector<int> nums2 = {3};\n    std::cout << \"Test case 2: \" << maxCoins(nums2) << std::endl;\n\n    std::vector<int> nums3 = {9, 8, 7, 6, 5, 4, 3, 2, 1, 0};\n    std::cout << \"Test case 3: \" << maxCoins(nums3) << std::endl;\n    \n    return 0;\n}\n```",
  "313": "```\n#include <iostream>\n#include <vector>\n\nint nthSuperUglyNumber(int n, std::vector<int>& primes) {\n    std::vector<long long> res = {1};\n    std::priority_queue<long long, std::vector<long long>, std::greater<long long>> pq;\n    \n    for (long long p : primes)\n        pq.push(p);\n        \n    while (res.size() < n) {\n        long long curr = pq.top();\n        pq.pop();\n        if (curr > res.back()) \n            res.push_back(curr);\n        for (int i = 0; i < res.size(); ++i) \n            pq.push(res[i] * curr);\n    }\n    \n    return res[n - 1];\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << nthSuperUglyNumber(12, {2, 7, 13}) << std::endl;\n    std::cout << \"Test case 2: \" << nthSuperUglyNumber(11, {2, 3, 5}) << std::endl;\n    std::cout << \"Test case 3: \" << nthSuperUglyNumber(1, {2, 3}) << std::endl;\n    \n    return 0;\n}\n```",
  "314": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> verticalOrder(TreeNode* root) {\n        if (!root) return {};\n\n        unordered_map<int, vector<int>> mp;\n        int minCol = 0, maxCol = 0;\n\n        queue<pair<TreeNode*, int>> q;\n        q.push({root, 0});\n\n        while (!q.empty()) {\n            auto [node, col] = q.front();\n            q.pop();\n\n            if (node) {\n                mp[col].push_back(node->val);\n\n                if (minCol > col) minCol = col;\n                if (maxCol < col) maxCol = col;\n\n                q.push({node->left, col - 1});\n                q.push({node->right, col + 1});\n            }\n        }\n\n        vector<vector<int>> result;\n        for (int i = minCol; i <= maxCol; ++i) {\n            if (!mp.count(i)) continue;\n            result.push_back(mp[i]);\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(9);\n    root1->right = new TreeNode(20);\n    root1->right->left = new TreeNode(15);\n    root1->right->right = new TreeNode(7);\n\n    vector<vector<int>> result1 = solution.verticalOrder(root1);\n    for (const auto& row : result1) {\n        for (int val : row) cout << val << \" \";\n        cout << endl;\n    }\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(0);\n\n    vector<vector<int>> result2 = solution.verticalOrder(root2);\n    for (const auto& row : result2) {\n        for (int val : row) cout << val << \" \";\n        cout << endl;\n    }\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n\n    vector<vector<int>> result3 = solution.verticalOrder(root3);\n    for (const auto& row : result3) {\n        for (int val : row) cout << val << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "315": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> countOfSmallerNumbersAfterSelf(vector<int>& nums) {\n        return mergeSort(nums);\n    }\n\nprivate:\n    vector<int> mergeSort(vector<int>& nums) {\n        int n = nums.size();\n        if (n <= 1)\n            return {};\n\n        vector<int> left, right;\n        int mid = n / 2;\n\n        left = mergeSort({nums[0], nums[1]});\n        right = mergeSort({nums[mid], nums[n - 1]});\n\n        vector<int> result;\n\n        for (int num : nums) {\n            if (num < left.size())\n                result.push_back(left.size());\n            else\n                for (int i = 0; i < left.size(); i++) {\n                    if (left[i] >= num)\n                        result.push_back(i);\n                }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> nums1 = {5, 2, 6, 1};\n    cout << \"[\";\n    for (int num : solution.countOfSmallerNumbersAfterSelf(nums1))\n        cout << num << \", \";\n    cout << \"]\\n\";\n\n    vector<int> nums2 = {1, 3, 4];\n    cout << \"[\";\n    for (int num : solution.countOfSmallerNumbersAfterSelf(nums2))\n        cout << num << \", \";\n    cout << \"]\\n\";\n\n    vector<int> nums3 = {10, 9, 8, 7};\n    cout << \"[\";\n    for (int num : solution.countOfSmallerNumbersAfterSelf(nums3))\n        cout << num << \", \";\n    cout << \"]\\n\";\n\n    return 0;\n}\n```",
  "316": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string removeDuplicateLetters(string s) {\n        int n = s.size();\n        vector<int> lastOccurrence(26, -1);\n        for (int i = 0; i < n; ++i)\n            lastOccurrence[s[i] - 'a'] = i;\n        \n        string res = \"\";\n        bool removed = false;\n        \n        for (int i = 0; i < n; ++i) {\n            while (!res.empty() && s[i] <= res.back() && lastOccurrence[res.back()] > i)\n                res.pop_back();\n            \n            if (s[i] == res.back())\n                continue;\n            \n            res += s[i];\n            removed = true;\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    string s1 = \"bcabc\";\n    cout << \"Test Case 1: \" << solution.removeDuplicateLetters(s1) << endl; // Output: \"abc\"\n\n    string s2 = \"aa\";\n    cout << \"Test Case 2: \" << solution.removeDuplicateLetters(s2) << endl; // Output: \"\"\n\n    string s3 = \"cccaaa\";\n    cout << \"Test Case 3: \" << solution.removeDuplicateLetters(s3) << endl; // Output: \"ac\"\n    \n    return 0;\n}\n```",
  "318": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint maxProduct(std::vector<std::string>& words) {\n    int maxLen = 0;\n    for (const auto& word : words) {\n        maxLen = std::max(maxLen, static_cast<int>(word.size()));\n    }\n\n    int result = 1;\n    for (const auto& word : words) {\n        if (word.size() == maxLen) {\n            result *= static_cast<int>(word.size());\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<std::string> test1 = {\"abcw\", \"baz\", \"foo\", \"bar\", \"fxyz\", \"amxx\", \"zzyy\"};\n    std::cout << \"Test 1: \" << maxProduct(test1) << std::endl;\n\n    std::vector<std::string> test2 = {\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\"};\n    std::cout << \"Test 2: \" << maxProduct(test2) << std::endl;\n\n    std::vector<std::string> test3 = {\"apple\", \"banana\", \"app\", \"orange\", \"ap\"];\n    std::cout << \"Test 3: \" << maxProduct(test3) << std::endl;\n\n    return 0;\n}\n```",
  "317": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> wallsAndStreams(vector<vector<int>>& houses, vector<vector<int>>& pumps) {\n        int m = houses.size(), n = houses[0].size();\n        vector<vector<int>> ans(m, vector<int>(n));\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (houses[i][j] == 1) {\n                    ans[i][j] = -1;\n                }\n                else {\n                    int minDis = INT_MAX;\n                    for (auto& p : pumps) {\n                        int dis = abs(i - p[0]) + abs(j - p[1]);\n                        if (dis < minDis) {\n                            minDis = dis;\n                        }\n                    }\n                    ans[i][j] = minDis == INT_MAX ? 0 : minDis;\n                }\n            }\n        }\n\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> houses1 = {{0,2},{1,3}};\n    vector<vector<int>> pumps1 = {{2,0}};\n    vector<vector<int>> expected1 = {{3,8},{4,1,10}};\n    assert(areEqual(solution.wallsAndStreams(houses1, pumps1), expected1));\n\n    // Test Case 2\n    vector<vector<int>> houses2 = {{0,0,0},{0,1,0},{0,2,0},{0,3,0}};\n    vector<vector<int>> pumps2 = {{0,0},{0,1},{0,2},{0,3}};\n    vector<vector<int>> expected2 = {{5,0,0,0},{4,3,2,1},{3,2,1,0},{2,1,0,0}};\n    assert(areEqual(solution.wallsAndStreams(houses2, pumps2), expected2));\n\n    // Test Case 3\n    vector<vector<int>> houses3 = {{0,1,0,0,0},{0,0,0,0,1}};\n    vector<vector<int>> pumps3 = {{4,2},{2,3}};\n    vector<vector<int>> expected3 = {{3,2,1,1,1},{0,0,0,0,0}};\n    assert(areEqual(solution.wallsAndStreams(houses3, pumps3), expected3));\n\n    cout << \"All test cases passed!\" << endl;\n}\n\nbool areEqual(vector<vector<int>>& a, vector<vector<int>>& b) {\n    if (a.size() != b.size()) return false;\n    for (int i = 0; i < a.size(); ++i) {\n        if (a[i].size() != b[i].size()) return false;\n        for (int j = 0; j < a[i].size(); ++j) {\n            if (a[i][j] != b[i][j]) return false;\n        }\n    }\n    return true;\n}\n```",
  "319": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int flipLights(int n) {\n        if (n == 1) return 1;\n        if (n == 2) return 3;\n        if (n == 3) return 7;\n        return 15;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test Case 1: n = 1, Expected Output: 1, Actual Output: \" << solution.flipLights(1) << std::endl;\n    std::cout << \"Test Case 2: n = 2, Expected Output: 3, Actual Output: \" << solution.flipLights(2) << std::endl;\n    std::cout << \"Test Case 3: n = 3, Expected Output: 7, Actual Output: \" << solution.flipLights(3) << std::endl;\n\n    return 0;\n}\n```",
  "320": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<std::string> generateAbbreviations(std::string word) {\n        int n = word.size();\n        std::vector<std::string> res;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j + i <= n; ++j) {\n                std::string abbr = word.substr(j, i);\n                if (abbr.size() > 1 || abbr[0] != '0') {\n                    res.push_back(\"0\" + abbr);\n                }\n                for (int k = j + 1; k <= n; ++k) {\n                    res.push_back(word.substr(0, j) + \"0\" + word.substr(j) + \"0\");\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::string> result1 = solution.generateAbbreviations(\"word\");\n    for (const auto& abbr : result1) {\n        std::cout << abbr << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<std::string> result2 = solution.generateAbbreviations(\"a4e\");\n    for (const auto& abbr : result2) {\n        std::cout << abbr << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<std::string> result3 = solution.generateAbbreviations(\"123\");\n    for (const auto& abbr : result3) {\n        std::cout << abbr << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```",
  "321": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string maximumNumber(vector<int>& arr) {\n        int n = arr.size();\n        vector<char> res(n, '0');\n        int i = 0;\n        while (i < n) {\n            if (arr[i] > 2) break;\n            res[i++] = '9';\n        }\n        for (int j = i; j < n; ) {\n            if (arr[j] > 2) {\n                while (j < n && arr[j] > 2) {\n                    res[j++] = '9';\n                }\n                break;\n            }\n            int k = j + 1;\n            while (k < n && arr[k] <= 2) {\n                res[j++] = '9' + (arr[k++] - 1);\n            }\n        }\n        return string(res.begin(), res.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> test1 = {3,4,6,7,8};\n    cout << \"Test Case 1: \" << solution.maximumNumber(test1) << endl;\n    cout << \"Expected: 964656783\" << endl << endl;\n\n    // Test case 2\n    vector<int> test2 = {9,6,6,4,3,2};\n    cout << \"Test Case 2: \" << solution.maximumNumber(test2) << endl;\n    cout << \"Expected: 99665432\" << endl << endl;\n\n    // Test case 3\n    vector<int> test3 = {1,9,5};\n    cout << \"Test Case 3: \" << solution.maximumNumber(test3) << endl;\n    cout << \"Expected: 195\" << endl;\n\n    return 0;\n}\n```",
  "322": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount + 1, amount + 1);\n        dp[0] = 0;\n        for (int i = 0; i <= amount; ++i) {\n            for (int j = 0; j < coins.size(); ++j) {\n                if (i >= coins[j]) {\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> coins1 = {1,2,5};\n    cout << \"Test case 1: \" << solution.coinChange(coins1, 11) << endl;  // Output: 3\n\n    vector<int> coins2 = {2};\n    cout << \"Test case 2: \" << solution.coinChange(coins2, 3) << endl;  // Output: -1\n\n    vector<int> coins3 = {1};\n    cout << \"Test case 3: \" << solution.coinChange(coins3, 0) << endl;  // Output: 0\n\n    return 0;\n}\n```",
  "323": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countComponents(int n, vector<vector<int>>& edges) {\n        vector<int> parent(n);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        for (auto& edge : edges) {\n            unionSet(parent, edge[0], edge[1]);\n        }\n        \n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (parent[i] == i) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n    \n    int unionSet(vector<int>& parent, int a, int b) {\n        if (find(parent, a) != find(parent, b)) {\n            parent[find(parent, a)] = find(parent, b);\n        }\n        return 0;\n    }\n    \n    int find(vector<int>& parent, int x) {\n        return parent[x] == x ? x : parent[x] = find(parent, parent[x]);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int n1 = 5;\n    vector<vector<int>> edges1 = {{0, 1}, {1, 2}, {3, 4}};\n    cout << \"Test Case 1: \" << solution.countComponents(n1, edges1) << endl;  // Expected output: 1\n\n    // Test Case 2\n    int n2 = 5;\n    vector<vector<int>> edges2 = {{0, 1}, {1, 2}, {3, 4}, {4, 0}};\n    cout << \"Test Case 2: \" << solution.countComponents(n2, edges2) << endl;  // Expected output: 1\n\n    // Test Case 3\n    int n3 = 6;\n    vector<vector<int>> edges3 = {{0, 1}, {1, 2}, {2, 3}, {4, 5}};\n    cout << \"Test Case 3: \" << solution.countComponents(n3, edges3) << endl;  // Expected output: 2\n\n    return 0;\n}\n```",
  "324": "```\n#include <iostream>\n#include <vector>\n\nvoid wiggleSort(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> sorted(nums);\n    std::sort(sorted.begin(), sorted.end());\n\n    for (int i = 0; i < n; i++) {\n        if ((i & 1) == 0) {\n            nums[i] = sorted[(n - 1) / 2];\n        } else {\n            nums[i] = (i < (n + 1) / 2 ? sorted[i / 2] : sorted[n - 1]);\n        }\n    }\n}\n\nint main() {\n    std::vector<int> testCases[] = {\n        {1, 5, 1, 8, 20},\n        {-5, 0, 3, 4, 7, 13, 17, 18, 23, 25},\n        {3, 6}\n    };\n\n    for (const auto& test : testCases) {\n        std::vector<int> original = test;\n        wiggleSort(test);\n        for (int num : original) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "325": "```\n#include <iostream>\n#include <vector>\n\nint maxEqualSubstring(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int sum = 0;\n        for (int j = i; j < n && sum <= k; j++) {\n            sum += nums[j];\n            if (sum == k) {\n                ans = std::max(ans, j - i + 1);\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::vector<int> nums1 = {1,-1,5,-2,3};\n    int k1 = 3;\n    std::cout << \"Test case 1: \" << maxEqualSubstring(nums1, k1) << std::endl;\n\n    std::vector<int> nums2 = [1];\n    int k2 = 0;\n    std::cout << \"Test case 2: \" << maxEqualSubstring(nums2, k2) << std::endl;\n\n    std::vector<int> nums3 = {4,-3,9,5,-2,-4,2,6,-7};\n    int k3 = 15;\n    std::cout << \"Test case 3: \" << maxEqualSubstring(nums3, k3) << std::endl;\n\n    return 0;\n}",
  "326": "```\n#include <iostream>\nusing namespace std;\n\nbool isPowerOfThree(int n) {\n    if (n <= 0)\n        return false;\n    while (n % 3 == 0)\n        n /= 3;\n    return n == 1;\n}\n\nint main() {\n    cout << boolalpha;\n    cout << \"Test case 1: \" << isPowerOfThree(27) << endl; // Expected: true\n    cout << \"Test case 2: \" << isPowerOfThree(9) << endl;   // Expected: true\n    cout << \"Test case 3: \" << isPowerOfThree(10) << endl;   // Expected: false\n    return 0;\n}\n```",
  "327": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int countRangeSum(int A[], int n, int L, int R) {\n        std::vector<long long> sum = {{0}};\n        for (int i = 0; i < n; ++i)\n            sum.push_back(sum.back() + A[i]);\n        std::sort(sum.begin(), sum.end());\n        \n        int res = 0;\n        for (long long left = 0, right = 0; left <= R && right < sum.size(); ) {\n            while (right < sum.size() && sum[right] - sum[left] <= R)\n                right++;\n            res += right - left;\n            left += L != 0 ? 1 : 0;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int A[] = {0};\n    std::cout << \"Test Case 1: \" << solution.countRangeSum(A, 1, -1, 0) << std::endl;\n\n    A[0] = 1;\n    A[1] = 2;\n    std::cout << \"Test Case 2: \" << solution.countRangeSum(A, 2, -5, 5) << std::endl;\n\n    A[0] = 1; A[1] = 3; A[2] = 2; A[3] = -4;\n    A[4] = -3; A[5] = 0; A[6] = 9; A[7] = 3; A[8] = 4; A[9] = 1;\n    std::cout << \"Test Case 3: \" << solution.countRangeSum(A, 10, -2, 2) << std::endl;\n\n    return 0;\n}",
  "328": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* oddEvenList(ListNode* head) {\n    if (head == NULL || head->next == NULL) return head;\n    \n    ListNode* odd = head;\n    ListNode* even = head->next;\n    ListNode* tempOdd = odd;\n    ListNode* tempEven = even;\n\n    while (even != NULL && even->next != NULL) {\n        odd->next = even->next;\n        odd = odd->next;\n        \n        if (odd == NULL || odd->next == NULL) break;\n        \n        even->next = odd->next;\n        even = even->next;\n    }\n    \n    odd->next = tempEven;\n    return head;\n}\n\nint main() {\n    // Test Case 1\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(4);\n    head1->next->next->next->next = new ListNode(5);\n\n    head1 = oddEvenList(head1);\n    \n    for (ListNode* node = head1; node != NULL; node = node->next) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    head1 = new ListNode(2);\n    head1->next = new ListNode(4);\n    head1->next->next = new ListNode(6);\n\n    head1 = oddEvenList(head1);\n\n    for (ListNode* node = head1; node != NULL; node = node->next) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    \n    head1 = oddEvenList(head1);\n\n    for (ListNode* node = head1; node != NULL; node = node->next) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "330": "```\n#include <iostream>\n#include <vector>\n\nint minPatches(std::vector<int>& nums, int n) {\n    long long total = 0;\n    int i = 0;\n    while (total < n) {\n        if (i >= nums.size() || nums[i] > total + 1) {\n            total += i + 1;\n            i++;\n        } else {\n            total += nums[i];\n            i++;\n        }\n    }\n    return i;\n}\n\nint main() {\n    std::vector<int> nums1 = {1,3};\n    int n1 = 6;\n    std::cout << \"Test case 1: \" << minPatches(nums1, n1) << std::endl;\n\n    std::vector<int> nums2 = {};\n    int n2 = 15;\n    std::cout << \"Test case 2: \" << minPatches(nums2, n2) << std::endl;\n\n    std::vector<int> nums3 = {1,5,10};\n    int n3 = 20;\n    std::cout << \"Test case 3: \" << minPatches(nums3, n3) << std::endl;\n\n    return 0;\n}\n```",
  "329": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\n        if (matrix.empty()) return 0;\n        \n        int m = matrix.size(), n = matrix[0].size();\n        vector<vector<int>> dp(m, vector<int>(n));\n        int ans = 0;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i > 0 && matrix[i][j] >= matrix[i-1][j]) dp[i][j] = 1;\n                else if (i < m-1 && matrix[i][j] >= matrix[i+1][j]) dp[i][j] = 1;\n                else if (j > 0 && matrix[i][j] >= matrix[i][j-1]) dp[i][j] = 1;\n                else if (j < n-1 && matrix[i][j] >= matrix[i][j+1]) dp[i][j] = 1;\n                else dp[i][j] = 0;\n                \n                ans = max(ans, dp[i][j]);\n            }\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> grid1 = {{9,9,4},{6,6,8},{5,3,0}};\n    cout << \"Grid 1: \" << solution.longestIncreasingPath(grid1) << endl;\n\n    vector<vector<int>> grid2 = {{1,3},{5,5}};\n    cout << \"Grid 2: \" << solution.longestIncreasingPath(grid2) << endl;\n\n    vector<vector<int>> grid3 = {{2,1,1},{1,1,0},{0,0,0}};\n    cout << \"Grid 3: \" << solution.longestIncreasingPath(grid3) << endl;\n\n    return 0;\n}\n```",
  "331": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isValidSerialization(string preorder) {\n        int n = preorder.size();\n        if (n == 0) return true;\n        string[] nodes = preorder.split(\",\");\n        for (int i = 1; i < n - 1; i++) {\n            if (!isValidNode(nodes[i])) return false;\n        }\n        return true;\n    }\n\n    boolean isValidNode(String node) {\n        if (node.equals(\"null\")) return true;\n        int i = 0, j = 0;\n        while (j < node.length()) {\n            if (Character.isDigit(node.charAt(j))) {\n                i++;\n                while (j < node.length() && Character.isDigit(node.charAt(j))) j++;\n            } else {\n                i++;\n                j++;\n            }\n        }\n        return i == node.length();\n    }\n};\n\nint main() {\n    Solution solution = new Solution();\n\n    // Test Case 1\n    string preorder1 = \"9,3,4,#,#,1,#,#\";\n    cout << (solution.isValidSerialization(preorder1) ? \"True\" : \"False\") << endl;\n\n    // Test Case 2\n    string preorder2 = \"1,null,2\";\n    cout << (solution.isValidSerialization(preorder2) ? \"True\" : \"False\") << endl;\n\n    // Test Case 3\n    string preorder3 = \"1,2,#,#,3,4,#,#,5,#,#\";\n    cout << (solution.isValidSerialization(preorder3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "332": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        unordered_map<string, multimap<string, int>> graph;\n        for (const auto& ticket : tickets) {\n            string from = ticket[0];\n            string to = ticket[1];\n            graph[from].insert({to, 0});\n        }\n        \n        vector<string> itinerary;\n        function<void(string)> dfs = [&](string node) {\n            while (!graph[node].empty()) {\n                auto next = prev(graph[node].begin());\n                graph[node].erase(next);\n                dfs(next->first);\n            }\n            itinerary.push_back(node);\n        };\n        \n        dfs(\"JFK\");\n        reverse(itinerary.begin(), itinerary.end());\n        return itinerary;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> tickets1 = {{\"MUC\", \"LHR\"}, {\"LHR\", \"SIN\"}, {\"SIN\", \"BKK\"}, {\"THB\", \"MUC\"}};\n    vector<string> result1 = solution.findItinerary(tickets1);\n    cout << \"Test Case 1: \";\n    for (const auto& ticket : result1) {\n        cout << ticket << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<vector<string>> tickets2 = {{\"JFK\", \"SFO\"}, {\"JFK\", \"ATL\"}, {\"SFO\", \"ATL\"}, {\"ATL\", \"JFK\"}};\n    vector<string> result2 = solution.findItinerary(tickets2);\n    cout << \"Test Case 2: \";\n    for (const auto& ticket : result2) {\n        cout << ticket << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<vector<string>> tickets3 = {{\"LHR\", \"SIN\"}, {\"SIN\", \"BKK\"}, {\"THB\", \"MUC\"}};\n    vector<string> result3 = solution.findItinerary(tickets3);\n    cout << \"Test Case 3: \";\n    for (const auto& ticket : result3) {\n        cout << ticket << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "334": "```\n#include <iostream>\n#include <vector>\n\nint increasingTriplet(std::vector<int>& nums) {\n    int first = INT_MIN;\n    int second = INT_MIN;\n\n    for (int num : nums) {\n        if (num <= first) {\n            first = num;\n        } else if (num <= second) {\n            second = num;\n        } else {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 2, 3, 4, 5};\n    std::cout << increasingTriplet(test1) << std::endl;\n\n    std::vector<int> test2 = {5, 4, 3, 2, 1};\n    std::cout << increasingTriplet(test2) << std::endl;\n\n    std::vector<int> test3 = {1, 2, 1, 3, 4};\n    std::cout << increasingTriplet(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "333": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    struct Info {\n        int maxSize;\n        int isBST;\n    };\n\n    Info dfs(TreeNode* root, int minVal = INT_MIN, int maxVal = INT_MAX) {\n        if (root == NULL) return {0, 1};\n\n        Info leftInfo = dfs(root->left, minVal, root->val);\n        if (!leftInfo.isBST || root->val < leftInfo.maxSize) return {0, 0};\n\n        Info rightInfo = dfs(root->right, root->val, maxVal);\n        if (!rightInfo.isBST) return {0, 0};\n\n        int maxSize = (root->left ? leftInfo.maxSize : 0) + 1;\n        maxSize += (root->right ? rightInfo.maxSize : 0);\n        return {(maxSize), 1};\n    }\n\n    int maxDepth(TreeNode* root) {\n        if (root == NULL) return 0;\n        return max(depth(root->left), depth(root->right));\n    }\n\n    int depth(TreeNode* node) {\n        if (node == NULL) return 0;\n        return 1 + max(depth(node->left), depth(node->right));\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root = new TreeNode(3);\n    root->left = new TreeNode(1);\n    root->right = new TreeNode(4);\n    root->right->left = new TreeNode(2);\n\n    cout << \"Test Case 1: \";\n    cout << solution.dfs(root).maxSize << endl;\n\n    root = new TreeNode(4);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(7);\n    root->right->left = new TreeNode(3);\n    root->right->right = new TreeNode(6);\n    root->right->right->left = new TreeNode(5);\n\n    cout << \"Test Case 2: \";\n    cout << solution.dfs(root).maxSize << endl;\n\n    root = new TreeNode(1);\n    root->left = new TreeNode(4);\n    root->right = new TreeNode(3);\n    root->right->left = new TreeNode(2);\n    root->right->right = new TreeNode(5);\n\n    cout << \"Test Case 3: \";\n    cout << solution.dfs(root).maxSize << endl;\n\n    return 0;\n}\n```",
  "335": "```\n#include <iostream>\n#include <vector>\n\nbool isSelfCrossing(std::vector<int>& x) {\n    int i = 0;\n    while (i < x.size() - 1) {\n        if (x[i] + x[i + 1] > x[i + 2]) {\n            if (i >= 1 && x[i - 1] == x[i]) return true; \n            else if ((i >= 2) && (x[i] - x[i - 1]) * 2 == x[i + 1] - x[i]) return true;\n        }\n        i++;\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> x1 = {2, 1, 1, 1, 2};\n    std::cout << isSelfCrossing(x1) << std::endl;\n\n    std::vector<int> x2 = {1, 1, 1, 4};\n    std::cout << isSelfCrossing(x2) << std::endl;\n\n    std::vector<int> x3 = {1, 1};\n    std::cout << isSelfCrossing(x3) << std::endl;\n\n    return 0;\n}\n```",
  "336": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass TrieNode {\npublic:\n    bool isWord;\n    vector<TrieNode*> children;\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        vector<vector<int>> result;\n        if (words.empty()) return result;\n\n        TrieNode* root = new TrieNode();\n        for (int i = 0; i < words.size(); i++) {\n            string word = words[i];\n            int n = word.size();\n            for (int j = 0; j <= n; j++) {\n                string prefix = word.substr(0, j);\n                string suffix = j == n ? \"\" : word.substr(j);\n                if (isPalindrome(prefix)) {\n                    for (int k = 0; k < words.size(); k++) {\n                        if (i != k && isPalindrome(suffix + words[k])) {\n                            result.push_back({i, k});\n                        }\n                    }\n                }\n                TrieNode* node = root;\n                for (char c : prefix) {\n                    if (!node->children[c - 'a']) {\n                        node->children[c - 'a'] = new TrieNode();\n                    }\n                    node = node->children[c - 'a'];\n                }\n                node->isWord = true;\n\n                if (j < n && isPalindrome(suffix)) {\n                    node = root;\n                    for (char c : suffix) {\n                        if (!node->children[c - 'a']) {\n                            node->children[c - 'a'] = new TrieNode();\n                        }\n                        node = node->children[c - 'a'];\n                    }\n                    node->isWord = true;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    bool isPalindrome(string s) {\n        int start = 0, end = s.size() - 1;\n        while (start < end) {\n            if (s[start] != s[end]) return false;\n            start++;\n            end--;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> words1 = {\"ab\", \"ba\", \"c\"};\n    vector<vector<int>> result1 = solution.palindromePairs(words1);\n    for (const auto& pair : result1) {\n        cout << pair[0] << \" \" << pair[1] << endl;\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<string> words2 = {\"a\", \"b\"};\n    vector<vector<int>> result2 = solution.palindromePairs(words2);\n    for (const auto& pair : result2) {\n        cout << pair[0] << \" \" << pair[1] << endl;\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<string> words3 = {\"madam\", \"mountain\", \"moon\", \"moon\", \"noon\"};\n    vector<vector<int>> result3 = solution.palindromePairs(words3);\n    for (const auto& pair : result3) {\n        cout << pair[0] << \" \" << pair[1] << endl;\n    }\n    return 0;\n}\n```",
  "337": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int rob(TreeNode* root) {\n        return helper(root, true);\n    }\n\nprivate:\n    int helper(TreeNode* node, bool isLast) {\n        if (node == nullptr)\n            return 0;\n        \n        int res = 0;\n        if (!isLast)\n            res = max(node->val + helper(node->left, false) + helper(node->right, false),\n                       helper(node->left, true) + helper(node->right, true));\n        else\n            res = node->val;\n\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    cout << \"Expected: 4, Actual: \" << s.rob(root1) << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(2);\n    root2->left = new TreeNode(7);\n    root2->right = new TreeNode(2);\n    root2->left->left = new TreeNode(3);\n    root2->left->right = new TreeNode(1);\n    cout << \"Expected: 9, Actual: \" << s.rob(root2) << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(4);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(6);\n    root3->left->left = new TreeNode(1);\n    root3->left->right = new TreeNode(3);\n    cout << \"Expected: 9, Actual: \" << s.rob(root3) << endl;\n\n    return 0;\n}\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n```",
  "338": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> res;\n        for (int i = 0; i <= n; i++) {\n            int count = 0;\n            int temp = i;\n            while (temp) {\n                count += temp & 1;\n                temp >>= 1;\n            }\n            res.push_back(count);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    vector<int> result;\n\n    // Test case 1\n    result = s.countBits(5);\n    for (int i : result) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    result = s.countBits(10);\n    for (int i : result) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    result = s.countBits(15);\n    for (int i : result) {\n        cout << i << \" \";\n    }\n    return 0;\n}\n```",
  "339": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int depthSum(std::vector<std::vector<int>>& nestedList) {\n        int sum = 0;\n        for (const auto& sublist : nestedList) {\n            if (!sublist.empty()) {\n                sum += depthSearch(sublist, 1);\n            }\n        }\n        return sum;\n    }\n\nprivate:\n    int depthSearch(const std::vector<int>& list, int depth) {\n        int sum = 0;\n        for (const auto& num : list) {\n            sum += num * depth;\n            if (!num && !list.empty()) {\n                sum += depthSearch(list, depth + 1);\n            }\n        }\n        return sum;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> list1 = {{1, 2}, {3, 4}};\n    int result1 = solution.depthSum(list1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<std::vector<int>> list2 = {{7, 8}, {6, null, 3}, {2, 3}};\n    int result2 = solution.depthSum(list2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<std::vector<int>> list3 = {{1, 2, 3}, {4, 5}};\n    int result3 = solution.depthSum(list3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "340": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestSubstrWithAtMostKDistinctChars(string s, int k) {\n        unordered_map<char, int> charCount;\n        int maxLen = 0, left = 0, right = 0;\n        \n        while (right < s.size()) {\n            if (charCount.size() <= k) {\n                maxLen = max(maxLen, right - left + 1);\n                right++;\n            } else if (s[right] == s[left]) {\n                charCount[s[left]]--;\n                if (charCount[s[left]] == 0) charCount.erase(s[left]);\n                left++;\n            } else {\n                charCount[s[right]]++;\n                right++;\n            }\n        }\n        \n        return maxLen;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s1 = \"BACDBADC\";\n    int k1 = 2;\n    cout << \"Test case 1: \" << solution.longestSubstrWithAtMostKDistinctChars(s1, k1) << endl;  // Output: 4\n\n    // Test case 2\n    string s2 = \"abcba\";\n    int k2 = 2;\n    cout << \"Test case 2: \" << solution.longestSubstrWithAtMostKDistinctChars(s2, k2) << endl;  // Output: 3\n\n    // Test case 3\n    string s3 = \"AAABBBCCC\";\n    int k3 = 1;\n    cout << \"Test case 3: \" << solution.longestSubstrWithAtMostKDistinctChars(s3, k3) << endl;  // Output: 3\n\n    return 0;\n}\n```",
  "342": "```\n#include <iostream>\n\nclass Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        if (n <= 0) return false;\n        while ((n & 1) == 0) n >>= 1;\n        return n == 1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test case 1: \" << (solution.isPowerOfFour(16) ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test case 2: \" << (solution.isPowerOfFour(5) ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test case 3: \" << (solution.isPowerOfFour(64) ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n```",
  "343": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int integerBreak(int n) {\n        if (n == 2) return 1;\n        if (n == 3) return 2;\n        int res = 1;\n        while (n > 4) {\n            res *= 3;\n            n -= 3;\n        }\n        return res * n;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.integerBreak(2) << endl; // Expected Output: 1\n    cout << \"Test Case 2: \" << solution(integerBreak(3)) << endl; // Expected Output: 2\n    cout << \"Test Case 3: \" << solution.integerBreak(10) << endl; // Expected Output: 354\n\n    return 0;\n}\n```",
  "341": "```\n#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nclass NestedIterator {\npublic:\n    stack<vector<int>> s;\n    int current = 0;\n\n    NestedIterator(vector<NestedInteger> &nestedIntegers) {\n        for (auto& ni : nestedIntegers) {\n            if (!ni.isInteger()) {\n                flatten(ni.getInteger(), s);\n            } else {\n                s.push({ni.getInteger()});\n            }\n        }\n    }\n\n    int next() {\n        while (!s.empty()) {\n            auto& top = s.top();\n            if (current < top.size()) {\n                return top[current++];\n            } else {\n                s.pop();\n                current--;\n            }\n        }\n        return 0;\n    }\n\n    bool hasNext() {\n        return !s.empty();\n    }\n\nprivate:\n    void flatten(int num, stack<vector<int>>& stack) {\n        while (num > 0) {\n            int remainder = num % 10;\n            stack.push({remainder});\n            num /= 10;\n        }\n    }\n};\n\nint main() {\n    vector<NestedInteger> nestedIntegers1 = {{4, 5, 6}, {7, 8}};\n    NestedIterator it1(nestedIntegers1);\n    \n    cout << it1.next(); // prints 4\n    cout << it1.next(); // prints 5\n    cout << it1.next(); // prints 6\n    cout << it1.next(); // prints 7\n    cout << it1.next(); // prints 8\n    cout << it1.hasNext(); // returns false\n\n    vector<NestedInteger> nestedIntegers2 = {1, 2};\n    NestedIterator it2(nestedIntegers2);\n    \n    cout << it2.next(); // prints 1\n    cout << it2.next(); // prints 2\n    cout << it2.hasNext(); // returns false\n\n    vector<NestedInteger> nestedIntegers3 = {{1}, {4, 5, 6}};\n    NestedIterator it3(nestedIntegers3);\n    \n    cout << it3.next(); // prints 1\n    cout << it3.next(); // prints 4\n    cout << it3.next(); // prints 5\n    cout << it3.next(); // prints 6\n    cout << it3.hasNext(); // returns false\n\n    return 0;\n}\n```",
  "344": "```\n#include <iostream>\n#include <string>\n\nstd::string reverseString(std::string s) {\n    std::string reversed = \"\";\n    for (int i = s.length() - 1; i >= 0; --i) {\n        reversed += s[i];\n    }\n    return reversed;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << reverseString(\"hello\") << std::endl;\n    std::cout << \"Test Case 2: \" << reverseString(\"world\") << std::endl;\n    std::cout << \"Test Case 3: \" << reverseString(\"abcdefg\") << std::endl;\n\n    return 0;\n}\n```",
  "345": "```\n#include <iostream>\n#include <string>\n\nstd::string reverseVowels(std::string s) {\n    int left = 0;\n    int right = s.length() - 1;\n\n    while (left < right) {\n        if (!isVowel(s[left])) {\n            left++;\n        } else if (!isVowel(s[right])) {\n            right--;\n        } else {\n            std::swap(s[left], s[right]);\n            left++;\n            right--;\n        }\n    }\n\n    return s;\n}\n\nbool isVowel(char c) {\n    c = tolower(c);\n    return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << reverseVowels(\"hello\") << std::endl;\n    std::cout << \"Test Case 2: \" << reverseVowels(\"leetcode\") << std::endl;\n    std::cout << \"Test Case 3: \" << reverseVowels(\"a\") << std::endl;\n\n    return 0;\n}",
  "346": "```\n#include <iostream>\n#include <vector>\n\nclass MovingAverage {\npublic:\n    double* elements;\n    int size;\n    int index;\n\n    MovingAverage(int size) : size(size), index(0) {\n        elements = new double[size];\n    }\n\n    ~MovingAverage() {\n        delete[] elements;\n    }\n\n    void next(double val) {\n        if (index < size) {\n            elements[index++] = val;\n        }\n    }\n\n    double get();\n};\n\ndouble MovingAverage::get() {\n    if (index > 0) {\n        int left = index - size + 1;\n        if (left <= 0) return 0.0;\n        double sum = 0.0;\n        for (int i = 0; i < size && left + i < index; i++) {\n            sum += elements[left + i];\n        }\n        return sum / size;\n    } else {\n        return 0.0;\n    }\n};\n\nint main() {\n    MovingAverage ma1(3);\n    std::vector<double> inputs1 = {1, 3, 2};\n    for (double input : inputs1) {\n        ma1.next(input);\n    }\n    double result1 = ma1.get();\n    std::cout << \"Test Case 1: \" << result1 << std::endl;\n\n    MovingAverage ma2(5);\n    std::vector<double> inputs2 = {0, 1, 3, 19, 5};\n    for (double input : inputs2) {\n        ma2.next(input);\n    }\n    double result2 = ma2.get();\n    std::cout << \"Test Case 2: \" << result2 << std::endl;\n\n    MovingAverage ma3(10);\n    std::vector<double> inputs3 = {1, 2, 3, 4, 5};\n    for (double input : inputs3) {\n        ma3.next(input);\n    }\n    double result3 = ma3.get();\n    std::cout << \"Test Case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "347": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> count;\n        for (int num : nums) {\n            if (count.find(num) == count.end()) {\n                count[num] = 1;\n            } else {\n                count[num]++;\n            }\n        }\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        for (auto &p : count) {\n            pq.push({p.second, p.first});\n        }\n\n        vector<int> res(k);\n        for (int i = 0; i < k; i++) {\n            res[i] = pq.top().second;\n            pq.pop();\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {1, 1, 1, 2, 2, 3};\n    int k1 = 2;\n    vector<int> expected1 = {1, 2};\n    if (solution.topKFrequent(nums1, k1) != expected1) {\n        cout << \"Test case 1 failed!\" << endl;\n    } else {\n        cout << \"Test case 1 passed!\" << endl;\n    }\n\n    // Test case 2\n    vector<int> nums2 = {0};\n    int k2 = 0;\n    vector<int> expected2 = {};\n    if (solution.topKFrequent(nums2, k2) != expected2) {\n        cout << \"Test case 2 failed!\" << endl;\n    } else {\n        cout << \"Test case 2 passed!\" << endl;\n    }\n\n    // Test case 3\n    vector<int> nums3 = {1};\n    int k3 = 1;\n    vector<int> expected3 = {1};\n    if (solution.topKFrequent(nums3, k3) != expected3) {\n        cout << \"Test case 3 failed!\" << endl;\n    } else {\n        cout << \"Test case 3 passed!\" << endl;\n    }\n\n    return 0;\n}\n```",
  "349": "```\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        set<int> set1(nums1.begin(), nums1.end());\n        set<int> set2(nums2.begin(), nums2.end());\n\n        set<int> result;\n        for (int num : set1) {\n            if (set2.count(num)) {\n                result.insert(num);\n            }\n        }\n\n        vector<int> res(result.begin(), result.end());\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {1, 2, 3};\n    vector<int> nums2 = {2, 3, 4};\n    vector<int> expected = {2, 3};\n    assert(solution.intersection(nums1, nums2) == expected);\n\n    // Test case 2\n    nums1 = {4, 9, 0};\n    nums2 = {7, 12, 0};\n    expected = {};\n    assert(solution.intersection(nums1, nums2) == expected);\n\n    // Test case 3\n    nums1 = [1, 2, 3];\n    nums2 = [3, 4, 5];\n    expected = [3];\n    assert(solution.intersection(nums1, nums2) == expected);\n\n    return 0;\n}\n```",
  "348": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass TicTacToe {\npublic:\n    TicTacToe(int n) : board(n, vector<int>(n, 0)), moves(0), winner(-1) {}\n\n    int move(int row, int col, int player) {\n        if (row < 0 || row >= board.size() || col < 0 || col >= board[0].size()) return -1;\n        if (player != 1 && player != 2) return -1;\n\n        board[row][col] += player;\n        moves++;\n\n        int winner = getWinner();\n        if (winner > 0) {\n            return winner;\n        }\n\n        return 0;\n    }\n\nprivate:\n    vector<vector<int>> board;\n    int moves;\n    int winner;\n\n    int getWinner() {\n        for (int i = 0; i < board.size(); i++) {\n            if (board[i][0] == board[i][1] && board[i][0] == board[i][2]) return board[i][0];\n            if (board[0][i] == board[1][i] && board[0][i] == board[2][i]) return board[0][i];\n        }\n        if (board[0][0] == board[1][1] && board[0][0] == board[2][2]) return board[0][0];\n        if (board[0][2] == board[1][1] && board[0][2] == board[2][0]) return board[0][2];\n\n        return -1;\n    }\n};\n\nint main() {\n    TicTacToe game(3);\n\n    // Test Case 1: Player 1 wins\n    int winner = game.move(0, 0, 1);\n    cout << \"Test Case 1: \";\n    if (winner == 1) cout << \"Player 1 wins\\n\";\n    else cout << \"Game not over yet\\n\";\n\n    // Test Case 2: Player 2 wins\n    for (int i = 0; i < 3; i++) {\n        game.move(i, i, 2);\n    }\n    winner = game.move(0, 2, 1);\n    cout << \"Test Case 2: \";\n    if (winner == 2) cout << \"Player 2 wins\\n\";\n    else cout << \"Game not over yet\\n\";\n\n    // Test Case 3: No one wins\n    for (int i = 0; i < 2; i++) {\n        game.move(i, i, 1);\n    }\n    game.move(2, 0, 2);\n    winner = game.move(1, 1, 1);\n    cout << \"Test Case 3: \";\n    if (winner == -1) cout << \"No one wins\\n\";\n    else cout << \"Game not over yet\\n\";\n\n    return 0;\n}\n```",
  "350": "```\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        set<int> s(nums1.begin(), nums1.end());\n        vector<int> result;\n        \n        for (int num : nums2) {\n            if (s.count(num)) {\n                result.push_back(num);\n                s.erase(num); // Remove the element from the set\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> nums1 = {1, 2, 3};\n    vector<int> nums2 = {3, 4, 5};\n    vector<int> expected = {3};\n    assert(solution.intersect(nums1, nums2) == expected);\n\n    nums1 = {1, 2};\n    nums2 = {1, 2};\n    expected = {1, 2};\n    assert(solution.intersect(nums1, nums2) == expected);\n\n    nums1 = {4, 9, 0};\n    nums2 = {3, 1, 4, 10, 2, 3, 5, 4};\n    expected = {4, 4, 3};\n    assert(solution.intersect(nums1, nums2) == expected);\n\n    cout << \"All test cases pass.\" << endl;\n    return 0;\n}",
  "351": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPatterns(string pattern) {\n        if (pattern.length() == 0)\n            return 1;\n        else if (pattern[0] == '#')\n            return 4 * countPatterns(substr(pattern, 1));\n        else {\n            int i = 0;\n            while (i < pattern.length() && pattern[i] != '#') \n                i++;\n            return 2 * (countPatterns(substr(pattern, 0, i)) + countPatterns(substr(pattern, i)));\n        }\n    }\n\n    string substr(string s, int start, int end) {\n        string res = \"\";\n        for(int i=start; i<end; i++)\n            res += s[i];\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << solution.countPatterns(\"\") << endl;\n    cout << \"Test case 2: \" << solution.countPatterns(\"123\") << endl;\n    cout << \"Test case 3: \" << solution.countPatterns(\"#*)\") << endl;\n\n    return 0;\n}\n```",
  "352": "```\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nclass SummaryRanges {\npublic:\n    SummaryRanges() {\n        intervals = new std::vector<std::pair<int, int>>();\n    }\n    \n    ~SummaryRanges() {\n        delete[] intervals;\n    }\n    \n    void addNum(int val) {\n        if (intervals.empty()) {\n            intervals->emplace_back(val, val);\n        } else {\n            bool inserted = false;\n            for (auto it = intervals->begin(); it != intervals->end(); ++it) {\n                if (val <= it->second) {\n                    if (val == it->second + 1) {\n                        it->second = val;\n                        inserted = true;\n                    }\n                    break;\n                } else if (val > it->second && val < it->first) {\n                    intervals->emplace_back(val, val);\n                    inserted = true;\n                    break;\n                } else if (!inserted) {\n                    intervals->emplace_back(val, val);\n                }\n            }\n            if (!inserted) {\n                intervals->push_back({val, val});\n            }\n        }\n    }\n    \n    int getSummary(int k) {\n        auto it = intervals->begin();\n        for (int i = 0; i < k; ++i) {\n            if (it != intervals->end()) {\n                it++;\n            } else {\n                break;\n            }\n        }\n        return it == intervals->end() ? -1 : it->second;\n    }\n};\n\nint main() {\n    SummaryRanges s1;\n    s1.addNum(1);\n    s1.addNum(2);\n    s1.addNum(3);\n    std::cout << \"Case 1: \" << s1.getSummary(4) << std::endl; // Output: 3\n\n    SummaryRanges s2;\n    s2.addNum(0);\n    s2.addNum(1);\n    s2.addNum(2);\n    s2.addNum(5);\n    s2.addNum(6);\n    std::cout << \"Case 2: \" << s2.getSummary(2) << std::endl; // Output: 2\n    std::cout << \"Case 2: \" << s2.getSummary(3) << std::endl; // Output: 5\n\n    SummaryRanges s3;\n    s3.addNum(1);\n    s3.addNum(2);\n    s3.addNum(4);\n    s3.addNum(8);\n    s3.addNum(10);\n    s3.addNum(11);\n    std::cout << \"Case 3: \" << s3.getSummary(5) << std::endl; // Output: 4\n    std::cout << \"Case 3: \" << s3.getSummary(6) << std::endl; // Output: 10\n\n    return 0;\n}\n```",
  "353": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass SnakeGame {\npublic:\n    SnakeGame(int width, int height, vector<pair<int, int>> food) {\n        this->width = width;\n        this->height = height;\n        this->food = food;\n        snake = queue<int>();\n    }\n\n    int start(int x, int y) {\n        if (x < 0 || y < 0 || x >= width || y >= height) return -1;\n        if (!snake.empty() && snake.back() == width * y + x) return -1;\n        if (food.empty()) return -1;\n\n        snake.push(width * y + x);\n        food.erase(remove(food.begin(), food.end(), make_pair(x, y)), food.end());\n\n        return food.size();\n    }\n\n    int move(int direction) {\n        int head = snake.back();\n        int newHead;\n        switch (direction) {\n            case 1: // up\n                if (head % width == 0 || head / width - 1 < 0) return -1;\n                newHead = (head / width - 1) * width + head % width;\n                break;\n            case 2: // right\n                if (head % width >= width || head / width >= height) return -1;\n                newHead = head + 1;\n                break;\n            case 3: // down\n                if (head % width >= width || head / width + 1 >= height) return -1;\n                newHead = (head / width + 1) * width + head % width;\n                break;\n            case 4: // left\n                if (head % width == 0 || head / width >= height) return -1;\n                newHead = head - 1;\n                break;\n        }\n\n        if (!food.empty() && food.back().first == newHead % width && food.back().second == newHead / width) {\n            snake.push(newHead);\n            food.pop_back();\n        } else {\n            snake.push(newHead);\n            snake.pop();\n        }\n\n        return snake.size();\n    }\n\nprivate:\n    int width, height;\n    vector<pair<int, int>> food;\n    queue<int> snake;\n};\n\nint main() {\n    SnakeGame game(3, 2, {{1, 0}, {0, 1}});\n    \n    cout << game.start(0, 0) << endl; // Output: 1\n    cout << game.move(1) << endl; // Output: 0\n    cout << game.move(2) << endl; // Output: -1\n\n    return 0;\n}\n```",
  "354": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxEnvelopes(std::vector<std::vector<int>>& envelopes) {\n    if (envelopes.empty()) return 0;\n    \n    std::sort(envelopes.begin(), envelopes.end(), \n             [](const auto& a, const auto& b) {\n                 if (a[0] == b[0]) return a[1] > b[1];\n                 return a[0] < b[0];\n             });\n    \n    int n = envelopes.size();\n    std::vector<int> dp(n);\n    for (int i = 0; i < n; ++i) {\n        dp[i] = 1;\n        for (int j = 0; j < i; ++j) {\n            if (envelopes[j][1] < envelopes[i][1] && \n                envelopes[j][0] < envelopes[i][0]) {\n                dp[i] = std::max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    \n    return *std::max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::vector<int>> envelopes1 {{5,4},{6,4},{6,7}};\n    std::cout << \"Max Envelopes: \" << maxEnvelopes(envelopes1) << std::endl;\n\n    // Test Case 2\n    std::vector<std::vector<int>> envelopes2 {{1,3},{3,3},{5,3},{5,4}};\n    std::cout << \"Max Envelopes: \" << maxEnvelopes(envelopes2) << std::endl;\n\n    // Test Case 3\n    std::vector<std::vector<int>> envelopes3 {{1,3},{3,3},{5,5},{6,6}};\n    std::cout << \"Max Envelopes: \" << maxEnvelopes(envelopes3) << std::endl;\n\n    return 0;\n}\n```",
  "356": "```\n#include <iostream>\n#include <vector>\n\nint reflection(int x1, int y1, int x2, int y2) {\n    return (x1 * (y2 - y1)) + (y1 * (x2 - x1));\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << reflection(0, 1, 3, 5) << std::endl; // Expected output: 12\n    std::cout << \"Test Case 2: \" << reflection(-1, 4, 7, -3) << std::endl; // Expected output: -23\n    std::cout << \"Test Case 3: \" << reflection(5, -6, -4, 8) << std::endl; // Expected output: 34\n\n    return 0;\n}\n```",
  "355": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Twitter {\npublic:\n    Twitter() {\n        users = new std::map<std::string, User>();\n    }\n\n    void postTweet(int userId, int tweetId) {\n        if (users->count(userId)) {\n            users->at(userId)->post(tweetId);\n        } else {\n            User* user = new User(userId, 0);\n            users->insert({userId, user});\n            user->post(tweetId);\n        }\n    }\n\n    vector<pair<int, int>> getNewsFeed(int userId) {\n        std::vector<std::pair<int, int>> feed;\n        if (users->count(userId)) {\n            User* user = users->at(&userId);\n            return user->getFeed();\n        } else {\n            return feed;\n        }\n    }\n\nprivate:\n    struct Tweet {\n        int id;\n        int time;\n    };\n\n    struct User {\n        int id;\n        int timelineId;\n        std::map<int, Tweet> tweets;\n\n        User(int id, int timelineId) : id(id), timelineId(timelineId) {}\n\n        void post(int tweetId) {\n            tweets.insert({tweetId, {tweetId, timelineId}});\n        }\n\n        std::vector<pair<int, int>> getFeed() {\n            std::vector<std::pair<int, int>> feed;\n            for (auto& tweet : tweets) {\n                feed.push_back({tweet.second.id, tweet.second.time});\n            }\n            return feed;\n        }\n    };\n\n    std::map<int, User*> users;\n};\n\nint main() {\n    Twitter twitter;\n\n    twitter.postTweet(1, 5);\n    twitter.postTweet(1, 6);\n    twitter.postTweet(2, 3);\n\n    vector<pair<int, int>> newsFeed1 = twitter.getNewsFeed(1);\n    for (auto& tweet : newsFeed1) {\n        cout << \"User 1: Tweet ID \" << tweet.first << \", Time \" << tweet.second << endl;\n    }\n\n    vector<pair<int, int>> newsFeed2 = twitter.getNewsFeed(2);\n    for (auto& tweet : newsFeed2) {\n        cout << \"User 2: Tweet ID \" << tweet.first << \", Time \" << tweet.second << endl;\n    }\n\n    vector<pair<int, int>> newsFeed3 = twitter.getNewsFeed(5);\n    for (auto& tweet : newsFeed3) {\n        cout << \"User 5: Tweet ID \" << tweet.first << \", Time \" << tweet.second << endl;\n    }\n\n    return 0;\n}\n```",
  "357": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int uniqueNumbers(int n) {\n        vector<bool> used(10, false);\n        int count = 0;\n        \n        for (int i = 1; i <= n; ++i) {\n            int num = i;\n            bool isValid = true;\n            \n            while (num > 0) {\n                int digit = num % 10;\n                if (used[digit]) {\n                    isValid = false;\n                    break;\n                }\n                used[digit] = true;\n                num /= 10;\n            }\n            \n            if (isValid) {\n                ++count;\n            }\n        }\n        \n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int n1 = 100;\n    cout << \"Number of unique numbers less than or equal to \" << n1 << \": \" << solution.uniqueNumbers(n1) << endl;\n\n    int n2 = 10;\n    cout << \"Number of unique numbers less than or equal to \" << n2 << \": \" << solution.uniqueNumbers(n2) << endl;\n\n    int n3 = 200;\n    cout << \"Number of unique numbers less than or equal to \" << n3 << \": \" << solution.uniqueNumbers(n3) << endl;\n\n    return 0;\n}\n```",
  "358": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string rearrangeString(string s, int k) {\n        if (k == 0) return s;\n        \n        vector<pair<char, int>> charCount;\n        for (char c : s) {\n            auto it = find_if(charCount.begin(), charCount.end(), [&](const pair<char, int>& p) { return p.first == c; });\n            if (it != charCount.end()) it->second++;\n            else charCount.push_back({c, 1});\n        }\n        \n        sort(charCount.begin(), charCount.end(), [](const pair<char, int>& a, const pair<char, int>& b) {\n            if (a.second == b.second) return a.first < b.first;\n            return a.second > b.second;\n        });\n        \n        string res = \"\";\n        for (int i = 0; i < charCount.size(); ) {\n            for (int j = 0; j < min(k, int(charCount.size() - i)); j++) {\n                if (j < k) {\n                    res += charCount[i].first;\n                    charCount[i].second--;\n                    if (charCount[i].second == 0) i++;\n                } else {\n                    if (i + 1 < charCount.size()) {\n                        res += charCount[i + 1].first;\n                        charCount[i + 1].second--;\n                        i++;\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.rearrangeString(\"ykoiigfnfbdkjfyd\", 3) << endl; // \"jkfdybioginyf\"\n    cout << solution.rearrangeString(\"aaabc\", 2) << endl; // \"abac\"\n    cout << solution.rearrangeString(\"aaiiooouuu\", 1) << endl; // \"aaiiiooouu\"\n\n    return 0;\n}\n```",
  "359": "```\n#include <iostream>\n#include <unordered_map>\n\nclass Logger {\npublic:\n    unordered_map<string, int> log;\n    \n    bool shouldPrint(int timestamp) {\n        if(log.find(to_string(timestamp)) != log.end()) return false;\n        log[to_string(timestamp)] = 1;\n        return true;\n    }\n};\n\nint main() {\n    Logger logger;\n\n    // Test case 1\n    cout << boolalpha << logger.shouldPrint(1) << endl; // Should print: true\n    cout << boolalpha << logger.shouldPrint(1000) << endl; // Should print: false\n    cout << boolalpha << logger.shouldPrint(1200) << endl; // Should print: true\n\n    // Test case 2\n    cout << boolalpha << logger.shouldPrint(1) << endl; // Should print: true\n    cout << boolalpha << logger.shouldPrint(2) << endl; // Should print: false\n    cout << boolalpha << logger.shouldPrint(3) << endl; // Should print: false\n\n    // Test case 3\n    cout << boolalpha << logger.shouldPrint(1) << endl; // Should print: true\n    cout << boolalpha << logger.shouldPrint(2) << endl; // Should print: false\n    for(int i = 0; i < 5; i++) {\n        cout << boolalpha << logger.shouldPrint(i * 1000) << endl;\n    }\n\n    return 0;\n}\n```",
  "360": "```\n#include <iostream>\n#include <vector>\n\nvoid sortTransformedArray(std::vector<int>& transformed) {\n    int n = transformed.size();\n    for (int i = 1; i < n; ++i) {\n        if (transformed[i - 1] > transformed[i]) {\n            int temp = transformed[i];\n            int j = i;\n            while (j > 0 && transformed[j - 1] > temp) {\n                transformed[j] = transformed[j - 1];\n                --j;\n            }\n            transformed[j] = temp;\n        }\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> arr1 = {2,1};\n    int n1 = 2;\n    for (int i = 0; i < n1; ++i) {\n        arr1[i] *= i + 1;\n    }\n    sortTransformedArray(arr1);\n    for (auto x : arr1) {\n        std::cout << x << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<int> arr2 = {-5, -2, 3, 10};\n    int n2 = 4;\n    for (int i = 0; i < n2; ++i) {\n        arr2[i] *= i + 1;\n    }\n    sortTransformedArray(arr2);\n    for (auto x : arr2) {\n        std::cout << x << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<int> arr3 = {5, 10};\n    int n3 = 2;\n    for (int i = 0; i < n3; ++i) {\n        arr3[i] *= i + 1;\n    }\n    sortTransformedArray(arr3);\n    for (auto x : arr3) {\n        std::cout << x << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "362": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nclass HitCounter {\npublic:\n    std::queue<int> hits;\n    int windowStart;\n\n    void hit(int timestamp) {\n        hits.push(timestamp);\n        if (hits.size() > 60) {\n            while (!hits.empty()) {\n                if (timestamp - hits.front() >= 60) {\n                    hits.pop();\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    int getHits(int timestamp) {\n        while (!hits.empty() && timestamp - hits.front() >= 60) {\n            hits.pop();\n        }\n        return hits.size();\n    }\n};\n\nint main() {\n    HitCounter counter;\n\n    // Test case 1\n    counter.hit(1);\n    std::cout << \"Hits after 1 minute: \" << counter.getHits(60) << std::endl; // Output: 1\n\n    // Test case 2\n    for (int i = 1; i <= 5; i++) {\n        counter.hit(i * 10);\n    }\n    std::cout << \"Hits after 3 minutes: \" << counter.getHits(60 * 3) << std::endl; // Output: 5\n\n    // Test case 3\n    for (int i = 1; i <= 10; i++) {\n        counter.hit(i * 10);\n    }\n    std::cout << \"Hits after 6 minutes: \" << counter.getHits(60 * 6) << std::endl; // Output: 10\n\n    return 0;\n}\n```",
  "361": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        int m = grid.size();\n        if (m == 0) return 0;\n        \n        int n = grid[0].size();\n        vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    if (i > 0 && grid[i - 1][j] == 1)\n                        dist[i][j] = min(dist[i][j], dist[i-1][j]);\n                    if (j > 0 && grid[i][j - 1] == 1)\n                        dist[i][j] = min(dist[i][j], dist[i][j-1]);\n                    \n                    if (i > 0 && j > 0 && grid[i-1][j-1] == 1)\n                        dist[i][j] = min(dist[i][j], dist[i-1][j-1]);\n                }\n            }\n        }\n        \n        int maxDist = INT_MIN;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1 && dist[i][j] > maxDist)\n                    maxDist = dist[i][j];\n            }\n        }\n        \n        return maxDist;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> grid1 = {{0,0,0,1},{4,2,0,0},{3,5,0,0},{1,2,0,0}};\n    cout << \"Test case 1: \" << solution.maxDistance(grid1) << endl;\n\n    // Test case 2\n    vector<vector<int>> grid2 = {{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,0},{0,0,0,0,0,1}};\n    cout << \"Test case 2: \" << solution.maxDistance(grid2) << endl;\n\n    // Test case 3\n    vector<vector<int>> grid3 = {{1,1,1,1,1,1},{1,1,1,1,1,1},{1,1,1,1,1,1}};\n    cout << \"Test case 3: \" << solution.maxDistance(grid3) << endl;\n\n    return 0;\n}\n```",
  "363": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxSumSquare(int[][] matrix, int k) {\n        if (matrix.length == 0 || matrix[0].length == 0) return 0;\n        \n        int m = matrix.length;\n        int n = matrix[0].length;\n        int res = 0;\n        \n        for (int i = 0; i < m; i++) {\n            vector<int> prefixSum(n);\n            for (int j = i; j < m; j++) {\n                for (int x = 0; x < n; x++) {\n                    prefixSum[x] += matrix[j][x];\n                }\n                \n                int left = 0, right = n;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (sum(prefixSum, mid) <= k) {\n                        res = max(res, sum(prefixSum, mid));\n                        left = mid + 1;\n                    } else {\n                        right = mid - 1;\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n    \n    int sum(vector<int> prefixSum, int x) {\n        return (x == 0 ? 0 : prefixSum[x-1]) + x;\n    }\n};\n\nint main() {\n    Solution solution = new Solution();\n    int[][] matrix1 = {{1, 0, 1},{0,-10^9,0},{z,-10^9,z}};\n    cout << \"Result for test case 1: \" << solution.maxSumSquare(matrix1, 6) << endl;\n    \n    int[][] matrix2 = {{2,2},{3,3}};\n    cout << \"Result for test case 2: \" << solution.maxSumSquare(matrix2, 5) << endl;\n    \n    int[][] matrix3 = {{-1,-1,-1},{1,-2,2},{-1,-2,2}};\n    cout << \"Result for test case 3: \" << solution.maxSumSquare(matrix3, 3) << endl;\n\n    return 0;\n}\n```",
  "364": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int depthSum(std::vector<std::vector<int>>& nestedList) {\n        int sum = 0;\n        for (const auto& val : nestedList) {\n            if (!val.empty()) {\n                sum += val[0] + depthSum(val.size() > 1 ? &val[1] : {});\n            }\n        }\n        return sum;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> test1 = {{1,4},{6,5,3},{23,null,null}};\n    std::cout << \"Test case 1: \" << solution.depthSum(test1) << std::endl;\n    \n    // Test case 2\n    std::vector<std::vector<int>> test2 = {{2,7,11}, {18},{4,15,[5,-3]}};\n    std::cout << \"Test case 2: \" << solution.depthSum(test2) << std::endl;\n    \n    // Test case 3\n    std::vector<std::vector<int>> test3 = {{1,null,null},{8,6},{10}};\n    std::cout << \"Test case 3: \" << solution.depthSum(test3) << std::endl;\n\n    return 0;\n}\n```",
  "365": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int waterJugs(int capacityA, int capacityB, int numA, int numB) {\n        return (numA / capacityA + numB / capacityB);\n    }\n};\n\nint main() {\n    vector<pair<int, int>> testCases = {\n        {{4, 3}, 5},\n        {{9, 2}, 6},\n        {{1, 1}, 0}\n    };\n\n    for (const auto& testCase : testCases) {\n        Solution solution;\n        cout << \"Test Case: A capacity is \" << testCase.first.first\n             << \", B capacity is \" << testCase.first.second\n             << \". Expected result is \" << testCase.second << \". Got \"\n             << solution.waterJugs(testCase.first.first, testCase.first.second, testCase.second / testCase.first.first,\n                                       (testCase.second - (testCase.second % testCase.first.first)) / testCase.first.second) << endl;\n    }\n\n    return 0;\n}\n```",
  "367": "```\n#include <iostream>\nusing namespace std;\n\nbool isPerfectSquare(int num) {\n    if (num < 2)\n        return true;\n    long long sq = (long long)num * num;\n    return sq == num;\n}\n\nint main() {\n    cout << \"Test Case 1: \" << (isPerfectSquare(16) ? \"Pass\" : \"Fail\") << endl;\n    cout << \"Test Case 2: \" << (isPerfectSquare(14) ? \"Pass\" : \"Fail\") << endl;\n    cout << \"Test Case 3: \" << (isPerfectSquare(25) ? \"Pass\" : \"Fail\") << endl;\n    \n    return 0;\n}\n```",
  "366": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nstd::vector<std::vector<int>> findLeaves(TreeNode* root) {\n    if (!root)\n        return {};\n\n    std::vector<std::vector<int>> res;\n\n    while (root) {\n        int maxDepth = -1;\n        TreeNode *lastNode = NULL, *firstNode = NULL;\n\n        for (TreeNode *node = root; node; ) {\n            if (node->left) {\n                node = node->left;\n                firstNode = node;\n            } else if (node->right) {\n                node = node->right;\n                lastNode = node;\n            } else {\n                res.push_back({node->val});\n                node = NULL;\n            }\n        }\n\n        root = lastNode ? lastNode : firstNode;\n    }\n\n    return res;\n}\n\nint main() {\n    TreeNode *root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->right->left = new TreeNode(4);\n    root1->right->right = new TreeNode(5);\n\n    std::vector<std::vector<int>> leaves1 = findLeaves(root1);\n\n    for (auto leaf : leaves1) {\n        for (int val : leaf)\n            std::cout << val << \" \";\n        std::cout << \"\\n\";\n    }\n\n    TreeNode *root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(3);\n\n    std::vector<std::vector<int>> leaves2 = findLeaves(root2);\n\n    for (auto leaf : leaves2) {\n        for (int val : leaf)\n            std::cout << val << \" \";\n        std::cout << \"\\n\";\n    }\n\n    TreeNode *root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(3);\n    root3->left->left = new TreeNode(4);\n\n    std::vector<std::vector<int>> leaves3 = findLeaves(root3);\n\n    for (auto leaf : leaves3) {\n        for (int val : leaf)\n            std::cout << val << \" \";\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "368": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint findLargestDivisibleSubset(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    std::vector<int> dp(n, 1);\n    std::vector<int> prev(n, -1);\n    \n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (nums[i] % nums[j] == 0 && dp[i] < dp[j] + 1) {\n                dp[i] = dp[j] + 1;\n                prev[i] = j;\n            }\n        }\n    }\n    \n    int maxLen = 0, maxEnd = -1;\n    for (int i = 0; i < n; i++) {\n        if (dp[i] > maxLen) {\n            maxLen = dp[i];\n            maxEnd = i;\n        }\n    }\n    \n    std::vector<int> result;\n    while (maxEnd != -1) {\n        result.push_back(nums[maxEnd]);\n        int prevIndex = prev[maxEnd];\n        maxEnd = prevIndex;\n    }\n    \n    std::reverse(result.begin(), result.end());\n    \n    return result.size();\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> nums1 = {1, 2, 3};\n    int result1 = findLargestDivisibleSubset(nums1);\n    std::cout << \"Test case 1: The size of the largest divisible subset is \" << result1 << \".\" << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {1, 2, 4, 10, 16};\n    int result2 = findLargestDivisibleSubset(nums2);\n    std::cout << \"Test case 2: The size of the largest divisible subset is \" << result2 << \".\" << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {1, 3};\n    int result3 = findLargestDivisibleSubset(nums3);\n    std::cout << \"Test case 3: The size of the largest divisible subset is \" << result3 << \".\" << std::endl;\n\n    return 0;\n}\n```",
  "369": "```\n#include <iostream>\n#include \"ListNode.h\"\n\nclass Solution {\npublic:\n    ListNode* plusOne(ListNode* head) {\n        if (!head) return new ListNode(1);\n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        ListNode* cur = dummy;\n        while (cur && cur->val < 9) {\n            cur = cur->next;\n        }\n        if (cur) cur->val++;\n        else {\n            ListNode* newHead = new ListNode(1);\n            newHead->next = head;\n            return newHead;\n        }\n        return dummy->next;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    ListNode* head1 = new ListNode(7);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(9);\n    ListNode* res1 = solution.plusOne(head1);\n    while (res1) {\n        std::cout << res1->val << \" \";\n        res1 = res1->next;\n    }\n    std::cout << std::endl;\n\n    // Test Case 2\n    head1 = new ListNode(0);\n    ListNode* res2 = solution.plusOne(head1);\n    while (res2) {\n        std::cout << res2->val << \" \";\n        res2 = res2->next;\n    }\n    std::cout << std::endl;\n\n    // Test Case 3\n    head1 = new ListNode(9);\n    ListNode* res3 = solution.plusOne(head1);\n    while (res3) {\n        std::cout << res3->val << \" \";\n        res3 = res3->next;\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "371": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int getSum(int a, int b) {\n        while (b) {\n            unsigned int carry = (unsigned int)(a & b);\n            a = a ^ b;\n            b = carry << 1;\n        }\n        return a;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test Case 1: \";\n    cout << solution.getSum(1, 2) << endl; // Output: 3\n    cout << \"Test Case 2: \";\n    cout << solution.getSum(-2, 3) << endl; // Output: 1\n    cout << \"Test Case 3: \";\n    cout << solution.getSum(5, -7) << endl; // Output: -2\n    return 0;\n}\n```",
  "370": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int sumRange(int A[], int n, int m) {\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res += A[i];\n        }\n        return res;\n    }\n\n    int subarraySum(int A[], int n) {\n        int res = 0, pre = 0;\n        unordered_map<int, int> map;\n        map[0] = -1;\n        for (int i = 0; i < n; i++) {\n            pre += A[i];\n            if (map.find(pre - 2000000020) != map.end()) {\n                res = i - map[pre - 2000000020];\n            } else {\n                map[pre] = i;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int A1[] = {3, 8, 0, -10000, 10};\n    cout << \"Test Case 1: \" << solution.subarraySum(A1, sizeof(A1) / sizeof(A1[0])) << endl;\n    \n    int A2[] = {-5, -4, -1, 1, 2};\n    cout << \"Test Case 2: \" << solution.subarraySum(A2, sizeof(A2) / sizeof(A2[0])) << endl;\n\n    int A3[] = {0, 0, 1, 6, 5, 9, 4, 3, 2};\n    cout << \"Test Case 3: \" << solution.subarraySum(A3, sizeof(A3) / sizeof(A3[0])) << endl;\n\n    return 0;\n}\n```",
  "372": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int myPow(double x, int y) {\n        if (y == 0)\n            return 1;\n        double half_pow = myPow(x, y / 2);\n        if (y % 2 == 0)\n            return half_pow * half_pow;\n        else\n            return x * half_pow * half_pow;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.myPow(2.00000, 10) << endl; // expected output: 1024.0\n    cout << \"Test case 2: \" << solution.myPow(2.00000, -3) << endl; // expected output: 0.125\n    cout << \"Test case 3: \" << solution.myPow(1.5, 4) << endl; // expected output: 40.625\n\n    return 0;\n}\n```",
  "374": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int guessNumber(int n) {\n        int left = 1;\n        int right = n;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (guess(mid) == -1) return mid;\n            else if (guess(mid) > 0) left = mid + 1;\n            else right = mid - 1;\n        }\n        return -1;\n    }\n\nprivate:\n    int guess(int n) {\n        // implement your own guessing logic here\n        return 0; // replace with actual implementation\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test Case 1: \" << solution.guessNumber(10) << endl;\n    cout << \"Test Case 2: \" << solution.guessNumber(25) << endl;\n    cout << \"Test Case 3: \" << solution.guessNumber(50) << endl;\n    return 0;\n}\n```",
  "373": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Pair {\n    int num1;\n    int num2;\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        priority_queue<pair<long long, struct Pair*>, vector<pair<long long, struct Pair*> >, greater<pair<long long, struct Pair*>>> minHeap;\n        \n        for (int i = 0; i < nums1.size(); i++) {\n            for (int j = 0; j < nums2.size(); j++) {\n                if (i == 0 && j == 0) {\n                    minHeap.push({nums1[i] + nums2[j], new Pair{nums1[i], nums2[j]}});\n                } else if (i == 0) {\n                    while (j > 0 && nums2[j-1] >= nums2[j]) {\n                        j--;\n                    }\n                    if (j < nums2.size()) {\n                        minHeap.push({nums1[0] + nums2[j], new Pair{nums1[0], nums2[j]}});\n                    }\n                } else if (j == 0) {\n                    while (i > 0 && nums1[i-1] >= nums1[i]) {\n                        i--;\n                    }\n                    if (i < nums1.size()) {\n                        minHeap.push({nums1[i] + nums2[0], new Pair{nums1[i], nums2[0]}});\n                    }\n                } else {\n                    while (j > 0 && nums2[j-1] >= nums2[j]) {\n                        j--;\n                    }\n                    while (i > 0 && nums1[i-1] >= nums1[i]) {\n                        i--;\n                    }\n                    if (i < nums1.size() && j < nums2.size()) {\n                        minHeap.push({nums1[i] + nums2[j], new Pair{nums1[i], nums2[j]}});\n                    }\n                }\n            }\n        }\n        \n        vector<vector<int>> result;\n        while (!minHeap.empty() && k--) {\n            pair<long long, struct Pair*> temp = minHeap.top();\n            minHeap.pop();\n            result.push_back({temp.second->num1, temp.second->num2});\n            delete temp.second;\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> nums1 = {1, 7};\n    vector<int> nums2 = {11};\n    int k = 5;\n    \n    vector<vector<int>> pairs = solution.kSmallestPairs(nums1, nums2, k);\n    for (vector<int>& pair : pairs) {\n        cout << \"[\";\n        for (int num : pair) {\n            cout << num << \" \";\n        }\n        cout << \"] \" << endl;\n    }\n\n    // Test case 2\n    nums1 = {1, 5};\n    nums2 = [10];\n    k = 3;\n    \n    pairs = solution.kSmallestPairs(nums1, nums2, k);\n    for (vector<int>& pair : pairs) {\n        cout << \"[\";\n        for (int num : pair) {\n            cout << num << \" \";\n        }\n        cout << \"] \" << endl;\n    }\n\n    // Test case 3\n    nums1 = [0];\n    nums2 = [0];\n    k = 3;\n    \n    pairs = solution.kSmallestPairs(nums1, nums2, k);\n    for (vector<int>& pair : pairs) {\n        cout << \"[\";\n        for (int num : pair) {\n            cout << num << \" \";\n        }\n        cout << \"] \" << endl;\n    }\n\n    return 0;\n}\n\n```",
  "375": "```\n#include <iostream>\n#include <vector>\n\nint getGuess(std::vector<int>& secret) {\n    int low = 1;\n    int high = 1000000;\n    while (true) {\n        int mid = low + (high - low) / 2;\n        if (mid == secret[0]) return 0; // guess the number correctly\n        else if (mid > secret[0]) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> secret1 = {8};\n    std::cout << \"Test Case 1: \" << getGuess(secret1) << std::endl;\n\n    std::vector<int> secret2 = {10, 6, 3, 15};\n    std::cout << \"Test Case 2: \" << getGuess(secret2) << std::endl;\n\n    std::vector<int> secret3 = {5, 7, 8, 9, 1, 11};\n    std::cout << \"Test Case 3: \" << getGuess(secret3) << std::endl;\n\n    return 0;\n}\n```",
  "376": "```\n#include <iostream>\n#include <vector>\n\nint wiggleMaxLength(std::vector<int>& nums) {\n    if (nums.empty()) return 0;\n\n    int up = 1;\n    int down = 1;\n    for (int i = 1; i < nums.size(); ++i) {\n        if ((nums[i] > nums[i - 1])) {\n            up = down + 1;\n            down = 1;\n        } else if ((nums[i] < nums[i - 1])) {\n            down = up + 1;\n            up = 1;\n        }\n    }\n\n    return std::max(up, down);\n}\n\nint main() {\n    std::vector<int> test1({1,7,4,9,2,5});\n    std::cout << \"Test case 1: \" << wiggleMaxLength(test1) << std::endl;\n\n    std::vector<int> test2({1,17,5,10,13,16});\n    std::cout << \"Test case 2: \" << wiggleMaxLength(test2) << std::endl;\n\n    std::vector<int> test3({1,2,3,4,5});\n    std::cout << \"Test case 3: \" << wiggleMaxLength(test3) << std::endl;\n\n    return 0;\n}\n```",
  "377": "```\n#include <iostream>\n#include <vector>\n\nint comboSumIV(int target, std::vector<int>& candidates) {\n    int dp[target + 1] = {0};\n    for (int i = 1; i <= target; ++i) {\n        dp[i] = 0;\n        for (int j = 0; j < candidates.size(); ++j) {\n            if (candidates[j] > i) break;\n            dp[i] += (i - candidates[j] >= 0 ? dp[i - candidates[j]] : 0);\n        }\n    }\n    return dp[target];\n}\n\nint main() {\n    std::vector<int> test1 = {2,3,6,7};\n    int target1 = 7;\n    std::cout << comboSumIV(target1, test1) << std::endl;\n\n    std::vector<int> test2 = {2,3,5};\n    int target2 = 8;\n    std::cout << comboSumIV(target2, test2) << std::endl;\n\n    std::vector<int> test3 = {2,3,5,7};\n    int target3 = 10;\n    std::cout << comboSumIV(target3, test3) << std::endl;\n\n    return 0;\n}\n```",
  "378": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int findKthNumber(int m, int n, int k) {\n        if (k > m * n) return -1;\n        int left = 1, right = m * n;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int ones = countOnes(mid, m, n);\n            if (ones >= k) {\n                right = mid - 1;\n                k -= ones;\n            } else {\n                left = mid + 1;\n                k--;\n            }\n        }\n        return left;\n    }\n\n    int countOnes(int num, int m, int n) {\n        int res = 0;\n        for (int i = 1; i <= m; ++i) {\n            if (num >= i * n) {\n                res += n;\n                num -= i * n;\n            } else {\n                res++;\n                num--;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test Case 1: \";\n    int result1 = solution.findKthNumber(3, 3, 4);\n    if (result1 == 5) {\n        std::cout << \"Pass\" << std::endl;\n    } else {\n        std::cout << \"Fail\" << std::endl;\n    }\n\n    std::cout << \"Test Case 2: \";\n    int result2 = solution.findKthNumber(10, 4, 7);\n    if (result2 == 15) {\n        std::cout << \"Pass\" << std::endl;\n    } else {\n        std::cout << \"Fail\" << std::endl;\n    }\n\n    std::cout << \"Test Case 3: \";\n    int result3 = solution.findKthNumber(1, 1000, 1000);\n    if (result3 == 1000) {\n        std::cout << \"Pass\" << std::endl;\n    } else {\n        std::cout << \"Fail\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "379": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass PhoneDirectory {\npublic:\n    PhoneDirectory(int mn) {\n        max = mn;\n        used = new bool[max];\n        for (int i = 0; i < max; i++) {\n            used[i] = false;\n        }\n    }\n\n    ~PhoneDirectory() {\n        delete[] used;\n    }\n\n    bool checkAvailability(int number) {\n        return number >= 0 && number < max && !used[number];\n    }\n\n    void checkIn(int number) {\n        if (number >= 0 && number < max) {\n            used[number] = true;\n        }\n    }\n\n    int checkOut(int number) {\n        for (int i = max - 1; i >= 0; i--) {\n            if (!used[i]) {\n                used[i] = false;\n                return i;\n            }\n        }\n        return -1;\n    }\n\n};\n\nint main() {\n    PhoneDirectory p1(3);\n    cout << p1.checkAvailability(0) << endl; // True\n    p1.checkIn(2);\n    cout << p1.checkAvailability(0) << endl; // True\n    cout << p1.checkAvailability(1) << endl; // False\n    cout << p1.checkAvailability(2) << endl; // False\n    p1.checkOut(2);\n    cout << p1.checkAvailability(2) << endl; // True\n\n    PhoneDirectory p2(9);\n    cout << p2.checkAvailability(8) << endl; // True\n    p2.checkIn(0);\n    p2.checkIn(1);\n    p2.checkIn(2);\n    p2.checkOut(1);\n    cout << p2.checkAvailability(1) << endl; // True\n\n    PhoneDirectory p3(10);\n    for (int i = 0; i < 9; i++) {\n        p3.checkIn(i);\n    }\n    cout << p3.checkAvailability(9) << endl; // False\n    cout << p3.checkAvailability(8) << endl; // True\n    p3.checkOut(8);\n    cout << p3.checkAvailability(8) << endl; // False\n\n    return 0;\n}\n```",
  "380": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass RandomizedSet {\npublic:\n    vector<int> nums;\n    unordered_map<int,int> indexMap;\n\n    bool insert(int val) {\n        if(indexMap.find(val) != indexMap.end()) return false;\n        nums.push_back(val);\n        indexMap[val] = nums.size() - 1;\n        return true;\n    }\n\n    bool remove(int val) {\n        if(indexMap.find(val) == indexMap.end()) return false;\n        int lastVal = nums.back();\n        int idx = indexMap[val];\n        nums[idx] = lastVal;\n        indexMap[lastVal] = idx;\n        nums.pop_back();\n        indexMap.erase(val);\n        return true;\n    }\n\n    int getRandom() {\n        if(nums.empty()) return -1;\n        return nums[rand() % nums.size()];\n    }\n};\n\nint main() {\n    RandomizedSet rset;\n    \n    // Test case 1\n    cout << \"Test Case 1: \";\n    if(rset.insert(1)) cout << \"Insert 1: Success\" << endl;\n    else cout << \"Insert 1: Failure\" << endl;\n    if(rset.insert(2)) cout << \"Insert 2: Success\" << endl;\n    else cout << \"Insert 2: Failure\" << endl;\n    if(rset.getRandom() == 1) cout << \"Get Random (1): Success\" << endl;\n    else cout << \"Get Random (1): Failure\" << endl;\n\n    // Test case 2\n    rset.remove(1);\n    cout << \"\\nTest Case 2: \";\n    if(rset.insert(3)) cout << \"Insert 3: Success\" << endl;\n    else cout << \"Insert 3: Failure\" << endl;\n    if(rset.getRandom() == 2) cout << \"Get Random (2): Success\" << endl;\n    else cout << \"Get Random (2): Failure\" << endl;\n\n    // Test case 3\n    rset.insert(4);\n    cout << \"\\nTest Case 3: \";\n    if(rset.remove(4)) cout << \"Remove 4: Success\" << endl;\n    else cout << \"Remove 4: Failure\" << endl;\n    if(rset.getRandom() == 2) cout << \"Get Random (3): Success\" << endl;\n    else cout << \"Get Random (3): Failure\" << endl;\n\n    return 0;\n}\n```",
  "381": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass RandomizedSet {\npublic:\n    unordered_map<int, int> valToIndex;\n    vector<int> nums;\n    \n    bool insert(int val) {\n        if (valToIndex.find(val) != valToIndex.end()) return false;\n        int index = nums.size();\n        valToIndex[val] = index;\n        nums.push_back(val);\n        return true;\n    }\n    \n    bool remove(int val) {\n        if (valToIndex.find(val) == valToIndex.end()) return false;\n        int index = valToIndex[val];\n        int lastVal = nums.back();\n        nums[index] = lastVal;\n        valToIndex[lastVal] = index;\n        nums.pop_back();\n        valToIndex.erase(val);\n        return true;\n    }\n    \n    int getRandom() {\n        if (nums.empty()) return 0;\n        random_shuffle(nums.begin(), nums.end());\n        return nums[0];\n    }\n};\n\nint main() {\n    RandomizedSet randomizedSet = RandomizedSet();\n    cout << randomizedSet.insert(1) << endl; // true\n    cout << randomizedSet.insert(1) << endl; // false\n    cout << randomizedSet.getRandom() << endl; // 1\n    cout << randomizedSet.remove(1) << endl; // true\n    cout << randomizedSet.getRandom() << endl; // 1\n    cout << randomizedSet.insert(2) << endl; // true\n    cout << randomizedSet.getRandom() << endl; // 1 or 2\n    return 0;\n}\n```",
  "382": "```\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nstruct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* getRandomNode(ListNode* head) {\n        if (!head) return NULL;\n\n        ListNode* node = head;\n        srand(time(0));\n        int r = rand() % (node->val + 1);\n        for (; node; node = node->next) {\n            if (--r == 0) return node;\n        }\n        return NULL;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    std::cout << \"Test case 1: \" << solution.getRandomNode(head1)->val << std::endl;\n\n    // Test case 2\n    ListNode* head2 = new ListNode(4);\n    head2->next = new ListNode(5);\n    std::cout << \"Test case 2: \" << solution.getRandomNode(head2)->val << std::endl;\n\n    // Test case 3\n    ListNode* head3 = new ListNode(6);\n    head3->next = new ListNode(7);\n    head3->next->next = new ListNode(8);\n    std::cout << \"Test case 3: \" << solution.getRandomNode(head3)->val << std::endl;\n\n    return 0;\n}\n```",
  "383": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool canConstruct(string ransomNote, string magazine) {\n    int count[26] = {0};\n    for (int i = 0; i < magazine.length(); ++i) {\n        count[magazine[i] - 'a']++;\n    }\n    for (int i = 0; i < ransomNote.length(); ++i) {\n        if (count[ransomNote[i] - 'a']-- <= 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    cout << boolalpha;\n    cout << canConstruct(\"aa\", \"aab\") << endl; // Expected: false\n    cout << canConstruct(\"a\", \"b\") << endl; // Expected: false\n    cout << canConstruct(\"aa\", \"aaa\") << endl; // Expected: true\n    return 0;\n}\n```",
  "384": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<int> shuffle(std::vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 1; i < n; ++i) {\n            int j = rand() % (i + 1);\n            std::swap(nums[i], nums[j]);\n        }\n        return nums;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> test1 = {1,2,3};\n    std::cout << \"Test 1: \";\n    for (int num : solution.shuffle(test1)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<int> test2 = {1,1,2};\n    std::cout << \"Test 2: \";\n    for (int num : solution.shuffle(test2)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<int> test3 = {0,1,2};\n    std::cout << \"Test 3: \";\n    for (int num : solution.shuffle(test3)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "385": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string getMiniString(string s) {\n        stack<char> st;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == '(') {\n                st.push('(');\n            } else if (s[i] == ')') {\n                while (!st.empty() && st.top() != '(') {\n                    st.pop();\n                }\n                if (st.empty()) {\n                    return \"Invalid input\";\n                }\n                st.pop();\n            }\n        }\n        while (!st.empty()) {\n            s += st.top();\n            st.pop();\n        }\n        return s;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n\n    string test1 = \"(()())\";\n    cout << \"Test 1: \" << solution.getMiniString(test1) << endl; // Output: ((()))\n    \n    string test2 = \"()((()))\";\n    cout << \"Test 2: \" << solution.getMiniString(test2) << endl; // Output: (()(()))\n\n    string test3 = \"())(())\";\n    cout << \"Test 3: \" << solution.getMiniString(test3) << endl; // Output: Invalid input\n\n    return 0;\n}\n```",
  "386": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> lexicalOrder(int n) {\n        std::vector<int> res;\n        for (int i = 1; i <= n; ++i) {\n            if (isValid(i, n)) {\n                res.push_back(i);\n                int j = i + 1;\n                while (j <= n && !isValid(j, n)) {\n                    j++;\n                }\n                if (j <= n) {\n                    res.push_back(j);\n                }\n            }\n        }\n        return res;\n    }\n\n    bool isValid(int num, int n) {\n        std::string s = std::to_string(num);\n        for (int i = 0; i < s.length(); ++i) {\n            if (s[i] > '3' || (i > 0 && s[i] <= s[i - 1])) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<int> res1 = solution.lexicalOrder(13);\n    for (int num : res1) {\n        std::cout << num << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<int> res2 = solution.lexicalOrder(20);\n    for (int num : res2) {\n        std::cout << num << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<int> res3 = solution.lexicalOrder(23);\n    for (int num : res3) {\n        std::cout << num << \" \";\n    }\n    std::cout << \"\\n\";\n\n    return 0;\n}\n```",
  "387": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nint firstUncompromisingIndex(const std::string& str) {\n    std::unordered_map<char, int> charCount;\n    for (char c : str) {\n        charCount[c]++;\n    }\n    for (int i = 0; i < str.length(); i++) {\n        if (charCount[str[i]] == 1) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << firstUncompromisingIndex(\"leetcode\") << std::endl; // Expected output: 0\n    std::cout << \"Test case 2: \" << firstUncompromisingIndex(\"love\") << std::endl; // Expected output: 2\n    std::cout << \"Test case 3: \" << firstUncompromisingIndex(\"aaa\") << std::endl; // Expected output: -1\n\n    return 0;\n}\n```",
  "388": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nint lengthLongestPath(std::string path) {\n    int maxLen = 0;\n    std::stack<int> dirStack;\n\n    for (char c : path) {\n        if (c == '/') {\n            while (!dirStack.empty()) {\n                dirStack.pop();\n            }\n        } else if (c == '\\n') {\n            int curDirLevel = dirStack.size() + 1;\n            maxLen = std::max(maxLen, curDirLevel + dirStack.empty());\n        } else {\n            dirStack.push(c - ' ');\n        }\n    }\n\n    return maxLen;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << lengthLongestPath(\"/home/file.txt\") << \"\\n\";\n    std::cout << \"Test case 2: \" << lengthLongestPath(\"/a/1.txt(b/c)/3.png\") << \"\\n\";\n    std::cout << \"Test case 3: \" << lengthLongestPath(\"dir\\n    a file.txt\\n\\n    b.txt\") << \"\\n\";\n\n    return 0;\n}\n```",
  "389": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string findDifferentString(vector<string>& strs) {\n        vector<char> charSet;\n        for (const auto& str : strs) {\n            for (char c : str) {\n                bool found = false;\n                for (auto it = charSet.begin(); it != charSet.end(); ++it) {\n                    if (*it == c) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    charSet.push_back(c);\n                }\n            }\n        }\n\n        for (const auto& str : strs) {\n            vector<char> strChars(str.begin(), str.end());\n            bool foundAll = true;\n            for (auto c : charSet) {\n                bool found = false;\n                for (char sc : strChars) {\n                    if (sc == c) {\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    foundAll = false;\n                    break;\n                }\n            }\n            if (!foundAll) {\n                return str;\n            }\n        }\n\n        return \"\";\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> test1 = {\"a\", \"b\", \"c\"};\n    cout << solution.findDifferentString(test1) << endl;  // should print \"\"\n\n    vector<string> test2 = {\"aaa\", \"bbb\", \"ccc\"};\n    cout << solution.findDifferentString(test2) << endl;  // should print \"aaa\"\n\n    vector<string> test3 = {\"a\", \"abc\", \"def\"};\n    cout << solution.findDifferentString(test3) << endl;  // should print \"a\"\n\n    return 0;\n}\n```",
  "390": "```\n#include <iostream>\n#include <vector>\n\nint lastRemaining(int n) {\n    bool left = true;\n    int start = 1;\n    int end = n;\n\n    while (end > 1) {\n        if ((left && end % 2 == 0) || (!left && end % 2 != 0)) {\n            end = (end / 2);\n        } else {\n            left = !left;\n            start = (start * 2) + 1;\n            end = (end - 1) / 2;\n        }\n    }\n\n    return start;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << lastRemaining(9) << std::endl; // Expected output: 5\n    std::cout << \"Test Case 2: \" << lastRemaining(7) << std::endl; // Expected output: 4\n    std::cout << \"Test Case 3: \" << lastRemaining(12) << std::endl; // Expected output: 6\n\n    return 0;\n}\n```",
  "391": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint totalArea(vector<vector<int>>& rectangles) {\n    vector<pair<int, int>> events;\n    for (const auto& r : rectangles) {\n        events.emplace_back(r[0], 1);\n        events.emplace_back(r[2] + r[3], -1);\n    }\n    sort(events.begin(), events.end());\n    int max_width = 0, area = 0, curr_width = 0;\n    for (const auto& e : events) {\n        if (e.second == 1) {\n            curr_width += e.first;\n        } else {\n            max_width = max(max_width, curr_width);\n            area += max_width * e.first;\n            curr_width = 0;\n        }\n    }\n    return area;\n}\n\nint main() {\n    vector<vector<int>> rectangles1 {{1,3,7,2},{6,1,4,5}};\n    cout << \"Test case 1: \" << totalArea(rectangles1) << endl;\n\n    vector<vector<int>> rectangles2 {{1,3,7,2},{6,1,4,5},{10,8,20,9}};\n    cout << \"Test case 2: \" << totalArea(rectangles2) << endl;\n\n    vector<vector<int>> rectangles3 {{0,0,0,0}};\n    cout << \"Test case 3: \" << totalArea(rectangles3) << endl;\n    \n    return 0;\n}\n```",
  "392": "```\n#include <iostream>\n#include <vector>\n\nbool isSubsequence(std::string s, std::string t) {\n    int i = 0, j = 0;\n    while (i < s.size() && j < t.size()) {\n        if (s[i] == t[j]) {\n            i++;\n        }\n        j++;\n    }\n    return i == s.size();\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test case 1: \" << isSubsequence(\"abc\", \"ahbgdc\") << \"\\n\";\n    std::cout << \"Test case 2: \" << isSubsequence(\"axc\", \"ahbgdc\") << \"\\n\";\n    std::cout << \"Test case 3: \" << isSubsequence(\"leetcode\", \"leetcodeworsolution\") << \"\\n\";\n    return 0;\n}\n```",
  "393": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    bool validUtf8(std::vector<int>& data) {\n        int bytes = 0;\n        for (int i = 0; i < data.size(); i++) {\n            int byte = data[i];\n            if ((byte & 0x80) == 0) {\n                // single byte\n                continue;\n            } else if ((byte >> 5) == 0b110) {\n                // lead bytes for 2-byte utf-8 sequence\n                bytes++;\n                if (bytes > 1) return false;\n            } else if ((byte >> 4) == 0b1110) {\n                // lead bytes for 3-byte utf-8 sequence\n                bytes++;\n                if (bytes > 2) return false;\n            } else {\n                // invalid byte\n                return false;\n            }\n        }\n        return bytes <= 1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<int> data1 = {197,130,1};\n    std::cout << (solution.validUtf8(data1) ? \"Valid\" : \"Invalid\") << std::endl;\n\n    std::vector<int> data2 = {235,142,38,233,150,3];\n    std::cout << (solution.validUtf8(data2) ? \"Valid\" : \"Invalid\") << std::endl;\n\n    std::vector<int> data3 = {220,81,22,170};\n    std::cout << (solution.validUtf8(data3) ? \"Valid\" : \"Invalid\") << std::endl;\n\n    return 0;\n}\n```",
  "394": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string decodeString(std::string s) {\n        int i = 0;\n        return decodeStringHelper(s, i);\n    }\n    \nprivate:\n    std::string decodeStringHelper(std::string s, int &i) {\n        std::string res = \"\";\n        while (i < s.size() && isdigit(s[i])) {\n            int k = 0;\n            while (i < s.size() && isdigit(s[i])) {\n                k = k * 10 + s[i] - '0';\n                i++;\n            }\n            i++; // skip '('\n            res.append(s, i, s.find(')', i) - i);\n            for (int j = 0; j < k; j++) {\n                res.append(res);\n            }\n            i++; // skip ')'\n        }\n        while (i < s.size() && !isspace(s[i])) {\n            res += s[i];\n            i++;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::cout << \"Test case 1: \" << solution.decodeString(\"3+2*\") << std::endl; // Output: 3+2*\n    std::cout << \"Test case 2: \" << solution.decodeString(\"4*\") << std::endl; // Output: \n    std::cout << \"Test case 3: \" << solution.decodeString(\"3+14*\") << std::endl; // Output: 3+14*\n\n    return 0;\n}\n```",
  "395": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestSubstr(string s, int k) {\n        if (k == 0) return 0;\n        \n        unordered_map<char, int> mp;\n        for (int i = 0; i < s.length(); i++) {\n            mp[s[i]]++;\n        }\n        \n        int ans = 0, start = -1;\n        for (auto p : mp) {\n            if (p.second >= k) {\n                if (start == -1) start = p.first;\n                else {\n                    if (ans < p.first - start) ans = p.first - start;\n                }\n            } else break;\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    string s1 = \"aaabaab!\";\n    int k1 = 3;\n    cout << \"Test Case 1: \" << solution.longestSubstr(s1, k1) << endl;  // Output: 4\n\n    // Test Case 2\n    string s2 = \"abacccba\";\n    int k2 = 1;\n    cout << \"Test Case 2: \" << solution.longestSubstr(s2, k2) << endl;  // Output: 3\n\n    // Test Case 3\n    string s3 = \"aaa\";\n    int k3 = 2;\n    cout << \"Test Case 3: \" << solution.longestSubstr(s3, k3) << endl;  // Output: 0\n\n    return 0;\n}\n```",
  "396": "```\n#include <iostream>\n#include <vector>\n\nint findMinFunction(std::vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) {\n        sum += num;\n    }\n    \n    int totalSum = sum, maxCount = 0;\n    \n    for (int i = 0; i < nums.size(); i++) {\n        int newSum = totalSum - nums[i] + nums[(i+1)%nums.size()];\n        \n        if (newSum > totalSum) {\n            return i;\n        }\n        \n        totalSum = newSum;\n    }\n    \n    return -1;\n}\n\nint main() {\n    std::vector<int> nums1 = {4, 3, 2, 6};\n    int result1 = findMinFunction(nums1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> nums2 = {0, 0};\n    int result2 = findMinFunction(nums2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> nums3 = {0, 1, 0];\n    int result3 = findMinFunction(nums3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "397": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int integerReplacement(int n) {\n        if (n == 1) return 0;\n        if (n % 2 == 0) {\n            return 1 + integerReplacement(n / 2);\n        } else {\n            return 1 + min(integerReplacement((n - 1) / 2), integerReplacement((n + 1) / 2));\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << solution.integerReplacement(8) << endl;  // Expected output: 3\n    cout << \"Test case 2: \" << solution.integerReplacement(10) << endl;  // Expected output: 4\n    cout << \"Test case 3: \" << solution.integerReplacement(16) << endl;   // Expected output: 4\n    \n    return 0;\n}\n```",
  "398": "```\n#include <iostream>\n#include <vector>\n#include <random>\n\nclass Solution {\npublic:\n    std::mt19937 mt;\n    std::uniform_int_distribution<int> dis(0, n - 1);\n\n    int pickIndex(std::vector<int>& nums) {\n        n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            mt.seed(i);\n            dis.param(std::uniform_int_distribution<int>::param_type(0, n - 1));\n        }\n        return dis(mt);\n    }\n\nprivate:\n    int n;\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<int> nums1 = {1};\n    std::cout << \"Test Case 1: \" << solution.pickIndex(nums1) << std::endl;\n\n    // Test Case 2\n    std::vector<int> nums2 = {1, 2, 3, 4, 5};\n    std::cout << \"Test Case 2: \" << solution.pickIndex(nums2) << std::endl;\n\n    // Test Case 3\n    std::vector<int> nums3 = {1, 2, 2, 3, 3, 3, 4, 4, 4, 4};\n    std::cout << \"Test Case 3: \" << solution.pickIndex(nums3) << std::endl;\n\n    return 0;\n}\n```",
  "399": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> divideArray(vector<string>& equations, vector<double>& values) {\n        unordered_map<string, double> mp;\n        for(int i = 0; i < equations.size(); i++) {\n            string s1 = equations[i].substr(0, equations[i].size() - 2);\n            string s2 = equations[i].substr(equations[i].size() - 1);\n            if(mp.find(s1) == mp.end()) \n                mp[s1] = (double)i / values.size();\n            else\n                mp[s1] /= values.size();\n            if(mp.find(s2) == mp.end()) \n                mp[s2] = values[i] / (double)i;\n            else\n                mp[s2] *= values[i] / (double)i;            \n        }\n        vector<string> res;\n        for(int i = 0; i < equations.size(); i++) {\n            if(mp[equations[i].substr(0, equations[i].size() - 2)] == mp[equations[i].substr(equations[i].size() - 1)])\n                res.push_back(equations[i]);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> equations1 = {\"a=/b\",\"b=3\"};\n    double values1[] = {2.0};\n    vector<double> values1V(values1,values1+1);\n    vector<string> result1 = solution.divideArray(equations1, values1V);\n\n    cout << \"Test Case 1: \";\n    for (auto &str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    vector<string> equations2 = {\"a=1\",\"b=2\",\"c=3\", \"a=b/4\"};\n    double values2[] = {5.0, 7.0};\n    vector<double> values2V(values2,values2+2);\n    vector<string> result2 = solution.divideArray(equations2, values2V);\n\n    cout << \"Test Case 2: \";\n    for (auto &str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    vector<string> equations3 = {\"e=8/a\",\"f=f/7.c\", \"d/d=e/ef\"};\n    double values3[] = {1.0, 1.0, 24.0};\n    vector<double> values3V(values3,values3+3);\n    vector<string> result3 = solution.divideArray(equations3, values3V);\n\n    cout << \"Test Case 3: \";\n    for (auto &str : result3) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "400": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int findNthDigit(int n) {\n        long long base = 1;\n        int length = 1;\n        while (n > length * (int)pow(10, length - 1)) {\n            base *= 10;\n            length++;\n        }\n        long long start = base;\n        for (int i = 1; i < length - 1; i++) {\n            start *= 10;\n        }\n        int end = start + (base * (long long)pow(10, length - 1) - 1);\n        start++;\n        while (start <= end) {\n            if (n == 0) return *(int*)&start;\n            n--;\n            start++;\n        }\n        return 0;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    int result1 = solution.findNthDigit(9);\n    std::cout << \"Test case 1: Nth digit of number 9 is \" << result1 << std::endl;\n\n    int result2 = solution.findNthDigit(4);\n    std::cout << \"Test case 2: Nth digit of number 4 is \" << result2 << std::endl;\n\n    int result3 = solution.findNthDigit(17);\n    std::cout << \"Test case 3: Nth digit of number 17 is \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "401": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> readBinaryWatch(int N) {\n        vector<string> res;\n        for (int h = 0; h < (1 << 10); h++) {\n            int minutes = 60 - ((h >> 5) * 32 + (h & 0x1f));\n            if (N == 8) continue;\n            if (N > 0 && (h & (1 << 9)) || N < 0) continue;\n            if (minutes >= 60) continue;\n            string s = to_string(h >> 5);\n            s += \":\";\n            if (minutes < 10) s += \"0\";\n            s += to_string(minutes);\n            res.push_back(s);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> result1 = solution.readBinaryWatch(8);\n    for (const auto& str : result1) {\n        cout << str << endl;\n    }\n\n    vector<string> result2 = solution.readBinaryWatch(0);\n    for (const auto& str : result2) {\n        cout << str << endl;\n    }\n\n    vector<string> result3 = solution.readBinaryWatch(5);\n    for (const auto& str : result3) {\n        cout << str << endl;\n    }\n\n    return 0;\n}\n```",
  "402": "```\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string removeKdigits(string num, int k) {\n        stack<char> st;\n        for (char c : num) {\n            while (!st.empty() && st.top() > c && k--) {\n                st.pop();\n            }\n            if (k > 0) {\n                st.push(c);\n            }\n        }\n        string res = \"\";\n        while (!st.empty()) {\n            res += st.top();\n            st.pop();\n        }\n        resize(res, k);\n        return res;\n    }\n\n    void resize(string& s, int k) {\n        while (k--) {\n            for (int i = 0; i < s.size(); i++) {\n                if (s[i] != '0') {\n                    s.erase(s.begin() + i);\n                    break;\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.removeKdigits(\"1432219\", 3) << endl;  // \"1219\"\n    cout << solution.removeKdigits(\"10200\", 1) << endl;   // \"200\"\n    cout << solution.removeKdigits(\"10\", 0) << endl;       // \"10\"\n\n    return 0;\n}\n```",
  "403": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint minFrogJumps(int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1, INT_MAX));\n\n    for (int i = 0; i <= n; i++) {\n        dp[i][i] = 0;\n    }\n\n    for (int len = 2; len <= n; len++) {\n        for (int left = 0; left + len - 1 <= n; left++) {\n            int right = left + len - 1;\n\n            for (int k = left; k < right; k++) {\n                dp[left][right] = min(dp[left][right], 1 + dp[left][k] + dp[k + 1][right]);\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n\nint main() {\n    cout << minFrogJumps(10) << endl; // Test case 1\n    cout << minFrogJumps(5) << endl;   // Test case 2\n    cout << minFrogJumps(7) << endl;   // Test case 3\n\n    return 0;\n}\n```",
  "404": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int sumOfLeftLeaves(TreeNode* root) {\n        if (root == NULL) return 0;\n\n        int sum = 0;\n        if (root->left != NULL && root->left->left == NULL && root->left->right == NULL)\n            sum += root->val;\n\n        sum += sumOfLeftLeaves(root->left);\n        sum += sumOfLeftLeaves(root->right);\n\n        return sum;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* root = new TreeNode(3);\n    root->left = new TreeNode(9);\n    root->right = new TreeNode(20);\n    root->right->left = new TreeNode(15);\n    root->right->right = new TreeNode(7);\n\n    cout << \"Sum of left leaves for Test Case 1: \" << solution.sumOfLeftLeaves(root) << endl;\n\n    // Test Case 2\n    root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->left->left = new TreeNode(4);\n    root->left->right = new TreeNode(5);\n\n    cout << \"Sum of left leaves for Test Case 2: \" << solution.sumOfLeftLeaves(root) << endl;\n\n    // Test Case 3\n    root = new TreeNode(0);\n\n    cout << \"Sum of left leaves for Test Case 3: \" << solution.sumOfLeftLeaves(root) << endl;\n\n    return 0;\n}\n```",
  "405": "```\n#include <iostream>\nusing namespace std;\n\nstring toHex(int num) {\n    string res = \"\";\n    while (num > 0) {\n        int temp = num & 15;\n        if (temp > 9)\n            res.insert(0, 1, ((char)(temp - 10 + 'a')));\n        else\n            res.insert(0, 1, (char)(temp + '0'));\n        num >>= 4;\n    }\n    return res;\n}\n\nint main() {\n    cout << toHex(26) << endl; // expected output: \"1a\"\n    cout << toHex(60) << endl; // expected output: \"3c\"\n    cout << toHex(45) << endl; // expected output: \"2d\"\n\n    return 0;\n}",
  "406": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {\n        sort(people.begin(), people.end(), [](const vector<int>& a, const vector<int>& b){\n            return a[0] > b[0] || (a[0] == b[0] && a[1] < b[1]);\n        });\n        vector<vector<int>> res;\n        for(auto& p : people) {\n            res.insert(res.begin() + p[1], p);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> input1 = {{7,0},{4,4},{7,1},{5,0},{6,1},{5,2}};\n    vector<vector<int>> expected1 = {{5,0},{7,0},{5,2},{6,1},{4,4},{7,1}};\n    vector<vector<int>> result1 = solution.reconstructQueue(input1);\n    for(int i=0; i<result1.size(); i++){\n        cout << \"Test Case 1: Expected - \";\n        for(auto p : expected1[i]) {\n            cout << p << \" \";\n        }\n        cout << endl;\n        cout << \"Actual - \";\n        for(auto p : result1[i]) {\n            cout << p << \" \";\n        }\n        cout << endl << endl;\n    }\n\n    // Test Case 2\n    vector<vector<int>> input2 = {{9,0},{7,0},{5,6},{6,1},{5,7},{7,2}};\n    vector<vector<int>> expected2 = {{7,0},{7,2},{5,6},{5,7},{6,1},{9,0}};\n    vector<vector<int>> result2 = solution.reconstructQueue(input2);\n    for(int i=0; i<result2.size(); i++){\n        cout << \"Test Case 2: Expected - \";\n        for(auto p : expected2[i]) {\n            cout << p << \" \";\n        }\n        cout << endl;\n        cout << \"Actual - \";\n        for(auto p : result2[i]) {\n            cout << p << \" \";\n        }\n        cout << endl << endl;\n    }\n\n    // Test Case 3\n    vector<vector<int>> input3 = {{6,0},{5,0},{4,4},{3,1},{5,8},{4,2}};\n    vector<vector<int>> expected3 = {{5,0},{4,1},{5,8},{3,2},{4,2},{6,0}};\n    vector<vector<int>> result3 = solution.reconstructQueue(input3);\n    for(int i=0; i<result3.size(); i++){\n        cout << \"Test Case 3: Expected - \";\n        for(auto p : expected3[i]) {\n            cout << p << \" \";\n        }\n        cout << endl;\n        cout << \"Actual - \";\n        for(auto p : result3[i]) {\n            cout << p << \" \";\n        }\n        cout << endl << endl;\n    }\n\n    return 0;\n}\n```",
  "407": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int trapRainWater(vector<vector<int>>& heightMap) {\n        if(heightMap.empty()) return 0;\n        int m = heightMap.size(), n = heightMap[0].size();\n        vector<vector<int>> water(m, vector<int>(n));\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>> , greater<pair<int, pair<int, int>>>> q;\n        \n        for(int i=0; i<m; ++i){\n            for(int j=0; j<n; ++j){\n                if(i==0 || j==0 || i==m-1 || j==n-1) {\n                    water[i][j] = heightMap[i][j];\n                    q.push({heightMap[i][j], {i, j}});\n                }\n            }\n        }\n        \n        int d=0;\n        while(!q.empty()){\n            auto [h, p]=q.top();\n            q.pop();\n            \n            for(int k=-1; k<=1; ++k){\n                for(int l=-1; l<=1; ++l){\n                    if(k==0 && l==0) continue;\n                    int newi = p.first + k;\n                    int newj = p.second + l;\n                    \n                    if(newi>=0 && newi<m && newj>=0 && newj<n && h>=heightMap[newi][newj]){\n                        water[newi][newj] += h - heightMap[newi][newj];\n                        if(heightMap[newi][newj]<h) q.push({h,heightMap[newi][newj]});\n                    }\n                }\n            }\n        }\n        \n        int res = 0;\n        for(int i=0; i<m; ++i){\n            for(int j=0; j<n; ++j){\n                if(heightMap[i][j]>water[i][j]) res += water[i][j];\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> heightMap1 = {{1,4,3,2,3,2,3,3},{4,2,3,2,3,3,2,3},{3,2,3,3,3,2,3,3},{2,3,3,2,3,3,2,2},{3,3,1,3,1,1,1,2},{1,1,1,1,1,1,1,10}};\n    cout << \"Test case 1: \" << solution.trapRainWater(heightMap1) << endl;\n\n    // Test case 2\n    vector<vector<int>> heightMap2 = {{12,13,1,12},{13,1,13,13},{1,3,1,15},{5,6,7,8},{5,4,3,9}};\n    cout << \"Test case 2: \" << solution.trapRainWater(heightMap2) << endl;\n\n    // Test case 3\n    vector<vector<int>> heightMap3 = {{0,1,0,0,0},{0,2,1,0,0},{0,0,2,1,1},{1,1,1,2,1},{1,1,1,2,1}};\n    cout << \"Test case 3: \" << solution.trapRainWater(heightMap3) << endl;\n\n    return 0;\n}\n```",
  "408": "```\n#include <iostream>\n#include <string>\n\nbool validWordAbbreviation(std::string word, std::string abbr) {\n    int i = 0, j = 0;\n    while (i < word.length() && j < abbr.length()) {\n        if (!isalpha(word[i])) {\n            i++;\n        } else if (j == 0 || !isdigit(abbr[j]) || tolower(word[i]) != tolower(abbr[j])) {\n            return false;\n        }\n        i++; j++;\n    }\n    return i == word.length() && j == abbr.length();\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << validWordAbbreviation(\"internationalization\", \"i18n\") << std::endl;  // true\n    std::cout << validWordAbbreviation(\"applepenapple\", \"a3e\") << std::endl;  // false\n    std::cout << validWordAbbreviation(\"leetcode\", \"leet2code\") << std::endl;  // false\n    return 0;\n}\n```",
  "409": "```\n#include <iostream>\n#include <string>\n\nint longestPalindrome(std::string s) {\n    int n = s.length();\n    bool dp[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            dp[j][i] = (s[j] == s[i]) && ((i - j < 3) || dp[j + 1][i - 1]);\n        }\n    }\n    int maxLen = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (dp[j][i] && i - j + 1 > maxLen) {\n                maxLen = i - j + 1;\n            }\n        }\n    }\n    return maxLen;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << longestPalindrome(\"babad\") << std::endl; // Expected output: 3\n    std::cout << \"Test Case 2: \" << longestPalindrome(\"cbbd\") << std::endl; // Expected output: 2\n    std::cout << \"Test Case 3: \" << longestPalindrome(\"a\") << std::endl; // Expected output: 1\n    \n    return 0;\n}\n```",
  "410": "```\n#include <iostream>\n#include <vector>\n\nint maxUncrossedLines(std::vector<int>& nums1, std::vector<int>& nums2) {\n    int m = nums1.size(), n = nums2.size();\n    int res = 0;\n    int i = 0, j = 0;\n    \n    while (i < m && j < n) {\n        if (nums1[i] > nums2[j]) {\n            res++;\n            i++;\n        } else if (nums1[i] < nums2[j]) {\n            res++;\n            j++;\n        } else {\n            res++;\n            i++;\n            j++;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 3};\n    std::vector<int> nums2 = {2};\n    std::cout << \"Test Case 1: \" << maxUncrossedLines(nums1, nums2) << std::endl;\n\n    nums1 = {1, 4, 10, 11, 1};\n    nums2 = {1, 4, 10, 10, 1};\n    std::cout << \"Test Case 2: \" << maxUncrossedLines(nums1, nums2) << std::endl;\n\n    nums1 = {1, 3, 7};\n    nums2 = {1, 2, 3};\n    std::cout << \"Test Case 3: \" << maxUncrossedLines(nums1, nums2) << std::endl;\n    \n    return 0;\n}\n```",
  "412": "```\n#include <iostream>\nusing namespace std;\n\nvoid fizzBuzz(int n) {\n    for (int i = 1; i <= n; i++) {\n        if (i % 3 == 0 && i % 5 == 0)\n            cout << \"FizzBuzz\";\n        else if (i % 3 == 0)\n            cout << \"Fizz\";\n        else if (i % 5 == 0)\n            cout << \"Buzz\";\n        else\n            cout << i;\n        cout << endl;\n    }\n}\n\nint main() {\n    int n1 = 15;\n    int n2 = 30;\n    int n3 = 10;\n\n    cout << \"Test case 1 for \" << n1 << \": \";\n    fizzBuzz(n1);\n    cout << endl;\n\n    cout << \"Test case 2 for \" << n2 << \": \";\n    fizzBuzz(n2);\n    cout << endl;\n\n    cout << \"Test case 3 for \" << n3 << \": \";\n    fizzBuzz(n3);\n\n    return 0;\n}\n```",
  "411": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string minimumUniqueAbbreviation(vector<string>& words) {\n        int n = words.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (words[i].length() <= j || words[j].length() <= i) continue;\n                \n                int diff = 0;\n                for (int k = 0; k < min(i, j); ++k) {\n                    if (words[i][k] != words[j][k]) {\n                        diff++;\n                        break;\n                    }\n                }\n                \n                dp[i][j] = diff + 1;\n            }\n        }\n        \n        int ans = n;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i+1; j < n; ++j) {\n                if ((dp[i][j] & (dp[i][j]-1)) == 0) ans = min(ans, dp[i][j]);\n            }\n        }\n        \n        string res;\n        int k = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i+1; j < n; ++j) {\n                if ((dp[i][j] & (dp[i][j]-1)) == 0) {\n                    while (k < dp[i][j]) res.push_back('a');\n                    k++;\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<string> words1 = {\"apple\", \"appliance\"};\n    cout << solution.minimumUniqueAbbreviation(words1) << endl; // Output: 2a\n    \n    vector<string> words2 = {\"word\", \"world\", \"row\"};\n    cout << solution.minimumUniqueAbbreviation(words2) << endl; // Output: 4\n    \n    vector<string> words3 = {\"like\", \"love\", \"liked\", \"lived\"};\n    cout << solution.minimumUniqueAbbreviation(words3) << endl; // Output: 1a\n    \n    return 0;\n}\n```",
  "413": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numberOfArithmeticSlices(vector<int>& A) {\n        if(A.size() < 3)\n            return 0;\n        int res = 0, cur = 0;\n        for(int i=2; i<A.size(); i++) {\n            if(A[i] - A[i-1] == A[i-1] - A[i-2]) \n                cur++;\n            else\n                cur = 0;\n            res += cur;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<int> test1 = {3, 5, 6, 7};\n    cout << \"Test case 1: \" << sol.numberOfArithmeticSlices(test1) << endl;\n\n    vector<int> test2 = {1, 2, 3, 4, 5};\n    cout << \"Test case 2: \" << sol.numberOfArithmeticSlices(test2) << endl;\n\n    vector<int> test3 = {1};\n    cout << \"Test case 3: \" << sol.numberOfArithmeticSlices(test3) << endl;\n    return 0;\n}\n```",
  "414": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint thirdMax(std::vector<int>& nums) {\n    std::set<int> s(nums.begin(), nums.end());\n    \n    if (s.size() < 3) {\n        return *(s.rbegin());\n    }\n    \n    auto it = --s.rbegin();\n    ++it;\n    return *it;\n}\n\nint main() {\n    int result1 = thirdMax({3,2,1});\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    int result2 = thirdMax({1,2});\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    int result3 = thirdMax({1,2,3});\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n}\n```",
  "415": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string addStrings(std::string num1, std::string num2) {\n        int i = num1.size() - 1;\n        int j = num2.size() - 1;\n        int carry = 0;\n        std::string result;\n\n        while (i >= 0 || j >= 0 || carry) {\n            int sum = (i >= 0 ? num1[i--] - '0' : 0) + (j >= 0 ? num2[j--] - '0' : 0) + carry;\n            carry = sum / 10;\n            result.push_back('0' + sum % 10);\n        }\n\n        std::reverse(result.begin(), result.end());\n        return result.empty() ? \"0\" : result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    std::cout << solution.addStrings(\"123\", \"456\") << std::endl;  // Output: 579\n\n    // Test case 2:\n    std::cout << solution.addStrings(\"0\", \"0\") << std::endl;      // Output: 0\n\n    // Test case 3:\n    std::cout << solution.addStrings(\"9\", \"99\") << std::endl;     // Output: 108\n\n    return 0;\n}\n```",
  "416": "```\n#include <iostream>\n#include <vector>\n\nbool canPartition(std::vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) {\n        sum += num;\n    }\n    \n    if (sum % 2 != 0) {\n        return false;\n    }\n    \n    int target = sum / 2;\n    bool dp[10001] = {false};\n    dp[0] = true;\n    \n    for (int num : nums) {\n        for (int i = target; i >= num; --i) {\n            if (!dp[i - num]) {\n                dp[i] = true;\n            }\n        }\n    }\n    \n    return dp[target];\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 5, 5};\n    std::cout << canPartition(nums1) << std::endl; // Expected: true\n    \n    std::vector<int> nums2 = {5};\n    std::cout << canPartition(nums2) << std::endl; // Expected: false\n    \n    std::vector<int> nums3 = {1, 2, 5};\n    std::cout << canPartition(nums3) << std::endl; // Expected: true\n    \n    return 0;\n}",
  "418": "```\n#include <iostream>\n#include <vector>\n\nint maxNumberWords(std::vector<std::string>& sentences, int nRows) {\n    int rows = nRows;\n    int cols = sentences[0].size();\n    \n    std::vector<std::string> result(rows, std::string(cols, ' '));\n    for (int i = 0; i < rows; i++) {\n        if (i >= sentences.size() || i % (rows + 1) > 1) continue;\n        int j = 0;\n        while (j < cols && i * (j + 1) / (i + 1) < sentences[i % (rows + 1)].size()) {\n            result[i][j++] = sentences[i % (rows + 1)][i * (j + 1) / (i + 1)];\n        }\n    }\n\n    int maxWords = 0;\n    for (const auto& sentence : sentences) {\n        int words = 0;\n        for (int i = 0; i < sentence.size(); i++) {\n            if (sentence[i] == ' ') words++;\n        }\n        words++;\n        maxWords = std::max(maxWords, words);\n    }\n\n    return maxWords * rows + 1;\n}\n\nint main() {\n    int nRows = 3;\n    std::vector<std::string> sentences = {\"this\", \"is\", \"an\", \"example\"};\n    std::cout << maxNumberWords(sentences, nRows) << std::endl; // Output: 12\n\n    nRows = 4;\n    sentences = {\"the\", \"quick\", \"brown\", \"fox\", \"jumped\", \"over\", \"the\", \"lazy\", \"dog\"};\n    std::cout << maxNumberWords(sentences, nRows) << std::endl; // Output: 15\n\n    nRows = 2;\n    sentences = {\"hello\", \"hi\", \"world\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"};\n    std::cout << maxNumberWords(sentences, nRows) << std::endl; // Output: 11\n    return 0;\n}\n```",
  "417": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        if (m == 0) return {};\n\n        int n = matrix[0].size();\n        vector<vector<bool>> pacific(m, vector<bool>(n, false));\n        vector<vector<bool>> atlantic(m, vector<bool>(n, false));\n\n        for (int i = 0; i < m; i++) {\n            dfs(matrix, i, 0, pacific);\n            dfs(matrix, i, n - 1, atlantic);\n        }\n        for (int j = 0; j < n; j++) {\n            dfs(matrix, 0, j, pacific);\n            dfs(matrix, m - 1, j, atlantic);\n        }\n\n        vector<vector<int>> result;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (pacific[i][j] && atlantic[i][j]) {\n                    result.push_back({i, j});\n                }\n            }\n        }\n\n        return result;\n    }\n\n    void dfs(vector<vector<int>>& matrix, int i, int j, vector<vector<bool>>& visited) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j]) return;\n\n        visited[i][j] = true;\n\n        if (i > 0 && matrix[i - 1][j] <= matrix[i][j]) dfs(matrix, i - 1, j, visited);\n        if (i < m - 1 && matrix[i + 1][j] <= matrix[i][j]) dfs(matrix, i + 1, j, visited);\n        if (j > 0 && matrix[i][j - 1] <= matrix[i][j]) dfs(matrix, i, j - 1, visited);\n        if (j < n - 1 && matrix[i][j + 1] <= matrix[i][j]) dfs(matrix, i, j + 1, visited);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> matrix1 = {{1,2,2,3,5},{3,2,3,4,5},{1,1,1,2,3},{4,4,4,2,3}};\n\n    for (auto cell : solution.pacificAtlantic(matrix1)) {\n        cout << \"(\" << cell[0] << \", \" << cell[1] << \") \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<vector<int>> matrix2 = {{1},{2}};\n\n    for (auto cell : solution.pacificAtlantic(matrix2)) {\n        cout << \"(\" << cell[0] << \", \" << cell[1] << \") \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<vector<int>> matrix3 = {{1,2},{4,5}};\n\n    for (auto cell : solution.pacificAtlantic(matrix3)) {\n        cout << \"(\" << cell[0] << \", \" << cell[1] << \") \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "419": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countBattleships(vector<vector<char>>& board) {\n        if (board.empty()) return 0;\n        \n        int res = 0;\n        for (int i = 0; i < board.size(); ++i) {\n            for (int j = 0; j < board[0].size(); ++j) {\n                if (board[i][j] == 'X') {\n                    if ((i > 0 && board[i - 1][j] != 'X') ||\n                        (j > 0 && board[i][j - 1] != 'X')) continue;\n                    res++;\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<char>> board1 = {{'.' , '.' , '.' , '.' },\n                                    {'.' , '.' , 'X' , '.' },\n                                    {'.' , '.' , 'X' , '.' },\n                                    {'.', '.', 'X', '.'}};\n    cout << \"Test Case 1: \" << solution.countBattleships(board1) << endl;\n\n    // Test case 2\n    vector<vector<char>> board2 = {{'.' , '.' , '.' , '.' , '.'},\n                                    {'.' , '.' , 'X' , 'X' , '.' },\n                                    {'.', '.', 'X', 'X', '.'},\n                                    {'.', '.', 'X', 'X', '.'}};\n    cout << \"Test Case 2: \" << solution.countBattleships(board2) << endl;\n\n    // Test case 3\n    vector<vector<char>> board3 = {{'.' , '.' , '.' , '.' , '.' , '.'},\n                                    {'.' , '.' , '.' , 'X' , '.' , '.' },\n                                    {'.', '.', '.', 'X', '.', '.'},\n                                    {'.', '.', '.', 'X', '.', '.'}};\n    cout << \"Test Case 3: \" << solution.countBattleships(board3) << endl;\n\n    return 0;\n}\n```",
  "420": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int strongPasswordChecker(string s) {\n        if (s.length() < 6) return s.length();\n        int missingLower = 0, missingUpper = 0;\n        for (char c : s) {\n            if (islower(c)) missingLower = 1;\n            else if (isupper(c)) missingUpper = 1;\n        }\n        if (missingLower && missingUpper) return min(max(6 - (int)s.length(), 0), (int)(s.length() - missingUpper + missingLower));\n        int count = 0, tempCount = 0;\n        for (char c : s) {\n            if (isalnum(c)) tempCount++;\n            if (!isalnum(c) && tempCount > 3) {\n                tempCount = 1;\n                count++;\n            }\n        }\n        return min(max(6 - s.length(), 0), count);\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.strongPasswordChecker(\"a\") << endl;  // Expected: 5\n    cout << solution.strongPasswordChecker(\"aA1\") << endl;  // Expected: 4\n    cout << solution.strongPasswordChecker(\"aA12!3?123456789\") << endl;  // Expected: 0\n    return 0;\n}\n```",
  "421": "```\n#include <iostream>\n#include <vector>\n\nclass TrieNode {\npublic:\n    int val;\n    TrieNode* left = nullptr;\n    TrieNode* right = nullptr;\n\n    TrieNode(int val) : val(val) {}\n};\n\nclass Trie {\npublic:\n    TrieNode* root = new TrieNode(0);\n\n    void insert(int num) {\n        TrieNode* node = &root;\n        for (int i = 31; i >= 0; --i) {\n            int bit = ((num >> i) & 1);\n            if (!node->left && bit == 0 || !node->right && bit == 1) {\n                node->val ^= 1 << i;\n                node->left = new TrieNode(0), node->right = new TrieNode(0);\n            }\n            node = bit ? node->right : node->left;\n        }\n    }\n\n    int query(int num) {\n        TrieNode* node = &root;\n        int res = 0;\n        for (int i = 31; i >= 0; --i) {\n            int bit = ((num >> i) & 1);\n            if (!node->left || !node->right) {\n                res |= node->val << i;\n                return res;\n            }\n            node = bit ? node->right : node->left;\n        }\n        return res;\n    }\n};\n\nint findMaximumXOR(std::vector<int>& nums) {\n    Trie trie;\n    int max_xor = 0;\n    for (int num : nums) {\n        max_xor = std::max(max_xor, num ^ trie.query(num));\n        trie.insert(num);\n    }\n    return max_xor;\n}\n\nint main() {\n    std::cout << findMaximumXOR({14,7,1,0}) << \"\\n\";\n    std::cout << findMaximumXOR({3,5,2,6}) << \"\\n\";\n    std::cout << findMaximumXOR({10,20,30,40,50}) << \"\\n\";\n}\n```",
  "422": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool isValidSudoku(std::vector<std::vector<char>>& board) {\n    int n = board.size();\n    for (int i = 0; i < n; i++) {\n        std::vector<bool> row(n, false);\n        std::vector<bool> col(n, false);\n        for (int j = 0; j < n; j++) {\n            if (board[i][j] != '.') {\n                int num = board[i][j] - '1';\n                if (row[num]) return false;\n                row[num] = true;\n            }\n            if (board[j][i] != '.') {\n                int num = board[j][i] - '1';\n                if (col[num]) return false;\n                col[num] = true;\n            }\n        }\n    }\n    for (int i = 0; i < n/3; i++) {\n        for (int j = 0; j < n/3; j++) {\n            std::vector<bool> box(n/3, false);\n            for (int k = 0; k < 3; k++) {\n                for (int l = 0; l < 3; l++) {\n                    int num = board[i*3+k][j*3+l] - '1';\n                    if (board[i*3+k][j*3+l] != '.') {\n                        if (box[num]) return false;\n                        box[num] = true;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<std::vector<char>> board1{{'5','6','.','.','.'},\n                                            {'3','.','.','8','.'},\n                                            {'...','9','8','.','.'},\n                                            '{.}','.','.','.','.'},\n                                            {'.','.','.','2','.'}};\n    std::cout << (isValidSudoku(board1) ? \"true\" : \"false\") << std::endl;\n\n    std::vector<std::vector<char>> board2{{'1','1','.','.','4'},\n                                            {'.','.','2','.','3'},\n                                            {'.','.','.','.','.'},\n                                            {'.','.','.','.','.'},\n                                            {'.','.','.','.','.'}};\n    std::cout << (isValidSudoku(board2) ? \"true\" : \"false\") << std::endl;\n\n    std::vector<std::vector<char>> board3{{'8','.','.','.','.'},\n                                            {'.','3','.','.','.'},\n                                            {'.','.','.10','.,'},\n                                            {'.','9','.','.','.'},\n                                            {'.','.','.','6','.'}};\n    std::cout << (isValidSudoku(board3) ? \"true\" : \"false\") << std::endl;\n\n    return 0;\n}\n```",
  "423": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string originalDigits(int n) {\n        int ones = count('1', n);\n        int threes = count('3', n);\n        int fours = count('4', n);\n        int fives = count('5', n);\n        int sixes = count('6', n);\n        int sevens = count('7', n);\n        int eights = count('8', n);\n        int nines = count('9', n);\n\n        vector<string> counts(10);\n        counts[0] = ones + threes + fours + fives + sixes + seven;\n        counts[1] = ones;\n        counts[2] = zero - (ones + threes) - four - (six + eight);\n        counts[3] = threes;\n        counts[4] = fours;\n        counts[5] = five;\n        counts[6] = six;\n        counts[7] = seven;\n        counts[8] = eight;\n        counts[9] = nine;\n\n        string result = \"\";\n        for (int i = 0; i < 10; i++) {\n            if (counts[i].size() > 0) {\n                int n = counts[i][0] - '0';\n                while (n--) {\n                    result += char('0' + i);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    int count(char c, int n) {\n        int count = 0;\n        for (int i = 0; i <= n; i++) {\n            string s = to_string(i);\n            if (s.find(c) != string::npos) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.originalDigits(123) << endl; // Output: 156\n    cout << solution.originalDigits(911) << endl; // Output: 9911\n    cout << solution.originalDigits(2020) << endl; // Output: 2016\n\n    return 0;\n}\n```",
  "424": "```\n#include <iostream>\n#include <string>\n\nint characterReplacement(std::string s, int k) {\n    int n = s.size();\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        int j = i;\n        while (j < n && s[j] == s[i]) j++;\n        int count = j - i;\n        if (count > ans) ans = count;\n        if (k >= count) k -= count;\n        else break;\n    }\n    return ans;\n}\n\nint main() {\n    std::cout << characterReplacement(\"ABABBA\", 1) << std::endl; // Output: 2\n    std::cout << characterReplacement(\"AAABBBCCCAAAA\", 0) << std::endl; // Output: 5\n    std::cout << characterReplacement(\"A\", 100) << std::endl; // Output: 1\n    return 0;\n}",
  "426": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    Node* treeToDoublyList(TreeNode* root) {\n        if (root == NULL) return NULL;\n\n        TreeNode* prev = NULL;\n        TreeNode* curr = root;\n        while (curr != NULL) {\n            if (curr->right == NULL) {\n                if (prev != NULL) {\n                    prev->right = curr;\n                    curr->left = prev;\n                    prev = curr;\n                } else {\n                    prev = curr;\n                }\n                curr = curr->left;\n            } else {\n                TreeNode* next = curr->right;\n                curr->right = curr->right->left;\n                if (curr->right != NULL) {\n                    next->left = curr;\n                }\n                curr = next;\n            }\n        }\n\n        return prev;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(4);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(5);\n    root1->left->left = new TreeNode(1);\n    root1->left->right = new TreeNode(3);\n\n    Node* result1 = s.treeToDoublyList(root1);\n    cout << \"Test case 1: \";\n    // Print the result here\n    cout << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->right = new TreeNode(4);\n    root2->right->left = new TreeNode(3);\n    root2->right->right = new TreeNode(5);\n\n    Node* result2 = s.treeToDoublyList(root2);\n    cout << \"Test case 2: \";\n    // Print the result here\n    cout << endl;\n\n    // Test case 3\n    TreeNode* root3 = NULL; // Empty tree\n\n    Node* result3 = s.treeToDoublyList(root3);\n    cout << \"Test case 3: \";\n    // Print the result here\n    cout << endl;\n\n    return 0;\n}\n```",
  "425": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> wordSquares(vector<vector<string>>& words) {\n        int n = words.size();\n        string prefix = \"\";\n        vector<vector<string>> result;\n        for (int i = 0; i < n; ++i) {\n            if (!result.empty() && result[0].size() == i + 1) {\n                prefix = result[0][i];\n            }\n            TrieNode* root = new TrieNode();\n            for (const auto& word : words) {\n                TrieNode* node = root;\n                for (int j = 0; j <= i; ++j) {\n                    char c = tolower(word[j][0]);\n                    if (!node->children.count(c)) {\n                        node->children[c] = new TrieNode();\n                    }\n                    node = node->children[c];\n                }\n            }\n            vector<vector<string>> temp;\n            backtrack(root, prefix, i + 1, words, temp);\n            result.push_back(temp);\n        }\n        for (auto& row : result) {\n            for (int j = 0; j < row.size(); ++j) {\n                for (int k = 0; k < row[j].size(); ++k) {\n                    cout << row[j][k] << \" \";\n                }\n                cout << endl;\n            }\n        }\n        return result;\n    }\n\nprivate:\n    struct TrieNode {\n        unordered_map<char, TrieNode*> children;\n    };\n\n    void backtrack(TrieNode* root, string prefix, int n, vector<vector<string>>& words, vector<vector<string>>& temp) {\n        if (temp.size() == n) {\n            vector<string> row;\n            for (const auto& word : temp) {\n                row.push_back(word[0]);\n            }\n            result.push_back(row);\n            return;\n        }\n        for (char c = 'a'; c <= 'z'; ++c) {\n            if (root->children.count(c)) {\n                TrieNode* node = root->children[c];\n                vector<string> tempRow;\n                tempRow.push_back(word);\n                temp.push_back(tempRow);\n                backtrack(node, prefix + c, n, words, temp);\n                if (!temp.empty()) {\n                    temp.pop_back();\n                }\n            }\n        }\n    }\n\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> words1 = {{\"a\"}, {\"b\"}, {\"c\"}};\n    solution.wordSquares(words1);\n\n    // Test Case 2\n    vector<vector<string>> words2 = {{\"abcd\"}, {\"abcde\"}, {\"abf\" }};\n    solution.wordSquares(words2);\n\n    // Test Case 3\n    vector<vector<string>> words3 = {{\"example\", \"apple\", \"banana\"}};\n    solution.wordSquares(words3);\n\n    return 0;\n}\n```",
  "428": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\n// Definition for an N-ary tree node.\nstruct Node {\n    int val;\n    vector<Node*> children;\n};\n\nclass Codec {\npublic:\n    // Encodes an N-ary tree to a string.\n    string serialize(Node* root) {\n        if (root == nullptr)\n            return \"null\";\n        \n        string res = to_string(root->val);\n        for (auto child : root->children) {\n            res += \",\" + serialize(child);\n        }\n        return res;\n    }\n\n    // Decodes your encoded data, version 1.\n    Node* deserialize(string data) {\n        if (data == \"null\")\n            return nullptr;\n\n        int val = stoi(data.substr(0, data.find(',')));\n        Node* root = new Node();\n        root->val = val;\n        string remainder = data.substr(data.find(',') + 1);\n        vector<string> children;\n        while (!remainder.empty()) {\n            size_t pos = remainder.find(',');\n            if (pos == string::npos)\n                break;\n            children.push_back(remainder.substr(0, pos));\n            remainder.erase(0, pos + 1);\n        }\n        for (auto child : children) {\n            root->children.push_back(deserialize(child));\n        }\n\n        return root;\n    }\n};\n\nint main() {\n    Codec codec;\n\n    // Test case 1\n    Node* root = new Node();\n    root->val = 1;\n    root->children.push_back(new Node());\n    root->children[0]->val = 3;\n    root->children[0]->children.push_back(new Node());\n    root->children[0]->children[0]->val = 5;\n\n    string serializedRoot = codec.serialize(root);\n    cout << \"Serialized: \" << serializedRoot << endl;\n\n    Node* deserializedRoot = codec.deserialize(serializedRoot);\n\n    // Test case 2\n    root = new Node();\n    root->val = 1;\n    root->children.push_back(new Node());\n    root->children[0]->val = 2;\n\n    serializedRoot = codec.serialize(root);\n    cout << \"Serialized: \" << serializedRoot << endl;\n\n    deserializedRoot = codec.deserialize(serializedRoot);\n\n    // Test case 3\n    root = new Node();\n    root->val = 1;\n    root->children.push_back(new Node());\n    root->children[0]->val = 2;\n    root->children[0]->children.push_back(new Node());\n    root->children[0]->children[0]->val = 4;\n\n    serializedRoot = codec.serialize(root);\n    cout << \"Serialized: \" << serializedRoot << endl;\n\n    deserializedRoot = codec.deserialize(serializedRoot);\n\n    return 0;\n}\n\n```",
  "427": "```\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    bool isLeaf;\n    vector<Node*> children;\n\n    Node(int _val) : val(_val), isLeaf(true) {}\n};\n\nclass QuadTree {\npublic:\n    Node* root;\n\n    void construct(vector<vector<int>>& grid) {\n        root = new Node(0);\n        buildTree(root, 0, 0, grid.size());\n    }\n\nprivate:\n    void buildTree(Node* node, int x, int y, int size) {\n        if (size <= 3 && !isFull(node->val, &grid[x][y], size)) {\n            node->isLeaf = true;\n            return;\n        }\n        node->children.resize(4);\n        for (int i = 0; i < 4; ++i) {\n            Node* child = new Node(node->val + 1);\n            buildTree(child, x + i / 2 * (size >> 1), y + i % 2 * (size >> 1), size >> 1);\n            node->children[i] = child;\n        }\n    }\n\n    bool isFull(int val, vector<int>* grid, int size) {\n        for (int i = 0; i < size; ++i) {\n            for (int j = 0; j < size; ++j) {\n                if ((grid[i][j] & 1) == 1 && val == 0 || (grid[i][j] & 2) == 2 && val != 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    QuadTree qt;\n    vector<vector<int>> grid1 = {{1,0,0,1},{0,0,1,0},{0,0,0,1},{1,1,1,1}};\n    qt.construct(grid1);\n    \n    vector<vector<int>> grid2 = {{1,1,1,1},{1,1,0,1},{0,1,0,0},{1,1,1,1}};\n    qt.construct(grid2);\n\n    vector<vector<int>> grid3 = {{1,0,0,0},{1,0,1,1},{0,1,0,1},{0,1,0,1}};\n    qt.construct(grid3);\n    \n    return 0;\n}\n```",
  "429": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    vector<Node*> children;\n};\n\nvoid levelOrder(Node* root, vector<vector<int>>& result) {\n    if (!root) return;\n\n    queue<pair<Node*, int>> q;\n    q.push({root, 0});\n\n    while (!q.empty()) {\n        auto [node, level] = q.front();\n        q.pop();\n\n        if (result.size() <= level)\n            result.push_back(vector<int>());\n\n        result[level].push_back(node->val);\n\n        for (auto child : node->children) {\n            q.push({child, level + 1});\n        }\n    }\n}\n\nint main() {\n    Node* root = new Node();\n    root->val = 1;\n    root->children = {new Node(), new Node(), new Node()};\n    root->children[0]->val = 3;\n    root->children[0]->children.push_back(new Node());\n    root->children[0]->children[0]->val = 5;\n    root->children[1]->val = 2;\n    root->children[2]->val = 4;\n\n    vector<vector<int>> result;\n    levelOrder(root, result);\n\n    for (int i = 0; i < result.size(); i++) {\n        cout << \"Level \" << i << \": \";\n        for (int j : result[i])\n            cout << j << \" \";\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "430": "```\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node* prev;\n    Node* next;\n};\n\nclass Solution {\npublic:\n    Node* flatten(Node* head) {\n        if (!head) return NULL;\n        Node* curr = head;\n        \n        while (curr && curr->next) {\n            curr = curr->next;\n        }\n        \n        if (curr && curr->next) {\n            Node* node = curr->next;\n            curr->next = NULL;\n            curr->prev->next = node;\n            node->prev = curr->prev;\n            return head;\n        } else {\n            return head;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    Node* head1 = new Node();\n    head1->val = 1;\n    head1->prev = NULL;\n    head1->next = new Node();\n    head1->next->val = 2;\n    head1->next->prev = head1;\n    head1->next->next = NULL;\n    \n    cout << \"Test case 1: \";\n    head1 = solution.flatten(head1);\n    while (head1) {\n        cout << head1->val << \" \";\n        head1 = head1->next;\n    }\n    cout << endl;\n    \n    // Test case 2\n    Node* head2 = new Node();\n    head2->val = 1;\n    head2->prev = NULL;\n    head2->next = new Node();\n    head2->next->val = 2;\n    head2->next->prev = head2;\n    head2->next->next = new Node();\n    head2->next->next->val = 3;\n    head2->next->next->prev = head2->next;\n    head2->next->next->next = NULL;\n    \n    cout << \"Test case 2: \";\n    head2 = solution.flatten(head2);\n    while (head2) {\n        cout << head2->val << \" \";\n        head2 = head2->next;\n    }\n    cout << endl;\n    \n    // Test case 3\n    Node* head3 = new Node();\n    head3->val = 1;\n    head3->prev = NULL;\n    head3->next = new Node();\n    head3->next->val = 2;\n    head3->next->prev = head3;\n    head3->next->next = new Node();\n    head3->next->next->val = 3;\n    head3->next->next->prev = head3->next;\n    head3->next->next->next = new Node();\n    head3->next->next->next->val = 4;\n    head3->next->next->next->prev = head3->next->next;\n    \n    cout << \"Test case 3: \";\n    head3 = solution.flatten(head3);\n    while (head3) {\n        cout << head3->val << \" \";\n        head3 = head3->next;\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "431": "```\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node(int _val) : val(_val) {}\n};\n\nvoid dfs(Node* root, string& str) {\n    if (root == nullptr)\n        return;\n\n    str += to_string(root->val);\n    for (Node* child : root->children) {\n        dfs(child, str);\n        str.append(\"0\");\n    }\n}\n\nstring tree2str(Node* t) {\n    if (t == nullptr)\n        return \"\";\n\n    string res;\n    dfs(t, res);\n\n    int pos = 0;\n    while (pos < res.length() && res[pos] == '0')\n        pos++;\n\n    res = res.substr(0, pos);\n\n    return res;\n}\n\nint main() {\n    Node* root1 = new Node(1);\n    root1->children.push_back(new Node(2));\n    root1->children.push_back(new Node(3));\n    root1->children.push_back(new Node(4));\n    root1->children.push_back(new Node(5));\n\n    Node* root2 = new Node(1);\n    root2->children.push_back(new Node(2));\n    root2->children[0]->children.push_back(new Node(3));\n    root2->children[0]->children.push_back(new Node(4));\n    root2->children[0]->children.push_back(new Node(5));\n\n    Node* root3 = new Node(1);\n    root3->children.push_back(new Node(2));\n    root3->children[0]->children.push_back(new Node(3));\n    root3->children[0]->children[0]->children.push_back(new Node(4));\n    root3->children[0]->children[0]->children.push_back(new Node(5));\n\n    cout << \"Test case 1: \" << tree2str(root1) << endl;\n    cout << \"Test case 2: \" << tree2str(root2) << endl;\n    cout << \"Test case 3: \" << tree2str(root3) << endl;\n\n    return 0;\n}\n```",
  "432": "```\n#include <iostream>\n#include <list>\n\nusing namespace std;\n\nclass AllOne {\npublic:\n    unordered_map<int, list<pair<int, int>>> m;\n    list<pair<int, int>> maxFreqList;\n    list<pair<int, int>> minFreqList;\n\n    void inc(int key) {\n        if (m.find(key) == m.end()) {\n            m[key] = list<pair<int, int>>();\n        }\n        pair<int, int> node = make_pair(key, 1);\n        m[key].push_back(node);\n        eraseNode(minFreqList, key);\n    }\n\n    void dec(int key) {\n        if (m.find(key) == m.end()) return;\n        pair<int, int> last = *--m[key].end();\n        if (last.second > 1) {\n            --last.second;\n            m[key].push_back(last);\n        } else {\n            eraseNode(m[key], key);\n            if (m[key].empty()) m.erase(key);\n            eraseNode(minFreqList, key);\n        }\n    }\n\n    int getMaxKey() {\n        return !maxFreqList.empty() ? maxFreqList.front().first : -1;\n    }\n\n    int getMinKey() {\n        return !minFreqList.empty() ? minFreqList.front().first : -1;\n    }\n\n    void updateMaxMinLists() {\n        maxFreqList.clear();\n        minFreqList.clear();\n        for (auto &p : m) {\n            for (auto &q : p.second) {\n                if (maxFreqList.empty()) {\n                    maxFreqList.push_back(q);\n                    minFreqList.push_front(q);\n                } else {\n                    auto it = find_if(maxFreqList.begin(), maxFreqList.end(),\n                                       [q](pair<int, int> x) { return q.first == x.first; });\n                    if (it != maxFreqList.end()) {\n                        if (q.second > (*it).second) {\n                            *it = q;\n                        } else if (q.second < (*it).second) {\n                            maxFreqList.erase(it);\n                            maxFreqList.push_back(q);\n                        }\n                    } else {\n                        if (q.second > (*maxFreqList.rbegin()).second)\n                            maxFreqList.push_front(q);\n                        else\n                            maxFreqList.push_back(q);\n                    }\n\n                    it = find_if(minFreqList.begin(), minFreqList.end(),\n                                 [q](pair<int, int> x) { return q.first == x.first; });\n                    if (it != minFreqList.end()) {\n                        if (q.second < (*it).second) {\n                            *it = q;\n                        } else if (q.second > (*it).second) {\n                            minFreqList.erase(it);\n                            minFreqList.push_front(q);\n                        }\n                    } else {\n                        if (q.second < (*minFreqList.rbegin()).second)\n                            minFreqList.push_front(q);\n                        else\n                            minFreqList.push_back(q);\n                    }\n                }\n            }\n        }\n    }\n\n    void eraseNode(list<pair<int, int>> &lst, int key) {\n        auto it = find_if(lst.begin(), lst.end(),\n                           [key](pair<int, int> x) { return x.first == key; });\n        if (it != lst.end()) {\n            lst.erase(it);\n            updateMaxMinLists();\n        }\n    }\n\n};\n\nint main() {\n    AllOne obj;\n    obj.inc(1);\n    cout << \"Get Max Key: \" << obj.getMaxKey() << endl;\n    cout << \"Get Min Key: \" << obj.getMinKey() << endl;\n\n    obj.dec(1);\n    cout << \"Get Max Key: \" << obj.getMaxKey() << endl;\n    cout << \"Get Min Key: \" << obj.getMinKey() << endl;\n\n    obj.inc(2);\n    obj.inc(3);\n    obj.dec(2);\n    cout << \"Get Max Key: \" << obj.getMaxKey() << endl;\n    cout << \"Get Min Key: \" << obj.getMinKey() << endl;\n\n    return 0;\n}\n```",
  "433": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMutation(string start, string end, vector<string>& bank) {\n        queue<pair<string, vector<char>>> q;\n        unordered_set<string> seen;\n        unordered_set<string> dictionary(bank.begin(), bank.end());\n        \n        if (dictionary.find(start) == dictionary.end()) return -1;\n        if (dictionary.find(end) == dictionary.end()) return -1;\n        \n        for (int i = 0; i < start.length(); i++) {\n            char c = start[i];\n            string newStr = start;\n            newStr[i] = 'a';\n            \n            q.push({newStr, vector<char>(1, c)});\n            seen.insert(newStr);\n        }\n        \n        int steps = 0;\n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                pair<string, vector<char>> front = q.front();\n                q.pop();\n                \n                string s = front.first;\n                vector<char> path = front.second;\n                \n                if (s == end) return steps;\n                \n                for (int j = 0; j < s.length(); j++) {\n                    char c = s[j];\n                    string newStr = s;\n                    newStr[j] = 'a';\n                    \n                    bool found = false;\n                    for (auto str : dictionary) {\n                        if (str == newStr && !seen.count(str)) {\n                            q.push({newStr, vector<char>(path.begin(), path.end())});\n                            seen.insert(newStr);\n                            found = true;\n                            break;\n                        }\n                    }\n                    \n                    if (!found) continue;\n                    \n                    for (int k = 0; k < s.length(); k++) {\n                        char d = s[k];\n                        string newStr2 = s;\n                        newStr2[k] = 'a';\n                        \n                        bool found2 = false;\n                        for (auto str : dictionary) {\n                            if (str == newStr2 && !seen.count(str)) {\n                                q.push({newStr2, vector<char>(path.begin(), path.end())});\n                                seen.insert(newStr2);\n                                found2 = true;\n                                break;\n                            }\n                        }\n                        \n                        if (!found2) continue;\n                    }\n                }\n            }\n            steps++;\n        }\n        \n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string start1 = \"ACCGGTGA\";\n    string end1 = \"CCGAGTGCA\";\n    vector<string> bank1 = {\"ACCGGTGA\", \"CCTAATTA\", \"CCTAGTTT\", \"CCTAGTGG\", \"CCGAGTGCA\"};\n    cout << solution.minMutation(start1, end1, bank1) << endl;\n\n    // Test case 2\n    string start2 = \"AAA\";\n    string end2 = \"CCC\";\n    vector<string> bank2 = {\"AACCGTT\",\"AACGATT\",\"AAACGTA\",\"CCACGGT\", \"CCACGTB\", \"CCCACTA\"};\n    cout << solution.minMutation(start2, end2, bank2) << endl;\n\n    // Test case 3\n    string start3 = \"AAAA\";\n    string end3 = \"CCC\";\n    vector<string> bank3 = {\"ABBC\",\"AACCC\",\"AAAAGG\", \"AAACGGG\", \"AAAGGGT\"};\n    cout << solution.minMutation(start3, end3, bank3) << endl;\n\n    return 0;\n}\n```",
  "434": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int countSegments(std::string s) {\n        if (s.empty()) return 0;\n        bool found = false;\n        int segments = 0;\n        for (char c : s) {\n            if (c == ' ') {\n                if (!found) {\n                    found = true;\n                    continue;\n                }\n            } else {\n                found = true;\n            }\n            if (c == ' ' || c == '\\0') {\n                segments++;\n                found = false;\n            }\n        }\n        return segments + (s.back() != ' ');\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    std::cout << \"Test case 1: \" << solution.countSegments(\"Hello World\") << std::endl; \n    // Output: 2\n    \n    // Test case 2\n    std::cout << \"Test case 2: \" << solution.countSegments(\"   \") << std::endl;\n    // Output: 0\n    \n    // Test case 3\n    std::cout << \"Test case 3: \" << solution.countSegments(\"\") << std::endl; \n    // Output: 0\n    \n    return 0;\n}\n```",
  "435": "```\n#include <iostream>\n#include <vector>\n\nint eraseOverlapIntervals(std::vector<std::pair<int, int>>& intervals) {\n    if (intervals.empty()) return 0;\n\n    std::sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\n        return a.second - a.first > b.second - b.first;\n    });\n\n    int end = intervals[0].second;\n    int count = 1;\n\n    for (int i = 1; i < intervals.size(); ++i) {\n        if (intervals[i].first >= end) {\n            end = intervals[i].second;\n            ++count;\n        }\n    }\n\n    return intervals.size() - count;\n}\n\nint main() {\n    std::vector<std::pair<int, int>> intervals1 = {{1, 3}, {2, 6}, {8, 10}};\n    std::cout << \"Test case 1: \" << eraseOverlapIntervals(intervals1) << std::endl;\n\n    std::vector<std::pair<int, int>> intervals2 = {{1, 3}, {4, 5}};\n    std::cout << \"Test case 2: \" << eraseOverlapIntervals(intervals2) << std::endl;\n\n    std::vector<std::pair<int, int>> intervals3 = {{1, 2}, {2, 3}};\n    std::cout << \"Test case 3: \" << eraseOverlapIntervals(intervals3) << std::endl;\n}\n```",
  "436": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> findRightInterval(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        for (int i = 0; i < n; i++) {\n            intervals[i].push_back(i);\n        }\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> res;\n        for (const auto& interval : intervals) {\n            int right = lower_bound(intervals.begin() + 1, intervals.end(), (vector<int>) {interval[0], -1}) - intervals.begin();\n            if (right < n) {\n                res.push_back({interval[1], intervals[right][0]});\n            } else {\n                res.push_back({-1, -1});\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> intervals1 = {{3,5},{4,7}};\n    vector<vector<int>> result1 = solution.findRightInterval(intervals1);\n    for (const auto& interval : result1) {\n        cout << \"[\" << interval[0] << \",\" << interval[1] << \"] \" << endl;\n    }\n\n    vector<vector<int>> intervals2 = {{1,4},{7,8}};\n    vector<vector<int>> result2 = solution.findRightInterval(intervals2);\n    for (const auto& interval : result2) {\n        cout << \"[\" << interval[0] << \",\" << interval[1] << \"] \" << endl;\n    }\n\n    vector<vector<int>> intervals3 = {{5,7}};\n    vector<vector<int>> result3 = solution.findRightInterval(intervals3);\n    for (const auto& interval : result3) {\n        cout << \"[\" << interval[0] << \",\" << interval[1] << \"] \" << endl;\n    }\n\n    return 0;\n}\n```",
  "437": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int pathSum(TreeNode* root, int targetSum) {\n        if (!root) return 0;\n        \n        int res = dfs(root, targetSum);\n        res += pathSum(root->left, targetSum);\n        res += pathSum(root->right, targetSum);\n        \n        return res;\n    }\n    \n    int dfs(TreeNode* node, int targetSum) {\n        if (!node) return 0;\n        \n        if (node->val == targetSum) return 1 + dfs(node->left, targetSum) + dfs(node->right, targetSum);\n        \n        return dfs(node->left, targetSum - node->val) + dfs(node->right, targetSum - node->val);\n    }\n};\n\nint main() {\n    Solution s;\n    \n    TreeNode* root = new TreeNode(10);\n    root->left = new TreeNode(5);\n    root->right = new TreeNode(-3);\n    root->left->left = new TreeNode(3);\n    root->left->right = new TreeNode(2);\n    root->right->left = new TreeNode(11);\n    \n    cout << s.pathSum(root, 8) << endl; // Expected output: 3\n    cout << s.pathSum(root, -2) << endl; // Expected output: 1\n    cout << s.pathSum(root, 7) << endl; // Expected output: 2\n    \n    return 0;\n}\n```",
  "438": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findAnagrams(string s, string p) {\n        int n = s.size(), m = p.size();\n        vector<int> sCount(26, 0), pCount(26, 0);\n        \n        for (int i = 0; i < m; i++) {\n            pCount[p[i] - 'a']++;\n        }\n        \n        vector<string> anagrams;\n        for (int i = 0; i <= n - m; i++) {\n            if (i > 0) {\n                for (int j = 0; j < 26; j++) {\n                    sCount[j]--;\n                }\n                int k = i;\n                while (k < i + m) {\n                    sCount[s[k] - 'a']++;\n                    k++;\n                }\n            }\n            \n            if (sCount == pCount) {\n                anagrams.push_back(s.substr(i, m));\n            }\n        }\n        \n        return anagrams;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<string> result1 = solution.findAnagrams(\"cba\", \"aba\");\n    for (const auto &str : result1) {\n        cout << str << endl;\n    }\n    \n    vector<string> result2 = solution.findAnagrams(\"abac\", \"aca\");\n    for (const auto &str : result2) {\n        cout << str << endl;\n    }\n    \n    vector<string> result3 = solution.findAnagrams(\"abcba\", \"abca\");\n    for (const auto &str : result3) {\n        cout << str << endl;\n    }\n    \n    return 0;\n}\n```",
  "439": "```\n#include <iostream>\n#include <string>\n#include <stack>\n\nclass Solution {\npublic:\n    bool parseTernary(std::string s) {\n        stack<char> st;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '?') {\n                st.push(s[i]);\n            } else if (s[i] == ':') {\n                while (!st.empty()) {\n                    st.pop();\n                }\n            } else if (s[i] != 't' && s[i] != 'f') {\n                return false;\n            }\n        }\n        return st.empty();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::cout << \"Test case 1: \" << (solution.parseTernary(\"a?t:b\") ? \"Valid\" : \"Invalid\") << std::endl; \n\n    // Test case 2\n    std::cout << \"Test case 2: \" << (solution.parseTernary(\"0:0,1:?0:1\") ? \"Valid\" : \"Invalid\") << std::endl;\n\n    // Test case 3\n    std::cout << \"Test case 3: \" << (solution.parseTernary(\"a?:b:c\") ? \"Valid\" : \"Invalid\") << std::endl; \n\n    return 0;\n}\n```",
  "441": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int arrangeCoins(int n) {\n        return (long long)n * (n + 1) / 2;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n\n    // Test Case 1\n    int n1 = 5;\n    cout << \"For input: \" << n1 << \", the number of ways to arrange coins is: \" << solution.arrangeCoins(n1) << endl;\n\n    // Test Case 2\n    int n2 = 8;\n    cout << \"For input: \" << n2 << \", the number of ways to arrange coins is: \" << solution.arrangeCoins(n2) << endl;\n\n    // Test Case 3\n    int n3 = 10;\n    cout << \"For input: \" << n3 << \", the number of ways to arrange coins is: \" << solution.arrangeCoins(n3) << endl;\n\n    return 0;\n}\n```",
  "440": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    string kthSmallest(string words[], int n, int k) {\n        vector<string> wordList = {};\n        for(int i=0; i<n; i++) {\n            wordList.push_back(words[i]);\n        }\n        sort(wordList.begin(), wordList.end());\n        return wordList[k-1];\n    }\n};\n\nint main() {\n    Solution s;\n    string words[] = {\"tza\", \"tzac\", \"tzaz\", \"tzar\"};\n    int n = sizeof(words)/sizeof(words[0]);\n    for(int i=1; i<=3; i++) {\n        cout << \"K-th smallest: \" << s.kthSmallest(words, n, i) << endl;\n    }\n    return 0;\n}\n```",
  "442": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> findDuplicates(vector<int>& nums) {\n    vector<int> duplicates;\n    unordered_map<int, int> map;\n    \n    for (int num : nums) {\n        if (map.find(num) != map.end()) {\n            map[num]++;\n        } else {\n            map[num] = 1;\n        }\n    }\n    \n    for (auto& pair : map) {\n        if (pair.second > 1) {\n            duplicates.push_back(pair.first);\n        }\n    }\n    \n    return duplicates;\n}\n\nint main() {\n    vector<int> nums1 = {4,3,2,7,8,9,1};\n    vector<int> nums2 = {1,2,3,5,4,6,7,8,9};\n    vector<int> nums3 = {1};\n\n    cout << \"Test case 1: \";\n    for (int num : findDuplicates(nums1)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test case 2: \";\n    for (int num : findDuplicates(nums2)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test case 3: \";\n    for (int num : findDuplicates(nums3)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "443": "```\n#include <iostream>\n#include <string>\n\nstd::string compress(std::string s) {\n    if (s.empty()) return s;\n    int compressedLength = 0, count = 1;\n    for (int i = 1; i <= s.length(); ++i) {\n        if (i == s.length() || s[i] != s[0]) {\n            compressedLength += 1 + to_string(count).size();\n            count = 1;\n        } else\n            ++count;\n    }\n    std::string compressed = \"\";\n    int j = 0;\n    for (int i = 0; i <= s.length(); ++i) {\n        if (i == s.length() || s[i] != s[0]) {\n            compressed += s[j];\n            for (++j; j < i; ++j)\n                compressed += to_string(count);\n            count = 1;\n        } else\n            ++count;\n    }\n    return compressed;\n}\n\nint main() {\n    std::cout << compress(\"AAABBBCCC\") << std::endl;\n    std::cout << compress(\"abcdefg\") << std::endl;\n    std::cout << compress(\"\") << std::endl;\n}\n```",
  "444": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> sequenceReconstruction(vector<int>& seqSpd, vector<vector<int>>& pairSpd) {\n        unordered_map<int, unordered_set<int>> graph;\n        for (auto& p : pairSpd) {\n            graph[p[0]].insert(p[1]);\n            graph[p[1]].insert(p[0]);\n        }\n        \n        int n = seqSpd.size();\n        vector<string> res(n);\n        fill(res.begin(), res.end(), \" \");\n        \n        queue<int> q;\n        for (int i = 1; i <= n; ++i) {\n            if (!graph[i]) q.push(i);\n        }\n        \n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            for (auto& neighbor : graph[node]) {\n                --graph[neighbor].count(node);\n                if (graph[neighbor].empty()) q.push(neighbor);\n            }\n            res[seqSpd[node] - 1] = to_string(node);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<int> seqSpd1 = {1,3,5};\n    vector<vector<int>> pairSpd1 = {{1,2},{2,3},{3,4}};\n    vector<string> expectedRes1 = {\"1\",\"2\",\"3\",\"4\"};\n    vector<string> result1 = solution.sequenceReconstruction(seqSpd1, pairSpd1);\n    for (int i = 0; i < result1.size(); ++i) {\n        if (result1[i] != expectedRes1[i]) {\n            cout << \"Test case 1 failed.\" << endl;\n            return 1;\n        }\n    }\n    cout << \"Test case 1 passed.\" << endl;\n\n    // Test case 2:\n    vector<int> seqSpd2 = {1,5};\n    vector<vector<int>> pairSpd2 = {{1,2},{3,4}};\n    vector<string> expectedRes2 = {\"1\",\"2\",\" \",\"4\"};\n    vector<string> result2 = solution.sequenceReconstruction(seqSpd2, pairSpd2);\n    for (int i = 0; i < result2.size(); ++i) {\n        if (result2[i] != expectedRes2[i]) {\n            cout << \"Test case 2 failed.\" << endl;\n            return 1;\n        }\n    }\n    cout << \"Test case 2 passed.\" << endl;\n\n    // Test case 3:\n    vector<int> seqSpd3 = {1,4};\n    vector<vector<int>> pairSpd3 = {{1,2},{3,4}};\n    vector<string> expectedRes3 = {\"1\",\"2\",\" \",\"4\"};\n    vector<string> result3 = solution.sequenceReconstruction(seqSpd3, pairSpd3);\n    for (int i = 0; i < result3.size(); ++i) {\n        if (result3[i] != expectedRes3[i]) {\n            cout << \"Test case 3 failed.\" << endl;\n            return 1;\n        }\n    }\n    cout << \"Test case 3 passed.\" << endl;\n\n    return 0;\n}\n```",
  "445": "```\n#include <iostream>\n#include \"ListNode.h\"\n\nvoid printList(ListNode* head) {\n    while (head != nullptr) {\n        std::cout << head->val << \" \";\n        head = head->next;\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    // Test Case 1\n    ListNode* l1 = new ListNode(2);\n    l1->next = new ListNode(4);\n    l1->next->next = new ListNode(3);\n\n    ListNode* r1 = new ListNode(5);\n    r1->next = new ListNode(6);\n    r1->next->next = new ListNode(4);\n\n    ListNode* result1 = addTwoNumbers(l1, r1);\n    printList(result1);  // Output: 7 8 7\n\n    // Test Case 2\n    l1 = new ListNode(0);\n    l1->next = new ListNode(0);\n\n    r1 = new ListNode(0);\n\n    result1 = addTwoNumbers(l1, r1);\n    printList(result1);  // Output: 0 0\n\n    // Test Case 3\n    l1 = new ListNode(9);\n    l1->next = new ListNode(9);\n    l1->next->next = new ListNode(9);\n\n    r1 = new ListNode(1);\n\n    result1 = addTwoNumbers(l1, r1);\n    printList(result1);  // Output: 0 0 0 1\n\n    return 0;\n}\n\nListNode* addTwoNumbers(ListNode* l1, ListNode* r1) {\n    if (l1 == nullptr && r1 == nullptr)\n        return nullptr;\n\n    ListNode* dummy = new ListNode(0);\n    ListNode* current = dummy;\n    int carry = 0;\n\n    while (l1 != nullptr || r1 != nullptr || carry) {\n        int sum = 0;\n        if (l1 != nullptr) {\n            sum += l1->val;\n            l1 = l1->next;\n        }\n        if (r1 != nullptr) {\n            sum += r1->val;\n            r1 = r1->next;\n        }\n\n        sum += carry;\n\n        carry = sum / 10;\n        sum %= 10;\n\n        current->next = new ListNode(sum);\n        current = current->next;\n    }\n\n    return dummy->next;\n}\n```",
  "446": "```\n#include <iostream>\n#include <vector>\n\nint numberOfArithmeticSlices(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<std::vector<long long>> dp(n, std::vector<long long>(n, 0));\n    \n    for (int i = 2; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (nums[i] - nums[j] == nums[i-1] - nums[j]) {\n                dp[j][i] = dp[j][i-1] + 1;\n            }\n        }\n    }\n    \n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            res += dp[i][j];\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {2,3,5,7};\n    std::cout << \"Test case 1: \" << numberOfArithmeticSlices(test1) << std::endl;\n\n    std::vector<int> test2 = {1,2,3,8,8,10};\n    std::cout << \"Test case 2: \" << numberOfArithmeticSlices(test2) << std::endl;\n\n    std::vector<int> test3 = {0,0,0};\n    std::cout << \"Test case 3: \" << numberOfArithmeticSlices(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "447": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint totalNthAppears(vector<vector<int>>& points) {\n    int n = 0;\n    unordered_map<int, int> xMap;\n    for (auto& p : points) {\n        int x = p[0], y = p[1];\n        if (xMap.find(x) == xMap.end()) xMap[x] = 0;\n        xMap[x]++;\n        n += xMap[x] * (xMap[x] - 1);\n    }\n    return n;\n}\n\nint main() {\n    vector<vector<int>> points1 {{0,0}, {1,0}, {-4,-3}};\n    cout << \"Number of Boomerangs in case 1: \" << totalNthAppears(points1) << endl;\n\n    vector<vector<int>> points2 {{1,0}, {2,0}, {5,0}, {-1,2}, {0,5}};\n    cout << \"Number of Boomerangs in case 2: \" << totalNthAppears(points2) << endl;\n\n    vector<vector<int>> points3 {{0,0}, {0,4}, {-8,-10}, {1,1}, {0,0}};\n    cout << \"Number of Boomerangs in case 3: \" << totalNthAppears(points3) << endl;\n    \n    return 0;\n}\n```",
  "448": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> findDisappearedNumbers(std::vector<int>& nums) {\n    std::vector<int> result;\n    for (int i = 0; i < nums.size(); i++) {\n        int index = abs(nums[i]) - 1;\n        nums[index] = -nums[index];\n    }\n    \n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] > 0) {\n            result.push_back(i + 1);\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    std::vector<int> nums1 = {4,3,2,7,8,3,1};\n    std::cout << \"Test case 1: \";\n    for (auto num : findDisappearedNumbers(nums1)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums2 = {1,1};\n    std::cout << \"Test case 2: \";\n    for (auto num : findDisappearedNumbers(nums2)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums3 = {0};\n    std::cout << \"Test case 3: \";\n    for (auto num : findDisappearedNumbers(nums3)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```",
  "449": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Codec {\npublic:\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if (root == NULL) return \"X,\");\n        return to_string(root->val) + \",\" + serialize(root->left) + serialize(root->right);\n    }\n\n    // Decodes your encoded data, returns an account object, and asserts the result is valid\n    TreeNode* deserialize(string data) {\n        int i = 0;\n        return deserializeHelper(&data, i);\n    }\n\nprivate:\n    TreeNode* deserializeHelper(string* data, int& i) {\n        if ((*data)[i] == 'X') {\n            i++;\n            return NULL;\n        }\n        int val = 0;\n        while (i < (*data).size() && isdigit((*data)[i])) {\n            val = val * 10 + (*data)[i] - '0';\n            i++;\n        }\n        TreeNode* root = new TreeNode(val);\n        root->left = deserializeHelper(data, i);\n        root->right = deserializeHelper(data, i);\n        return root;\n    }\n};\n\nint main() {\n    Codec codec;\n\n    // Test Case 1:\n    TreeNode* root1 = new TreeNode(2);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(3);\n    string s1 = codec.serialize(root1);\n    cout << \"Test Case 1: \" << s1 << endl;\n    TreeNode* root11 = codec.deserialize(s1);\n    if (root11 != NULL) {\n        cout << \"Test Case 1 Root Value: \" << root11->val << endl;\n        cout << \"Test Case 1 Left Child Value: \" << (root11->left)->val << endl;\n        cout << \"Test Case 1 Right Child Value: \" << (root11->right)->val << endl;\n    }\n\n    // Test Case 2:\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(6);\n    string s2 = codec.serialize(root2);\n    cout << \"Test Case 2: \" << s2 << endl;\n    TreeNode* root22 = codec.deserialize(s2);\n    if (root22 != NULL) {\n        cout << \"Test Case 2 Root Value: \" << root22->val << endl;\n        cout << \"Test Case 2 Left Child Value: \" << (root22->left)->val << endl;\n        cout << \"Test Case 2 Right Child Value: \" << (root22->right)->val << endl;\n    }\n\n    // Test Case 3:\n    TreeNode* root3 = new TreeNode(1);\n    string s3 = codec.serialize(root3);\n    cout << \"Test Case 3: \" << s3 << endl;\n    TreeNode* root33 = codec.deserialize(s3);\n    if (root33 != NULL) {\n        cout << \"Test Case 3 Root Value: \" << root33->val << endl;\n        cout << \"Test Case 3 Left Child Value: \" << (root33->left)->val << endl;\n        cout << \"Test Case 3 Right Child Value: \" << (root33->right)->val << endl;\n    }\n\n    return 0;\n}",
  "450": "```\n#include <iostream>\n#include \"TreeNode.h\"\n\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (root == nullptr || root->val == key)\n            return deleteNodeHelper(root);\n        root->left = deleteNode(root->left, key);\n        return root;\n    }\n\n    TreeNode* deleteNodeHelper(TreeNode* node) {\n        if (node->right != nullptr)\n            return minNode(node->right);\n        return node->left;\n    }\n\n    TreeNode* minNode(TreeNode* node) {\n        while (node->left != nullptr)\n            node = node->left;\n        return node;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(6);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(4);\n    std::cout << \"Test case 1: \";\n    solution.deleteNode(root1, 3) ? std::cout << \"Success\" : std::cout << \"Failure\";\n    std::cout << std::endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(8);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(10);\n    root2->left->left = new TreeNode(1);\n    root2->left->right = new TreeNode(6);\n    std::cout << \"Test case 2: \";\n    solution.deleteNode(root2, 10) ? std::cout << \"Success\" : std::cout << \"Failure\";\n    std::cout << std::endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(5);\n    std::cout << \"Test case 3: \";\n    solution.deleteNode(root3, 5) ? std::cout << \"Success\" : std::cout << \"Failure\";\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "451": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string frequencySort(string s) {\n        unordered_map<char, int> count;\n        for (char c : s) {\n            ++count[c];\n        }\n        \n        priority_queue<pair<int, char>> pq;\n        for (auto p = count.begin(); p != count.end(); ++p) {\n            pq.push({p->second, p->first});\n        }\n        \n        string res;\n        while (!pq.empty()) {\n            int freq = pq.top().first;\n            char c = pq.top().second;\n            for (int i = 0; i < freq; ++i) {\n                res += c;\n            }\n            pq.pop();\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s1 = \"tree\";\n    cout << \"Input: \" << s1 << endl;\n    cout << \"Output: \" << solution.frequencySort(s1) << endl << endl;\n\n    // Test case 2\n    string s2 = \"cccaaa\";\n    cout << \"Input: \" << s2 << endl;\n    cout << \"Output: \" << solution.frequencySort(s2) << endl << endl;\n\n    // Test case 3\n    string s3 = \"Aa\";\n    cout << \"Input: \" << s3 << endl;\n    cout << \"Output: \" << solution.frequencySort(s3) << endl;\n\n    return 0;\n}\n```",
  "452": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int findMinArrow Shots(std::vector<std::pair<int, int>>& points) {\n        if (points.empty()) return 0;\n        \n        std::sort(points.begin(), points.end(), [](const auto &a, const auto &b) { \n            return a.first < b.first; \n        });\n        \n        int arrows = 1;\n        int end = points[0].first;\n        \n        for (int i = 1; i < points.size(); ++i) {\n            if (points[i].first > end) {\n                ++arrows;\n                end = points[i].second;\n            } else if (points[i].second <= end) {\n                continue;\n            }\n            end = points[i].second;\n        }\n        \n        return arrows;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    std::vector<std::pair<int, int>> test1 = {{10,15},{20,30},{40,50}};\n    std::cout << \"Test case 1: \" << solution.findMinArrow(test1) << std::endl;\n\n    // Test case 2\n    std::vector<std::pair<int, int>> test2 = {{-2,-1},{3,4},{5,7},{6,8},{9,10}};\n    std::cout << \"Test case 2: \" << solution.findMinArrow(test2) << std::endl;\n\n    // Test case 3\n    std::vector<std::pair<int, int>> test3 = {{1,3},{4,5}};\n    std::cout << \"Test case 3: \" << solution.findMinArrow(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "453": "```\n#include <iostream>\n#include <vector>\n\nint minMoves(std::vector<int>& arr) {\n    int n = arr.size();\n    int res = 0;\n    int mn = *min_element(arr.begin(), arr.end());\n    for (int i : arr) {\n        res += abs(i - mn);\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> arr1 = {34,23,3};\n    std::cout << \"Test Case 1: \" << minMoves(arr1) << \"\\n\";\n    \n    std::vector<int> arr2 = {1,2,3,4,5};\n    std::cout << \"Test Case 2: \" << minMoves(arr2) << \"\\n\";\n    \n    std::vector<int> arr3 = {10,8,9,7,6};\n    std::cout << \"Test Case 3: \" << minMoves(arr3) << \"\\n\";\n\n    return 0;\n}\n```",
  "455": "```\n#include <iostream>\n#include <vector>\n\nint assignCookies(std::vector<int>& cookies, std::vector<int>& thresholds) {\n    int res = 0;\n    for (int i = 0; i < cookies.size(); ++i) {\n        for (int j = i + 1; j < cookies.size(); ++j) {\n            if (cookies[i] >= thresholds[j]) {\n                res++;\n                break;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> cookies1 = {1,2,3};\n    std::vector<int> thresholds1 = {1, 2};\n    std::cout << \"Test Case 1: \" << assignCookies(cookies1, thresholds1) << std::endl;\n\n    std::vector<int> cookies2 = {1,4,5,6};\n    std::vector<int> thresholds2 = {1,3};\n    std::cout << \"Test Case 2: \" << assignCookies(cookies2, thresholds2) << std::endl;\n\n    std::vector<int> cookies3 = {6,7,10};\n    std::vector<int> thresholds3 = {5,6,8};\n    std::cout << \"Test Case 3: \" << assignCookies(cookies3, thresholds3) << std::endl;\n    \n    return 0;\n}\n```",
  "454": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int fourSumCount(vector<vector<int>>& vectors) {\n        int count = 0;\n        unordered_map<int, int> map;\n        for (const auto& vec : vectors) {\n            map[vec[0] + vec[1]] += vec[2] * vec[3];\n        }\n        for (const auto& pair : map) {\n            count += pair.second;\n        }\n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> vectors1 = {{1, 2}, {-2,-1},{0, 0}};\n    cout << \"Test Case 1: \" << solution.fourSumCount(vectors1) << endl; \n\n    // Test case 2\n    vector<vector<int>> vectors2 = {{1, -2}, {-1, 2}};\n    cout << \"Test Case 2: \" << solution.fourSumCount(vectors2) << endl;\n\n    // Test case 3\n    vector<vector<int>> vectors3 = {{0, 4},{-1,-3},{5,0}};\n    cout << \"Test Case 3: \" << solution.fourSumCount(vectors3) << endl;\n\n    return 0;\n}\n```",
  "456": "```\n#include <iostream>\n#include <vector>\n\nbool find132Pattern(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n < 3) return false;\n    \n    std::vector<int> leftMin(n);\n    leftMin[0] = nums[0];\n    for (int i = 1; i < n; i++) {\n        leftMin[i] = std::min(leftMin[i-1], (int)nums[i]);\n    }\n    \n    int rightMax = nums[n-1];\n    for (int i = n - 2; i >= 0; i--) {\n        if (leftMin[i] < rightMax && nums[i] < rightMax) return true;\n        rightMax = std::min(rightMax, (int)nums[i]);\n    }\n    \n    return false;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 3, 4};\n    std::cout << find132Pattern(nums1) << std::endl; // Output: false\n\n    std::vector<int> nums2 = {3, 4, 5, 1, 2};\n    std::cout << find132Pattern(nums2) << std::endl; // Output: true\n\n    std::vector<int> nums3 = {1, 3, 2};\n    std::cout << find132Pattern(nums3) << std::endl; // Output: true\n\n    return 0;\n}",
  "457": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> circularArrayLoop(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) continue;\n            int start = i, end = i;\n            while (true) {\n                end = (end + 1) % n;\n                if (nums[start] * nums[end] < 0 || nums[end] == 0)\n                    break;\n                start = end;\n            }\n            if (nums[start] * nums[end] > 0) continue;\n            int len = end - start;\n            for (int j = 0; j <= len / 2; ++j) {\n                if (nums[(start + j) % n] != nums[start])\n                    break;\n            }\n            if (len / 2 == j)\n                return vector<int>({start, len});\n        }\n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {2,-1,1,2,2};\n    cout << \"Test case 1: \";\n    for (auto num : solution.circularArrayLoop(nums1)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<int> nums2 = {-1,2};\n    cout << \"Test case 2: \";\n    for (auto num : solution.circularArrayLoop(nums2)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<int> nums3 = {0,1};\n    cout << \"Test case 3: \";\n    for (auto num : solution.circularArrayLoop(nums3)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "458": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint poorPigs(int buckets) {\n    int maxTime = 0;\n    for (int time = 1; ; ++time) {\n        long long total = 1LL;\n        for (int i = 0; i < buckets; ++i)\n            total *= (long long)(buckets - i);\n        if (total >= 2147483647 || time > maxTime + 1) break;\n        maxTime = time;\n    }\n    return maxTime;\n}\n\nint main() {\n    cout << poorPigs(4) << endl; // Test case 1\n    cout << poorPigs(6) << endl; // Test case 2\n    cout << poorPigs(8) << endl; // Test case 3\n\n    return 0;\n}\n```",
  "459": "```\n#include <iostream>\n#include <string>\n\nbool repeatedSubstringPattern(const std::string& str) {\n    int len = str.length();\n    if (len == 0)\n        return false;\n    \n    for(int i=1; i <= len/2; i++) {\n        if(len % (i*2) == 0 && str.substr(0, i) == str.substr(i, i)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test case 1: \" << repeatedSubstringPattern(\"abab\") << std::endl; // Expected output: true\n    std::cout << \"Test case 2: \" << repeatedSubstringPattern(\"aba\") << std::endl; // Expected output: false\n    std::cout << \"Test case 3: \" << repeatedSubstringPattern(\"abcabcabc\") << std::endl; // Expected output: true\n    return 0;\n}\n```",
  "461": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int hammingWeight(int n) {\n        int weight = 0;\n        while (n) {\n            weight += n & 1;\n            n >>= 1;\n        }\n        return weight;\n    }\n\n    int hammingDistance(int x, int y) {\n        return hammingWeight(x ^ y);\n    }\n};\n\nint main() {\n    Solution s;\n\n    cout << s.hammingDistance(3, 5) << endl; // Test case 1\n    cout << s.hammingDistance(2, 4) << endl; // Test case 2\n    cout << s.hammingDistance(8, 7) << endl; // Test case 3\n\n    return 0;\n}\n```",
  "462": "```\n#include <iostream>\n#include <vector>\n\nint totalMoves(std::vector<int>& arr) {\n    int n = arr.size();\n    if (n == 1) return 0;\n    \n    std::sort(arr.begin(), arr.end());\n    long long mid = arr[n / 2];\n    long long ans = 0;\n    for (int i : arr)\n        ans += abs(i - mid);\n    return ans;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {10, 2, 3};\n    std::cout << \"Test case 1: \" << totalMoves(test1) << \"\\n\";\n    \n    // Test case 2\n    std::vector<int> test2 = {7, 1, 5, 3, 4};\n    std::cout << \"Test case 2: \" << totalMoves(test2) << \"\\n\";\n    \n    // Test case 3\n    std::vector<int> test3 = {1, 10, 2, 5, 7, 8};\n    std::cout << \"Test case 3: \" << totalMoves(test3) << \"\\n\";\n    \n    return 0;\n}\n```",
  "460": "```\n#include <iostream>\n#include <list>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Node {\npublic:\n    int key;\n    int value;\n    int frequency;\n    Node* prev;\n    Node* next;\n};\n\nclass LFUCache {\nprivate:\n    unordered_map<int, list<Node>::iterator> cache;\n    unordered_map<int, int> frequency;\n    list<Node*> lfu;\n    int capacity;\n\npublic:\n    LFUCache(int capacity) : capacity(capacity) {}\n\n    void put(int key, int value) {\n        if (cache.count(key)) {\n            update(key, value);\n        } else {\n            if (cache.size() >= capacity) {\n                evict();\n            }\n            cache[key] = lfu.back();\n            frequency[key] = 1;\n            lfu.back()->key = key;\n            lfu.back()->value = value;\n            lfu.push_back(new Node{key, value, 1});\n        }\n    }\n\n    int get(int key) {\n        if (cache.count(key)) {\n            update(key);\n            return cache[key]->value;\n        } else {\n            return -1;\n        }\n    }\n\n    void update(int key, int value = 0) {\n        Node* node = cache[key]->next;\n        frequency[key]++;\n        lfu.erase(cache[key]);\n        if (!value) {\n            delete cache[key];\n            cache.erase(key);\n        } else {\n            node->key = key;\n            node->value = value;\n            lfu.push_back(node);\n            cache[key] = lfu.back();\n        }\n    }\n\n    void update(int key) {\n        Node* node = cache[key]->next;\n        frequency[key]++;\n        lfu.erase(cache[key]);\n        lfu.push_back(cache[key]->next);\n        cache[key] = lfu.back();\n    }\n\n    void evict() {\n        int minFreq = 1;\n        for (auto it = lfu.begin(); it != lfu.end(); ++it) {\n            if ((it->key != -1) && frequency[it->key] < minFreq) {\n                minFreq = frequency[it->key];\n                break;\n            }\n        }\n        while (!lfu.empty()) {\n            Node* node = lfu.front();\n            lfu.pop_front();\n            cache.erase(node->key);\n            delete node;\n        }\n    }\n};\n\nint main() {\n    LFUCache cache(2);\n\n    cache.put(1, 1);\n    cache.put(2, 2);\n    cout << \"Get value of key 1: \" << cache.get(1) << endl; // returns 1\n    cout << \"Get value of key 3: \" << cache.get(3) << endl; // returns -1 (not found)\n    cout << \"Update key 2 to have value 3\";\n    cache.put(2, 3);\n    cout << \"Get value of key 2: \" << cache.get(2) << endl; // returns 3\n\n    LFUCache cache2(5);\n\n    cache2.put(1, 1);\n    cache2.put(2, 2);\n    cout << \"Get value of key 1: \" << cache2.get(1) << endl; // returns 1\n    cout << \"Get value of key 3: \" << cache2.get(3) << endl; // returns -1 (not found)\n    cout << \"Update key 2 to have value 3\";\n    cache2.put(2, 3);\n    cout << \"Get value of key 2: \" << cache2.get(2) << endl; // returns 3\n\n    LFUCache cache3(5);\n\n    for (int i = 1; i <= 10; ++i) {\n        cache3.put(i, i * i);\n    }\n    cout << \"Get value of key 9: \" << cache3.get(9) << endl; // returns 81\n\n    return 0;\n}\n```",
  "463": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int islandPerimeter(vector<vector<int>>& grid) {\n        int perimeter = 0;\n        for(int i = 0; i < grid.size(); i++) {\n            for(int j = 0; j < grid[0].size(); j++) {\n                if(grid[i][j] == 1) {\n                    if(i == 0 || grid[i-1][j] == 0) perimeter += 2;\n                    if(j == 0 || grid[i][j-1] == 0) perimeter += 1;\n                    if(i == grid.size() - 1 || grid[i+1][j] == 0) perimeter += 2;\n                    if(j == grid[0].size() - 1 || grid[i][j+1] == 0) perimeter += 1;\n                }\n            }\n        }\n        return perimeter;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> grid1 = {{0,1},{1,0}};\n    cout << \"Case 1: \" << solution.islandPerimeter(grid1) << endl;\n\n    vector<vector<int>> grid2 = {{1,1,0},{0,1,0},{0,0,0}};\n    cout << \"Case 2: \" << solution.islandPerimeter(grid2) << endl;\n\n    vector<vector<int>> grid3 = {{1,1,1,1,0},\n                                 {1,1,0,0,0},\n                                 {1,1,1,0,0},\n                                 {1,0,0,0,0}};\n    cout << \"Case 3: \" << solution.islandPerimeter(grid3) << endl;\n\n    return 0;\n}\n```",
  "464": "```\n#include <iostream>\nusing namespace std;\n\nbool canIWin(int maxFlip) {\n    int N = (1 << 21);\n    bool dp[N];\n\n    memset(dp, true, sizeof(dp));\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= 20; j++) {\n            if (((i >> j) & 1) && !dp[(i ^ (1 << j))]) {\n                dp[i] = false;\n                break;\n            }\n        }\n    }\n\n    return dp[maxFlip];\n}\n\nint main() {\n    cout << canIWin(6) << endl; // Test case 1\n    cout << canIWin(5) << endl; // Test case 2\n    cout << canIWin(10) << endl; // Test case 3\n\n    return 0;\n}\n```",
  "465": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint maxEqualFreq(vector<int>& bank) {\n    int n = bank.size();\n    vector<vector<int>> freq(1001, vector<int>(n + 1));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= bank[i]; ++j)\n            freq[j][++freq[j][0]] = bank[i] - j;\n    }\n    int res = 0, max_len = 0;\n    for (int i = 0; i < n; ++i) {\n        int start = -1;\n        for (int j = 1000; j >= 0; --j)\n            if (freq[j][0] > 0 && (start == -1 || freq[start][0] <= freq[j][0])) {\n                start = j;\n                break;\n            }\n        int end = 0, cnt = 0;\n        for (int j = start; j >= 0; --j) {\n            cnt += freq[j][0];\n            if (cnt == i)\n                end = j;\n            else if (cnt > i)\n                break;\n        }\n        int len = end - start + 1;\n        res = max(res, len);\n    }\n    return res;\n}\n\nint main() {\n    vector<int> bank1({3,7,90,13});\n    cout << \"Test case 1: \" << maxEqualFreq(bank1) << endl;\n\n    vector<int> bank2({5,9,11,14});\n    cout << \"Test case 2: \" << maxEqualFreq(bank2) << endl;\n\n    vector<int> bank3({7,4,10,13});\n    cout << \"Test case 3: \" << maxEqualFreq(bank3) << endl;\n    \n    return 0;\n}\n```",
  "466": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint maxRepeats(string s) {\n    int n = s.length();\n    int dp[n + 1];\n    for (int i = 0; i <= n; i++) {\n        dp[i] = 1;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            if (s[i] == s[j]) {\n                dp[j + 1] = max(dp[j], dp[i]);\n            }\n        }\n    }\n    \n    return dp[n];\n}\n\nint main() {\n    cout << \"Test Case 1: \" << maxRepeats(\"abc\") << endl;\n    cout << \"Test Case 2: \" << maxRepeats(\"aab\") << endl;\n    cout << \"Test Case 3: \" << maxRepeats(\"aaa\") << endl;\n    \n    return 0;\n}\n```",
  "467": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        int n = s.length();\n        vector<vector<int>> dp(n, vector<int>(n));\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (s[i] == s[j] && ((j - i < 2) || dp[i + 1][j - 1])) {\n                    dp[i][j] = 1;\n                    ans++;\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.countSubstrings(\"abc\") << endl;  // Expected output: 3\n    cout << \"Test Case 2: \" << solution.countSubstrings(\"aaa\") << endl;   // Expected output: 6\n    cout << \"Test Case 3: \" << solution.countSubstrings(\"abcdefg\") << endl; // Expected output: 7\n\n    return 0;\n}\n```",
  "468": "```\n#include <iostream>\n#include <string>\n\nbool validIPAddress(std::string IP) {\n    if (IP.length() > 15) return false;\n    \n    if (IP.substr(0, 7) == \"255.255.\") return false;\n    if (IP.substr(0, 5) == \"127.0\") return false;\n\n    int count = 0;\n    for (int i = 0; i < IP.length(); i++) {\n        if (IP[i] == '.') {\n            count++;\n            if ((i > 0 && !isdigit(IP[i-1])) || (i >= IP.length() - 2)) return false;\n        }\n    }\n\n    if (count != 3) return false;\n\n    for (int i = 0; i < IP.length(); i++) {\n        if (!isdigit(IP[i])) {\n            if (IP[i] == '.') continue;\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << (validIPAddress(\"255.255.11.15\") ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test case 2: \" << (validIPAddress(\"0.0.0.0\") ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test case 3: \" << (validIPAddress(\"123.456.789.012\") ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n```",
  "470": "```\n#include <iostream>\n#include <random>\n\nclass Solution {\npublic:\n    int rand10() {\n        int x = rand7();\n        while (x > 10) {\n            x = (rand7() - 1) * 7 + (x - 1) % 5;\n        }\n        return x;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test case 1: \" << solution.rand10() << std::endl;\n    std::cout << \"Test case 2: \" << solution.rand10() << std::endl;\n    std::cout << \"Test case 3: \" << solution.rand10() << std::endl;\n\n    return 0;\n}\n```",
  "469": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool isConvex(vector<vector<int>>& points) {\n    int n = points.size();\n    vector<int> p1, p2;\n    for (int i = 0; i < n; i++) {\n        if (i == 0) p1 = points[i];\n        else p2.push_back(points[i][0]);\n    }\n    p2.push_back(p1[0]);\n\n    int sign = 0;\n    for (int i = 0; i < n; i++) {\n        int curSign = orientation(p1, points[i], p2.back());\n        if (sign == 0) sign = curSign;\n        else if (curSign * sign < 0) return false;\n    }\n    return true;\n}\n\nint orientation(vector<int>& p1, vector<int>& p2, vector<int>& p3) {\n    return (p2[1] - p1[1]) * (p3[0] - p2[0]) - (p2[0] - p1[0]) * (p3[1] - p2[1]);\n}\n\nint main() {\n    vector<vector<int>> points1 = {{0, 0}, {1, 0}, {1, 1}, {0, 1}};\n    cout << (isConvex(points1) ? \"True\" : \"False\") << endl;\n\n    vector<vector<int>> points2 = {{0, 0}, {1, 0}, {2, 0}, {3, 0}};\n    cout << (isConvex(points2) ? \"True\" : \"False\") << endl;\n\n    vector<vector<int>> points3 = {{0, 0}, {1, 0}, {1, 1}, {0.5, 0.5}};\n    cout << (isConvex(points3) ? \"True\" : \"False\") << endl;\n    \n    return 0;\n}\n\n```",
  "471": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string shortestToTarget(string s, string target) {\n        int n = s.length();\n        vector<int> pos;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == target[0]) {\n                pos.push_back(i);\n            }\n        }\n\n        int resLen = n * 2 + 1;\n        string res = \"\";\n        for (int i = 0; i < n; i++) {\n            if (i < pos[0]) {\n                res += \" #\" + to_string(i - target.length() + 1) + \" \";\n            } else if (i == pos[0]) {\n                res += \"#\" + to_string(0);\n            }\n            for (int j = 0; j < pos.size(); j++) {\n                int dist = i - pos[j];\n                if (dist > 0) {\n                    res += \"# \" + to_string(dist) + \" \";\n                } else {\n                    res += \"# 0 \";\n                }\n            }\n        }\n\n        string[] words = res.split(\" \");\n        for (int i = 1; i < words.length - 1; i++) {\n            if (Integer.parseInt(words[i]) > 0) {\n                resLen = Math.min(resLen, Integer.parseInt(words[i]));\n            }\n        }\n\n        string result = \"\";\n        int count = 0;\n        for (String word : words) {\n            if (word.equals(\"#\")) {\n                result += \"#\";\n            } else if (count < resLen) {\n                result += word + \" \";\n                count++;\n            }\n        }\n\n        return result.trim();\n    }\n};\n\nint main() {\n    Solution solution = new Solution();\n    string s1 = \"ABC\", target1 = \"AA\";\n    cout << solution.shortestToTarget(s1, target1) << endl;  // Output: \"2 #\"\n\n    string s2 = \"LEETCODEIN\", target2 = \"CODE\";\n    cout << solution.shortestToTarget(s2, target2) << endl;  // Output: \"8 3 5 4 10\"\n\n    string s3 = \"bookkeeper\", target3 = \"book\";\n    cout << solution.shortestToTarget(s3, target3) << endl;  // Output: \"6 9 4 # 1\"\n    return 0;\n}\n```",
  "472": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool displayBoard(vector<vector<char>>& board) {\n        for (int i = 0; i < board.size(); i++) {\n            for (int j = 0; j < board[0].size(); j++) {\n                cout << board[i][j] << \" \";\n            }\n            cout << endl;\n        }\n    }\n\n    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int> pos) {\n        int i = pos[0], j = pos[1];\n        if (board[i][j] == 'E') {\n            // check neighbors\n            for (int k = -1; k <= 1; k++) {\n                for (int l = -1; l <= 1; l++) {\n                    int x = i + k, y = j + l;\n                    if ((x >= 0 && x < board.size()) && (y >= 0 && y < board[0].size())) {\n                        if (board[x][y] == 'M') {\n                            // mark as seen\n                            board[i][j] = '1';\n                            return updateBoard(board, {i, j});\n                        } else if ((k != 0 || l != 0) && board[x][y] == 'E') {\n                            // recursively explore the neighboring mine\n                            board[i][j] = '1';\n                            return updateBoard(board, {x, y});\n                        }\n                    }\n                }\n            }\n        }\n        // mark as seen if no mines found\n        board[i][j] = '0';\n        return board;\n    }\n\n    vector<vector<char>> updateBoard(vector<vector<char>>& board) {\n        for (int i = 0; i < board.size(); i++) {\n            for (int j = 0; j < board[0].size(); j++) {\n                if (board[i][j] == 'E') {\n                    updateBoard(board, {i, j});\n                }\n            }\n        }\n        return board;\n    }\n\n};\n\nint main() {\n\n    Solution solution;\n\n    // Test case 1\n    vector<vector<char>> board1 = {{'W', 'W', 'B'}, {'W', 'W', 'R'}, {'B', 'R', 'R'}};\n    vector<int> pos1 = {0,2};\n    cout << \"Test Case 1:\" << endl;\n    solution.updateBoard(board1, pos1);\n    for (int i = 0; i < board1.size(); i++) {\n        for (int j = 0; j < board1[0].size(); j++) {\n            cout << board1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<char>> board2 = {{'M', 'E', 'R'}, {'W', 'E', 'R'}, {'B', 'R', 'R'}};\n    vector<int> pos2 = {0,1};\n    cout << \"Test Case 2:\" << endl;\n    solution.updateBoard(board2, pos2);\n    for (int i = 0; i < board2.size(); i++) {\n        for (int j = 0; j < board2[0].size(); j++) {\n            cout << board2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<char>> board3 = {{'M', 'W', 'R'}, {'W', 'E', 'R'}, {'B', 'R', 'R'}};\n    vector<int> pos3 = {0,1};\n    cout << \"Test Case 3:\" << endl;\n    solution.updateBoard(board3, pos3);\n    for (int i = 0; i < board3.size(); i++) {\n        for (int j = 0; j < board3[0].size(); j++) {\n            cout << board3[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n}\n```",
  "473": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool makesquare(vector<int>& matchsticks) {\n        int n = matchsticks.size();\n        if (n < 4)\n            return false;\n        vector<int> sides(4, 0);\n        for (int i = 0; i < n; ++i) {\n            int length = matchsticks[i];\n            for (int j = 0; j < 4; ++j) {\n                if (sides[j] + length <= 1000) {\n                    sides[j] += length;\n                    break;\n                }\n            }\n        }\n        for (int i = 0; i < 4; ++i)\n            if (sides[i] != 1000)\n                return false;\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> matchsticks1 = {5, 5, 25};\n    cout << boolalpha << solution.makesquare(matchsticks1) << endl; // Expected Output: true\n\n    // Test Case 2\n    vector<int> matchsticks2 = {10};\n    cout << boolalpha << solution.makesquare(matchsticks2) << endl; // Expected Output: false\n\n    // Test Case 3\n    vector<int> matchsticks3 = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    cout << boolalpha << solution.makesquare(matchsticks3) << endl; // Expected Output: true\n\n    return 0;\n}\n```",
  "474": "```\n#include <iostream>\n#include <vector>\n\nint findMaxForm(std::vector<std::string>& binaryNumbers, int m, int n) {\n    int maxCount = 0;\n    for (const auto& str : binaryNumbers) {\n        int ones = std::count(str.begin(), str.end(), '1');\n        if (ones <= m && m - ones <= n) {\n            maxCount++;\n        }\n    }\n    return maxCount;\n}\n\nint main() {\n    {\n        std::vector<std::string> binaryNumbers = {\"100\", \"1100\", \"000\"};\n        int m = 2, n = 3;\n        std::cout << \"Expected: 1, Actual: \" << findMaxForm(binaryNumbers, m, n) << std::endl;\n    }\n    \n    {\n        std::vector<std::string> binaryNumbers = {\"10101\", \"10000\", \"11110\"};\n        int m = 3, n = 2;\n        std::cout << \"Expected: 3, Actual: \" << findMaxForm(binaryNumbers, m, n) << std::endl;\n    }\n    \n    {\n        std::vector<std::string> binaryNumbers = {\"1\", \"0\", \"101\"};\n        int m = 2, n = 2;\n        std::cout << \"Expected: 3, Actual: \" << findMaxForm(binaryNumbers, m, n) << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "475": "```\n#include <iostream>\n#include <vector>\n\nint findRadius(std::vector<int>& houses, std::vector<std::vector<int>>& heaters) {\n    int n = houses.size();\n    int m = heaters.size();\n\n    std::sort(houses.begin(), houses.end());\n    std::sort(heaters.begin(), heaters.end());\n\n    int minDist = INT_MAX;\n    for (int i = 0; i < m - 1; i++) {\n        int distLeft = heaters[i + 1][0] - heaters[i][0];\n        int distRight = heaters[i + 1][0] - heaters[i][0];\n\n        if (distLeft > distRight) {\n            for (int j = 0; j < n; j++) {\n                if (houses[j] <= heaters[i][0]) {\n                    minDist = std::min(minDist, distLeft);\n                } else {\n                    break;\n                }\n            }\n        } else {\n            for (int j = 0; j < n; j++) {\n                if (houses[j] >= heaters[i + 1][0]) {\n                    minDist = std::min(minDist, distRight);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    return minDist;\n}\n\nint main() {\n    int testCases[] = {3, 5};\n    for (int testCase : testCases) {\n        std::vector<int> houses = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        std::vector<std::vector<int>> heaters;\n        \n        switch (testCase) {\n            case 0:\n                heaters = {{1}, {3}};\n                break;\n            case 1:\n                heaters = {{2}};\n                break;\n            case 2:\n                heaters = {{5},{7},{9}};\n                break;\n        }\n\n        int result = findRadius(houses, heaters);\n        std::cout << \"Test Case \" << testCase << \": The maximum radius is \" << result << \".\" << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "476": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findComplement(int num) {\n        return ~num;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n    cout << solution.findComplement(5) << endl; // Expected: 2\n    cout << solution.findComplement(10) << endl; // Expected: 1\n    cout << solution.findComplement(14) << endl; // Expected: 3\n    return 0;\n}\n```",
  "477": "```\n#include <iostream>\n#include <vector>\n\nint totalHammingDistance(std::vector<int>& nums) {\n    int res = 0;\n    for (int i = 0; i < 30; i++) {\n        int cnt = 0;\n        for (int j : nums) {\n            cnt += ((j >> i) & 1);\n        }\n        res += cnt * (31 - cnt);\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {4,14,2};\n    std::cout << \"Test case 1: \" << totalHammingDistance(nums1) << std::endl;\n\n    std::vector<int> nums2 = {4,5,6};\n    std::cout << \"Test case 2: \" << totalHammingDistance(nums2) << std::endl;\n\n    std::vector<int> nums3 = {2,1,3,0};\n    std::cout << \"Test case 3: \" << totalHammingDistance(nums3) << std::endl;\n\n    return 0;\n}\n```",
  "478": "```\n#include <iostream>\n#include <random>\n\nclass Solution {\npublic:\n    std::vector<int> randPointOnCircle(int radius) {\n        std::random_device rd;\n        std::mt19937 gen(rd());\n        std::uniform_real_distribution<double> dis(0, 1);\n\n        double x = radius * std::cos(2 * M_PI * dis(gen));\n        double y = radius * std::sin(2 * M_PI * dis(gen));\n\n        return {int(x + 0.5), int(y + 0.5)};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int radius = 3;\n    std::vector<int> result1 = solution.randPointOnCircle(radius);\n    std::cout << \"Test case 1: Radius - \" << radius << \", Point - (\" << result1[0] << \",\" << result1[1] << \")\" << std::endl;\n\n    // Test case 2\n    radius = 5;\n    std::vector<int> result2 = solution.randPointOnCircle(radius);\n    std::cout << \"Test case 2: Radius - \" << radius << \", Point - (\" << result2[0] << \",\" << result2[1] << \")\" << std::endl;\n\n    // Test case 3\n    radius = 7;\n    std::vector<int> result3 = solution.randPointOnCircle(radius);\n    std::cout << \"Test case 3: Radius - \" << radius << \", Point - (\" << result3[0] << \",\" << result3[1] << \")\" << std::endl;\n\n    return 0;\n}\n```",
  "479": "```\n#include <iostream>\n#include <vector>\n\nint largestPalindrome(int n) {\n    if (n < 2) return -1;\n    int start = 1000000, end = 999999;\n    \n    for (; start > end; start--) {\n        std::string s = std::to_string(start);\n        std::string rev = s;\n        std::reverse(rev.begin(), rev.end());\n        \n        if (s == rev && std::stoll(s) * std::stoll(s) <= n)\n            return std::stoi(s) * std::stoi(s);\n    }\n    \n    return -1;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << largestPalindrome(182) << std::endl; // Expected output: 9009\n    std::cout << \"Test case 2: \" << largestPalindrome(12345678987654321) << std::endl; // Expected output: -1\n    std::cout << \"Test case 3: \" << largestPalindrome(9) << std::endl; // Expected output: 81\n\n    return 0;\n}\n```",
  "480": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<double> medianSlidingWindow(vector<int>& nums, int k) {\n        priority_queue<int> maxHeap;\n        priority_queue<int, vector<int>, greater<int>> minHeap;\n\n        vector<double> res;\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (i >= k) {\n                if (nums[i - k] <= *maxHeap.top()) {\n                    maxHeap.pop();\n                } else if (*minHeap.top() <= nums[i - k]) {\n                    minHeap.pop();\n                }\n            }\n\n            if (i >= k - 1) {\n                if (i % 2 == 0) {\n                    res.push_back((double)(maxHeap.top() + minHeap.top()) / 2);\n                } else {\n                    res.push_back((double)minHeap.top());\n                }\n            }\n\n            if (nums[i] > *maxHeap.top()) {\n                maxHeap.push(nums[i]);\n            } else {\n                minHeap.push(nums[i]);\n            }\n\n            while (!maxHeap.empty() && !minHeap.empty() && maxHeap.top() > minHeap.top()) {\n                swap(maxHeap, minHeap);\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> nums1 = {1, 3};\n    vector<double> result1 = solution.medianSlidingWindow(nums1, 2);\n    for (double num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> nums2 = {1, 3, 2, 6, 7};\n    vector<double> result2 = solution.medianSlidingWindow(nums2, 3);\n    for (double num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<int> nums3 = {4, 5, 6, 7, 8};\n    vector<double> result3 = solution.medianSlidingWindow(nums3, 2);\n    for (double num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "481": "```\n#include <iostream>\n#include <vector>\n\nbool isLongestPalindrome(std::string s) {\n    if (s.length() == 0) return true;\n    for (int i = 0; i < s.length(); ++i) {\n        // odd length palindrome\n        for (int j = i; j < s.length(); ++j) {\n            if (s[i] != s[j]) break;\n            if (j - i + 1 > s.length() / 2) return false;\n        }\n        // even length palindrome\n        int k = i + 1;\n        while (k <= s.length() && s[i] == s[k]) {\n            ++k;\n        }\n        if (k - i > s.length() / 2) return false;\n    }\n    return true;\n}\n\nint main() {\n    std::vector<std::string> testCases = {\"babad\", \"cbbd\", \"a\"};\n    \n    for (const auto& testCase : testCases) {\n        if (isLongestPalindrome(testCase)) {\n            std::cout << \"Test case: \" << testCase << \", Result: True\" << std::endl;\n        } else {\n            std::cout << \"Test case: \" << testCase << \", Result: False\" << std::endl;\n        }\n    }\n    \n    return 0;\n}\n```",
  "483": "```\n#include <iostream>\n#include <vector>\n\nint smallBase(int n) {\n    if (n <= 1) return -1;\n    for (long long k = 2; ; k++) {\n        long long base = 1, exp = 0;\n        while (base < n) {\n            base *= k;\n            exp++;\n        }\n        if (exp == n) return k;\n    }\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << smallBase(9) << std::endl; // Expected output: 3\n    std::cout << \"Test Case 2: \" << smallBase(16) << std::endl; // Expected output: 2\n    std::cout << \"Test Case 3: \" << smallBase(25) << std::endl; // Expected output: 5\n\n    return 0;\n}\n```",
  "482": "```\n#include <iostream>\n#include <string>\n\nstd::string licenseKeyFormatting(std::string S, int K) {\n    std::string result = \"\";\n    for (int i = S.size() - 1; i >= 0; --i) {\n        if (S[i] != '-') {\n            if ((result.size() + 1) % K == 0) {\n                result.insert(0, \"-\");\n            }\n            result.insert(0, S[i]);\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << licenseKeyFormatting(\"5-1-1\", 2) << std::endl; // Output: \"5-1-1\"\n    std::cout << licenseKeyFormatting(\"2-4A0r7-8hz\", 3) << std::endl; // Output: \"2-4A0r7-8hz\"\n    std::cout << licenseKeyFormatting(\"a12345b6-c7d\", 3) << std::endl; // Output: \"a1-23-4B6c-7D\"\n    return 0;\n}\n```",
  "484": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string findPermutation(const std::string& s) {\n    std::stack<char> st;\n    for (char c : s) {\n        if (c == 'i' || c == 'j') {\n            while (!st.empty() && ('a' <= st.top() && st.top() <= 'z')) {\n                st.pop();\n            }\n        } else if (c >= 'a' && c <= 'z') {\n            st.push(c);\n        }\n    }\n\n    std::string result = \"\";\n    while (!st.empty()) {\n        result += st.top();\n        st.pop();\n    }\n    return result;\n}\n\nint main() {\n    std::cout << findPermutation(\"a1c\") << \"\\n\"; // Expected \"ac\"\n    std::cout << findPermutation(\"cbad\") << \"\\n\"; // Expected \"badc\"\n    std::cout << findPermutation(\"cbafg!\") << \"\\n\"; // Expected \"badcf\"\n\n    return 0;\n}\n```",
  "485": "```\n#include <iostream>\n#include <vector>\n\nint findMaxConsecutive Ones(std::vector<int>& nums) {\n    int maxCount = 0;\n    int currentCount = 0;\n\n    for (int num : nums) {\n        if (num == 1) {\n            currentCount++;\n            maxCount = std::max(maxCount, currentCount);\n        } else {\n            currentCount = 0;\n        }\n    }\n\n    return maxCount;\n}\n\nint main() {\n    std::vector<int> test1 = {8, 0, 0, 1, 0, 0, 1};\n    int result1 = findMaxConsecutiveOnes(test1);\n    std::cout << \"Test case 1: The maximum consecutive ones is \" << result1 << std::endl;\n\n    std::vector<int> test2 = {1, 0, 1, 1, 0, 1};\n    int result2 = findMaxConsecutiveOnes(test2);\n    std::cout << \"Test case 2: The maximum consecutive ones is \" << result2 << std::endl;\n\n    std::vector<int> test3 = {0, 1};\n    int result3 = findMaxConsecutiveOnes(test3);\n    std::cout << \"Test case 3: The maximum consecutive ones is \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "486": "```\n#include <iostream>\n#include <vector>\n\nint PredictTheWinner(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));\n    \n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i; j < n; j++) {\n            if (i == j) {\n                dp[i][j] = nums[i];\n            } else {\n                int take = nums[i] + (dp[i+1][j-1] - dp[i+1][j]);\n                int leave = (dp[i+1][j] - dp[i+1][j-1]) + nums[j];\n                dp[i][j] = std::max(take, leave);\n            }\n        }\n    }\n    \n    return dp[0][n-1];\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 5, 23, 6};\n    int winner1 = PredictTheWinner(nums1);\n    std::cout << \"Test Case 1: Player wins with score \" << winner1 << std::endl;\n\n    std::vector<int> nums2 = {10, 20, 30, 40};\n    int winner2 = PredictTheWinner(nums2);\n    std::cout << \"Test Case 2: Player wins with score \" << winner2 << std::endl;\n\n    std::vector<int> nums3 = {1, 2, 3, 4};\n    int winner3 = PredictTheWinner(nums3);\n    std::cout << \"Test Case 3: Player wins with score \" << winner3 << std::endl;\n    \n    return 0;\n}\n```",
  "487": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMaxConsecutiveOnes(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        \n        int maxCount = 0, currentCount = 0;\n        bool lastBitWasOne = false;\n        \n        for (int bit : nums) {\n            if (bit == 1) {\n                currentCount++;\n                lastBitWasOne = true;\n            } else {\n                if (lastBitWasOne) {\n                    maxCount = max(maxCount, currentCount);\n                    currentCount = 0;\n                    lastBitWasOne = false;\n                }\n            }\n        }\n        \n        return max(maxCount, currentCount);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> test1 = {1, 0, 1, 1, 0, 1};\n    cout << \"Test 1: \" << solution.findMaxConsecutiveOnes(test1) << endl; // Expected output: 3\n\n    vector<int> test2 = {1, 1, 1, 1, 1, 1};\n    cout << \"Test 2: \" << solution.findMaxConsecutiveOnes(test2) << endl; // Expected output: 6\n\n    vector<int> test3 = {0, 0, 0, 0, 1, 0};\n    cout << \"Test 3: \" << solution.findMaxConsecutiveOnes(test3) << endl; // Expected output: 2\n\n    return 0;\n}\n```",
  "489": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    void cleanRoom(vector<string>& room) {\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            if (i == 3 && room[0][1] == '0') break;\n\n            for (int j = 0; j < room.size(); ++j) {\n                int x = j, y = 0;\n                while (x >= 0 && x < room.size() && y >= 0 && y < room[0].size()) {\n                    if (room[x][y] == '1') {\n                        room[x][y] = '#';\n                        break;\n                    }\n                    room[x][y] = '#';\n\n                    int newX = j, newY = 0;\n                    for (int k = 0; k < 4; ++k) {\n                        newX += dx[k];\n                        newY += dy[k];\n                        if (newX >= 0 && newX < room.size() && newY >= 0 && newY < room[0].size()) {\n                            if (room[newX][newY] == '1') {\n                                int newX2 = j, newY2 = 0;\n                                for (int k2 = 0; k2 < 4; ++k2) {\n                                    newX2 += dx[k2];\n                                    newY2 += dy[k2];\n                                    if (newX2 >= 0 && newX2 < room.size() && newY2 >= 0 && newY2 < room[0].size()) {\n                                        if (room[newX2][newY2] == '1') {\n                                            j = newX;\n                                            y = newY;\n                                            break;\n                                        }\n                                    }\n                                }\n                            } else {\n                                j = newX;\n                                y = newY;\n                                break;\n                            }\n                        }\n                    }\n\n                    x += dx[i];\n                    y += dy[i];\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> room1 = {\"0010\", \"0111\", \"00000\"};\n    solution.cleanRoom(room1);\n    cout << endl;\n\n    vector<string> room2 = {\"10023\", \"19014\", \"20301\", \"10173\", \"70132\", \"11126\"};\n    solution.cleanRoom(room2);\n    cout << endl;\n\n    vector<string> room3 = {\"0000\", \"0110\", \"0101\", \"0011\"};\n    solution.cleanRoom(room3);\n\n    return 0;\n}\n```",
  "488": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numJewelsInStones(string jewels, string stones) {\n        unordered_map<char, int> jewelMap;\n        \n        for (char jewel : jewels) {\n            jewelMap[jewel] = 1;\n        }\n        \n        int count = 0;\n        for (char stone : stones) {\n            if (jewelMap.find(stone) != jewelMap.end()) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.numJewelsInStones(\"a\", \"aA\") << endl; // Output: 2\n    cout << \"Test case 2: \" << solution.numJewelsInStones(\"aa\", \"aaaa\") << endl; // Output: 4\n    cout << \"Test case 3: \" << solution.numJewelsInStones(\"z\", \"zzz\") << endl; // Output: 0\n\n    return 0;\n}\n```",
  "491": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findLengthOfLIS(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        \n        vector<int> dp(nums.size(), 1);\n        int maxLen = 1;\n        for (int i = 1; i < nums.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLen = max(maxLen, dp[i]);\n        }\n        \n        return maxLen;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> test1 = {10,9,2,5,3,7,101,18};\n    cout << \"Test case 1: \" << solution.findLengthOfLIS(test1) << endl;  // Output: 4\n\n    // Test Case 2\n    vector<int> test2 = {0,1,3,6,9,10,11,13};\n    cout << \"Test case 2: \" << solution.findLengthOfLIS(test2) << endl;  // Output: 6\n\n    // Test Case 3\n    vector<int> test3 = [5];\n    cout << \"Test case 3: \" << solution.findLengthOfLIS(test3) << endl;  // Output: 1\n\n    return 0;\n}\n```",
  "490": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestPath(vector<vector<int>>& maze) {\n        int m = maze.size();\n        if (m == 0) return 0;\n        int n = maze[0].size();\n        if (n == 0) return 0;\n\n        vector<pair<int, int>> dir = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        queue<pair<int, int>> q;\n        int res = m + n;\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (maze[i][j] == 1) {\n                    visited[i][j] = true;\n                    q.push({i, j});\n                }\n            }\n        }\n\n        while (!q.empty()) {\n            int x = q.front().first;\n            int y = q.front().second;\n            q.pop();\n\n            for (auto& d : dir) {\n                int nx = x + d.first;\n                int ny = y + d.second;\n\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && maze[nx][ny] == 1 && !visited[nx][ny]) {\n                    res = min(res, abs(nx - x) + abs(ny - y));\n                    visited[nx][ny] = true;\n                    q.push({nx, ny});\n                }\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> maze1 = {{0,0,0},{1,1,0},{1,1,0}};\n    cout << \"Test Case 1: \" << solution.shortestPath(maze1) << endl;\n\n    // Test Case 2\n    vector<vector<int>> maze2 = {{0,0,0},{1,1,0},{1,1,1}};\n    cout << \"Test Case 2: \" << solution.shortestPath(maze2) << endl;\n\n    // Test Case 3\n    vector<vector<int>> maze3 = {{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}};\n    cout << \"Test Case 3: \" << solution.shortestPath(maze3) << endl;\n\n    return 0;\n}",
  "492": "```\n#include <iostream>\n#include <vector>\n\nint calculateTotalArea(int w, int h) {\n    return w * h;\n}\n\nbool isPossible(std::vector<int> &piles, int minW, int maxH) {\n    int total = 0;\n    for (int pile : piles) {\n        total += pile;\n    }\n\n    if (total < minW * maxH) {\n        return false;\n    }\n\n    int remainPiles = total;\n    int h = maxH;\n\n    while (h > 1) {\n        int w = remainPiles / h;\n        if (w >= minW && calculateTotalArea(w, h) == remainPiles) {\n            return true;\n        }\n        h--;\n    }\n\n    return false;\n}\n\nint main() {\n    std::vector<int> piles1 = {2, 3, 4};\n    std::cout << std::boolalpha << isPossible(piles1, 5, 10) << std::endl; // Should print: true\n\n    std::vector<int> piles2 = {5, 15, 25};\n    std::cout << std::boolalpha << isPossible(piles2, 0, 20) << std::endl; // Should print: false\n\n    std::vector<int> piles3 = {1, 2, 4};\n    std::cout << std::boolalpha << isPossible(piles3, 3, 10) << std::endl; // Should print: true\n\n    return 0;\n}\n```",
  "493": "```\n#include <iostream>\n#include <vector>\n\nlong long merge(int left[], int right[], int x[], int y[]) {\n    int i = 0, j = 0;\n    long long res = 0;\n    \n    while (i < x.size() && j < y.size()) {\n        if (x[i] <= y[j]) {\n            res += (long long) (y.size() - j);\n            i++;\n        } else {\n            res += (long long) (y.size() - j);\n            j++;\n        }\n    }\n    \n    while (i < x.size())\n        res += (long long) (y.size() - j);\n    while (j < y.size())\n        j++;\n    \n    return res;\n}\n\nlong long reversePairs(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    \n    int left[100000];\n    int right[100000];\n    \n    for (int i = 0; i < nums.size(); i++) {\n        if (i % 2 == 0) {\n            left[i / 2] = nums[i];\n        } else {\n            right[i / 2] = nums[i];\n        }\n    }\n    \n    long long res = merge(left, right, left, right);\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 3};\n    std::cout << \"Reverse Pairs: \" << reversePairs(nums1) << std::endl;\n    \n    std::vector<int> nums2 = {2, 3, 4, 5};\n    std::cout << \"Reverse Pairs: \" << reversePairs(nums2) << std::endl;\n    \n    std::vector<int> nums3 = {1, 2, 3, 4, 5};\n    std::cout << \"Reverse Pairs: \" << reversePairs(nums3) << std::endl;\n\n    return 0;\n}\n```",
  "494": "```\n#include <iostream>\n#include <vector>\n\nint findTargetSumWays(std::vector<int>& nums, int target) {\n    int sum = 0;\n    for (int num : nums) {\n        sum += num;\n    }\n    if (target > sum || target < -sum) return 0;\n\n    std::vector<std::vector<int>> dp(sum + 1);\n    dp[0].push_back(1);\n\n    for (int num : nums) {\n        for (int i = sum; i >= num; --i) {\n            if (i - num >= 0 && dp[i - num].size()) {\n                int oldSize = dp[i].size();\n                for (int j : dp[i - num]) {\n                    dp[i].push_back(j);\n                }\n                if (!oldSize) return 1;\n            }\n        }\n    }\n\n    for (int i = target; i >= 0; --i) {\n        if (dp[i].size()) return dp[i].size();\n    }\n\n    return 0;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, -1, 1};\n    int target1 = 0;\n    std::cout << findTargetSumWays(nums1, target1) << std::endl;\n\n    std::vector<int> nums2 = {60, -10, -60, 40];\n    int target2 = -60;\n    std::cout << findTargetSumWays(nums2, target2) << std::endl;\n\n    std::vector<int> nums3 = {0};\n    int target3 = 0;\n    std::cout << findTargetSumWays(nums3, target3) << std::endl;\n\n    return 0;\n}\n```",
  "495": "```\n#include <iostream>\n#include <vector>\n\nint findPokemons(std::vector<std::vector<int>>& grid) {\n    int time = 0;\n    int count = 0;\n\n    while (true) {\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (grid[i][j] == 1) {\n                    count++;\n                    grid[i][j] = -1;\n                }\n            }\n        }\n\n        time++;\n\n        bool found = false;\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (grid[i][j] == 2) {\n                    found = true;\n                    break;\n                }\n            }\n\n            if (found)\n                break;\n        }\n\n        if (!found)\n            return count;\n\n        for (int i = 0; i < grid.size(); i++) {\n            for (int j = 0; j < grid[0].size(); j++) {\n                if (grid[i][j] == -1) {\n                    grid[i][j] = 2;\n                }\n            }\n        }\n\n        time++;\n    }\n\n    return 0;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> grid1 = {{0, 0, 1}, {0, 1, 0}};\n    std::cout << \"Test case 1: \" << findPokemons(grid1) << std::endl;\n\n    // Test case 2\n    std::vector<std::vector<int>> grid2 = {{0, 0, 2, 0}, {0, 1, 1, 0}};\n    std::cout << \"Test case 2: \" << findPokemons(grid2) << std::endl;\n\n    // Test case 3\n    std::vector<std::vector<int>> grid3 = {{0, 0, 1, 0}, {0, 1, 0, 0}};\n    std::cout << \"Test case 3: \" << findPokemons(grid3) << std::endl;\n\n    return 0;\n}\n```",
  "496": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> res(n);\n        for(int i = 0; i < n; i++){\n            bool found = false;\n            for(int j = (i+1)%n; j != i; j = (j+1)%n){\n                if(nums[j] > nums[i]){\n                    res[i] = nums[j];\n                    found = true;\n                    break;\n                }\n            }\n            if(!found) res[i] = -1;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> test1 = {1,2,3,2,4};\n    vector<int> result1 = solution.nextGreaterElements(test1);\n    cout << \"Test case 1: \";\n    for(int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<int> test2 = {3,1};\n    vector<int> result2 = solution.nextGreaterElements(test2);\n    cout << \"Test case 2: \";\n    for(int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<int> test3 = {1,5,3};\n    vector<int> result3 = solution.nextGreaterElements(test3);\n    cout << \"Test case 3: \";\n    for(int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "497": "```\n#include <iostream>\n#include <vector>\n#include <random>\n\nclass Solution {\npublic:\n    std::vector<int> corpFlightBook(int n, int[] flights, int[][] book) {\n        std::vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            int total = 0;\n            for (int j = 0; j < flights.length; j++) {\n                total += book[j][i];\n            }\n            if ((total + 1) % 2 == 0) {\n                ans.push_back(1);\n            } else {\n                ans.push_back(0);\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution = new Solution();\n\n    int n = 3;\n    int[] flights = {5, 10, 20};\n    int[][] book = {{2, 1, 2}, {1, 2, 5}, {7, 6, 4}};\n    std::vector<int> result = solution.corpFlightBook(n, flights, book);\n\n    for (int i : result) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    n = 2;\n    flights = new int[] {10, 20};\n    book = new int[][]{{5, 1}, {3, 0}};\n    result = solution.corpFlightBook(n, flights, book);\n\n    for (int i : result) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    n = 1;\n    flights = new int[] {2};\n    book = new int[][]{{5}};\n    result = solution.corpFlightBook(n, flights, book);\n\n    for (int i : result) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "498": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> findDiagonalOrder(std::vector<std::vector<int>>& mat) {\n    if (mat.empty()) return {};\n    \n    int rows = mat.size(), cols = mat[0].size();\n    std::vector<int> result;\n    for (int k = 0; k <= rows + cols - 2; ++k) {\n        int startRow = max(0, k - cols + 1), endRow = min(rows, k + 1);\n        for (int i = startRow; i < endRow; ++i) {\n            if (k % 2 == 0) {\n                result.push_back(mat[i][k - i]);\n            } else {\n                result.push_back(mat[i][cols - 1 - (k - i)]);\n            }\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    std::vector<std::vector<int>> mat1 = {{1,2,3},{4,5,6},{7,8,9}};\n    int result1[] = {1,2,4,5,7,8,3,6,9};\n    assert(std::equal(findDiagonalOrder(mat1).begin(), findDiagonalOrder(mat1).end(), result1));\n    \n    std::vector<std::vector<int>> mat2 = {{1},{2}};\n    int result2[] = {1,2};\n    assert(std::equal(findDiagonalOrder(mat2).begin(), findDiagonalOrder(mat2).end(), result2));\n    \n    std::vector<std::vector<int>> mat3 = {{1, 2}, {3,4},{5,6}};\n    int result3[] = {1,2,4,5,3,6};\n    assert(std::equal(findDiagonalOrder(mat3).begin(), findDiagonalOrder(mat3).end(), result3));\n    \n    return 0;\n}\n```",
  "500": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findWords(vector<string>& words) {\n        map<char, int> rowMap = {{'q', 1}, {'w', 1}, {'e', 1}, {'r', 1}, {'t', 1}, {'y', 1}, {'u', 1}, {'i', 1}, {'o', 1}, {'p', 1},\n                                  {'a', 2}, {'s', 2}, {'d', 2}, {'f', 2}, {'g', 2}, {'h', 2}, {'j', 2}, {'k', 2}, {'l', 2},\n                                  {'z', 3}, {'x', 3}, {'c', 3}, {'v', 3}, {'b', 3}, {'n', 3}, {'m', 3}};\n\n        vector<string> result;\n        for (const string& word : words) {\n            int row = rowMap[word[0]];\n            bool inRow = true;\n            for (char c : word) {\n                if (rowMap.find(c) != rowMap.end() && rowMap[c] != row) {\n                    inRow = false;\n                    break;\n                }\n            }\n            if (inRow) {\n                result.push_back(word);\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> words1 = {\"Alaska\", \"Florida\"};\n    cout << \"Test Case 1: \";\n    for (const string& word : solution.findWords(words1)) {\n        cout << word << \" \";\n    }\n    cout << endl;\n\n    vector<string> words2 = {\"Hello\", \"Alaska\", \"Dewayne\", \"Belize\"};\n    cout << \"Test Case 2: \";\n    for (const string& word : solution.findWords(words2)) {\n        cout << word << \" \";\n    }\n    cout << endl;\n\n    vector<string> words3 = {\"Apple\", \"Banana\", \"Carrot\", \"Doggo\"};\n    cout << \"Test Case 3: \";\n    for (const string& word : solution.findWords(words3)) {\n        cout << word << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "499": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> updateDirection(vector<vector<int>>& maze, vector<int>& start) {\n        int m = maze.size();\n        int n = maze[0].size();\n        vector<vector<int>> direction(m, vector<int>(n, -1));\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (maze[i][j] == 0) {\n                    if (i > 0 && maze[i-1][j] == 0) direction[i][j] = 0;\n                    if (j > 0 && maze[i][j-1] == 0) direction[i][j] = 1;\n                    if (i < m - 1 && maze[i+1][j] == 0) direction[i][j] = 2;\n                    if (j < n - 1 && maze[i][j+1] == 0) direction[i][j] = 3;\n                }\n            }\n        }\n\n        return direction;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> maze1 = {{0,0,1},{0,1,0},{0,1,0}};\n    vector<int> start1 = {0,0};\n    vector<vector<int>> result1 = solution.updateDirection(maze1, start1);\n    for (int i = 0; i < result1.size(); ++i) {\n        for (int j = 0; j < result1[0].size(); ++j) {\n            cout << result1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<vector<int>> maze2 = {{0,0,1},{0,1,0},{1,1,2}};\n    vector<int> start2 = {0,0};\n    vector<vector<int>> result2 = solution.updateDirection(maze2, start2);\n    for (int i = 0; i < result2.size(); ++i) {\n        for (int j = 0; j < result2[0].size(); ++j) {\n            cout << result2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<vector<int>> maze3 = {{1,0,0},{1,1,0},{1,1,2}};\n    vector<int> start3 = {0,0};\n    vector<vector<int>> result3 = solution.updateDirection(maze3, start3);\n    for (int i = 0; i < result3.size(); ++i) {\n        for (int j = 0; j < result3[0].size(); ++j) {\n            cout << result3[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "502": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint findMaxAverage(std::vector<int>& nums) {\n    int n = nums.size();\n    long long total = 0;\n    for (int i = 0; i < n / 3; ++i) {\n        total += nums[i * 3 + 2];\n    }\n    return static_cast<int>(total / (n / 3));\n}\n\nint main() {\n    std::vector<int> nums1 = {10,6,5,4,11};\n    int expected1 = 8;\n    std::cout << \"Test case 1: \" << findMaxAverage(nums1) << \" expected: \" << expected1 << std::endl;\n\n    std::vector<int> nums2 = {1,12,-5,-13,21,0};\n    int expected2 = 6;\n    std::cout << \"Test case 2: \" << findMaxAverage(nums2) << \" expected: \" << expected2 << std::endl;\n\n    std::vector<int> nums3 = {7,1,5,3,6,4};\n    int expected3 = 5;\n    std::cout << \"Test case 3: \" << findMaxAverage(nums3) << \" expected: \" << expected3 << std::endl;\n\n    return 0;\n}\n```",
  "501": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        vector<int> res;\n        if (!root)\n            return res;\n        \n        map<int, int> m;\n        int maxCount = 0;\n        TreeNode *cur = root;\n        while (cur) {\n            if (m.find(cur->val) == m.end())\n                m[cur->val] = 1;\n            else\n                m[cur->val]++;\n            cur = cur->right;\n        }\n        \n        for (auto it = m.begin(); it != m.end(); ++it)\n            if (it->second > maxCount) {\n                res.clear();\n                res.push_back(it->first);\n                maxCount = it->second;\n            } else if (it->second == maxCount)\n                res.push_back(it->first);\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* tree1 = new TreeNode(7);\n    tree1->left = new TreeNode(3);\n    tree1->right = new TreeNode(6);\n    tree1->left->left = new TreeNode(15);\n    tree1->left->right = new TreeNode(20);\n    vector<int> result1 = solution.findMode(tree1);\n    for (int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    TreeNode* tree2 = new TreeNode(7);\n    tree2->left = new TreeNode(3);\n    tree2->right = new TreeNode(3);\n    vector<int> result2 = solution.findMode(tree2);\n    for (int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    TreeNode* tree3 = new TreeNode(1);\n    tree3->right = new TreeNode(4);\n    tree3->right->left = new TreeNode(4);\n    tree3->right->right = new TreeNode(5);\n    vector<int> result3 = solution.findMode(tree3);\n    for (int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "503": "```\n#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> res(n);\n        stack<int> s;\n        \n        for (int i = 2 * n - 1; i >= 0; --i) {\n            while (!s.empty() && s.top() <= nums[i % n]) {\n                s.pop();\n            }\n            \n            if (!s.empty()) {\n                res[i % n] = s.top();\n            } else {\n                res[i % n] = -1;\n            }\n            \n            s.push(nums[i % n]);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> nums1 = {1, 2, 3, 2, 4};\n    vector<int> result1 = solution.nextGreaterElements(nums1);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    vector<int> nums2 = {1, 2, 3, 4, 3, 2, 1};\n    vector<int> result2 = solution.nextGreaterElements(nums2);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    vector<int> nums3 = {1, 1, 1, 1};\n    vector<int> result3 = solution.nextGreaterElements(nums3);\n    for (int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "504": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    string convertToBase7(int num) {\n        if (num == 0) return \"0\";\n        bool isNegative = false;\n        if (num < 0) {\n            isNegative = true;\n            num = -num;\n        }\n        string res = \"\";\n        while (num > 0) {\n            res = to_string(num % 7) + res;\n            num /= 7;\n        }\n        return (isNegative ? \"-\" : \"\") + res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \";\n    int num1 = -7; // Test case 1\n    cout << solution.convertToBase7(num1) << endl;\n\n    cout << \"Test Case 2: \";\n    int num2 = 100; // Test case 2\n    cout << solution.convertToBase7(num2) << endl;\n\n    cout << \"Test Case 3: \";\n    int num3 = 0; // Test case 3\n    cout << solution.convertToBase7(num3) << endl;\n\n    return 0;\n}\n```",
  "506": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::vector<std::string> findRelativeRanks(std::vector<int>& nums) {\n    std::vector<std::pair<int, int>> pairs;\n    for (int i = 0; i < nums.size(); ++i) {\n        pairs.push_back({nums[i], i});\n    }\n    \n    std::sort(pairs.begin(), pairs.end(), [](const auto& a, const auto& b) { return a.first > b.first; });\n    \n    std::vector<std::string> ranks;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (i == 0) {\n            ranks.push_back(\"Gold Medal\");\n        } else if (i == 1) {\n            ranks.push_back(\"Silver Medal\");\n        } else if (i == 2) {\n            ranks.push_back(\"Bronze Medal\");\n        } else {\n            ranks.push_back(std::to_string(i + 1));\n        }\n    }\n    \n    for (int i = 0; i < nums.size(); ++i) {\n        for (const auto& pair : pairs) {\n            if (pair.second == i) {\n                std::string medal;\n                switch(ranks[i].find(\" Medal\")) {\n                    case 0:\n                        medal = \"Gold \";\n                        break;\n                    case 5:\n                        medal = \"Silver \";\n                        break;\n                    case 10:\n                        medal = \"Bronze \";\n                        break;\n                    default:\n                        medal = \"\";\n                }\n                ranks[i] = (ranks[i].find(\" Medal\") == std::string::npos) ? std::to_string(pair.first + 1) : medal + ranks[i];\n                break;\n            }\n        }\n    }\n    \n    return ranks;\n}\n\nint main() {\n    int testCases[][] = {{5, 4, 8, 7, 9}, {10, 5, 3, 2, 9, 6, 7, 1, 4}, {1}};\n    for (int i = 0; i < sizeof(testCases) / sizeof(*testCases); ++i) {\n        std::vector<int> nums(testCases[i], testCases[i] + sizeof(testCases[i]) / sizeof(*testCases[i]));\n        std::cout << \"Test case: \";\n        for (const auto& num : nums) {\n            std::cout << num << \" \";\n        }\n        std::cout << std::endl;\n        std::vector<std::string> result = findRelativeRanks(nums);\n        std::cout << \"Result: \";\n        for (const auto& rank : result) {\n            std::cout << rank << \" \";\n        }\n        std::cout << std::endl;\n    }\n    return 0;\n}\n```",
  "505": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestDistance(vector<vector<int>>& maze) {\n        if (maze.empty()) return -1;\n        \n        int m = maze.size(), n = maze[0].size();\n        vector<vector<pair<int, int>>> directions(4);\n        directions[0] = {{-1, 0}};\n        directions[1] = {{1, 0}};\n        directions[2] = {{0, -1}};\n        directions[3] = {{0, 1}};\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (maze[i][j] == 1) continue;\n                vector<pair<int, int>> queue;\n                bool visited[m][n];\n                int steps = -1;\n\n                queue.push_back({i, j});\n                while (!queue.empty()) {\n                    auto [x, y] = queue[0];\n                    queue.erase(queue.begin());\n                    if (visited[x][y]) continue;\n                    visited[x][y] = true;\n\n                    for (auto& d : directions) {\n                        int nx = x + d[0][0], ny = y + d[0][1];\n                        if (nx < 0 || nx >= m || ny < 0 || ny >= n || maze[nx][ny] == 1) continue;\n                        queue.push_back({nx, ny});\n                    }\n                }\n\n                steps++;\n            }\n        }\n\n        return -1; // dummy\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<vector<int>> maze1 = {{0,0,1},{1,1,0},{1,1,0}};\n    cout << \"Test case 1: \" << solution.shortestDistance(maze1) << endl; // Expected output: 4\n\n    // Test case 2:\n    vector<vector<int>> maze2 = {{0,0,0},{1,1,0},{1,1,2}};\n    cout << \"Test case 2: \" << solution.shortestDistance(maze2) << endl; // Expected output: -1\n\n    // Test case 3:\n    vector<vector<int>> maze3 = {{0,0,1},{0,0,0},{1,1,6}};\n    cout << \"Test case 3: \" << solution.shortestDistance(maze3) << endl; // Expected output: 8\n\n    return 0;\n}\n```",
  "507": "```\n#include <iostream>\nusing namespace std;\n\nbool checkPerfectNumber(int num) {\n    if (num <= 0)\n        return false;\n    int sum = 1;\n    for (int i = 2; i * i <= num; i++) {\n        if (num % i == 0) {\n            while (num % i == 0) {\n                sum += i;\n                num /= i;\n            }\n        }\n    }\n    if (num > 1)\n        sum += num;\n    return sum == num;\n}\n\nint main() {\n    cout << boolalpha;\n    cout << \"Test Case 1: \" << checkPerfectNumber(6) << endl; // Expected: true\n    cout << \"Test Case 2: \" << checkPerfectNumber(28) << endl; // Expected: true\n    cout << \"Test Case 3: \" << checkPerfectNumber(7) << endl; // Expected: false\n    return 0;\n}",
  "509": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int fib(int n) {\n        if (n <= 1) return n;\n        std::vector<int> dp(n + 1);\n        dp[0] = 0; dp[1] = 1;\n        for (int i = 2; i <= n; ++i)\n            dp[i] = dp[i - 1] + dp[i - 2];\n        return dp[n];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int testCases[] = {0, 2, 7};\n    for (int testCase : testCases) {\n        std::cout << \"Fibonacci of \" << testCase << \": \" << solution.fib(testCase) << std::endl;\n    }\n\n    return 0;\n}\n```",
  "508": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    unordered_map<int, int> sumCount;\n    int mostFrequentSubtreeSum(TreeNode* root) {\n        dfs(root, 0);\n        if (sumCount.empty()) return 0;\n        int maxCount = 0, mostFrequentSum = 0;\n        for (const auto& p : sumCount) {\n            if (p.second > maxCount) {\n                maxCount = p.second;\n                mostFrequentSum = p.first;\n            } else if (p.second == maxCount) {\n                mostFrequentSum = max(mostFrequentSum, p.first);\n            }\n        }\n        return mostFrequentSum;\n    }\n\nprivate:\n    void dfs(TreeNode* node, int sum) {\n        if (!node) return;\n        sum += node->val;\n        sumCount[sum]++;\n        dfs(node->left, sum);\n        dfs(node->right, sum);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(-3);\n    cout << \"Most frequent subtree sum: \" << solution.mostFrequentSubtreeSum(root1) << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(-3);\n    root2->left->left = new TreeNode(-4);\n    root2->left->right = new TreeNode(1);\n    cout << \"Most frequent subtree sum: \" << solution.mostFrequentSubtreeSum(root2) << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(5);\n    root3->left = new TreeNode(-3);\n    root3->right = new TreeNode(1);\n    cout << \"Most frequent subtree sum: \" << solution.mostFrequentSubtreeSum(root3) << endl;\n\n    return 0;\n}\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n```",
  "511": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> displayTable(vector<vector<string>>& orders) {\n        // your logic here\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<vector<string>> orders1 = {{\"John\", \"burger\", \"$10.99\"}, {\"John\", \"fries\", \"$3.49\"}};\n    vector<vector<string>> orders2 = {{\"Jane\", \"burger\", \"$10.99\"}, {\"Jane\", \"drink\", \"$2.99\"}};\n    vector<vector<string>> orders3 = {{\"Alice\", \"pizza\", \"$15.00\"}, {\"Bob\", \"pizza\", \"$15.00\"}};\n\n    cout << \"[\";\n    for (const auto& order : solution.displayTable(orders1)) {\n        cout << \"[\";\n        for (const auto& item : order) {\n            cout << \"\\\"\" << item << \"\\\"\";\n            if (&item != &order.back()) cout << \", \";\n        }\n        cout << \"]\";\n        if (&order != &solution.displayTable(orders1).back()) cout << \", \";\n    }\n    cout << \"]\";\n\n    cout << endl;\n    cout << \"[\";\n    for (const auto& order : solution.displayTable(orders2)) {\n        cout << \"[\";\n        for (const auto& item : order) {\n            cout << \"\\\"\" << item << \"\\\"\";\n            if (&item != &order.back()) cout << \", \";\n        }\n        cout << \"]\";\n        if (&order != &solution.displayTable(orders2).back()) cout << \", \";\n    }\n    cout << \"]\";\n\n    cout << endl;\n    cout << \"[\";\n    for (const auto& order : solution.displayTable(orders3)) {\n        cout << \"[\";\n        for (const auto& item : order) {\n            cout << \"\\\"\" << item << \"\\\"\";\n            if (&item != &order.back()) cout << \", \";\n        }\n        cout << \"]\";\n        if (&order != &solution.displayTable(orders3).back()) cout << \", \";\n    }\n    cout << \"]\";\n\n    return 0;\n}\n```",
  "510": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, int val) {\n        if (!root) return NULL;\n        \n        TreeNode* cur = root;\n        while (cur && cur->val < val) {\n            cur = cur->right;\n        }\n        \n        if (cur && cur->val == val) {\n            if (!cur->right) return NULL; // no successor\n            cur = cur->right;\n            while (cur && cur->left) cur = cur->left;\n            return cur;\n        } else {\n            return cur;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(2);\n    root1->right = new TreeNode(5);\n    root1->right->left = new TreeNode(3);\n    root1->right->right = new TreeNode(4);\n\n    cout << \"Test case 1: Root is 2, value to find is 2. Expected result: NULL, actual result: \";\n    if (solution.inorderSuccessor(root1, 2) == NULL) {\n        cout << \"PASS\" << endl;\n    } else {\n        cout << \"FAIL\" << endl;\n    }\n    \n    TreeNode* root2 = new TreeNode(5);\n    root2->right = new TreeNode(6);\n\n    cout << \"Test case 2: Root is 5, value to find is 6. Expected result: 6, actual result: \";\n    if (solution.inorderSuccessor(root2, 6) == root2->right) {\n        cout << \"PASS\" << endl;\n    } else {\n        cout << \"FAIL\" << endl;\n    }\n\n    TreeNode* root3 = new TreeNode(5);\n    root3->left = new TreeNode(1);\n    root3->right = new TreeNode(7);\n\n    cout << \"Test case 3: Root is 5, value to find is 6. Expected result: NULL, actual result: \";\n    if (solution.inorderSuccessor(root3, 6) == NULL) {\n        cout << \"PASS\" << endl;\n    } else {\n        cout << \"FAIL\" << endl;\n    }\n\n    return 0;\n}\n```",
  "512": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int calculateHiscores(vector<vector<int>>& scores) {\n        int total = 0;\n        for (auto& row : scores) {\n            int sum = 0;\n            for (int score : row) {\n                sum += score;\n            }\n            total += sum;\n        }\n        return total;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> scores1 = {{10, 20}, {30, 40}};\n    int result1 = solution.calculateHiscores(scores1);\n    cout << \"Test case 1: The hiscore is \" << result1 << endl;\n\n    // Test case 2\n    vector<vector<int>> scores2 = {{50, 60, 70}, {80, 90}};\n    int result2 = solution.calculateHiscores(scores2);\n    cout << \"Test case 2: The hiscore is \" << result2 << endl;\n\n    // Test case 3\n    vector<vector<int>> scores3 = {};\n    int result3 = solution.calculateHiscores(scores3);\n    cout << \"Test case 3: The hiscore is \" << result3 << endl;\n\n    return 0;\n}\n```",
  "513": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        if (!root) return 0;\n        queue<TreeNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            int n = q.size();\n            for (int i = 0; i < n; ++i) {\n                TreeNode* node = q.front(); q.pop();\n                if (i == 0) return node->val;\n                if (node->right) q.push(node->right);\n                if (node->left) q.push(node->left);\n            }\n        }\n        return 0;\n    }\n};\n\nint main() {\n    Solution solution;\n    TreeNode* root1 = new TreeNode(2);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(4);\n    root1->right->left = new TreeNode(3);\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(0);\n\n    TreeNode* root3 = new TreeNode(5);\n    root3->left = new TreeNode(3);\n    root3->right = new TreeNode(7);\n    root3->left->left = new TreeNode(4);\n    root3->left->right = new TreeNode(6);\n\n    cout << \"Test case 1: Root is \" << solution.findBottomLeftValue(root1) << endl;\n    cout << \"Test case 2: Root is \" << solution.findBottomLeftValue(root2) << endl;\n    cout << \"Test case 3: Root is \" << solution.findBottomLeftValue(root3) << endl;\n\n    return 0;\n}\n```",
  "514": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxFreedom(vector<string>& tiles) {\n        int res = 0;\n        for (int i = 1; i < tiles.size(); ++i) {\n            if (tiles[i][0] == tiles[i-1][0]) {\n                res++;\n                i++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> tiles1 = {\"blackboard\", \"whiteboard\", \"blackboard\", \"whiteboard\"};\n    cout << solution.maxFreedom(tiles1) << endl;  // Output: 2\n\n    vector<string> tiles2 = {\"abbbaba\", \"bababa\", \"abbbaba\", \"bababa\", \"abbbaba\", \"bababa\"};\n    cout << solution.maxFreedom(tiles2) << endl;  // Output: 3\n\n    vector<string> tiles3 = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"};\n    cout << solution.maxFreedom(tiles3) << endl;  // Output: 0\n\n    return 0;\n}\n```",
  "516": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint longestPalindromicSubseq(string s) {\n    int n = s.length();\n    vector<vector<int>> dp(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n    for (int cl = 2; cl <= n; cl++) {\n        for (int i = 0; i <= n - cl; i++) {\n            int j = i + cl - 1;\n            if (s[i] == s[j] && cl == 2) {\n                dp[i][j] = 2;\n            } else if (s[i] == s[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 2;\n            } else {\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) + 1;\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n\nint main() {\n    cout << \"Test case 1: \" << longestPalindromicSubseq(\"babad\") << endl; // Expected output: 3\n    cout << \"Test case 2: \" << longestPalindromicSubseq(\"cbbd\") << endl; // Expected output: 2\n    cout << \"Test case 3: \" << longestPalindromicSubseq(\"a\") << endl; // Expected output: 1\n    return 0;\n}\n```",
  "517": "```\n#include <iostream>\n#include <vector>\n\nint maxAffinity(std::vector<int>& times) {\n    int n = times.size();\n    if (n <= 2) return n;\n\n    std::vector<int> dp(n, 1);\n    for (int i = 2; i < n; ++i) {\n        dp[i] = (times[i-1] - times[i-2]) >= (times[n-1] - times[i-1])\n                ? dp[i-1] + 1\n                : dp[i-2] + 1;\n    }\n    return *std::max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    std::vector<int> test1 = {1,4,20};\n    std::cout << \"Test 1: \" << maxAffinity(test1) << \"\\n\";\n    \n    std::vector<int> test2 = {1,2,3,4};\n    std::cout << \"Test 2: \" << maxAffinity(test2) << \"\\n\";\n\n    std::vector<int> test3 = {20,50,10,60};\n    std::cout << \"Test 3: \" << maxAffinity(test3) << \"\\n\";\n    \n    return 0;\n}\n```",
  "515": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    std::vector<int> largestValues(TreeNode* root) {\n        if (root == NULL) return {};\n        \n        std::vector<std::vector<TreeNode*>> levels;\n        int level = 0;\n        std::vector<TreeNode*> currentLevel;\n        \n        TreeNode *p = root;\n        while (p != NULL) {\n            if (p->left != NULL || p->right != NULL) {\n                if (levels.size() <= level) {\n                    levels.push_back({});\n                }\n                levels[level].push_back(p);\n            } else {\n                currentLevel.push_back(p);\n            }\n            \n            if (p->left != NULL) p = p->left;\n            else if (p->right != NULL) p = p->right;\n            else {\n                while (!currentLevel.empty()) {\n                    TreeNode *temp = currentLevel.back();\n                    currentLevel.pop_back();\n                    if (temp->left != NULL || temp->right != NULL) p = temp;\n                    else break;\n                }\n                if (p == NULL) break;\n            }\n        }\n        \n        std::vector<int> result;\n        for (int i = 0; i < levels.size(); ++i) {\n            int maxVal = INT_MIN;\n            for (TreeNode *node : levels[i]) {\n                maxVal = std::max(maxVal, node->val);\n            }\n            result.push_back(maxVal);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(2);\n    root1->left->left = new TreeNode(5);\n    root1->left->right = new TreeNode(4);\n    std::vector<int> expected1 = {1, 2, 3};\n    auto result1 = solution.largestValues(root1);\n    for (int i = 0; i < result1.size(); ++i) {\n        if (result1[i] != expected1[i]) {\n            std::cout << \"Test Case 1 failed!\" << std::endl;\n            return 1;\n        }\n    }\n\n    // Test Case 2\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(4);\n    root2->right = new TreeNode(8);\n    root2->left->left = new TreeNode(11);\n    root2->left->right = new TreeNode(13);\n    root2->right = new TreeNode(4);\n    root2->right->left = new TreeNode(7);\n    root2->right->right = new TreeNode(2);\n    std::vector<int> expected2 = {5, 8, 11};\n    auto result2 = solution.largestValues(root2);\n    for (int i = 0; i < result2.size(); ++i) {\n        if (result2[i] != expected2[i]) {\n            std::cout << \"Test Case 2 failed!\" << std::endl;\n            return 1;\n        }\n    }\n\n    // Test Case 3\n    TreeNode* root3 = new TreeNode(6);\n    root3->left = new TreeNode(5);\n    root3->right = new TreeNode(9);\n    root3->left->left = new TreeNode(8);\n    root3->left->right = new TreeNode(7);\n    std::vector<int> expected3 = {6, 9};\n    auto result3 = solution.largestValues(root3);\n    for (int i = 0; i < result3.size(); ++i) {\n        if (result3[i] != expected3[i]) {\n            std::cout << \"Test Case 3 failed!\" << std::endl;\n            return 1;\n        }\n    }\n\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}\n```",
  "518": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<vector<int>> dp(amount + 1, vector<int>(coins.size() + 1, 0));\n        \n        for (int i = 0; i <= coins.size(); i++) {\n            dp[0][i] = 1;\n        }\n        \n        for (int i = 1; i <= amount; i++) {\n            for (int j = 0; j <= coins.size(); j++) {\n                if (j == 0) {\n                    dp[i][j] = dp[i - 1][j];\n                } else if (i >= coins[j]) {\n                    dp[i][j] = dp[i][j - 1] + dp[i - coins[j]][j];\n                } else {\n                    dp[i][j] = dp[i][j - 1];\n                }\n            }\n        }\n        \n        return dp[amount][coins.size()];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << solution.change(5, vector<int>{1, 2, 5}) << endl; // Output: 4\n    cout << solution.change(3, vector<int>{2}) << endl; // Output: 0\n    cout << solution.change(10, vector<int>{1, 2, 5}) << endl; // Output: 14\n    \n    return 0;\n}\n```",
  "519": "```\n#include <iostream>\n#include <vector>\n#include <random>\n\nclass Solution {\npublic:\n    std::vector<int> flipAndStack(std::vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        if (m == 0) return {};\n        int n = matrix[0].size();\n\n        std::vector<int> result;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 1) {\n                    if ((i + j) % 2 == 0) {\n                        result.push_back(1);\n                    } else {\n                        result.push_back(-1);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::vector<int>> matrix1 = {{0,1},{1,1}};\n    int expected1[] = {0};\n    std::cout << \"Test case 1: \";\n    for (int num : solution.flipAndStack(matrix1)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> matrix2 = {{0,1},{1,0}};\n    int expected2[] = {1};\n    std::cout << \"Test case 2: \";\n    for (int num : solution.flipAndStack(matrix2)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> matrix3 = {{0,1,0},{1,1,1},{0,1,0}};\n    int expected3[] = {1,-1,-1};\n    std::cout << \"Test case 3: \";\n    for (int num : solution.flipAndStack(matrix3)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "520": "```\n#include <iostream>\n#include <string>\n\nbool detectCapitalUse(std::string word) {\n    if (word.empty()) return true;\n    bool isAllUpper = std::all_of(word.begin(), word.end(), ::isupper);\n    bool isAllLower = std::all_of(word.begin(), word.end(), ::islower);\n\n    return isAllUpper || (isAllLower && std::tolower(word[0]) == std::tolower(word[1]));\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << detectCapitalUse(\"USA\") << std::endl; // true\n    std::cout << detectCapitalUse(\"Fla\") << std::endl; // false\n    std::cout << detectCapitalUse(\"Google\") << std::endl; // true\n    return 0;\n}",
  "521": "```\n#include <iostream>\n#include <string>\n\nint findLUSlength(std::string a, std::string b) {\n    if (a == b) return 0;\n    return (a.size() > b.size()) ? a.size() : b.size();\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << findLUSlength(\"abc\", \"def\") << std::endl; // Expected output: 3\n    std::cout << \"Test case 2: \" << findLUSlength(\"aaa\", \"aaa\") << std::endl; // Expected output: 0\n    std::cout << \"Test case 3: \" << findLUSlength(\"xyz\", \"xy\") << std::endl; // Expected output: 2\n\n    return 0;\n}\n```",
  "522": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint findLUSlength(std::vector<std::string>& strs) {\n    int max = -1;\n    for (const auto& str : strs) {\n        bool isUncommon = true;\n        for (const auto& s : strs) {\n            if (s != str && std::count(s.begin(), s.end(), str[0]) > 0)\n                isUncommon = false;\n        }\n        if (isUncommon) max = std::max(max, static_cast<int>(str.length()));\n    }\n    return max;\n}\n\nint main() {\n    std::vector<std::string> strs1 = {\"cool\",\"lock\",\"cook\"};\n    std::cout << \"Test case 1: \" << findLUSlength(strs1) << std::endl;\n\n    std::vector<std::string> strs2 = {\"aba\",\"cdcd\"};\n    std::cout << \"Test case 2: \" << findLUSlength(strs2) << std::endl;\n\n    std::vector<std::string> strs3 = {\"aaa\",\"bbb\",\"ccc\"};\n    std::cout << \"Test case 3: \" << findLUSlength(strs3) << std::endl;\n\n    return 0;\n}\n```",
  "523": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    bool checkSubarraySum(std::vector<int>& nums, int k) {\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            int sum = 0;\n            for (int j = i; j < n; ++j) {\n                sum += nums[j];\n                if ((sum % k == 0 && j > i) || k == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> test1 = {23, 2, 4, 6, 7};\n    int test1k = 6;\n    if (solution.checkSubarraySum(test1, test1k)) {\n        std::cout << \"Test case 1: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Fail\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> test2 = {23, 2, 2, 4, 6];\n    int test2k = 0;\n    if (solution.checkSubarraySum(test2, test2k)) {\n        std::cout << \"Test case 2: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Fail\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> test3 = {0};\n    int test3k = 0;\n    if (solution.checkSubarraySum(test3, test3k)) {\n        std::cout << \"Test case 3: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Fail\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "524": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string findLongestWord(vector<string>& words, string s) {\n        vector<string> res;\n        for (auto word : words) {\n            int i = 0, j = 0;\n            while (i < word.size() && j < s.size()) {\n                if (word[i] == s[j]) {\n                    i++;\n                }\n                j++;\n            }\n            if (i == word.size())\n                res.push_back(word);\n        }\n        sort(res.begin(), res.end());\n        return *res.rbegin();\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> words1 = {\"w\",\"wo\",\"wor\",\"world\"};\n    string s1 = \"world\";\n    cout << solution.findLongestWord(words1, s1) << endl;\n\n    vector<string> words2 = {\"a\",\"apple\",\"app\",\"appl\"};\n    string s2 = \"ap\";\n    cout << solution.findLongestWord(words2, s2) << endl;\n\n    vector<string> words3 = {\"apple\",\"banana\",\"orange\",\"pple\"};\n    string s3 = \"le\";\n    cout << solution.findLongestWord(words3, s3) << endl;\n}\n```",
  "526": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int countArrangement(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            if (isPrime(i)) {\n                bool flag = true;\n                int temp = i;\n                while (temp > 0) {\n                    int lastDigit = temp % 10;\n                    if (lastDigit == 0 || lastDigit != 2 && lastDigit != 3 && lastDigit != 5 && lastDigit != 7) {\n                        flag = false;\n                        break;\n                    }\n                    temp /= 10;\n                }\n                if (flag) res++;\n            }\n        }\n        return res;\n    }\n\n    bool isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test case 1: \" << solution.countArrangement(2) << std::endl;\n    std::cout << \"Test case 2: \" << solution.countArrangement(3) << std::endl;\n    std::cout << \"Test case 3: \" << solution.countArrangement(9) << std::endl;\n\n    return 0;\n}\n```",
  "525": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxUnConfused(int n, vector<int>& blacklist) {\n        set<int> blackSet(blacklist.begin(), blacklist.end());\n        vector<int> res(n);\n        for (int i = 0; i < n; ++i) {\n            if (!blackSet.count(i)) {\n                res[i] = 1;\n                for (int j = i + 1; j <= n; ++j) {\n                    if (blackSet.count(j - 1)) {\n                        res[j - 1] = 1;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        int maxLen = 0, left = -1, right = -1;\n        for (int i = 0; i < n; ++i) {\n            if (!blackSet.count(i)) {\n                if (left == -1) {\n                    left = i;\n                } else {\n                    right = i;\n                    maxLen = max(maxLen, right - left + 1);\n                }\n            } else {\n                if (left != -1) {\n                    left = -1;\n                    right = -1;\n                }\n            }\n        }\n        return maxLen;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1\n    int n1 = 5;\n    vector<int> blacklist1 = {2, 3};\n    cout << \"Test Case 1: \" << s.maxUnConfused(n1, blacklist1) << endl;\n\n    // Test case 2\n    int n2 = 10;\n    vector<int> blacklist2 = {};\n    cout << \"Test Case 2: \" << s.maxUnConfused(n2, blacklist2) << endl;\n\n    // Test case 3\n    int n3 = 12;\n    vector<int> blacklist3 = {1};\n    cout << \"Test Case 3: \" << s.maxUnConfused(n3, blacklist3) << endl;\n\n    return 0;\n}\n```",
  "528": "```\n#include <iostream>\n#include <vector>\n#include <random>\n\nclass Solution {\npublic:\n    std::vector<int> randomPickIndex(std::vector<int>& w) {\n        int total = 0;\n        for (int weight : w) {\n            total += weight;\n        }\n        \n        std::random_device rd;\n        std::mt19937 gen(rd());\n        std::uniform_int_distribution<> dis(1, total);\n        \n        int target = dis(gen);\n        for (int i = 0; i < w.size(); i++) {\n            if (target <= w[i]) {\n                return {i};\n            }\n            target -= w[i];\n        }\n        \n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<int> weights1 = {1,3,5,2};\n    int target1 = 6;\n    for (auto& index : solution.randomPickIndex(weights1)) {\n        std::cout << \"Test Case 1: Random Pick Index is \" << index << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<int> weights2 = {10,11,12};\n    int target2 = 33;\n    for (auto& index : solution.randomPickIndex(weights2)) {\n        std::cout << \"Test Case 2: Random Pick Index is \" << index << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<int> weights3 = {1,4};\n    int target3 = 8;\n    for (auto& index : solution.randomPickIndex(weights3)) {\n        std::cout << \"Test Case 3: Random Pick Index is \" << index << std::endl;\n    }\n\n    return 0;\n}",
  "527": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<std::string> wordAbbreviation(std::vector<std::string>& words) {\n        int n = words.size();\n        std::vector<std::string> result(n);\n        \n        for (int i = 0; i < n; ++i) {\n            int abbrevLength = 1;\n            while (abbrevLength <= words[i].size() && !isalnum(words[i][words[i].size() - abbrevLength])) {\n                ++abbrevLength;\n            }\n            \n            if (abbrevLength > 1) {\n                result[i] = words[i].substr(0, words[i].size() - abbrevLength + 1) + std::to_string(i);\n            } else {\n                result[i] = words[i];\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::string> words1 = {\"internationalization\", \"undeclared\"};\n    for (const auto& word : solution.wordAbbreviation(words1)) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<std::string> words2 = {\"word\", \"words\", \"wordly\"};\n    for (const auto& word : solution.wordAbbreviation(words2)) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<std::string> words3 = {\"a1b2\", \"a12b\"};\n    for (const auto& word : solution.wordAbbreviation(words3)) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "530": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int getMinimumDifference(TreeNode* root) {\n        vector<int> vals;\n        inorder(root, vals);\n        int minDiff = INT_MAX;\n        for (int i = 0; i < vals.size() - 1; i++) {\n            minDiff = min(minDiff, vals[i + 1] - vals[i]);\n        }\n        return minDiff;\n    }\n\nprivate:\n    void inorder(TreeNode* node, vector<int>& vals) {\n        if (node == NULL) return;\n        inorder(node->left, vals);\n        vals.push_back(node->val);\n        inorder(node->right, vals);\n    }\n};\n\nint main() {\n    Solution solution;\n    TreeNode* root1 = new TreeNode(4);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(6);\n    root1->left->left = new TreeNode(1);\n    root1->left->right = new TreeNode(3);\n    cout << \"Test case 1: \" << solution.getMinimumDifference(root1) << endl;\n\n    TreeNode* root2 = new TreeNode(8);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(10);\n    root2->right->left = new TreeNode(1);\n    root2->right->right = new TreeNode(6);\n    cout << \"Test case 2: \" << solution.getMinimumDifference(root2) << endl;\n\n    TreeNode* root3 = new TreeNode(4);\n    cout << \"Test case 3: \" << solution.getMinimumDifference(root3) << endl;\n    \n    return 0;\n}\n```",
  "529": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> updateBoard(vector<vector<char>>& board, vector<int> start) {\n        int m = board.size(), n = board[0].size();\n        int dx[] = {-1, 1, -1, 1, 0, 0};\n        int dy[] = {-1, 1, 0, 0, -1, 1};\n        \n        function<void(int, int)> dfs = [&](int i, int j) {\n            if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != 'E') return;\n            \n            board[i][j] = 'B';\n            for (int k = 0; k < 6; ++k) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (ni >= 0 && ni < m && nj >= 0 && nj < n && board[ni][nj] == 'M') {\n                    board[i][j] = '#';\n                    return;\n                }\n            }\n            \n            int cnt = 0;\n            for (int k = 0; k < 6; ++k) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (ni >= 0 && ni < m && nj >= 0 && nj < n && board[ni][nj] == 'E') {\n                    ++cnt;\n                }\n            }\n            \n            if (cnt > 0) {\n                board[i][j] = '1' + cnt;\n            } else {\n                dfs(i, j);\n            }\n        };\n        \n        dfs(start[0], start[1]);\n        return board;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<char>> board1 = {{'E', 'E', 'E', 'E', 'E'}, {'E', '0', '0', '0', 'E'}, \n                                   {'E', '0', 'M', '0', 'E'}, {'E', '0', '0', '0', 'E'}, \n                                   {'E', 'E', 'E', 'E', 'E'}};\n    vector<int> start1 = {3, 1};\n    vector<vector<int>> result1 = solution.updateBoard(board1, start1);\n    for (auto row : result1) {\n        for (char c : row) {\n            cout << c << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test Case 2\n    vector<vector<char>> board2 = {{'E', '0', '0'}, {'E', '0', 'M'}, {'E', 'E', '0'}};\n    vector<int> start2 = {1, 2};\n    vector<vector<int>> result2 = solution.updateBoard(board2, start2);\n    for (auto row : result2) {\n        for (char c : row) {\n            cout << c << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test Case 3\n    vector<vector<char>> board3 = {{'E', 'E', '0'}, {'M', '1', '0'}, {'E', '1', 'E'}};\n    vector<int> start3 = {1, 1};\n    vector<vector<int>> result3 = solution.updateBoard(board3, start3);\n    for (auto row : result3) {\n        for (char c : row) {\n            cout << c << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "532": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint findKthPair(std::vector<int>& nums, int k) {\n    std::unordered_map<int, int> count;\n    for (int num : nums) {\n        count[num] = count.count(num) + 1;\n    }\n    \n    int pairs = 0;\n    for (auto& pair : count) {\n        if (pair.second > 1 && k - pair.first >= 0) {\n            int right = pair.first + k;\n            int left = pair.first - k;\n            int leftCount = count.count(left);\n            int rightCount = count.count(right);\n            \n            pairs += std::min(leftCount, rightCount);\n        }\n    }\n    \n    return pairs;\n}\n\nint main() {\n    std::vector<int> nums1 = {3, 1, 4, 1, 5};\n    std::cout << \"Test case 1: \" << findKthPair(nums1, 2) << std::endl; // Output: 2\n\n    std::vector<int> nums2 = {1, 3, 1, 5, 16};\n    std::cout << \"Test case 2: \" << findKthPair(nums2, 4) << std::endl; // Output: 3\n\n    std::vector<int> nums3 = {2, 2, 2, 10, 10, 20, 40];\n    std::cout << \"Test case 3: \" << findKthPair(nums3, 0) << std::endl; // Output: 12\n}\n```",
  "531": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findLonelyPixel(vector<vector<char>>& picture) {\n        vector<int> rowCounts(1001, 0);\n        vector<int> colCounts(1001, 0);\n\n        for (int i = 0; i < picture.size(); i++) {\n            for (int j = 0; j < picture[0].size(); j++) {\n                if (picture[i][j] == 'B') {\n                    rowCounts[i]++;\n                    colCounts[j]++;\n                }\n            }\n        }\n\n        int maxCountRow = -1, maxCountCol = -1;\n        for (int i = 0; i < rowCounts.size(); i++) {\n            if (rowCounts[i] > 0 && rowCounts[i] > maxCountRow) {\n                maxCountRow = rowCounts[i];\n            }\n        }\n\n        for (int j = 0; j < colCounts.size(); j++) {\n            if (colCounts[j] > 0 && colCounts[j] > maxCountCol) {\n                maxCountCol = colCounts[j];\n            }\n        }\n\n        int count = 0;\n        for (int i = 0; i < picture.size(); i++) {\n            for (int j = 0; j < picture[0].size(); j++) {\n                if (picture[i][j] == 'B' && rowCounts[i] == 1 && colCounts[j] == 1) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<char>> picture1 = {{\"W\",\"W\",\"B\",\"W\",\"B\"},\n                                       {\"W\",\"W\",\"W\",\"W\",\"W\"},\n                                       {\"B\",\"B\",\"B\",\"B\",\"B\"}};\n    cout << \"Test case 1: \" << solution.findLonelyPixel(picture1) << endl;\n\n    // Test case 2\n    vector<vector<char>> picture2 = {{'A', 'A', 'B', 'B', 'C'},\n                                      {'A', 'B', 'B', 'B', 'C'},\n                                      {'B', 'B', 'B', 'B', 'C'}};\n    cout << \"Test case 2: \" << solution.findLonelyPixel(picture2) << endl;\n\n    // Test case 3\n    vector<vector<char>> picture3 = {{'B', 'B', 'B'},\n                                      {'B', 'B', 'B'},\n                                      {'B', 'B', 'B'}};\n    cout << \"Test case 3: \" << solution.findLonelyPixel(picture3) << endl;\n\n    return 0;\n}\n```",
  "533": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findLonelyPixel(vector<vector<char>>& picture) {\n        int m = picture.size();\n        if(m == 0) return 0;\n        \n        vector<int> rowCounts(m, 0);\n        vector<bool> isCenter(m, false);\n\n        for(int i = 0; i < m; ++i) {\n            for(int j = 0; j < picture[i].size(); ++j) {\n                if(picture[i][j] == 'B') {\n                    rowCounts[i]++;\n                    isCenter[i] = true;\n                }\n            }\n        }\n\n        int maxRowCount = 0;\n        int lonelyPixelCount = 0;\n\n        for(int i = 0; i < m; ++i) {\n            if(rowCounts[i] > 0 && !isCenter[i]) {\n                maxRowCount = rowCounts[i];\n                break;\n            }\n        }\n\n        for(int i = 0; i < m; ++i) {\n            for(int j = 0; j < picture[i].size(); ++j) {\n                if(picture[i][j] == 'B' && (rowCounts[i] == maxRowCount || !isCenter[i])) {\n                    lonelyPixelCount++;\n                }\n            }\n        }\n\n        return lonelyPixelCount;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<char>> picture1 = {{ \"W\", \"W\", \"B\", \"W\" }, {\"W\", \"B\", \"W\", \"W\"}, {\"B\", \"W\", \"W\", \"W\"}};\n    cout << \"Test case 1: \" << solution.findLonelyPixel(picture1) << endl;\n\n    // Test case 2\n    vector<vector<char>> picture2 = {{ \"W\", \"W\", \"B\" }, {\"W\", \"B\", \"W\"}, {\"B\", \"W\", \"W\"}};\n    cout << \"Test case 2: \" << solution.findLonelyPixel(picture2) << endl;\n\n    // Test case 3\n    vector<vector<char>> picture3 = {{ \"B\" }};\n    cout << \"Test case 3: \" << solution.findLonelyPixel(picture3) << endl;\n\n    return 0;\n}\n```",
  "534": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        unordered_map<int, bool> mp;\n        vector<vector<int>> res;\n        \n        for (int num : nums) {\n            if (mp.find(num - k) != mp.end() || mp.find(num + k) != mp.end()) {\n                res.push_back({num - k >= 0 ? num - k : k, num});\n            }\n            mp[num] = true;\n        }\n        \n        return res.size();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {1,3,1};\n    int k1 = 3;\n    cout << \"Test case 1: \" << solution.findPairs(nums1, k1) << endl;\n\n    // Test case 2\n    vector<int> nums2 = {1,1,3,4];\n    int k2 = 3;\n    cout << \"Test case 2: \" << solution.findPairs(nums2, k2) << endl;\n\n    // Test case 3\n    vector<int> nums3 = {[0 ... 10][]{rand() % 100}};\n    int k3 = 2;\n    cout << \"Test case 3: \" << solution.findPairs(nums3, k3) << endl;\n\n    return 0;\n}\n```",
  "535": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    std::string encode(const std::string& longUrl) {\n        if (longUrl.empty()) return \"\";\n        \n        std::unordered_map<std::string, std::string> map;\n        int counter = 0;\n        \n        for (char c : longUrl) {\n            if (c == ' ') {\n                counter++;\n            }\n        }\n        \n        for (int i = 0; i <= counter; i++) {\n            map[longUrl.substr(0, longUrl.find(' '))] = \"http://tinyurl.com/\" + std::to_string(i);\n            longUrl.erase(0, longUrl.find(' ') + 1);\n        }\n        \n        return map[longUrl];\n    }\n\n    std::string originalUrl(const std::string& shortUrl) {\n        if (shortUrl.empty()) return \"\";\n        \n        int index = -1;\n        for (char c : shortUrl) {\n            if (c == '0' || c == '1' || c == '2' || c == '3' || c == '4' ||\n                c == '5' || c == '6' || c == '7' || c == '8' || c == '9') {\n                index++;\n            }\n        }\n        \n        return \"http://tinyurl.com/\" + shortUrl.substr(index + 1);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::cout << \"Test case 1: \";\n    std::string longUrl = \"https://www.example.com/this-is-a-long-url\";\n    std::cout << solution.encode(longUrl) << std::endl;\n    \n    std::cout << \"Test case 2: \";\n    std::string shortUrl = \"http://tinyurl.com/4r5vQq\";\n    std::cout << solution.originalUrl(shortUrl) << std::endl;\n    \n    std::cout << \"Test case 3: \";\n    longUrl = \"https://www.example.com-this-is-a-long-url-123\";\n    std::cout << solution.encode(longUrl) << std::endl;\n    \n    return 0;\n}\n```",
  "536": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* str2tree(string s) {\n        if (s.empty()) return nullptr;\n\n        int n = s.size();\n        long long num = 0;\n        bool isNeg = false;\n        if (s[0] == '-') {\n            isNeg = true;\n            num = -1;\n        } else {\n            num = 1;\n        }\n\n        for (int i = 1; i < n; ++i) {\n            if (isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0');\n            } else {\n                TreeNode* root = new TreeNode((int)(num));\n                if (i == n - 1 || s[i + 1] == '(') return root;\n\n                int j = i;\n                while (j < n && s[j] != ',') ++j;\n                string leftStr = s.substr(i, j - i);\n\n                i = j;\n                while (i < n && s[i] != '(') ++i;\n                string rightStr = s.substr(i + 1, j - i - 2);\n                i = j;\n\n                root->left = str2tree(leftStr);\n                root->right = str2tree(rightStr);\n\n                return root;\n            }\n        }\n\n        TreeNode* root = new TreeNode((int)(num));\n        if (n > 1) return root;\n\n        return nullptr;\n    }\n};\n\nint main() {\n    Solution s;\n    string test1 = \"3,9,#,#,1\";\n    TreeNode* t1 = s.str2tree(test1);\n    // Output: [3,9,1]\n\n    string test2 = \"0,8,4,#,#,5,1,#,#,12,#,6\";\n    TreeNode* t2 = s.str2tree(test2);\n    // Output: [0,8,4,5,1,12,null,null,6]\n\n    string test3 = \"#,2,3,#,#\";\n    TreeNode* t3 = s.str2tree(test3);\n    // Output: []\n\n    return 0;\n}\n```",
  "537": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Complex {\npublic:\n    int real;\n    int imag;\n};\n\nComplex multiply(Complex c1, Complex c2) {\n    return Complex{(c1.real * c2.real) - (c1.imag * c2.imag), \n                   (c1.real * c2.imag) + (c1.imag * c2.real)};\n}\n\nint main() {\n    Complex test1 = {1, 1};\n    Complex test2 = {1, 2};\n    Complex test3 = {-1, -1};\n\n    Complex result1 = multiply(test1, test2);\n    Complex result2 = multiply(result1, test3);\n    Complex result3 = multiply(test1, test3);\n\n    cout << \"Test Case 1: \" << test1.real << \" + \" << test1.imag << \"i * (\" << test2.real << \" + \" << test2.imag << \"i) = \" << result1.real << \" + \" << result1.imag << \"i\" << endl;\n    cout << \"Expected Result: \" << (test1.real*test2.real)-(test1.imag*test2.imag) << \" + (\" << test1.real*test2.imag << \"+\" << test1.imag*test2.real << \")i\" << endl;\n    cout << \"Actual Result: \" << result1.real << \" + \" << result1.imag << \"i\" << endl;\n\n    cout << \"Test Case 2: \" << result1.real << \" + \" << result1.imag << \"i * (\" << test3.real << \" + \" << test3.imag << \"i) = \" << result2.real << \" + \" << result2.imag << \"i\" << endl;\n    cout << \"Expected Result: \" << ((test1.real*result1.real)-(test1.imag*result1.imag)) - (test1.imag*result1.imag) + (test1.real*result1.imag) + (test1.imag*result1.real) << \" + (\" << (test1.real*result1.imag) + (test1.imag*result1.real) << \")i\" << endl;\n    cout << \"Actual Result: \" << result2.real << \" + \" << result2.imag << \"i\" << endl;\n\n    cout << \"Test Case 3: \" << test1.real << \" + \" << test1.imag << \"i * (\" << test3.real << \" + \" << test3.imag << \"i) = \" << result3.real << \" + \" << result3.imag << \"i\" << endl;\n    cout << \"Expected Result: \" << ((test1.real*test3.real)-(test1.imag*test3.imag)) - (test1.imag*test3.imag) + (test1.real*test3.imag) + (test1.imag*test3.real) << \" + (\" << (test1.real*test3.imag) + (test1.imag*test3.real) << \")i\" << endl;\n    cout << \"Actual Result: \" << result3.real << \" + \" << result3.imag << \"i\" << endl;\n\n    return 0;\n}\n```",
  "538": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    void convertBST(TreeNode* root, long long &sum) {\n        if (!root) return;\n        convertBST(root->right, sum);\n        sum += root->val;\n        root->val = sum;\n        convertBST(root->left, sum);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* test1Root = new TreeNode(5);\n    test1Root->right = new TreeNode(2);\n    test1Root->right->right = new TreeNode(3);\n    long long sum = 0;\n    solution.convertBST(test1Root, sum);\n    cout << \"Test case 1: \";\n    for (TreeNode* node = test1Root; node != NULL; node = node->right) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    TreeNode* test2Root = new TreeNode(10);\n    test2Root->left = new TreeNode(3);\n    test2Root->left->left = new TreeNode(1);\n    test2Root->right = new TreeNode(8);\n    sum = 0;\n    solution.convertBST(test2Root, sum);\n    cout << \"Test case 2: \";\n    for (TreeNode* node = test2Root; node != NULL; node = node->right) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    TreeNode* test3Root = new TreeNode(1);\n    sum = 0;\n    solution.convertBST(test3Root, sum);\n    cout << \"Test case 3: \";\n    for (TreeNode* node = test3Root; node != NULL; node = node->right) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
  "539": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint findMinDifference(std::vector<std::string>& watchTimes) {\n    std::vector<int> times;\n    for (const auto& time : watchTimes) {\n        int hour = std::stoi(time.substr(0, 2));\n        int minute = std::stoi(time.substr(3, 4));\n        times.push_back(hour * 60 + minute);\n    }\n    std::sort(times.begin(), times.end());\n\n    int minDiff = (times[1] - times[0]);\n    for (int i = 1; i < times.size() - 1; ++i) {\n        minDiff = std::min(minDiff, times[i + 1] - times[i]);\n    }\n    return std::min(minDiff, 24 * 60 - times.back() + times.front());\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::string> watchTimes1 = {\"02:15\", \"08:00\"};\n    std::cout << findMinDifference(watchTimes1) << std::endl;\n\n    // Test case 2\n    std::vector<std::string> watchTimes2 = {\"05:41\", \"21:15\", \"03:24\"};\n    std::cout << findMinDifference(watchTimes2) << std::endl;\n\n    // Test case 3\n    std::vector<std::string> watchTimes3 = {\"00:05\", \"23:59\"};\n    std::cout << findMinDifference(watchTimes3) << std::endl;\n}\n```",
  "540": "```\n#include <iostream>\n#include <vector>\n\nint singleNonDuplicate(std::vector<int>& nums) {\n    int left = 0;\n    int right = nums.size() - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n\n        if ((mid % 2 == 1) && (nums[mid] == nums[mid-1])) {\n            left = mid+1;\n        } else if ((mid % 2 == 0) && (nums[mid] == nums[mid+1])) {\n            right = mid;\n        } else if (mid % 2 == 1) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return nums[left];\n}\n\nint main() {\n    // Test Case 1\n    std::vector<int> nums1 = {1, 1, 2};\n    int result1 = singleNonDuplicate(nums1);\n    if (result1 == 2) {\n        std::cout << \"Test Case 1: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1: Fail\" << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<int> nums2 = {1, 1];\n    int result2 = singleNonDuplicate(nums2);\n    if (result2 == -1) {\n        std::cout << \"Test Case 2: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2: Fail\" << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<int> nums3 = {1, 1, 1, 2};\n    int result3 = singleNonDuplicate(nums3);\n    if (result3 == 2) {\n        std::cout << \"Test Case 3: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3: Fail\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "541": "```\n#include <iostream>\n#include <string>\n\nvoid reverseStr(std::string& s, int left, int right) {\n    while (left < right) {\n        std::swap(s[left], s[right]);\n        left++;\n        right--;\n    }\n}\n\nint main() {\n    std::string s1 = \"abcdef\";\n    reverseStr(s1, 2, 5);\n    if (s1 != \"acfedb\") {\n        std::cout << \"Test case 1 failed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 passed\" << std::endl;\n    }\n\n    std::string s2 = \"hello\";\n    reverseStr(s2, 0, 4);\n    if (s2 != \"olleh\") {\n        std::cout << \"Test case 2 failed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 passed\" << std::endl;\n    }\n\n    std::string s3 = \"abcd\";\n    reverseStr(s3, 1, 3);\n    if (s3 != \"bacd\") {\n        std::cout << \"Test case 3 failed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 passed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "542": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        if (m == 0) return {};\n        int n = matrix[0].size();\n        vector<vector<int>> res(m, vector<int>(n));\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (matrix[i][j] == 0) {\n                    dfs(res, matrix, i, j);\n                }\n            }\n        }\n\n        for (int i = m - 1; i >= 0; --i) {\n            for (int j = n - 1; j >= 0; --j) {\n                if (matrix[i][j] == 0) {\n                    dfs(res, matrix, i, j);\n                }\n            }\n        }\n\n        return res;\n    }\n\nprivate:\n    void dfs(vector<vector<int>>& res, vector<vector<int>>& matrix, int x, int y) {\n        if (x < 0 || x >= matrix.size() || y < 0 || y >= matrix[0].size()) {\n            return;\n        }\n        if (res[x][y] != 0) {\n            return;\n        }\n        res[x][y] = 1;\n        int dx[] = {-1, 1, 0, 0};\n        int dy[] = {0, 0, -1, 1};\n        for (int i = 0; i < 4; ++i) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if (nx >= 0 && nx < matrix.size() && ny >= 0 && ny < matrix[0].size()) {\n                if (matrix[nx][ny] == 0) {\n                    dfs(res, matrix, nx, ny);\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> matrix1 = {{0,1},{1,0}};\n    vector<vector<int>> expected1 = {{0,0},{0,1}};\n    assert(solution.updateMatrix(matrix1) == expected1);\n\n    // Test case 2\n    vector<vector<int>> matrix2 = {{0,0,0},{0,1,0}};\n    vector<vector<int>> expected2 = {{0,0,0},{0,1,1}};\n    assert(solution.updateMatrix(matrix2) == expected2);\n\n    // Test case 3\n    vector<vector<int>> matrix3 = {{0,0,0},{1,1,1},{1,1,1}};\n    vector<vector<int>> expected3 = {{0,0,0},{0,1,1},{0,1,1}};\n    assert(solution.updateMatrix(matrix3) == expected3);\n\n    return 0;\n}\n```",
  "543": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int diameterOfBinaryTree(TreeNode* root) {\n        int maxDiameter = 0;\n        depth(root, maxDiameter);\n        return maxDiameter;\n    }\n\n    int depth(TreeNode* node, int& maxDiameter) {\n        if (!node) return 0;\n\n        int leftDepth = depth(node->left, maxDiameter);\n        int rightDepth = depth(node->right, maxDiameter);\n\n        maxDiameter = max(maxDiameter, leftDepth + rightDepth);\n\n        return 1 + max(leftDepth, rightDepth);\n    }\n};\n\nint main() {\n    Solution solution;\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->right->left = new TreeNode(4);\n    root1->right->right = new TreeNode(5);\n\n    cout << \"Test case 1: \" << solution.diameterOfBinaryTree(root1) << endl;\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->right = new TreeNode(2);\n\n    cout << \"Test case 2: \" << solution.diameterOfBinaryTree(root2) << endl;\n\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(3);\n    root3->left->left = new TreeNode(4);\n    root3->left->right = new TreeNode(5);\n\n    cout << \"Test case 3: \" << solution.diameterOfBinaryTree(root3) << endl;\n\n    return 0;\n}",
  "544": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string findContests(vector<string>& keywords) {\n        vector<string> contests;\n        for (int i = 0; i < keywords.size(); i++) {\n            if (i % 2 == 0) {\n                contests.push_back(keywords[i] + \" vs \" + keywords[i+1]);\n            }\n        }\n        return string(\"# \" + join(contests, \"\\n# \"));\n    }\n\n    string join(vector<string>& strs, string sep) {\n        string result = \"\";\n        for (int i = 0; i < strs.size(); i++) {\n            if (i > 0) result += sep;\n            result += strs[i];\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> keywords1 = {\"LeetCode\", \"For\", \"Example\", \"This\", \"Is\", \"The\", \"Contest\", \"Title\"};\n    cout << \"Test Case 1: \" << solution.findContests(keywords1) << endl;\n    cout << \"Expected output: # LeetCode vs For\\n# This vs The\\n# Is vs Contest\\n# Title vs Example\" << endl << endl;\n\n    // Test case 2\n    vector<string> keywords2 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"};\n    cout << \"Test Case 2: \" << solution.findContests(keywords2) << endl;\n    cout << \"Expected output: # a vs b\\n# c vs d\\n# e vs f\" << endl << endl;\n\n    // Test case 3\n    vector<string> keywords3 = {\"LeetCode\", \"Is\", \"The\", \"Best\"};\n    cout << \"Test Case 3: \" << solution.findContests(keywords3) << endl;\n    cout << \"Expected output: # LeetCode vs Is\\n# The vs Best\" << endl;\n\n    return 0;\n}\n```",
  "545": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<int> boundaryOfBinaryTree(TreeNode* root) {\n        if (!root)\n            return {};\n\n        vector<int> result;\n\n        // Left boundary\n        while (root->left) {\n            result.push_back(root->val);\n            root = root->left;\n        }\n\n        // Leaves\n        while (root) {\n            if (root->left || root->right)\n                break;\n            result.push_back(root->val);\n            root = root->left ? root->left : root->right;\n        }\n\n        // Right boundary\n        while (root->right) {\n            result.push_back(root->val);\n            root = root->right;\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->left->left = new TreeNode(4);\n    root1->left->right = new TreeNode(5);\n\n    vector<int> result1 = solution.boundaryOfBinaryTree(root1);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->right = new TreeNode(3);\n    root2->right->left = new TreeNode(2);\n\n    vector<int> result2 = solution.boundaryOfBinaryTree(root2);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    TreeNode* root3 = new TreeNode(1);\n    root3->right = new TreeNode(2);\n\n    vector<int> result3 = solution.boundaryOfBinaryTree(root3);\n    for (int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "546": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int removeBoxes(vector<vector<int>>& boxes) {\n        int res = 0;\n        vector<vector<vector<int>>> dp(boxes.size(), vector<vector<int>>(boxes[0].size(), vector<int>(3)));\n        for (int i = boxes.size() - 1; i >= 0; --i) {\n            for (int j = boxes[i].size() - 1; j >= 0; --j) {\n                if (i < boxes.size() - 1 && j < boxes[i + 1].size() && boxes[i][j] == boxes[i + 1][0]) {\n                    dp[i][j][0] = i > 0 ? min(dp[i - 1][j][2], dp[i - 1][j][0]) : res;\n                } else if (i > 0) {\n                    dp[i][j][0] = max({dp[i - 1][k][0] + boxes[i - 1][k] * k for k in range(j, -1, -1)});\n                } else {\n                    dp[i][j][0] = res;\n                }\n                if (i > 0) {\n                    dp[i][j][1] = min({dp[k][j][1] + boxes[k][j] for k in range(i)});\n                } else {\n                    dp[i][j][1] = res;\n                }\n                if (j < boxes[0].size() - 1 && i > 0) {\n                    dp[i][j][2] = min({dp[k][j + 1][2] + boxes[k][j] for k in range(i)});\n                } else {\n                    dp[i][j][2] = res;\n                }\n                if (i > 0 && j < boxes[0].size() - 1) {\n                    dp[i][j][1] += min({dp[k][j + 1][0] for k in range(i)}) + boxes[i][j];\n                }\n            }\n        }\n        return dp[0][0][0];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<int>> box1 = {{1,3},{2,5},{3,4}};\n    cout << \"Test case 1: \" << solution.removeBoxes(box1) << endl; // Expected output: 10\n\n    vector<vector<int>> box2 = {{1,6},{2,5},{3,3},{4,3}};\n    cout << \"Test case 2: \" << solution.removeBoxes(box2) << endl; // Expected output: 13\n\n    vector<vector<int>> box3 = {{1,1},{2,5},{3,5},{4,4},{5,5}};\n    cout << \"Test case 3: \" << solution.removeBoxes(box3) << endl; // Expected output: 16\n    \n    return 0;\n}\n```",
  "547": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int findCircleNum(std::vector<std::vector<int>>& M) {\n        if (M.empty()) return 0;\n\n        int numProvinces = 0;\n        bool visited[M.size()];\n        for (int i = 0; i < M.size(); i++) {\n            visited[i] = false;\n        }\n\n        for (int i = 0; i < M.size(); i++) {\n            if (!visited[i]) {\n                dfs(M, visited, i);\n                numProvinces++;\n            }\n        }\n\n        return numProvinces;\n    }\n\n    void dfs(std::vector<std::vector<int>>& M, bool visited[], int start) {\n        visited[start] = true;\n\n        for (int j = 0; j < M.size(); j++) {\n            if (M[start][j] == 1 && !visited[j]) {\n                dfs(M, visited, j);\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    std::vector<std::vector<int>> graph1{{1,1,0},{1,1,0},{0,0,1}};\n    std::cout << \"Expected: 2, Actual: \" << solution.findCircleNum(graph1) << std::endl;\n\n    std::vector<std::vector<int>> graph2{{1,0,0},{0,1,0},{0,0,1}};\n    std::cout << \"Expected: 3, Actual: \" << solution.findCircleNum(graph2) << std::endl;\n\n    std::vector<std::vector<int>> graph3{{1,1,0},{1,1,1},{0,1,1}};\n    std::cout << \"Expected: 1, Actual: \" << solution.findCircleNum(graph3) << std::endl;\n    return 0;\n}\n```",
  "548": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> splitArraySum(int targetsum, vector<int>& arr) {\n        int n = arr.size();\n        vector<vector<int>> res;\n        for (int i = 0; i < n; ++i) {\n            int sum1 = 0;\n            vector<int> temp;\n            for (int j = i; j < n; ++j) {\n                sum1 += arr[j];\n                temp.push_back(arr[j]);\n                if (sum1 == targetsum) {\n                    res.push_back(temp);\n                    break;\n                } else if (sum1 > targetsum) {\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<int> arr1 = {6, 3, 2};\n    int targetSum1 = 9;\n    vector<vector<int>> result1 = solution.splitArraySum(targetSum1, arr1);\n    for (auto &v : result1) {\n        for (int i : v) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test Case 2\n    vector<int> arr2 = {9};\n    int targetSum2 = 5;\n    vector<vector<int>> result2 = solution.splitArraySum(targetSum2, arr2);\n    for (auto &v : result2) {\n        for (int i : v) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test Case 3\n    vector<int> arr3 = {9};\n    int targetSum3 = 10;\n    vector<vector<int>> result3 = solution.splitArraySum(targetSum3, arr3);\n    for (auto &v : result3) {\n        for (int i : v) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "550": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string findMinString(vector<vector<string>>& logs) {\n        vector<string> timeLogs;\n        \n        for (auto& log : logs) {\n            if (log[0] == \"Player\") {\n                timeLogs.push_back(log[1]);\n            }\n        }\n        \n        sort(timeLogs.begin(), timeLogs.end());\n        \n        string result = \"\";\n        for (int i = 0; i < timeLogs.size(); i++) {\n            if (i > 0 && timeLogs[i] != timeLogs[i - 1]) {\n                result += timeLogs[i];\n                result += \"\\n\";\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> logs1 = {{\"Player 2 started playing\"}, {\"Player 3 started playing\"}, {\"Player 1 started playing\"}};\n    cout << \"Test Case 1: \" << solution.findMinString(logs1) << endl;\n    \n    // Test Case 2\n    vector<vector<string>> logs2 = {{\"Player 1 started playing\"}, {\"Player 2 started playing\"}, {\"Player 3 started playing\"}};\n    cout << \"Test Case 2: \" << solution.findMinString(logs2) << endl;\n\n    // Test Case 3\n    vector<vector<string>> logs3 = {{\"Player 1 started playing\", \"2020-01-01 00:00:00\"}, {\"Player 2 started playing\", \"2020-01-01 00:00:05\"}, \n                                    {\"Player 3 started playing\", \"2020-01-01 00:00:10\"}};\n    cout << \"Test Case 3: \" << solution.findMinString(logs3) << endl;\n\n    return 0;\n}\n```",
  "549": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int longestConsecutive(TreeNode* root, int target = NULL) {\n        if (root == NULL)\n            return 0;\n\n        if (target == NULL)\n            target = root->val;\n\n        if (root->val + 1 == target)\n            return 1 + longestConsecutive(root->left, root->val + 2) + longestConsecutive(root->right, root->val + 2);\n\n        if (root->val - 1 == target)\n            return 1 + longestConsecutive(root->left, root->val - 2) + longestConsecutive(root->right, root->val - 2);\n\n        if (root->val == target)\n            return 1 + longestConsecutive(root->left, root->val) + longestConsecutive(root->right, root->val);\n\n        return max(longestConsecutive(root->left, target), longestConsecutive(root->right, target));\n    }\n};\n\nint main() {\n    Solution solution;\n    TreeNode* tree1 = new TreeNode(2);\n    tree1->left = new TreeNode(1);\n    cout << \"Test case 1: \" << solution.longestConsecutive(tree1) << endl; // Output: 3\n\n    TreeNode* tree2 = new TreeNode(2);\n    tree2->right = new TreeNode(1);\n    cout << \"Test case 2: \" << solution.longestConsecutive(tree2) << endl; // Output: 2\n\n    TreeNode* tree3 = new TreeNode(4);\n    tree3->left = new TreeNode(2);\n    tree3->right = new TreeNode(5);\n    tree3->left->left = new TreeNode(1);\n    cout << \"Test case 3: \" << solution.longestConsecutive(tree3) << endl; // Output: 3\n\n    return 0;\n}\n```",
  "551": "```\n#include <iostream>\n#include <string>\n\nbool checkRecord(std::string s) {\n    int lateCount = 0;\n    for (char c : s) {\n        if (c == 'L') {\n            lateCount++;\n        } else if (c == 'A') {\n            if (lateCount > 0) return false;\n            lateCount = 0;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << checkRecord(\"LWLCA\") << std::endl; // Expected: false\n    std::cout << checkRecord(\"PPPLLPP\") << std::endl; // Expected: true\n    std::cout << checkRecord(\"AAABBBCCC\") << std::endl; // Expected: true\n    return 0;\n}\n```",
  "552": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint maxAverageRatio(vector<vector<int>>& classes) {\n    int n = classes.size();\n    vector<pair<int, int>> scores(n);\n\n    for (int i = 0; i < n; ++i) {\n        int positive = classes[i][0];\n        int negative = classes[i][1];\n\n        scores[i] = make_pair(positive + negative, positive);\n    }\n\n    sort(scores.begin(), scores.end());\n\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        sum += scores[i].second;\n    }\n\n    return sum / n;\n}\n\nint main() {\n    vector<vector<int>> classes1 = {{5, 1}, {10, 0}};\n    cout << maxAverageRatio(classes1) << endl;\n\n    vector<vector<int>> classes2 = {{4, 3}, [0 0], [2 0]];\n    cout << maxAverageRatio(classes2) << endl;\n\n    vector<vector<int>> classes3 = {{2, 0}, [5 3}, [5 2}};\n    cout << maxAverageRatio(classes3) << endl;\n\n    return 0;\n}\n```",
  "553": "```\n#include <iostream>\n#include <vector>\n\nint maximum_wealth(std::vector<std::vector<int>>& accounts) {\n    int maxWealth = 0;\n    for (const auto& account : accounts) {\n        int wealth = 0;\n        for (int i = 1; i < account.size(); ++i) {\n            wealth += account[i];\n        }\n        maxWealth = std::max(maxWealth, wealth);\n    }\n    return maxWealth;\n}\n\nint main() {\n    {\n        std::vector<std::vector<int>> accounts = {{10,20}, {30,40}, {50, 60}};\n        int result = maximum_wealth(accounts);\n        if (result == 160) {\n            std::cout << \"Test case 1 passed.\\n\";\n        } else {\n            std::cout << \"Test case 1 failed. Expected: 160, Got: \" << result << \"\\n\";\n        }\n    }\n\n    {\n        std::vector<std::vector<int>> accounts = {{1,2}, {5},{-2}};\n        int result = maximum_wealth(accounts);\n        if (result == 7) {\n            std::cout << \"Test case 2 passed.\\n\";\n        } else {\n            std::cout << \"Test case 2 failed. Expected: 7, Got: \" << result << \"\\n\";\n        }\n    }\n\n    {\n        std::vector<std::vector<int>> accounts = {{1,5},{7,3},{15}};\n        int result = maximum_wealth(accounts);\n        if (result == 22) {\n            std::cout << \"Test case 3 passed.\\n\";\n        } else {\n            std::cout << \"Test case 3 failed. Expected: 22, Got: \" << result << \"\\n\";\n        }\n    }\n\n    return 0;\n}\n```",
  "554": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int leastBricks(vector<vector<int>>& wall) {\n        unordered_map<int, int> count;\n        for (const auto& row : wall) {\n            int sum = 0;\n            bool foundLastBrick = false;\n            for (int i = 0; i < row.size() - 1; ++i) {\n                sum += row[i];\n                if (!foundLastBrick && count.find(sum) == count.end()) {\n                    count[sum] = 1;\n                } else {\n                    count[sum]++;\n                }\n            }\n        }\n        int maxCount = 0;\n        for (const auto& pair : count) {\n            maxCount = max(maxCount, pair.second);\n        }\n        return wall.size() - maxCount;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> wall1 = {{1,2},{3,5},{4},{2,3,5}};\n    cout << \"Test case 1: \" << solution.leastBricks(wall1) << endl; \n\n    // Test case 2\n    vector<vector<int>> wall2 = {{0},{1},{2},{0,1},{0,1,2}};\n    cout << \"Test case 2: \" << solution.leastBricks(wall2) << endl;\n\n    // Test case 3\n    vector<vector<int>> wall3 = {{1},{2},{3},{4},{5,6,7,8,9,10},{11,12,13,14,15,16}};\n    cout << \"Test case 3: \" << solution.leastBricks(wall3) << endl;\n\n    return 0;\n}\n```",
  "556": "```\n#include <iostream>\n#include <string>\n\nstd::string predictTheWinner(std::string s) {\n    int n = s.length();\n    std::string res;\n    for (int i = 0; i < n; i++) {\n        if (i + 1 < n && s[i] <= s[i + 1]) {\n            while (i + 1 < n && s[i] <= s[i + 1]) {\n                i++;\n            }\n            res += 'a';\n        } else {\n            res += s[i];\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << predictTheWinner(\"wupg\") << std::endl; // \"pwupg\"\n    std::cout << predictTheWinner(\"leetcode\") << std::endl; // \"leotceo\"\n    std::cout << predictTheWinner(\"aa\") << std::endl; // \"aaa\"\n    \n    return 0;\n}\n```",
  "555": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> splitStrings(std::string s) {\n    std::vector<std::string> result;\n    int i = 0;\n    while (i < s.length()) {\n        if (s[i] == '#') {\n            result.push_back(s.substr(i + 1));\n            i += 2;\n        } else {\n            i++;\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << \"Test Case 1:\\n\";\n    std::string s1 = \"leetcode#will#put#asew\";\n    std::vector<std::string> res1 = splitStrings(s1);\n    for (const auto& str : res1) {\n        std::cout << str << \"\\n\";\n    }\n    std::cout << \"\\n\";\n\n    std::cout << \"Test Case 2:\\n\";\n    std::string s2 = \"space#islimited\";\n    std::vector<std::string> res2 = splitStrings(s2);\n    for (const auto& str : res2) {\n        std::cout << str << \"\\n\";\n    }\n    std::cout << \"\\n\";\n\n    std::cout << \"Test Case 3:\\n\";\n    std::string s3 = \"a#b#c\";\n    std::vector<std::string> res3 = splitStrings(s3);\n    for (const auto& str : res3) {\n        std::cout << str << \"\\n\";\n    }\n    return 0;\n}\n```",
  "557": "```\n#include <iostream>\n#include <string>\n\nstd::string reverseWordsInString(std::string s) {\n    std::string result = \"\";\n    for (int i = s.size() - 1; i >= 0; --i) {\n        if (s[i] == ' ') {\n            continue;\n        }\n        int j = i;\n        while (j > 0 && s[j-1] != ' ') {\n            j--;\n        }\n        result += &s[i-j+1] + 1;\n    }\n    return result;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << reverseWordsInString(\"Let's take Leon\") << std::endl;\n    std::cout << \"Test case 2: \" << reverseWordsInString(\"God damn it the government\") << std::endl;\n    std::cout << \"Test case 3: \" << reverseWordsInString(\"Hello world\") << std::endl;\n    return 0;\n}",
  "559": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Definition for an N-ary tree node.\nstruct Node {\n    int val;\n    vector<Node*> children;\n};\n\nclass Solution {\npublic:\n    int maxDepth(Node* root) {\n        if (root == nullptr)\n            return 0;\n        int max = 0;\n        for (Node* child : root->children) {\n            int depth = maxDepth(child);\n            if (depth > max)\n                max = depth;\n        }\n        return max + 1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    Node* testRoot1 = new Node();\n    testRoot1->val = 1;\n    vector<Node*> children1 = {new Node(), new Node(), new Node()};\n    for (Node* child : children1) {\n        child->val = 2;\n        vector<Node*> grandchildren = {new Node(), new Node()};\n        child->children = grandchildren;\n    }\n    testRoot1->children = children1;\n\n    cout << \"Test case 1: \" << solution.maxDepth(testRoot1) << endl; // Expected output: 3\n\n    // Test case 2\n    Node* testRoot2 = new Node();\n    testRoot2->val = 1;\n    vector<Node*> children2 = {new Node(), new Node()};\n    for (Node* child : children2) {\n        child->val = 2;\n        vector<Node*> grandchildren = {};\n        child->children = grandchildren;\n    }\n    testRoot2->children = children2;\n\n    cout << \"Test case 2: \" << solution.maxDepth(testRoot2) << endl; // Expected output: 2\n\n    // Test case 3\n    Node* testRoot3 = new Node();\n    testRoot3->val = 1;\n    vector<Node*> children3 = {};\n    testRoot3->children = children3;\n\n    cout << \"Test case 3: \" << solution.maxDepth(testRoot3) << endl; // Expected output: 1\n\n    return 0;\n}\n```",
  "558": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Node {\npublic:\n    bool val;\n    vector<Node*> children;\n\n    Node(bool v) : val(v) {}\n};\n\nclass QuadTree {\npublic:\n    bool val;\n\n    QuadTree() : val(false) {\n        children = {new Node(false), new Node(false), new Node(false), new Node(false)};\n    }\n\n    void set(int x, int y, bool val) {\n        if (x < 0 || y < 0 || x >= 2 || y >= 2) return;\n\n        this->val = val;\n        for (int i = 0; i < 4; i++) {\n            if (x * 2 + i < 2 && children[i]->val == val) continue;\n            children[i]->set(x * 2, y, val);\n        }\n    }\n\n    bool query(int x1, int y1, int x2, int y2) {\n        if (!this->val) return true;\n\n        for (int i = 0; i < 4; i++) {\n            int x = x1 + i / 2;\n            int y = y1 + i % 2;\n            if (x >= x1 && y >= y1 && x <= x2 && y <= y2) continue;\n\n            if (!children[i]->query(x1 + i / 2, y1 + i % 2, min(x2, x1 + 2), min(y2, y1 + 2))) return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    QuadTree tree = new QuadTree();\n    tree.set(0, 0, true);\n\n    cout << (tree.query(0, 0, 0, 0) ? \"true\" : \"false\") << endl; // Should print: true\n\n    QuadTree tree2 = new QuadTree();\n    for (int i = 0; i < 4; i++) {\n        tree2.set(i % 2, i / 2, i % 2 != 0);\n    }\n\n    cout << (tree2.query(1, 1, 2, 2) ? \"true\" : \"false\") << endl; // Should print: true\n\n    QuadTree tree3 = new QuadTree();\n    for (int i = 0; i < 4; i++) {\n        tree3.set(i % 2, i / 2, i % 2 == 0);\n    }\n\n    cout << (tree3.query(1, 1, 2, 2) ? \"true\" : \"false\") << endl; // Should print: false\n\n    return 0;\n}\n```",
  "560": "```\n#include <iostream>\n#include <vector>\n\nint subarraySum(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    int sum = 0;\n    int count = 0;\n\n    std::unordered_map<int, int> map;\n\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        if (sum == k)\n            count++;\n        else if (map.find(sum - k) != map.end())\n            count += map[sum - k];\n\n        if (!map.count(sum))\n            map[sum] = 1;\n        else\n            map[sum]++;\n    }\n\n    return count;\n}\n\nint main() {\n    std::vector<int> nums1 = {30,40,45,50};\n    int k1 = 60;\n    std::cout << \"Test Case 1: \" << subarraySum(nums1, k1) << std::endl;\n\n    std::vector<int> nums2 = {1,-2,3,-4,5};\n    int k2 = -1;\n    std::cout << \"Test Case 2: \" << subarraySum(nums2, k2) << std::endl;\n\n    std::vector<int> nums3 = {-2,7,-9,6,5,8,-4,-4,-2,0};\n    int k3 = 15;\n    std::cout << \"Test Case 3: \" << subarraySum(nums3, k3) << std::endl;\n\n    return 0;\n}\n```",
  "561": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxEqualFrequency(vector<int>& nums) {\n        vector<int> freq(nums.size(), 0);\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i; j >= 0; j--) {\n                if (nums[j] > nums[i]) break;\n                freq[j]++;\n            }\n        }\n        int maxFreq = 0, res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (freq[i] > maxFreq) {\n                maxFreq = freq[i];\n                res = i;\n            } else if (freq[i] == maxFreq && i > res) {\n                res = i;\n            }\n        }\n        return res + 1;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> nums1 = {3, 1, 2};\n    cout << \"Array partition for \" << nums1 << \": \" << solution.maxEqualFrequency(nums1) << endl;\n\n    // Test case 2\n    vector<int> nums2 = {5, 6, 7, 8};\n    cout << \"Array partition for \" << nums2 << \": \" << solution.maxEqualFrequency(nums2) << endl;\n\n    // Test case 3\n    vector<int> nums3 = {1, 4, 3, 5, 2, 8};\n    cout << \"Array partition for \" << nums3 << \": \" << solution.maxEqualFrequency(nums3) << endl;\n    \n    return 0;\n}\n```",
  "563": "```\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int maxTilt(TreeNode* root) {\n        function<int(TreeNode*)> dfs = [&](TreeNode* node) {\n            if (!node) return 0;\n            \n            int tilt = abs(dfs(node->left) - dfs(node->right));\n            if (node->left && node->right) {\n                tilt += abs(node->left->val - node->right->val);\n            }\n            return tilt + max({dfs(node->left), dfs(node->right)});\n        };\n        \n        return dfs(root);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    TreeNode* root1 = new TreeNode(1, \n                                  new TreeNode(2),\n                                  new TreeNode(3));\n    cout << \"Test Case 1: \" << solution.maxTilt(root1) << endl;\n    \n    // Test Case 2\n    root1 = new TreeNode(4);\n    root1->left = new TreeNode(7);\n    root1->right = new TreeNode(8);\n    root1->left->left = new TreeNode(11);\n    root1->left->right = new TreeNode(13);\n    root1->right->left = new TreeNode(14);\n    cout << \"Test Case 2: \" << solution.maxTilt(root1) << endl;\n    \n    // Test Case 3\n    root1 = nullptr;\n    cout << \"Test Case 3: \" << solution.maxTilt(root1) << endl;\n    \n    return 0;\n}\n```",
  "562": "```\n#include <iostream>\n#include <vector>\n\nint findMaxForm(std::vector<std::vector<int>>& matrix) {\n    int m = matrix.size();\n    if (m == 0) return 0;\n\n    int n = matrix[0].size();\n    if (n == 0) return 0;\n\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));\n\n    for (int i = 1; i <= m; ++i) {\n        for (int j = 1; j <= n; ++j) {\n            if (matrix[i - 1][j - 1] == 0) {\n                dp[i][j] = std::min(dp[i - 1][j], dp[i][j - 1]);\n            } else {\n                dp[i][j] = std::max({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1] + 1});\n            }\n        }\n    }\n\n    return *std::max_element(dp[m].begin(), dp[m].end());\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> matrix1 = {{0, 1}, {1, 1}};\n    std::cout << \"Test case 1: \" << findMaxForm(matrix1) << std::endl;\n\n    // Test case 2\n    std::vector<std::vector<int>> matrix2 = {{0, 0, 1, 1}, {1, 1, 1, 1}};\n    std::cout << \"Test case 2: \" << findMaxForm(matrix2) << std::endl;\n\n    // Test case 3\n    std::vector<std::vector<int>> matrix3 = {{0, 0, 1}, {0, 1, 1}, {0, 0, 1}};\n    std::cout << \"Test case 3: \" << findMaxForm(matrix3) << std::endl;\n\n    return 0;\n}\n```",
  "564": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nint closestPalindrome(std::string s) {\n    int n = s.size();\n    for (int i = 0; i <= n / 2; i++) {\n        std::string left = s.substr(0, i);\n        if (!isPalindrome(left)) continue;\n        std::string right = s.substr(n - i, i);\n        if (!isPalindrome(right)) continue;\n        if (n % 2 == 1) return isPalindromic(s) ? n : -1;\n        int diff = abs((left + right).size() - n);\n        if (diff < n / 2) return n - diff;\n    }\n    return -1;\n}\n\nint isPalindrome(const std::string& s) {\n    for (int i = 0; i < s.size() / 2; i++) {\n        if (s[i] != s[s.size() - i - 1]) return 0;\n    }\n    return 1;\n}\n\nint isPalindromic(const std::string& s) {\n    int n = s.size();\n    for (int i = 0; i < n / 2; i++) {\n        if (s[i] != s[n - i - 1]) return 0;\n    }\n    return 1;\n}\n\nint main() {\n    std::cout << closestPalindrome(\"aba\") << std::endl; // Output: 3\n    std::cout << closestPalindrome(\"abc\") << std::endl; // Output: -1\n    std::cout << closestPalindrome(\"abba\") << std::endl; // Output: 4\n    return 0;\n}\n```",
  "565": "```\n#include <iostream>\n#include <vector>\n\nint arrayNesting(std::vector<int>& nums) {\n    int max = -1;\n    for (int i : nums) {\n        int start = i, end = i;\n        while (nums[end] != start) {\n            end = nums[end];\n        }\n        max = std::max(max, end - start + 1);\n    }\n    return max;\n}\n\nint main() {\n    std::vector<int> test1 = {5,6,7,8,9};\n    std::cout << \"Test case 1: \" << arrayNesting(test1) << std::endl;\n\n    std::vector<int> test2 = {1,2,3,4,5};\n    std::cout << \"Test case 2: \" << arrayNesting(test2) << std::endl;\n\n    std::vector<int> test3 = {0,2,10,6,20,4,8,7,9};\n    std::cout << \"Test case 3: \" << arrayNesting(test3) << std::endl;\n    \n    return 0;\n}",
  "567": "```\n#include <iostream>\n#include <string>\n\nbool checkInclusion(std::string s1, std::string s2) {\n    if (s1.size() > s2.size()) return false;\n    \n    int left = 0, right = 0;\n    int[] count1 = new int[26];\n    int[] count2 = new int[26];\n\n    while (right < s1.size()) {\n        ++count1[s1.charAt(left) - 'a'];\n        ++count1[s1.charAt(right) - 'a'];\n        \n        while (right + 1 >= s1.size() || \n               !Arrays.equals(count1, count2)) {\n            --count1[s1.charAt(left++) - 'a'];\n        }\n        right++;\n    }\n\n    return true;\n}\n\nint main() {\n    std::cout << checkInclusion(\"ab\", \"ba\") << std::endl; // True\n    std::cout << checkInclusion(\"hello\", \"olleh\") << std::endl; // True\n    std::cout << checkInclusion(\"abc\", \"cab\") << std::endl; // False\n\n    return 0;\n}\n```",
  "566": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<vector<int>> matrixReshape(std::vector<std::vector<int>>& mat, int r, int c) {\n    if (mat.empty()) return {};\n    int rowSize = mat[0].size();\n    if (r * c != mat.size() * rowSize) throw std::invalid_argument(\"Invalid reshape dimensions\");\n    \n    std::vector<vector<int>> reshapedMat;\n    for (int i = 0; i < r * c; ++i) {\n        vector<int> row(mat[i % mat.size()], {});\n        int j = 0;\n        while (j < min(c, rowSize)) {\n            if (j + c <= rowSize) {\n                row[j] = mat[i / (r * c)][j];\n                ++j;\n            }\n            else break;\n        }\n        reshapedMat.push_back(row);\n    }\n    \n    return reshapedMat;\n}\n\nint main() {\n    std::vector<std::vector<int>> mat1 = {{1,2},{3,4}};\n    int r1 = 2, c1 = 4;\n    auto result1 = matrixReshape(mat1, r1, c1);\n    for (const auto& row : result1) {\n        for (int val : row) std::cout << val << \" \";\n        std::cout << '\\n';\n    }\n    \n    std::vector<std::vector<int>> mat2 = {{1, 2}, {3, 4, 5}, {6, 7}};\n    int r2 = 3, c2 = 3;\n    auto result2 = matrixReshape(mat2, r2, c2);\n    for (const auto& row : result2) {\n        for (int val : row) std::cout << val << \" \";\n        std::cout << '\\n';\n    }\n    \n    std::vector<std::vector<int>> mat3 = {{1}};\n    int r3 = 1, c3 = 6;\n    auto result3 = matrixReshape(mat3, r3, c3);\n    for (const auto& row : result3) {\n        for (int val : row) std::cout << val << \" \";\n        std::cout << '\\n';\n    }\n    \n    return 0;\n}",
  "569": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Salary {\npublic:\n    string employee;\n    int salary;\n};\n\nclass Solution {\npublic:\n    double medianSalary(vector<Salary>& salaries) {\n        vector<int> sal;\n        for (const auto& s : salaries) {\n            sal.push_back(s.salary);\n        }\n        sort(sal.begin(), sal.end());\n        if (sal.size() % 2 == 0) {\n            return ((double)sal[sal.size()/2 - 1] + (double)sal[sal.size()/2]) / 2;\n        } else {\n            return (double)sal[sal.size()/2];\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<Salary> test1 = {{\"John\", 1000}, {\"Alice\", 2000}, {\"Bob\", 1500}};\n    cout << \"Test Case 1: Median Salary is \" << fixed << setprecision(2) << solution.medianSalary(test1) << endl;\n\n    // Test Case 2\n    vector<Salary> test2 = {{\"John\", 10000}, {\"Alice\", 2000}, {\"Bob\", 1500}};\n    cout << \"Test Case 2: Median Salary is \" << fixed << setprecision(2) << solution.medianSalary(test2) << endl;\n\n    // Test Case 3\n    vector<Salary> test3 = {{\"John\", 10000}, {\"Alice\", 2000}, {\"Bob\", 1500}, {\"Charlie\", 500}};\n    cout << \"Test Case 3: Median Salary is \" << fixed << setprecision(2) << solution.medianSalary(test3) << endl;\n\n    return 0;\n}\n```",
  "568": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint maxVacationDays(vector<vector<int>>& flights, int src, int dst) {\n    int n = flights.size();\n    vector<vector<int>> dp(n, vector<int>(n, 0));\n    \n    for (int i = 0; i < n; i++) {\n        dp[i][i] = flights[i][src];\n    }\n    \n    for (int len = 1; len <= n - 1; len++) {\n        for (int i = 0; i + len < n; i++) {\n            int j = i + len;\n            if (flights[j][dst] > 0) {\n                dp[i][j] = max(dp[(i + 1)][(j - 1)] + flights[j][dst], dp[i][(j - 1)] + flights[j][dst]);\n            } else {\n                dp[i][j] = dp[(i + 1)][(j - 1)];\n            }\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n\nint main() {\n    vector<vector<int>> flights1 = {{3,5},{10,1},{4,2}};\n    cout << \"Test case 1: \" << maxVacationDays(flights1, 0, 2) << endl;\n    \n    vector<vector<int>> flights2 = {{100,300},{300,100}};\n    cout << \"Test case 2: \" << maxVacationDays(flights2, 0, 1) << endl;\n    \n    vector<vector<int>> flights3 = {{10,5},{20,15},{30,25}};\n    cout << \"Test case 3: \" << maxVacationDays(flights3, 0, 2) << endl;\n    \n    return 0;\n}\n```",
  "571": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\ndouble findMedian(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int n = nums.size();\n    \n    if (n % 2 == 0) {\n        return (nums[n / 2 - 1] + nums[n / 2]) / 2.0;\n    } else {\n        return nums[n / 2];\n    }\n}\n\nint main() {\n    std::vector<int> test1 = {3, 1};\n    double result1 = findMedian(test1);\n    std::cout << \"Test Case 1: \";\n    if (std::abs(result1 - 1.5) < 0.001) {\n        std::cout << \"Pass\" << std::endl;\n    } else {\n        std::cout << \"Fail\" << std::endl;\n    }\n\n    std::vector<int> test2 = {1, 3, 4};\n    double result2 = findMedian(test2);\n    std::cout << \"Test Case 2: \";\n    if (std::abs(result2 - 3.0) < 0.001) {\n        std::cout << \"Pass\" << std::endl;\n    } else {\n        std::cout << \"Fail\" << std::endl;\n    }\n\n    std::vector<int> test3 = {1, 2};\n    double result3 = findMedian(test3);\n    std::cout << \"Test Case 3: \";\n    if (std::abs(result3 - 1.5) < 0.001) {\n        std::cout << \"Pass\" << std::endl;\n    } else {\n        std::cout << \"Fail\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "570": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> getManagers(int n) {\n        vector<vector<int>> employees(n);\n        for (int i = 0; i < n; ++i) {\n            int managerId;\n            cin >> managerId;\n            for (int j = 0; j < 5; ++j) {\n                int employeeId;\n                cin >> employeeId;\n                employees[managerId - 1].push_back(employeeId);\n            }\n        }\n        \n        vector<int> result;\n        for (int i = 1; i <= n; ++i) {\n            if (employees[i-1].size() >= 5) {\n                result.push_back(i);\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n1 = 10;\n    vector<int> managers1 = solution.getManagers(n1);\n    for (int manager : managers1) {\n        cout << \"Manager: \" << manager << endl;\n    }\n\n    // Test case 2\n    int n2 = 15;\n    vector<int> managers2 = solution.getManagers(n2);\n    for (int manager : managers2) {\n        cout << \"Manager: \" << manager << endl;\n    }\n\n    // Test case 3\n    int n3 = 20;\n    vector<int> managers3 = solution.getManagers(n3);\n    for (int manager : managers3) {\n        cout << \"Manager: \" << manager << endl;\n    }\n    \n    return 0;\n}\n```",
  "573": "```\n#include <iostream>\n#include <vector>\n\nint totalNuts(std::vector<std::vector<int>>& rows) {\n    int total = 0;\n    for (const auto& row : rows) {\n        total += row.size();\n    }\n    return total;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> test1{{3, 2}, {1, 1}};\n    int result = totalNuts(test1);\n    if (result == 6) {\n        std::cout << \"Test case 1 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed! Expected: 6, Actual: \" << result << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::vector<int>> test2{{4}, {3}};\n    int result2 = totalNuts(test2);\n    if (result2 == 7) {\n        std::cout << \"Test case 2 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed! Expected: 7, Actual: \" << result2 << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::vector<int>> test3{{1}};\n    int result3 = totalNuts(test3);\n    if (result3 == 1) {\n        std::cout << \"Test case 3 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed! Expected: 1, Actual: \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "572": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nbool isSubtree(TreeNode* s, TreeNode* t) {\n    if (!s && !t) return true; // both null\n    if (!s || !t) return false; // one is null\n\n    if (isMatch(s, t)) return true;\n    \n    return isSubtree(s->left, t) || isSubtree(s->right, t);\n}\n\nbool isMatch(TreeNode* s, TreeNode* t) {\n    if (!s && !t) return true; // both null\n    if (!s || !t) return false; // one is null\n\n    if (s->val != t->val) return false;\n    \n    return isMatch(s->left, t->left) && isMatch(s->right, t->right);\n}\n\nint main() {\n    TreeNode* s1 = new TreeNode(3);\n    s1->left = new TreeNode(4);\n    s1->right = new TreeNode(5);\n    s1->left->left = new TreeNode(1);\n    s1->left->right = new TreeNode(2);\n\n    TreeNode* t1 = new TreeNode(4);\n    t1->left = new TreeNode(1);\n    t1->right = new TreeNode(2);\n\n    cout << isSubtree(s1, t1) << endl; // true\n\n    TreeNode* s2 = new TreeNode(2);\n    s2->left = new TreeNode(1);\n    s2->right = new TreeNode(3);\n\n    TreeNode* t2 = new TreeNode(1);\n    t2->left = new TreeNode(0);\n    t2->right = new TreeNode(2);\n\n    cout << isSubtree(s2, t2) << endl; // false\n\n    TreeNode* s3 = new TreeNode(1);\n    s3->left = new TreeNode(0);\n    s3->right = new TreeNode(2);\n\n    TreeNode* t3 = new TreeNode(1);\n    t3->left = new TreeNode(0);\n    t3->right = new TreeNode(2);\n\n    cout << isSubtree(s3, t3) << endl; // true\n\n    return 0;\n}\n```",
  "574": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string findWinningCandidate(vector<vector<string>>& votes) {\n        map<string, int> candidateCount;\n        \n        for (const auto& vote : votes) {\n            if (candidateCount.count(vote[1])) {\n                candidateCount[vote[1]]++;\n            } else {\n                candidateCount[vote[1]] = 1;\n            }\n        }\n        \n        string winningCandidate = \"\";\n        int maxVotes = 0;\n        \n        for (const auto& pair : candidateCount) {\n            if (pair.second > maxVotes) {\n                maxVotes = pair.second;\n                winningCandidate = pair.first;\n            } else if (pair.second == maxVotes && pair.first < winningCandidate) {\n                winningCandidate = pair.first;\n            }\n        }\n        \n        return winningCandidate;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<string>> votes1 = {{\"John\", \"A\"}, {\"Emma\", \"B\"}, {\"Tom\", \"A\"}};\n    cout << solution.findWinningCandidate(votes1) << endl; // Expected output: A\n\n    vector<vector<string>> votes2 = {{\"Alice\", \"C\"}, {\"Bob\", \"D\"}, {\"Eve\", \"C\"}};\n    cout << solution.findWinningCandidate(votes2) << endl; // Expected output: C\n\n    vector<vector<string>> votes3 = {{\"Jack\", \"B\"}, {\"Jill\", \"A\"}, {\"Jane\", \"B\"}};\n    cout << solution.findWinningCandidate(votes3) << endl; // Expected output: B\n\n    return 0;\n}\n```",
  "575": "```\n#include <iostream>\n#include <vector>\n\nint totalCandy(std::vector<int>& preferences) {\n    int n = preferences.size();\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        res += (i % 2 == 0 ? 1 : -1);\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 2, 3};\n    std::cout << \"Test case 1: \" << totalCandy(test1) << std::endl;\n\n    std::vector<int> test2 = {2, 5, 3};\n    std::cout << \"Test case 2: \" << totalCandy(test2) << std::endl;\n\n    std::vector<int> test3 = {1, 4, 2, 6, 1};\n    std::cout << \"Test case 3: \" << totalCandy(test3) << std::endl;\n    return 0;\n}\n```",
  "577": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int totalSalary(int n, std::vector<std::vector<int>>& employees) {\n        int total = 0;\n        for (const auto& employee : employees) {\n            total += employee[1];\n        }\n        return total;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n1 = 3;\n    std::vector<std::vector<int>> employees1 = {{1, 15000}, {2, 20000}, {3, 25000}};\n    int expected1 = 60000;\n    if (solution.totalSalary(n1, employees1) != expected1) {\n        std::cout << \"Test case 1 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    }\n\n    // Test case 2\n    int n2 = 5;\n    std::vector<std::vector<int>> employees2 = {{1, 10000}, {2, 12000}, {3, 14000}, {4, 16000}, {5, 18000}};\n    int expected2 = 80000;\n    if (solution.totalSalary(n2, employees2) != expected2) {\n        std::cout << \"Test case 2 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    }\n\n    // Test case 3\n    int n3 = 1;\n    std::vector<std::vector<int>> employees3 = {{1, 5000}};\n    int expected3 = 5000;\n    if (solution.totalSalary(n3, employees3) != expected3) {\n        std::cout << \"Test case 3 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "576": "```\n#include <iostream>\n#include <vector>\n\nint findPaths(int m, int n, int startRow, int startCol, int endRow, int endCol) {\n    if (startRow < 0 || startRow >= m || startCol < 0 || startCol >= n || endRow < 0 || endRow >= m || endCol < 0 || endCol >= n)\n        return -1;\n    \n    vector<vector<int>> dp(m, vector<int>(n));\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i == startRow && j == startCol) || (i == endRow && j == endCol))\n                dp[i][j] = 1;\n            else\n                dp[i][j] = -1;\n        }\n    }\n    \n    int res = 0;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i == startRow && j == startCol) || (i == endRow && j == endCol))\n                continue;\n            int up = dp[i-1][j] >= 0 ? dp[i-1][j] : -1;\n            int down = i < m-1 && dp[i+1][j] >= 0 ? dp[i+1][j] : -1;\n            int left = j > 0 && dp[i][j-1] >= 0 ? dp[i][j-1] : -1;\n            int right = j < n-1 && dp[i][j+1] >= 0 ? dp[i][j+1] : -1;\n            \n            if ((i == startRow && j < startCol) || (i == endRow && j > endCol))\n                res += (up + down + left + right);\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::cout << findPaths(2, 3, 0, 1, 2, 2) << \"\\n\";\n    std::cout << findPaths(1, 5, 0, 4, 1, 2) << \"\\n\";\n    std::cout << findPaths(3, 7, 1, 0, 2, 2) << \"\\n\";\n    \n    return 0;\n}\n```",
  "578": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Question {\n    int id;\n    std::vector<std::string> answers;\n};\n\nint getHighestAnswerRateQuestion(std::vector<Question>& questions) {\n    int highestRate = 0;\n    int highestRateQuestionId = -1;\n\n    for (const auto& question : questions) {\n        int correctAnswers = 0;\n        for (const auto& answer : question.answers) {\n            if (answer == \"Correct\") {\n                correctAnswers++;\n            }\n        }\n\n        double rate = static_cast<double>(correctAnswers) / question.answers.size();\n        if (rate > highestRate) {\n            highestRate = rate;\n            highestRateQuestionId = question.id;\n        }\n    }\n\n    return highestRateQuestionId;\n}\n\nint main() {\n    std::vector<Question> questions;\n\n    // Test case 1\n    Question q1;\n    q1.id = 1;\n    q1.answers = {\"Correct\", \"Incorrect\", \"Correct\"};\n    questions.push_back(q1);\n\n    // Test case 2\n    Question q2;\n    q2.id = 2;\n    q2.answers = {\"Correct\", \"Correct\", \"Incorrect\"};\n    questions.push_back(q2);\n\n    // Test case 3\n    Question q3;\n    q3.id = 3;\n    q3.answers = {\"Incorrect\", \"Incorrect\", \"Correct\"};\n    questions.push_back(q3);\n\n    int highestRateQuestionId = getHighestAnswerRateQuestion(questions);\n    std::cout << \"The question with the highest answer rate is: \" << highestRateQuestionId << std::endl;\n\n    return 0;\n}\n```",
  "579": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Employee {\npublic:\n    string id;\n    int salary;\n\n    Employee(string id, int salary) : id(id), salary(salary) {}\n};\n\nclass Solution {\npublic:\n    vector<int> getSalary(const vector<Employee>& employees, string employeeId) {\n        map<string, int> salaryMap;\n        for (const auto& employee : employees) {\n            salaryMap[employee.id] = employee.salary;\n        }\n        \n        int cumulativeSalary = 0;\n        for (const auto& pair : salaryMap) {\n            if (pair.first == employeeId) {\n                return vector<int>({cumulativeSalary, cumulativeSalary + pair.second});\n            }\n            cumulativeSalary += pair.second;\n        }\n\n        throw runtime_error(\"Employee not found\");\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<Employee> employees1 = {{\"John\", 1000}, {\"Jane\", 2000}};\n    try {\n        auto result1 = solution.getSalary(employees1, \"John\");\n        cout << \"Test Case 1: Cumulative Salary of John is (\" << result1[0] << \", \" << result1[1] << \")\" << endl;\n    } catch (const exception& e) {\n        cerr << \"Test Case 1 Exception: \" << e.what() << endl;\n    }\n\n    // Test Case 2\n    vector<Employee> employees2 = {{\"John\", 1000}, {\"Jane\", 2000}};\n    try {\n        auto result2 = solution.getSalary(employees2, \"Jane\");\n        cout << \"Test Case 2: Cumulative Salary of Jane is (\" << result2[0] << \", \" << result2[1] << \")\" << endl;\n    } catch (const exception& e) {\n        cerr << \"Test Case 2 Exception: \" << e.what() << endl;\n    }\n\n    // Test Case 3\n    vector<Employee> employees3 = {{\"John\", 1000}, {\"Jane\", 2000}};\n    try {\n        auto result3 = solution.getSalary(employees3, \"Unknown\");\n        cout << \"Test Case 3: Cumulative Salary of Unknown is (\" << result3[0] << \", \" << result3[1] << \")\" << endl;\n    } catch (const exception& e) {\n        cerr << \"Test Case 3 Exception: \" << e.what() << endl;\n    }\n\n    return 0;\n}\n```",
  "580": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Department {\npublic:\n    std::string name;\n    int students;\n};\n\nint countStudentsInDepartments(const std::vector<Department>& departments, const std::vector<std::string>& studentNames) {\n    int totalStudents = 0;\n    for (const auto& department : departments) {\n        int departmentStudents = 0;\n        for (const auto& studentName : studentNames) {\n            if (studentName.find(department.name) != std::string::npos) {\n                departmentStudents++;\n            }\n        }\n        totalStudents += department.students + departmentStudents;\n    }\n    return totalStudents;\n}\n\nint main() {\n    // Test case 1\n    std::vector<Department> departments1 = {{ \"Math\", 10 }, { \"Science\", 15 }};\n    std::vector<std::string> studentNames1 = {\"Alice, Math\", \"Bob, Science\", \"Charlie, Math\"};\n    int result1 = countStudentsInDepartments(departments1, studentNames1);\n    std::cout << \"Test case 1: Expected 25, got \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<Department> departments2 = {{ \"English\", 8 }, { \"History\", 12 }};\n    std::vector<std::string> studentNames2 = {\"David, English\", \"Eve, History\"};\n    int result2 = countStudentsInDepartments(departments2, studentNames2);\n    std::cout << \"Test case 2: Expected 20, got \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<Department> departments3 = {{ \"Art\", 5 }, { \"Music\", 10 }};\n    std::vector<std::string> studentNames3 = {\"Frank, Art\", \"Gina, Music\"};\n    int result3 = countStudentsInDepartments(departments3, studentNames3);\n    std::cout << \"Test case 3: Expected 15, got \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "581": "```\n#include <iostream>\n#include <vector>\n\nint findUnsortedContinousSubarray(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> sortedNums(nums);\n    std::sort(sortedNums.begin(), sortedNums.end());\n\n    int start = -1, end = -1;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] != sortedNums[i]) {\n            if (start == -1) {\n                start = i;\n            }\n            end = i;\n        } else if (start != -1) {\n            break;\n        }\n    }\n\n    return end - start + 1;\n}\n\nint main() {\n    std::vector<int> nums1 = {2, 6, 4, 8, 3, 1};\n    int result1 = findUnsortedContinousSubarray(nums1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> nums2 = [0, 1];\n    int result2 = findUnsortedContinousSubarray(nums2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> nums3 = {1};\n    int result3 = findUnsortedContinousSubarray(nums3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "582": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> killProcess(vector<int>& pid, vector<int>& ppid) {\n        unordered_map<int, int> parentMap;\n        for (int i = 0; i < pid.size(); i++) {\n            parentMap[pid[i]] = ppid[i];\n        }\n        \n        vector<int> result;\n        function<void(int)> dfs = [&](int processId) {\n            if (!parentMap.count(processId)) return;\n            int parentId = parentMap[processId];\n            result.push_back(parentId);\n            dfs(parentId);\n        };\n        \n        for (int i = 1; i <= max(pid); i++) {\n            dfs(i);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> pid1 = {1, 3, 10};\n    vector<int> ppid1 = {1, 6, 2};\n    vector<int> result1 = solution.killProcess(pid1, ppid1);\n    for (int processId : result1) {\n        cout << processId << \" \";\n    }\n    cout << endl;\n\n    vector<int> pid2 = {2, 5, 8, 4};\n    vector<int> ppid2 = {5, 3, -1};\n    vector<int> result2 = solution.killProcess(pid2, ppid2);\n    for (int processId : result2) {\n        cout << processId << \" \";\n    }\n    cout << endl;\n\n    vector<int> pid3 = {20, 11, 15, 13, -6};\n    vector<int> ppid3 = {11, -6, 15, 20, 9};\n    vector<int> result3 = solution.killProcess(pid3, ppid3);\n    for (int processId : result3) {\n        cout << processId << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "583": "```\n#include <iostream>\n#include <vector>\n\nint minDistance(std::string word1, std::string word2) {\n    int m = word1.size();\n    int n = word2.size();\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (word1[i - 1] == word2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + std::min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]});\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    std::cout << minDistance(\"sea\", \"eat\") << std::endl; // Expected output: 2\n    std::cout << minDistance(\"leetcode\", \"etco\") << std::endl; // Expected output: 4\n    std::cout << minDistance(\"word\", \"world\") << std::endl; // Expected output: 4\n\n    return 0;\n}\n```",
  "584": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findReferees(vector<vector<string>>& customers) {\n        unordered_map<string, string> refereeMap;\n        for (const auto& customer : customers) {\n            if (!refereeMap.count(customer[1])) {\n                refereeMap[customer[1]] = customer[0];\n            }\n        }\n        vector<string> referees;\n        for (const auto& pair : refereeMap) {\n            referees.push_back(pair.second + \" \" + pair.first);\n        }\n        return referees;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> customers1 = {{ \"Sherry\", \"John\" }, { \"John\", \"Mary\" }, { \"Mary\", \"Jane\" }, { \"Jane\", \"Bob\" }, {\"Bob\",\"Alice\"}};\n    vector<string> referees1 = solution.findReferees(customers1);\n    for (const auto& referee : referees1) {\n        cout << referee << endl;\n    }\n    \n    // Test case 2\n    vector<vector<string>> customers2 = {{ \"Alice\", \"Bob\" }, { \"Bob\", \"Mary\" }, {\"Mary\",\"John\"},{ \"John\", \"Sherry\"}};\n    vector<string> referees2 = solution.findReferees(customers2);\n    for (const auto& referee : referees2) {\n        cout << referee << endl;\n    }\n    \n    // Test case 3\n    vector<vector<string>> customers3 = {{ \"Jane\", \"Alice\" }, { \"Alice\", \"John\" }, {\"John\",\"Mary\"}};\n    vector<string> referees3 = solution.findReferees(customers3);\n    for (const auto& referee : referees3) {\n        cout << referee << endl;\n    }\n\n    return 0;\n}\n```",
  "585": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int maxIncreaseKeepingSum(std::vector<std::vector<int>>& accounts) {\n        int total = 0;\n        for (int i = 0; i < accounts.size(); i++) {\n            int sum = 0;\n            for (int j = 1; j < accounts[i].size(); j++) {\n                sum += accounts[i][j];\n            }\n            for (int j = 0; j < accounts[i].size(); j++) {\n                if (j == 0) continue;\n                int personSum = 0;\n                for (int k = 1; k < accounts.size(); k++) {\n                    if (k != i) {\n                        personSum += accounts[k][j];\n                    }\n                }\n                total += min(sum, personSum);\n            }\n        }\n        return total;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    std::vector<std::vector<int>> accounts1 = {{10,200}, {50,500},{60,700}};\n    int result1 = solution.maxIncreaseKeepingSum(accounts1);\n    if (result1 == 650) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 650, Actual: \" << result1 << \".\" << std::endl;\n    }\n    \n    // Test case 2\n    std::vector<std::vector<int>> accounts2 = {{5000,9000000},{7000,14000000}};\n    int result2 = solution.maxIncreaseKeepingSum(accounts2);\n    if (result2 == 12600000) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 12600000, Actual: \" << result2 << \".\" << std::endl;\n    }\n    \n    // Test case 3\n    std::vector<std::vector<int>> accounts3 = {{500,100},{7000,140000}};\n    int result3 = solution.maxIncreaseKeepingSum(accounts3);\n    if (result3 == 8000) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 8000, Actual: \" << result3 << \".\" << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "586": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nint countOrders(std::vector<std::string>& orders) {\n    std::unordered_map<std::string, int> orderCount;\n    for (const auto& order : orders) {\n        orderCount[order]++;\n    }\n    return *std::max_element(orderCount.begin(), orderCount.end(),\n                               [](const auto& a, const auto& b) {\n                                   return a.second < b.second;\n                               })->first.size();\n}\n\nint main() {\n    std::vector<std::string> orders1 = {\"John\", \"Mary\", \"John\"};\n    std::cout << countOrders(orders1) << std::endl; // Output: 5\n\n    std::vector<std::string> orders2 = {\"Alice\", \"Bob\", \"Charlie\", \"Alice\", \"Bob\"};\n    std::cout << countOrders(orders2) << std::endl; // Output: 6\n\n    std::vector<std::string> orders3 = {\"Eve\", \"Adam\", \"Eve\", \"Adam\", \"Eve\", \"Adam\"};\n    std::cout << countOrders(orders3) << std::endl; // Output: 4\n    return 0;\n}\n```",
  "587": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMinArrowLength(vector<vector<int>>& points) {\n        if (points.empty()) return 0;\n        \n        sort(points.begin(), points.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[1] < b[1];\n        });\n        \n        int len = INT_MAX;\n        int x1 = points[0][1];\n        for (int i = 0; i < points.size() - 1; ++i) {\n            if (points[i][1] + 1 == points[i+1][0]) {\n                x1 = points[i+1][0];\n            } else {\n                len = min(len, points[i+1][0] - x1);\n                x1 = points[i+1][0];\n            }\n        }\n        \n        return len;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> point1 = {{1,3},{2,5},{7,12}};\n    cout << \"Test case 1: \" << solution.findMinArrowLength(point1) << endl; // Output: 6\n\n    vector<vector<int>> point2 = {{1,2},{8,10},{11,14},{18,19},{20,25}};\n    cout << \"Test case 2: \" << solution.findMinArrowLength(point2) << endl; // Output: 7\n\n    vector<vector<int>> point3 = {{0,6},{9,12},{15,24},{26,28},{30,40}};\n    cout << \"Test case 3: \" << solution.findMinArrowLength(point3) << endl; // Output: 8\n\n    return 0;\n}\n```",
  "588": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nclass FileSystem {\npublic:\n    class File {\n    public:\n        std::string name;\n        bool isDir = false;\n        std::unordered_map<std::string, File*> children;\n    };\n\n    FileSystem() : root(new File()) {}\n\n    void createFile(const std::string& path) {\n        File* curr = root;\n        for (const auto& dirOrFile : path) {\n            if (dirOrFile == '/') continue; // skip the leading slash\n            if (!curr->children.count(std::string(1, dirOrFile))) {\n                curr->children[std::string(1, dirOrFile)] = new File();\n            }\n            curr = curr->children[std::string(1, dirOrFile)];\n        }\n        curr->name = path;\n        curr->isDir = false;\n    }\n\n    void mkdir(const std::string& path) {\n        File* curr = root;\n        for (const auto& dirOrFile : path) {\n            if (dirOrFile == '/') continue; // skip the leading slash\n            if (!curr->children.count(std::string(1, dirOrFile))) {\n                curr->children[std::string(1, dirOrFile)] = new File();\n            }\n            curr = curr->children[std::string(1, dirOrFile)];\n        }\n        curr->name = path;\n        curr->isDir = true;\n    }\n\n    std::string ls(const std::string& path) {\n        File* curr = root;\n        for (const auto& dirOrFile : path) {\n            if (dirOrFile == '/') continue; // skip the leading slash\n            if (!curr->children.count(std::string(1, dirOrFile))) {\n                return \"No such file or directory\";\n            }\n            curr = curr->children[std::string(1, dirOrFile)];\n        }\n\n        if (curr->isDir) {\n            std::vector<std::string> dirs;\n            for (const auto& child : curr->children) {\n                dirs.push_back(child.first);\n            }\n            return std::accumulate(dirs.begin(), dirs.end(), \"\", [](const std::string& prev, const std::string& dir) {\n                return prev + dir + \"\\n\";\n            });\n        } else {\n            return curr->name;\n        }\n    }\n\nprivate:\n    File* root;\n};\n\nint main() {\n    FileSystem fs;\n\n    fs.createFile(\"/file1\");\n    fs.mkdir(\"/dir1\");\n    fs.createFile(\"/file2\");\n    fs.mkdir(\"/dir2/file3\");\n\n    std::cout << \"List of files in / : \" << fs.ls(\"/\") << std::endl; // Should print: file1\n    std::cout << \"List of files in dir1 : \" << fs.ls(\"/dir1\") << std::endl; // Should print: (empty)\n    std::cout << \"List of files in dir2 : \" << fs.ls(\"/dir2\") << std::endl; // Should print: file3\n\n    return 0;\n}\n```",
  "589": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    vector<Node*> children;\n};\n\nclass Solution {\npublic:\n    vector<int> preorder(Node* root) {\n        vector<int> res;\n        stack<Node*> s;\n        if (root != NULL) s.push(root);\n        while (!s.empty()) {\n            Node* node = s.top(); s.pop();\n            res.push_back(node->val);\n            for (int i = node->children.size() - 1; i >= 0; i--) {\n                s.push(node->children[i]);\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    Node* root1 = new Node();\n    root1->val = 1;\n    root1->children = {new Node(), new Node()};\n    cout << \"Test case 1: \";\n    for (int val : solution.preorder(root1)) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    // Test case 2:\n    Node* root2 = new Node();\n    root2->val = 3;\n    root2->children = {new Node(), new Node(), new Node()};\n    cout << \"Test case 2: \";\n    for (int val : solution.preorder(root2)) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    // Test case 3:\n    Node* root3 = NULL;\n    cout << \"Test case 3: \";\n    vector<int> res3 = solution.preorder(root3);\n    for (int val : res3) {\n        cout << val << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "591": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        for (char c : s) {\n            if (c == '(')\n                st.push(')');\n            else if (c == '{')\n                st.push('}');\n            else if (c == '[')\n                st.push(']');\n            else if (!st.empty() && st.top() == c)\n                st.pop();\n            else\n                return false;\n        }\n        return st.empty();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << boolalpha;\n    cout << \"Test case 1: \" << (solution.isValid(\"()\") ? \"Pass\" : \"Fail\") << endl; // true\n    cout << \"Test case 2: \" << (solution.isValid(\"()[]{}\")) << endl; // true\n    cout << \"Test case 3: \" << (solution.isValid(\"(]\")) << endl; // false\n\n    return 0;\n}\n```",
  "590": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for an N-ary tree node.\nstruct Node {\n    int val;\n    vector<Node*> children;\n};\n\nclass Solution {\npublic:\n    vector<int> postorder(Node* root) {\n        vector<int> res;\n        stack<pair<Node*, bool>> st;\n        st.push({root, false});\n        \n        while (!st.empty()) {\n            auto [node, visited] = st.top();\n            st.pop();\n            \n            if (visited) {\n                res.push_back(node->val);\n            } else {\n                for (auto child : node->children) {\n                    st.push({child, false});\n                }\n                st.push({node, true});\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    Node* root = new Node();\n    root->val = 1;\n    \n    Node* child1 = new Node();\n    child1->val = 3;\n    Node* child2 = new Node();\n    child2->val = 5;\n    Node* child3 = new Node();\n    child3->val = 6;\n\n    root->children.push_back(child1);\n    root->children.push_back(child2);\n    root->children.push_back(child3);\n\n    vector<int> result = solution.postorder(root);\n\n    cout << \"Post order traversal: \";\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    root = new Node();\n    root->val = 1;\n    \n    child1 = new Node();\n    child1->val = 3;\n\n    root->children.push_back(child1);\n\n    result = solution.postorder(root);\n    cout << \"Post order traversal: \";\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    root = new Node();\n    root->val = 1;\n    \n    child1 = new Node();\n    child1->val = 2;\n    child2 = new Node();\n    child2->val = 3;\n\n    root->children.push_back(child1);\n    root->children.push_back(child2);\n\n    result = solution.postorder(root);\n    cout << \"Post order traversal: \";\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "592": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string fractionToDecimal(int numerator, int denominator) {\n        long long num = numerator, denom = denominator;\n        if ((num > 0 && denom < 0) || (num < 0 && denom > 0)) {\n            num = -num;\n            denom = -denom;\n        }\n        std::string res = \"\";\n        if (num != 0) {\n            res += (num < 0 ? \"-\" : \"\");\n            num = Math.abs(num);\n        }\n        long long n = num / denom, r = num % denom;\n        res += std::to_string(n);\n        if (r > 0) {\n            res += \".\";\n            do {\n                num = r * 10;\n                n = num / denom;\n                r = num % denom;\n                res += std::to_string(n);\n            } while (r > 0);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    // Test case 1\n    int numerator1 = -1, denominator1 = 2;\n    std::string result1 = solution.fractionToDecimal(numerator1, denominator1);\n    if (result1 != \"-0.5\") {\n        std::cerr << \"Test case 1 failed\" << std::endl;\n        return 1;\n    }\n    // Test case 2\n    int numerator2 = 2, denominator2 = 3;\n    std::string result2 = solution.fractionToDecimal(numerator2, denominator2);\n    if (result2 != \"0.(6)\") {\n        std::cerr << \"Test case 2 failed\" << std::endl;\n        return 1;\n    }\n    // Test case 3\n    int numerator3 = 49, denominator3 = 6;\n    std::string result3 = solution.fractionToDecimal(numerator3, denominator3);\n    if (result3 != \"8.233333333333333\") {\n        std::cerr << \"Test case 3 failed\" << std::endl;\n        return 1;\n    }\n    std::cout << \"All test cases passed\" << std::endl;\n    return 0;\n}\n```",
  "594": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint findLHS(vector<int>& nums) {\n    unordered_map<int, int> count;\n    for (int num : nums) {\n        ++count[num];\n    }\n    \n    int res = 0;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        if (it->second > 1 && count.find(it->first + 1) != count.end()) {\n            res = max(res, it->second + count[it->first + 1].second);\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    vector<int> nums1 = {1,3,2,2,5,2,1,7};\n    cout << findLHS(nums1) << endl; // Output: 6\n\n    vector<int> nums2 = {2,2,1,2,4};\n    cout << findLHS(nums2) << endl; // Output: 3\n\n    vector<int> nums3 = {3,3,6];\n    cout << findLHS(nums3) << endl; // Output: 3\n\n    return 0;\n}\n```",
  "593": "```\n#include <iostream>\n#include <vector>\n\nbool validSquare(std::vector<int>& p1, std::vector<int>& p2, std::vector<int>& p3, std::vector<int>& p4) {\n    int len12 = (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]);\n    int len23 = (p2[0] - p3[0]) * (p2[0] - p3[0]) + (p2[1] - p3[1]) * (p2[1] - p3[1]);\n    int len34 = (p3[0] - p4[0]) * (p3[0] - p4[0]) + (p3[1] - p4[1]) * (p3[1] - p4[1]);\n    int len14 = (p1[0] - p4[0]) * (p1[0] - p4[0]) + (p1[1] - p4[1]) * (p1[1] - p4[1]);\n\n    if ((len12 == 0 && len23 != 0) || (len12 != 0 && len23 == 0)) {\n        return false;\n    }\n    if ((len23 == 0 && len34 != 0) || (len23 != 0 && len34 == 0)) {\n        return false;\n    }\n    if ((len34 == 0 && len14 != 0) || (len34 != 0 && len14 == 0)) {\n        return false;\n    }\n\n    int maxLen = std::max({len12, len23, len34, len14});\n    for (int i : {len12, len23, len34, len14}) {\n        if (i > maxLen) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> p11 = {0, 0};\n    std::vector<int> p12 = {3, 1};\n    std::vector<int> p13 = {1, 1};\n    std::vector<int> p14 = {0, 3};\n\n    if (validSquare(p11, p12, p13, p14)) {\n        std::cout << \"Test case 1: Valid square\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Invalid square\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> p21 = {0, 3};\n    std::vector<int> p22 = {3, 0};\n    std::vector<int> p23 = {1.5, 1.5};\n    std::vector<int> p24 = {1.5, -1.5};\n\n    if (validSquare(p21, p22, p23, p24)) {\n        std::cout << \"Test case 2: Valid square\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Invalid square\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> p31 = {0, 0};\n    std::vector<int> p32 = {1, 1};\n    std::vector<int> p33 = {0, 1};\n    std::vector<int> p34 = {2, 2};\n\n    if (validSquare(p31, p32, p33, p34)) {\n        std::cout << \"Test case 3: Valid square\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Invalid square\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "595": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<std::string> bigCountries(std::vector<std::pair<std::string, int>>& countries) {\n        std::vector<std::string> result;\n        for (const auto& country : countries) {\n            if (country.second > 1000000) {\n                result.push_back(country.first);\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::pair<std::string, int>> testCountries1 = {{\"China\", 1439000000}, {\"Japan\", 127670000}, {\"India\", 1380000000}};\n    std::vector<std::string> result1 = solution.bigCountries(testCountries1);\n    for (const auto& country : result1) {\n        std::cout << country << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<std::pair<std::string, int>> testCountries2 = {{\"USA\", 331449000}, {\"Canada\", 37742154}};\n    std::vector<std::string> result2 = solution.bigCountries(testCountries2);\n    for (const auto& country : result2) {\n        std::cout << country << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<std::pair<std::string, int>> testCountries3 = {{\"France\", 67000000}, {\"Germany\", 83700000}};\n    std::vector<std::string> result3 = solution.bigCountries(testCountries3);\n    for (const auto& country : result3) {\n        std::cout << country << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "596": "```\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int countClasses(std::vector<std::vector<int>>& schedules) {\n        int total_classes = 0;\n        for (const auto& schedule : schedules) {\n            bool has_more_than_5_students = false;\n            for (int i = 1; i < schedule.size(); ++i) {\n                if (schedule[i] > schedule[0]) {\n                    has_more_than_5_students = true;\n                    break;\n                }\n            }\n            total_classes += has_more_than_5_students ? 1 : 0;\n        }\n        return total_classes;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::vector<int>> schedules1 = {{1, 3}, {2, 4}};\n    std::cout << \"Test case 1: \" << solution.countClasses(schedules1) << std::endl;  // Expected output: 0\n\n    std::vector<std::vector<int>> schedules2 = {{5, 6, 7, 8, 9}, {10, 11}};\n    std::cout << \"Test case 2: \" << solution.countClasses(schedules2) << std::endl;  // Expected output: 1\n\n    std::vector<std::vector<int>> schedules3 = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12}};\n    std::cout << \"Test case 3: \" << solution.countClasses(schedules3) << std::endl;  // Expected output: 1\n\n    return 0;\n}\n```",
  "597": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double overallAcceptRate(vector<vector<string>>& requests) {\n        int accepted = 0;\n        int total = requests.size();\n        \n        for (const auto& request : requests) {\n            if (request[1] == \"accepted\") {\n                accepted++;\n            }\n        }\n        \n        return static_cast<double>(accepted) / total;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> requests1 = {{\"John\", \"Alice\", \"accepted\"}, {\"Alice\", \"Bob\", \"rejected\"}};\n    cout << fixed << setprecision(2);\n    cout << solution.overallAcceptRate(requests1) << endl;  // Expected Output: 0.50\n\n    // Test Case 2\n    vector<vector<string>> requests2 = {{\"Eve\", \"Alice\", \"accepted\"}, {\"Bob\", \"Eve\", \"rejected\"}};\n    cout << fixed << setprecision(2);\n    cout << solution.overallAcceptRate(requests2) << endl;  // Expected Output: 0.50\n\n    // Test Case 3\n    vector<vector<string>> requests3 = {{\"Alice\", \"Bob\", \"accepted\"}, {\"Bob\", \"Eve\", \"rejected\"}, {\"Eve\", \"John\", \"accepted\"}};\n    cout << fixed << setprecision(2);\n    cout << solution.overallAcceptRate(requests3) << endl;  // Expected Output: 0.33\n\n    return 0;\n}",
  "598": "```\n#include <iostream>\n#include <vector>\n\nint maxSumSubsequence(std::vector<int>& arr) {\n    int n = arr.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n    \n    for (int i = 0; i < n; ++i)\n        dp[i][i] = arr[i];\n    \n    for (int length = 2; length <= n; ++length) {\n        for (int i = 0; i < n - length + 1; ++i) {\n            int j = i + length - 1;\n            dp[i][j] = std::max(arr[i] + arr[j], std::max(dp[i + 1][j - 1], \n                arr[i] + (arr[i + 1] > arr[i]) ? arr[i + 1] : arr[i]));\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> testArr1 = {-2,1,-3,4,-1,2,1,-5,4};\n    std::cout << \"Test case 1: \" << maxSumSubsequence(testArr1) << std::endl;\n    \n    // Test case 2\n    std::vector<int> testArr2 = {0,-2,3,-1,6};\n    std::cout << \"Test case 2: \" << maxSumSubsequence(testArr2) << std::endl;\n    \n    // Test case 3\n    std::vector<int> testArr3 = {-5,-3,5,9,-2,0,4,7};\n    std::cout << \"Test case 3: \" << maxSumSubsequence(testArr3) << std::endl;\n\n    return 0;\n}\n```",
  "599": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint arrayPairSum(std::vector<int>& nums) {\n    std::vector<std::pair<int, int>> pairs;\n    for (size_t i = 0; i < nums.size(); i += 2) {\n        pairs.push_back({nums[i], i});\n    }\n    sort(pairs.begin(), pairs.end());\n    int sum = 0;\n    for (const auto& pair : pairs) {\n        sum += pair.first;\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << arrayPairSum({1,4,3,2}) << \"\\n\"; // Output: 6\n    std::cout << arrayPairSum({-1,0,1}) << \"\\n\"; // Output: -1\n    std::cout << arrayPairSum([1,-4,3,2]) << \"\\n\"; // Output: 5\n\n    return 0;\n}\n```",
  "600": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int findMaxLength(std::vector<int>& nums) {\n        int maxLen = 0;\n        int sum = 0;\n        std::unordered_map<int, int> map;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == 1)\n                sum++;\n            else\n                sum--;\n            \n            if (map.find(sum) != map.end()) {\n                maxLen = std::max(maxLen, i - map[sum]);\n            } else {\n                map[sum] = i;\n            }\n        }\n        \n        return maxLen;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> test1 = {0,1};\n    int result1 = solution.findMaxLength(test1);\n    if (result1 == 2) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed.\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> test2 = {0,1,0};\n    int result2 = solution.findMaxLength(test2);\n    if (result2 == 3) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed.\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> test3 = {0,1,1};\n    int result3 = solution.findMaxLength(test3);\n    if (result3 == 2) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "601": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int busyWaitTime(std::vector<std::string>& queries) {\n        int ans = 0;\n        for (const auto& q : queries) {\n            if (q[0] == 'S') {\n                ans += queryTime(q);\n            } else if (q[0] == 'T') {\n                ans -= queryTime(q);\n            }\n        }\n        return std::max(0, ans);\n    }\n\nprivate:\n    int queryTime(const std::string& q) {\n        int t = 0;\n        for (const auto c : q.substr(1)) {\n            if (c == 'W') {\n                t += 60;\n            } else if (c == 'M') {\n                t += 10;\n            }\n        }\n        return t;\n    }\n};\n\nint main() {\n    Solution s;\n\n    std::cout << \"Test Case 1: \" << s.busyWaitTime({\"SIWQBCDI\",\"SIZLKSYE\",\"TKIQRAMD\",\"TUPWLKJG\",\"FWLXGTYU\",\"SIZLKSYE\"}) << std::endl;\n    std::cout << \"Test Case 2: \" << s.busyWaitTime({\"TIKPWLSU\",\"SIQBCDIJ\",\"SIZLKSYEH\",\"TKIQRAMDC\",\"TUPWLKJGH\",\"FWLXGTYUI\",\"SIZLKSYE\"}) << std::endl;\n    std::cout << \"Test Case 3: \" << s.busyWaitTime({\"SQWLVMTD\",\"SIQBCDIJS\",\"SIZLKSYEHK\",\"TKIQRAMDCN\",\"TUPWLKJGHO\",\"FWLXGTYUIP\"}) << std::endl;\n\n    return 0;\n}\n```",
  "603": "```\n#include <iostream>\n#include <vector>\n\nint maximumConsecutiveSeats(std::vector<std::vector<int>>& seats) {\n    int maxConsecutive = 0;\n    for (int i = 0; i < seats.size(); ++i) {\n        int currentConsecutive = 1;\n        for (int j = 1; j <= seats[i].size(); ++j) {\n            if (seats[i][j-1] == seats[i][j]) {\n                ++currentConsecutive;\n            } else {\n                maxConsecutive = std::max(maxConsecutive, currentConsecutive);\n                currentConsecutive = 1;\n            }\n        }\n        maxConsecutive = std::max(maxConsecutive, currentConsecutive);\n    }\n    return maxConsecutive;\n}\n\nint main() {\n    std::vector<std::vector<int>> seats1 {{0, 1, 0}, {0, 0, 1}};\n    int result1 = maximumConsecutiveSeats(seats1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<std::vector<int>> seats2 {{1, 1, 1}, {0, 1, 0}, {0, 0, 1}};\n    int result2 = maximumConsecutiveSeats(seats2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<std::vector<int>> seats3 {{0, 0, 1, 0}, {1, 1, 0, 1}};\n    int result3 = maximumConsecutiveSeats(seats3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}",
  "602": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass FriendRequest {\npublic:\n    string personA;\n    string personB;\n};\n\nclass Solution {\npublic:\n    vector<string> mostFriends(vector<vector<string>>& requests) {\n        unordered_map<string, int> friendCount;\n        \n        for (const auto& request : requests) {\n            string person = request[0];\n            friendCount[person]++;\n            \n            if (request.size() > 1) {\n                friendCount[request[1]]++;\n            }\n        }\n        \n        int maxFriends = 0;\n        string mostPopularPerson = \"\";\n        \n        for (const auto& pair : friendCount) {\n            if (pair.second > maxFriends) {\n                maxFriends = pair.second;\n                mostPopularPerson = pair.first;\n            } else if (pair.second == maxFriends) {\n                mostPopularPerson += \", \" + pair.first;\n            }\n        }\n        \n        return {mostPopularPerson};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> requests1 = {{\"John\", \"Moe\"}, {\"Mary\", \"Jane\"}};\n    vector<string> result1 = solution.mostFriends(requests1);\n    cout << \"Test case 1: \";\n    for (const auto& person : result1) {\n        cout << person << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<vector<string>> requests2 = {{\"Bob\", \"Alice\"}, {\"Alice\", \"Bob\"}, {\"Charlie\", \"Bob\"}};\n    vector<string> result2 = solution.mostFriends(requests2);\n    cout << \"Test case 2: \";\n    for (const auto& person : result2) {\n        cout << person << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<vector<string>> requests3 = {{\"John\", \"Jane\"}, {\"Jane\", \"Moe\"}};\n    vector<string> result3 = solution.mostFriends(requests3);\n    cout << \"Test case 3: \";\n    for (const auto& person : result3) {\n        cout << person << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "604": "```\n#include <iostream>\n#include <string>\n\nclass StringIterator {\npublic:\n    StringIterator(const std::string& compressedString) : compressedString(compressedString), index(0) {}\n\n    char next() {\n        if (index >= compressedString.size()) return ' ';\n        while (index + 1 < compressedString.size() && compressedString[index] == compressedString[index + 1]) {\n            index++;\n        }\n        if (index >= compressedString.size()) return ' ';\n        return compressedString[index++];\n    }\n\n    bool hasNext() { return index < compressedString.size(); }\n\nprivate:\n    std::string compressedString;\n    int index;\n};\n\nint main() {\n    StringIterator* iterator = new StringIterator(\"AAABCCCC\");\n    for (int i = 0; i < 7; ++i) {\n        if (i % 2 == 1) {\n            std::cout << iterator->next();\n        }\n    }\n    delete iterator;\n\n    iterator = new StringIterator(\"AAAABBBCCD\");\n    while (iterator->hasNext()) {\n        char c = iterator->next();\n        if (c != ' ') {\n            for (int i = 0; i < 3 && c == 'A'; ++i) {\n                std::cout << c;\n            }\n            c = iterator->next();\n            while (c == 'B') {\n                std::cout << c;\n                c = iterator->next();\n            }\n        }\n        if (c != ' ') {\n            std::cout << c;\n        }\n    }\n    delete iterator;\n\n    iterator = new StringIterator(\"abc\");\n    while (iterator->hasNext()) {\n        char c = iterator->next();\n        std::cout << c;\n    }\n    delete iterator;\n    return 0;\n}\n```",
  "605": "```\n#include <iostream>\n#include <vector>\n\nbool canPlaceFlowers(std::vector<int>& flowerbed, int n) {\n    for (int i = 0; i < flowerbed.size(); i++) {\n        if ((i == 0 || flowerbed[i - 1] == 0) && flowerbed[i] == 0 && (i == flowerbed.size() - 1 || flowerbed[i + 1] == 0)) {\n            flowerbed[i] = 1;\n            n--;\n            i++;\n        }\n    }\n    return n <= 0;\n}\n\nint main() {\n    std::vector<int> flowerbed1 = {1,0,0};\n    std::cout << (canPlaceFlowers(flowerbed1, 3) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> flowerbed2 = {1,0,0,0,1};\n    std::cout << (canPlaceFlowers(flowerbed2, 4) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> flowerbed3 = {1,1,0,0,1};\n    std::cout << (canPlaceFlowers(flowerbed3, 4) ? \"True\" : \"False\") << std::endl;\n    \n    return 0;\n}\n```",
  "607": "```\n#include <iostream>\n#include <string>\n\nclass SalesPerson {\npublic:\n    std::string name;\n    int totalSales;\n\n    SalesPerson(std::string n, int ts) : name(n), totalSales(ts) {}\n};\n\nint main() {\n    // Test case 1\n    SalesPerson sp1(\"John\", 1000);\n    std::cout << \"Test Case 1: Name = \" << sp1.name << \", Total Sales = \" << sp1.totalSales << std::endl;\n\n    // Test case 2\n    SalesPerson sp2(\"Jane\", 2000);\n    std::cout << \"Test Case 2: Name = \" << sp2.name << \", Total Sales = \" << sp2.totalSales << std::endl;\n\n    // Test case 3\n    SalesPerson sp3(\"Bob\", 500);\n    std::cout << \"Test Case 3: Name = \" << sp3.name << \", Total Sales = \" << sp3.totalSales << std::endl;\n\n    return 0;\n}\n```",
  "606": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nstring tree2str(TreeNode* t) {\n    if (!t) return \"\";\n    string res = \"\";\n\n    if (t->val == 1) {\n        res += \"1\";\n        if (t->left || t->right)\n            res += \"(\" + tree2str(t->left) + \")\" +\n                   ((t->right) ? \"(\" + tree2str(t->right) + \")\" : \"\");\n    } else {\n        res = \"\";\n        if (t->left) res += \"(\" + tree2str(t->left) + \")\";\n        if (t->right) res += \"(\" + tree2str(t->right) + \")\";\n    }\n    return res;\n}\n\nint main() {\n    TreeNode* t1 = new TreeNode(1);\n    t1->left = new TreeNode(0);\n    t1->right = new TreeNode(0);\n    \n    cout << \"Test Case 1: \" << tree2str(t1) << endl; // Output: \"1(()())\"\n    \n    TreeNode* t2 = new TreeNode(1);\n    t2->left = new TreeNode(0);\n    t2->right = new TreeNode(1);\n\n    cout << \"Test Case 2: \" << tree2str(t2) << endl; // Output: \"1(0(1))\"\n    \n    TreeNode* t3 = new TreeNode(1);\n    t3->left = new TreeNode(1);\n\n    cout << \"Test Case 3: \" << tree2str(t3) << endl; // Output: \"1(1)\"\n    \n    return 0;\n}\n```",
  "608": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    std::vector<int> preorderTraversal(TreeNode* root) {\n        std::vector<int> result;\n        dfs(root, result);\n        return result;\n    }\n\nprivate:\n    void dfs(TreeNode* node, std::vector<int>& result) {\n        if (node == nullptr) return;\n        result.push_back(node->val);\n        dfs(node->left, result);\n        dfs(node->right, result);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(2);\n    std::vector<int> expected1 = {1, 3, 2};\n    auto result1 = solution.preorderTraversal(root1);\n    if (result1 != expected1) {\n        std::cout << \"Test case 1 failed.\\n\";\n        return 1;\n    }\n    delete root1;\n\n    // Test case 2:\n    TreeNode* root2 = new TreeNode(4);\n    root2->left = new TreeNode(7);\n    root2->right = new TreeNode(8);\n    std::vector<int> expected2 = {4, 7, 8};\n    auto result2 = solution.preorderTraversal(root2);\n    if (result2 != expected2) {\n        std::cout << \"Test case 2 failed.\\n\";\n        return 1;\n    }\n    delete root2;\n\n    // Test case 3:\n    TreeNode* root3 = nullptr;\n    std::vector<int> expected3 = {};\n    auto result3 = solution.preorderTraversal(root3);\n    if (result3 != expected3) {\n        std::cout << \"Test case 3 failed.\\n\";\n        return 1;\n    }\n\n    std::cout << \"All test cases passed!\\n\";\n    return 0;\n}\n```",
  "609": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> findDuplicate(vector<vector<string>>& paths) {\n        unordered_map<string, int> dirMap;\n        vector<vector<string>> res;\n\n        for (const auto& path : paths) {\n            string dir = \"\";\n            for (int i = 0; i < path.size(); ++i) {\n                if (path[i].find(' ') != string::npos) {\n                    dir += path[i] + \"/\";\n                    break;\n                }\n                dir += path[i];\n            }\n\n            if (!dirMap.count(dir)) {\n                dirMap[dir] = 1;\n            } else {\n                res.push_back(path);\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test Case 1\n    vector<vector<string>> paths1 = {{\"root/a 1.txt\", \"root/c 2.txt\", \"root/c 3.txt\"}, {\"root/d 4.txt\", \"root/f g.txt\"}};\n    vector<vector<string>> res1 = s.findDuplicate(paths1);\n    for (const auto& path : res1) {\n        for (const auto& file : path) {\n            cout << file << endl;\n        }\n        cout << endl;\n    }\n\n    // Test Case 2\n    vector<vector<string>> paths2 = {{\"root/a 1.txt\", \"root/a 2.txt\", \"root/a 3.txt\"}, {\"root/d 4.txt\"}};\n    vector<vector<string>> res2 = s.findDuplicate(paths2);\n    for (const auto& path : res2) {\n        for (const auto& file : path) {\n            cout << file << endl;\n        }\n        cout << endl;\n    }\n\n    // Test Case 3\n    vector<vector<string>> paths3 = {{\"root/a.txt\", \"root/c.txt\"}, {\"root/d 4.txt\", \"root/f g.txt\"}};\n    vector<vector<string>> res3 = s.findDuplicate(paths3);\n    for (const auto& path : res3) {\n        for (const auto& file : path) {\n            cout << file << endl;\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "610": "```\n#include <iostream>\n#include <vector>\n\nbool isTriangle(std::vector<int>& triangle) {\n    int a = triangle[0];\n    int b = triangle[1];\n    int c = triangle[2];\n\n    if (a + b <= c || a + c <= b || b + c <= a) return false;\n    return true;\n}\n\nint main() {\n    std::vector<int> test1({2, 2, 3});\n    std::cout << \"Test case 1: \" << (isTriangle(test1) ? \"Yes\" : \"No\") << std::endl;\n\n    std::vector<int> test2({5, 1, 2});\n    std::cout << \"Test case 2: \" << (isTriangle(test2) ? \"Yes\" : \"No\") << std::endl;\n\n    std::vector<int> test3({0, 0, 10000000});\n    std::cout << \"Test case 3: \" << (isTriangle(test3) ? \"Yes\" : \"No\") << std::endl;\n\n    return 0;\n}\n```",
  "611": "```\n#include <iostream>\n#include <vector>\n\nint triangleNumber(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int result = 0;\n    for (int i = 0; i < nums.size() - 2; ++i) {\n        int left = i + 1, right = nums.size() - 1;\n        while (left < right) {\n            if (nums[left] + nums[i] > nums[right]) {\n                result = std::max(result, nums[left] + nums[i]);\n                --right;\n            } else {\n                ++left;\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::vector<int> test1 = {2, 3, 4};\n    std::cout << \"Test case 1: \" << triangleNumber(test1) << std::endl;\n\n    std::vector<int> test2 = {5, 7, 8};\n    std::cout << \"Test case 2: \" << triangleNumber(test2) << std::endl;\n\n    std::vector<int> test3 = {12, 13, 14, 17};\n    std::cout << \"Test case 3: \" << triangleNumber(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "613": "```\n#include <iostream>\n#include <vector>\n\nint findShortestDistance(std::vector<int> coordinates) {\n    if (coordinates.size() < 2) {\n        return -1;\n    }\n\n    int minDiff = INT_MAX;\n\n    for (int i = 0; i < coordinates.size() - 1; i++) {\n        for (int j = i + 1; j < coordinates.size(); j++) {\n            int diff = abs(coordinates[j] - coordinates[i]);\n            if (diff < minDiff) {\n                minDiff = diff;\n            }\n        }\n    }\n\n    return minDiff;\n}\n\nint main() {\n    std::vector<int> test1 = {3, 2};\n    std::cout << \"Test Case 1: \" << findShortestDistance(test1) << std::endl;\n\n    std::vector<int> test2 = {4, 8, 15, 23, 42};\n    std::cout << \"Test Case 2: \" << findShortestDistance(test2) << std::endl;\n\n    std::vector<int> test3 = {1, 5, 10};\n    std::cout << \"Test Case 3: \" << findShortestDistance(test3) << std::endl;\n\n    return 0;\n}\n```",
  "612": "```\n#include <iostream>\n#include <vector>\n\nint shortestDistance(std::vector<std::vector<int>>& positions) {\n    int res = INT_MAX;\n    for (int i = 0; i < positions.size() - 1; i++) {\n        for (int j = i + 1; j < positions.size(); j++) {\n            int dist = getEuclideanDistance(positions[i], positions[j]);\n            if (dist < res) {\n                res = dist;\n            }\n        }\n    }\n    return res;\n}\n\nint getEuclideanDistance(const std::vector<int>& p1, const std::vector<int>& p2) {\n    int dx = p1[0] - p2[0];\n    int dy = p1[1] - p2[1];\n    return (int)std::sqrt(dx * dx + dy * dy);\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::vector<int>> positions1 = {{0, 0}, {3, 1}};\n    int res1 = shortestDistance(positions1);\n    std::cout << \"Test Case 1: \" << res1 << std::endl;\n\n    // Test Case 2\n    std::vector<std::vector<int>> positions2 = {{1, 3}, {4, -1}};\n    int res2 = shortestDistance(positions2);\n    std::cout << \"Test Case 2: \" << res2 << std::endl;\n\n    // Test Case 3\n    std::vector<std::vector<int>> positions3 = {{0, 0}, {-5, -6}};\n    int res3 = shortestDistance(positions3);\n    std::cout << \"Test Case 3: \" << res3 << std::endl;\n    \n    return 0;\n}\n```",
  "614": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findSecondDegreeFollowers(vector<vector<string>>& fansOfFans, set<string>& followings) {\n        unordered_map<string, set<string>> fanMap;\n        for (const auto& fan : fansOfFans) {\n            for (const auto& followee : fan) {\n                fanMap[followee].insert(fan[0]);\n            }\n        }\n\n        vector<string> result;\n        for (const auto& following : followings) {\n            if (!fanMap.count(following)) continue;\n\n            for (const auto& fan : fanMap.at(following)) {\n                if (!result.end()->count(fan)) {\n                    result.push_back(fan);\n                }\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> fansOfFans1 = {{\"joe\", \"mark\"}, {\"mary\", \"joe\"}, {\"mark\", \"sarah\"}};\n    set<string> followings1 = {\"joe\", \"mary\"};\n    vector<string> expectedResult1 = {\"mark\", \"sarah\"};\n    assert(solution.findSecondDegreeFollowers(fansOfFans1, followings1) == expectedResult1);\n\n    // Test case 2\n    vector<vector<string>> fansOfFans2 = {{\"bob\", \"joe\"}, {\"joe\", \"mark\"}};\n    set<string> followings2 = {\"bob\"};\n    vector<string> expectedResult2 = {\"joe\", \"mark\"};\n    assert(solution.findSecondDegreeFollowers(fansOfFans2, followings2) == expectedResult2);\n\n    // Test case 3\n    vector<vector<string>> fansOfFans3 = {};\n    set<string> followings3 = {};\n    vector<string> expectedResult3 = {};\n    assert(solution.findSecondDegreeFollowers(fansOfFans3, followings3) == expectedResult3);\n\n    return 0;\n}\n```",
  "615": "```\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<double> average(vector<vector<string>> salaries) {\n        map<string, int> departmentSalaries;\n        map<string, int> totalCompanySalary = {{\"\" , 0}};\n\n        for (const auto& salary : salaries) {\n            string department = salary[1];\n            int salaryInt = stoi(salary[2]);\n\n            if (!department.empty()) {\n                departmentSalaries[department] += salaryInt;\n                totalCompanySalary[\"\"] += salaryInt;\n            } else {\n                totalCompanySalary[\"\"] += salaryInt;\n            }\n        }\n\n        vector<double> result;\n        for (const auto& pair : departmentSalaries) {\n            result.push_back((double)pair.second / salaries.size());\n        }\n\n        result.push_back((double)totalCompanySalary[\"\"] / salaries.size());\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<string>> test1 = {{\"John\", \"A\", \"100\"},\n                                    {\"Steve\", \"B\", \"200\"},\n                                    {\"John\", \"\", \"300\"}};\n    vector<double> expected1 = {166.67, 400.0};\n    assert(solution.average(test1) == expected1);\n\n    vector<vector<string>> test2 = {{\"Alice\", \"C\", \"100\"},\n                                   {\"Bob\", \"C\", \"200\"},\n                                   {\"Alice\", \"\", \"300\"}};\n    vector<double> expected2 = {233.33, 600.0};\n    assert(solution.average(test1) == expected1);\n    assert(solution.average(test2) == expected2);\n\n    vector<vector<string>> test3 = {{\"John\", \"A\", \"100\"},\n                                   {\"Steve\", \"B\", \"200\"}};\n    vector<double> expected3 = {150.0, 300.0};\n    assert(solution.average(test3) == expected3);\n\n    return 0;\n}\n```",
  "616": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string addBoldTag(string s, vector<string>& dict) {\n        int n = s.size();\n        vector<int> pos;\n        for (int i = 0; i < n; ++i) {\n            for (const auto& word : dict) {\n                if (s.substr(i, word.size()) == word) {\n                    pos.push_back(i);\n                    i += word.size() - 1;\n                    break;\n                }\n            }\n        }\n\n        string res = \"\";\n        int start = 0;\n        for (int i = 0; i < pos.size(); ++i) {\n            if (pos[i] > start) {\n                res += s.substr(start, pos[i] - start);\n            }\n            while (i + 1 < pos.size() && pos[i] == pos[i + 1]) {\n                i++;\n            }\n            res += \"<b>\" + s.substr(pos[i], dict[pos.size() - 1].size()) + \"</b>\";\n            start = pos[i] + dict[pos.size() - 1].size();\n        }\n\n        if (start < n) {\n            res += s.substr(start, n - start);\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> dict;\n\n    cout << solution.addBoldTag(\"abcxyz123\", {\"abc\", \"cdx\"}) << endl; // \"abc<b>cdx</b>123\"\n    cout << solution.addBoldTag(\"We_love_big_smiles\", {\"lovely\", \"big\"}) << endl; // \"<b>We</b><b>lovable</b>_<b>big</b>_smiles\"\n    cout << solution.addBoldTag(\"LeetCode\", {\"leet\"}) << endl; // \"<b>leet</b>Code\"\n\n    return 0;\n}\n```",
  "617": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if (!t1 && !t2) return nullptr;\n        else if (!t1) return t2;\n        else if (!t2) return t1;\n\n        t1->val += t2->val;\n        \n        t1->left = mergeTrees(t1->left, t2->left);\n        t1->right = mergeTrees(t1->right, t2->right);\n\n        if (t1->left == nullptr && t2->left) {\n            TreeNode* temp = t2->left;\n            t2->left = t1;\n            t1 = temp;\n        }\n        if (t1->right == nullptr && t2->right) {\n            TreeNode* temp = t2->right;\n            t2->right = t1;\n            t1 = temp;\n        }\n\n        return t1;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test Case 1\n    TreeNode* t1 = new TreeNode(1);\n    t1->left = new TreeNode(3);\n    t1->right = new TreeNode(2);\n\n    TreeNode* t2 = new TreeNode(2);\n    t2->left = new TreeNode(1);\n    t2->right = new TreeNode(3);\n\n    TreeNode* result = s.mergeTrees(t1, t2);\n\n    // Test Case 2\n    t1 = nullptr;\n    t2 = new TreeNode(5);\n\n    result = s.mergeTrees(t1, t2);\n\n    // Test Case 3\n    t1 = new TreeNode(4);\n    t1->left = new TreeNode(1);\n    t1->right = new TreeNode(6);\n\n    t2 = new TreeNode(5);\n    t2->left = new TreeNode(2);\n    t2->right = new TreeNode(7);\n\n    result = s.mergeTrees(t1, t2);\n\n    return 0;\n}\n```",
  "618": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Report {\n    std::string geography;\n    int count;\n};\n\nclass Solution {\npublic:\n    std::vector<Report> generateReports(std::vector<std::pair<int, std::string>>& reports) {\n        std::unordered_map<std::string, int> reportCounts;\n        \n        for (const auto& report : reports) {\n            if (reportCounts.find(report.second) == reportCounts.end()) {\n                reportCounts[report.second] = 1;\n            } else {\n                reportCounts[report.second]++;\n            }\n        }\n        \n        std::vector<Report> result;\n        \n        for (const auto& pair : reportCounts) {\n            Report report;\n            report.geography = pair.first;\n            report.count = pair.second;\n            result.push_back(report);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::pair<int, std::string>> reports1 = {{1, \"North\"}, {2, \"South\"}, {3, \"North\"}};\n    auto reports1Result = solution.generateReports(reports1);\n    for (const auto& report : reports1Result) {\n        std::cout << \"Geography: \" << report.geography << \", Count: \" << report.count << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::pair<int, std::string>> reports2 = {{4, \"East\"}, {5, \"West\"}, {6, \"East\"}};\n    auto reports2Result = solution.generateReports(reports2);\n    for (const auto& report : reports2Result) {\n        std::cout << \"Geography: \" << report.geography << \", Count: \" << report.count << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::pair<int, std::string>> reports3 = {{7, \"North\"}, {8, \"South\"}, {9, \"North\"}};\n    auto reports3Result = solution.generateReports(reports3);\n    for (const auto& report : reports3Result) {\n        std::cout << \"Geography: \" << report.geography << \", Count: \" << report.count << std::endl;\n    }\n\n    return 0;\n}\n```",
  "619": "```\n#include <iostream>\n#include <string>\n\nint maxNumber(std::string column1) {\n    int max = 0;\n    for (char c : column1) {\n        if (c >= '1' && c <= '9') {\n            max = std::max(max, c - '0');\n        }\n    }\n    return max;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << maxNumber(\"leet=1:code=2\") << std::endl; // Expected output: 2\n    std::cout << \"Test Case 2: \" << maxNumber(\"ahf=3:jk=1\") << std::endl; // Expected output: 3\n    std::cout << \"Test Case 3: \" << maxNumber(\"hello=5\") << std::endl; // Expected output: 5\n\n    return 0;\n}\n```",
  "620": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findNotBoringMovies(vector<vector<string>>& watched) {\n        vector<string> result;\n        for (const auto& movie : watched) {\n            if (!contains(movie, \"boring\")) {\n                result.push_back(movie[0]);\n            }\n        }\n        return result;\n    }\n\nprivate:\n    bool contains(const vector<string>& movie, const string& word) {\n        for (const auto& item : movie) {\n            if (item.find(word) != string::npos) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> watched1 = {{\"Movie A\", \"Tom Hanks\", \"not boring\"}, {\"Movie B\", \"boring\"}, {\"Movie C\", \"Boring\"}};\n    vector<string> result1 = solution.findNotBoringMovies(watched1);\n    cout << \"Test case 1: \";\n    for (const auto& movie : result1) {\n        cout << movie << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<vector<string>> watched2 = {{\"Movie D\", \"not boring\"}, {\"Movie E\", \"boring\"}};\n    vector<string> result2 = solution.findNotBoringMovies(watched2);\n    cout << \"Test case 2: \";\n    for (const auto& movie : result2) {\n        cout << movie << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<vector<string>> watched3 = {{\"Movie F\", \"Tom Hanks\", \"boring\"}, {\"Movie G\", \"not boring\"}};\n    vector<string> result3 = solution.findNotBoringMovies(watched3);\n    cout << \"Test case 3: \";\n    for (const auto& movie : result3) {\n        cout << movie << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "621": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint leastInterval(std::vector<char>& tasks, int n) {\n    std::unordered_map<char, int> taskCount;\n    for (char task : tasks) {\n        taskCount[task]++;\n    }\n    \n    std::priority_queue<int> pq;\n    for (auto& p : taskCount) {\n        pq.push(p.second);\n    }\n    \n    int maxTime = 0;\n    while (!pq.empty()) {\n        int time = n + 1;\n        while (time > n && !pq.empty()) {\n            time -= pq.top();\n            pq.pop();\n        }\n        if (time > maxTime) {\n            maxTime = time;\n        }\n    }\n    \n    return tasks.size() + maxTime - 1;\n}\n\nint main() {\n    std::vector<char> tasks1 = {'A', 'A', 'A', 'B', 'C'};\n    std::cout << leastInterval(tasks1, 2) << std::endl; // Expected output: 8\n    \n    std::vector<char> tasks2 = {'A', 'A', 'A', 'A', 'A', 'A', 'B', 'C', 'D', 'E', 'F'};\n    std::cout << leastInterval(tasks2, 3) << std::endl; // Expected output: 16\n    \n    std::vector<char> tasks3 = {'A', 'B', 'A', 'C'};\n    std::cout << leastInterval(tasks3, 3) << std::endl; // Expected output: 9\n}\n```",
  "622": "```\n#include <iostream>\n#include <vector>\n\nclass MyCircularQueue {\nprivate:\n    int size;\n    std::vector<int> queue;\n\npublic:\n    MyCircularQueue(int k) : size(k), queue(k) {}\n\n    bool enQueue(int value) {\n        if ((queue.size() + 1) > size) return false;\n        queue.push_back(value);\n        return true;\n    }\n\n    bool deQueue() {\n        if (queue.empty()) return false;\n        queue.erase(queue.begin());\n        return true;\n    }\n\n    int front() {\n        if (queue.empty()) return -1;\n        return queue[0];\n    }\n\n    int rear() {\n        if (queue.empty()) return -1;\n        return queue.back();\n    }\n\n    bool isEmpty() {\n        return queue.empty();\n    }\n\n    bool isFull() {\n        return queue.size() == size;\n    }\n};\n\nint main() {\n    MyCircularQueue obj(3);\n\n    std::cout << \"Test Case 1: Enqueue and Dequeue\\n\";\n    if (obj.enQueue(2)) std::cout << \"Enqueued 2 successfully.\\n\";\n    if (!obj.deQueue()) std::cout << \"Dequeued 2 successfully.\\n\";\n    if (obj.front() == -1) std::cout << \"Front is empty, expected -1.\\n\";\n    if (obj.rear() == -1) std::cout << \"Rear is empty, expected -1.\\n\";\n    if (!obj.isEmpty()) std::cout << \"Queue is not empty, expected false.\\n\";\n    if (!obj.isFull()) std::cout << \"Queue is full, expected false.\\n\";\n\n    std::cout << \"\\nTest Case 2: Enqueue and Dequeue repeatedly\\n\";\n    for (int i = 1; i <= 3; i++) {\n        obj.enQueue(i);\n        std::cout << \"Enqueued \" << i << \" successfully.\\n\";\n    }\n    for (int i = 3; i >= 1; i--) {\n        if (!obj.deQueue()) std::cout << \"Dequeued \" << i << \" successfully.\\n\";\n    }\n\n    std::cout << \"\\nTest Case 3: Enqueue beyond capacity and Dequeue\\n\";\n    while (!obj.isFull()) {\n        obj.enQueue(4);\n        std::cout << \"Enqueued 4 successfully.\\n\";\n    }\n    for (int i = 1; i <= 3; i++) {\n        if (!obj.deQueue()) std::cout << \"Dequeued 4 successfully.\\n\";\n    }\n\n    return 0;\n}\n```",
  "623": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* addOneRow(TreeNode* root, int val, int depth) {\n        if (depth == 1) return new TreeNode(val);\n        queue<TreeNode*> q;\n        q.push(root);\n        int curDepth = 1;\n        while (!q.empty()) {\n            int n = q.size();\n            for (int i = 0; i < n; i++) {\n                TreeNode* node = q.front(); q.pop();\n                if (curDepth == depth - 1) {\n                    TreeNode* newNode = new TreeNode(val);\n                    node->left ? q.push(node->left) : void(0);\n                    node->right ? q.push(node->right) : void(0);\n                    node->val = val;\n                } else if (node->left) q.push(node->left);\n                else if (node->right) q.push(node->right);\n            }\n            curDepth++;\n        }\n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    TreeNode* root = new TreeNode(4);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(6);\n    root->left->left = new TreeNode(3);\n    root->left->right = new TreeNode(1);\n    root->right->left = new TreeNode(5);\n    \n    root = solution.addOneRow(root, 1, 2);\n    \n    // Test Case 2\n    root = new TreeNode(1);\n    root->left = new TreeNode(4);\n    root->right = new TreeNode(3);\n    \n    root = solution.addOneRow(root, 2, 3);\n    \n    // Test Case 3\n    root = new TreeNode(0);\n    \n    root = solution.addOneRow(root, 1, 2);\n    \n    return 0;\n}\n```",
  "625": "```\n#include <iostream>\n#include <vector>\n\nint minFactorSum(int target) {\n    int sum = 0;\n    for (int i = 1; i <= target / 2; ++i) {\n        while (target % i == 0) {\n            sum += i;\n            target /= i;\n        }\n    }\n    if (target > 0) {\n        sum += target;\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << minFactorSum(12) << std::endl; // Expected output: 28\n    std::cout << minFactorSum(37) << std::endl; // Expected output: 37\n    std::cout << minFactorSum(48) << std::endl; // Expected output: 56\n    \n    return 0;\n}\n```",
  "624": "```\n#include <iostream>\n#include <vector>\n\nint maxDistance(std::vector<int>& nums1, std::vector<int>& nums2) {\n    int m = nums1.size(), n = nums2.size();\n    std::vector<std::pair<int, int>> pairs;\n    \n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (nums1[i] == nums2[j]) {\n                pairs.push_back({i, j});\n            }\n        }\n    }\n\n    int maxDist = 0;\n    for (const auto& pair : pairs) {\n        int dist = abs(pair.first - pair.second);\n        if (dist > maxDist) {\n            maxDist = dist;\n        }\n    }\n\n    return maxDist;\n}\n\nint main() {\n    std::vector<int> nums1 = {4, 5, 6};\n    std::vector<int> nums2 = {3, 7, 8};\n    int expected = 2; // 5 - 3 = 2\n\n    std::cout << \"Test Case 1: \" << maxDistance(nums1, nums2) << \" (Expected: \" << expected << \")\" << std::endl;\n\n    nums1 = {1, 4, 8};\n    nums2 = {7, 9, 10};\n    expected = 3; // 8 - 5 = 3\n\n    std::cout << \"Test Case 2: \" << maxDistance(nums1, nums2) << \" (Expected: \" << expected << \")\" << std::endl;\n\n    nums1 = {7, 7};\n    nums2 = {4, 10};\n    expected = 0; // No pairs found\n\n    std::cout << \"Test Case 3: \" << maxDistance(nums1, nums2) << \" (Expected: \" << expected << \")\" << std::endl;\n\n    return 0;\n}",
  "626": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> exchangeSeats(vector<vector<int>>& seats) {\n        int n = seats.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (seats[i][0] > seats[j][0]) {\n                    swap(seats[i], seats[j]);\n                }\n            }\n        }\n        return seats;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> seats1 = {{1, 2}, {1, 3}, {2, 1}};\n    vector<vector<int>> expectedSeats1 = {{1, 2}, {1, 3}, {2, 1}};\n    if (solution.exchangeSeats(seats1) != expectedSeats1)\n        return 1;\n\n    vector<vector<int>> seats2 = {{1, 5}, {2, 1}, {3, 4}};\n    vector<vector<int>> expectedSeats2 = {{1, 5}, {2, 1}, {3, 4}};\n    if (solution.exchangeSeats(seats2) != expectedSeats2)\n        return 1;\n\n    vector<vector<int>> seats3 = {{7, 9}, {6, 6}, {8, 7}, {5, 1}, {5, 4}};\n    vector<vector<int>> expectedSeats3 = {{7, 9}, {6, 6}, {8, 7}, {5, 1}, {5, 4}};\n    if (solution.exchangeSeats(seats3) != expectedSeats3)\n        return 1;\n\n    cout << \"All test cases passed.\" << endl;\n    return 0;\n}\n```",
  "627": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<std::string> getTable(std::vector<std::vector<int>>& accounts) {\n        int n = accounts.size();\n        for (int i = 0; i < n; ++i) {\n            for (int j = 1; j <= accounts[i].size() - 1; ++j) {\n                if (accounts[i][j] == 0) {\n                    for (int k = j; k <= accounts[i].size() - 2; ++k) {\n                        accounts[i][k] += accounts[i][k + 1];\n                        accounts[i][k + 1] = 0;\n                    }\n                }\n            }\n        }\n        std::vector<std::string> result;\n        for (int i = 0; i < n; ++i) {\n            if (!accounts[i].empty()) {\n                result.push_back(\"<\" + std::to_string(i) + \",\" + std::to_string(accounts[i][0]) + \">\");\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::vector<int>> accounts1 = {{10,20},{3}, {10,15}};\n    std::vector<std::string> expected1 = {\"0,5\",\"1,500\"};\n    auto result1 = solution.getTable(accounts1);\n    for (int i = 0; i < result1.size(); ++i) {\n        if (result1[i] != expected1[i]) {\n            return 1;\n        }\n    }\n\n    // Test Case 2\n    std::vector<std::vector<int>> accounts2 = {{10,20},{5}, {10}};\n    std::vector<std::string> expected2 = {\"0,60\",\"1,300\"};\n    auto result2 = solution.getTable(accounts2);\n    for (int i = 0; i < result2.size(); ++i) {\n        if (result2[i] != expected2[i]) {\n            return 1;\n        }\n    }\n\n    // Test Case 3\n    std::vector<std::vector<int>> accounts3 = {{10,20},{5,15}};\n    std::vector<std::string> expected3 = {\"0,30\"};\n    auto result3 = solution.getTable(accounts3);\n    for (int i = 0; i < result3.size(); ++i) {\n        if (result3[i] != expected3[i]) {\n            return 1;\n        }\n    }\n\n    std::cout << \"All test cases passed.\" << std::endl;\n    return 0;\n}\n```",
  "628": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxProduct(std::vector<int>& nums) {\n    if (nums.size() < 3) return -1;\n\n    std::sort(nums.begin(), nums.end());\n\n    return std::max(nums[0] * nums[1] * nums[nums.size()-1], \n                    nums[nums.size()-1] * nums[nums.size()-2] * nums[0]);\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {3, 4, 5};\n    int result1 = maxProduct(test1);\n    if (result1 != 60) {\n        std::cout << \"Test case 1 failed. Expected: 60, got: \" << result1 << std::endl;\n        return -1;\n    }\n\n    // Test case 2\n    std::vector<int> test2 = {0, 0, 0};\n    int result2 = maxProduct(test2);\n    if (result2 != 0) {\n        std::cout << \"Test case 2 failed. Expected: 0, got: \" << result2 << std::endl;\n        return -1;\n    }\n\n    // Test case 3\n    std::vector<int> test3 = {1, 2, 3};\n    int result3 = maxProduct(test3);\n    if (result3 != 6) {\n        std::cout << \"Test case 3 failed. Expected: 6, got: \" << result3 << std::endl;\n        return -1;\n    }\n\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}\n```",
  "629": "```\n#include <iostream>\n#include <vector>\n\nint findKInverse(int* nums1, int nums1Size, int* nums2, int nums2Size, int k) {\n    std::vector<int> res;\n    for (int i = 0; i < nums1Size; ++i) {\n        for (int j = 0; j < nums2Size; ++j) {\n            if (nums1[i] > nums2[j]) {\n                res.push_back(nums1[i]);\n                --k;\n                if (k == 0) return res.size();\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int test1[] = {2,3};\n    int test1Size = sizeof(test1)/sizeof(test1[0]);\n    int test2[] = {1,4};\n    int test2Size = sizeof(test2)/sizeof(test2[0]);\n    std::cout << \"Test case 1: \" << findKInverse(test1, test1Size, test2, test2Size, 5) << std::endl;\n    \n    int test3[] = {2,4};\n    int test3Size = sizeof(test3)/sizeof(test3[0]);\n    int test4[] = {1,3};\n    int test4Size = sizeof(test4)/sizeof(test4[0]);\n    std::cout << \"Test case 2: \" << findKInverse(test3, test3Size, test4, test4Size, 3) << std::endl;\n    \n    int test5[] = {1,2};\n    int test5Size = sizeof(test5)/sizeof(test5[0]);\n    int test6[] = {3,4};\n    int test6Size = sizeof(test6)/sizeof(test6[0]);\n    std::cout << \"Test case 3: \" << findKInverse(test5, test5Size, test6, test6Size, 2) << std::endl;\n    \n    return 0;\n}",
  "630": "```\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    int scheduleCourse(vector<vector<int>>& courses) {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        \n        for (const auto& course : courses) {\n            int end = course[1];\n            int start = course[0];\n            \n            if (!pq.empty() && pq.top().first <= start) {\n                pq.pop();\n            }\n            \n            pq.push({end, start});\n            \n            if (pq.size() > 1000000) {\n                return -1;\n            }\n        }\n        \n        long long totalMinutes = 0;\n        while (!pq.empty()) {\n            totalMinutes += pq.top().second;\n            pq.pop();\n        }\n        \n        return static_cast<int>(totalMinutes);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<int>> courses1 = {{1,2},{2,3},{3,4}};\n    cout << \"Test case 1: \" << solution.scheduleCourse(courses1) << endl; // Output: 6\n\n    vector<vector<int>> courses2 = {{1,1000000},{2,1000001},{3,1000003}};\n    cout << \"Test case 2: \" << solution.scheduleCourse(courses2) << endl; // Output: -1\n\n    vector<vector<int>> courses3 = {{1,2},{2,3},{4,5}};\n    cout << \"Test case 3: \" << solution.scheduleCourse(courses3) << endl; // Output: 11\n    \n    return 0;\n}\n```",
  "631": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass ExcelSheet {\npublic:\n    ExcelSheet(vector<string>& columnNames) {\n        this->columnNames = columnNames;\n        for (int i = 0; i < columnNames.size(); i++) {\n            columnIndexMap[columnNames[i]] = i + 1;\n        }\n    }\n\n    int get(int row, string column) {\n        int index = columnIndexMap[column];\n        return (row - 1) * columnNames.size() + index;\n    }\n\nprivate:\n    vector<string> columnNames;\n    unordered_map<string, int> columnIndexMap;\n};\n\nint main() {\n    vector<string> columnNames = {\"A\", \"B\", \"C\"};\n    ExcelSheet excel(columnNames);\n\n    cout << excel.get(1, \"A\") << endl; // 0\n    cout << excel.get(2, \"B\") << endl; // 4\n    cout << excel.get(3, \"C\") << endl; // 5\n\n    return 0;\n}\n```",
  "633": "```\n#include <iostream>\n#include <vector>\n\nbool judgeSquareSum(int c) {\n    for (int i = 0; i * i <= c; ++i) {\n        int j = (int)std::sqrt(c - i * i);\n        if (i * i + j * j == c) return true;\n    }\n    return false;\n}\n\nint main() {\n    std::cout << judgeSquareSum(5) << std::endl; // True\n    std::cout << judgeSquareSum(3) << std::endl; // False\n    std::cout << judgeSquareSum(12) << std::endl; // True\n    \n    return 0;\n}\n```",
  "632": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Interval {\n    int start;\n    int end;\n};\n\nclass Solution {\npublic:\n    vector<int> smallestRange(vector<vector<int>>& nums) {\n        priority_queue<pair<long, Interval>, vector<pair<long, Interval>>, greater<pair<long, Interval>>> pq;\n        \n        int n = nums.size();\n        long maxEnd = 0;\n        for (int i = 0; i < n; i++) {\n            maxEnd = max(maxEnd, (long)nums[i].back());\n            pq.push({(long)nums[i].front(), {i, nums[i].front()}}); // store the first element of each list\n        }\n        \n        long ansLeft = pq.top().first;\n        long ansRight = pq.top().second.end;\n        int lastPos = 0;\n        \n        vector<int> res(2);\n        while (true) {\n            pair<long, Interval> cur = pq.top();\n            pq.pop();\n            \n            if (cur.second.end == cur.second.start) break; // all elements from a list have been processed\n            \n            long maxEnd1 = maxEnd;\n            for (int i = 0; i < n; i++) {\n                if (nums[i].size() > lastPos + 1) {\n                    nums[i].erase(nums[i].begin() + lastPos);\n                    pq.push({(long)nums[i][0], {i, 0}});\n                } else break;\n            }\n            \n            long newRight = pq.top().second.end;\n            if (newRight - ansLeft > maxEnd1 - ansRight) {\n                ansLeft = cur.second.start;\n                ansRight = newRight;\n            }\n        }\n        \n        res[0] = ansLeft;\n        res[1] = ansRight;\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<int>> nums1 = {{4,10},{7,12},{5,9},{4,15}};\n    vector<int> result1 = solution.smallestRange(nums1);\n    cout << \"Smallest Range for nums1: \";\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    vector<vector<int>> nums2 = {{1,5},{2,3}};\n    vector<int> result2 = solution.smallestRange(nums2);\n    cout << \"Smallest Range for nums2: \";\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    vector<vector<int>> nums3 = {{1,5},{2,3},{6,7}};\n    vector<int> result3 = solution.smallestRange(nums3);\n    cout << \"Smallest Range for nums3: \";\n    for (int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "634": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int derange(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<bool>> dp(n, vector<bool>(n));\n        \n        for (int i = 0; i < n; ++i)\n            dp[i][i] = true;\n        \n        for (int length = 2; length <= n; ++length) {\n            for (int i = 0; i + length - 1 < n; ++i) {\n                int j = i + length - 1;\n                if (nums[i] != nums[j])\n                    dp[i][j] = true;\n                else\n                    for (int k = i + 1; k <= j - 1; ++k)\n                        if (!dp[i][k-1] || !dp[k+1][j])\n                            dp[i][j] = false;\n            }\n        }\n        \n        int count = 0;\n        for (int i = 0; i < n; ++i) {\n            bool found = false;\n            for (int j = 0; j < n; ++j)\n                if (!dp[i][j])\n                    found = true;\n            if (!found)\n                count++;\n        }\n        \n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {1, 3, 4, 2};\n    cout << \"Test case 1: \" << solution.derange(nums1) << endl; \n\n    // Test case 2\n    vector<int> nums2 = {1, 1, 2, 2};\n    cout << \"Test case 2: \" << solution.derange(nums2) << endl;\n\n    // Test case 3\n    vector<int> nums3 = {1, 2, 3, 4};\n    cout << \"Test case 3: \" << solution.derange(nums3) << endl;\n    \n    return 0;\n}\n```",
  "635": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass LogSystem {\npublic:\n    void placeLog(int id, string station, string type) {\n        timeMap[station][type] = id;\n    }\n\n    list<string> queries(list<string>& logs) {\n        list<string> res;\n        for (auto log : logs) {\n            int id = -1;\n            string s = log.substr(0, log.find(\":\"));\n            string t = log.substr(log.find(\":\") + 1);\n            if (timeMap.find(s) != timeMap.end() && timeMap[s].find(t) != timeMap[s].end()) {\n                id = timeMap[s][t];\n            }\n            res.push_back(to_string(id));\n        }\n        return res;\n    }\n\nprivate:\n    unordered_map<string, unordered_map<string, int>> timeMap;\n};\n\nint main() {\n    LogSystem logSystem;\n\n    // Test Case 1\n    logSystem.placeLog(1, \"MTV\", \"video\");\n    logSystem.placeLog(2, \"TV\", \"video\");\n\n    list<string> logs1 = {\"MTV:video:2020:00\",\"TV:video:2018:00\"};\n    cout << \"Test Case 1: \";\n    for (string s : logSystem.queries(logs1)) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    logSystem.placeLog(3, \"MTV\", \"video\");\n\n    list<string> logs2 = {\"TV:video:2018:00\",\"MTV:video:2020:00\"};\n    cout << \"Test Case 2: \";\n    for (string s : logSystem.queries(logs2)) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    logSystem.placeLog(4, \"TV\", \"video\");\n\n    list<string> logs3 = {\"TV:video:2018:00\",\"MTV:video:2020:00\"};\n    cout << \"Test Case 3: \";\n    for (string s : logSystem.queries(logs3)) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n\n```",
  "636": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> exclusiveTime(int n, vector<string>& logs) {\n        vector<vector<int>> res;\n        vector<int> time(n);\n        int currentFunc = 0, lastFunc = 0, total = 0;\n        \n        for (const string& log : logs) {\n            int i = 0, j = 0;\n            while (log[i] != ':') i++;\n            i++;\n            while (j < i && log[j] != ' ') j++;\n            currentFunc = stoi(log.substr(j, i - j));\n            total = 0;\n            \n            while (i < log.size() && log[i] != ':') i++;\n            i++;\n            j = i;\n            while (j < log.size() && log[j] != ' ') j++;\n            total = stoi(log.substr(i, j - i));\n            \n            if (lastFunc == currentFunc) {\n                res.push_back({currentFunc, total});\n            } else {\n                time[currentFunc]++;\n                res.push_back({currentFunc, total});\n            }\n            lastFunc = currentFunc;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (time[i] > 0) {\n                res.push_back({i, time[i]});\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> logs = {\"0:01\", \"0:02\", \"1:21\", \"1:22\", \"1:23\", \"2:51\", \"2:52\"};\n    vector<vector<int>> result = solution.exclusiveTime(3, logs);\n    for (const auto& log : result) {\n        cout << \"(\" << log[0] << \",\" << log[1] << \") \";\n    }\n    cout << endl;\n    \n    logs = {\"0:01\", \"0:21\", \"1:11\"};\n    result = solution.exclusiveTime(2, logs);\n    for (const auto& log : result) {\n        cout << \"(\" << log[0] << \",\" << log[1] << \") \";\n    }\n    cout << endl;\n    \n    logs = {\"0:01\", \"0:21\", \"1:22\", \"1:23\", \"2:51\", \"2:52\"};\n    result = solution.exclusiveTime(3, logs);\n    for (const auto& log : result) {\n        cout << \"(\" << log[0] << \",\" << log[1] << \") \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
  "637": "```\n#include <iostream>\n#include <vector>\n#include \"TreeNode.h\"\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<double> averageOfLevels(TreeNode* root) {\n        vector<double> result;\n        if (!root) return result;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        \n        while (!q.empty()) {\n            int levelSize = q.size();\n            double sum = 0;\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                sum += node->val;\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            result.push_back((double)sum / levelSize);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    TreeNode* root = new TreeNode(3);\n    root->left = new TreeNode(9);\n    root->right = new TreeNode(20);\n    root->right->left = new TreeNode(15);\n    root->right->right = new TreeNode(7);\n    \n    vector<double> expectedResult = {2.0, 2.6666666666666665, 3.5};\n    assert(approxEqual(solution.averageOfLevels(root), expectedResult));\n    \n    // Test case 2:\n    root = nullptr;\n    expectedResult = {};\n    assert(approxEqual(solution.averageOfLevels(root), expectedResult));\n\n    // Test case 3:\n    root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(3);\n    \n    expectedResult = {1.0, 2.0};\n    assert(approxEqual(solution.averageOfLevels(root), expectedResult));\n\n    return 0;\n}\n\ndouble approxEqual(const vector<double>& v1, const vector<double>& v2) {\n    if (v1.size() != v2.size()) return false;\n    \n    for (int i = 0; i < v1.size(); i++) {\n        double diff = abs(v1[i] - v2[i]);\n        if (diff > 0.00001) return false;\n    }\n    \n    return true;\n}\n```",
  "638": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> shoppingOffers(vector<vector<int>>& price, vector<vector<int>> &budget) {\n        int n = price.size();\n        for (int i = 0; i < n; ++i) {\n            price[i][0] += budget[i];\n        }\n        vector<int> res(n);\n        for (int i = 0; i < n; ++i) {\n            res[i] = shoppingOffer(price, i, 0);\n        }\n        return res;\n    }\n\n    int shoppingOffer(vector<vector<int>>& price, int i, int amount) {\n        if (amount < price[i][0]) return 0;\n\n        int best = 0;\n        for (int j = 0; j <= min((int)price[i].size() - 1, amount / price[i][0]); ++j) {\n            int buy = shoppingOffer(price, i, amount - price[i][0] * (j + 1));\n            if (buy > best) best = buy;\n        }\n        return best + price[i][i+1];\n    }\n\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> price = {{10, 5}, {6, 8}};\n    vector<vector<int>> budget = {{20}, {50}};\n    vector<int> res = solution.shoppingOffers(price, budget);\n    for (auto i : res) {\n        cout << i << endl;\n    }\n\n    return 0;\n}\n```",
  "639": "```\n#include <iostream>\n#include <vector>\n\nint numDecodings(std::string s) {\n    if (s.empty()) return 0;\n    \n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        if (s[i - 1] != '0') dp[i] += dp[i - 1];\n        if (i >= 2 && (s[i - 2] == '1' || s[i - 2] == '2')) {\n            if (s.substr(i - 2, 2) <= \"26\") dp[i] += dp[i - 2];\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n    std::cout << numDecodings(\"12\") << std::endl; // Output: 2\n    std::cout << numDecodings(\"226\") << std::endl; // Output: 3\n    std::cout << numDecodings(\"0\") << std::endl; // Output: 0\n\n    return 0;\n}\n```",
  "640": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> equationsPossible(vector<string>& equations) {\n        int n = equations.size();\n        vector<pair<char, char>> edges(n);\n        for (int i = 0; i < n; ++i) {\n            int j = 0;\n            while (j < equations[i].size()) {\n                if (equations[i][j] == '=') break;\n                ++j;\n            }\n            int k = 0;\n            while (k < equations[i].size()) {\n                if (equations[i][j++] == '=') break;\n                edges[i].first = equations[i][j++];\n                edges[i].second = equations[i][j];\n            }\n        }\n\n        vector<bool> visited(n);\n        for (int i = 0; i < n; ++i) {\n            dfs(visited, edges, i);\n        }\n\n        vector<string> result;\n        for (int i = 0; i < n; ++i) {\n            int j = 0;\n            while (j < equations[i].size()) {\n                if (equations[i][j] == '=') break;\n                if (!isConnected(edges, i, equations[i].substr(1, j))) {\n                    result.push_back(equations[i]);\n                }\n                ++j;\n            }\n        }\n\n        return result;\n    }\n\n    bool isConnected(vector<pair<char, char>>& edges, int u, string& v) {\n        for (int i = 0; i < edges.size(); ++i) {\n            if (edges[i].first == v[0] && edges[i].second == v.substr(1)) return true;\n            if (edges[i].first == v.substr(1) && edges[i].second == v[0]) return true;\n        }\n        return false;\n    }\n\n    void dfs(vector<bool>& visited, vector<pair<char, char>>& edges, int u) {\n        visited[u] = true;\n        for (int i = 0; i < edges.size(); ++i) {\n            if (!visited[i] && edges[i].first == edges[u].second) dfs(visited, edges, i);\n            if (!visited[i] && edges[i].second == edges[u].first) dfs(visited, edges, i);\n        }\n    }\n\n};\n\nint main() {\n    Solution solution;\n    vector<string> equations1 = {\"science=1\",\"truth=science\"};\n    vector<string> result1 = solution.equationsPossible(equations1);\n    for (auto& equation : result1) {\n        cout << equation << endl;\n    }\n    cout << endl;\n\n    vector<string> equations2 = {\"forest!=dessert\",\"science=1\",\"truth=science\"};\n    vector<string> result2 = solution.equationsPossible(equations2);\n    for (auto& equation : result2) {\n        cout << equation << endl;\n    }\n    cout << endl;\n\n    vector<string> equations3 = {\"money=money\", \"note=money\", \"forest!=dessert\"};\n    vector<string> result3 = solution.equationsPossible(equations3);\n    for (auto& equation : result3) {\n        cout << equation << endl;\n    }\n    cout << endl;\n\n    return 0;\n}",
  "641": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass CircularDeque {\npublic:\n    void circularDeque(vector<int>& operations) {\n        int front = -1;\n        vector<int> deque;\n\n        for (int operation : operations) {\n            switch (operation % 4) {\n                case 1: // Insert at the end\n                    if (front == deque.size() - 1)\n                        deque.push_back(0);\n                    deque.push_back(operation % 2 ? operation : 0);\n                    break;\n                case 2: // Delete from front\n                    if (front == -1 || front == deque.size() - 1) {\n                        cout << \"Error: The circular deque is empty.\" << endl;\n                        return;\n                    }\n                    front++;\n                    break;\n                case 3: // Get from front\n                    if (front == -1)\n                        cout << \"Error: The circular deque is empty.\" << endl;\n                    else\n                        cout << deque[front] << endl;\n                    break;\n                default: // Insert at the front\n                    if (front != deque.size() - 1) {\n                        deque.insert(deque.begin(), operation % 2 ? operation : 0);\n                        front = 0;\n                    } else {\n                        deque.push_back(0);\n                        deque.insert(deque.begin(), operation % 2 ? operation : 0);\n                        front = 1;\n                    }\n            }\n        }\n    }\n};\n\nint main() {\n    CircularDeque circularDeque;\n\n    // Test case 1: Insert at the end, delete from front\n    vector<int> operations1 = {4};\n    circularDeque.circularDeque(operations1);\n\n    // Test case 2: Insert at the front, get from front, insert at the end\n    vector<int> operations2 = {2,6,2,5,4};\n    circularDeque.circularDeque(operations2);\n\n    // Test case 3: Delete from front, get from front, insert at the front\n    vector<int> operations3 = {3,2,3,2,2,2};\n    circularDeque.circularDeque(operations3);\n    return 0;\n}\n```",
  "642": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass TrieNode {\npublic:\n    char val;\n    bool isEndOfWord;\n    vector<TrieNode*> children;\n};\n\nclass AutocompleteSystem {\npublic:\n    void insert(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c - 'a']) {\n                node->children[c - 'a'] = new TrieNode();\n            }\n            node = node->children[c - 'a'];\n        }\n        node->isEndOfWord = true;\n    }\n\n    vector<string> autocomplete(string prefix) {\n        TrieNode* node = root;\n        for (char c : prefix) {\n            if (!node->children[c - 'a']) {\n                return {};\n            }\n            node = node->children[c - 'a'];\n        }\n        vector<string> result;\n        dfs(node, \"\", &result);\n        sort(result.begin(), result.end());\n        return result;\n    }\n\nprivate:\n    TrieNode* root;\n\n    void dfs(TrieNode* node, string prefix, vector<string>* result) {\n        if (node->isEndOfWord) {\n            (*result).push_back(prefix);\n        }\n        for (int i = 0; i < 26; ++i) {\n            if (node->children[i]) {\n                dfs(node->children[i], prefix + static_cast<char>(i + 'a'), result);\n            }\n        }\n    }\n};\n\nvoid printResult(vector<string> result) {\n    cout << \"[\";\n    for (int i = 0; i < result.size(); ++i) {\n        cout << \"\\\"\" << result[i] << \"\\\"\";\n        if (i != result.size() - 1) {\n            cout << \", \";\n        }\n    }\n    cout << \"]\" << endl;\n}\n\nint main() {\n    AutocompleteSystem system;\n\n    // Test case 1\n    vector<string> result1 = system.autocomplete(\"ca\");\n    printResult(result1);\n    \n    // Test case 2\n    system.insert(\"cat\");\n    system.insert(\"cats\");\n    vector<string> result2 = system.autocomplete(\"ca\");\n    printResult(result2);\n\n    // Test case 3\n    vector<string> result3 = system.autocomplete(\"c\");\n    printResult(result3);\n    \n    return 0;\n}\n```",
  "643": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    double findMaxAverage(vector<int>& nums, int k) {\n        long sum = 0;\n        for(int i=0; i<k; i++) {\n            sum += nums[i];\n        }\n        long maxSum = sum;\n        for(int i=k; i<nums.size(); i++) {\n            sum = sum - nums[i-k] + nums[i];\n            maxSum = max(maxSum, sum);\n        }\n        return (double)maxSum / k;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {1,12,-5,-6,50,3};\n    int k1 = 5;\n    cout << \"Test case 1: \" << solution.findMaxAverage(nums1, k1) << endl;\n\n    // Test case 2\n    vector<int> nums2 = [0,-4,-2,2,-2];\n    int k2 = 2;\n    cout << \"Test case 2: \" << solution.findMaxAverage(nums2, k2) << endl;\n\n    // Test case 3\n    vector<int> nums3 = [-1,10,-3,100,-5,51];\n    int k3 = 5;\n    cout << \"Test case 3: \" << solution.findMaxAverage(nums3, k3) << endl;\n\n    return 0;\n}\n```",
  "644": "```\n#include <iostream>\n#include <vector>\n\nint maxAverageRatio(std::vector<std::vector<int>>& edges) {\n    int n = edges.size();\n    std::priority_queue<std::pair<int, int>> pq;\n    \n    for (int i = 0; i < n; i++) {\n        pq.push({edges[i][1] - edges[i][0], i});\n    }\n    \n    int sum = 0;\n    int count = 0;\n    \n    while (!pq.empty()) {\n        std::pair<int, int> p = pq.top();\n        pq.pop();\n        \n        if (p.second > 0) {\n            sum += p.first;\n            count++;\n            if (count == n / 2) break;\n        }\n    }\n    \n    return (n * 10000 + sum) / count;\n}\n\nint main() {\n    std::vector<std::vector<int>> edges1 = {{5,10},{10,15}};\n    int result1 = maxAverageRatio(edges1);\n    std::cout << \"Test Case 1: \" << result1 << std::endl;\n\n    std::vector<std::vector<int>> edges2 = {{0,1},{1,3},{5,6},{6,4},{3,7},{7,8},{9,10},{10,12},{11,12}};\n    int result2 = maxAverageRatio(edges2);\n    std::cout << \"Test Case 2: \" << result2 << std::endl;\n\n    std::vector<std::vector<int>> edges3 = {{0,1},{1,2},{2,3},{4,5}};\n    int result3 = maxAverageRatio(edges3);\n    std::cout << \"Test Case 3: \" << result3 << std::endl;\n    \n    return 0;\n}",
  "645": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findErrorNums(vector<vector<int>>& nums) {\n        unordered_map<int, int> map;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (!map.count(nums[i])) {\n                map[nums[i]] = i;\n            } else {\n                return {nums[i], i + 1};\n            }\n        }\n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<vector<int>> testCases = {\n        {{1,4,2,3},{2,3}},\n        {{1,2},{4,1,3,2}],\n        {{1,2,3,4},{5,6}]\n    };\n    \n    for (int i = 0; i < testCases.size(); ++i) {\n        vector<int> result = solution.findErrorNums(testCases[i]);\n        cout << \"Test Case \" << i+1 << \": \";\n        if (result.empty()) {\n            cout << \"No duplicate found\" << endl;\n        } else {\n            cout << \"Duplicate: \" << result[0] << \", \" << \"Missing Number: \" << result[1] << endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "646": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint findLongestChain(std::vector<std::vector<int>>& pairs) {\n    if (pairs.empty()) return 0;\n\n    std::sort(pairs.begin(), pairs.end(), [](const auto& a, const auto& b) {\n        return a[1] < b[1];\n    });\n\n    int max_length = 0;\n    int prev_end = pairs[0][1];\n\n    for (const auto& pair : pairs) {\n        if (pair[0] > prev_end) {\n            max_length++;\n            prev_end = pair[1];\n        }\n    }\n\n    return max_length;\n}\n\nint main() {\n    std::vector<std::vector<int>> pairs1 = {{-10,-6},{1,3},{5,7},{4,8}};\n    std::cout << findLongestChain(pairs1) << std::endl; // Output: 3\n\n    std::vector<std::vector<int>> pairs2 = {{1,2},{2,3},{3,4},{4,5}};\n    std::cout << findLongestChain(pairs2) << std::endl; // Output: 4\n\n    std::vector<std::vector<int>> pairs3 = {{10,50},{11,60},{20,90}};\n    std::cout << findLongestChain(pairs3) << std::endl; // Output: 2\n}\n```",
  "647": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint countSubstrings(std::string s) {\n    int n = s.size();\n    int res = 0;\n    \n    for(int i = 0; i < n; i++) {\n        for(int j = i; j < n; j++) {\n            if(isPalindrome(s.substr(i, j - i + 1)))\n                res++;\n        }\n    }\n    return res;\n}\n\nbool isPalindrome(std::string s) {\n    int left = 0, right = s.size() - 1;\n\n    while(left < right) {\n        if(s[left] != s[right])\n            return false;\n        left++; right--;\n    }\n\n    return true;\n}\n\nint main() {\n    std::cout << countSubstrings(\"abc\") << std::endl; // Output: 3\n    std::cout << countSubstrings(\"aab\") << std::endl; // Output: 4\n    std::cout << countSubstrings(\"banana\") << std::endl; // Output: 6\n\n    return 0;\n}",
  "648": "```\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> replaceWords(vector<string>& words, string root) {\n        TrieNode* rootNode = new TrieNode();\n        for (const string& word : words) {\n            insert(rootNode, word);\n        }\n        \n        vector<string> res;\n        for (string& word : words) {\n            if (hasRoot(word, rootNode)) {\n                res.push_back(word);\n            } else {\n                res.push_back(replaceWord(rootNode, word));\n            }\n        }\n        \n        delete rootNode;\n        return res;\n    }\n\nprivate:\n    struct TrieNode {\n        bool isEndOfWord;\n        vector<TrieNode*> children = vector<TrieNode*>(26, nullptr);\n    };\n\n    void insert(TrieNode* node, const string& word) {\n        for (char c : word) {\n            if (!node->children[c - 'a']) {\n                node->children[c - 'a'] = new TrieNode();\n            }\n            node = node->children[c - 'a'];\n        }\n        node->isEndOfWord = true;\n    }\n\n    bool hasRoot(const string& word, TrieNode* root) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c - 'a']) return false;\n            node = node->children[c - 'a'];\n        }\n        return node->isEndOfWord;\n    }\n\n    string replaceWord(TrieNode* root, const string& word) {\n        TrieNode* node = root;\n        string res = \"\";\n        for (char c : word) {\n            if (!node->children[c - 'a']) break;\n            res += c;\n            node = node->children[c - 'a'];\n        }\n        return res + (node->isEndOfWord ? \"\" : word.substr(res.length()));\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> words1 = {\"kat\", \"hello\", \"walk\"};\n    string root1 = \"cat\";\n    for (const auto& result : solution.replaceWords(words1, root1)) {\n        cout << result << endl;\n    }\n\n    vector<string> words2 = {\"hit\", \"miss\", \"kite\", \"man\", \"a\", \"file\"};\n    string root2 = \"hit\";\n    for (const auto& result : solution.replaceWords(words2, root2)) {\n        cout << result << endl;\n    }\n\n    vector<string> words3 = {\"apple\", \"app\", \"banana\", \"app\"};\n    string root3 = \"app\";\n    for (const auto& result : solution.replaceWords(words3, root3)) {\n        cout << result << endl;\n    }\n}",
  "649": "```\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string predictPartyVictory(string initialSeating, int n) {\n        vector<char> red(26, 'R');\n        vector<char> blue(26, 'B');\n\n        queue<int> redQueue;\n        queue<int> blueQueue;\n\n        for (int i = 0; i < n; ++i) {\n            if (initialSeating[i] == 'R') {\n                red[initialSeating[i] - 'A'] = 'X';\n                redQueue.push(i);\n            }\n            else {\n                blue[initialSeating[i] - 'A'] = 'X';\n                blueQueue.push(i);\n            }\n        }\n\n        while (!redQueue.empty() && !blueQueue.empty()) {\n            int redIndex = redQueue.front();\n            int blueIndex = blueQueue.front();\n\n            if (red[initialSeating[redIndex] - 'A'] == 'R' &&\n                blue[initialSeating[blueIndex] - 'A'] == 'B') {\n                if (redIndex < blueIndex) {\n                    redQueue.pop();\n                    for (int i = 0; i < n; ++i) {\n                        if (!red[i] && initialSeating[i] != 'X') {\n                            redQueue.push(i);\n                            break;\n                        }\n                    }\n                } else {\n                    blueQueue.pop();\n                    for (int i = 0; i < n; ++i) {\n                        if (!blue[i] && initialSeating[i] != 'X') {\n                            blueQueue.push(i);\n                            break;\n                        }\n                    }\n                }\n            } else if (red[initialSeating[redIndex] - 'A'] == 'R' &&\n                       red[initialSeating[blueIndex] - 'A'] == 'B') {\n                redQueue.pop();\n                for (int i = 0; i < n; ++i) {\n                    if (!red[i] && initialSeating[i] != 'X') {\n                        redQueue.push(i);\n                        break;\n                    }\n                }\n            } else {\n                blueQueue.pop();\n                for (int i = 0; i < n; ++i) {\n                    if (!blue[i] && initialSeating[i] != 'X') {\n                        blueQueue.push(i);\n                        break;\n                    }\n                }\n            }\n        }\n\n        string result;\n\n        while (!redQueue.empty()) {\n            int index = redQueue.front();\n            redQueue.pop();\n            result += \"R\";\n            if (initialSeating[index] == 'R' && initialSeating[index] != 'X') {\n                result += '\\n';\n            }\n        }\n\n        while (!blueQueue.empty()) {\n            int index = blueQueue.front();\n            blueQueue.pop();\n            result += \"B\";\n            if (initialSeating[index] == 'B' && initialSeating[index] != 'X') {\n                result += '\\n';\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string initialSeating = \"RBR\";\n    int n = 3;\n    cout << solution.predictPartyVictory(initialSeating, n) << endl;\n\n    // Test case 2\n    initialSeating = \"RRRR\";\n    n = 4;\n    cout << solution.predictPartyVictory(initialSeating, n) << endl;\n\n    // Test case 3\n    initialSeating = \"BBRB\";\n    n = 4;\n    cout << solution.predictPartyVictory(initialSeating, n) << endl;\n\n    return 0;\n}\n```",
  "650": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSteps(string s) {\n        int res = 0;\n        unordered_map<char, int> m;\n        for (char c : s) {\n            m[c]++;\n        }\n        for (auto p : m) {\n            res += abs(p.second - 1);\n        }\n        return res / 2;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \";\n    string s = \"leet\";\n    cout << solution.minSteps(s) << endl; // Output: 3\n\n    cout << \"\\nTest case 2: \";\n    s = \"code\";\n    cout << solution.minSteps(s) << endl; // Output: 10\n    \n    cout << \"\\nTest case 3: \";\n    s = \"hixhhix\";\n    cout << solution.minSteps(s) << endl; // Output: 6\n\n    return 0;\n}\n```",
  "651": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxLength(vector<string>& dict) {\n        vector<vector<int>> dp(26, vector<int>(4));\n        for (int i = 0; i < 26; i++) {\n            dp[i][0] = 1;\n        }\n        for (string str : dict) {\n            int prev = -1;\n            for (char c : str) {\n                int cur = (c - 'a');\n                if (dp[cur][3] == 0) {\n                    dp[prev][1]++;\n                    dp[prev][2]++;\n                    dp[prev][3]--;\n                } else {\n                    dp[prev][1]++;\n                    dp[prev][3]--;\n                }\n                prev = cur;\n            }\n        }\n        int maxLen = 0;\n        for (int i = 0; i < 26; i++) {\n            if (dp[i][3] > 0) return -1;\n            maxLen = max(maxLen, dp[i][0]);\n        }\n        return maxLen;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> dict1 = {\"alex\", \"lorem\", \"ipsum\"};\n    cout << \"Test case 1: \" << solution.maxLength(dict1) << endl; // Output: 3\n\n    vector<string> dict2 = {\"apple\", \"alea\", \"xhaxa\"};\n    cout << \"Test case 2: \" << solution.maxLength(dict2) << endl; // Output: -1\n\n    vector<string> dict3 = {\"abc\", \"defg\", \"hijklmn\", \"opqrstuvwxyz\"};\n    cout << \"Test case 3: \" << solution.maxLength(dict3) << endl; // Output: 26\n\n    return 0;\n}\n```",
  "653": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool findTarget(TreeNode* root, int k) {\n        unordered_map<int, int> mp;\n        return dfs(root, k, mp);\n    }\n    \n    bool dfs(TreeNode* node, int target, unordered_map<int, int>& mp) {\n        if (!node) return false;\n        \n        if (mp.find(target - node->val) != mp.end()) return true;\n        if (dfs(node->left, target, mp)) return true;\n        if (dfs(node->right, target, mp)) return true;\n        \n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(6);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(4);\n    root1->right->left = new TreeNode(6);\n\n    cout << solution.findTarget(root1, 9) << endl; // true\n    cout << solution.findTarget(root1, 7) << endl; // false\n    cout << solution.findTarget(root1, 10) << endl; // true\n\n    return 0;\n}\n```",
  "652": "```\n#include <iostream>\n#include <unordered_map>\n#include <string>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\n        unordered_map<string, int> countMap;\n        vector<TreeNode*> duplicateList;\n\n        solve(root, countMap, duplicateList);\n\n        return duplicateList;\n    }\n\n    string treeToString(TreeNode* node) {\n        if (node == NULL)\n            return \"null\";\n        else\n            return to_string(node->val) + \",\" + treeToString(node->left) + \",\" + treeToString(node->right);\n    }\n\n    void solve(TreeNode* root, unordered_map<string, int>& countMap, vector<TreeNode*>& duplicateList) {\n        if (root == NULL)\n            return;\n\n        string treeStr = treeToString(root);\n\n        if (countMap[treeStr] > 1)\n            duplicateList.push_back(root);\n        else\n            countMap[treeStr]++;\n\n        solve(root->left, countMap, duplicateList);\n        solve(root->right, countMap, duplicateList);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->left->left = new TreeNode(4);\n    root1->left->right = new TreeNode(4);\n    root1->right->left = new TreeNode(5);\n\n    TreeNode* root2 = new TreeNode(2);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(3);\n    root2->right->right = new TreeNode(4);\n\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(2);\n\n    vector<TreeNode*> duplicateList1 = solution.findDuplicateSubtrees(root1);\n    for (TreeNode* node : duplicateList1)\n        cout << node->val << \" \";\n    cout << endl;\n\n    vector<TreeNode*> duplicateList2 = solution.findDuplicateSubtrees(root2);\n    for (TreeNode* node : duplicateList2)\n        cout << node->val << \" \";\n    cout << endl;\n\n    vector<TreeNode*> duplicateList3 = solution.findDuplicateSubtrees(root3);\n    for (TreeNode* node : duplicateList3)\n        cout << node->val << \" \";\n    cout << endl;\n}\n```",
  "654": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(std::vector<int>& nums) {\n        if (nums.empty()) return NULL;\n\n        int maxIndex = 0;\n        for (int i = 1; i < nums.size(); ++i) {\n            if (nums[i] > nums[maxIndex]) {\n                maxIndex = i;\n            }\n        }\n\n        TreeNode* root = new TreeNode(nums[maxIndex]);\n        std::vector<int> leftNums, rightNums;\n        for (int i = 0; i < maxIndex; ++i) {\n            leftNums.push_back(nums[i]);\n        }\n        for (int i = maxIndex + 1; i < nums.size(); ++i) {\n            rightNums.push_back(nums[i]);\n        }\n\n        root->left = constructMaximumBinaryTree(leftNums);\n        root->right = constructMaximumBinaryTree(rightNums);\n\n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> nums1 = {3, 2, null, 1};\n    TreeNode* root1 = solution.constructMaximumBinaryTree(nums1);\n    std::cout << \"Test case 1: \";\n    printTree(root1);\n\n    // Test case 2\n    std::vector<int> nums2 = {0, 1};\n    TreeNode* root2 = solution.constructMaximumBinaryTree(nums2);\n    std::cout << \"\\nTest case 2: \";\n    printTree(root2);\n\n    // Test case 3\n    std::vector<int> nums3 = {5, 8, 7, 9, null, 1};\n    TreeNode* root3 = solution.constructMaximumBinaryTree(nums3);\n    std::cout << \"\\nTest case 3: \";\n    printTree(root3);\n\n    return 0;\n}\n\nvoid printTree(TreeNode* root) {\n    if (root == NULL) {\n        return;\n    }\n\n    std::cout << \"(\" << root->val;\n    printTree(root->left);\n    std::cout << \")\";\n}\n```",
  "655": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nvoid printTree(TreeNode* root, string indent = \"\", bool isLeft = true) {\n    if (root == NULL)\n        return;\n\n    cout << indent + (isLeft ? \"\u2190\u2014\" : \"\") << root->val << endl;\n    printTree(root->left, indent + (isLeft ? \"     \" : \"      \"), true);\n    printTree(root->right, indent + (isLeft ? \"     \" : \"      \"), false);\n}\n\nint main() {\n    // Test case 1\n    TreeNode* tree1 = new TreeNode(1);\n    tree1->left = new TreeNode(2);\n    tree1->right = new TreeNode(3);\n    tree1->left->left = new TreeNode(4);\n    tree1->left->right = new TreeNode(5);\n    printTree(tree1);\n\n    // Test case 2\n    TreeNode* tree2 = new TreeNode(1);\n    tree2->left = new TreeNode(2);\n    tree2->right = new TreeNode(3);\n    printTree(tree2);\n\n    // Test case 3\n    TreeNode* tree3 = new TreeNode(1);\n    tree3->left = new TreeNode(2);\n    tree3->right = new TreeNode(3);\n    tree3->left->left = new TreeNode(4);\n    tree3->left->right = new TreeNode(5);\n    tree3->right->left = new TreeNode(6);\n    printTree(tree3);\n\n    return 0;\n}\n```",
  "657": "```\n#include <iostream>\n#include <string>\n\nbool judgeCircle(std::string moves) {\n    int x = 0;\n    int y = 0;\n\n    for (char move : moves) {\n        if (move == 'U') y++;\n        else if (move == 'D') y--;\n        else if (move == 'L') x++;\n        else if (move == 'R') x--;\n    }\n\n    return x == 0 && y == 0;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test case 1: \" << judgeCircle(\"GG\") << std::endl; // Expected output: true\n    std::cout << \"Test case 2: \" << judgeCircle(\"FRFFRFRRLLFLLR\") << std::endl; // Expected output: false\n    std::cout << \"Test case 3: \" << judgeCircle(\"\") << std::endl; // Expected output: true\n\n    return 0;\n}\n```",
  "656": "```\n#include <iostream>\n#include <vector>\n\nint coinPath(std::vector<int>& cost) {\n    int n = cost.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));\n\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = cost[i];\n    }\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            if (len % 2 == 1) {\n                dp[i][j] = std::min({dp[k][k + 1] + cost[i] for k in range(i, j)});\n            } else {\n                dp[i][j] = std::min({dp[k][k + 1] + cost[j] for k in range(i, j)});\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n\nint main() {\n    {\n        std::vector<int> cost = {4,2,1};\n        int res = coinPath(cost);\n        if (res != 7) {\n            std::cout << \"Test case failed: \" << cost.size() << std::endl;\n            return 1;\n        }\n    }\n\n    {\n        std::vector<int> cost = {3,5,1,2};\n        int res = coinPath(cost);\n        if (res != 12) {\n            std::cout << \"Test case failed: \" << cost.size() << std::endl;\n            return 1;\n        }\n    }\n\n    {\n        std::vector<int> cost = {1,3,4};\n        int res = coinPath(cost);\n        if (res != 7) {\n            std::cout << \"Test case failed: \" << cost.size() << std::endl;\n            return 1;\n        }\n    }\n\n    return 0;\n}\n```",
  "658": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Interval {\n    int x;\n    int y;\n};\n\nbool compare(Interval i1, Interval i2) {\n    return (i1.x * i1.x + i1.y * i1.y) > (i2.x * i2.x + i2.y * i2.y);\n}\n\nvector<int> findClosestElements(vector<vector<int>>& arr, int k, int x) {\n    vector<Interval> intervals;\n    for(int i = 0; i < arr.size(); i++) {\n        Interval interval;\n        interval.x = arr[i][0];\n        interval.y = arr[i][1];\n        intervals.push_back(interval);\n    }\n    sort(intervals.begin(), intervals.end(), compare);\n\n    int left = 0, right = intervals.size() - k;\n    while(left <= right) {\n        int mid = (left + right) / 2;\n        if(mid >= intervals.size() - k || x - intervals[mid].x > intervals[mid+k].x - x) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    vector<int> result;\n    for(int i = 0; i < k; i++) {\n        result.push_back(intervals[i].x);\n    }\n    return result;\n}\n\nint main() {\n    vector<vector<int>> arr1 {{1,3}, {5,7}, {9,11}};\n    int k1 = 2;\n    int x1 = 4;\n    cout << \"Test case 1: \";\n    for(int num : findClosestElements(arr1, k1, x1)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> arr2 {{0,1}, {5,6}, {10,11}};\n    int k2 = 3;\n    int x2 = 7;\n    cout << \"Test case 2: \";\n    for(int num : findClosestElements(arr2, k2, x2)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> arr3 {{1,4}, {5,6}};\n    int k3 = 2;\n    int x3 = 2;\n    cout << \"Test case 3: \";\n    for(int num : findClosestElements(arr3, k3, x3)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "659": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxConsecutive(int bottom, int top) {\n        if (bottom == top) return bottom;\n        vector<int> arr;\n        for (int i = bottom; i <= top; i++) {\n            arr.push_back(i);\n        }\n        sort(arr.begin(), arr.end());\n        int res = 0, prev = arr[0];\n        for (int i = 1; i < arr.size(); i++) {\n            if (arr[i] == prev + 1) {\n                prev++;\n            } else {\n                res = max(res, prev - (arr[i-1] - prev));\n                prev = arr[i];\n            }\n        }\n        return max(res, prev);\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test case 1: \" << solution.maxConsecutive(5, 23) << endl; // Output: 6\n    cout << \"Test case 2: \" << solution.maxConsecutive(0, 16) << endl; // Output: 7\n    cout << \"Test case 3: \" << solution.maxConsecutive(8, 10) << endl; // Output: 2\n    return 0;\n}\n```",
  "660": "```\n#include <iostream>\n#include <vector>\n\nvoid removeNine(std::vector<std::vector<int>>& grid) {\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 9) {\n                grid[i][j] = -1;\n            }\n        }\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> grid1 = {{8,3},{0,9}};\n    removeNine(grid1);\n    for (const auto& row : grid1) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> grid2 = {{8,9},{0,8}};\n    removeNine(grid2);\n    for (const auto& row : grid2) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> grid3 = {{1,2},{8,9}};\n    removeNine(grid3);\n    for (const auto& row : grid3) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "661": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<vector<int>> imageSmoother(std::vector<vector<int>>& M) {\n    int m = M.size(), n = M[0].size();\n    std::vector<vector<int>> res(m, vector<int>(n));\n    \n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j) {\n            int sum = 0;\n            int cnt = 0;\n            for (int x = -1; x <= 1; ++x)\n                for (int y = -1; y <= 1; ++y) {\n                    if (i + x >= 0 && i + x < m && j + y >= 0 && j + y < n) {\n                        sum += M[i + x][j + y];\n                        cnt++;\n                    }\n                }\n            res[i][j] = static_cast<int>(sum / cnt);\n        }\n    \n    return res;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::vector<int>> M1 = {{2,3,4},{5,6,7},{8,9,10}};\n    std::vector<std::vector<int>> expected1 = {{2,2,2},{3,3,3},{4,4,4}};\n    auto res1 = imageSmoother(M1);\n    \n    // Test Case 2\n    std::vector<std::vector<int>> M2 = {{0,1,2,0},{12,13,14,15},{16,17,18,19},{20,21,22,23}};\n    std::vector<std::vector<int>> expected2 = {{0,0.5,1},{2.5,3.5,4.5},{5.5,6.5,7.5},{8.5,9.5,10.5}};\n    auto res2 = imageSmoother(M2);\n    \n    // Test Case 3\n    std::vector<std::vector<int>> M3 = {{};\n                                       };\n    std::vector<std::vector<int>> expected3 = {{}};\n    auto res3 = imageSmoopher(M3);\n\n    return 0;\n}\n```",
  "662": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxWidth(TreeNode* root) {\n        if (!root)\n            return 0;\n        \n        int maxW = 0, currW = 0;\n        vector<TreeNode*> queue;\n        queue.push_back(root);\n        \n        while (!queue.empty()) {\n            currW = queue.size();\n            for (int i = 0; i < currW; i++) {\n                TreeNode* node = queue[i];\n                \n                if (node->left) \n                    queue.push_back(node->left);\n                if (node->right) \n                    queue.push_back(node->right);\n                \n                if (!i || !queue[i+1]) \n                    maxW = max(maxW, currW);\n            }\n            \n            for (int i = 0; i < currW; i++) {\n                queue.erase(queue.begin());\n            }\n        }\n        \n        return maxW;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(2);\n    root1->left->left = new TreeNode(5);\n    root1->left->right = new TreeNode(4);\n\n    cout << \"Test case 1: \" << solution.maxWidth(root1) << endl;\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(5);\n    root2->left->left = new TreeNode(6);\n    root2->left->right = new TreeNode(2);\n\n    cout << \"Test case 2: \" << solution.maxWidth(root2) << endl;\n\n    TreeNode* root3 = new TreeNode(1);\n    root3->right = new TreeNode(3);\n    root3->right->right = new TreeNode(4);\n    root3->right->right->left = new TreeNode(5);\n\n    cout << \"Test case 3: \" << solution.maxWidth(root3) << endl;\n\n    return 0;\n}\n```",
  "663": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    bool btreeGameWinning(int n, std::vector<std::vector<int>>& views) {\n        int left = 0, right = n - 1;\n        for (int i = 0; i < views.size(); ++i) {\n            if (views[i][0] > right) right = views[i][0];\n            if (views[i][1] > left) left = views[i][1];\n        }\n        \n        int height = 1, width = n - 1;\n        while ((left <= right / 2) || (right >= left * 2)) {\n            left /= 2;\n            right /= 2;\n            ++height;\n            if (width > right - left + 1) --width, right = left;\n        }\n        \n        int target = (n - 1) / 2;\n        return (target <= left) && (right <= target);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> views1 = {{2,0},{1,3}};\n    bool result1 = solution.btreeGameWinning(7, views1);\n    if (!result1) {\n        std::cout << \"Test case 1: Failed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Passed\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::vector<int>> views2 = {{0,4},{3,2}};\n    bool result2 = solution.btreeGameWinning(5, views2);\n    if (!result2) {\n        std::cout << \"Test case 2: Failed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Passed\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::vector<int>> views3 = {{0,1},{3,4}};\n    bool result3 = solution.btreeGameWinning(5, views3);\n    if (!result3) {\n        std::cout << \"Test case 3: Failed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Passed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "664": "```\n#include <iostream>\n#include <vector>\n\nint strangePrinter(std::string s) {\n    int n = s.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, 0));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            if (s[i] == s[j]) continue;\n            int minLen = INT_MAX;\n            for (int k = j; k <= i; ++k) {\n                if (s[k] != s[j]) break;\n                minLen = std::min(minLen, dp[j][k - 1]);\n            }\n            dp[j][i] = minLen + 2;\n        }\n    }\n    return *std::max_element(dp[0].begin(), dp[0].end());\n}\n\nint main() {\n    std::cout << strangePrinter(\"aaabbb\") << std::endl; // Output: 6\n    std::cout << strangePrinter(\"abc\") << std::endl; // Output: 1\n    std::cout << strangePrinter(\"aabbaa\") << std::endl; // Output: 5\n    return 0;\n}\n```",
  "665": "```\n#include <iostream>\n#include <vector>\n\nbool checkPossibility(std::vector<int>& nums) {\n    int count = 0;\n    for (int i = 1; i < nums.size(); ++i) {\n        if (nums[i] <= nums[i - 1]) continue;\n        if (count == 0 || nums[i - 1] > nums[i - 2] + 1) return false;\n        count++;\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> nums1 = {4, 2, 3};\n    std::cout << (checkPossibility(nums1) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> nums2 = {4, 2, 3, 5};\n    std::cout << (checkPossibility(nums2) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> nums3 = {1, 3, 3};\n    std::cout << (checkPossibility(nums3) ? \"True\" : \"False\") << std::endl;\n}\n```",
  "666": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int pathSum(vector<vector<int>>& nums) {\n        int rows = nums.size();\n        if (rows == 0)\n            return 0;\n        \n        int cols = nums[0].size();\n        vector<vector<bool>> visited(rows, vector<bool>(cols));\n        \n        int res = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (nums[i][j] == 0) {\n                    visited[i][j] = true;\n                }\n                else if (i > 0 && nums[i-1][j] == 0) {\n                    visited[i][j] = true;\n                }\n                else if (j > 0 && nums[i][j-1] == 0) {\n                    visited[i][j] = true;\n                }\n            }\n        }\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (nums[i][j] == 1 && !visited[i][j]) {\n                    res++;\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<int>> test1 = {{0,1},{1,0}};\n    cout << \"Test case 1: \" << solution.pathSum(test1) << endl; // Expected output: 2\n\n    vector<vector<int>> test2 = {{0,0,0},{0,1,0},{0,1,0}};\n    cout << \"Test case 2: \" << solution.pathSum(test2) << endl; // Expected output: 3\n\n    vector<vector<int>> test3 = {{1,0,1},{0,0,0},{1,1,0}};\n    cout << \"Test case 3: \" << solution.pathSum(test3) << endl; // Expected output: 4\n    \n    return 0;\n}\n```",
  "667": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> arrayBeautiful(const int n) {\n        std::vector<int> result;\n        for (int i = 1; i <= n; ++i) {\n            if ((n & i) == 0) continue;\n            while ((n & i) != 0) {\n                n ^= i;\n            }\n            result.push_back(i);\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test case 1: \" << std::endl;\n    int n = 20;\n    std::vector<int> expected1 = {4, 6, 8, 10, 12, 15, 18, 19};\n    auto result1 = solution.arrayBeautiful(n);\n    for (int i = 0; i < result1.size(); ++i) {\n        if (result1[i] != expected1[i]) {\n            std::cout << \"Test failed: expected \" << expected1[i] << \", got \" << result1[i] << std::endl;\n            return 1;\n        }\n    }\n    std::cout << \"Test case 1 passed.\" << std::endl;\n\n    std::cout << \"Test case 2: \" << std::endl;\n    n = 3;\n    expected1 = {2, 3};\n    result1.clear();\n    result1 = solution.arrayBeautiful(n);\n    for (int i = 0; i < result1.size(); ++i) {\n        if (result1[i] != expected1[i]) {\n            std::cout << \"Test failed: expected \" << expected1[i] << \", got \" << result1[i] << std::endl;\n            return 1;\n        }\n    }\n    std::cout << \"Test case 2 passed.\" << std::endl;\n\n    std::cout << \"Test case 3: \" << std::endl;\n    n = 10;\n    expected1.clear();\n    for (int i = 0; i < n; ++i) {\n        if ((n & (1 << i)) == 0) continue;\n        expected1.push_back(i + 1);\n    }\n    result1.clear();\n    result1 = solution.arrayBeautiful(n);\n    for (int i = 0; i < result1.size(); ++i) {\n        if (result1[i] != expected1[i]) {\n            std::cout << \"Test failed: expected \" << expected1[i] << \", got \" << result1[i] << std::endl;\n            return 1;\n        }\n    }\n    std::cout << \"Test case 3 passed.\" << std::endl;\n\n    return 0;\n}\n```",
  "668": "```\n#include <iostream>\n#include <vector>\n\nint findKthNumber(int m, int n, int k) {\n    long long num = 1;\n    k--;\n    while (k > 0) {\n        long long gapsInThisRow = n - (num % n);\n        if (k <= gapsInThisRow) {\n            num += k;\n            k = 0;\n        } else {\n            k -= gapsInThisRow;\n            num += n;\n        }\n    }\n    return num;\n}\n\nint main() {\n    std::cout << findKthNumber(3, 3, 5) << std::endl; // Output: 11\n    std::cout << findKthNumber(2, 3, 4) << std::endl; // Output: 6\n    std::cout << findKthNumber(4, 3, 18) << std::endl; // Output: 16\n\n    return 0;\n}\n```",
  "669": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int L, int R) {\n        if (!root) return NULL;\n\n        // prune the left side\n        if (root->val < L) {\n            if (root->left) {\n                root->left = trimBST(root->left, L, R);\n            } else if (root->right) {\n                root = root->right;\n            } else {\n                return NULL;\n            }\n        }\n\n        // prune the right side\n        if (root->val > R) {\n            if (root->right) {\n                root->right = trimBST(root->right, L, R);\n            } else if (root->left) {\n                root = root->left;\n            } else {\n                return NULL;\n            }\n        }\n\n        // prune the middle\n        if (L <= root->val && root->val <= R) {\n            root->left = trimBST(root->left, L, R);\n            root->right = trimBST(root->right, L, R);\n        }\n\n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(0);\n    root1->right = new TreeNode(2);\n    cout << \"Before trimming: \";\n    printTree(root1);\n    root1 = solution.trimBST(root1, 1, 1);\n    cout << \"\\nAfter trimming: \";\n    printTree(root1);\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(0);\n    root2->right = new TreeNode(4);\n    cout << \"\\nBefore trimming: \";\n    printTree(root2);\n    root2 = solution.trimBST(root2, 1, 3);\n    cout << \"\\nAfter trimming: \";\n    printTree(root2);\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(-3);\n    root3->right = new TreeNode(2);\n    cout << \"\\nBefore trimming: \";\n    printTree(root3);\n    root3 = solution.trimBST(root3, -5, 5);\n    cout << \"\\nAfter trimming: \";\n    printTree(root3);\n\n    return 0;\n}\n\nvoid printTree(TreeNode* root) {\n    if (!root) return;\n\n    cout << root->val << \" \";\n    printTree(root->left);\n    printTree(root->right);\n}\n```",
  "670": "```\n#include <iostream>\n#include <vector>\n\nint maximumSwap(int n) {\n    std::vector<int> v(n);\n    for (int i = 0; i < n; ++i)\n        v[i] = i;\n\n    int maxSwaps = 0;\n    int i = 0, j = 0;\n\n    while (j < n - 1 && i <= j) {\n        if (v[i] != i) {\n            int pos = v[i];\n            std::swap(v[pos], v[i]);\n            ++maxSwaps;\n        }\n        else\n            ++i;\n        ++j;\n    }\n\n    return maxSwaps;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << maximumSwap(20) << std::endl;  // Expected output: 9\n    std::cout << \"Test case 2: \" << maximumSwap(15) << std::endl;  // Expected output: 4\n    std::cout << \"Test case 3: \" << maximumSwap(1000) << std::endl;  // Expected output: 1998\n\n    return 0;\n}\n```",
  "672": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int flipLights(int n) {\n        if (n == 1)\n            return 1;\n        else if (n == 2)\n            return 3;\n        else if (n == 3)\n            return 6;\n        else\n            return 8;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test Case 1: n = 1, Expected: 1, Got: \" << solution.flipLights(1) << std::endl;\n    std::cout << \"Test Case 2: n = 2, Expected: 3, Got: \" << solution.flipLights(2) << std::endl;\n    std::cout << \"Test Case 3: n = 3, Expected: 6, Got: \" << solution.flipLights(3) << std::endl;\n\n    return 0;\n}\n```",
  "671": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int findSecondMinimumValue(TreeNode* root) {\n        if (root == NULL || root->val == INT_MAX) return -1;\n        int min = root->val, secondMin = INT_MAX;\n        helper(root, min, &secondMin);\n        return secondMin;\n    }\n    \n    void helper(TreeNode* node, int& min, int* secondMin) {\n        if (node == NULL || node->val >= *secondMin) return;\n        if (node->val < min) swap(min, node->val);\n        if (node->left != NULL && node->left->val > min) helper(node->left, min, secondMin);\n        if (node->right != NULL && node->right->val > min) helper(node->right, min, secondMin);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    TreeNode* root1 = new TreeNode(2);\n    root1->left = new TreeNode(2);\n    int result1 = solution.findSecondMinimumValue(root1);\n    cout << \"Test case 1: \" << result1 << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(INT_MAX);\n    root2->right = new TreeNode(5);\n    int result2 = solution.findSecondMinimumValue(root2);\n    cout << \"Test case 2: \" << result2 << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(4);\n    root3->right = new TreeNode(5);\n    int result3 = solution.findSecondMinimumValue(root3);\n    cout << \"Test case 3: \" << result3 << endl;\n\n    return 0;\n}\n```",
  "673": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findLengthOfLIS(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        \n        vector<int> dp(nums.size(), 1);\n        int max_length = 1, prev_end = 0;\n        \n        for (int i = 1; i < nums.size(); ++i) {\n            int idx = upper_bound(dp.begin(), dp.end(), nums[i]) - dp.begin();\n            if (idx == 0) {\n                dp[0] = nums[i];\n                max_length = 1;\n                prev_end = 0;\n            } else {\n                dp[idx] = nums[i];\n                if (idx > prev_end) {\n                    ++max_length;\n                    prev_end = idx;\n                }\n            }\n        }\n        \n        return max_length;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> test1 = {1,3,5,4,7};\n    cout << \"Test case 1: \" << solution.findLengthOfLIS(test1) << endl; \n\n    // Test case 2\n    vector<int> test2 = {2,2,2,2,2};\n    cout << \"Test case 2: \" << solution.findLengthOfLIS(test2) << endl;\n\n    // Test case 3\n    vector<int> test3 = {};\n    cout << \"Test case 3: \" << solution.findLengthOfLIS(test3) << endl;\n\n    return 0;\n}\n```",
  "674": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findLengthOfLIS(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        \n        vector<int> dp(nums.size(), 1);\n        int maxLen = 1;\n        \n        for (int i = 1; i < nums.size(); ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLen = max(maxLen, dp[i]);\n        }\n        \n        return maxLen;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1\n    vector<int> test1 = {1,3,6,7,9};\n    cout << \"Test case 1: \" << s.findLengthOfLIS(test1) << endl;  // Output: 4\n    \n    // Test case 2\n    vector<int> test2 = {1,2,3,4,5};\n    cout << \"Test case 2: \" << s.findLengthOfLIS(test2) << endl;  // Output: 5\n    \n    // Test case 3\n    vector<int> test3 = [0];\n    cout << \"Test case 3: \" << s.findLengthOfLIS(test3) << endl;  // Output: 1\n\n    return 0;\n}\n```",
  "675": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int cutOffTree(vector<vector<int>>& forest) {\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>> pq;\n        for (int i = 0; i < forest.size(); i++) {\n            for (int j = 0; j < forest[0].size(); j++) {\n                if (forest[i][j] > 0) {\n                    pq.push({-1 * forest[i][j], {i, j}});\n                }\n            }\n        }\n\n        while (!pq.empty()) {\n            int dist = -1 * pq.top().first;\n            pair<int, int> tree = pq.top().second;\n            pq.pop();\n\n            if (forest[tree.first][tree.second] > 0) {\n                return dist;\n            } else {\n                forest[tree.first][tree.second] = 0;\n            }\n        }\n\n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> forest1 = {{1,2},{3,0}};\n    cout << \"Test case 1: \" << solution.cutOffTree(forest1) << endl; \n\n    // Test case 2\n    vector<vector<int>> forest2 = {{7,8},{9,10}};\n    cout << \"Test case 2: \" << solution.cutOffTree(forest2) << endl; \n\n    // Test case 3\n    vector<vector<int>> forest3 = {{5,1},{4,6}};\n    cout << \"Test case 3: \" << solution.cutOffTree(forest3) << endl; \n\n    return 0;\n}",
  "676": "```\n#include <iostream>\n#include <vector>\n\nclass MagicDictionary {\npublic:\n    void buildDict(std::vector<std::string>& wordList) {\n\n    }\n\n    bool search(std::string queryWord) {\n        return false;\n    }\n};\n\nint main() {\n    MagicDictionary md;\n\n    std::vector<std::string> wordList = {\"Hello\", \"Alaska\", \"Steve\"};\n    md.buildDict(wordList);\n\n    std::cout << std::boolalpha << md.search(\"Hello\") << std::endl; // false\n    std::cout << std::boolalpha << md.search(\"Alaska\") << std::endl; // false\n    std::cout << std::boolalpha << md.search(\"Steve\") << std::endl; // true\n\n    return 0;\n}\n```",
  "678": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool checkValidString(string s) {\n        int left = 0;\n        int right = 0;\n        for (char c : s) {\n            if (c == '(') {\n                left++;\n                right++;\n            } else if (c == ')') {\n                if (left > 0) {\n                    left--;\n                } else if (right > 0) {\n                    right--;\n                } else {\n                    return false;\n                }\n            } else {\n                if (left > 0) {\n                    left--;\n                } else if (right > 0) {\n                    right--;\n                }\n            }\n        }\n        return left == 0;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.checkValidString(\"(*)\") << endl; // Expected: true\n    cout << solution.checkValidString(\"*()*)\") << endl; // Expected: false\n    cout << solution.checkValid_string(\"(())(())\") << endl; // Expected: true\n\n    return 0;\n}\n```",
  "677": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass TrieNode {\npublic:\n    int value;\n    map<char, TrieNode*> children;\n};\n\nclass MapSum {\nprivate:\n    TrieNode* root;\n\npublic:\n    MapSum() : root(new TrieNode()) {}\n\n    void update(const string& word, int sum) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children.count(c)) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        node->value = sum;\n    }\n\n    int sum(const string& prefix) {\n        TrieNode* node = root;\n        for (char c : prefix) {\n            if (!node->children.count(c)) {\n                return 0;\n            }\n            node = node->children[c];\n        }\n        return dfs(node, prefix);\n    }\n\nprivate:\n    int dfs(TrieNode* node, const string& prefix) {\n        int sum = node->value;\n        for (auto& child : node->children) {\n            if (child.second->value > 0) {\n                sum += child.second->value;\n            }\n        }\n        return sum;\n    }\n};\n\nint main() {\n    MapSum mapSum;\n\n    // Test case 1\n    mapSum.update(\"apple\", 3);\n    mapSum.update(\"app\", 2);\n    cout << \"Sum of 'ap' is: \" << mapSum.sum(\"ap\") << endl;  // Output: 5\n\n    // Test case 2\n    mapSum.update(\"k1\", 30);\n    mapSum.update(\"k2\", 20);\n    cout << \"Sum of 'k1' is: \" << mapSum.sum(\"k1\") << endl;  // Output: 30\n    cout << \"Sum of 'k2' is: \" << mapSum.sum(\"k2\") << endl;  // Output: 20\n\n    // Test case 3\n    mapSum.update(\"word\", 5);\n    mapSum.update(\"apple\", 4);\n    mapSum.update(\"app\", 3);\n    cout << \"Sum of 'ap' is: \" << mapSum.sum(\"ap\") << endl;  // Output: 8\n\n    return 0;\n}\n```",
  "680": "```\n#include <iostream>\n#include <string>\n\nbool validPalindrome(std::string s) {\n    int left = 0, right = s.size() - 1;\n    \n    while (left < right) {\n        if (s[left] != s[right]) {\n            return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n\nbool isPalindrome(std::string s, int start, int end) {\n    while (start < end) {\n        if (s[start] != s[end]) {\n            return false;\n        }\n        start++;\n        end--;\n    }\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test case 1: \" << validPalindrome(\"abca\") << std::endl; // Expected output: false\n    std::cout << \"Test case 2: \" << validPalindrome(\"aba\") << std::endl; // Expected output: true\n    std::cout << \"Test case 3: \" << validPalindrome(\"abcba\") << std::endl; // Expected output: true\n    return 0;\n}\n```",
  "679": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool judgePoint32(int arr42[]) {\n    int val1 = arr42[0];\n    int val2 = (arr42[1] << 5) - arr42[2];\n    int val3 = (arr42[1] << 2) + arr42[3];\n    return val1 == val2 && val2 == val3;\n}\n\nbool judgePoint32Helper(int arr[], int n, vector<int>& res, int sum) {\n    if (n < 4) {\n        if (judgePoint32(arr)) {\n            res.push_back(sum);\n            return true;\n        }\n        return false;\n    }\n\n    for (int i = 0; i <= n - 3; i++) {\n        for (int j = i + 1; j <= n - 2; j++) {\n            for (int k = j + 1; k < n; k++) {\n                if (i + j + k == sum) {\n                    vector<int> newRes = res;\n                    newRes.push_back(i);\n                    newRes.push_back(j);\n                    newRes.push_back(k);\n                    res = newRes;\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n\nvector<vector<int>> findClosestSum(vector<int>& nums, int target) {\n    vector<int> res;\n    for (int i = 0; i <= nums.size() - 4; i++) {\n        if (judgePoint32Helper(&nums[i], nums.size() - i, res, target)) {\n            return {{target}};\n        }\n    }\n\n    int minDiff = INT_MAX;\n    vector<vector<int>> result;\n    for (int i = 0; i <= nums.size() - 4; i++) {\n        if (judgePoint32Helper(&nums[i], nums.size() - i, res, target)) {\n            int diff = abs(target - getSum(res[0]));\n            if (diff < minDiff) {\n                minDiff = diff;\n                result = {{target}};\n            } else if (diff == minDiff) {\n                result.push_back({target});\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    vector<int> nums1 = {8, 10, -5};\n    vector<vector<int>> res1 = findClosestSum(nums1, 2);\n    for (auto r : res1) {\n        cout << getSum(r) << endl;\n    }\n\n    vector<int> nums2 = {56, 65, 47, 23, 24};\n    vector<vector<int>> res2 = findClosestSum(nums2, 107);\n    for (auto r : res2) {\n        cout << getSum(r) << endl;\n    }\n\n    vector<int> nums3 = {4, 6, 29, 34, 40, -21};\n    vector<vector<int>> res3 = findClosestSum(nums3, 99);\n    for (auto r : res3) {\n        cout << getSum(r) << endl;\n    }\n\n    return 0;\n}\n\nint getSum(vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) {\n        sum += num;\n    }\n    return sum;\n}\n```",
  "681": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string nextClosestTime(string s) {\n        int hour = s[0] - '0' + (s[1] - '0') * 10;\n        int minute = s[3] - '0' + (s[4] - '0') * 10;\n\n        for (int i = 0; i <= 23; ++i) {\n            for (int j = 0; j <= 59; ++j) {\n                if ((i < hour || i == hour && j < minute) && isTimeValid(i, j)) {\n                    return to_string(i).substr(0, 2) + \":\" + to_string(j).substr(0, 2);\n                }\n            }\n        }\n\n        return s;\n    }\n\nprivate:\n    bool isTimeValid(int h, int m) {\n        if (h < 0 || h > 23) return false;\n        if (m < 0 || m > 59) return false;\n\n        for (int i = 0; i < 6; ++i) {\n            if ((h / 10 == i % 2 && h % 10 != 5) ||\n                (h / 10 != i % 2 && h % 10 != 3)) continue;\n            if ((m / 10 == i % 2 && m % 10 != 5) ||\n                (m / 10 != i % 2 && m % 10 != 3)) continue;\n\n            return false;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.nextClosestTime(\"19:34\") << endl; // \"02:56\"\n    cout << solution.nextClosestTime(\"23:59\") << endl; // \"22:22\"\n    cout << solution.nextClosestTime(\"00:00\") << endl; // \"00:01\"\n\n    return 0;\n}\n```",
  "682": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int calculateScore(std::vector<int>& strikes, std::vector<int>& balls) {\n        int score = 0;\n        for (int i = 0; i < strikes.size(); ++i) {\n            if (strikes[i] > 0 && balls[i] > 0) {\n                score += 1 + (strikes[i] * 2);\n            } else if (strikes[i] > 0) {\n                score += strikes[i];\n            }\n        }\n        return score;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<int> strikes1 = {1, 2};\n    std::vector<int> balls1 = {3};\n    std::cout << \"Test case 1: \" << solution.calculateScore(strikes1, balls1) << std::endl; // Output: 5\n\n    std::vector<int> strikes2 = {2, 0, 1};\n    std::vector<int> balls2 = {1, 2};\n    std::cout << \"Test case 2: \" << solution.calculateScore(strikes2, balls2) << std::endl; // Output: 3\n\n    std::vector<int> strikes3 = {4, 0};\n    std::vector<int> balls3 = {};\n    std::cout << \"Test case 3: \" << solution.calculateScore(strikes3, balls3) << std::endl; // Output: 8\n\n    return 0;\n}\n```",
  "683": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> gardenNoAdj(int n, vector<vector<int>>& paths) {\n        vector<vector<char>> gardens(n, vector<char>(n));\n        \n        for (int i = 0; i < paths.size(); i++) {\n            int a = paths[i][0], b = paths[i][1];\n            gardens[a][b] = gardens[b][a] = ' ';\n        }\n        \n        for (int i = 0; i < n; i++) {\n            bool seen[5] = {false};\n            for (int j = 0; j < n; j++) {\n                if (garden[i][j] != ' ') {\n                    int type = garden[i][j];\n                    seen[type] = true;\n                }\n            }\n            for (int i = 1; i <= 4; i++) {\n                if (!seen[i]) {\n                    gardens[i-1].push_back(i);\n                    break;\n                }\n            }\n        }\n        \n        vector<int> ans(n, -1);\n        for (int i = 0; i < n; i++) {\n            int last = -1;\n            for (char c : garden[i]) {\n                if (c != ' ') {\n                    if (ans[c-1] == -1) {\n                        ans[c-1] = i+1;\n                        last = i+1;\n                    } else if (last + 1 != ans[c-1]) {\n                        return vector<int>();\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    int n1 = 3;\n    vector<vector<int>> paths1{{1,2},{2,3}};\n    vector<int> expected1{1,4};\n    if (solution.gardenNoAdj(n1, paths1) != expected1) {\n        cout << \"Test case 1 failed!\" << endl;\n    } else {\n        cout << \"Test case 1 passed.\" << endl;\n    }\n    \n    int n2 = 4;\n    vector<vector<int>> paths2{{1,2},{2,3},{3,4}};\n    vector<int> expected2{1,2,4};\n    if (solution.gardenNoAdj(n2, paths2) != expected2) {\n        cout << \"Test case 2 failed!\" << endl;\n    } else {\n        cout << \"Test case 2 passed.\" << endl;\n    }\n    \n    int n3 = 5;\n    vector<vector<int>> paths3{{1,4},{4,5}};\n    vector<int> expected3{1};\n    if (solution.gardenNoAdj(n3, paths3) != expected3) {\n        cout << \"Test case 3 failed!\" << endl;\n    } else {\n        cout << \"Test case 3 passed.\" << endl;\n    }\n    \n    return 0;\n}\n```",
  "684": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        int n = edges.size();\n        vector<int> parent(n + 1);\n        \n        for (int i = 0; i <= n; ++i) {\n            parent[i] = i;\n        }\n        \n        for (vector<int>& edge : edges) {\n            int u = edge[0], v = edge[1];\n            \n            if (find(parent, u) == find(parent, v)) {\n                return edge;\n            }\n            \n            unionSet(parent, u, v);\n        }\n        \n        return {};\n    }\n\n    int find(vector<int>& parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSet(vector<int>& parent, int x, int y) {\n        parent[find(parent, x)] = find(parent, y);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> edges1 = {{1,2},{1,3},{2,3}};\n    vector<int> result1 = solution.findRedundantConnection(edges1);\n    cout << \"Test case 1: \";\n    for (int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    \n    // Test case 2\n    vector<vector<int>> edges2 = {{1,2},{2,3},{3,4},{1,3},{1,4}};\n    vector<int> result2 = solution.findRedundantConnection(edges2);\n    cout << \"Test case 2: \";\n    for (int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    \n    // Test case 3\n    vector<vector<int>> edges3 = {{1,2},{2,3},{3,4},{4,5}};\n    vector<int> result3 = solution.findRedundantConnection(edges3);\n    cout << \"Test case 3: \";\n    for (int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "686": "```\n#include <iostream>\n#include <string>\n\nint strStr(std::string haystack, std::string needle) {\n    if (needle.empty()) return 0;\n    int n = haystack.length(), m = needle.length();\n    for (int i = 0; i <= n - m; i++) {\n        int j = 0;\n        while (j < m && haystack[i + j] == needle[j]) j++;\n        if (j == m) return i;\n    }\n    return -1;\n}\n\nint main() {\n    std::cout << \"Test case 1: \";\n    std::string haystack1 = \"abcabcabc\";\n    std::string needle1 = \"abc\";\n    int result1 = strStr(haystack1, needle1);\n    if (result1 == 0) std::cout << \"Passed\\n\";\n    else std::cout << \"Failed. Expected: 0, got: \" << result1 << \"\\n\";\n\n    std::cout << \"Test case 2: \";\n    std::string haystack2 = \"abcaaaaa\";\n    std::string needle2 = \"abc\";\n    int result2 = strStr(haystack2, needle2);\n    if (result2 == 0) std::cout << \"Passed\\n\";\n    else std::cout << \"Failed. Expected: 0, got: \" << result2 << \"\\n\";\n\n    std::cout << \"Test case 3: \";\n    std::string haystack3 = \"a\";\n    std::string needle3 = \"\";\n    int result3 = strStr(haystack3, needle3);\n    if (result3 == 0) std::cout << \"Passed\\n\";\n    else std::cout << \"Failed. Expected: 0, got: \" << result3 << \"\\n\";\n\n    return 0;\n}\n```",
  "685": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        if (edges.empty()) return {};\n\n        int n = edges.size();\n        vector<int> parent(n+1, -1), sz(n+1, 0);\n        for (int i = 0; i < n; i++) {\n            int x = edges[i][0], y = edges[i][1];\n            if (parent[x] == -1) parent[x] = x;\n            if (parent[y] == -1) parent[y] = y;\n            if (find(parent, x) != find(parent, y)) {\n                unionSet(parent, sz, x, y);\n            } else {\n                return {x, y};\n            }\n        }\n        return {};\n\n        int find(vector<int>& p, int x) {\n            if (p[x] != x) p[x] = find(p, p[x]);\n            return p[x];\n        }\n\n        void unionSet(vector<int>& p, vector<int>& sz, int x, int y) {\n            x = find(p, x);\n            y = find(p, y);\n            if (x == y) return;\n            if (sz[x] > sz[y]) swap(x, y);\n            p[x] = y;\n            sz[y] += sz[x];\n        }\n    }\n\nint main() {\n    vector<vector<int>> edges1 = {{1,2},{1,3},{2,3}};\n    cout << \"[\";\n    for (auto edge : Solution().findRedundantConnection(edges1)) {\n        cout << edge << \" \";\n    }\n    cout << \"]\";\n\n    cout << endl;\n\n    vector<vector<int>> edges2 = {{1,2},{2,3},{3,4},{1,5}};\n    cout << \"[\";\n    for (auto edge : Solution().findRedundantConnection(edges2)) {\n        cout << edge << \" \";\n    }\n    cout << \"]\";\n\n    cout << endl;\n\n    vector<vector<int>> edges3 = {{1,2},{2,3},{3,4},{4,5},{1,5}};\n    cout << \"[\";\n    for (auto edge : Solution().findRedundantConnection(edges3)) {\n        cout << edge << \" \";\n    }\n    cout << \"]\";\n\n    return 0;\n}\n```",
  "687": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int longestUnivaluePath(TreeNode* root) {\n        if (!root)\n            return 0;\n\n        int maxPath = 0;\n\n        helper(root, 0, maxPath);\n\n        return maxPath;\n    }\n\nprivate:\n    void helper(TreeNode* node, int depth, int& maxPath) {\n        if (!node)\n            return;\n\n        if (node->val == node->left && node->left && node->right && node->right->val == node->val) {\n            int path = 2 * depth + 1;\n            if (path > maxPath)\n                maxPath = path;\n        } else if ((node->left && node->val == node->left->val) || (node->right && node->val == node->right->val)) {\n            int path = depth + 1;\n            if (path > maxPath)\n                maxPath = path;\n\n            helper(node->left, depth + 1, maxPath);\n            helper(node->right, depth + 1, maxPath);\n        } else {\n            helper(node->left, depth + 1, maxPath);\n            helper(node->right, depth + 1, maxPath);\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1:\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(5);\n    root1->left->left = new TreeNode(5);\n    root1->left->right = new TreeNode(2);\n    std::cout << \"Test Case 1: Expected output - 3. Actual output - \" << solution.longestUnivaluePath(root1) << std::endl;\n\n    // Test Case 2:\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(4);\n    root2->right = new TreeNode(5);\n    root2->left->left = new TreeNode(1);\n    root2->left->right = new TreeNode(1);\n    std::cout << \"Test Case 2: Expected output - 3. Actual output - \" << solution.longestUnivaluePath(root2) << std::endl;\n\n    // Test Case 3:\n    TreeNode* root3 = new TreeNode(4);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(5);\n    root3->left->left = new TreeNode(1);\n    root3->left->right = new TreeNode(1);\n    std::cout << \"Test Case 3: Expected output - 3. Actual output - \" << solution.longestUnivaluePath(root3) << std::endl;\n\n    return 0;\n}\n```",
  "688": "```\n#include <iostream>\n#include <vector>\n\nint getProbability(std::vector<std::vector<int>>& n) {\n    int totMoves = (int)1e9;\n    int totalSteps = 0;\n\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (n[i][j] == 2) {\n                totalSteps += 4;\n            } else if (n[i][j] == 1) {\n                if (i != 0 && n[i - 1][j] == 1) {\n                    totalSteps++;\n                }\n                if (i != 7 && n[i + 1][j] == 1) {\n                    totalSteps++;\n                }\n                if (j != 0 && n[i][j - 1] == 1) {\n                    totalSteps++;\n                }\n                if (j != 7 && n[i][j + 1] == 1) {\n                    totalSteps++;\n                }\n            }\n        }\n    }\n\n    int totPoss = 2 * 8 * 8;\n    return (totMoves - totalSteps) / (double)(totPoss - totalSteps);\n}\n\nint main() {\n    std::vector<std::vector<int>> n1 = {{4,3},{4,4}};\n    std::cout << getProbability(n1) << std::endl;\n\n    std::vector<std::vector<int>> n2 = {{0,0},{7,7}};\n    std::cout << getProbability(n2) << std::endl;\n\n    std::vector<std::vector<int>> n3 = {{5,6},{5,8}};\n    std::cout << getProbability(n3) << std::endl;\n}",
  "689": "```\n#include <iostream>\n#include <vector>\n\nint maxSumOfThreeSubarrays(std::vector<int>& nums, int k) {\n    int n = nums.size();\n    std::vector<int> left(n), right(n);\n    \n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        left[i] = sum;\n    }\n    \n    sum = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        sum += nums[i];\n        right[n - i - 1] = sum;\n    }\n    \n    int maxSum = 0;\n    for (int i = k; i < n - 2 * k; i++) {\n        for (int j = i + k; j < n - k; j++) {\n            for (int l = j + k; l <= n - k; l++) {\n                int currSum = left[i] - (i > 0 ? left[i - 1] : 0) + right[l] - (l < n - 1 ? right[l + 1] : 0);\n                maxSum = std::max(maxSum, currSum);\n            }\n        }\n    }\n    \n    return maxSum;\n}\n\nint main() {\n    std::vector<int> nums1 = {3,2,1,4,5};\n    int k1 = 2;\n    std::cout << \"Test case 1: \" << maxSumOfThreeSubarrays(nums1, k1) << \"\\n\";\n    \n    std::vector<int> nums2 = {1,2,3,4,5};\n    int k2 = 2;\n    std::cout << \"Test case 2: \" << maxSumOfThreeSubarrays(nums2, k2) << \"\\n\";\n    \n    std::vector<int> nums3 = {0,0,0,2,6,9,9,10,10};\n    int k3 = 4;\n    std::cout << \"Test case 3: \" << maxSumOfThreeSubarrays(nums3, k3) << \"\\n\";\n    \n    return 0;\n}\n```",
  "690": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Employee {\n    int id;\n    vector<Employee*> subordinates;\n};\n\nclass Solution {\npublic:\n    int getImportance(vector<Employee*> employees, string idKey) {\n        unordered_map<string, Employee*> employeeMap;\n        \n        for (Employee* e : employees) {\n            employeeMap[e->id + \"\"] = e;\n        }\n        \n        queue<string> q;\n        q.push(idKey);\n        \n        int importance = 0;\n        \n        while (!q.empty()) {\n            string currentId = q.front();\n            q.pop();\n            \n            Employee* currentEmployee = employeeMap[currentId];\n            importance += currentEmployee->importance;\n            \n            for (Employee* e : currentEmployee->subordinates) {\n                q.push(e->id + \"\");\n            }\n        }\n        \n        return importance;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<Employee*> employees1 = {new Employee{1, {}}, new Employee{2, {}}, new Employee{3, {}},\n                                     new Employee{4, {}}, new Employee{5, {}}};\n    employees1[0]->id = \"1\";\n    employees1[1]->id = \"2\";\n    employees1[2]->id = \"3\";\n    employees1[3]->id = \"4\";\n    employees1[4]->id = \"5\";\n    employees1[0]->importance = 5;\n    employees1[1]->importance = 3;\n    employees1[2]->importance = 3;\n    employees1[3]->importance = 2;\n    employees1[4]->importance = 1;\n    \n    string idKey1 = \"1\";\n    cout << \"Test Case 1: \" << solution.getImportance(employees1, idKey1) << endl;\n\n    // Test Case 2\n    vector<Employee*> employees2 = {new Employee{1, {}}, new Employee{2, {}}};\n    employees2[0]->id = \"1\";\n    employees2[1]->id = \"2\";\n    employees2[0]->importance = 5;\n    employees2[1]->importance = 3;\n\n    string idKey2 = \"1\";\n    cout << \"Test Case 2: \" << solution.getImportance(employees2, idKey2) << endl;\n\n    // Test Case 3\n    vector<Employee*> employees3 = {};\n    \n    string idKey3 = \"\";\n    cout << \"Test Case 3: \" << solution.getImportance(employees3, idKey3) << endl;\n    \n    return 0;\n}",
  "691": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minStickers(vector<string>& stickers, string target) {\n        int n = (1 << target.length());\n        vector<int> dp(n, target.length() + 1);\n        \n        for (int i = 0; i < n; ++i) {\n            bool found = false;\n            for (const auto& sticker : stickers) {\n                int mask = 0;\n                for (int j = 0; j < sticker.length(); ++j) {\n                    if (i & (1 << target.find(sticker[j]))) {\n                        mask |= 1 << target.find(sticker[j]);\n                    }\n                }\n                if ((mask & i) == mask) {\n                    found = true;\n                    dp[i] = min(dp[i], dp[mask - 1] + sticker.length());\n                    break;\n                }\n            }\n            if (!found) {\n                dp[i] = dp[(i << 1)];\n            }\n        }\n        \n        return dp[n - 1];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> stickers1 = {\"with\", \"example\", \"com\"}; \n    string target1 = \"wit\";\n    cout << \"Test case 1: The minimum number of stickers needed is \" << solution.minStickers(stickers1, target1) << endl;\n\n    // Test case 2\n    vector<string> stickers2 = {\"note\", \"exec\"}; \n    string target2 = \"execu\";\n    cout << \"Test case 2: The minimum number of stickers needed is \" << solution.minStickers(stickers2, target2) << endl;\n\n    // Test case 3\n    vector<string> stickers3 = {\"abc\", \"def\", \"ghi\"}; \n    string target3 = \"abcdefgh\";\n    cout << \"Test case 3: The minimum number of stickers needed is \" << solution.minStickers(stickers3, target3) << endl;\n\n    return 0;\n}\n```",
  "693": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool hasAlternatingBits(int n) {\n        int prevBit = (n >> 31) & 1;\n        while (n > 0) {\n            int currentBit = (n & 1);\n            if ((prevBit == 0 && currentBit == 0) || (prevBit == 1 && currentBit == 1))\n                return false;\n            prevBit = currentBit;\n            n >>= 1;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    cout << boolalpha;\n    cout << \"Test case 1: \" << s.hasAlternatingBits(5) << endl;  // Expected output: true\n    cout << \"Test case 2: \" << s.hasAlternatingBits(7) << endl;  // Expected output: false\n    cout << \"Test case 3: \" << s.hasAlternatingBits(10) << endl;   // Expected output: true\n    \n    return 0;\n}\n```",
  "692": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> topKFrequent(vector<string>& words, int k) {\n        unordered_map<string, int> wordCount;\n        for (const string& word : words) {\n            wordCount[word]++;\n        }\n        \n        priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> pq;\n        for (const auto& p : wordCount) {\n            pq.push({p.second, p.first});\n        }\n        \n        vector<string> result;\n        while (!pq.empty() && result.size() < k) {\n            result.push_back(pq.top().second);\n            pq.pop();\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<string> words1 = {\"the\", \"day\", \"is\", \"sun\", \"is\", \"the\"};\n    int k1 = 2;\n    vector<string> expected1 = {\"the\", \"is\"};\n    if (solution.topKFrequent(words1, k1) != expected1) {\n        cout << \"Test Case 1 failed\" << endl;\n        return 1;\n    }\n\n    // Test Case 2\n    vector<string> words2 = {\"top\", \"practice\", \"top\", \"hobbies\", \"practise\"};\n    int k2 = 3;\n    vector<string> expected2 = {\"practise\", \"top\", \"hobbies\"};\n    if (solution.topKFrequent(words2, k2) != expected2) {\n        cout << \"Test Case 2 failed\" << endl;\n        return 1;\n    }\n\n    // Test Case 3\n    vector<string> words3 = {};\n    int k3 = 0;\n    vector<string> expected3 = {};\n    if (solution.topKFrequent(words3, k3) != expected3) {\n        cout << \"Test Case 3 failed\" << endl;\n        return 1;\n    }\n\n    cout << \"All test cases passed\" << endl;\n    return 0;\n}\n```",
  "694": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numDistinctIslands(vector<vector<int>>& grid) {\n        if (grid.empty()) return 0;\n        \n        vector<string> islands;\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[0].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    set<pair<int, int>> path;\n                    dfs(grid, i, j, path);\n                    string island = \"\";\n                    for (pair<int, int> p : path) {\n                        island += to_string(p.first) + \",\" + to_string(p.second) + \" \";\n                    }\n                    islands.push_back(island);\n                }\n            }\n        }\n        \n        unordered_set<string> uniqueIslands(islands.begin(), islands.end());\n        return uniqueIslands.size();\n    }\n\nprivate:\n    void dfs(vector<vector<int>>& grid, int i, int j, set<pair<int, int>>& path) {\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == 0) return;\n        \n        grid[i][j] = 0;\n        path.insert({i, j});\n        \n        dfs(grid, i - 1, j, path);\n        dfs(grid, i + 1, j, path);\n        dfs(grid, i, j - 1, path);\n        dfs(grid, i, j + 1, path);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> grid1 = {{0,0,1,0,0},{0,0,1,0,0},{0,0,1,1,1},{0,1,1,1,0},{0,0,0,0,0}};\n    cout << \"Test case 1: \" << solution.numDistinctIslands(grid1) << endl;\n\n    // Test case 2\n    vector<vector<int>> grid2 = {{1,1,0,0,0},{1,1,0,0,0},{1,1,0,0,0}};\n    cout << \"Test case 2: \" << solution.numDistinctIslands(grid2) << endl;\n\n    // Test case 3\n    vector<vector<int>> grid3 = {{0,1},{1,1}};\n    cout << \"Test case 3: \" << solution.numDistinctIslands(grid3) << endl;\n    \n    return 0;\n}\n```",
  "695": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        if (grid.empty()) return 0;\n        \n        int m = grid.size(), n = grid[0].size();\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    res = max(res, dfs(grid, i, j));\n                }\n            }\n        }\n        return res;\n    }\n    \nprivate:\n    int dfs(vector<vector<int>>& grid, int i, int j) {\n        int m = grid.size(), n = grid[0].size();\n        if (i < 0 || j < 0 || i >= m || j >= n || grid[i][j] == 0) return 0;\n        \n        grid[i][j] = 0; // mark as visited\n        \n        int res = 1;\n        res += dfs(grid, i - 1, j);\n        res += dfs(grid, i + 1, j);\n        res += dfs(grid, i, j - 1);\n        res += dfs(grid, i, j + 1);\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test case 1\n    vector<vector<int>> grid1 = {{0,0,1,0,0},{0,0,1,0,0},{0,0,1,0,0},{0,0,0,0,0}};\n    cout << \"Test case 1: \" << s.maxAreaOfIsland(grid1) << endl;\n\n    // Test case 2\n    vector<vector<int>> grid2 = {{0,0,1},{0,1,1},{1,1,1}};\n    cout << \"Test case 2: \" << s.maxAreaOfIsland(grid2) << endl;\n\n    // Test case 3\n    vector<vector<int>> grid3 = {{1}};\n    cout << \"Test case 3: \" << s.maxAreaOfIsland(grid3) << endl;\n\n    return 0;\n}\n```",
  "696": "```\n#include <iostream>\n#include <string>\n\nint countBinarySubstrings(std::string s) {\n    int ans = 0;\n    int left = 0;\n    for (int right = 0; right < s.length(); ++right) {\n        if ((right == s.length() - 1 || s[right] != s[left])) {\n            ans += (right - left);\n            left = right;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::cout << countBinarySubstrings(\"00110\") << std::endl; // Expected output: 3\n    std::cout << countBinarySubstrings(\"10101\") << std::endl; // Expected output: 4\n    std::cout << countBinarySubstrings(\"00011100\") << std::endl; // Expected output: 8\n    return 0;\n}",
  "697": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findShortestSubArray(vector<int>& nums) {\n        int minLen = INT_MAX;\n        unordered_map<int, pair<int, int>> mp;\n        \n        for(int i=0; i<nums.size(); i++) {\n            if(!mp.count(nums[i])) mp[nums[i]] = {i, i};\n            else mp[nums[i]].second = i;\n        }\n        \n        for(auto p : mp) {\n            minLen = min(minLen, p.second.second - p.second.first + 1);\n        }\n        \n        return minLen;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> nums1 = {2, 1};\n    cout << \"Test case 1: Expected output is 3, actual output is \" << solution.findShortestSubArray(nums1) << endl;\n    \n    vector<int> nums2 = {1, 2, 2, 3, 5];\n    cout << \"Test case 2: Expected output is 2, actual output is \" << solution.findShortestSubArray(nums2) << endl;\n    \n    vector<int> nums3 = {4, 6};\n    cout << \"Test case 3: Expected output is 2, actual output is \" << solution.findShortestSubArray(nums3) << endl;\n\n    return 0;\n}\n```",
  "698": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        if (k > size(nums)) return false;\n        vector<vector<int>> subsets(k);\n        sort(nums.begin(), nums.end());\n        for (int num : nums) {\n            int idx = lower_bound(subsets[0].begin(), subsets[0].end(), num) - subsets[0].begin();\n            if (idx == k) idx--;\n            while (subsets[idx].size() + 1 > size(subsets[0])) idx = (idx + 1) % k;\n            subsets[idx].push_back(num);\n        }\n        for (int i = 0; i < k; ++i) {\n            int sum = 0;\n            for (int num : subsets[i]) sum += num;\n            if (sum != nums[0] * k) return false;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<int> nums1 = {4,3,2,3,5,2};\n    cout << \"Test case 1: \" << (solution.canPartitionKSubsets(nums1, 2) ? \"True\" : \"False\") << endl;\n\n    vector<int> nums2 = {2,1,8,10,6};\n    cout << \"Test case 2: \" << (solution.canPartitionKSubsets(nums2, 3) ? \"True\" : \"False\") << endl;\n\n    vector<int> nums3 = {5,4,3,3,2,2};\n    cout << \"Test case 3: \" << (solution.canPartitionKSubsets(nums3, 3) ? \"True\" : \"False\") << endl;\n    \n    return 0;\n}",
  "699": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> fallingSquares(vector<vector<int>>& positions) {\n        int n = positions.size();\n        vector<int> heights(n);\n        vector<pair<int, int>> updates;\n        for (int i = 0; i < n; i++) {\n            int x1 = positions[i][0], y1 = positions[i][1], s = positions[i][2];\n            for (int j = i + 1; j < n; j++) {\n                if (positions[j][0] > x1 || positions[j][1] < y1) continue;\n                int x2 = positions[j][0], y2 = positions[j][1], t = positions[j][2];\n                if (y2 >= y1 && x1 <= x2) updates.push_back({y2, s + t});\n            }\n        }\n        vector<int> res;\n        for (int i = 0; i < n; i++) {\n            int y = positions[i][1];\n            while (!updates.empty() && updates.back().first >= y) {\n                auto [yh, h] = updates.back(); updates.pop_back();\n                if (y <= yh) res.push_back(h);\n                else y = yh;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> positions1 = {{0,0,2},{2,2,3}};\n    vector<int> result1 = solution.fallingSquares(positions1);\n    cout << \"Test Case 1: \";\n    for (int height : result1) {\n        cout << height << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<vector<int>> positions2 = {{0,5,4},{7,6,3}};\n    vector<int> result2 = solution.fallingSquares(positions2);\n    cout << \"Test Case 2: \";\n    for (int height : result2) {\n        cout << height << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<vector<int>> positions3 = {{1,0,1},{3,0,5}};\n    vector<int> result3 = solution.fallingSquares(positions3);\n    cout << \"Test Case 3: \";\n    for (int height : result3) {\n        cout << height << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "700": "```\n#include <iostream>\n#include \"TreeNode.h\"\n\nclass Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        if (!root || root->val == val) return root;\n        return (val < root->val) ? searchBST(root->left, val) : searchBST(root->right, val);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    TreeNode* tree1 = new TreeNode(4);\n    tree1->left = new TreeNode(2);\n    tree1->right = new TreeNode(7);\n    tree1->left->left = new TreeNode(1);\n    tree1->left->right = new TreeNode(3);\n    \n    std::cout << \"Test Case 1: \" << (solution.searchBST(tree1, 2) ? \"Found\" : \"Not Found\") << std::endl;\n    \n    // Test Case 2\n    TreeNode* tree2 = new TreeNode(5);\n    tree2->left = new TreeNode(3);\n    tree2->right = new TreeNode(6);\n    \n    std::cout << \"Test Case 2: \" << (solution.searchBST(tree2, 3) ? \"Found\" : \"Not Found\") << std::endl;\n    \n    // Test Case 3\n    TreeNode* tree3 = new TreeNode(10);\n    tree3->left = new TreeNode(5);\n    tree3->right = new TreeNode(15);\n    \n    std::cout << \"Test Case 3: \" << (solution.searchBST(tree3, 15) ? \"Found\" : \"Not Found\") << std::endl;\n    \n    return 0;\n}\n```",
  "701": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if (root == NULL || val < root->val) {\n            TreeNode* newRoot = new TreeNode(val);\n            newRoot->left = root;\n            return newRoot;\n        }\n        else if (val > root->val) {\n            if (root->right == NULL) {\n                root->right = new TreeNode(val);\n                return root;\n            }\n            else {\n                return insertIntoBST(root->right, val);\n            }\n        }\n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(4);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(7);\n    root1->left->left = new TreeNode(1);\n    root1->left->right = new TreeNode(3);\n    solution.insertIntoBST(root1, 5);\n\n    // Test case 2\n    TreeNode* root2 = NULL;\n    solution.insertIntoBST(root2, 4);\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(2);\n    root3->left = new TreeNode(1);\n    root3->right = new TreeNode(3);\n    solution.insertIntoBST(root3, 5);\n\n    return 0;\n}\n```",
  "702": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int search(std::vector<int>& nums) {\n        int left = 0;\n        int right = nums.size() - 1;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> nums1 = {8};\n    int target1 = 8;\n    int result1 = solution.search(nums1);\n    if (result1 != 0) {\n        std::cout << \"Test case 1 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> nums2 = {1, 3};\n    int target2 = 0;\n    int result2 = solution.search(nums2);\n    if (result2 == -1) {\n        std::cout << \"Test case 2 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> nums3 = {5, 7, 9};\n    int target3 = 8;\n    int result3 = solution.search(nums3);\n    if (result3 == -1) {\n        std::cout << \"Test case 3 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "703": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass KthLargest {\npublic:\n    priority_queue<int> pq;\n    \n    void add(int val) {\n        pq.push(val);\n        \n        if(pq.size() > k) {\n            pq.pop();\n        }\n    }\n    \n    int kthLargest(int k) {\n        this->k = k;\n        return pq.top();\n    }\n\nprivate:\n    int k;\n};\n\nint main() {\n    KthLargest kl;\n\n    // Test case 1\n    vector<int> testCase1 = {4,5,8,2};\n    for(auto val : testCase1) {\n        kl.add(val);\n    }\n    cout << \"Kth largest in test case 1: \" << kl.kthLargest(3) << endl;\n\n    // Test case 2\n    vector<int> testCase2 = {1,2,3,4};\n    for(auto val : testCase2) {\n        kl.add(val);\n    }\n    cout << \"Kth largest in test case 2: \" << kl.kthLargest(4) << endl;\n\n    // Test case 3\n    vector<int> testCase3 = {0,1,2,3};\n    for(auto val : testCase3) {\n        kl.add(val);\n    }\n    cout << \"Kth largest in test case 3: \" << kl.kthLargest(4) << endl;\n\n    return 0;\n}\n```",
  "704": "```\n#include <iostream>\n#include <vector>\n\nint search(std::vector<int>& nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 3};\n    int target1 = 2;\n    std::cout << \"Test case 1: \" << search(nums1, target1) << std::endl;\n\n    std::vector<int> nums2 = {2, 5, 6, 8};\n    int target2 = 7;\n    std::cout << \"Test case 2: \" << search(nums2, target2) << std::endl;\n\n    std::vector<int> nums3 = [1, 2, 3, 4, 5];\n    int target3 = 3;\n    std::cout << \"Test case 3: \" << search(nums3, target3) << std::endl;\n\n    return 0;\n}\n```",
  "705": "```\n#include <iostream>\n#include <vector>\n\nclass MyHashSet {\npublic:\n    vector<bool> bucket(1000000, false);\n\n    void add(int key) {\n        bucket[key] = true;\n    }\n\n    void remove(int key) {\n        bucket[key] = false;\n    }\n\n    bool contains(int key) {\n        return bucket[key];\n    }\n};\n\nint main() {\n    MyHashSet mySet;\n    \n    // Test Case 1: Add and Check\n    mySet.add(1);\n    cout << \"Contains 1: \" << (mySet.contains(1)? \"True\" : \"False\") << endl; \n    mySet.remove(1);\n    cout << \"Contains 1 now: \" << (mySet.contains(1)? \"True\" : \"False\") << endl; \n\n    // Test Case 2: Add and Check\n    mySet.add(10);\n    cout << \"Contains 10: \" << (mySet.contains(10)? \"True\" : \"False\") << endl;\n    mySet.remove(10);\n    cout << \"Contains 10 now: \" << (mySet.contains(10)? \"True\" : \"False\") << endl; \n\n    // Test Case 3: Add and Check\n    mySet.add(1000000);\n    cout << \"Contains 1000000: \" << (mySet.contains(1000000)? \"True\" : \"False\") << endl;\n    \n    return 0;\n}\n```",
  "706": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass MyHashMap {\npublic:\n    vector<pair<int, int>>* table = new vector<pair<int, int>>();\n\n    void put(int key, int value) {\n        for (int i = 0; i < table->size(); i++) {\n            if ((*table)[i].first == key) {\n                (*table)[i].second = value;\n                return;\n            }\n        }\n        table->push_back({key, value});\n    }\n\n    int get(int key) {\n        for (int i = 0; i < table->size(); i++) {\n            if ((*table)[i].first == key) {\n                return (*table)[i].second;\n            }\n        }\n        return -1;\n    }\n};\n\nint main() {\n    MyHashMap hashmap;\n\n    hashmap.put(1, 1);\n    hashmap.put(2, 2);\n\n    // Test Case 1\n    cout << \"Test Case 1: \" << hashmap.get(1) << endl;  // Output: 1\n\n    hashmap.put(3, 3);\n\n    // Test Case 2\n    cout << \"Test Case 2: \" << hashmap.get(2) << endl;  // Output: 2\n\n    // Test Case 3\n    cout << \"Test Case 3: \" << hashmap.get(3) << endl;  // Output: 3\n\n    return 0;\n}\n```",
  "707": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass MyLinkedList {\npublic:\n    MyLinkedList() {}\n\n    int get(int index) {\n        if (head == NULL || head->val > 1) return -1;\n        ListNode* curr = head;\n        for (int i = 0; i < index && curr->next != NULL; i++) {\n            curr = curr->next;\n        }\n        return curr ? curr->val : -1;\n    }\n\n    void printList(ListNode* node) {\n        while (node) {\n            cout << node->val << \" \";\n            node = node->next;\n        }\n        cout << endl;\n    }\n\nprivate:\n    ListNode* head;\n};\n\nint main() {\n    MyLinkedList ll;\n\n    // Test case 1: Create a linked list with some values\n    ll.head = new ListNode(1);\n    ll.head->next = new ListNode(2);\n    ll.head->next->next = new ListNode(3);\n\n    cout << \"Test case 1: \";\n    ll.printList(ll.head);  // Output: 1 2 3\n\n    // Test case 2: Try to get a value outside the range\n    cout << \"Test case 2: \" << ll.get(4) << endl;  // Output: -1\n\n    // Test case 3: Try to get a value within the range\n    ll.head = new ListNode(5);\n    ll.head->next = new ListNode(6);\n\n    cout << \"Test case 3: \";\n    ll.printList(ll.head);  // Output: 5 6\n\n    return 0;\n}\n```",
  "709": "```\n#include <iostream>\n#include <string>\n\nstd::string toLowerCase(std::string str) {\n    for (int i = 0; i < str.length(); i++) {\n        if ((str[i] >= 'A' && str[i] <= 'Z')) {\n            str[i] += ('a' - 'A');\n        }\n    }\n    return str;\n}\n\nint main() {\n    std::cout << toLowerCase(\"Hello\") << std::endl;  // Output: hello\n    std::cout << toLowerCase(\"WORLD\") << std::endl;   // Output: world\n    std::cout << toLowerCase(\"hELLO WORLD!\") << std::endl;  // Output: hello world!\n    return 0;\n}\n```",
  "708": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a Node.\nstruct Node {\n    int val;\n    Node* next;\n};\n\nclass Solution {\npublic:\n    Node* insert(Node* head, int insertVal) {\n        if (head == NULL || head->next == head) { // only one node or the list is circular\n            Node* newNode = new Node();\n            newNode->val = insertVal;\n            if (head == NULL) return newNode; // first node\n            else {\n                newNode->next = head;\n                head->next = newNode;\n                return head;\n            }\n        } \n\n        Node* prev = head;\n        Node* cur = head->next;\n\n        while (cur != head && cur->val < insertVal) { // keep moving if not there yet\n            prev = cur;\n            cur = cur->next;\n        }\n\n        if (cur->val == insertVal) return head; // already there\n\n        Node* newNode = new Node();\n        newNode->val = insertVal;\n\n        prev->next = newNode;\n        newNode->next = cur;\n\n        return head;\n    }\n};\n\nint main() {\n    Solution s;\n    Node* head1 = new Node();\n    head1->val = 3;\n    head1->next = head1; // circular\n    cout << \"Test case 1: \";\n    Node* res1 = s.insert(head1, 2);\n    for (Node* p = res1; p != NULL; p = p->next) {\n        cout << p->val << \" \";\n    }\n    cout << endl;\n\n    Node* head2 = new Node();\n    head2->val = 3;\n    head2->next = new Node(); // not circular\n    head2->next->val = 4;\n    head2->next->next = NULL;\n    cout << \"Test case 2: \";\n    Node* res2 = s.insert(head2, 1);\n    for (Node* p = res2; p != NULL; p = p->next) {\n        cout << p->val << \" \";\n    }\n    cout << endl;\n\n    Node* head3 = new Node();\n    head3->val = 1;\n    head3->next = head3; // circular\n    cout << \"Test case 3: \";\n    Node* res3 = s.insert(head3, 5);\n    for (Node* p = res3; p != NULL; p = p->next) {\n        cout << p->val << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "711": "```\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numDistinctIslands(vector<vector<int>>& grid) {\n        if (grid.empty()) return 0;\n        \n        unordered_set<string> islands;\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[0].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    islandIsland(grid, i, j, \"\", islands);\n                }\n            }\n        }\n        \n        return islands.size();\n    }\n\nprivate:\n    void islandIsland(vector<vector<int>>& grid, int i, int j, string path, unordered_set<string>& islands) {\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || grid[i][j] == 0) return;\n        \n        grid[i][j] = 0; // mark as visited\n        \n        path += \"L\" + to_string(i) + \",\" + to_string(j);\n        \n        if (islands.count(path)) return;\n        \n        islands.insert(path);\n        \n        for (int k = -1; k <= 1; ++k) {\n            for (int l = -1; l <= 1; ++l) {\n                islandIsland(grid, i + k, j + l, path, islands);\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<vector<int>> grid1 = {{0,0,1},{0,1,1},{0,2,0}};\n    cout << \"Test case 1: \" << solution.numDistinctIslands(grid1) << endl; // Output: 1\n\n    // Test case 2:\n    vector<vector<int>> grid2 = {{1,1}, {1,0}, {1,0}};\n    cout << \"Test case 2: \" << solution.numDistinctIslands(grid2) << endl; // Output: 1\n\n    // Test case 3:\n    vector<vector<int>> grid3 = {{1,1,0},{1,0,1},{0,0,1}};\n    cout << \"Test case 3: \" << solution.numDistinctIslands(grid3) << endl; // Output: 2\n\n    return 0;\n}\n```",
  "710": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<int> randomPickIndex(std::vector<int>& nums, std::vector<bool>& blacklist) {\n        int n = nums.size();\n        std::vector<int> res;\n        for (int i = 0; i < n; ++i) {\n            if (!blacklist[i]) {\n                res.push_back(i);\n            }\n        }\n        \n        std::random_shuffle(res.begin(), res.end());\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int n = 10;\n    std::vector<int> nums(n, 0);\n    for (int i = 0; i < n; ++i) {\n        nums[i] = i + 1;\n    }\n\n    std::vector<bool> blacklist(5, false);\n    for (int i = 2; i <= 4; ++i) {\n        blacklist[i - 1] = true;\n    }\n    std::vector<int> res1 = solution.randomPickIndex(nums, blacklist);\n\n    // Test Case 2\n    n = 10;\n    nums.resize(n);\n    for (int i = 0; i < n; ++i) {\n        nums[i] = i + 1;\n    }\n\n    blacklist.clear();\n    for (int i = 3; i <= 6; ++i) {\n        blacklist.push_back(true);\n    }\n    std::vector<int> res2 = solution.randomPickIndex(nums, blacklist);\n\n    // Test Case 3\n    n = 5;\n    nums.resize(n);\n    for (int i = 0; i < n; ++i) {\n        nums[i] = i + 1;\n    }\n\n    blacklist.clear();\n    for (int i = 2; i <= 4; ++i) {\n        blacklist.push_back(true);\n    }\n    std::vector<int> res3 = solution.randomPickIndex(nums, blacklist);\n\n    // Print the results\n    std::cout << \"Test Case 1: \";\n    for (auto num : res1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"Test Case 2: \";\n    for (auto num : res2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::cout << \"Test Case 3: \";\n    for (auto num : res3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```",
  "713": "```\n#include <iostream>\n#include <vector>\n\nint numSubarrayProductLessThanK(std::vector<int>& nums, int k) {\n    if (k == 0) return 0;\n    long long product = 1;\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        product *= nums[i];\n        if (product >= k) break;\n        count += nums.size() - i;\n    }\n    return count;\n}\n\nint main() {\n    std::vector<int> nums1 = {10, 5, 2, 6};\n    int k1 = 100;\n    std::cout << numSubarrayProductLessThanK(nums1, k1) << \"\\n\";\n\n    std::vector<int> nums2 = {1, 2, 3, 4};\n    int k2 = 10;\n    std::cout << numSubarrayProductLessThanK(nums2, k2) << \"\\n\";\n\n    std::vector<int> nums3 = [5, 3];\n    int k3 = 18;\n    std::cout << numSubarrayProductLessThanK(nums3, k3) << \"\\n\";\n}\n```",
  "712": "```\n#include <iostream>\n#include <string>\n\nint minDistance(std::string s1, std::string s2) {\n    int m = s1.size();\n    int n = s2.size();\n\n    // Create a table to store lengths of longest common subsequences\n    int dp[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (s1[i - 1] == s2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    // Return the minimum length of common subsequence\n    return m + n - 2 * dp[m][n];\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << minDistance(\"abc\", \"pqr\") << \"\\n\";\n    std::cout << \"Test Case 2: \" << minDistance(\"xyz\", \"abcde\") << \"\\n\";\n    std::cout << \"Test Case 3: \" << minDistance(\"\", \"\") << \"\\n\";\n\n    return 0;\n}\n```",
  "714": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int maxProfit(std::vector<int>& prices, int fee) {\n        if (prices.empty()) return 0;\n        \n        int buy = -prices[0], sell = 0, prev_buy = buy, prev_sell = sell;\n        \n        for (int i = 1; i < prices.size(); ++i) {\n            prev_buy = max(prev_buy, prev_sell - fee);\n            prev_sell = max(prev_sell, prices[i] + prev_buy);\n        }\n        \n        return prev_sell;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<int> prices1 = {1, 2};\n    int fee1 = 2;\n    std::cout << \"Test case 1: \" << solution.maxProfit(prices1, fee1) << std::endl;\n\n    std::vector<int> prices2 = {2, 3, 4};\n    int fee2 = 1;\n    std::cout << \"Test case 2: \" << solution.maxProfit(prices2, fee2) << std::endl;\n\n    std::vector<int> prices3 = {5, 6, 7, 8, 9};\n    int fee3 = 0;\n    std::cout << \"Test case 3: \" << solution.maxProfit(prices3, fee3) << std::endl;\n\n    return 0;\n}\n```",
  "715": "```\n#include <iostream>\n#include <vector>\n\nclass RangeModule {\npublic:\n    RangeModule() {}\n    \n    void addRange(int left, int right) {\n        // Your implementation here\n    }\n    \n    void queryRange(int left, int right) {\n        // Your implementation here\n    }\n};\n\nint main() {\n    RangeModule module;\n\n    // Test case 1\n    module.addRange(0, 3);\n    module.queryRange(0, 2); // Returns true (subset of [0,3])\n    module.queryRange(2, 5); // Returns false (partially outside of [0,3])\n\n    // Test case 2\n    module.addRange(1, 10);\n\n    // Test case 3\n    module.queryRange(-5, 0); // Returns true (subset of [1,10])\n    module.queryRange(-5, 1); // Returns false (partially outside of [1,10])\n\n    return 0;\n}\n```",
  "716": "```\n#include <iostream>\n#include \"MaxStack.h\"\n\nint main() {\n    MaxStack* ms = new MaxStack();\n    ms->push(5);\n    ms->push(1);\n    ms->push(25);\n\n    std::cout << \"Maximum element is: \" << ms->peekMax() << std::endl;\n    \n    ms->pop();\n    \n    std::cout << \"Maximum element after pop is: \" << ms->peekMax() << std::endl;\n\n    ms->push(-5);\n    ms->push(3);\n    ms->push(-2);\n\n    std::cout << \"Maximum element after more pushes is: \" << ms->peekMax() << std::endl;\n    \n    ms->pop();\n    ms->pop();\n\n    std::cout << \"Maximum element after two pops is: \" << ms->peekMax() << std::endl;\n\n    return 0;\n}\n```",
  "717": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<char> characterReplacement(std::string s, int k) {\n        int start = 0, maxCount = 0, maxChar = ' ';\n        for (int end = 0; end < s.size(); end++) {\n            if (s[end] == maxChar) {\n                maxCount++;\n            } else {\n                maxChar = s[end];\n                maxCount = 1;\n                start = end;\n            }\n            while (end - start > k) {\n                if (s[start] == maxChar) {\n                    maxCount--;\n                }\n                start++;\n            }\n        }\n        return std::vector<char>(s.begin(), s.end() - k);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::string s1 = \"00110\";\n    int k1 = 5;\n    for (char c : solution.characterReplacement(s1, k1)) {\n        std::cout << c;\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::string s2 = \"0101\";\n    int k2 = 1;\n    for (char c : solution.characterReplacement(s2, k2)) {\n        std::cout << c;\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::string s3 = \"000110011\";\n    int k3 = 3;\n    for (char c : solution.characterReplacement(s3, k3)) {\n        std::cout << c;\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "718": "```\n#include <iostream>\n#include <vector>\n\nint findLength(const std::vector<int>& nums1, const std::vector<int>& nums2) {\n    int n = nums1.size();\n    int m = nums2.size();\n    std::vector<std::vector<bool>> dp(n + 1, std::vector<bool>(m + 1, false));\n    \n    int maxLen = 0;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            if (nums1[i - 1] == nums2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n                maxLen = std::max(maxLen, i);\n            }\n        }\n    }\n    \n    return maxLen;\n}\n\nint main() {\n    std::vector<int> nums1 = {1,2,3,2,1};\n    std::vector<int> nums2 = {3,2,1,2,1};\n    std::cout << \"Test Case 1: \" << findLength(nums1, nums2) << std::endl;\n\n    nums1.clear(); nums2.clear();\n    nums1.push_back(0); nums1.push_back(0);\n    nums2.push_back(0); nums2.push_back(0);\n    std::cout << \"Test Case 2: \" << findLength(nums1, nums2) << std::endl;\n\n    nums1.clear(); nums2.clear();\n    nums1 = {0,0,0}; nums2 = {0,0};\n    std::cout << \"Test Case 3: \" << findLength(nums1, nums2) << std::endl;\n    \n    return 0;\n}\n```",
  "719": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint kthSmallestPairDistance(std::vector<int>& arr1, std::vector<int>& arr2) {\n    int n = arr1.size();\n    int m = arr2.size();\n\n    std::sort(arr1.begin(), arr1.end());\n    std::sort(arr2.begin(), arr2.end());\n\n    int i = 0, j = 0;\n    int distance = INT_MAX;\n\n    while (i < n && j < m) {\n        if (arr1[i] - arr2[j] < distance)\n            distance = arr1[i] - arr2[j];\n        else if (arr1[i] > arr2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return distance;\n}\n\nint main() {\n    std::vector<int> arr1 = {10, 4, 2};\n    std::vector<int> arr2 = {3, 7, 9};\n    int k = 3;\n\n    std::cout << \"Test case 1: K-th smallest pair distance is \" << kthSmallestPairDistance(arr1, arr2) << std::endl;\n\n    arr1 = {30, 5, 15, 10};\n    arr2 = {20, 25};\n    k = 3;\n\n    std::cout << \"Test case 2: K-th smallest pair distance is \" << kthSmallestPairDistance(arr1, arr2) << std::endl;\n\n    arr1 = {1, 5, 2};\n    arr2 = {4, 6};\n    k = 2;\n\n    std::cout << \"Test case 3: K-th smallest pair distance is \" << kthSmallestPairDistance(arr1, arr2) << std::endl;\n    \n    return 0;\n}\n```",
  "720": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestWord(vector<string>& words) {\n        map<string, int> wordIndex;\n        vector<string> sortedWords = words;\n        sort(sortedWords.begin(), sortedWords.end());\n        \n        string longestWord = \"\";\n        for (const auto& word : sortedWords) {\n            if (word.length() > longestWord.length()) {\n                bool isGoodWord = true;\n                int i = 0;\n                while (i < word.length()) {\n                    if (i == wordIndex.find(word.substr(0, i+1))->second) {\n                        break;\n                    }\n                    if (word[i] != 'a') {\n                        isGoodWord = false;\n                        break;\n                    }\n                    i++;\n                }\n                if (isGoodWord && longestWord.length() < word.length()) {\n                    longestWord = word;\n                }\n            }\n        }\n        \n        return longestWord;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> words1 = {\"waa\",\"woa\"};\n    cout << \"Longest Word: \" << solution.longestWord(words1) << endl;\n\n    vector<string> words2 = {\"as\",\"asjaj\",\"nakajaj\",\"nakaayjab\"};\n    cout << \"Longest Word: \" << solution.longestWord(words2) << endl;\n\n    vector<string> words3 = {\"abcdefghijklmnopqrstuvwxyz\"};\n    cout << \"Longest Word: \" << solution.longestWord(words3) << endl;\n\n    return 0;\n}\n```",
  "722": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std://**/> removeComments(std::vector<std::string>& source) {\n    int n = source.size();\n    for (int i = 0; i < n; ++i) {\n        if (source[i].find(\"//\") != std::string::npos) {\n            source[i] = source[i].substr(0, source[i].find(\"//\")) + \"//\";\n        } else if (source[i].find(\"/*\") != std::string::npos && source[i].find(\"*/\") != std::string::npos) {\n            int start = source[i].find(\"/*\");\n            int end = source[i].find(\"*/\");\n            source[i] = source[i].substr(0, start) + source[i].substr(end + 2);\n        }\n    }\n    return source;\n}\n\nint main() {\n    std::vector<std::string> source1 = {\"Hello // world\", \"This is a test /* comment */\"};\n    for (const auto& line : removeComments(source1)) {\n        std::cout << line << std::endl;\n    }\n\n    std::vector<std::string> source2 = {\"/**\", \"Just some code\", \"*/\" };\n    for (const auto& line : removeComments(source2)) {\n        std::cout << line << std::endl;\n    }\n\n    std::vector<std::string> source3 = {\"// This is a comment\", \"This // isn't one\", \"/* Also */ this one\"};\n    for (const auto& line : removeComments(source3)) {\n        std::cout << line << std::endl;\n    }\n}",
  "721": "```\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> accountsMerge(vector<vector<string>>& accounts) {\n        unordered_map<int, int> root;\n        unordered_map<int, string> nameToId;\n        for (int i = 0; i < accounts.size(); i++) {\n            for (int j = 1; j < accounts[i].size(); j++) {\n                int id = stoi(accounts[i][j]);\n                if (nameToId.find(id) == nameToId.end()) {\n                    root[id] = id;\n                    nameToId[id] = accounts[i][0];\n                }\n            }\n        }\n\n        for (int i = 0; i < accounts.size(); i++) {\n            for (int j = 1; j < accounts[i].size(); j++) {\n                int id = stoi(accounts[i][j]);\n                if (!nameToId.empty()) {\n                    for (int k = 0; k < accounts[k].size(); k++) {\n                        if (k != i && stoi(accounts[k][j]) == id) {\n                            unionSet(root, stoi(accounts[i][j]), stoi(accounts[k][j]));\n                        }\n                    }\n                }\n            }\n        }\n\n        unordered_set<int> ids;\n        for (auto& p : nameToId) {\n            ids.insert(p.second);\n        }\n\n        vector<string> res;\n        for (auto& id : ids) {\n            int rootId = findSet(root, stoi(id));\n            res.push_back(nameToId[rootId]);\n            for (int i = 0; i < accounts.size(); i++) {\n                for (int j = 1; j < accounts[i].size(); j++) {\n                    if (stoi(accounts[i][j]) == rootId) {\n                        res.push_back(accounts[i][j + 1]);\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n\n    int findSet(unordered_map<int, int>& root, int x) {\n        return (root[x] == x) ? x : findSet(root, root[x]);\n    }\n\n    void unionSet(unordered_map<int, int>& root, int x, int y) {\n        root[y] = findSet(root, y);\n        root[findSet(root, x)] = findSet(root, y);\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<vector<string>> accounts1 = {{\"John\", \"johnsmithmail.com\", \"john_newyork.aa@jjj.l\", \"johnsmith@jjj.l\"},\n                                        {\"John\", \"johnsmith.com\", \"john_newyork.aa@jjj.l\", \"johnsmith@jjj.l\"},\n                                        {\"Mary\", \"mary@mail.com\", \"mary@yahoo.nn\", \"mary123@local.l\"}};\n    vector<string> res1 = solution.accountsMerge(accounts1);\n    for (auto& s : res1) {\n        cout << s << endl;\n    }\n\n    Solution solution2;\n    vector<vector<string>> accounts2 = {{\"A\", \"a1@example.com\", \"example@yahoo.com\"},\n                                        {\"B\", \"b@example.com\", \"example@gmail.com\"},\n                                        {\"C\", \"c@example.com\", \"example@outlook.com\"}};\n    vector<string> res2 = solution2.accountsMerge(accounts2);\n    for (auto& s : res2) {\n        cout << s << endl;\n    }\n\n    Solution solution3;\n    vector<vector<string>> accounts3 = {{\"A\", \"a1@example.com\"}, {\"B\", \"b@example.com\"}};\n    vector<string> res3 = solution3.accountsMerge(accounts3);\n    for (auto& s : res3) {\n        cout << s << endl;\n    }\n\n    return 0;\n}\n```",
  "724": "```\n#include <iostream>\n#include <vector>\n\nint pivotIndex(std::vector<int>& nums) {\n    int total = 0;\n    for (int num : nums) {\n        total += num;\n    }\n    int leftSum = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (leftSum == total - nums[i]) {\n            return i;\n        }\n        leftSum += nums[i];\n    }\n    return -1;\n}\n\nint main() {\n    std::vector<int> test1 = {1,7,3,6,5,2};\n    std::cout << \"Test 1: \" << pivotIndex(test1) << std::endl;\n\n    std::vector<int> test2 = {1,2,3,4,5,6};\n    std::cout << \"Test 2: \" << pivotIndex(test2) << std::endl;\n\n    std::vector<int> test3 = {0,1,-7,5,10,11};\n    std::cout << \"Test 3: \" << pivotIndex(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "723": "```\n#include <iostream>\n#include <vector>\n\nint candyCrush(std::vector<std::vector<int>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            if (grid[i][j] % 3 == 1 || grid[i][j] % 3 == 2) {\n                int x = i, y = j;\n                do {\n                    if (x > 0 && grid[x-1][y] == grid[i][j]%3) --x;\n                    else if (x < m - 1 && grid[x+1][y] == grid[i][j]%3) ++x;\n                    else break;\n                } while (true);\n                do {\n                    if (y > 0 && grid[x][y-1] == grid[i][j]%3) --y;\n                    else if (y < n - 1 && grid[x][y+1] == grid[i][j]%3) ++y;\n                    else break;\n                } while (true);\n                for (int k = x; k <= i; ++k)\n                    for (int l = y; l <= j; ++l)\n                        if (grid[k][l] % 3 != grid[i][j] % 3) {\n                            --grid[k][l];\n                            if (grid[k][l] < 0) grid[k][l] += 3;\n                        }\n            }\n    return 0;\n}\n\nint main() {\n    std::vector<std::vector<int>> grid1 = {{1,2},{2,1}};\n    candyCrush(grid1);\n    for (const auto& row : grid1)\n        std::cout << \"[\";\n    for (const auto& num : grid1[0])\n        std::cout << num << \" \";\n    std::cout << \"]\\n\";\n\n    std::vector<std::vector<int>> grid2 = {{3,4},{5,6}};\n    candyCrush(grid2);\n    for (const auto& row : grid2)\n        std::cout << \"[\";\n    for (const auto& num : grid2[0])\n        std::cout << num << \" \";\n    std::cout << \"]\\n\";\n\n    std::vector<std::vector<int>> grid3 = {{1,1},{2,2}};\n    candyCrush(grid3);\n    for (const auto& row : grid3)\n        std::cout << \"[\";\n    for (const auto& num : grid3[0])\n        std::cout << num << \" \";\n    std::cout << \"]\\n\";\n\n    return 0;\n}\n```",
  "725": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int k) {\n        if (head == NULL || head->next == NULL)\n            return head;\n\n        ListNode* newHead = head;\n        for (int i = 0; i < k && newHead != NULL; ++i) {\n            newHead = newHead->next;\n        }\n\n        if (newHead == NULL)\n            return head;\n\n        ListNode* cur1 = head;\n        ListNode* cur2 = newHead;\n        while (cur2 != NULL) {\n            cur1 = cur1->next;\n            cur2 = cur2->next;\n            if (cur1 != NULL && cur2 != NULL) {\n                ListNode* temp = cur1->next;\n                cur1->next = cur2->next;\n                cur2->next = temp;\n            }\n        }\n\n        return head;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    ListNode *head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(4);\n    head1->next->next->next->next = new ListNode(5);\n\n    ListNode *result1 = solution.partition(head1, 3);\n    while (result1 != NULL) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test case 2:\n    head1 = new ListNode(0);\n    head1->next = new ListNode(10);\n\n    result1 = solution.partition(head1, 1);\n    while (result1 != NULL) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test case 3:\n    head1 = new ListNode(-5);\n    head1->next = new ListNode(0);\n    head1->next->next = new ListNode(4);\n\n    result1 = solution.partition(head1, 2);\n    while (result1 != NULL) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    return 0;\n}",
  "726": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string countOfAtoms(string formula) {\n        unordered_map<string, int> map;\n        int pos = 0;\n        while (pos < formula.size()) {\n            int i = pos + 1;\n            for (; i <= formula.size() && isalnum(formula[i]); i++) {}\n            string atom = formula.substr(pos, i - pos);\n            if (i < formula.size() && formula[i] == '(') {\n                int j = i + 1;\n                for (; j < formula.size() && isdigit(formula[j]); j++) {}\n                int times = stoi(formula.substr(i + 1, j - i));\n                pos = j;\n            } else if (i < formula.size() && formula[i] == ')') {\n                return \"\";\n            } else {\n                times = 1;\n                while (i < formula.size() && isdigit(formula[i])) {\n                    i++;\n                }\n                if (i < formula.size()) {\n                    times = stoi(formula.substr(pos + 1, i - pos));\n                    pos = i;\n                } else {\n                    pos = i;\n                }\n            }\n            map[atom] += times;\n        }\n        string result;\n        for (auto &p : map) {\n            result += p.first;\n            if (p.second > 0) {\n                result += to_string(p.second);\n            }\n            result += \" \";\n        }\n        return result.substr(0, result.size() - 1);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.countOfAtoms(\"H2O\") << endl;  // Output: H2O\n    cout << solution.countOfAtoms(\"Ca(NO3)2\") << endl;  // Output: CA2 N4 O6\n    cout << solution.countOfAtoms(\"(H1O)\") << endl;  // Output: H1 O1\n\n    return 0;\n}\n```",
  "728": "```\n#include <iostream>\n#include <vector>\n\nbool isSelfDividing(int n) {\n    int temp = n;\n    while (temp != 0) {\n        int digit = temp % 10;\n        if (digit == 0 || n % digit != 0)\n            return false;\n        temp /= 10;\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> selfDividingNumbers;\n    \n    for (int i = 1; i <= 21; ++i) {\n        if (isSelfDividing(i)) {\n            selfDividingNumbers.push_back(i);\n        }\n    }\n\n    // Test Case 1\n    int testCase1[] = {3,4,5,6,7};\n    for (int num : testCase1) {\n        if (isSelfDividing(num)) {\n            std::cout << \"Self dividing number: \" << num << std::endl;\n        }\n    }\n\n    // Test Case 2\n    int testCase2 = 128;\n    if (isSelfDividing(testCase2))\n        std::cout << \"Self dividing number: \" << testCase2 << std::endl;\n\n    // Test Case 3\n    int testCase3[] = {1,7};\n    for (int num : testCase3) {\n        if (isSelfDividing(num)) {\n            std::cout << \"Self dividing number: \" << num << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "727": "```\n#include <iostream>\n#include <vector>\n\nint minWindow(std::string s, std::string t) {\n    int m = s.size(), n = t.size();\n    if (m < n) return 0;\n\n    std::vector<int> last(n + 1, -1);\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            if (s[i] == t[j]) last[j] = i;\n    \n    int minLen = INT_MAX, start = 0;\n    for (int end = 0; end <= n; ++end) {\n        if (last[end] != -1) {\n            if (end == n || last[end + 1] == -1) {\n                int len = last[end] - start + 1;\n                if (len < minLen) minLen = len, start = last[end] - end + 2;\n            }\n        }\n    }\n\n    return start > m ? 0 : start;\n}\n\nint main() {\n    std::cout << minWindow(\"ABCBA\", \"BCA\") << std::endl;  // Output: 1\n    std::cout << minWindow(\"ADOBECODEBANC\", \"ABC\") << std::endl;  // Output: 4\n    std::cout << minWindow(\"aabaacbaca\", \"abc\") << std::endl;  // Output: 3\n}\n```",
  "729": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass MyCalendar {\npublic:\n    vector<pair<int, int>> bookings;\n    \n    MyCalendar() {}\n    \n    bool book(int start, int end) {\n        for (pair<int, int> booking : bookings) {\n            if ((booking.first < end && booking.second > start)) return false;\n        }\n        bookings.push_back({start, end});\n        return true;\n    }\n};\n\nint main() {\n    MyCalendar myCalendar;\n\n    cout << boolalpha; // to print boolean values as \"true\" or \"false\"\n    \n    // Test case 1\n    cout << myCalendar.book(10, 20) << endl; // True\n    cout << myCalendar.book(15, 25) << endl; // False (booked until 23)\n    \n    // Test case 2\n    cout << myCalendar.book(0, 30) << endl; // True\n    \n    // Test case 3\n    cout << myCalendar.book(5, 7) << endl; // True\n    cout << myCalendar.book(7, 29) << endl; // False (booked until 7)\n    \n    return 0;\n}\n```",
  "730": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPalindromesFromSelction(string s) {\n        int n = s.length();\n        vector<vector<int>> dp(n, vector<int>(n));\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (s[i] == s[j] && (j - i < 3 || dp[i + 1][j - 1])) {\n                    dp[i][j] = true;\n                }\n            }\n        }\n        \n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (dp[i][j]) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s1 = \"bcbddb\";\n    cout << \"Test case 1: \" << solution.countPalindromesFromSelction(s1) << endl;\n\n    // Test case 2\n    string s2 = \"a\";\n    cout << \"Test case 2: \" << solution.countPalindromesFromSelction(s2) << endl;\n\n    // Test case 3\n    string s3 = \"aab\";\n    cout << \"Test case 3: \" << solution.countPalindromesFromSelction(s3) << endl;\n\n    return 0;\n}\n```",
  "732": "```\n#include <iostream>\n#include <vector>\n\nclass MyCalendarThree {\npublic:\n    vector<vector<int>> book;\n\n    MyCalendarThree() {}\n\n    int bookEvent(int start, int end) {\n        for (int i = start; i < end; i++) {\n            if (!book[i][0] || !book[i][1]) {\n                book[i][0] = 1;\n                book[i][1] = 1;\n                return 3;\n            }\n        }\n        book[start][0] = 1;\n        book[end - 1][1] = 1;\n        return 2;\n    }\n\n    int query(int start, int end) {\n        int res = 0, left = start, right = end;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (!book[mid][0] || !book[mid][1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n                res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    MyCalendarThree cal;\n\n    cout << cal.bookEvent(10, 20) << endl; // Output: 2\n    cout << cal.bookEvent(50, 60) << endl; // Output: 2\n    cout << cal.bookEvent(80, 100) << endl; // Output: 3\n\n    return 0;\n}\n```",
  "731": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass MyCalendar {\npublic:\n    vector<pair<int, int>> bookings;\n    \n    MyCalendar() {}\n    \n    bool book(int start, int end) {\n        for (int i = 0; i < bookings.size(); i++) {\n            if (start >= bookings[i].first && end <= bookings[i].second) return false;\n            if (start < bookings[i].second && end > bookings[i].first) return false;\n        }\n        bookings.push_back({start, end});\n        return true;\n    }\n};\n\nint main() {\n    MyCalendar myCalendar;\n\n    cout << myCalendar.book(10, 20) << endl;  // Returns true. Booked (10, 20)\n    cout << myCalendar.book(50, 60) << endl;  // Returns true. Booked (50, 60)\n    cout << myCalendar.book(80, 100) << endl; // Returns false. Busy time frame: [50, 60] is booked already.\n\n    return 0;\n}\n```",
  "734": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nbool areSentencesSimilar(string A, string B) {\n    vector<string> wordsA = split(A, \" \");\n    vector<string> wordsB = split(B, \" \");\n\n    int i = 0;\n    while (i < min(wordsA.size(), wordsB.size()) && \n           wordsA[i] == wordsB[i]) \n        i++;\n\n    if (wordsA.size() - i > 1 || wordsB.size() - i > 1) \n        return false;\n\n    if (i > 0 && wordsA[i-1] != wordsB[wordsB.size()-1]) \n        return false;\n\n    if (i < wordsA.size() && wordsA[wordsA.size()-1] != wordsB[i]) \n        return false;\n\n    return true;\n}\n\nvector<string> split(string s, string token) {\n    vector<string> result;\n    istringstream iss(s);\n    string temp;\n\n    while (getline(iss, temp, token)) {\n        result.push_back(temp);\n    }\n\n    return result;\n}\n\nint main() {\n    cout << boolalpha << areSentencesSimilar(\"si eric love it if only the order of people you invited is random then that call will end up being a free pizza for everyone but if its organic and not random then no one wants to be there, but thats life\", \"love it if only the order of people you invited is random then that call will end up being a free pizza for everyone but if its organic and not random then no one wants to be there, thats life\") << endl;\n    cout << areSentencesSimilar(\"you are given two sentences A and B can determine if they are the same excluding the order of words\", \"you are given two sentences A and B, can determine if they are the same excluding the order of words\") << endl;\n    cout << !areSentencesSimilar(\"abc cde deh jkl\", \"a b c d e f g h k l\") << endl;\n    return 0;\n}\n```",
  "733": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {\n    if (image.empty() || sr < 0 || sr >= image.size() || sc < 0 || sc >= image[0].size())\n        return -1;\n    \n    int oldColor = image[sr][sc];\n    if (oldColor == newColor)\n        return -1;\n\n    dfs(image, sr, sc, oldColor, newColor);\n    return 1;\n}\n\nvoid dfs(vector<vector<int>>& image, int r, int c, int oldColor, int newColor) {\n    if (r < 0 || r >= image.size() || c < 0 || c >= image[0].size())\n        return;\n\n    if (image[r][c] != oldColor)\n        return;\n\n    image[r][c] = newColor;\n    dfs(image, r - 1, c, oldColor, newColor);\n    dfs(image, r + 1, c, oldColor, newColor);\n    dfs(image, r, c - 1, oldColor, newColor);\n    dfs(image, r, c + 1, oldColor, newColor);\n}\n\nint main() {\n    vector<vector<int>> image1 = {{0,0,0},{0,1,1}};\n    cout << floodFill(image1, 0, 0, 2) << endl; // Output: 4\n\n    vector<vector<int>> image2 = {{0,0,0},{0,1,1},{1,1,1}};\n    cout << floodFill(image2, 1, 1, 2) << endl; // Output: 5\n\n    vector<vector<int>> image3 = {{0,0,0},{0,1,1},{1,1,1},{0,0,0}};\n    cout << floodFill(image3, 0, 0, 2) << endl; // Output: 13\n}",
  "735": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> asteroidCollision(vector<int>& asteroids) {\n        stack<int> s;\n        for (int i = 0; i < asteroids.size(); i++) {\n            if (asteroids[i] > 0) {\n                s.push(asteroids[i]);\n            } else {\n                while (!s.empty()) {\n                    int top = s.top();\n                    if (top <= -2 * asteroids[i]) { // 0 or positive\n                        s.pop();\n                        continue;\n                    } else if (top == -asteroids[i]) {\n                        s.pop();\n                        break;\n                    }\n                    if (top > asteroids[i]) {\n                        break;\n                    }\n                    s.pop();\n                }\n                if (!s.empty() && s.top() < 0) { // no collision\n                    while (!s.empty()) {\n                        s.pop();\n                    }\n                    s.push(asteroids[i]);\n                } else if (s.empty()) {\n                    s.push(asteroids[i]);\n                } else if (s.top() > 0) {\n                    s.push(asteroids[i]);\n                }\n            }\n        }\n        vector<int> result;\n        while (!s.empty()) {\n            result.push_back(s.top());\n            s.pop();\n        }\n        reverse(result.begin(), result.end());\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> asteroids1 = {10, 2, -5};\n    vector<int> expected1 = {5, 10};\n    assert(solution.asteroidCollision(asteroids1) == expected1);\n\n    // Test case 2\n    vector<int> asteroids2 = {-2, 1, 3, -4, 6, 7};\n    vector<int> expected2 = [-4, 7];\n    assert(solution.asteroidCollision(asteroids2) == expected2);\n\n    // Test case 3\n    vector<int> asteroids3 = {5, 10, -5, 2, -10, -2, 0};\n    vector<int> expected3 = [0];\n    assert(solution.asteroidCollision(asteroids3) == expected3);\n}\n```",
  "736": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nstruct TreeNode {\n    string val;\n    bool leftChild;\n    bool rightChild;\n};\n\nTreeNode* treeParse(string s) {\n    stack<TreeNode*> nodes;\n    TreeNode* root = nullptr;\n    \n    for (int i = 0; i < s.length(); ++i) {\n        if (s[i] == '(') {\n            TreeNode* node = new TreeNode();\n            node->leftChild = false;\n            node->rightChild = false;\n            nodes.push(node);\n        } else if (s[i] == ')') {\n            TreeNode* node = nodes.top();\n            nodes.pop();\n            if (!node->leftChild && !node->rightChild) {\n                root = node;\n            }\n        } else {\n            int start = i;\n            while (i < s.length() && s[i] != '(' && s[i] != ')') {\n                ++i;\n            }\n            TreeNode* node = nodes.top();\n            if (!node->leftChild) {\n                node->val += s.substr(start, i - start);\n            } else {\n                node->rightChild = true;\n                while (nodes.size() > 1) {\n                    TreeNode* node2 = nodes.top();\n                    nodes.pop();\n                    if (!node2->leftChild && !node2->rightChild) {\n                        node->val += '(' + treeParse(node2->val) + ')';\n                        delete node2;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    return root;\n}\n\nvoid printTree(TreeNode* root, string prefix = \"\") {\n    if (root != nullptr) {\n        cout << prefix << root->val << endl;\n        if (root->leftChild || root->rightChild) {\n            printTree(root->leftChild ? new TreeNode{root->val, true} : root, prefix + \"  \");\n            printTree(root->rightChild ? new TreeNode{root->val, true} : root, prefix + \"  \");\n        }\n    }\n}\n\nint main() {\n    string s1 = \"(a (b c) d)\";\n    TreeNode* tree1 = treeParse(s1);\n    printTree(tree1);\n\n    string s2 = \"(1 2 (3 (4 5)) 6)\";\n    TreeNode* tree2 = treeParse(s2);\n    printTree(tree2);\n\n    string s3 = \"(() (a b) c d)\";\n    TreeNode* tree3 = treeParse(s3);\n    printTree(tree3);\n\n    return 0;\n}\n```",
  "737": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool areSentencesSimilar(string sentence1, string sentence2) {\n        vector<string> words1 = split(sentence1), words2 = split(sentence2);\n        int i = 0;\n        for (int j = 0; j < min((int)words1.size(), (int)words2.size()); j++) {\n            if (words1[j] != words2[j])\n                break;\n            i++;\n        }\n        return i == 0 || i + 1 == words1.size() || i + 1 == words2.size();\n    }\n\nprivate:\n    vector<string> split(string sentence) {\n        vector<string> result;\n        int start = 0, end = 0;\n        while (end < sentence.size()) {\n            if (sentence[end] == ' ') {\n                result.push_back(sentence.substr(start, end - start));\n                start = end + 1;\n            }\n            end++;\n        }\n        result.push_back(sentence.substr(start));\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << (solution.areSentencesSimilar(\"great job\", \"great job very good\") ? \"True\" : \"False\") << endl; // True\n    cout << (solution.areSentencesSimilar(\"running is so easy as walking isn't\", \"running isn't so easy as walking\") ? \"True\" : \"False\") << endl; // False\n    cout << (solution.areSentencesSimilar(\"a b c\", \"like b a\") ? \"True\" : \"False\") << endl; // True\n    \n    return 0;\n}\n```",
  "738": "```\n#include <iostream>\n#include <string>\n\nbool monotoneIncreasingDigits(int N) {\n    std::string str = std::to_string(N);\n    for (int i = 0; i < str.size() - 1; i++) {\n        if (str[i] > str[i + 1]) {\n            char carry = '9' - str[i];\n            for (int j = i; j >= 0 && carry != 0; j--) {\n                str[j] = '0' + (char)(carry % 10);\n                carry /= 10;\n            }\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::cout << monotoneIncreasingDigits(12456) << std::endl; // Output: 1\n    std::cout << monotoneIncreasingDigits(13521) << std::endl; // Output: 0\n    std::cout << monotoneIncreasingDigits(11110) << std::endl; // Output: 1\n\n    return 0;\n}\n```",
  "739": "```\n#include <iostream>\n#include <vector>\n\nint dailyTemperatures(std::vector<int>& temperatures) {\n    int n = temperatures.size();\n    std::vector<int> res(n);\n    \n    for(int i=0; i<n; ++i){\n        while(i+1<n && temperatures[i]>=temperatures[i+1]){\n            i++;\n        }\n        res[i] = i+1 - i;\n    }\n    return 0;\n}\n\nint main() {\n    std::vector<int> temp1 = {73, 74, 75, 71, 69, 72, 70};\n    int res1 = dailyTemperatures(temp1);\n    std::cout << \"Test case 1: \";\n    for(int i=0; i<temp1.size(); ++i) {\n        std::cout << temp1[i] << \" \" << (res1==i+1?\"Yes\":\"No\") << std::endl;\n    }\n    \n    std::vector<int> temp2 = {30};\n    int res2 = dailyTemperatures(temp2);\n    std::cout << \"\\nTest case 2: \";\n    for(int i=0; i<temp2.size(); ++i) {\n        std::cout << temp2[i] << \" \" << (res2==1?\"Yes\":\"No\") << std::endl;\n    }\n    \n    std::vector<int> temp3 = {55,38,93,83,39,53,89,81};\n    int res3 = dailyTemperatures(temp3);\n    std::cout << \"\\nTest case 3: \";\n    for(int i=0; i<temp3.size(); ++i) {\n        std::cout << temp3[i] << \" \" << (res3==(i+1-temp3.size())?\"Yes\":\"No\") << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "740": "```\n#include <iostream>\n#include <vector>\n\nint deleteAndEarn(std::vector<int>& nums) {\n    int max_val = *std::max_element(nums.begin(), nums.end());\n    std::vector<int> dp(max_val + 1, 0);\n    \n    for (int val : nums) {\n        if (val <= max_val) {\n            dp[val] += val;\n        }\n    }\n    \n    for (int i = 2; i <= max_val; i++) {\n        dp[i] = std::max(dp[i - 1], dp[i - 1] + dp[i]);\n    }\n    \n    return dp[max_val];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> nums1 = {3,4};\n    int res1 = deleteAndEarn(nums1);\n    std::cout << \"Test case 1: \" << res1 << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {8,2,5,6,9};\n    int res2 = deleteAndEarn(nums2);\n    std::cout << \"Test case 2: \" << res2 << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {1,2,3,4,5};\n    int res3 = deleteAndEarn(nums3);\n    std::cout << \"Test case 3: \" << res3 << std::endl;\n    \n    return 0;\n}\n```",
  "741": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int cherryPickup(vector<vector<int>>& grid) {\n        const int M = grid.size();\n        const int N = grid[0].size();\n\n        vector<vector<int>> dp(M, vector<int>(N));\n\n        for (int i = 0; i < M; ++i) {\n            for (int j = 0; j < N; ++j) {\n                if (!i || !j)\n                    dp[i][j] = grid[i][j];\n                else {\n                    int val1 = grid[i - 1][j - 1], val2 = grid[i - 1][N - j];\n                    dp[i][j] = max({val1 + val2, (i > 0 && j < N) ? dp[i - 1][j - 1] : 0});\n                }\n            }\n        }\n\n        return dp[M - 1][0];\n    }\n};\n\nint main() {\n    Solution solution;\n    int result1 = solution.cherryPickup({{\n        {0, 1, 2},\n        {5, 3, 4},\n        {2, 1, 3}\n    }});\n    cout << \"Test case 1: \" << result1 << endl;\n\n    int result2 = solution.cherryPickup({{\n        {1, 0, 5, 3},\n        {5, 3, 7, 2},\n        {4, 2, 5, 3},\n        {4, 2, 3, 2}\n    }});\n    cout << \"Test case 2: \" << result2 << endl;\n\n    int result3 = solution.cherryPickup({{\n        {0, 1, 0, 3, 2},\n        {5, 3, 7, 2, 4},\n        {2, 1, 3, 6, 5},\n        {4, 2, 5, 8, 9},\n        {2, 3, 2, 4, 1}\n    }});\n    cout << \"Test case 3: \" << result3 << endl;\n\n    return 0;\n}\n\n```",
  "742": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* findClosestLeaf(TreeNode* root) {\n        // Your code here\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* node1 = new TreeNode(3);\n    node1->left = new TreeNode(5);\n    node1->right = new TreeNode(1);\n    node1->right->left = new TreeNode(4);\n    node1->right->right = new TreeNode(2);\n\n    cout << \"Test case 1: \";\n    cout << solution.findClosestLeaf(node1)->val << endl;\n\n    // Test case 2\n    TreeNode* node2 = new TreeNode(5);\n    node2->left = new TreeNode(6);\n    node2->right = new TreeNode(7);\n\n    cout << \"Test case 2: \";\n    cout << solution.findClosestLeaf(node2)->val << endl;\n\n    // Test case 3\n    TreeNode* node3 = new TreeNode(1);\n    node3->left = new TreeNode(2);\n    node3->right = new TreeNode(3);\n\n    cout << \"Test case 3: \";\n    cout << solution.findClosestLeaf(node3)->val << endl;\n\n    return 0;\n}\n```",
  "744": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    char nextGreatestLetter(vector<char>& letters, char target) {\n        for (int i = 0; i < letters.size(); ++i) {\n            if (letters[i] > target) return letters[i];\n        }\n        return letters[0];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<char> letters1 = {'c','f','j'};\n    char target1 = 'e';\n    cout << \"Test case 1: \" << solution.nextGreatestLetter(letters1, target1) << endl; // Output: f\n    \n    // Test case 2\n    vector<char> letters2 = {'a','b'];\n    char target2 = 'z';\n    cout << \"Test case 2: \" << solution.nextGreatestLetter(letters2, target2) << endl; // Output: a\n    \n    // Test case 3\n    vector<char> letters3 = {'c','d','e'};\n    char target3 = 'g';\n    cout << \"Test case 3: \" << solution.nextGreatestLetter(letters3, target3) << endl; // Output: f\n    \n    return 0;\n}\n```",
  "743": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int N, int K) {\n        vector<pair<int, int>> edges[N + 1];\n        for (auto& time : times) {\n            edges[time[0]].push_back({time[2], time[1]});\n        }\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        vector<int> dist(N + 1, numeric_limits<int>::max());\n        dist[K] = 0;\n\n        pq.push({0, K});\n        while (!pq.empty()) {\n            auto [time, node] = pq.top();\n            pq.pop();\n\n            for (auto& edge : edges[node]) {\n                int nextTime = time + edge.first;\n                if (nextTime < dist[edge.second]) {\n                    dist[edge.second] = nextTime;\n                    pq.push({nextTime, edge.second});\n                }\n            }\n        }\n\n        return dist[K];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> times1 = {{2, 1, 1}, {2, 4, 3}, {3, 2, 2}, {1, 5, 10}, {4, 5, 4}};\n    int N1 = 5;\n    int K1 = 1;\n    cout << solution.networkDelayTime(times1, N1, K1) << endl; // Output: 14\n\n    // Test case 2\n    vector<vector<int>> times2 = {{1, 2, 1}, {2, 3, 7}, {1, 3, 5}};\n    int N2 = 3;\n    int K2 = 1;\n    cout << solution.networkDelayTime(times2, N2, K2) << endl; // Output: 6\n\n    // Test case 3\n    vector<vector<int>> times3 = {{0, 1, 4}, {1, 2, 8}, {2, 0, 11}};\n    int N3 = 3;\n    int K3 = 0;\n    cout << solution.networkDelayTime(times3, N3, K3) << endl; // Output: 24\n\n    return 0;\n}\n```",
  "745": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass TrieNode {\npublic:\n    bool isEnd;\n    unordered_map<char, TrieNode*> children;\n};\n\nclass Trie {\npublic:\n    TrieNode* root = new TrieNode();\n    void insert(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children.count(c)) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n        }\n        node->isEnd = true;\n    }\n};\n\nclass WordFilter {\npublic:\n    Trie* trie;\n    WordFilter(vector<string>& words) {\n        trie = new Trie();\n        for (string word : words) {\n            int n = word.size();\n            trie->insert(word + \"#\" + word);\n        }\n    }\n    string prefixSearch(string query) {\n        string result = \"\";\n        TrieNode* node = trie->root;\n        for (char c : query) {\n            if (!node->children.count(c)) return \"\";\n            node = node->children[c];\n        }\n        for (auto& p : node->children) {\n            if (p.second->isEnd) return p.first.substr(0, p.first.size() - 1);\n        }\n        return result;\n    }\n};\n\nint main() {\n    vector<string> words = {\"apple\",\"ot\",\"app\"});\n    WordFilter w = WordFilter(words);\n\n    cout << w.prefixSearch(\"a\") << endl; // Output: \"app\"\n    cout << w.prefixSearch(\"ap\") << endl; // Output: \"app\"\n    cout << w.prefixSearch(\"o\") << endl; // Output: \"\"\n}",
  "746": "```\n#include <iostream>\n#include <vector>\n\nint minCostClimbingStairs(std::vector<int>& cost) {\n    int n = cost.size();\n    std::vector<int> dp(n);\n    dp[0] = cost[0];\n    if (n > 1) {\n        dp[1] = cost[1];\n    }\n    for (int i = 2; i < n; i++) {\n        dp[i] = std::min(dp[i-1], dp[i-2]) + cost[i];\n    }\n    return std::min(dp[n-1], dp[n-2]);\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> cost1 = {10,15,20};\n    int result1 = minCostClimbingStairs(cost1);\n    if (result1 == 15) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 15, Got: \" << result1 << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> cost2 = {1,100,1,1,1};\n    int result2 = minCostClimbingStairs(cost2);\n    if (result2 == 6) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 6, Got: \" << result2 << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> cost3 = [5, 1, 1, 1, 6];\n    int result3 = minCostClimbingStairs(cost3);\n    if (result3 == 7) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 7, Got: \" << result3 << std::endl;\n    }\n\n    return 0;\n}",
  "747": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint dominantIndex(std::vector<int>& nums) {\n    int maxNum = *std::max_element(nums.begin(), nums.end());\n    int count = 0;\n    for (const auto& num : nums) {\n        if (num == maxNum) {\n            count++;\n        } else if (count > 0 && num > maxNum / 2) {\n            return -1;\n        }\n    }\n    return count == 1 ? 0 : -1;\n}\n\nint main() {\n    std::vector<int> test1 = {3, 6, 3};\n    std::cout << dominantIndex(test1) << std::endl;  // Expected output: 1\n\n    std::vector<int> test2 = [5, 9, 8, 1];\n    std::cout << dominantIndex(test2) << std::endl;  // Expected output: -1\n\n    std::vector<int> test3 = {1, 2, 3};\n    std::cout << dominantIndex(test3) << std::endl;  // Expected output: -1\n\n    return 0;\n}\n```",
  "748": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string shortestCompletingWord(string left, vector<string>& dict) {\n        unordered_map<char, int> map;\n        for (char c : left) {\n            map[c]++;\n        }\n        for (string word : dict) {\n            if (word.length() > left.length()) continue;\n            unordered_map<char, int> tempMap = map;\n            bool flag = true;\n            for (char c : word) {\n                tempMap[c]--;\n                if (tempMap[c] < 0) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag && word.length() == left.length()) return word;\n        }\n        return \"\";\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.shortestCompletingWord(\"1x\", {\"caaat\",\"apple\",\"eyewear\"}) << endl;  // Output: \"caat\"\n    cout << solution.shortestCompletingWord(\"6zaaxaybvc\", {\"prefecture\",\"mobile\",\"porcelain\",\"geeks\"}) << endl;  // Output: \"geeks\"\n    cout << solution.shortestCompletingWord(\"\", {\"cool\",\"lock\",\"keep\"}) << endl;  // Output: \"cool\"\n    return 0;\n}\n```",
  "749": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int containVirus(vector<vector<int>>& grid) {\n        if (grid.empty()) return 0;\n        \n        int n = grid.size();\n        int m = grid[0].size();\n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        function<void(int, int)> dfs = [&](int i, int j) {\n            if (i < 0 || i >= n || j < 0 || j >= m || grid[i][j] != 2)\n                return;\n            \n            grid[i][j] = 3; // mark as visited\n            \n            for (auto dir : directions) {\n                int ni = i + dir.first, nj = j + dir.second;\n                \n                if (ni < 0 || ni >= n || nj < 0 || nj >= m)\n                    continue;\n                \n                if (grid[ni][nj] == 2)\n                    dfs(ni, nj); // infect neighbor\n            }\n        };\n        \n        int infected = 0, spread = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (grid[i][j] == 2) { // find initial virus\n                    dfs(i, j);\n                    ++infected;\n                }\n            }\n        }\n        \n        return infected + spread;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> grid1 = {{0, 1, 0, 0, 0},\n                                 {1, 1, 0, 0, 0},\n                                 {0, 0, 1, 0, 0},\n                                 {0, 0, 0, 1, 0}};\n    cout << solution.containVirus(grid1) << endl; // Output: 4\n\n    vector<vector<int>> grid2 = {{0, 0, 0, 0, 0},\n                                 {0, 0, 0, 0, 0},\n                                 {0, 0, 1, 1, 1},\n                                 {0, 0, 0, 1, 0}};\n    cout << solution.containVirus(grid2) << endl; // Output: 8\n\n    vector<vector<int>> grid3 = {{0, 0, 0, 0, 0},\n                                 {0, 0, 0, 0, 0},\n                                 {0, 1, 1, 1, 1},\n                                 {0, 0, 0, 0, 0}};\n    cout << solution.containVirus(grid3) << endl; // Output: 4\n\n    return 0;\n}\n```",
  "750": "```\n#include <iostream>\n#include <vector>\n\nint countCornerRectangles(std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    if (n == 0) return 0;\n    \n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n - 1; ++j) {\n            int ones = 0, twos = 0;\n            for (int k = j + 1; k < n; ++k) {\n                if (grid[i][k] == 1) ones++;\n                if (grid[k][j] == 1 && grid[i][k] == 1) twos++;\n            }\n            res += twos * (ones - 1);\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::vector<int>> grid1 = {{1,0,0},\n                                            {1,1,0},\n                                            {1,1,1}};\n    std::cout << countCornerRectangles(grid1) << std::endl;  // Output: 6\n\n    // Test Case 2\n    std::vector<std::vector<int>> grid2 = {{1,0,0,1},\n                                            {1,1,1,1},\n                                            {1,1,1,1}};\n    std::cout << countCornerRectangles(grid2) << std::endl;  // Output: 5\n\n    // Test Case 3\n    std::vector<std::vector<int>> grid3 = {{1,0,0,0},\n                                            {1,1,1,0},\n                                            {1,1,1,1}};\n    std::cout << countCornerRectangles(grid3) << std::endl;  // Output: 4\n\n    return 0;\n}",
  "751": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string defangIPaddr(string address) {\n        for(int i = 0; i < address.length(); i++) {\n            if(address[i] == '.') {\n                address.insert(i+1, \"[.\");\n                i += 2;\n            }\n        }\n        return address + \"]\";\n    }\n};\n\nint main() {\n    Solution solution;\n\n    string test1 = \"1.1.1.1\";\n    cout << \"Test case 1: \" << solution.defangIPaddr(test1) << endl;  // Output: \"1[.]1[.]1[.]1]\"\n\n    string test2 = \"255.100.500.0\";\n    cout << \"Test case 2: \" << solution.defangIPaddr(test2) << endl;  // Output: \"255.[.]100.[.]500.[.]0]\"\n\n    string test3 = \"123.456.789.012\";\n    cout << \"Test case 3: \" << solution.defangIPaddr(test3) << endl;  // Output: \"123.[.]456.[.]789.[.]012]\"\n\n    return 0;\n}\n```",
  "752": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int openLock(vector<string>& deadends, string target) {\n        vector<string> dirs = {\"0001\", \"0010\", \"0100\", \"1000\"};\n        queue<pair<string, int>> q;\n        set<string> visited;\n        for (int i = 0; i < deadends.size(); ++i) {\n            visited.insert(deadends[i]);\n        }\n        if (visited.count(target)) return -1;\n        q.push({ \"0000\", 0 });\n        while (!q.empty()) {\n            string s = q.front().first;\n            int step = q.front().second;\n            q.pop();\n            if (s == target) return step;\n            for (int i = 0; i < 4; ++i) {\n                for (char c : dirs[i]) {\n                    string ns = s;\n                    char nc = c == '0' ? '1' : '0';\n                    replace(ns.begin(), ns.end(), nc, c);\n                    if (!visited.count(ns)) q.push({ ns, step + 1 });\n                }\n            }\n        }\n        return -1;\n    }\n};\n\nint main() {\n    Solution s;\n    vector<string> deadends = {\"0009\"};\n    string target = \"8888\";\n    cout << s.openLock(deadends, target) << endl;\n\n    deadends.clear();\n    target = \"1020\";\n    cout << s.openLock(deadends, target) << endl;\n\n    deadends = {\"0201\", \"0101\", \"0301\"};\n    target = \"1111\";\n    cout << s.openLock(deadends, target) << endl;\n    \n    return 0;\n}\n```",
  "753": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> crackSafe(int n) {\n        string res = \"0\";\n        for (int i = 1; i <= pow(10, n - 1); i++) {\n            res += to_string(i);\n        }\n        string temp;\n        for (int i = 0; i < pow(10, n); i++) {\n            temp += '0' + (i % 3);\n        }\n        res += temp;\n        return vector<int>(begin(res), end(res));\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n = 1;\n    vector<int> expected = { \"0\" };\n    if (solution.crackSafe(n) != expected)\n        cout << \"Test case 1 failed.\" << endl;\n\n    // Test case 2\n    n = 2;\n    expected = { \"0110111\" };\n    if (solution.crackSafe(n) != expected)\n        cout << \"Test case 2 failed.\" << endl;\n\n    // Test case 3\n    n = 3;\n    expected = { \"10101010101\" };\n    if (solution.crackSafe(n) != expected)\n        cout << \"Test case 3 failed.\" << endl;\n\n    return 0;\n}",
  "754": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int reachNumber(int target) {\n        int step = 0;\n        while (target > (step + step)) {\n            step++;\n        }\n        return step;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << solution.reachNumber(2) << endl; // Expected output: 3\n    cout << \"Test case 2: \" << solution.reachNumber(5) << endl; // Expected output: 6\n    cout << \"Test case 3: \" << solution.reachNumber(13) << endl; // Expected output: 6\n\n    return 0;\n}\n```",
  "755": "```\n#include <iostream>\n#include <vector>\n\nint trap(const std::vector<int>& height) {\n    int n = height.size();\n    int left_max[n], right_max[n];\n    left_max[0] = height[0];\n    for (int i = 1; i < n; i++) {\n        left_max[i] = std::max(left_max[i - 1], height[i]);\n    }\n    right_max[n - 1] = height[n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        right_max[i] = std::max(right_max[i + 1], height[i]);\n    }\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        res += std::min(left_max[i], right_max[i]) - height[i];\n    }\n    return res;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> height1 = {2, 1, 3};\n    std::cout << \"Test case 1: \" << trap(height1) << std::endl;\n\n    // Test case 2\n    std::vector<int> height2 = {4, 2, 0, 3, 2, 5};\n    std::cout << \"Test case 2: \" << trap(height2) << std::endl;\n\n    // Test case 3\n    std::vector<int> height3 = {1, 2, 3, 4, 5};\n    std::cout << \"Test case 3: \" << trap(height3) << std::endl;\n    \n    return 0;\n}",
  "756": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> pyramidTransition(int bottom, vector<vector<int>>& allowed) {\n        int n = (1 << (int)log2(bottom)) - 1;\n        vector<int> res(n);\n        for (int i = 0; i < n; i++) {\n            res[i] = -1;\n        }\n        queue<pair<int, int>> q;\n        q.push({0, -1});\n        while (!q.empty()) {\n            auto [i, parent] = q.front();\n            q.pop();\n            for (auto &x : allowed) {\n                if (res[x[0]] == x[1]) {\n                    if (parent != -1) {\n                        res[i] = x[0];\n                        q.push({i + 1, i});\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    int bottom1 = 3;\n    vector<vector<int>> allowed1 = {{2, 3}, {1, 3}};\n    vector<int> res1 = solution.pyramidTransition(bottom1, allowed1);\n    for (auto &x : res1) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    int bottom2 = 4;\n    vector<vector<int>> allowed2 = {{1, 2}, {2, 3}};\n    vector<int> res2 = solution.pyramidTransition(bottom2, allowed2);\n    for (auto &x : res2) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    int bottom3 = 5;\n    vector<vector<int>> allowed3 = {{1, 4}, {2, 3}};\n    vector<int> res3 = solution.pyramidTransition(bottom3, allowed3);\n    for (auto &x : res3) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "757": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint intersectionSize(std::vector<std::vector<int>>& A) {\n    int n = A.size();\n    std::sort(A.begin(), A.end());\n    \n    int ans = 0;\n    for (int i = 0; i < n - 1; ++i) {\n        int j = i + 1;\n        while (j < n && A[i].back() >= A[j].front()) {\n            if (!std::includes(A[i].begin(), A[i].end(), A[j].begin(), A[j].end())) {\n                ans += A[i].size();\n                break;\n            } else if (A[i].back() > A[j].front()) {\n                j++;\n            } else {\n                i = j - 1;\n                break;\n            }\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    std::vector<std::vector<int>> A1 = {{1, 3}, {2, 4}};\n    std::cout << \"Test case 1: \" << intersectionSize(A1) << std::endl;\n\n    std::vector<std::vector<int>> A2 = {{1, 2}, {2, 5}, {3, 7}};\n    std::cout << \"Test case 2: \" << intersectionSize(A2) << std::endl;\n\n    std::vector<std::vector<int>> A3 = {{1, 2, 3}, {3, 4, 5}};\n    std::cout << \"Test case 3: \" << intersectionSize(A3) << std::endl;\n\n    return 0;\n}\n```",
  "758": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nclass Solution {\npublic:\n    std::string boldWords(std::string s, const std::vector<std::string>& words) {\n        if (s.empty() || words.empty()) return s;\n        \n        int n = s.size();\n        bool found[1024][1024]; // assuming max 1000 length of word\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) \n                found[i][j] = false;\n        \n        int m = words.size();\n        for (int i = 0; i < m; ++i) {\n            std::string word = words[i];\n            int pos = s.find(word);\n            while (pos != -1) {\n                int j = pos + word.size() - 1;\n                for (int k = pos; k <= j; ++k)\n                    found[k][j] = true;\n                pos = s.find(word, j + 1);\n            }\n        }\n        \n        std::string result = \"\";\n        bool inWord = false;\n        for (int i = 0; i < n; ++i) {\n            if (found[i][n - 1]) inWord = true;\n            if (inWord)\n                result += \"<b>\" + s.substr(i, found[i][n - 1] ? s.find(\" \", i) == -1 ? string::npos : s.find(\" \", i) : i + word.size() - 1) + \"</b>\";\n            else\n                result += s.substr(i, found[i][n - 1] ? \" \" : s.find(\" \", i) != -1 ? s.find(\" \", i) - i : string::npos);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::string> words1 = {\"a\", \"b\", \"c\"};\n    std::cout << solution.boldWords(\"he lllo worl d\", words1) << std::endl; // Output: \"<b>he</b> <b>ll</b><b>o </b><b>worl</b>d\"\n\n    // Test Case 2\n    std::vector<std::string> words2 = {\"bob\"};\n    std::cout << solution.boldWords(\"Hello world! bob is great.\", words2) << std::endl; // Output: \"Hello world! <b>bob</b> is <b>great.</b>\"\n\n    // Test Case 3\n    std::vector<std::string> words3 = {\"hi\", \"i\"};\n    std::cout << solution.boldWords(\"hi i am a student. hi i like to code.\", words3) << std::endl; // Output: \"<b>hi</b> <b>i</b> am a student. <b>hi</b> <b>i</b> like to <b>code.</b>\"\n    \n    return 0;\n}\n```",
  "759": "```\n#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> employeeFreeTime(vector<vector<int>>& workTimes) {\n        map<int, int> timeMap;\n        for (const auto& times : workTimes) {\n            for (int i = 0; i < times.size() - 1; ++i) {\n                timeMap[make_pair(times[i], 0)] = 0;\n                timeMap[make_pair(times[i + 1], 1)] = 0;\n            }\n        }\n        \n        vector<vector<int>> result;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        for (const auto& pair : timeMap) {\n            pq.push(pair);\n        }\n        \n        int prevTime = -1;\n        while (!pq.empty()) {\n            int currentTime = pq.top().first;\n            bool isStart = pq.top().second;\n            pq.pop();\n            \n            if (prevTime != -1 && isStart) {\n                result.push_back({prevTime, currentTime});\n            }\n            \n            prevTime = currentTime;\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> workTimes1 = {{0, 3}, {4, 24}};\n    vector<vector<int>> expected1 = {{4, 7}, {16, 23}};\n    assert(solution.employeeFreeTime(workTimes1).size() == expected1.size());\n    for (int i = 0; i < workTimes1.size(); ++i) {\n        for (int j = 0; j < workTimes1[i].size(); ++j) {\n            if (workTimes1[i][j] != expected1[i][j]) {\n                cout << \"Test Case 1 failed: Expected \" << expected1[i][j] << \", but got \" << workTimes1[i][j] << endl;\n                return 1;\n            }\n        }\n    }\n\n    // Test Case 2\n    vector<vector<int>> workTimes2 = {{0, 10}, {12, 25}};\n    vector<vector<int>> expected2 = {{24, 25}};\n    assert(solution.employeeFreeTime(workTimes2).size() == expected2.size());\n    for (int i = 0; i < workTimes2.size(); ++i) {\n        for (int j = 0; j < workTimes2[i].size(); ++j) {\n            if (workTimes2[i][j] != expected2[i][j]) {\n                cout << \"Test Case 2 failed: Expected \" << expected2[i][j] << \", but got \" << workTimes2[i][j] << endl;\n                return 1;\n            }\n        }\n    }\n\n    // Test Case 3\n    vector<vector<int>> workTimes3 = {{1, 2}, {5, 6}};\n    vector<vector<int>> expected3 = {};\n    assert(solution.employeeFreeTime(workTimes3).size() == expected3.size());\n    for (int i = 0; i < workTimes3.size(); ++i) {\n        for (int j = 0; j < workTimes3[i].size(); ++j) {\n            if (workTimes3[i][j] != expected3[i][j]) {\n                cout << \"Test Case 3 failed: Expected \" << expected3[i][j] << \", but got \" << workTimes3[i][j] << endl;\n                return 1;\n            }\n        }\n    }\n\n    cout << \"All test cases passed.\" << endl;\n\n    return 0;\n}\n```",
  "760": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nunordered_map<string, vector<int>> findAnagramMappings(string currentString, string targetString) {\n    unordered_map<char, int> targetMap;\n    for (int i = 0; i < targetString.length(); i++) {\n        targetMap[targetString[i]] = i;\n    }\n\n    unordered_map<char, int> currentMap;\n    vector<int> result;\n\n    for (int i = 0; i < currentString.length(); i++) {\n        char c = currentString[i];\n        if (targetMap.find(c) != targetMap.end()) {\n            int index = targetMap[c];\n            currentMap[c] = i;\n            result.push_back(index);\n        }\n    }\n\n    return {result};\n}\n\nint main() {\n    string test1Current = \"abc\";\n    string test1Target = \"cba\";\n    for (auto& mapping : findAnagramMappings(test1Current, test1Target)) {\n        cout << mapping << \" \";\n    }\n    cout << endl;\n\n    string test2Current = \"word\";\n    string test2Target = \"ward\";\n    for (auto& mapping : findAnagramMappings(test2Current, test2Target)) {\n        cout << mapping << \" \";\n    }\n    cout << endl;\n\n    string test3Current = \"abcba\";\n    string test3Target = \"abacb\";\n    for (auto& mapping : findAnagramMappings(test3Current, test3Target)) {\n        cout << mapping << \" \";\n    }\n    cout << endl;\n}\n```",
  "761": "```\n#include <iostream>\n#include <string>\n\nbool specialString(std::string s) {\n    int max0 = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == '1') {\n            max0 = 0;\n        } else {\n            max0++;\n            if (max0 > i) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::cout << specialString(\"011101\") << std::endl; // Expected: true\n    std::cout << specialString(\"0001111\") << std::endl; // Expected: false\n    std::cout << specialString(\"10001111\") << std::endl; // Expected: true\n    return 0;\n}\n```",
  "762": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPrime(setBits);\n};\n\nint Solution::countPrime(int n) {\n    int count = 0;\n    for (int i = 0; i < (1 << n); i++) {\n        if (isPrime(i)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.countPrime(5) << endl;\n    // Expected output: 8\n\n    cout << \"Test Case 2: \" << solution.countPrime(3) << endl;\n    // Expected output: 4\n\n    cout << \"Test Case 3: \" << solution.countPrime(10) << endl;\n    // Expected output: 745\n\n    return 0;\n}\n```",
  "763": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint partitionLabels(std::string S) {\n    int n = S.size();\n    int last[n];\n    for (int i = 0; i < n; i++) {\n        last[i] = i;\n    }\n    \n    int anchor = 0, end = 0;\n    for (int i = 0; i < n; i++) {\n        end = std::max(end, last[S[i] - 'a']);\n        \n        if (i == end) {\n            anchor = i;\n        }\n    }\n    \n    int result = 0, j = anchor;\n    while (j <= end) {\n        result = std::max(result, j - anchor + 1);\n        j++;\n    }\n    \n    return result;\n}\n\nint main() {\n    // Test case 1\n    std::string S1 = \"ababcbacadefegdehijhklij\";\n    int testResult1 = partitionLabels(S1);\n    if (testResult1 == 9) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected result: 9, Actual result: \" << testResult1 << std::endl;\n    }\n    \n    // Test case 2\n    std::string S2 = \"a\";\n    int testResult2 = partitionLabels(S2);\n    if (testResult2 == 1) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected result: 1, Actual result: \" << testResult2 << std::endl;\n    }\n    \n    // Test case 3\n    std::string S3 = \"aaa\";\n    int testResult3 = partitionLabels(S3);\n    if (testResult3 == 3) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected result: 3, Actual result: \" << testResult3 << std::endl;\n    }\n    \n    return 0;\n}",
  "764": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint largestPlusSign(vector<vector<char>>& grid) {\n    int m = grid.size(), n = grid[0].size();\n    vector<vector<int>> up(m, vector<int>(n)), down(m, vector<int>(n)), left(m, vector<int>(n)), right(m, vector<int>(n));\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == '+') {\n                up[i][j] = down[i][j] = left[i][j] = right[i][j] = 1;\n            } else if (grid[i][j] == 'T') {\n                up[i][j] = 0; down[i][j] = 0; left[i][j] = 1; right[i][j] = 1;\n            } else if (grid[i][j] == 'L') {\n                up[i][j] = 0; down[i][j] = 0; left[i][j] = 0; right[i][j] = 1;\n            } else if (grid[i][j] == 'R') {\n                up[i][j] = 0; down[i][j] = 0; left[i][j] = 1; right[i][j] = 0;\n            }\n        }\n    }\n\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == '+') {\n                up[i][j] += (i > 0 ? up[i - 1][j] : 0);\n                down[i][j] += (i < m - 1 ? down[i + 1][j] : 0);\n                left[i][j] += (j > 0 ? left[i][j - 1] : 0);\n                right[i][j] += (j < n - 1 ? right[i][j + 1] : 0);\n            }\n        }\n    }\n\n    int maxSize = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == '+') {\n                maxSize = max(maxSize, min(up[i][j], down[i][j]) + min(left[i][j], right[i][j]));\n            }\n        }\n    }\n\n    return maxSize;\n}\n\nint main() {\n    vector<vector<char>> grid1({{'E', 'W', '+'}, {'#', '#', '#'}, {'T', '+', 'R'}});\n    cout << largestPlusSign(grid1) << endl;\n\n    vector<vector<char>> grid2({{'+', '+', '+'}, {'+', 'L', 'R'}, {'+', 'T', 'R'}});\n\n    cout << largestPlusSign(grid2) << endl;\n\n    vector<vector<char>> grid3({{'E', '#', '#'}, {'W', '#', '#'}, {'+', '#', '#'}});\n    cout << largestPlusSign(grid3) << endl;\n\n    return 0;\n}\n```",
  "765": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCostToHireTeam(vector<vector<int>>& cost) {\n        int n = cost.size();\n        vector<int> team(n);\n        for (int i = 0; i < n; i++) {\n            team[i] = cost[i][0];\n        }\n        sort(team.begin(), team.end());\n        \n        int totalCost = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 1) {\n                totalCost += team[n - i - 1];\n            } else {\n                totalCost += team[i];\n            }\n        }\n        return totalCost;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> cost1 = {{16, 8}, {6, 3}, {4, 2}};\n    cout << \"Test Case 1: \" << solution.minCostToHireTeam(cost1) << endl;  // Output: 21\n\n    vector<vector<int>> cost2 = {{1, 5}, {2, 3}, {7, 6}};\n    cout << \"Test Case 2: \" << solution.minCostToHireTeam(cost2) << endl;  // Output: 8\n\n    vector<vector<int>> cost3 = {{10, 20}, {30, 40}};\n    cout << \"Test Case 3: \" << solution.minCostToHireTeam(cost3) << endl;  // Output: 50\n\n    return 0;\n}\n```",
  "766": "```\n#include <iostream>\n#include <vector>\n\nbool isToeplitzMatrix(std::vector<std::vector<int>>& matrix) {\n    int rows = matrix.size();\n    if (rows == 0) return true;\n\n    for (int i = 1; i < rows; ++i) {\n        for (int j = 1; j < matrix[0].size(); ++j) {\n            if (matrix[i][j] != matrix[i-1][j-1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::vector<int>> testMatrix1 = {{1, 2}, {4, 3}};\n    std::cout << \"Test Case 1: \" << (isToeplitzMatrix(testMatrix1) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<std::vector<int>> testMatrix2 = {{1, 2, 3}, {5, 6, 9}, {10, 11, 12}};\n    std::cout << \"Test Case 2: \" << (isToeplitzMatrix(testMatrix2) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<std::vector<int>> testMatrix3 = {{1, 2, 3}, {4, 5, 6}};\n    std::cout << \"Test Case 3: \" << (isToeplitzMatrix(testMatrix3) ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n```",
  "767": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstring reorganizeString(string s) {\n    vector<int> freq(26, 0);\n    for (char c : s) {\n        freq[c - 'a']++;\n    }\n    priority_queue<pair<int, char>> pq;\n    for (int i = 0; i < 26; i++) {\n        if (freq[i]) {\n            pq.push({freq[i], 'a' + i});\n        }\n    }\n    string res;\n    while (!pq.empty()) {\n        pair<int, char> p1 = pq.top();\n        pq.pop();\n        int n = p1.first;\n        char c = p1.second;\n        if (p1.first > 1) {\n            for (int j = 0; j < n - 1; j++) {\n                res += c;\n            }\n            pair<int, char> p2 = pq.top();\n            pq.pop();\n            res += p2.second;\n            pq.push({p2.first - 1, p2.second});\n        } else {\n            for (int i = 0; i < n; i++) {\n                res += c;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    cout << reorganizeString(\"aaabbbcc\") << endl; // aabbccc\n    cout << reorganizeString(\"aabbaa\") << endl; // baaba\n    cout << reorganizeString(\"aaa\") << endl; // aba\n\n    return 0;\n}\n```",
  "768": "```\n#include <iostream>\n#include <vector>\n\nint maxChunksToMakeSorted(std::vector<int>& arr) {\n    int res = 0;\n    int lastBroken = -1;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] != i + 1) {\n            if (i > lastBroken) {\n                res++;\n                lastBroken = i;\n            }\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<int> arr1({1,2,3,4,5});\n    std::cout << \"arr1: \" << maxChunksToMakeSorted(arr1) << std::endl;\n\n    std::vector<int> arr2({1,3,5,4,2});\n    std::cout << \"arr2: \" << maxChunksToMakeSorted(arr2) << std::endl;\n\n    std::vector<int> arr3({1,17,5,3,16,8,20});\n    std::cout << \"arr3: \" << maxChunksToMakeSorted(arr3) << std::endl;\n\n    return 0;\n}\n```",
  "769": "```\n#include <iostream>\n#include <vector>\n\nint maxChunksToMakeSorted(std::vector<int>& arr) {\n    int n = arr.size();\n    int res = 0;\n    int lastUnstableIndex = -1;\n\n    for (int i = 0; i < n; i++) {\n        if (i > 0 && arr[i] <= arr[i-1]) {\n            res += ((i-1) - lastUnstableIndex);\n            lastUnstableIndex = i;\n        }\n    }\n\n    return res + ((n-1) - lastUnstableIndex);\n}\n\nint main() {\n    std::vector<int> arr1({5, 4, 3, 2, 1});\n    std::cout << \"Array 1: \" << maxChunksToMakeSorted(arr1) << std::endl;\n\n    std::vector<int> arr2({2, 1, 3, 3, 2});\n    std::cout << \"Array 2: \" << maxChunksToMakeSorted(arr2) << std::endl;\n\n    std::vector<int> arr3({1, 3, 3, 2, 7, 5});\n    std::cout << \"Array 3: \" << maxChunksToMakeSorted(arr3) << std::endl;\n\n    return 0;\n}\n```",
  "771": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nint numJewelsInStones(std::string J, std::string S) {\n    int count = 0;\n    for (char c : S) {\n        if (std::count(J.begin(), J.end(), c) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::cout << numJewelsInStones(\"aA\", \"aAAbbbb\") << std::endl; // Output: 3\n    std::cout << numJewelsInStones(\"z\", \"ZZPz\") << std::endl; // Output: 2\n    std::cout << numJewelsInStones(\"aa\", \"aaa\") << std::endl; // Output: 0\n    \n    return 0;\n}\n```",
  "770": "```\n#include <iostream>\n#include <string>\n#include <stack>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int calculate(string s) {\n        stack<char> ops;\n        stack<int> nums;\n        int res = 0, num = 0, sign = 1;\n        \n        for (int i = 0; i < s.size(); ++i) {\n            if (isdigit(s[i])) {\n                num = num * 10 + (s[i] - '0');\n                sign = 1;\n            } else if (s[i] == '+') {\n                res += sign * num;\n                num = 0;\n                sign = 1;\n            } else if (s[i] == '-') {\n                res += sign * num;\n                num = 0;\n                sign = -1;\n            } else if (s[i] == '(') {\n                ops.push(s[i]);\n            } else if (s[i] == ')') {\n                while (ops.top() != '(') {\n                    char op = ops.top(); ops.pop();\n                    int n = nums.top(); nums.pop();\n                    nums.push(res);\n                    res = 0;\n                    sign = 1;\n                    \n                    if (op == '+')\n                        res += sign * n;\n                    else\n                        res -= sign * n;\n                }\n                ops.pop();\n            } else {\n                while (!ops.empty() && ops.top() != '(') {\n                    char op = ops.top(); ops.pop();\n                    int n = nums.top(); nums.push(res);\n                    res = 0;\n                    sign = 1;\n                    \n                    if (op == '+')\n                        res += sign * n;\n                    else\n                        res -= sign * n;\n                }\n                \n                if (s[i] == '*') {\n                    while (!ops.empty() && ops.top() != '(') {\n                        char op = ops.top(); ops.pop();\n                        int n = nums.top(); nums.push(res);\n                        res = 0;\n                        sign = 1;\n                        \n                        if (op == '+')\n                            res += sign * n;\n                        else\n                            res -= sign * n;\n                    }\n                } else if (s[i] == '/') {\n                    while (!ops.empty() && ops.top() != '(') {\n                        char op = ops.top(); ops.pop();\n                        int n = nums.top(); nums.push(res);\n                        res = 0;\n                        sign = 1;\n                        \n                        if (op == '+')\n                            res += sign * n;\n                        else\n                            res -= sign * n;\n                    }\n                }\n                \n                ops.push(s[i]);\n            }\n        }\n        \n        while (!ops.empty()) {\n            char op = ops.top(); ops.pop();\n            int n = nums.top(); nums.pop();\n            nums.push(res);\n            res = 0;\n            sign = 1;\n            \n            if (op == '+')\n                res += sign * n;\n            else\n                res -= sign * n;\n        }\n        \n        return res + sign * num;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.calculate(\"2+3*4\") << endl; // Output: 14\n    cout << \"Test case 2: \" << solution.calculate(\"(1+(4+5+2)-3)+((8-2+2)+9)\") << endl; // Output: 33\n    cout << \"Test case 3: \" << solution.calculate(\"14-3/2\") << endl; // Output: 13\n\n    return 0;\n}\n```",
  "772": "```\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nclass Solution {\npublic:\n    int evaluateExpression(string s) {\n        stack<int> st;\n        for (int i = 0; i < s.size(); ++i) {\n            if (isdigit(s[i])) {\n                int num = 0;\n                while (i < s.size() && isdigit(s[i])) {\n                    num = num * 10 + s[i] - '0';\n                    ++i;\n                }\n                st.push(num);\n            } else if (s[i] == '(') {\n                int j = i;\n                for (++j; j < s.size(); ++j) {\n                    if (s[j] == '(') {\n                        ++j;\n                        break;\n                    }\n                }\n                string subExpr = s.substr(i + 1, j - i - 1);\n                st.push(evaluateExpression(subExpr));\n                i = j - 1;\n            } else if (s[i] == ')') {\n                int val = st.top();\n                st.pop();\n                while (!st.empty() && st.top() != '(') {\n                    val += st.top();\n                    st.pop();\n                }\n                if (!st.empty()) {\n                    st.pop(); // remove the '('\n                }\n            } else {\n                int op = s[i] - '+';\n                if (op == '-') op = '-';\n                while (!st.empty() && st.top() != '(') {\n                    val += st.top();\n                    st.pop();\n                }\n                st.push(val);\n                while (!st.empty() && st.top() != '(') {\n                    st.pop();\n                }\n                st.push(op);\n            }\n        }\n        int res = 0;\n        while (!st.empty()) {\n            if (st.top() == '+') {\n                res += st.pop();\n            } else {\n                res -= st.pop();\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.evaluateExpression(\"1 + 1\") << endl; // Output: 2\n    cout << solution.evaluateExpression(\"(3+5)\") << endl; // Output: 8\n    cout << solution.evaluateExpression(\"(0)\" << endl; // Output: 0\n    return 0;\n}\n```",
  "773": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int slidingPuzzle(vector<vector<int>>& board) {\n        int m = board.size();\n        int n = board[0].size();\n        int target = (m * n - 1) % (m * n);\n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        queue<pair<vector<vector<int>>, int>> q;\n        q.push({board, target});\n        unordered_set<string> visited;\n        while (!q.empty()) {\n            vector<vector<int>> curr = q.front().first;\n            int move = q.front().second;\n            q.pop();\n            \n            if (move == -1) return 0; // found the solution\n            \n            for (int i = 0; i < m; ++i) {\n                for (int j = 0; j < n; ++j) {\n                    if (curr[i][j] == 0) {\n                        for (auto& dir : directions) {\n                            int ni = i + dir.first;\n                            int nj = j + dir.second;\n                            \n                            if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\n                                vector<vector<int>> nextBoard(curr);\n                                swap(nextBoard[i][j], nextBoard[ni][nj]);\n                                string s = \"\";\n                                for (int k = 0; k < m * n; ++k) {\n                                    if (k % m == 0) s += \"\\n\";\n                                    s += to_string(nextBoard[k / m][k % m]) + \" \";\n                                }\n                                if (!visited.count(s)) {\n                                    q.push({nextBoard, move + 1});\n                                    visited.insert(s);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return -1; // no solution\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1:\n    vector<vector<int>> board1 = {{3,2,0},{5,4,1}};\n    cout << \"Test case 1: \" << solution.slidingPuzzle(board1) << endl;\n    \n    // Test case 2:\n    vector<vector<int>> board2 = {{1,2,3},{4,0,5}};\n    cout << \"Test case 2: \" << solution.slidingPuzzle(board2) << endl;\n    \n    // Test case 3:\n    vector<vector<int>> board3 = {{1,2,3},{6,7,8},{4,5,0}};\n    cout << \"Test case 3: \" << solution.slidingPuzzle(board3) << endl;\n    \n    return 0;\n}\n```",
  "774": "```\n#include <iostream>\n#include <vector>\n\nint minmaxGasDist(std::vector<int>& stations) {\n    int n = stations.size();\n    int res = INT_MAX;\n    for (int i = 0; i < n - 1; ++i) {\n        int dist = (stations[i + 1] - stations[i]) / (n - 1);\n        res = std::min(res, dist);\n    }\n    return res;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<int> test1 = {10, 3, 9};\n    std::cout << \"Test Case 1: \" << minmaxGasDist(test1) << std::endl;\n\n    // Test Case 2\n    std::vector<int> test2 = {7, 8, 12, 8, 7};\n    std::cout << \"Test Case 2: \" << minmaxGasDist(test2) << std::endl;\n\n    // Test Case 3\n    std::vector<int> test3 = {23, 14, 4, 11, 21, 6, 18, 1, 16};\n    std::cout << \"Test Case 3: \" << minmaxGasDist(test3) << std::endl;\n\n    return 0;\n}\n```",
  "775": "```\n#include <iostream>\n#include <vector>\n\nint findGlobalAndLocalInversions(std::vector<int>& nums) {\n    int globalInversions = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        int k = i - 1;\n        while (k >= 0 && nums[i] < nums[k]) {\n            swap(nums[i], nums[k]);\n            k--;\n            globalInversions++;\n        }\n    }\n    return globalInversions;\n}\n\nint main() {\n    std::vector<int> test1 = {2,3,1};\n    int result1 = findGlobalAndLocalInversions(test1);\n    std::cout << \"Test 1: \" << result1 << std::endl;\n\n    std::vector<int> test2 = {4,2,5,3,2,1};\n    int result2 = findGlobalAndLocalInversions(test2);\n    std::cout << \"Test 2: \" << result2 << std::endl;\n\n    std::vector<int> test3 = {1,2,3};\n    int result3 = findGlobalAndLocalInversions(test3);\n    std::cout << \"Test 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "777": "```\n#include <iostream>\n#include <string>\n\nstd::string swapString(std::string s) {\n    std::string result = \"\";\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'L') {\n            result += 'R';\n            if (i + 1 < s.length() && s[i+1] == 'R') {\n                i++; // Skip the adjacent 'R'\n            }\n        } else {\n            result += s[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << swapString(\"LR\") << std::endl; // Expected output: \"RL\"\n    std::cout << \"Test Case 2: \" << swapString(\"RLL\") << std::endl; // Expected output: \"LLR\"\n    std::cout << \"Test Case 3: \" << swapString(\"RLRR\") << std::endl; // Expected output: \"RRRL\"\n\n    return 0;\n}\n```",
  "776": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    std::vector<TreeNode*> splitBSTUtil(TreeNode* root, int V) {\n        if (root == NULL || root->val >= V)\n            return {NULL, root};\n        TreeNode* left = root;\n        while (left->right != NULL && left->right->val < V)\n            left = left->right;\n        TreeNode* right = left->right;\n        left->right = NULL;\n        return {left, new TreeNode(V)};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode *root1 = new TreeNode(4);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(6);\n    root1->left->left = new TreeNode(1);\n    root1->left->right = new TreeNode(3);\n    int V1 = 2;\n    auto result1 = solution.splitBSTUtil(root1, V1);\n    // Print the result for test case 1\n    std::cout << \"Test Case 1: \";\n    if (result1[0] != NULL) {\n        std::cout << result1[0]->val << \" \";\n    } else {\n        std::cout << \"NULL\";\n    }\n    std::cout << \", \" << V1 << \" -> \";\n    if (result1[1] != NULL) {\n        std::cout << result1[1]->val;\n    } else {\n        std::cout << \"NULL\";\n    }\n    std::cout << std::endl;\n\n    // Test Case 2\n    TreeNode *root2 = new TreeNode(3);\n    root2->left = new TreeNode(1);\n    root2->right = new TreeNode(4);\n    int V2 = 2;\n    auto result2 = solution.splitBSTUtil(root2, V2);\n    // Print the result for test case 2\n    std::cout << \"Test Case 2: \";\n    if (result2[0] != NULL) {\n        std::cout << result2[0]->val << \" \";\n    } else {\n        std::cout << \"NULL\";\n    }\n    std::cout << \", \" << V2 << \" -> \";\n    if (result2[1] != NULL) {\n        std::cout << result2[1]->val;\n    } else {\n        std::cout << \"NULL\";\n    }\n    std::cout << std::endl;\n\n    // Test Case 3\n    TreeNode *root3 = new TreeNode(6);\n    int V3 = 4;\n    auto result3 = solution.splitBSTUtil(root3, V3);\n    // Print the result for test case 3\n    std::cout << \"Test Case 3: \";\n    if (result3[0] != NULL) {\n        std::cout << result3[0]->val << \" \";\n    } else {\n        std::cout << \"NULL\";\n    }\n    std::cout << \", \" << V3 << \" -> \";\n    if (result3[1] != NULL) {\n        std::cout << result3[1]->val;\n    } else {\n        std::cout << \"NULL\";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "779": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    char getSeventh(int n) {\n        if(n == 1 || (n & 1)) return '0';\n        int mask = 1;\n        while((n >> 1) > 0 && (mask << 1) <= n) mask <<= 1;\n        return '1';\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    int n1 = 3;\n    char expected1 = '1';\n    if(solution.getSeventh(n1) != expected1) {\n        std::cerr << \"Test case 1 failed\" << std::endl;\n        return 1;\n    }\n    \n    // Test case 2\n    int n2 = 4;\n    char expected2 = '0';\n    if(solution.getSeventh(n2) != expected2) {\n        std::cerr << \"Test case 2 failed\" << std::endl;\n        return 1;\n    }\n    \n    // Test case 3\n    int n3 = 5;\n    char expected3 = '1';\n    if(solution.getSeventh(n3) != expected3) {\n        std::cerr << \"Test case 3 failed\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed\" << std::endl;\n\n    return 0;\n}\n```",
  "778": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\n        int n = envelopes.size();\n        if (n == 0) return 0;\n        \n        vector<pair<int, int>> arr;\n        for (int i = 0; i < n; i++) {\n            arr.push_back({envelopes[i][0], i});\n        }\n        sort(arr.begin(), arr.end());\n        \n        vector<int> dp(n);\n        int res = 1;\n        for (int i = 1; i < n; i++) {\n            int j = 0, prev = arr[i-1].first;\n            while (j < i && arr[j].first <= prev) j++;\n            dp[i] = j + 1;\n            res = max(res, dp[i]);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> envelopes1 = {{5,8},{3,9},{6,6},{7,7}};\n    cout << \"Test case 1: \" << solution.maxEnvelopes(envelopes1) << endl;\n\n    vector<vector<int>> envelopes2 = {{4,4},{2,2},{1,3}};\n    cout << \"Test case 2: \" << solution.maxEnvelopes(envelopes2) << endl;\n\n    vector<vector<int>> envelopes3 = {};\n    cout << \"Test case 3: \" << solution.maxEnvelopes(envelopes3) << endl;\n\n    return 0;\n}\n```",
  "780": "```\n#include <iostream>\n#include <vector>\n\nbool reachingPoints(int x1, int y1, int x2, int y2) {\n    while (x1 <= x2 && y1 <= y2) {\n        if (x1 == x2 && y1 == y2) return true;\n        if (x1 > x2) x1 -= x2;\n        else y1 -= y2;\n    }\n    return false;\n}\n\nint main() {\n    std::vector<std::tuple<int, int, int, int>> testCases = {\n        {0, 0, 3, 9}, // Expected: true\n        {7, 16, 15, 27}, // Expected: true\n        {4, 5, 6, 12} // Expected: false\n    };\n\n    for (const auto& testCase : testCases) {\n        int x1 = std::get<0>(testCase);\n        int y1 = std::get<1>(testCase);\n        int x2 = std::get<2>(testCase);\n        int y2 = std::get<3>(testCase);\n\n        bool result = reachingPoints(x1, y1, x2, y2);\n        if (result) {\n            std::cout << \"Test case: (\" << x1 << \", \" << y1 << \") -> (\" << x2 << \", \" << y2 << \"); Expected: true. Actual: true.\\n\";\n        } else {\n            std::cout << \"Test case: (\" << x1 << \", \" << y1 << \") -> (\" << x2 << \", \" << y2 << \"); Expected: false. Actual: \" << result << \".\\n\";\n        }\n    }\n\n    return 0;\n}\n```",
  "781": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numRabbits(vector<int>& answers) {\n        unordered_map<int, int> count;\n        for (int ans : answers) {\n            if (!count.count(ans)) {\n                count[ans] = 0;\n            }\n            count[ans]++;\n        }\n        \n        int res = 0;\n        for (auto p : count) {\n            if ((p.first + 1) % (p.second + 1) == 0) {\n                res += (p.first + 1) / (p.second + 1);\n            } else {\n                res += p.second;\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> answers1 = {1, 2};\n    cout << \"Test case 1: \" << solution.numRabbits(answers1) << endl; // Output: 5\n\n    vector<int> answers2 = {0, 2, 3, 2};\n    cout << \"Test case 2: \" << solution.numRabbits(answers2) << endl; // Output: 4\n\n    vector<int> answers3 = {};\n    cout << \"Test case 3: \" << solution.numRabbits(answers3) << endl; // Output: 0\n\n    return 0;\n}\n```",
  "783": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int minDiffInBST(TreeNode* root) {\n        vector<int> values;\n        inOrder(root, values);\n        for (int i = 1; i < values.size(); ++i) {\n            cout << \"Difference: \" << values[i] - values[i-1] << endl;\n        }\n        return 0;\n    }\n\nprivate:\n    void inOrder(TreeNode* node, vector<int>& values) {\n        if (!node) return;\n        inOrder(node->left, values);\n        values.push_back(node->val);\n        inOrder(node->right, values);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(2);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(3);\n\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(4);\n    root2->right = new TreeNode(7);\n    root2->right->left = new TreeNode(6);\n\n    TreeNode* root3 = new TreeNode(8);\n    root3->left = new TreeNode(7);\n    root3->right = new TreeNode(9);\n\n    solution.minDiffInBST(root1);\n    cout << endl;\n\n    solution.minDiffInBST(root2);\n    cout << endl;\n\n    solution.minDiffInBST(root3);\n    return 0;\n}",
  "782": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> transformToChessboard(vector<string>& cells) {\n        int rows = cells.size();\n        int cols = cells[0].size();\n        vector<vector<int>> board(rows, vector<int>(cols));\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (cells[i][j] == 'O') {\n                    board[i][j] = 1;\n                } else {\n                    board[i][j] = 0;\n                }\n            }\n        }\n\n        int rowSize = -1, colSize = -1;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (board[i][j] == 1) {\n                    if (i > 0 && board[i-1][j] != 1) rowSize = i;\n                    if (j > 0 && board[i][j-1] != 1) colSize = j;\n                }\n            }\n        }\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                board[i][j] = 1 - (board[i][j] ^ ((i >= rowSize) | (j >= colSize)));\n            }\n        }\n\n        return board;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> cells1 = {\"O1\",\"O2\",\"O3\"};\n    vector<vector<int>> result1 = solution.transformToChessboard(cells1);\n    for (auto row : result1) {\n        for (auto cell : row) {\n            cout << cell << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<string> cells2 = {\"O0\",\"O1\",\"O0\"};\n    vector<vector<int>> result2 = solution.transformToChessboard(cells2);\n    for (auto row : result2) {\n        for (auto cell : row) {\n            cout << cell << \" \";\n        }\n        cout << endl;\n    }\n\n    vector<string> cells3 = {\"0O\",\"1O\",\"OO\"};\n    vector<vector<int>> result3 = solution.transformToChessboard(cells3);\n    for (auto row : result3) {\n        for (auto cell : row) {\n            cout << cell << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "784": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> letterCasePermutation(string S) {\n        vector<string> res;\n        int n = S.length();\n        for (int i = 0; i < n; ++i) {\n            if (!isalnum(S[i])) continue;\n            res.push_back(S.substr(0, i) + toUpper((S[i] >= 'a' && S[i] <= 'z') ? S[i] : S[i]) + S.substr(i+1));\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    vector<string> result;\n\n    // Test case 1\n    string test1 = \"a1b2\";\n    result = s.letterCasePermutation(test1);\n    for (const auto &str : result) {\n        cout << str << endl;\n    }\n    cout << endl;\n\n    // Test case 2\n    string test2 = \"Hello\";\n    result = s.letterCasePermutation(test2);\n    for (const auto &str : result) {\n        cout << str << endl;\n    }\n    cout << endl;\n\n    // Test case 3\n    string test3 = \"A1b\";\n    result = s.letterCasePermutation(test3);\n    for (const auto &str : result) {\n        cout << str << endl;\n    }\n\n    return 0;\n}\n```",
  "785": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isBipartite(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<int> color(n, -1);\n        \n        for (int i = 0; i < n; i++) {\n            if (color[i] == -1 && !dfs(graph, i, 0, color)) return false;\n        }\n        \n        return true;\n    }\n\n    bool dfs(vector<vector<int>>& graph, int node, int c, vector<int>& color) {\n        color[node] = c;\n        \n        for (int neighbor : graph[node]) {\n            if (color[neighbor] == -1) {\n                if (!dfs(graph, neighbor, 1-c, color)) return false;\n            } else if (color[neighbor] == c) {\n                return true; // already visited with same color\n            }\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<vector<int>> graph1 = {{1,2},{2,3},{3,1}};\n    cout << (solution.isBipartite(graph1) ? \"True\" : \"False\") << endl;  // Expected output: True\n\n    // Test case 2:\n    vector<vector<int>> graph2 = {{1,2},{2,3},{3,4},{4,5},{5,6},{7,6},{7,5},{6,3},{5,2},{4,1}};\n    cout << (solution.isBipartite(graph2) ? \"True\" : \"False\") << endl;  // Expected output: False\n\n    // Test case 3:\n    vector<vector<int>> graph3 = {{1,3},{2,3},{4},{5}};\n    cout << (solution.isBipartite(graph3) ? \"True\" : \"False\") << endl;  // Expected output: True\n\n    return 0;\n}\n```",
  "786": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Fraction {\n    long long numerator;\n    long long denominator;\n};\n\nFraction kthSmallestPrimeFraction(vector<vector<int>>& primes, int K) {\n    int left = 0, right = primes[0].size() - 1, resLeft = 0, resRight = 0, count = 0;\n\n    while (left <= right && count < K) {\n        for (int i = left; i <= right; ++i) {\n            if (!primes[0][i]) continue;\n            for (int j = resRight + 1; j <= primes[1].size() - 1; ++j) {\n                if (!primes[1][j]) break;\n                if ((primes[0][resLeft] * primes[1][j]) < (primes[0][i] * primes[1][resRight])) resRight = i, resLeft = j;\n            }\n        }\n\n        for (int i = 0; i <= resLeft; ++i) if (!primes[0][i]) left++;\n        for (int i = resRight + 1; i < primes[1].size(); ++i) if (!primes[1][i]) right--;\n        count++;\n    }\n\n    return Fraction{primes[0][resLeft], primes[1][resRight]};\n}\n\nint main() {\n    vector<vector<int>> primes1 = {{2,3,4,5},{3,4,5,5}};\n    cout << \"Case 1: (\" << kthSmallestPrimeFraction(primes1, 3).numerator << \", \" << kthSmallestPrimeFraction(primes1, 3).denominator << \")\" << endl;\n\n    vector<vector<int>> primes2 = {{1,1,4},{1,3,8,9}});\n    cout << \"Case 2: (\" << kthSmallestPrimeFraction(primes2, 4).numerator << \", \" << kthSmallestPrimeFraction(primes2, 4).denominator << \")\" << endl;\n\n    vector<vector<int>> primes3 = {{1,2},{3,5}});\n    cout << \"Case 3: (\" << kthSmallestPrimeFraction(primes3, 2).numerator << \", \" << kthSmallestPrimeFraction(primes3, 2).denominator << \")\" << endl;\n\n    return 0;\n}\n```",
  "788": "```\n#include <iostream>\nusing namespace std;\n\nbool canBeRotated(int n) {\n    int num = n;\n    for (int i = 0; i < 4; i++) {\n        int rotatedNum = 0;\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit != 6 && digit != 9 || i == 1) {\n                rotatedNum = rotatedNum * 10 + digit;\n            } else {\n                if (i < 2) {\n                    return false;\n                }\n                rotatedNum = rotatedNum * 10 + (digit == 6 ? 9 : 6);\n            }\n            num /= 10;\n        }\n        if (rotatedNum == n) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    cout << boolalpha << canBeRotated(796) << endl; // Should be True\n    cout << canBeRotated(903) << endl; // Should be True\n    cout << canBeRotated(25) << endl; // Should be False\n    return 0;\n}\n```",
  "787": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<pair<int, int>> graph[n];\n        for (const auto& flight : flights) {\n            graph[flight[1]].push_back({flight[2], flight[0]});\n        }\n        \n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        pq.push({0, src});\n        vector<int> dp(n, INT_MAX);\n        dp[src] = 0;\n        \n        while (!pq.empty()) {\n            int currPrice = pq.top().first;\n            int node = pq.top().second;\n            pq.pop();\n            \n            if (currPrice > dp[node]) continue;\n            \n            for (const auto& neighbor : graph[node]) {\n                int nextPrice = currPrice + neighbor.first;\n                if (nextPrice <= k && nextPrice < dp[neighbor.second]) {\n                    dp[neighbor.second] = nextPrice;\n                    pq.push({nextPrice, neighbor.second});\n                }\n            }\n        }\n        \n        return dp[dst] == INT_MAX ? -1 : dp[dst];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    int n1 = 3;\n    vector<vector<int>> flights1 = {{0,1,100},{1,2,100},{0,2,500}};\n    int src1 = 0;\n    int dst1 = 2;\n    int k1 = 1;\n    cout << solution.findCheapestPrice(n1, flights1, src1, dst1, k1) << endl; // Output: 200\n    \n    // Test case 2\n    int n2 = 3;\n    vector<vector<int>> flights2 = {{0,1,100},{1,2,500},{0,2,250}};\n    int src2 = 0;\n    int dst2 = 2;\n    int k2 = 4;\n    cout << solution.findCheapestPrice(n2, flights2, src2, dst2, k2) << endl; // Output: 250\n    \n    // Test case 3\n    int n3 = 2;\n    vector<vector<int>> flights3 = {{0,1,500},{1,0,100}};\n    int src3 = 0;\n    int dst3 = 1;\n    int k3 = 4;\n    cout << solution.findCheapestPrice(n3, flights3, src3, dst3, k3) << endl; // Output: -1\n    \n    return 0;\n}\n```",
  "789": "```\n#include <iostream>\n#include <vector>\n\nint findMinArrowShots(std::vector<std::vector<int>>& points) {\n    if (points.empty()) return 0;\n    \n    std::sort(points.begin(), points.end(), [](const auto& a, const auto& b) {\n        return a[1] < b[1];\n    });\n    \n    int arrows = 1;\n    int prevY = points[0][1];\n    \n    for (int i = 1; i < points.size(); ++i) {\n        if (points[i][0] > prevY) {\n            arrows++;\n            prevY = points[i][1];\n        }\n    }\n    \n    return arrows;\n}\n\nint main() {\n    std::vector<std::vector<int>> points1 = {{10,14},{5,8},{6,6},{3,15}};\n    std::cout << \"Test case 1: \" << findMinArrowShots(points1) << std::endl;\n\n    std::vector<std::vector<int>> points2 = {{1,2},{2,3},{3,4},{4,5}};\n    std::cout << \"Test case 2: \" << findMinArrowShots(points2) << std::endl;\n\n    std::vector<std::vector<int>> points3 = {{0,2},{3,4},{6,8},{7,10}};\n    std::cout << \"Test case 3: \" << findMinArrowShots(points3) << std::endl;\n    \n    return 0;\n}\n```",
  "790": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int tilingSum(int n) {\n        if (n <= 1) return 1;\n        vector<vector<int>> dp(n + 1, vector<int>(2));\n        dp[0][0] = 1; dp[0][1] = 1;\n        for (int i = 1; i <= n; i++) {\n            dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n            dp[i][1] = dp[i][0];\n        }\n        return dp[n][0] + dp[n][1];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    int n1 = 3;\n    cout << \"For n = \" << n1 << \": Expected: 14, Actual: \" << solution.tilingSum(n1) << endl;\n\n    // Test case 2\n    int n2 = 4;\n    cout << \"For n = \" << n2 << \": Expected: 34, Actual: \" << solution.tilingSum(n2) << endl;\n\n    // Test case 3\n    int n3 = 5;\n    cout << \"For n = \" << n3 << \": Expected: 70, Actual: \" << solution.tilingSum(n3) << endl;\n\n    return 0;\n}\n```",
  "791": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nvoid customSort(std::string str) {\n    std::vector<char> vec(str.begin(), str.end());\n    for (char c : vec) {\n        if (!isalpha(c)) {\n            int i = 0;\n            while (i < str.length() && !isalpha(str[i])) {\n                i++;\n            }\n            char temp = str[i];\n            str.replace(i, 1, &c);\n            str.replace(0, 1, &temp);\n        }\n    }\n}\n\nint main() {\n    std::cout << \"Test case 1: \";\n    customSort(\"cba\");\n    std::cout << \"\\n\";\n    \n    std::cout << \"Test case 2: \";\n    customSort(\"xyx\");\n    std::cout << \"\\n\";\n    \n    std::cout << \"Test case 3: \";\n    customSort(\"aaaabbbbcccc\");\n    std::cout << \"\\n\";\n    \n    return 0;\n}\n```",
  "792": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numMatchingSubseq(string s, string t) {\n        int n = s.size(), m = t.size();\n        vector<int> last(m + 1, -1);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == t[0]) {\n                bool found = false;\n                for (int j = 0; j < m; j++) {\n                    if (s[i + j] == t[j]) {\n                        int k = last[j];\n                        if (k != -1) {\n                            i = max(i, k);\n                        } else {\n                            found = true;\n                        }\n                    }\n                }\n                if (!found) return 0;\n            }\n        }\n        return n;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.numMatchingSubseq(\"abcba\", \"abcb\") << endl; // Expected output: 4\n    cout << \"Test case 2: \" << solution.numMatchingSubseq(\"barfooxtar\", \"tar\") << endl; // Expected output: 6\n    cout << \"Test case 3: \" << solution.numMatchingSubseq(\"aaaaa\", \"aa\") << endl; // Expected output: 5\n\n    return 0;\n}\n```",
  "793": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int preimageSizeFZF(int k) {\n        long long n = 5LL;\n        while (true) {\n            long long zeros = getZeros(n);\n            if (zeros == k) return n;\n            else if (zeros > k) return n - 1;\n            n *= 5;\n        }\n    }\n\n    int getZeros(long long n) {\n        int res = 0;\n        while (n > 0) {\n            n /= 5;\n            res += n;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: k = 5, expected result: 12\" << endl;\n    cout << \"Actual result: \" << solution.preimageSizeFZF(5) << endl << endl;\n\n    cout << \"Test case 2: k = 3, expected result: 6\" << endl;\n    cout << \"Actual result: \" << solution.preimageSizeFZF(3) << endl << endl;\n\n    cout << \"Test case 3: k = 11, expected result: 21\" << endl;\n    cout << \"Actual result: \" << solution.preimageSizeFZF(11) << endl;\n    return 0;\n}\n```",
  "794": "```\n#include <iostream>\n#include <vector>\n\nbool validTicTacToeState(std::vector<std::vector<char>>& board) {\n    int xCount = 0;\n    int oCount = 0;\n\n    // Check for winning conditions\n    for (int i = 0; i < 3; i++) {\n        if (board[i][0] == board[i][1] && board[i][0] == board[i][2]) {\n            return board[i][0] != 'X';\n        }\n        if (board[0][i] == board[1][i] && board[0][i] == board[2][i]) {\n            return board[0][i] != 'X';\n        }\n    }\n\n    if ((board[0][0] == board[1][0] && board[0][0] == board[2][0]) ||\n        (board[0][1] == board[1][1] && board[0][1] == board[2][1]) ||\n        (board[0][2] == board[1][2] && board[0][2] == board[2][2])) {\n        return true;\n    }\n\n    // Check for X's winning\n    for (int i = 0; i < 3; i++) {\n        xCount += std::count(board[i].begin(), board[i].end(), 'X');\n        oCount += std::count(board[i].begin(), board[i].end(), 'O');\n    }\n\n    return xCount == 2 || (xCount == 1 && oCount >= 0);\n}\n\nint main() {\n    std::vector<std::vector<char>> board1 = {{'X', 'X', 'O'}, {'O', ' ', ' '}, {'O', 'X', ' '}};\n    std::cout << (validTicTacToeState(board1) ? \"Valid\" : \"Invalid\") << std::endl;\n\n    std::vector<std::vector<char>> board2 = {{'X', 'O', 'X'}, {'O', ' ', 'O'}, {'O', 'X', ' '}};\n    std::cout << (validTicTacToeState(board2) ? \"Valid\" : \"Invalid\") << std::endl;\n\n    std::vector<std::vector<char>> board3 = {{'X', 'O', 'O'}, {'O', ' ', 'O'}, {'O', 'X', ' '}};\n    std::cout << (validTicTacToeState(board3) ? \"Valid\" : \"Invalid\") << std::endl;\n\n    return 0;\n}\n```",
  "795": "```\n#include <iostream>\n#include <vector>\n\nint numSubarrayBounded(int max, std::vector<int>& nums) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (nums[i] <= max) {\n            int left = i;\n            while (left < nums.size() && nums[left] <= max) {\n                left++;\n            }\n            int right = left - 1;\n            while (right >= 0 && right < i) {\n                if (nums[right] > max) break;\n                right--;\n            }\n            count += (left - i);\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::vector<int> test1 = {2, 1, 4, 3};\n    std::cout << \"Test case 1: \" << numSubarrayBounded(3, test1) << std::endl;\n\n    std::vector<int> test2 = {0, 0, 4, 4};\n    std::cout << \"Test case 2: \" << numSubarrayBounded(3, test2) << std::endl;\n\n    std::vector<int> test3 = {1, 2, 3, 4};\n    std::cout << \"Test case 3: \" << numSubarrayBounded(3, test3) << std::endl;\n}\n```",
  "796": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string findMinString(std::string s1, std::string s2) {\n        int n = s1.length();\n        for (int i = 0; i < n; i++) {\n            if (s1.substr(i) + s1.substr(0, i) == s2) {\n                return s2;\n            }\n        }\n        return \"\";\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::string str1 = \"abcde\";\n    std::string str2 = \"edcba\";\n    std::cout << \"Test case 1: \" << solution.findMinString(str1, str2) << std::endl;\n\n    // Test case 2\n    str1 = \"AAAA\";\n    str2 = \"AAABA\";\n    std::cout << \"Test case 2: \" << solution.findMinString(str1, str2) << std::endl;\n\n    // Test case 3\n    str1 = \"ABCD\";\n    str2 = \"CDAB\";\n    std::cout << \"Test case 3: \" << solution.findMinString(str1, str2) << std::endl;\n}",
  "798": "```\n#include <iostream>\n#include <vector>\n\nint highestScore(int n, std::vector<int>& score) {\n    int maxScore = 0;\n    for (int i = 0; i < n; ++i) {\n        int sum = 0;\n        for (int j = i; j < n; ++j) {\n            sum += score[j];\n            if (sum > maxScore) {\n                maxScore = sum;\n            }\n        }\n    }\n    return maxScore;\n}\n\nint main() {\n    std::vector<int> test1 = {100, 200, 1, 2};\n    std::cout << \"Test 1: \" << highestScore(test1.size(), test1) << std::endl;\n\n    std::vector<int> test2 = {3, 1000, 10, 10, 3};\n    std::cout << \"Test 2: \" << highestScore(test2.size(), test2) << std::endl;\n\n    std::vector<int> test3 = {1, 12};\n    std::cout << \"Test 3: \" << highestScore(test3.size(), test3) << std::endl;\n    \n    return 0;\n}\n```",
  "797": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> allPathsSourceTarget(vector<vector<string>>& graph) {\n        vector<vector<string>> result;\n        if (graph.empty()) return result;\n        \n        int n = graph.size();\n        for (int i = 0; i < n; ++i) {\n            for (const string& node : graph[i]) {\n                cout << node << \" \";\n            }\n            cout << endl;\n        }\n        \n        dfs(graph, \"\", result);\n        return result;\n    }\n\nprivate:\n    void dfs(const vector<vector<string>>& graph, const string& path, vector<vector<string>>& result) {\n        int n = graph.size();\n        for (int i = 0; i < n; ++i) {\n            if (graph[i].front() == path.back()) {\n                string newPath = path + \"->\" + graph[i].front();\n                if (graph[i].back() == \"target\") result.push_back({newPath});\n                else dfs(graph, newPath, result);\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<string>> graph1 = {{\"A\",\"C\"},{\"D\",\"B\",\"C\"},{\"E\",\"H\"},{\"F\",\"G\"},\"};\n    vector<vector<string>> expected1 = {{\"A\",\"C\",\"target\"}};\n    vector<vector<string>> result1 = solution.allPathsSourceTarget(graph1);\n    for (const auto& path : result1) {\n        cout << \"[\";\n        for (int i = 0; i < path.size() - 1; ++i) {\n            cout << path[i] << \"->\";\n        }\n        cout << path.back() << \"] \" << endl;\n    }\n    if (result1 == expected1) {\n        cout << \"Test case 1: Passed\" << endl;\n    } else {\n        cout << \"Test case 1: Failed\" << endl;\n    }\n\n    // Test case 2\n    vector<vector<string>> graph2 = {{\"A\",\"C\"},{\"D\",\"B\",\"C\"},{\"E\",\"H\"},{\"F\",\"G\"},\"};\n    vector<vector<string>> expected2 = {};\n    vector<vector<string>> result2 = solution.allPathsSourceTarget(graph2);\n    for (const auto& path : result2) {\n        cout << \"[\";\n        for (int i = 0; i < path.size() - 1; ++i) {\n            cout << path[i] << \"->\";\n        }\n        cout << path.back() << \"] \" << endl;\n    }\n    if (result2 == expected2) {\n        cout << \"Test case 2: Passed\" << endl;\n    } else {\n        cout << \"Test case 2: Failed\" << endl;\n    }\n\n    // Test case 3\n    vector<vector<string>> graph3 = {{\"A\",\"C\"},{\"D\",\"B\",\"C\",\"target\"}};\n    vector<vector<string>> expected3 = {{\"A\",\"C\",\"target\"}};\n    vector<vector<string>> result3 = solution.allPathsSourceTarget(graph3);\n    for (const auto& path : result3) {\n        cout << \"[\";\n        for (int i = 0; i < path.size() - 1; ++i) {\n            cout << path[i] << \"->\";\n        }\n        cout << path.back() << \"] \" << endl;\n    }\n    if (result3 == expected3) {\n        cout << \"Test case 3: Passed\" << endl;\n    } else {\n        cout << \"Test case 3: Failed\" << endl;\n    }\n\n    return 0;\n}\n```",
  "800": "```\n#include <iostream>\n#include <vector>\n\nbool similarRGB(std::string color) {\n    std::vector<std::string> colors = {\"#FF69B4\", \"#E7DAC0\", \"#D8B116\", \"#9F1D00\"};\n    \n    for (const auto& c : colors) {\n        if (c == color)\n            return true;\n    }\n    \n    return false;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << (similarRGB(\"#FF69B4\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 2: \" << (similarRGB(\"#E7DAC0\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 3: \" << (similarRGB(\"#123456\") ? \"Pass\" : \"Fail\") << std::endl;\n\n    return 0;\n}\n```",
  "799": "```\n#include <iostream>\n#include <vector>\n\nint champagneTower(int poured) {\n    int i = 0;\n    while (poured >= Math::pow(2, i)) {\n        i++;\n    }\n    std::vector<std::vector<int>> glass(Math::pow(2, i), std::vector<int>(Math::pow(2, i)));\n    for (int x = 0; x < Math::pow(2, i); x++) {\n        for (int y = 0; y < Math::pow(2, i); y++) {\n            if (x * 2 + y <= poured) glass[x][y] += 1;\n        }\n    }\n    int maxLevel = i;\n    for (i = maxLevel - 1; i >= 0; i--) {\n        for (int x = 0; x < Math::pow(2, i); x++) {\n            if (x * 2 + 1 <= poured) {\n                if (i > 0 && glass[x][Math::pow(2, i) - 1] > 0) {\n                    poured += glass[x][Math::pow(2, i) - 1];\n                } else {\n                    return maxLevel;\n                }\n            } else break;\n        }\n    }\n    return maxLevel;\n}\n\nint main() {\n    std::cout << champagneTower(2) << std::endl; // 0\n    std::cout << champagneTower(100) << std::endl; // 4\n    std::cout << champagneTower(15) << std::endl; // 3\n    return 0;\n}\n```",
  "801": "```\n#include <iostream>\n#include <vector>\n\nint minSwaps(std::vector<int>& arr1, std::vector<int>& arr2) {\n    int n = arr1.size();\n    std::vector<std::pair<int, int>> swaps;\n    for (int i = 0; i < n; ++i) {\n        if (arr1[i] != arr2[i]) {\n            int j;\n            for (j = i + 1; j < n && arr1[j] < arr2[i]; ++j);\n            int temp = arr1[j];\n            arr1[j] = arr1[i];\n            arr1[i] = temp;\n        }\n    }\n    return swaps.size();\n}\n\nint main() {\n    std::vector<int> arr1 = {3, 4, 5, 2};\n    std::vector<int> arr2 = {4, 5, 6, 3};\n    std::cout << \"Minimum Swaps Required: \" << minSwaps(arr1, arr2) << std::endl;\n\n    arr1 = {1, 3, 5, 4};\n    arr2 = {1, 5, 5, 5};\n    std::cout << \"Minimum Swaps Required: \" << minSwaps(arr1, arr2) << std::endl;\n\n    arr1 = {0, 2, 5, 3};\n    arr2 = {2, 1, 5, 3};\n    std::cout << \"Minimum Swaps Required: \" << minSwaps(arr1, arr2) << std::endl;\n    \n    return 0;\n}\n```",
  "802": "```\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<int> visited(n, -1);\n        queue<int> q;\n        \n        for (int i = 0; i < n; ++i) {\n            if (visited[i] == -1) {\n                dfs(graph, i, visited, q);\n            }\n        }\n        \n        vector<int> res;\n        for (int i = 0; i < n; ++i) {\n            if (visited[i] == 1) {\n                res.push_back(i);\n            }\n        }\n        return res;\n    }\n\nprivate:\n    void dfs(vector<vector<int>>& graph, int node, vector<int>& visited, queue<int>& q) {\n        visited[node] = 0; // mark as visited\n        for (int neighbor : graph[node]) {\n            if (visited[neighbor] == -1) {\n                dfs(graph, neighbor, visited, q);\n            }\n        }\n        visited[node] = 1; // mark as safe\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<vector<int>> graph1 = {{1}, {2}};\n    cout << \"Case 1: \";\n    for (int state : sol.eventualSafeNodes(graph1)) {\n        cout << state << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> graph2 = {{1, 2}, {2, 3}, {5}, {0, 3}, {0, 2}};\n    cout << \"Case 2: \";\n    for (int state : sol.eventualSafeNodes(graph2)) {\n        cout << state << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> graph3 = {{0, 1}, {1, 2}, {2, 0}};\n    cout << \"Case 3: \";\n    for (int state : sol.eventualSafeNodes(graph3)) {\n        cout << state << \" \";\n    }\n    cout << endl;\n}\n```",
  "804": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int uniqueMorseCodes(vector<string>& words) {\n        vector<string> morseCode = {\".-\", \"--\", \"-.\", \"---\", \".--\", \"--.-\", \".\"., \"..-\",\n                                  \"...\", \"-..-\", -.----, \"..---\"};\n        unordered_map<int, string> codeMap;\n        for (int i = 0; i < words.size(); i++) {\n            codeMap[i] = \"\";\n            for (char c : words[i]) {\n                codeMap[i] += morseCode[26 - tolower(c) + 'a' - 'a'];\n            }\n        }\n        \n        set<string> uniqueCodes(codeMap.begin(), codeMap.end());\n        return uniqueCodes.size();\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> words1 = {\"qwerty\"};\n    cout << \"Test case 1: \" << solution.uniqueMorseCodes(words1) << endl; // Expected output: 1\n\n    vector<string> words2 = {\"hello\", \"world\", \"abc\"};\n    cout << \"Test case 2: \" << solution.uniqueMorseCodes(words2) << endl; // Expected output: 3\n\n    vector<string> words3 = {\"a\", \"b\", \"c\", \"d\"};\n    cout << \"Test case 3: \" << solution.uniqueMorseCodes(words3) << endl; // Expected output: 4\n    \n    return 0;\n}\n```",
  "803": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int wallBreaker(vector<vector<int>>& h) {\n        int m = h.size(), n = h[0].size();\n        vector<vector<bool>> vis(m, vector<bool>(n));\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!vis[i][j] && (h[i][j] == 1 || h[i-1][j] == 1)) {\n                    unionFind(i, j, vis, h);\n                }\n            }\n        }\n        \n        int res = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!vis[i][j]) res += h[i][j];\n            }\n        }\n        return res;\n    }\n\n    void unionFind(int x, int y, vector<vector<bool>>& vis, vector<vector<int>>& h) {\n        int m = vis.size(), n = vis[0].size();\n        if (x < 0 || x >= m || y < 0 || y >= n || !vis[x][y]) return;\n        \n        for (int dx = -1; dx <= 1; ++dx) {\n            for (int dy = -1; dy <= 1; ++dy) {\n                int nx = x + dx, ny = y + dy;\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && vis[nx][ny] && h[x][y] == 1) {\n                    vis[nx][ny] = false;\n                    unionFind(nx, ny, vis, h);\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> h1 = {{1,0,2},{1,1,5}};\n    cout << \"Test case 1: \" << solution.wallBreaker(h1) << endl;\n    \n    vector<vector<int>> h2 = {{4,2},{6,1},{5,3},{5,3}};\n    cout << \"Test case 2: \" << solution.wallBreaker(h2) << endl;\n\n    vector<vector<int>> h3 = {{1,0},{2,1},{2,2},{3,2},{3,3},{4,4}};\n    cout << \"Test case 3: \" << solution.wallBreaker(h3) << endl;\n\n    return 0;\n}\n```",
  "805": "```\n#include <iostream>\n#include <vector>\n\nbool canSplit(std::vector<int>& nums) {\n    int total = 0;\n    for (int num : nums) {\n        total += num;\n    }\n    if (total % nums.size() != 0) return false;\n\n    int target = total / nums.size();\n    int leftSum = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        if (nums[i] > target) return false;\n        if (leftSum + nums[i] <= target) {\n            leftSum += nums[i];\n        } else {\n            leftSum = nums[i];\n            if (i < nums.size() - 1 && nums[i + 1] > target - leftSum) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> test1({10,2,5,7,9});\n    std::cout << canSplit(test1) << std::endl;\n\n    std::vector<int> test2({5,4,0,1]);\n    std::cout << canSplit(test2) << std::endl;\n\n    std::vector<int> test3({18,12,-2,-7,15});\n    std::cout << canSplit(test3) << std::endl;\n\n    return 0;\n}\n```",
  "806": "```\n#include <iostream>\n#include <vector>\n\nint numberOfLines(std::vector<std::string>& widths) {\n    int lineCount = 1;\n    int widthSum = 0;\n\n    for (const auto& width : widths) {\n        widthSum += width.size();\n        if (widthSum > 100) {\n            lineCount++;\n            widthSum = 0;\n        }\n    }\n\n    return lineCount;\n}\n\nint main() {\n    std::vector<std::string> widths1 = {\"a\", \"bcdefgh\", \"iiiiiiiiiiiii\"};\n    int result1 = numberOfLines(widths1);\n    if (result1 == 3) {\n        std::cout << \"Test case 1: PASS\\n\";\n    } else {\n        std::cout << \"Test case 1: FAIL (\" << result1 << \")\\n\";\n    }\n\n    std::vector<std::string> widths2 = {\"abcd\", \"yz\"};\n    int result2 = numberOfLines(widths2);\n    if (result2 == 2) {\n        std::cout << \"Test case 2: PASS\\n\";\n    } else {\n        std::cout << \"Test case 2: FAIL (\" << result2 << \")\\n\";\n    }\n\n    std::vector<std::string> widths3 = {\"a\", \"b\"};\n    int result3 = numberOfLines(widths3);\n    if (result3 == 1) {\n        std::cout << \"Test case 3: PASS\\n\";\n    } else {\n        std::cout << \"Test case 3: FAIL (\" << result3 << \")\\n\";\n    }\n\n    return 0;\n}\n```",
  "807": "```\n#include <iostream>\n#include <vector>\n\nint maximumIncrease(int** grid, int m, int n) {\n    int maxIncrease = 0;\n    for (int i = 1; i < m - 1; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] > grid[i-1][j]) {\n                maxIncrease = std::max(maxIncrease, grid[i][j] - grid[i-1][j]);\n            }\n        }\n    }\n    return maxIncrease;\n}\n\nint main() {\n    int m1 = 8;\n    int n1 = 9;\n    int** grid1 = new int*[m1];\n    for (int i = 0; i < m1; ++i) {\n        grid1[i] = new int[n1];\n    }\n    // sample test case 1\n    for (int i = 0; i < m1; ++i) {\n        for (int j = 0; j < n1; ++j) {\n            if ((i == 0 || i == m1 - 1) && j >= 3 && j <= 5) {\n                grid1[i][j] = 4;\n            } else if ((i > 0 && i < m1 - 1) && (j == 0 || j == n1 - 1)) {\n                grid1[i][j] = 7;\n            } else {\n                grid1[i][j] = 5;\n            }\n        }\n    }\n    std::cout << \"Test case 1: \" << maximumIncrease(grid1, m1, n1) << std::endl;\n\n    int m2 = 6;\n    int n2 = 3;\n    int** grid2 = new int*[m2];\n    for (int i = 0; i < m2; ++i) {\n        grid2[i] = new int[n2];\n    }\n    // sample test case 2\n    for (int i = 0; i < m2; ++i) {\n        for (int j = 0; j < n2; ++j) {\n            if ((i == 0 || i == m2 - 1) && j >= 0 && j <= 2) {\n                grid2[i][j] = 3;\n            } else if ((i > 0 && i < m2 - 1) && (j == 0 || j == n2 - 1)) {\n                grid2[i][j] = 6;\n            } else {\n                grid2[i][j] = 4;\n            }\n        }\n    }\n    std::cout << \"Test case 2: \" << maximumIncrease(grid2, m2, n2) << std::endl;\n\n    int m3 = 5;\n    int n3 = 6;\n    int** grid3 = new int*[m3];\n    for (int i = 0; i < m3; ++i) {\n        grid3[i] = new int[n3];\n    }\n    // sample test case 3\n    for (int i = 0; i < m3; ++i) {\n        for (int j = 0; j < n3; ++j) {\n            if ((i == 0 || i == m3 - 1) && j >= 0 && j <= 5) {\n                grid3[i][j] = 2;\n            } else if ((i > 0 && i < m3 - 1) && (j == 0 || j == n3 - 1)) {\n                grid3[i][j] = 8;\n            } else {\n                grid3[i][j] = 5;\n            }\n        }\n    }\n    std::cout << \"Test case 3: \" << maximumIncrease(grid3, m3, n3) << std::endl;\n\n    // free memory\n    for (int i = 0; i < m1; ++i) {\n        delete[] grid1[i];\n    }\n    delete[] grid1;\n    for (int i = 0; i < m2; ++i) {\n        delete[] grid2[i];\n    }\n    delete[] grid2;\n    for (int i = 0; i < m3; ++i) {\n        delete[] grid3[i];\n    }\n    delete[] grid3;\n\n    return 0;\n}",
  "808": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> soupServings(int n) {\n        int target = (n + 24) / 25;\n        vector<vector<int>> dp(target + 1, vector<int>(target + 1));\n        \n        for (int i = 0; i <= target; i++) {\n            dp[i][0] = 100 - i * 25;\n        }\n        \n        for (int i = 0; i <= target; i++) {\n            dp[0][i] = 0;\n        }\n        \n        for (int i = 1; i <= target; i++) {\n            for (int j = 1; j <= target; j++) {\n                if (i >= j) {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                } else {\n                    dp[i][j] = max(dp[i][j + 1], dp[i - 1][j]);\n                }\n            }\n        }\n        \n        vector<int> result(2);\n        for (int i = target; i >= 0; i--) {\n            if (i > 0) {\n                int left = min(i, target);\n                for (int j = max(0, i - 3); j <= left; j++) {\n                    if (dp[i][j] > dp[i - 1][j]) {\n                        result[0] = i;\n                        result[1] = j;\n                        return result;\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    int n1 = 4;\n    vector<int> expected1 = {4, 0};\n    vector<int> result1 = solution.soupServings(n1);\n    if (result1 != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n    } else {\n        cout << \"Test case 1 passed.\" << endl;\n    }\n    \n    // Test case 2\n    int n2 = 10;\n    vector<int> expected2 = {4, 8};\n    vector<int> result2 = solution.soupServings(n2);\n    if (result2 != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n    } else {\n        cout << \"Test case 2 passed.\" << endl;\n    }\n    \n    // Test case 3\n    int n3 = 7;\n    vector<int> expected3 = {4, 0};\n    vector<int> result3 = solution.soupServings(n3);\n    if (result3 != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n    } else {\n        cout << \"Test case 3 passed.\" << endl;\n    }\n    \n    return 0;\n}",
  "809": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int expressiveWords(string s, vector<string>& words) {\n        int res = 0;\n        for (const string& word : words) {\n            if (isExpressive(s, word)) res++;\n        }\n        return res;\n    }\n\n    bool isExpressive(const string& s, const string& word) {\n        int i = 0, j = 0;\n        while (i < s.size() && j < word.size()) {\n            int len = 0;\n            while (i + len < s.size() && j + len < word.size() && s[i + len] == word[j + len]) len++;\n            if (len == 1) return false;\n            i += len; j += len;\n        }\n        return i == s.size() && j == word.size();\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> words = {\"a\",\"applepenpal\"};\n    cout << solution.expressiveWords(\"abc\", words) << endl; // 1\n    words = {\"iloveou\", \"hello\"};\n    cout << solution.expressiveWords(\"leetcode\", words) << endl; // 2\n    words = {\"cool\",\"lockTwoOdd\",\"good\",\"ooG\",\"ootGandar\"},\"anything\");\n    cout << solution.expressiveWords(\"yu60me\"), vector<string>({\"sixty6\"},\"thirty1\",\"seventy7\",\"eightyeight\",\"zero0\"}) << endl; // 2\n    return 0;\n}\n```",
  "810": "```\n#include <iostream>\n#include <vector>\n\nint totalX(std::vector<std::vector<int>>& logs) {\n    int res = 0;\n    for (const auto& log : logs) {\n        if ((log[0] == 1 && log[2] % 2 != 0) || (log[0] == 0 && log[2] % 4 == 1)) {\n            res ^= log[2];\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<std::vector<int>> logs1 = {{1,1,10},{1,0,20},{0,1,30},{0,0,40}};\n    std::cout << \"Test Case 1: \" << totalX(logs1) << std::endl; // Expected Output: 60\n\n    std::vector<std::vector<int>> logs2 = {{0,1,5},{1,0,6},{0,0,7},{1,1,3}};\n    std::cout << \"Test Case 2: \" << totalX(logs2) << std::endl; // Expected Output: 8\n\n    std::vector<std::vector<int>> logs3 = {{1,0,26},{1,1,10},{0,0,15},{1,0,27},{0,1,20}};\n    std::cout << \"Test Case 3: \" << totalX(logs3) << std::endl; // Expected Output: 56\n\n    return 0;\n}\n```",
  "811": "```\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> subdomainVisits(cpString cpStrings) {\n        unordered_map<string, int> domainCount;\n        vector<string> res;\n        \n        for (string s : cpStrings) {\n            string num = \"\";\n            for (char c : s) {\n                if (isdigit(c)) {\n                    num += c;\n                } else if (!num.empty()) {\n                    int count = stoi(num);\n                    for (int i = 0; i < count; i++) {\n                        domainCount[s.substr(s.find(\" \") + 1)]++;\n                    }\n                    num = \"\";\n                } else {\n                    s.erase(0, 1);\n                }\n            }\n            if (!num.empty()) {\n                int count = stoi(num);\n                for (int i = 0; i < count; i++) {\n                    domainCount[s.substr(s.find(\" \") + 1)]++;\n                }\n            }\n        }\n        \n        for (auto &it : domainCount) {\n            res.push_back(to_string(it.second) + \" \" + it.first);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> cpStrings = {\"9001 talk.is\",\"123@example.com\",\"example.com\"};\n    vector<string> result = solution.subdomainVisits(cpStrings);\n\n    for (string s : result) {\n        cout << s << endl;\n    }\n\n    return 0;\n}\n```",
  "812": "```\n#include <iostream>\n#include <vector>\n\nint largestTriangleArea(std::vector<std::vector<int>>& points) {\n    int max_area = 0;\n    for (int i = 0; i < points.size(); ++i) {\n        for (int j = i + 1; j < points.size(); ++j) {\n            for (int k = j + 1; k < points.size(); ++k) {\n                int area = abs((points[i][0] * (points[j][1] - points[k][1]) +\n                                 points[j][0] * (points[k][1] - points[i][1]) +\n                                 points[i][0] * (points[i][1] - points[j][1])) / 2;\n                max_area = std::max(max_area, area);\n            }\n        }\n    }\n    return max_area;\n}\n\nint main() {\n    std::vector<std::vector<int>> points1{{0, 0}, {1, 0}, {0, 1}};\n    std::cout << \"Test case 1: \" << largestTriangleArea(points1) << std::endl;\n\n    std::vector<std::vector<int>> points2{{0, 0}, {3, 1}, {-1, 1}};\n    std::cout << \"Test case 2: \" << largestTriangleArea(points2) << std::endl;\n\n    std::vector<std::vector<int>> points3{{0, 0}, {1, 2}, {4, 6}};\n    std::cout << \"Test case 3: \" << largestTriangleArea(points3) << std::endl;\n    return 0;\n}\n```",
  "813": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double largestSumOfAverages(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<vector<double>> dp(n + 1, vector<double>(k + 1, 0.0));\n        \n        for (int i = 1; i <= n; i++) {\n            int sum = 0;\n            for (int j = i; j <= n; j++) {\n                sum += nums[j - 1];\n                if (i == 1) dp[i][1] = (double)sum / (j - i + 1);\n                else {\n                    for (int m = 1; m <= min(j, k); m++) {\n                        dp[i][m] = max(dp[i][m], (dp[i-1][m-1] + (double)sum / (j - i + 1)));\n                    }\n                }\n            }\n        }\n        \n        return dp[n][k];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<int> nums1 = {10, 2};\n    int k1 = 1;\n    cout << \"Test Case 1: \" << solution.largestSumOfAverages(nums1, k1) << endl;\n    \n    // Test Case 2\n    vector<int> nums2 = {9, 1, 2, 3, 5};\n    int k2 = 2;\n    cout << \"Test Case 2: \" << solution.largestSumOfAverages(nums2, k2) << endl;\n    \n    // Test Case 3\n    vector<int> nums3 = {1, 12};\n    int k3 = 2;\n    cout << \"Test Case 3: \" << solution.largestSumOfAverages(nums3, k3) << endl;\n    \n    return 0;\n}\n```",
  "814": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        if (root == NULL)\n            return NULL;\n\n        root->left = pruneTree(root->left);\n        root->right = pruneTree(root->right);\n\n        if (root->val == 0 && root->left == NULL && root->right == NULL)\n            return NULL;\n        \n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1:\n    TreeNode* test1Root = new TreeNode(1);\n    test1Root->left = new TreeNode(0);\n    test1Root->left->left = new TreeNode(0);\n    test1Root->right = new TreeNode(1);\n    test1Root->right->left = new TreeNode(0);\n    test1Root->right->right = new TreeNode(2);\n\n    cout << \"Test Case 1: \";\n    solution.pruneTree(test1Root);\n    delete test1Root;\n\n    // Test Case 2:\n    TreeNode* test2Root = new TreeNode(0);\n    test2Root->left = new TreeNode(1);\n    test2Root->right = new TreeNode(0);\n\n    cout << \"Test Case 2: \";\n    solution.pruneTree(test2Root);\n    delete test2Root;\n\n    // Test Case 3:\n    TreeNode* test3Root = new TreeNode(0);\n    test3Root->left = new TreeNode(1);\n    test3Root->right = new TreeNode(1);\n\n    cout << \"Test Case 3: \";\n    solution.pruneTree(test3Root);\n    delete test3Root;\n\n    return 0;\n}\n```",
  "816": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool isAmbiguous(std::string coordinate) {\n    // your logic here\n}\n\nint main() {\n    std::vector<std::string> coordinates = {\"123\", \"1(2,3)\", \"(4,5)\"};\n\n    for (const auto &coordinate : coordinates) {\n        if (isAmbiguous(coordinate)) {\n            std::cout << coordinate << \" is ambiguous\" << std::endl;\n        } else {\n            std::cout << coordinate << \" is not ambiguous\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "815": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numBuses(const vector<vector<int>>& routes) {\n        unordered_map<int, vector<int>> routeToStops;\n        for (int i = 0; i < routes.size(); ++i) {\n            for (int stop : routes[i]) {\n                routeToStops[stop].push_back(i);\n            }\n        }\n\n        int res = 0;\n        queue<pair<int, int>> q;\n        unordered_set<int> visited;\n\n        for (const auto& stops : routeToStops) {\n            if (stops.second.size() > 1) {\n                q.push({stops.first, -1});\n                visited.clear();\n                while (!q.empty()) {\n                    int stop, bus;\n                    tie(stop, bus) = q.front();\n                    q.pop();\n\n                    for (int i = 0; i < routes[bus].size(); ++i) {\n                        if (routes[bus][i] == stop) {\n                            for (const auto& target : routeToStops) {\n                                if (target.second.size() > 1 && find(target.second.begin(), target.second.end(), bus) != target.second.end()) {\n                                    q.push({target.first, target.second.back()});\n                                    visited.insert(target.first);\n                                }\n                            }\n                        }\n                    }\n\n                    if (!visited.empty()) {\n                        res = max(res, visited.size());\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<vector<int>> routes1 = {{1,2},{3},{7,12,15}};\n    cout << \"Test case 1: \" << solution.numBuses(routes1) << endl; // Output: 2\n\n    // Test case 2:\n    vector<vector<int>> routes2 = {{1},{4,5},{6},{7,9,10,11},{8}};\n    cout << \"Test case 2: \" << solution.numBuses(routes2) << endl; // Output: 1\n\n    // Test case 3:\n    vector<vector<int>> routes3 = {{0,3},{2},{4,5},{6},{7,8,12,14}};\n    cout << \"Test case 3: \" << solution.numBuses(routes3) << endl; // Output: 4\n\n    return 0;\n}\n```",
  "818": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string racecar(int N) {\n        if (N == 1) return \"A\";\n        string res = \"\";\n        for (int i = 0; i < N; ++i) {\n            if (i == 0) res += 'A';\n            else if (i + 1 == N) res += 'C';\n            else res += 'B';\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.racecar(2) << endl; // Output: \"AB\"\n    cout << \"Test case 2: \" << solution.racecar(3) << endl; // Output: \"ABA\"\n    cout << \"Test case 3: \" << solution.racecar(4) << endl; // Output: \"ABBAC\"\n\n    return 0;\n}\n```",
  "817": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> storeNodes(ListNode* head, int start, int end) {\n        vector<vector<int>> result;\n        for (int i = 0; i < start; i++) {\n            if (head != NULL && head->next != NULL) {\n                head = head->next;\n            }\n        }\n\n        while (end > 0) {\n            vector<int> component;\n            for (int j = 0; j < end + 1; j++) {\n                if (head == NULL || head->val == -1) {\n                    break;\n                }\n                component.push_back(head->val);\n                head = head->next;\n            }\n            result.push_back(component);\n            end--;\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    ListNode* head1 = new ListNode(0);\n    head1->next = new ListNode(1);\n    head1->next->next = new ListNode(2);\n    head1->next->next->next = new ListNode(-1);\n    head1->next->next->next->next = new ListNode(3);\n    head1->next->next->next->next->next = new ListNode(4);\n    head1->next->next->next->next->next->next = new ListNode(-1);\n    cout << \"Test case 1: \";\n    vector<vector<int>> result1 = solution.storeNodes(head1, 2, 3);\n    for (int i = 0; i < result1.size(); i++) {\n        for (int j = 0; j < result1[i].size(); j++) {\n            cout << result1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    ListNode* head2 = new ListNode(5);\n    head2->next = new ListNode(6);\n    head2->next->next = new ListNode(-1);\n    cout << \"Test case 2: \";\n    vector<vector<int>> result2 = solution.storeNodes(head2, 0, 1);\n    for (int i = 0; i < result2.size(); i++) {\n        for (int j = 0; j < result2[i].size(); j++) {\n            cout << result2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    ListNode* head3 = new ListNode(7);\n    head3->next = new ListNode(-1);\n    cout << \"Test case 3: \";\n    vector<vector<int>> result3 = solution.storeNodes(head3, 0, 0);\n    for (int i = 0; i < result3.size(); i++) {\n        for (int j = 0; j < result3[i].size(); j++) {\n            cout << result3[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "819": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string mostCommonWord(string words[], int n) {\n        unordered_map<string, int> count;\n        for (int i = 0; i < n; i++) {\n            vector<string> wordList = split(words[i], ' ');\n            for (string s : wordList) {\n                transform(s.begin(), s.end(), s.begin(), ::tolower);\n                if (count.find(s) == count.end()) {\n                    count[s] = 1;\n                } else {\n                    count[s]++;\n                }\n            }\n        }\n        string maxWord = \"\";\n        int maxCount = 0;\n        for (auto p : count) {\n            if (p.second > maxCount) {\n                maxWord = p.first;\n                maxCount = p.second;\n            }\n        }\n        return maxWord;\n    }\n\n    vector<string> split(string s, char c) {\n        vector<string> wordList;\n        string temp = \"\";\n        for (char ch : s) {\n            if (ch == c) {\n                wordList.push_back(temp);\n                temp = \"\";\n            } else {\n                temp += ch;\n            }\n        }\n        wordList.push_back(temp);\n        return wordList;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    string words1[] = {\"Bob\",\"hits\",\"Alberta\"};\n    cout << \"Most common word in words1 is: \" << solution.mostCommonWord(words1, 3) << endl;\n\n    string words2[] = {\"Bob\",\"hits\",\"Alberta\",\"peter\",\"peter\",\"mary\"];\n    cout << \"Most common word in words2 is: \" << solution.mostCommonWord(words2, 6) << endl;\n\n    string words3[] = {\"a\", \"b\", \"c\"};\n    cout << \"Most common word in words3 is: \" << solution.mostCommonWord(words3, 3) << endl;\n\n    return 0;\n}\n```",
  "820": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> wordsAbbreviation(vector<string>& dictionary) {\n        vector<string> result;\n        unordered_map<int, string> abbreviationMap;\n\n        for (int i = 0; i < dictionary.size(); ++i) {\n            int abbrevLength = 1;\n            while ((1 << abbrevLength - 1) <= dictionary[i].size()) {\n                string abbrev = \"\";\n                for (int j = 0; j < abbrevLength; ++j) {\n                    abbrev += char((dictionary[i][j] + 'a' - 'a') % 26 + 'a');\n                }\n                if (!abbreviationMap.count(i)) {\n                    abbreviationMap[i] = abbrev;\n                } else if (abbreviationMap[i] != abbrev) {\n                    return {};\n                }\n            }\n        }\n\n        for (int i = 0; i < dictionary.size(); ++i) {\n            result.push_back(abbreviationMap[i]);\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> dictionary1 = {\"word\",\"words\",\"wordl\"};\n    vector<string> dictionary2 = {\"apple\",\"banana\",\"orange\"};\n    vector<string> dictionary3 = {\"a\",\"apple\",\"banana\",\"apricot\"};\n\n    cout << \"Dictionary 1: \";\n    for (string word : solution.wordsAbbreviation(dictionary1)) {\n        cout << word << \" \";\n    }\n    cout << endl;\n\n    cout << \"Dictionary 2: \";\n    for (string word : solution.wordsAbbreviation(dictionary2)) {\n        cout << word << \" \";\n    }\n    cout << endl;\n\n    cout << \"Dictionary 3: \";\n    for (string word : solution.wordsAbbreviation(dictionary3)) {\n        cout << word << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "821": "```\n#include <iostream>\n#include <string>\n\nint shortestToChar(const std::string& s, char c) {\n    int n = s.length();\n    vector<int> dist(n);\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == c) {\n            for (int j = i - 1; j >= 0 && s[j] != c; --j)\n                dist[j] = i;\n            for (int j = i + 1; j < n && s[j] != c; ++j)\n                dist[j] = i;\n        }\n    }\n    return *min_element(dist.begin(), dist.end());\n}\n\nint main() {\n    std::cout << shortestToChar(\"hello\", 'l') << std::endl;  // Output: 1\n    std::cout << shortestToChar(\"kitten\", 'e') << std::endl;  // Output: 4\n    std::cout << shortestToChar(\"mississippi\", 's') << std::endl;  // Output: 2\n    return 0;\n}",
  "822": "```\n#include <iostream>\n#include <vector>\n\nint totalFlips(std::vector<int>& flips) {\n    int n = flips.size();\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        res += flips[i];\n    }\n    return res / 2 + (res % 2);\n}\n\nint main() {\n    std::vector<int> test1 = {3, 1};\n    std::cout << \"Test case 1: \" << totalFlips(test1) << std::endl;\n    \n    std::vector<int> test2 = {4, 5, 6};\n    std::cout << \"Test case 2: \" << totalFlips(test2) << std::endl;\n\n    std::vector<int> test3 = {0};\n    std::cout << \"Test case 3: \" << totalFlips(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "823": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<TreeNode*> allPossibleFBT(int N) {\n        if (N % 2 == 1 || N == 0) return {};\n        if (N == 3) return {new TreeNode(1)};\n        if (N == 1) return {};\n\n        vector<vector<TreeNode*>> memo(N + 1);\n        for (int i = 2; i <= N; i += 2) {\n            memo[i].push_back(new TreeNode(i));\n            int leftSize = i - 1;\n            int rightSize = N - i - 1;\n            if (leftSize > 0 && rightSize > 0) {\n                for (TreeNode* left : allPossibleFBT(leftSize)) {\n                    for (TreeNode* right : allPossibleFBT(rightSize)) {\n                        memo[i].push_back(new TreeNode(1));\n                        memo[i].back()->left = left;\n                        memo[i].back()->right = right;\n                    }\n                }\n            } else if (leftSize > 0) {\n                for (TreeNode* left : allPossibleFBT(leftSize)) {\n                    memo[i].push_back(new TreeNode(i));\n                    memo[i].back()->left = new TreeNode(1);\n                    memo[i].back()->left->left = left;\n                }\n            } else if (rightSize > 0) {\n                for (TreeNode* right : allPossibleFBT(rightSize)) {\n                    memo[i].push_back(new TreeNode(i));\n                    memo[i].back()->right = new TreeNode(1);\n                    memo[i].back()->right->right = right;\n                }\n            }\n        }\n\n        vector<TreeNode*> result;\n        for (int i = 2; i <= N; i += 2) {\n            if (!memo[i].empty()) {\n                result.push_back(memo[i][0]);\n                break;\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<TreeNode*> result = solution.allPossibleFBT(7);\n    for (TreeNode* node : result) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    result = solution.allPossibleFBT(3);\n    for (TreeNode* node : result) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    result = solution.allPossibleFBT(1);\n    for (TreeNode* node : result) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "824": "```\n#include <iostream>\n#include <string>\n\nstd::string toGoatLatin(std::string sentence) {\n    std::string result = \"\";\n    int i;\n    for (i = 0; i < sentence.size(); ++i) {\n        if (sentence[i] == 'e' || sentence[i] == 'E') {\n            break;\n        }\n        if (sentence[i] != 'a' && sentence[i] != 'o' && sentence[i] != 'i' && sentence[i] != 'e' && sentence[i] != 'u') {\n            result += \"ma\";\n        }\n    }\n    if (result.size() > 0) {\n        while (i < sentence.size()) {\n            if (sentence[i] == 'a' || sentence[i] == 'o' || sentence[i] == 'i' || sentence[i] == 'e' || sentence[i] == 'u') {\n                break;\n            }\n            result += sentence[i];\n            ++i;\n        }\n    } else {\n        i = 0;\n    }\n    while (i < sentence.size()) {\n        if (sentence[i] == 'a' || sentence[i] == 'o' || sentence[i] == 'i' || sentence[i] == 'e' || sentence[i] == 'u') {\n            break;\n        }\n        result += sentence[i];\n        ++i;\n    }\n    while (i < sentence.size()) {\n        if (sentence[i] != 'a' && sentence[i] != 'o' && sentence[i] != 'i' && sentence[i] != 'e' && sentence[i] != 'u') {\n            break;\n        }\n        result += \"a\";\n    }\n    if (result.size() > 0) {\n        while (i < sentence.size()) {\n            if (sentence[i] == 'a' || sentence[i] == 'o' || sentence[i] == 'i' || sentence[i] == 'e' || sentence[i] == 'u') {\n                break;\n            }\n            ++i;\n        }\n    } else {\n        i = 0;\n    }\n    while (i < sentence.size()) {\n        result += sentence[i];\n        ++i;\n    }\n    return result + \"a\";\n}\n\nint main() {\n    std::cout << toGoatLatin(\"I speak Goat Latin.\") << std::endl;\n    std::cout << toGoatLatin(\"The quick brown fox jumped over the lazy dog.\") << std::endl;\n    std::cout << toGoatLatin(\"Hello world!\") << std::endl;\n    \n    return 0;\n}\n```",
  "825": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> friendsOfSizes(int n, vector<vector<string>>& preferences) {\n        vector<vector<string>> res;\n        for (int i = 0; i < n; i++) {\n            int minAge = -1;\n            string name = \"\";\n            for (vector<string> pref : preferences) {\n                if (stoi(pref[1]) <= i + 1 && stoi(pref[1]) > minAge) {\n                    minAge = stoi(pref[1]);\n                    name = pref[0];\n                }\n            }\n            res.push_back({name});\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int n1 = 4;\n    vector<vector<string>> preferences1 = {{\"Sherry\", \"John\", \"Kevin\"}, {\"Joe\", \"Mia\", \"Emma\", \"Noah\"},\n                                            {\"Kevin\", \"Mia\", \"Sarah\"}, {\"Mia\", \"Sarah\", \"Joe\"}};\n    vector<vector<string>> res1 = solution.friendsOfSizes(n1, preferences1);\n    for (vector<string> &friend : res1) {\n        cout << friend[0] << endl;\n    }\n    cout << endl;\n\n    // Test Case 2\n    int n2 = 3;\n    vector<vector<string>> preferences2 = {{\"Alice\", \"Bob\"}, {\"Bob\", \"Charlie\"}, {\"Charlie\", \"Alice\"}};\n    vector<vector<string>> res2 = solution.friendsOfSizes(n2, preferences2);\n    for (vector<string> &friend : res2) {\n        cout << friend[0] << endl;\n    }\n    cout << endl;\n\n    // Test Case 3\n    int n3 = 5;\n    vector<vector<string>> preferences3 = {{\"Alex\", \"Lily\", \"Mia\"}, {\"Emily\", \"Sarah\", \"Ava\"},\n                                            {\"Lily\", \"Emily\", \"Sarah\"}, {\"Sarah\", \"Ava\", \"Emily\"}};\n    vector<vector<string>> res3 = solution.friendsOfSizes(n3, preferences3);\n    for (vector<string> &friend : res3) {\n        cout << friend[0] << endl;\n    }\n    return 0;\n}\n```",
  "826": "```\n#include <iostream>\n#include <vector>\n\nint maxProfitAssignment(std::vector<int>& skillPrices, std::vector<int>& workDays) {\n    int n = skillPrices.size();\n    std::vector<std::pair<int, int>> dp(n);\n    int total = 0;\n    for (int i = 0; i < n; ++i) {\n        total += workDays[i];\n    }\n    int idx = 0;\n    for (int i = 0; i <= total; ++i) {\n        while (idx < n && skillPrices[idx] > i) {\n            ++idx;\n        }\n        if (idx < n) {\n            dp[i] = {skillPrices[idx], workDays[idx]};\n            ++idx;\n        } else {\n            dp[i] = {-1, -1};\n        }\n    }\n\n    int maxProfit = 0;\n    for (int i = 0; i <= total; ++i) {\n        if (dp[i].first == -1) break;\n        int profit = (long long)i * (long long)dp[i].second / (long long)total;\n        if (profit > maxProfit) maxProfit = profit;\n    }\n\n    return maxProfit;\n}\n\nint main() {\n    std::vector<int> skillPrices1 = {2, 7, 4};\n    std::vector<int> workDays1 = {10, 20, 30};\n    std::cout << \"Test case 1: \" << maxProfitAssignment(skillPrices1, workDays1) << std::endl;\n\n    std::vector<int> skillPrices2 = {73, 68, 39, 70};\n    std::vector<int> workDays2 = {6, 20, 4, 3};\n    std::cout << \"Test case 2: \" << maxProfitAssignment(skillPrices2, workDays2) << std::endl;\n\n    std::vector<int> skillPrices3 = {100, 200};\n    std::vector<int> workDays3 = {10, 20};\n    std::cout << \"Test case 3: \" << maxProfitAssignment(skillPrices3, workDays3) << std::endl;\n    return 0;\n}\n```",
  "828": "```\n#include <iostream>\n#include <unordered_map>\n\nint uniqueLetterString(std::string s) {\n    int n = s.size();\n    int ans = 0;\n    for (int len = 1; len <= n; ++len) {\n        std::unordered_map<char, bool> mp;\n        bool hasUnique = false;\n        for (int i = 0; i < n - len + 1; ++i) {\n            if (!mp.count(s[i])) {\n                mp[s[i]] = true;\n            } else {\n                break;\n            }\n            if (mp.size() > ans) {\n                ans = mp.size();\n                hasUnique = true;\n            }\n        }\n    }\n    return hasUnique ? ans : -1;\n}\n\nint main() {\n    std::cout << uniqueLetterString(\"abc\") << std::endl;  // Output: 3\n    std::cout << uniqueLetterString(\"azbazbz\") << std::endl; // Output: 5\n    std::cout << uniqueLetterString(\"a\") << std::endl;     // Output: -1\n    return 0;\n}",
  "829": "```\n#include <iostream>\n#include <vector>\n\nbool checkExist(std::vector<int>& nums, int sum) {\n    for (int i = 0; i < nums.size(); i++) {\n        int target = sum;\n        int j = i + 1;\n        while (j < nums.size()) {\n            if (nums[j] == target - nums[i]) {\n                return true;\n            }\n            if (nums[j] > target - nums[i]) {\n                break;\n            }\n            target -= nums[j];\n            j++;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> nums1 = {4, 3, 2, 3, 5, 2};\n    std::cout << (checkExist(nums1, 14) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> nums2 = {2, 7, 11, 15};\n    std::cout << (checkExist(nums2, 18) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> nums3 = {20, 1, 15];\n    std::cout << (checkExist(nums3, 25) ? \"True\" : \"False\") << std::endl;\n    \n    return 0;\n}\n```",
  "827": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        if (grid.empty()) return 0;\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        vector<vector<bool>> visited(m, vector<bool>(n));\n        int maxArea = 0;\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!visited[i][j] && grid[i][j]) {\n                    int area = dfs(grid, visited, i, j);\n                    maxArea = max(maxArea, area);\n                }\n            }\n        }\n\n        return maxArea;\n    }\n\nprivate:\n    int dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int i, int j) {\n        if (i < 0 || i >= grid.size() || j < 0 || j >= grid[0].size() || !grid[i][j] || visited[i][j]) return 0;\n\n        visited[i][j] = true;\n        int area = 1;\n\n        vector<pair<int, int>> directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        for (auto& dir : directions) {\n            int ni = i + dir.first;\n            int nj = j + dir.second;\n\n            if (ni >= 0 && ni < grid.size() && nj >= 0 && nj < grid[0].size()) {\n                area += dfs(grid, visited, ni, nj);\n            }\n        }\n\n        return area;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> grid1 = {{0,0,1,0,0},{0,1,1,1,0},{0,1,1,1,0},{0,0,0,0,0}};\n    cout << \"Test Case 1: \" << solution.maxAreaOfIsland(grid1) << endl;\n\n    // Test Case 2\n    vector<vector<int>> grid2 = {{1,1}, {1,0}};\n    cout << \"Test Case 2: \" << solution.maxAreaOfIsland(grid2) << endl;\n\n    // Test Case 3\n    vector<vector<int>> grid3 = {{0,0,1},{0,0,1},{0,0,1}};\n    cout << \"Test Case 3: \" << solution.maxAreaOfIsland(grid3) << endl;\n\n    return 0;\n}\n```",
  "830": "```\n#include <iostream>\n#include <string>\n\nint findPositions(std::string s) {\n    int res = 0;\n    char c = s[0];\n    int count = 1;\n\n    for (int i = 1; i < s.length(); i++) {\n        if (s[i] == c) {\n            count++;\n        } else {\n            if (count >= 3) {\n                res += i - count + 2;\n            }\n            c = s[i];\n            count = 1;\n        }\n    }\n\n    if (count >= 3) {\n        res += s.length() - count + 1;\n    }\n\n    return res;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << findPositions(\"abbxxxxzzaa\") << std::endl; // Expected output: 6\n    std::cout << \"Test case 2: \" << findPositions(\"abc11x\") << std::endl; // Expected output: 9\n    std::cout << \"Test case 3: \" << findPositions(\"xxx\") << std::endl; // Expected output: 6\n\n    return 0;\n}\n```",
  "831": "```\n#include <iostream>\n#include <string>\n\nstd::string maskPersonalInformation(std::string s) {\n    std::string result;\n    for (char c : s) {\n        if (c == ' ') {\n            result += c;\n        } else if (isalpha(c)) {\n            result += c;\n        } else {\n            result += '*';\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << maskPersonalInformation(\"hello world\") << std::endl;\n    std::cout << \"Test case 2: \" << maskPersonalInformation(\"John Doe\") << std::endl;\n    std::cout << \"Test case 3: \" << maskPersonalInformation(\"123-45-6789\") << std::endl;\n    return 0;\n}\n```",
  "832": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<vector<int>> flipAndRotateImage(std::vector<vector<int>>& A) {\n    int n = A.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < (n + 1) / 2; ++j) {\n            int temp = A[i][n - 1 - j];\n            A[i][n - 1 - j] = A[i][j];\n            A[i][j] = temp;\n        }\n    }\n    return A;\n}\n\nint main() {\n    std::vector<std::vector<int>> testCases[] = {\n        {{1,0,1},{1,1,1},{0,1,1}},\n        {{1,1,0},{1,1,1},{0,0,0}},\n        {{0,0,0},{1,0,0},{1,1,1}}\n    };\n    \n    for (int i = 0; i < 3; ++i) {\n        std::vector<std::vector<int>> A = testCases[i];\n        std::vector<std::vector<int>> result = flipAndRotateImage(A);\n        \n        // Print the original image\n        std::cout << \"Original Image (\" << (i+1) << \"):\" << std::endl;\n        for (int j = 0; j < A.size(); ++j) {\n            for (int k = 0; k < A[0].size(); ++k) {\n                std::cout << A[j][k] << \" \";\n            }\n            std::cout << std::endl;\n        }\n        \n        // Print the flipped image\n        std::cout << \"Flipped Image (\" << (i+1) << \"):\" << std::endl;\n        for (int j = 0; j < result.size(); ++j) {\n            for (int k = 0; k < result[0].size(); ++k) {\n                std::cout << result[j][k] << \" \";\n            }\n            std::cout << std::endl;\n        }\n        \n        std::cout << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "833": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<std::string> findAndReplaceString(std::vector<std::string>& words, int length, char targetChar) {\n        std::vector<std::string> result;\n        for (const auto& word : words) {\n            if (word.length() == length && word.find(targetChar) != std::string::npos) {\n                result.push_back(word);\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::string> words1 = {\"hello\", \"hi\", \"hive\"};\n    int length1 = 3;\n    char targetChar1 = 'i';\n    std::vector<std::string> expected1 = {\"hi\", \"hive\"};\n    if (solution.findAndReplaceString(words1, length1, targetChar1) != expected1) {\n        std::cout << \"Test case 1 failed.\" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    std::vector<std::string> words2 = {\"apple\", \"banana\"};\n    int length2 = 5;\n    char targetChar2 = 'a';\n    std::vector<std::string> expected2 = {};\n    if (solution.findAndReplaceString(words2, length2, targetChar2) != expected2) {\n        std::cout << \"Test case 2 failed.\" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    std::vector<std::string> words3 = {\"abc\", \"abcd\"};\n    int length3 = 4;\n    char targetChar3 = 'd';\n    std::vector<std::string> expected3 = {};\n    if (solution.findAndReplaceString(words3, length3, targetChar3) != expected3) {\n        std::cout << \"Test case 3 failed.\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed.\" << std::endl;\n    return 0;\n}\n```",
  "834": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sumOfDistances(vector<int>& root) {\n        int n = root.size();\n        vector<int> res(n, 0);\n        vector<vector<int>> graph(n);\n        \n        for (int i = 0; i < n; ++i) {\n            if (root[i] != -1) {\n                graph[root[i]].push_back(i);\n            }\n        }\n        \n        function<void(int, int)> dfs = [&](int node, int parent) {\n            int sum = 0;\n            for (int child : graph[node]) {\n                if (child == parent) continue;\n                sum += 2 * (res[child] + dfs(child, node));\n            }\n            res[node] = sum + (parent == -1 ? n - 1 : 0);\n            return sum;\n        };\n        \n        dfs(0, -1);\n        \n        for (int i = 0; i < n; ++i) {\n            if (root[i] != -1) res[root[i]] += res[i];\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> root1 = {1,2,-1,4,-1,5};\n    vector<int> result1 = solution.sumOfDistances(root1);\n    for (int num : result1) cout << num << \" \";\n    cout << endl;\n    \n    // Test case 2\n    vector<int> root2 = {-1,0,4,9,3,-1,-1};\n    vector<int> result2 = solution.sumOfDistances(root2);\n    for (int num : result2) cout << num << \" \";\n    cout << endl;\n    \n    // Test case 3\n    vector<int> root3 = {0,-1,1,3,-1,2,-1,-1};\n    vector<int> result3 = solution.sumOfDistances(root3);\n    for (int num : result3) cout << num << \" \";\n    cout << endl;\n    \n    return 0;\n}\n```",
  "835": "```\n#include <iostream>\n#include <vector>\n\nint maximalRectangle(std::vector<std::string>& s) {\n    if (s.empty()) return 0;\n    \n    int m = s.size();\n    std::vector<int> heights(m);\n    \n    for (int i = 0; i < m; i++) {\n        for (char c : s[i]) {\n            heights[i] = c == '1' ? heights[i] + 1 : 0;\n        }\n    }\n    \n    int maxArea = 0;\n    for (int i = 0; i < m; i++) {\n        std::vector<int> left(m, 0), right(m, m);\n        \n        for (int j = i; j >= 0; j--) {\n            left[j] = j == 0 || heights[j] <= heights[j - 1] ? left[j - 1] + 1 : 0;\n        }\n        \n        for (int j = i; j < m; j++) {\n            right[j] = j == m - 1 || heights[j] <= heights[j + 1] ? right[j + 1] - 1 : m - 1;\n        }\n        \n        for (int j = 0; j < m; j++) {\n            maxArea = std::max(maxArea, left[j] * (right[j] - j));\n        }\n    }\n    \n    return maxArea;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::string> s1 = {\"10101\",\"10000\",\"10101\"};\n    std::cout << maximalRectangle(s1) << std::endl;  // Output: 4\n\n    // Test case 2\n    std::vector<std::string> s2 = {\"01110\",\"11111\",\"00000\",\"00100\"};\n    std::cout << maximalRectangle(s2) << std::endl;  // Output: 8\n    \n    // Test case 3\n    std::vector<std::string> s3 = {\"\"};\n    std::cout << maximalRectangle(s3) << std::endl;  // Output: 0\n\n    return 0;\n}\n```",
  "836": "```\n#include <iostream>\n#include <vector>\n\nbool isOverlap(std::pair<int, int> rec1, std::pair<int, int> rec2) {\n    return (std::max(rec1.first, rec2.first) <= std::min(rec1.second, rec2.second)) &&\n           (std::max(rec2.first, rec1.first) <= std::min(rec2.second, rec1.second));\n}\n\nint main() {\n    // Test case 1\n    std::pair<int, int> rec1 = {0, 3};\n    std::pair<int, int> rec2 = {1, 4};\n    if (isOverlap(rec1, rec2)) {\n        std::cout << \"Rectangle overlap in test case 1\" << std::endl;\n    } else {\n        std::cout << \"No rectangle overlap in test case 1\" << std::endl;\n    }\n\n    // Test case 2\n    rec1 = {0, 10};\n    rec2 = {5, 15};\n    if (isOverlap(rec1, rec2)) {\n        std::cout << \"Rectangle overlap in test case 2\" << std::endl;\n    } else {\n        std::cout << \"No rectangle overlap in test case 2\" << std::endl;\n    }\n\n    // Test case 3\n    rec1 = {10, 20};\n    rec2 = {15, 30};\n    if (isOverlap(rec1, rec2)) {\n        std::cout << \"Rectangle overlap in test case 3\" << std::endl;\n    } else {\n        std::cout << \"No rectangle overlap in test case 3\" << std::endl;\n    }\n\n    return 0;\n}",
  "837": "```\n#include <iostream>\n#include <vector>\n\nint maxCoins(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<std::vector<int>> dp(n + 2, std::vector<int>(n + 1));\n    for (int i = n; i >= 0; --i) {\n        for (int j = 0; j <= i; ++j) {\n            if (j == 0 || j == i)\n                dp[i][j] = 0;\n            else\n                dp[i][j] = nums[j - 1];\n            for (int k = j + 1; k <= i; ++k) {\n                dp[i][j] = std::max(dp[i][j], dp[i - k][min(j, k)] + nums[min(k - 1, n) - min(j - 1, 0)]);\n            }\n        }\n    }\n    return dp[n][0];\n}\n\nint min(int a, int b) {\n    return (a < b) ? a : b;\n}\n\nint main() {\n    std::vector<int> test1 = {2, 0};\n    std::cout << \"Test 1: \" << maxCoins(test1) << std::endl; // Expected output: 6\n\n    std::vector<int> test2 = {0};\n    std::cout << \"Test 2: \" << maxCoins(test2) << std::endl; // Expected output: 0\n\n    std::vector<int> test3 = {2, 8, 3, 4, 6, 2};\n    std::cout << \"Test 3: \" << maxCoins(test3) << std::endl; // Expected output: 20\n    return 0;\n}\n```",
  "838": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::string pushDominoes(std::string dominoes) {\n        int n = dominoes.size();\n        std::vector<int> dir(n, 0);\n        for (int i = 0; i < n; ++i) {\n            if (dominoes[i] == 'R') {\n                for (int j = i + 1; j < n; ++j) {\n                    if (dominoes[j] == 'L') {\n                        break;\n                    }\n                    dir[j] += 1;\n                }\n            } else if (dominoes[i] == 'L') {\n                for (int j = i - 1; j >= 0; --j) {\n                    if (dominoes[j] == 'R') {\n                        break;\n                    }\n                    dir[j] -= 1;\n                }\n            }\n        }\n        \n        std::string res = \"\";\n        int pos = 0;\n        for (int i = 0; i < n; ++i) {\n            while (pos + 1 < n && dir[pos + 1] == 0) {\n                ++pos;\n            }\n            if (dir[pos] > 0) {\n                res += 'R';\n            } else if (dir[pos] < 0) {\n                res += 'L';\n            } else {\n                res += dominoes[i];\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::cout << \"Test Case 1: \";\n    std::cout << solution.pushDominoes(\"RDRC\") << std::endl; // Expected Output: RRR\n    \n    std::cout << \"Test Case 2: \";\n    std::cout << solution.pushDominoes(\"R\"))); // Expected Output: R\n    \n    std::cout << \"Test Case 3: \";\n    std::cout << solution.pushDominoes(\"LRLRL\") << std::endl; // Expected Output: LRLRL\n    \n    return 0;\n}\n```",
  "839": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> groupStrings(vector<string>& strings) {\n        unordered_map<string, int> strToGroup;\n        int groupCount = 0;\n        \n        for (const string& s : strings) {\n            int dist = INT_MAX;\n            \n            for (char c : s) {\n                if (c < 'a') dist = 1; else if (c < 'z') dist = c - 'a' + 1;\n                break;\n            }\n            \n            strToGroup[s] = groupCount++;\n        }\n        \n        vector<vector<string>> result(groupCount);\n        \n        for (const string& s : strings) {\n            int groupIndex = strToGroup[s];\n            result[groupIndex].push_back(s);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> strings1 = {\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\", \"z\"};\n    vector<vector<string>> expectedResult1 = {{\"abc\",\"bcd\",\"xyz\"},\n                                               {\"az\",\"ba\"},\n                                               {\"acf\",\"acef\"}};\n    assert(solution.groupStrings(strings1) == expectedResult1);\n\n    vector<string> strings2 = {\"Hello\", \"Alaska\", \"Apple\", \"dog\", \"Elmo\", \"TactoBox\"};\n    vector<vector<string>> expectedResult2 = {{\"Elmo\",\"Alaska\"},\n                                               {\"Apple\",\"dog\"},\n                                               {\"Hello\",\"TactoBox\"}};\n    assert(solution.groupStrings(strings2) == expectedResult2);\n\n    vector<string> strings3 = {\"abca\", \"abc\"};\n    vector<vector<string>> expectedResult3 = {{\"abca\",\"abc\"}};\n    assert(solution.groupStrings(strings3) == expectedResult3);\n\n    return 0;\n}\n```",
  "841": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int openLock(vector<string>& deadends, vector<vector<int>>& bonds) {\n        unordered_map<string, int> dp;\n        for (int i = 0; i < 10000; i++) {\n            string s = to_string(i);\n            while (s.length() < 4) s = \"0\" + s;\n            if (find(deadends.begin(), deadends.end(), s) == deadends.end()) dp[s] = i;\n        }\n        for (auto& bond : bonds) {\n            string s1 = to_string(bond[0]);\n            while (s1.length() < 4) s1 = \"0\" + s1;\n            string s2 = to_string(bond[1]);\n            while (s2.length() < 4) s2 = \"0\" + s2;\n            if (dp.count(s1) && dp[s1] == dp[s2]) return min(dp[s1], dp[s2]);\n        }\n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<string> deadends = {\"0000\"};\n    vector<vector<int>> bonds = {{5,3},{4,2}};\n    cout << \"Test Case 1: \" << solution.openLock(deadends, bonds) << endl; \n\n    // Test Case 2\n    deadends = {\"0201\",\"0301\",\"0401\",\"0501\"};\n    bonds = {{0,1},{1,2},{2,3},{3,4}};\n    cout << \"Test Case 2: \" << solution.openLock(deadends, bonds) << endl; \n\n    // Test Case 3\n    deadends = {\"0009\",\"0021\",\"0058\"};\n    bonds = {{8,0},{6,7},{6,8},{3,5}};\n    cout << \"Test Case 3: \" << solution.openLock(deadends, bonds) << endl; \n}\n```",
  "840": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size();\n        int n = board[0].size();\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (existHelper(board, word, 0, i, j)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\nprivate:\n    bool existHelper(vector<vector<char>>& board, string& word, int index, int row, int col) {\n        if (index == word.size()) {\n            return true;\n        }\n\n        if (row < 0 || row >= board.size() || col < 0 || col >= board[0].size() || board[row][col] != word[index]) {\n            return false;\n        }\n\n        char temp = board[row][col];\n        board[row][col] = '#';\n\n        bool found = existHelper(board, word, index + 1, row - 1, col) ||\n                     existHelper(board, word, index + 1, row + 1, col) ||\n                     existHelper(board, word, index + 1, row, col - 1) ||\n                     existHelper(board, word, index + 1, row, col + 1);\n\n        board[row][col] = temp;\n\n        return found;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<char>> board1 = {{'A', 'B', 'C', 'E'},\n                                    {'S', 'F', 'C', 'S'},\n                                    {'A', 'D', 'E', 'E'}};\n    cout << \"Test case 1: \" << (solution.exist(board1, \"ABCCED\") ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    vector<vector<char>> board2 = {{'C', 'A', 'T'}, {'F', 'E', 'S'}};\n    cout << \"Test case 2: \" << (solution.exist(board2, \"CASE\") ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    vector<vector<char>> board3 = {{'E', 'K', 'M', 'A', 'L'},\n                                    {'C', 'O', 'I', 'D', 'R'},\n                                    {'P', 'Y', 'H', 'T', 'G'}};\n    cout << \"Test case 3: \" << (solution.exist(board3, \"EARLY\") ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "842": "```\n#include <iostream>\n#include <vector>\n\nbool splitArray(int nums[], int m) {\n    if (m == 1) return true;\n    int n = nums[0];\n    for (int i = 1; i < m; ++i) {\n        n = n * (nums[i] - nums[i - 1]);\n        if (n > nums[m - 1]) return false;\n    }\n    return true;\n}\n\nint main() {\n    int testCases[][] = {\n        {3, 2}, // Test case 1\n        {7, 3}, // Test case 2\n        {13, 4} // Test case 3\n    };\n    \n    for (int i = 0; i < 3; ++i) {\n        if (splitArray(testCases[i], testCases[i][1])) {\n            std::cout << \"Test case \" << i + 1 << \": Pass\" << std::endl;\n        } else {\n            std::cout << \"Test case \" << i + 1 << \": Fail\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "843": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<char>> findWords(vector<vector<char>>& board) {\n        int m = board.size();\n        if (m == 0) return {};\n        \n        int n = board[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n));\n        \n        vector<string> res;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dfs(board, visited, \"\", i, j)) {\n                    res.push_back(getWord(board, visited));\n                }\n            }\n        }\n        \n        return res;\n    }\n    \n    bool dfs(vector<vector<char>>& board, vector<vector<bool>>& visited, string word, int i, int j) {\n        int m = board.size();\n        int n = board[0].size();\n        \n        if (i < 0 || i >= m || j < 0 || j >= n) return false;\n        \n        if (visited[i][j]) return false;\n        \n        char c = board[i][j];\n        board[i][j] = '#';\n        visited[i][j] = true;\n        \n        string s = word + c;\n        \n        if (s.size() == 4 && s == \"word\") {\n            return true;\n        }\n        \n        if (c != 'o') return false;\n        \n        for (int k = -1; k <= 1; k++) {\n            for (int l = -1; l <= 1; l++) {\n                if (k == 0 && l == 0) continue;\n                \n                int x = i + k;\n                int y = j + l;\n                \n                if (x >= 0 && x < m && y >= 0 && y < n) {\n                    if (dfs(board, visited, s, x, y)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        board[i][j] = c;\n        visited[i][j] = false;\n        \n        return false;\n    }\n    \n    string getWord(vector<vector<char>>& board, vector<vector<bool>>& visited) {\n        int m = board.size();\n        int n = board[0].size();\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j]) return \"\";\n            }\n        }\n        \n        return \"word\";\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<char>> board1{{'A', 'B'}, {'C', 'D'}};\n    cout << \"[\";\n    for (auto& word : solution.findWords(board1)) {\n        cout << \"\\\"\" << word << \"\\\", \";\n    }\n    cout << \"]\\n\";\n    \n    // Test case 2\n    vector<vector<char>> board2{{'o', 'a', 'a'}, {'r', 'l', 'n'}, {'w', 'o', 'm'}};\n    cout << \"[\";\n    for (auto& word : solution.findWords(board2)) {\n        cout << \"\\\"\" << word << \"\\\", \";\n    }\n    cout << \"]\\n\";\n    \n    // Test case 3\n    vector<vector<char>> board3{{'a', 'a'}, {'b', 'c'}};\n    cout << \"[\";\n    for (auto& word : solution.findWords(board3)) {\n        cout << \"\\\"\" << word << \"\\\", \";\n    }\n    cout << \"]\\n\";\n    \n    return 0;\n}\n```",
  "844": "```\n#include <iostream>\n#include <string>\n\nbool backspaceCompare(std::string S, std::string T) {\n    int i = S.size() - 1;\n    int j = T.size() - 1;\n    while (i >= 0 || j >= 0) {\n        while (i >= 0 && (S[i] == '#' || S[i--] == '\\0'));\n        while (j >= 0 && (T[j] == '#' || T[j--] == '\\0'));\n        if (i < 0 && j < 0)\n            return true;\n        if (i < 0 || j < 0 || S[i] != T[j])\n            return false;\n        i--;\n        j--;\n    }\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha << backspaceCompare(\"a#\", \"c#\") << std::endl; // true\n    std::cout << std::boolalpha << backspaceCompare(\"ab#c\", \"ad#c\") << std::endl; // true\n    std::cout << std::boolalpha << backspaceCompare(\"bswh\", \"b\") << std::endl; // false\n    return 0;\n}",
  "845": "```\n#include <iostream>\n#include <vector>\n\nint longestMountain(std::vector<int>& arr) {\n    int n = arr.size();\n    int res = 0;\n    for (int i = 1; i < n - 1; ++i) {\n        if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {\n            int left = i - 1, right = i + 1;\n            while (left > 0 && arr[left] >= arr[left-1])\n                --left;\n            while (right < n-1 && arr[right] >= arr[right+1])\n                ++right;\n            res = std::max(res, right-left+1);\n        }\n    }\n    return res;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> arr1 = {2,2,3,4,5,6};\n    std::cout << \"Test Case 1: \" << longestMountain(arr1) << std::endl;\n\n    // Test case 2\n    std::vector<int> arr2 = {0,1,0,2,1,0,3,4,5,4,3,0,2,1};\n    std::cout << \"Test Case 2: \" << longestMountain(arr2) << std::endl;\n\n    // Test case 3\n    std::vector<int> arr3 = {9,8,7,6,5,4,3,2,1,0};\n    std::cout << \"Test Case 3: \" << longestMountain(arr3) << std::endl;\n    \n    return 0;\n}\n```",
  "846": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool isNStraightHand(std::vector<int>& hand, int W) {\n    if (hand.empty()) return true;\n    \n    std::sort(hand.begin(), hand.end());\n    for (int i = 0; i < hand.size(); i++) {\n        int start = i;\n        while (start + W <= hand.size() && hand[start] == hand[start+W-1]) {\n            start += W;\n        }\n        if (i != start) return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    std::vector<int> v1({1,2,3,2,2,2,4,5});\n    std::cout << std::boolalpha << isNStraightHand(v1, 3) << std::endl; // false\n    std::vector<int> v2({8,6,7,1,3,5});\n    std::cout << std::boolalpha << isNStraightHand(v2, 3) << std::endl; // true\n    std::vector<int> v3({1,2,4,2,4,3,4,5});\n    std::cout << std::boolalpha << isNStraightHand(v3, 4) << std::endl; // false\n    \n    return 0;\n}\n```",
  "847": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<vector<int>> dp(n, vector<int>(1 << n, INT_MAX));\n        dp[0][1] = 0;\n        \n        for (int mask = 1; mask < (1 << n); mask++) {\n            for (int node = 0; node < n; node++) {\n                if (((mask >> node) & 1)) {\n                    for (int neighbor : graph[node]) {\n                        int newMask = mask ^ (1 << node);\n                        dp[neighbor][newMask] = min(dp[neighbor][newMask], dp[node][mask] + 1);\n                    }\n                }\n            }\n        }\n        \n        int res = INT_MAX;\n        for (int i = 0; i < n; i++) {\n            res = min(res, dp[i][(1 << n) - 1]);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    vector<vector<int>> graph1 = {{2},{3},{4},{5}};\n    cout << Solution().shortestPathLength(graph1) << endl;\n\n    vector<vector<int>> graph2 = {{1,2},{2,3},{3,1},{1,3},{4,5}};\n    cout << Solution().shortestPathLength(graph2) << endl;\n\n    vector<vector<int>> graph3 = {{1},{2},{3},{4},{5},{6},{7}};\n    cout << Solution().shortestPathLength(graph3) << endl;\n\n    return 0;\n}\n```",
  "848": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int maxLength(const std::string& str) {\n        if (str.empty()) return 0;\n        \n        int n = str.size();\n        int res = 0, curr = 0;\n        for (int i = 0; i < n; ++i) {\n            curr += (str[i] - 'a' + 1) % 26;\n            res = std::max(res, curr);\n            if (res > 26) res -= 26;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::string str1 = \"abcdefg\";\n    int expected1 = 6;\n    if (solution.maxLength(str1) != expected1) {\n        std::cerr << \"Test case 1 failed\\n\";\n        return 1;\n    }\n\n    // Test case 2\n    std::string str2 = \"abcdefghijklmnopqrstuvwxyz\";\n    int expected2 = 26;\n    if (solution.maxLength(str2) != expected2) {\n        std::cerr << \"Test case 2 failed\\n\";\n        return 1;\n    }\n\n    // Test case 3\n    std::string str3 = \"zyxwvutsrqponmlkjihgfedcba\";\n    int expected3 = 26;\n    if (solution.maxLength(str3) != expected3) {\n        std::cerr << \"Test case 3 failed\\n\";\n        return 1;\n    }\n\n    std::cout << \"All test cases passed.\\n\";\n\n    return 0;\n}\n```",
  "849": "```\n#include <iostream>\n#include <vector>\n\nint maxDistToClosest(std::vector<int>& seats) {\n    int n = seats.size();\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!seats[i]) {\n            res = std::max(res, i / 2);\n        }\n    }\n    return res;\n}\n\nint main() {\n    // Test case 1:\n    std::vector<int> seats1 = {1,0,0,0};\n    int expected1 = 3;\n    if (expected1 != maxDistToClosest(seats1)) {\n        std::cerr << \"Test case 1 failed.\\n\";\n        return 1;\n    }\n\n    // Test case 2:\n    std::vector<int> seats2 = {0,0,1};\n    int expected2 = 2;\n    if (expected2 != maxDistToClosest(seats2)) {\n        std::cerr << \"Test case 2 failed.\\n\";\n        return 1;\n    }\n\n    // Test case 3:\n    std::vector<int> seats3 = {0,0,0};\n    int expected3 = 0;\n    if (expected3 != maxDistToClosest(seats3)) {\n        std::cerr << \"Test case 3 failed.\\n\";\n        return 1;\n    }\n\n    std::cout << \"All test cases passed.\\n\";\n    return 0;\n}\n```",
  "850": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxArea(vector<vector<int>>& height) {\n        if (height.empty()) return 0;\n        \n        int n = height.size();\n        vector<int> left(n), right(n);\n        \n        for (int i = 0; i < n; ++i)\n            left[i] = (i == 0 ? 0 : height[i-1][0]);\n        \n        for (int i = n - 1; i >= 0; --i)\n            right[i] = (i == n - 1 ? n - 1 : height[i+1][0]);\n        \n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans = max(ans, min(left[i], right[i]) * (height[i][0] - left[i]));\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> height1 = {{1,8,2},{2,1,9},{5,6,10}};\n    cout << \"Test case 1: Expected output is 36. Actual output is \" << solution.maxArea(height1) << endl;\n\n    // Test case 2\n    vector<vector<int>> height2 = {{3,1,2},{3,3,3},{4,5,6}};\n    cout << \"Test case 2: Expected output is 32. Actual output is \" << solution.maxArea(height2) << endl;\n\n    // Test case 3\n    vector<vector<int>> height3 = {{12,3,30,23,11}};\n    cout << \"Test case 3: Expected output is 20. Actual output is \" << solution.maxArea(height3) << endl;\n\n    return 0;\n}\n```",
  "852": "```\n#include <iostream>\n#include <vector>\n\nint findPeakElement(std::vector<int>& arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] > arr[mid + 1]) {\n            right = mid;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return arr[left];\n}\n\nint main() {\n    std::vector<int> testArray1 = {1, 2, 3, 1};\n    std::cout << \"Test case 1: \" << findPeakElement(testArray1) << std::endl;\n\n    std::vector<int> testArray2 = {1, 2, 1, 1, 3, 5, 4};\n    std::cout << \"Test case 2: \" << findPeakElement(testArray2) << std::endl;\n\n    std::vector<int> testArray3 = {0, 2};\n    std::cout << \"Test case 3: \" << findPeakElement(testArray3) << std::endl;\n    \n    return 0;\n}\n```",
  "851": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int loudAndRich(vector<vector<int>>& queries) {\n        vector<vector<int>> graph(101);\n        vector<int> rich(102, -1);\n\n        for (const auto& query : queries) {\n            int A = query[0];\n            int B = query[1];\n\n            if (rich[B] == -1) {\n                for (int i = 0; i < graph.size(); i++) {\n                    graph[i].clear();\n                }\n                rich.assign(102, -1);\n                rich[A] = B;\n                for (int i = A + 1; i <= 100; i++) {\n                    if (rich[i] == -1) {\n                        for (int j = i + 1; j <= 100; j++) {\n                            if (j != i && !rich[j]) {\n                                graph[i].push_back(j);\n                            }\n                        }\n                    }\n                }\n\n                int temp = B;\n                while (temp != -1) {\n                    rich[temp] = A;\n                    temp = rich[temp];\n                }\n            }\n        }\n\n        for (const auto& query : queries) {\n            int A = query[0];\n            cout << query[1] << \" can hear \" << rich[A + 1] << endl;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> queries1 = {{1, 2},{2,3},{4,5}};\n    solution.loudAndRich(queries1);\n\n    cout << \"\\n\";\n\n    vector<vector<int>> queries2 = {{1, 2},{2,3},{6,7}};\n    solution.loudAndRich(queries2);\n\n    cout << \"\\n\";\n\n    vector<vector<int>> queries3 = {{1, 4},{5,6},{10,15}};\n    solution.loudAndRich(queries3);\n\n    return 0;\n}\n```",
  "853": "```\n#include <iostream>\n#include <vector>\n\nint totalTravelTime(std::vector<int>& trucks) {\n    int n = trucks.size();\n    int maxTruckSpeed = 0;\n    for (int truck : trucks) {\n        if (truck > maxTruckSpeed) {\n            maxTruckSpeed = truck;\n        }\n    }\n\n    int time = 0;\n    for (int i = 0; i < n; i++) {\n        time += (maxTruckSpeed - trucks[i]) * 2;\n    }\n\n    return time;\n}\n\nint main() {\n    std::vector<int> fleet1 = {2,100};\n    std::cout << \"Fleet 1: \" << totalTravelTime(fleet1) << std::endl;\n\n    std::vector<int> fleet2 = {5,10,15,10};\n    std::cout << \"Fleet 2: \" << totalTravelTime(fleet2) << std::endl;\n\n    std::vector<int> fleet3 = {60,40};\n    std::cout << \"Fleet 3: \" << totalTravelTime(fleet3) << std::endl;\n\n    return 0;\n}\n```",
  "854": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool areKSimilar(string s, string t) {\n        queue<pair<int, int>> q;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] != t[i]) {\n                q.push({i, s[i] == 'a' ? 1 : -1});\n            }\n        }\n        \n        while (!q.empty()) {\n            int i = q.front().first;\n            int diff = q.front().second;\n            q.pop();\n            \n            if (s[i] != t[i]) {\n                return false;\n            }\n            \n            if (diff == 1) {\n                for (int j = i + 1; j < s.length(); j++) {\n                    if (t[j] > t[i]) {\n                        return false;\n                    }\n                }\n            } else {\n                for (int j = i + 1; j < s.length(); j++) {\n                    if (t[j] < t[i]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << boolalpha;\n    \n    // Test case 1\n    string s1 = \"aba\";\n    string t1 = \"caa\";\n    cout << \"Case 1: \" << solution.areKSimilar(s1, t1) << endl; // Expected output: false\n\n    // Test case 2\n    string s2 = \"axxinha\";\n    string t2 = \"axxiaxnha\";\n    cout << \"Case 2: \" << solution.areKSimilar(s2, t2) << endl; // Expected output: true\n\n    // Test case 3\n    string s3 = \"leetcode\";\n    string t3 = \"practice\";\n    cout << \"Case 3: \" << solution.areKSimilar(s3, t3) << endl; // Expected output: false\n\n    return 0;\n}\n```",
  "856": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    int scoreOfParentheses(std::string S) {\n        int score = 0;\n        int currentScore = 0;\n        int depth = 0;\n\n        for (int i = 0; i < S.size(); i++) {\n            if (S[i] == '(') {\n                depth++;\n            } else {\n                depth--;\n            }\n\n            if (depth > 0) {\n                currentScore += !S[i-1] ? 1 : 2;\n            } else {\n                score += currentScore * (currentScore % 2);\n                currentScore = 0;\n            }\n        }\n\n        return score;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test Case 1: \" << solution.scoreOfParentheses(\"(()())\") << std::endl; // Output: 4\n    std::cout << \"Test Case 2: \" << solution.scoreOfParentheses((\"]((()))[\") << std::endl; // Output: 10\n    std::cout << \"Test Case 3: \" << solution.scoreOfParentheses(\"()\") << std::endl; // Output: 2\n\n    return 0;\n}\n```",
  "855": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nclass ExamRoom {\npublic:\n    ExamRoom(int n) : seats(n), time(0) {}\n\n    int nextAvailable(int start, int end) {\n        if (start == end) return start;\n        return (end + start) / 2;\n    }\n\n    void examRoom(int n) {\n        int seat = nextAvailable(0, n);\n        for (int i = 1; i < n - 1; i++) {\n            int mid = (i + (n - i - 1)) / 2;\n            if (mid > seat) seat = mid;\n        }\n    }\n\n    void reserve(int start, int end) {\n        time++;\n        for (int i = start; i < end; i++) seats[i] = time;\n    }\n\n    std::vector<int> getReserved() {\n        std::vector<int> res;\n        for (int i = 0; i < seats.size(); i++) if (seats[i] != 0) res.push_back(i);\n        return res;\n    }\n\n};\n\nint main() {\n    ExamRoom er1(4);\n    er1.examRoom(2);\n    std::cout << \"Reserved seats: \";\n    for (int seat : er1.getReserved()) std::cout << seat << \" \";\n    std::cout << std::endl;\n\n    ExamRoom er2(3);\n    er2.examRoom(5);\n    std::cout << \"Reserved seats: \";\n    for (int seat : er2.getReserved()) std::cout << seat << \" \";\n    std::cout << std::endl;\n\n    ExamRoom er3(7);\n    er3.examRoom(4);\n    std::cout << \"Reserved seats: \";\n    for (int seat : er3.getReserved()) std::cout << seat << \" \";\n    std::cout << std::endl;\n}\n```",
  "858": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> reflect(std::vector<int>& p) {\n        int x = p[0];\n        int y = p[1];\n        return {x, -y};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> p1 = {1, 2};\n    std::vector<int> result1 = solution.reflect(p1);\n    if (result1 != std::vector<int>{1, -2}) {\n        std::cerr << \"Test case 1 failed\" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    std::vector<int> p2 = {-3, 4};\n    std::vector<int> result2 = solution.reflect(p2);\n    if (result2 != std::vector<int>{-3, -4}) {\n        std::cerr << \"Test case 2 failed\" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    std::vector<int> p3 = {5, 6};\n    std::vector<int> result3 = solution.reflect(p3);\n    if (result3 != std::vector<int>{5, -6}) {\n        std::cerr << \"Test case 3 failed\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed\" << std::endl;\n    return 0;\n}\n```",
  "857": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double mincostToHireKWorkers(vector<int>& wages, vector<int>& workingHours) {\n        auto worker = [&](int w, int h) { return -1.0 * (double)(w / h); };\n        priority_queue<pair<double, pair<int, int>>, vector<pair<double, pair<int, int>>>, greater<>> pq;\n        \n        for(int i=0; i<wages.size(); i++) {\n            pq.push({worker(wages[i], workingHours[i]), {wages[i], workingHours[i]}});\n        }\n        \n        double ans = 0.0;\n        for(int i=0; i<k; i++) {\n            auto w = pq.top().second.first;\n            auto h = pq.top().second.second;\n            ans += (double)w;\n            pq.pop();\n        }\n        \n        return ans;\n    }\n};\n\nint k = 3;\n\nint main() {\n    Solution solution;\n    \n    vector<int> wages1 = {16,2,7};\n    vector<int> workingHours1 = {4,6,5};\n    cout << fixed << setprecision(10) << solution.mincostToHireKWorkers(wages1, workingHours1) << endl;\n    \n    vector<int> wages2 = {10,2,5,1};\n    vector<int> workingHours2 = {15,10,4,8};\n    cout << fixed << setprecision(10) << solution.mincostToHireKWorkers(wages2, workingHours2) << endl;\n    \n    vector<int> wages3 = {3,1,2};\n    vector<int> workingHours3 = {5,2,7};\n    cout << fixed << setprecision(10) << solution.mincostToHireKWorkers(wages3, workingHours3) << endl;\n    \n    return 0;\n}",
  "859": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool hasBuddy(string s) {\n        vector<int> count(26, 0);\n        for (char c : s) {\n            count[c - 'a']++;\n        }\n        int odd = 0;\n        for (int i = 0; i < 26; i++) {\n            if ((count[i] % 2) != 0) {\n                if (odd > 1) return false;\n                odd++;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution s;\n\n    cout << boolalpha << s.hasBuddy(\"abba\") << endl; // Expected: true\n    cout << boolalpha << s.hasBuddy(\"telxmx\") << endl; // Expected: false\n    cout << boolalpha << s.hasBuddy(\"aa\") << endl;     // Expected: true\n\n    return 0;\n}\n```",
  "860": "```\n#include <iostream>\n#include <vector>\n\nbool LemonadeChange(std::vector<int>& bills) {\n    int five = 0;\n    int ten = 0;\n\n    for (int bill : bills) {\n        if (bill == 5) {\n            five++;\n        } else if (bill == 10) {\n            if (five > 0) {\n                five--;\n                ten++;\n            } else {\n                return false;\n            }\n        } else {\n            while (ten > 0 && five > 0) {\n                five--;\n                ten--;\n            }\n            if (five < bill) {\n                return false;\n            }\n            while (bill > 5) {\n                bill -= 5;\n            }\n            five = bill;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<int> bills1 = {10, 20};\n    std::cout << \"Test case 1: \" << (LemonadeChange(bills1) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> bills2 = {5, 5, 5, 10, 20};\n    std::cout << \"Test case 2: \" << (LemonadeChange(bills2) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> bills3 = {5};\n    std::cout << \"Test case 3: \" << (LemonadeChange(bills3) ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n```",
  "861": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int matrixScore(vector<vector<int>>& grid) {\n        int n = grid.size();\n        for (int i = 0; i < n; ++i) {\n            if (!grid[i][0]) {\n                for (int j = 0; j < n; ++j) {\n                    grid[j][i] = 1 - grid[j][i];\n                }\n            }\n        }\n        int score = 0;\n        for (int i = 0; i < n; ++i) {\n            int ones = 0;\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j]) ones++;\n            }\n            score += (1 << (n - 1 - ones));\n        }\n        return score;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> grid1 = {{0,0,1},{1,1,1},{1,0,1}};\n    cout << \"Test case 1: \" << solution.matrixScore(grid1) << endl;\n\n    vector<vector<int>> grid2 = {{0,0,0},{0,0,1}};\n\n    cout << \"Test case 2: \" << solution.matrixScore(grid2) << endl;\n\n    vector<vector<int>> grid3 = {{1,1,1,1},{1,0,0,1},{1,1,1,1},{1,0,0,1}};\n    cout << \"Test case 3: \" << solution.matrixScore(grid3) << endl;\n}\n```",
  "862": "```\n#include <iostream>\n#include <vector>\n\nint shortestSubArray(std::vector<int>& arr, int k) {\n    int n = arr.size();\n    long long prefixSum[n + 1];\n    for (int i = 0; i < n; ++i)\n        prefixSum[i] = prefixSum[i - 1] + arr[i];\n\n    int res = n;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            if (prefixSum[j + 1] - prefixSum[i] >= k)\n                res = std::min(res, j - i + 1);\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> arr1 = {4, 3, 2, 3, 5, 5};\n    int k1 = 9;\n    int result1 = shortestSubArray(arr1, k1);\n    if (result1 == 3) {\n        std::cout << \"Test case 1: Pass\\n\";\n    } else {\n        std::cout << \"Test case 1: Fail (\" << result1 << \" expected)\\n\";\n    }\n\n    // Test case 2\n    std::vector<int> arr2 = {1, 2};\n    int k2 = 3;\n    int result2 = shortestSubArray(arr2, k2);\n    if (result2 == 2) {\n        std::cout << \"Test case 2: Pass\\n\";\n    } else {\n        std::cout << \"Test case 2: Fail (\" << result2 << \" expected)\\n\";\n    }\n\n    // Test case 3\n    std::vector<int> arr3 = {10, 1};\n    int k3 = 20;\n    int result3 = shortestSubArray(arr3, k3);\n    if (result3 == 2) {\n        std::cout << \"Test case 3: Pass\\n\";\n    } else {\n        std::cout << \"Test case 3: Fail (\" << result3 << \" expected)\\n\";\n    }\n\n    return 0;\n}\n```",
  "863": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    std::vector<int> distanceK(TreeNode* root, TreeNode* target, int K) {\n        std::vector<std::pair<TreeNode*, int>> nodes;\n        dfs(root, NULL, &nodes);\n        std::vector<int> res;\n        for (const auto& node : nodes) {\n            if (std::abs(node.second - K) <= K) {\n                res.push_back(node.first->val);\n            }\n        }\n        return res;\n    }\n\nprivate:\n    void dfs(TreeNode* root, TreeNode* parent, std::vector<std::pair<TreeNode*, int>>* nodes) {\n        if (!root) return;\n        int val = root->val;\n        if (parent) {\n            (*nodes).push_back({root, parent->val});\n        }\n        if (root->left) dfs(root->left, root, nodes);\n        if (root->right) dfs(root->right, root, nodes);\n    }\n};\n\nint main() {\n    TreeNode* node1 = new TreeNode(3);\n    TreeNode* node2 = new TreeNode(5);\n    TreeNode* node3 = new TreeNode(1);\n    TreeNode* node4 = new TreeNode(6);\n    TreeNode* node5 = new TreeNode(2);\n    TreeNode* node6 = new TreeNode(0);\n\n    node1->left = node2;\n    node1->right = node3;\n    node2->left = node4;\n    node2->right = node5;\n    node3->right = node6;\n\n    Solution solution;\n    std::vector<int> res1 = solution.distanceK(node1, node2, 3);\n    for (int val : res1) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n\n    TreeNode* node7 = new TreeNode(5);\n    TreeNode* node8 = new TreeNode(4);\n    TreeNode* node9 = new TreeNode(2);\n\n    node7->left = node8;\n    node7->right = node9;\n\n    solution.distanceK(node7, node7, 1); // No nodes at distance K\n\n    std::vector<int> res3 = solution.distanceK(node7, node8, 2);\n    for (int val : res3) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "864": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint shortestToChar(string s, char c) {\n    vector<int> dist(s.size(), s.size());\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == c) {\n            for (int j = max(0, i-1); j >= 0; --j) {\n                dist[j] = min(dist[j], i - j);\n            }\n            for (int j = i+1; j < s.size(); ++j) {\n                dist[j] = min(dist[j], j - i);\n            }\n        }\n    }\n\n    int res = 0;\n    queue<pair<int, bool>> q;\n    q.push({0, false});\n    while (!q.empty()) {\n        pair<int, bool> p = q.front();\n        q.pop();\n        if (p.second) {\n            res = p.first;\n            break;\n        }\n        for (int i = max(0, p.first-1); i >= 0; --i) {\n            if (dist[i] == res+1) {\n                q.push({i, true});\n            } else if (res > dist[i]) {\n                res = dist[i];\n            }\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    cout << shortestToChar(\"loveletters\", 'l') << endl;  // Output: 1\n    cout << shortestToChar(\"hello\", 'h') << endl;      // Output: 0\n    cout << shortestToChar(\"aeiou\", 'a') << endl;     // Output: 0\n\n    return 0;\n}\n```",
  "866": "```\n#include <iostream>\n#include <string>\n\nbool isPrime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++)\n        if (n % i == 0) return false;\n    return true;\n}\n\nstd::string genPalindromes(int low, int high) {\n    std::string result;\n    for (int i = low; i <= high; i++) {\n        if (isPrime(i)) {\n            std::string str = std::to_string(i);\n            bool isPalindrome = true;\n            for (int j = 0; j < str.length() / 2; j++) {\n                if (str[j] != str[str.length() - 1 - j]) {\n                    isPalindrome = false;\n                    break;\n                }\n            }\n            if (isPalindrome) result += str + \"\\n\";\n        }\n    }\n    return result;\n}\n\nint main() {\n    int low = 10, high = 100;\n    std::cout << genPalindromes(low, high);\n\n    low = 1; high = 20;\n    std::cout << genPalindromes(low, high);\n\n    low = 50; high = 5000;\n    std::cout << genPalindromes(low, high);\n}\n```",
  "865": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* subtreeWithAllDeepest(TreeNode* root) {\n        if (!root) return NULL;\n        return helper(root, 0).first;\n    }\n\nprivate:\n    pair<TreeNode*, int> helper(TreeNode* node, int depth) {\n        if (!node) return make_pair(NULL, -1);\n        pair<TreeNode*, int> left = helper(node->left, depth + 1);\n        pair<TreeNode*, int> right = helper(node->right, depth + 1);\n        if (depth > left.second && depth > right.second) {\n            return make_pair(node, depth);\n        }\n        if (left.second > right.second) {\n            return left;\n        }\n        return right;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* root = new TreeNode(3);\n    root->left = new TreeNode(5);\n    root->right = new TreeNode(1);\n    root->left->left = new TreeNode(6);\n    root->left->right = new TreeNode(2);\n    root->right->left = new TreeNode(0);\n    root->right->right = new TreeNode(8);\n    cout << \"Test Case 1: \";\n    cout << solution.subtreeWithAllDeepest(root)->val << endl;\n\n    // Test Case 2\n    root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(3);\n    root->left->left = new TreeNode(4);\n    root->left->right = new TreeNode(5);\n    cout << \"Test Case 2: \";\n    cout << solution.subtreeWithAllDeepest(root)->val << endl;\n\n    // Test Case 3\n    root = new TreeNode(1);\n    root->left = new TreeNode(2);\n    cout << \"Test Case 3: \";\n    cout << solution.subtreeWithAllDeepest(root)->val << endl;\n    \n    return 0;\n}\n```",
  "868": "```\n#include <iostream>\n#include <string>\n\nint findMaxGap(const std::string& N) {\n    int maxGap = 0;\n    bool foundStartBit = false;\n\n    for (char c : N) {\n        if (c == '1') {\n            if (foundStartBit) {\n                maxGap = std::max(maxGap, (int)(N.length() - N.find(c)) - foundStartBit);\n            }\n            foundStartBit = true;\n        } else if (foundStartBit) {\n            foundStartBit = false;\n        }\n    }\n\n    return maxGap;\n}\n\nint main() {\n    std::cout << findMaxGap(\"10000001000110000\") << std::endl;  // Expected output: 5\n    std::cout << findMaxGap(\"1101111111100000\") << std::endl;  // Expected output: 3\n    std::cout << findMaxGap(\"00000010101100001\") << std::endl;  // Expected output: 4\n\n    return 0;\n}\n```",
  "867": "```\n#include <iostream>\n#include <vector>\n\nvoid transpose(std::vector<std::vector<int>>& matrix) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            std::swap(matrix[i][j], matrix[j][i]);\n        }\n    }\n}\n\nvoid printMatrix(const std::vector<std::vector<int>>& matrix) {\n    int rows = matrix.size();\n    int cols = matrix[0].size();\n\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            std::cout << matrix[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::vector<int>> testMatrix1 = {{1, 2, 3}, {4, 5, 6}};\n    std::cout << \"Original Matrix: \";\n    printMatrix(testMatrix1);\n    transpose(testMatrix1);\n    std::cout << \"Transposed Matrix: \";\n    printMatrix(testMatrix1);\n    std::cout << std::endl;\n\n    // Test Case 2\n    std::vector<std::vector<int>> testMatrix2 = {{7, 8}, {9, 10}};\n    std::cout << \"Original Matrix: \";\n    printMatrix(testMatrix2);\n    transpose(testMatrix2);\n    std::cout << \"Transposed Matrix: \";\n    printMatrix(testMatrix2);\n    std::cout << std::endl;\n\n    // Test Case 3\n    std::vector<std::vector<int>> testMatrix3 = {{11, 12}, {13, 14}, {15, 16}};\n    std::cout << \"Original Matrix: \";\n    printMatrix(testMatrix3);\n    transpose(testMatrix3);\n    std::cout << \"Transposed Matrix: \";\n    printMatrix(testMatrix3);\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "869": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool reorderedPowerOf2(int N) {\n    int count[10] = {0};\n    while (N) {\n        count[N % 10]++;\n        N /= 10;\n    }\n    if (!count[0]) {\n        for (int i = 1; i <= 9; i++) {\n            if (!count[i])\n                return false;\n        }\n        return true;\n    } else {\n        for (int i = 1; i <= 9; i++) {\n            if (count[i] > count[0])\n                return false;\n        }\n        return true;\n    }\n}\n\nint main() {\n    std::vector<int> testCases = {1, 46, 256};\n\n    for (auto testCase : testCases) {\n        if (reorderedPowerOf2(testCase)) {\n            std::cout << \"Test case \" << testCase << \": Reordered power of 2.\" << std::endl;\n        } else {\n            std::cout << \"Test case \" << testCase << \": Not a reordered power of 2.\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "870": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> advantageShuffle(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int left = 0, right = nums.size() - 1;\n    std::vector<int> result;\n\n    while (left <= right) {\n        if (nums[left] < nums[right]) {\n            result.push_back(nums[right]);\n            right--;\n        } else {\n            result.push_back(nums[left]);\n            left++;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<int> nums1 = {2, 1, 4};\n    std::cout << \"Test case 1: \";\n    for (int num : advantageShuffle(nums1)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums2 = {4, 3, 1, 2};\n    std::cout << \"Test case 2: \";\n    for (int num : advantageShuffle(nums2)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums3 = {10, 4, 5, 8};\n    std::cout << \"Test case 3: \";\n    for (int num : advantageShuffle(nums3)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "871": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minRefuelStops(int target, vector<int>& start, vector<int>& mpg) {\n        int n = start.size();\n        vector<long long> dp(n+1, -1e9);\n        dp[0] = 0;\n        for (int i = 0; i < n; ++i) {\n            while (start[i] + mpg[i] * (i > 0 ? dp[i-1]+1 : 1) <= target) {\n                if (dp[i] == -1e9) break;\n                dp[i+1] = max(dp[i+1], dp[i]);\n            }\n        }\n        int ans = 0;\n        for (int i = n; i > 0; --i) {\n            while (start[i-1] + mpg[i-1] * (i > 1 ? dp[i-2]+1 : 1) <= target) {\n                if (dp[i-1] == -1e9) break;\n                ans = max(ans, dp[i-1]);\n                start[i-1] += mpg[i-1];\n            }\n        }\n        return ans + (target > start.back());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int target = 100;\n    vector<int> start1 = {10};\n    vector<int> mpg1 = {10};\n    cout << \"Test case 1: \" << solution.minRefuelStops(target, start1, mpg1) << endl;  // Expected output: 0\n\n    // Test case 2\n    int target2 = 100;\n    vector<int> start2 = {1,3,15};\n    vector<int> mpg2 = {2,3,5};\n    cout << \"Test case 2: \" << solution.minRefuelStops(target2, start2, mpg2) << endl;  // Expected output: 3\n\n    // Test case 3\n    int target3 = 25;\n    vector<int> start3 = {10,20};\n    vector<int> mpg3 = {5,15};\n    cout << \"Test case 3: \" << solution.minRefuelStops(target3, start3, mpg3) << endl;  // Expected output: 2\n\n    return 0;\n}\n```",
  "872": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        vector<int> leaves1;\n        vector<int> leaves2;\n\n        dfs(root1, NULL, leaves1);\n        dfs(root2, NULL, leaves2);\n\n        return equal(leaves1.begin(), leaves1.end(), leaves2.begin());\n    }\n\n    void dfs(TreeNode* node, TreeNode* parent, vector<int>& leaves) {\n        if (!node->left && !node->right) {\n            if (parent != NULL)\n                leaves.push_back(node->val);\n        } else {\n            if (parent != NULL) {\n                if (parent->left == node) {\n                    dfs(node->left, node, leaves);\n                    dfs(node->right, node, leaves);\n                } else {\n                    dfs(node->right, node, leaves);\n                    dfs(node->left, node, leaves);\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(5);\n    root1->right = new TreeNode(1);\n    root1->right->left = new TreeNode(2);\n    root1->right->right = new TreeNode(4);\n\n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(5);\n    root2->right = new TreeNode(2);\n\n    cout << solution.leafSimilar(root1, root2) << endl; // Output: 1\n\n    // Test case 2:\n    root1 = new TreeNode(1);\n    root1->right = new TreeNode(3);\n    root1->right->left = new TreeNode(2);\n    root1->right->right = new TreeNode(4);\n\n    root2 = new TreeNode(1);\n    root2->right = new TreeNode(4);\n\n    cout << solution.leafSimilar(root1, root2) << endl; // Output: 0\n\n    // Test case 3:\n    root1 = new TreeNode(6);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(8);\n    root1->left->left = new TreeNode(7);\n    root1->left->right = new TreeNode(4);\n    root1->right = new TreeNode(9);\n\n    root2 = new TreeNode(6);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(7);\n\n    cout << solution.leafSimilar(root1, root2) << endl; // Output: 1\n\n    return 0;\n}\n```",
  "873": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        unordered_map<int, vector<int>> mp;\n        for (int i = 0; i < A.size(); i++) {\n            mp[A[i]].push_back(i);\n        }\n        \n        int n = A.size();\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int a = A[i], b = A[j];\n                int len = 2;\n                while (true) {\n                    int c = a + b;\n                    if (c >= n || mp[c].empty()) break;\n                    for (int k : mp[c]) {\n                        if (k != i && k != j && mp[a].size() > 0 && mp[b].size() > 0 && \n                            mp[a][0] < k && mp[b][0] < k) {\n                            len = max(len, mp[a].size() + mp[b].size() - 1);\n                        }\n                    }\n                    a = b;\n                    b = c;\n                }\n                res = max(res, len);\n            }\n        }\n        return res >= 3 ? res : 0;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> A1({1,2,3,4,5,6,7,8});\n    cout << \"Test Case 1: \" << solution.lenLongestFibSubseq(A1) << endl;\n    \n    // Test case 2\n    vector<int> A2({1,3,7,10,12,15,21,25,30});\n    cout << \"Test Case 2: \" << solution.lenLongestFibSubseq(A2) << endl;\n    \n    // Test case 3\n    vector<int> A3({5,5,5});\n    cout << \"Test Case 3: \" << solution.lenLongestFibSubseq(A3) << endl;\n    \n    return 0;\n}\n```",
  "875": "```\n#include <iostream>\n#include <vector>\n\nint minEatingTime(std::vector<int>& piles, int k) {\n    int left = 0;\n    int right = 0;\n    for (int pile : piles) {\n        right += pile;\n    }\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        int eaten = 0;\n        int i = 0;\n        for (; i < piles.size(); ++i) {\n            eaten += min(mid, piles[i]);\n            if (eaten >= k) break;\n        }\n        \n        if (eaten >= k) right = mid - 1;\n        else left = mid + 1;\n    }\n    \n    return left;\n}\n\nint main() {\n    std::vector<int> piles1 = {2,0,4};\n    int k1 = 3;\n    std::cout << minEatingTime(piles1, k1) << std::endl;\n\n    std::vector<int> piles2 = {982911, 1232119, 987147, 1071305, 1041437};\n    int k2 = 1026;\n    std::cout << minEatingTime(piles2, k2) << std::endl;\n\n    std::vector<int> piles3 = {4,10};\n    int k3 = 5;\n    std::cout << minEatingTime(piles3, k3) << std::endl;\n\n    return 0;\n}\n```",
  "874": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> robotSim(int xMove, int yMove, int targetX, int targetY) {\n        vector<int> result(2, 0);\n        int currX = 0, currY = 0;\n        \n        for (int i = 0; i < targetX || i < targetY; i++) {\n            if (xMove > yMove) {\n                if (currX >= targetX) break;\n                currX++;\n            } else if (yMove > xMove) {\n                if (currY >= targetY) break;\n                currY++;\n            } else {\n                if (abs(currX - targetX) + abs(currY - targetY) <= 0) break;\n                if (currX < targetX && currY < targetY) {\n                    currX++;\n                    currY++;\n                } else if (currX > targetX || currY > targetY) {\n                    currX--;\n                    currY--;\n                } else if (abs(currX - targetX) <= abs(currY - targetY)) {\n                    currX++;\n                } else {\n                    currY++;\n                }\n            }\n        }\n        \n        result[0] = currX;\n        result[1] = currY;\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<int> result1 = solution.robotSim(3, 2, 0, 0);\n    for (int i : result1) cout << i << \" \";\n    cout << endl; // Output: 0 0\n    \n    vector<int> result2 = solution.robotSim(5, 4, 3, 3);\n    for (int i : result2) cout << i << \" \";\n    cout << endl; // Output: 3 3\n    \n    vector<int> result3 = solution.robotSim(1, 0, 2, 2);\n    for (int i : result3) cout << i << \" \";\n    cout << endl; // Output: 2 2\n    \n    return 0;\n}\n```",
  "876": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* middleNode(ListNode* head) {\n    ListNode* slow = head;\n    ListNode* fast = head;\n    \n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    return slow;\n}\n\nint main() {\n    // Test case 1\n    ListNode* node1 = new ListNode(1);\n    ListNode* node2 = new ListNode(2);\n    ListNode* node3 = new ListNode(3);\n    ListNode* node4 = new ListNode(4);\n    ListNode* node5 = new ListNode(5);\n\n    node1->next = node2;\n    node2->next = node3;\n    node3->next = node4;\n    node4->next = node5;\n\n    ListNode* head = node1;\n    \n    ListNode* middle = middleNode(head);\n    \n    cout << \"Middle node: \" << middle->val << endl;\n\n    // Test case 2\n    node1 = new ListNode(1);\n    node2 = new ListNode(2);\n\n    node1->next = node2;\n\n    head = node1;\n    \n    middle = middleNode(head);\n    \n    cout << \"Middle node: \" << middle->val << endl;\n\n    // Test case 3\n    node1 = new ListNode(1);\n\n    head = node1;\n    \n    middle = middleNode(head);\n    \n    cout << \"Middle node: \" << middle->val << endl;\n\n    return 0;\n}\n```",
  "877": "```\n#include <iostream>\n#include <vector>\n\nint stoneGameArray(std::vector<int>& piles) {\n    int n = piles.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = piles[i];\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i + len - 1 < n; i++) {\n            int j = i + len - 1;\n            if (len % 2 == 0) {\n                dp[i][j] = std::max(piles[i] + dp[i + 1][j], piles[j] + dp[i][j - 1]);\n            } else {\n                dp[i][j] = std::min(dp[i + 1][j], dp[i][j - 1]) - piles[(i + j) / 2];\n            }\n        }\n    }\n    return dp[0][n - 1];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> piles1 = {5,3,4,5};\n    std::cout << \"Test case 1: \" << stoneGameArray(piles1) << std::endl;\n\n    // Test case 2\n    std::vector<int> piles2 = {6,2,7,1,2,7};\n    std::cout << \"Test case 2: \" << stoneGameArray(piles2) << std::endl;\n\n    // Test case 3\n    std::vector<int> piles3 = {100};\n    std::cout << \"Test case 3: \" << stoneGameArray(piles3) << std::endl;\n    \n    return 0;\n}\n```",
  "878": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findNthMagicalNumber(int n, int start, int end) {\n        vector<int> primes;\n        for (int i = start; ; i += 2) {\n            bool isPrime = true;\n            for (int j = 3; j * j <= i; j += 2) {\n                if (i % j == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) primes.push_back(i);\n            if (primes.size() == n) break;\n        }\n\n        int low = start, high = end;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            int count = 0;\n            for (int prime : primes) {\n                if (mid % prime == 0) count++;\n            }\n            if (count >= n) high = mid - 1;\n            else low = mid + 1;\n        }\n\n        return low;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.findNthMagicalNumber(5, 2, 1000000) << endl; // Expected output: 4\n    cout << \"Test case 2: \" << solution.findNthMagicalNumber(3, 1, 10) << endl; // Expected output: 6\n    cout << \"Test case 3: \" << solution.findNthMagicalNumber(4, 1, 20000) << endl; // Expected output: 12288\n\n    return 0;\n}\n```",
  "879": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint profitableSchemes(int n, int minProfit, vector<vector<int>>& group) {\n    vector<vector<int>> dp(n + 1, vector<int>(minProfit + 1));\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j <= minProfit; j++) {\n            if (j < group[i - 1][0]) {\n                dp[i][j] = dp[i - 1][j];\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][max(0, j - group[i - 1][0])] + group[i - 1][1]);\n            }\n        }\n    }\n    \n    int result = 0;\n    for (int i = 0; i <= minProfit; i++) {\n        if (dp[n][i] >= minProfit) {\n            result++;\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    vector<vector<int>> group1 = {{2, 6}, {1, 8}};\n    cout << profitableSchemes(4, 6, group1) << endl; // Output: 2\n\n    vector<vector<int>> group2 = {{2, 3}};\n    cout << profitableSchemes(4, 5, group2) << endl; // Output: 0\n\n    vector<vector<int>> group3 = {{1, 3}, {2, 3}};\n    cout << profitableSchemes(3, 9, group3) << endl; // Output: 1\n    return 0;\n}\n```",
  "880": "```\n#include <iostream>\n#include <vector>\n#include <stack>\n\nclass Solution {\npublic:\n    std::string decodeAtIndex(std::string s, int k) {\n        long length = 0;\n        char c;\n        for (long i = 0; i < s.size(); i++) {\n            if (s[i] == '[') length++;\n            else if (s[i] == ']') length--;\n            else if (c = s[i], c >= 'a' && c <= 'z') {\n                while (length > 1) {\n                    k %= length;\n                    for (long j = i; j < s.size() && s[j] != '['; j++) {\n                        if (!--k) return s.substr(i, j - i + 1);\n                    }\n                }\n                if (!--k) return std::string(1, c);\n            }\n        }\n        return \"\";\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    std::cout << \"Test Case 1: \";\n    std::cout << solution.decodeAtIndex(\"RLEencode[ab]cd[RQ[qz]]\", 8) << std::endl;\n    \n    // Test case 2\n    std::cout << \"Test Case 2: \";\n    std::cout << solution.decodeAtIndex(\"a5b[cde]3[fh]\", 6) << std::endl;\n    \n    // Test case 3\n    std::cout << \"Test Case 3: \";\n    std::cout << solution.decodeAtIndex(\"RLEencode[ab]cd[RQ[qz]]\", 14) << std::endl;\n    \n    return 0;\n}\n```",
  "881": "```\n#include <iostream>\n#include <vector>\n\nint numRescueBoats(std::vector<int>& people) {\n    int left = 0;\n    int right = people.size() - 1;\n    int ans = 0;\n\n    std::sort(people.begin(), people.end());\n\n    while (left <= right) {\n        if ((people[left] + people[right]) <= 2) {\n            left++;\n            right--;\n        } else {\n            right--;\n        }\n        ans++;\n    }\n\n    return ans;\n}\n\nint main() {\n    // Test case 1:\n    std::vector<int> people1 = {1, 2};\n    int result1 = numRescueBoats(people1);\n    if (result1 == 1) {\n        std::cout << \"Test case 1 passed.\\n\";\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 1, Got: \" << result1 << \"\\n\";\n    }\n\n    // Test case 2:\n    std::vector<int> people2 = {3, 2, 2, 1};\n    int result2 = numRescueBoats(people2);\n    if (result2 == 3) {\n        std::cout << \"Test case 2 passed.\\n\";\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 3, Got: \" << result2 << \"\\n\";\n    }\n\n    // Test case 3:\n    std::vector<int> people3 = {1, 5};\n    int result3 = numRescueBoats(people3);\n    if (result3 == 2) {\n        std::cout << \"Test case 3 passed.\\n\";\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 2, Got: \" << result3 << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "883": "```\n#include <iostream>\n#include <vector>\n\nint surfaceArea(std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] > 0) {\n                ans += 2; // sides\n                if (i == 0 || grid[i-1][j] < grid[i][j]) ans++; // top\n                if (i == n - 1 || grid[i+1][j] < grid[i][j]) ans++; // bottom\n                if (j == 0 || grid[i][j-1] < grid[i][j]) ans++; // left\n                if (j == n - 1 || grid[i][j+1] < grid[i][j]) ans++; // right\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::vector<std::vector<int>> grid1 = {{2}};\n    std::cout << \"Test case 1: \" << surfaceArea(grid1) << std::endl;\n\n    std::vector<std::vector<int>> grid2 = {{1,2},{3,4}};\n    std::cout << \"Test case 2: \" << surfaceArea(grid2) << std::endl;\n\n    std::vector<std::vector<int>> grid3 = {{1,1,1},{1,0,5},{4,4,4}};\n    std::cout << \"Test case 3: \" << surfaceArea(grid3) << std::endl;\n    \n    return 0;\n}\n```",
  "882": "```\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    int reachableNodes(vector<vector<int>>& edges, int n, vector<vector<int>>& restrictions) {\n        int res = 0;\n        vector<vector<pair<int, int>>> adj(n);\n        for (auto& edge : edges) {\n            adj[edge[0]].push_back({edge[1], edge[2]});\n            adj[edge[1]].push_back({edge[0], edge[2]});\n        }\n        \n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        for (int i = 0; i < n; i++) {\n            if (i == restrictions[0][0] || i == restrictions[0][1]) continue;\n            pq.push({edges[i][2], i});\n        }\n        \n        while (!pq.empty()) {\n            int node = pq.top().second;\n            int cost = pq.top().first;\n            pq.pop();\n            \n            for (auto& neighbor : adj[node]) {\n                if (neighbor.second > 0) {\n                    int nextNode = neighbor.first;\n                    int nextCost = neighbor.second - cost;\n                    \n                    if (nextCost < 0) continue;\n                    \n                    for (int i = 0; i < restrictions.size(); i++) {\n                        if (restrictions[i][0] == node && restrictions[i][1] == nextNode) {\n                            if (nextCost > restrictions[i][2]) break;\n                            else nextCost -= restrictions[i][2];\n                            continue;\n                        }\n                    }\n                    \n                    pq.push({nextCost, nextNode});\n                    res += cost;\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> edges1 = {{0,1,10},{0,2,3},{1,2,12}};\n    vector<vector<int>> restrictions1 = {{1,2,2}};\n    cout << \"Test case 1: \" << solution.reachableNodes(edges1, 3, restrictions1) << endl;\n    \n    // Test case 2\n    vector<vector<int>> edges2 = {{0,1,5},{1,2,10},{2,3,15}};\n    vector<vector<int>> restrictions2 = {{0,1,4}};\n    cout << \"Test case 2: \" << solution.reachableNodes(edges2, 4, restrictions2) << endl;\n    \n    // Test case 3\n    vector<vector<int>> edges3 = {{0,1,10},{1,2,5},{2,3,15}};\n    vector<vector<int>> restrictions3 = {};\n    cout << \"Test case 3: \" << solution.reachableNodes(edges3, 4, restrictions3) << endl;\n    \n    return 0;\n}\n```",
  "885": "```\n#include <iostream>\n#include <vector>\n\nint countSpiralNumbers(int R) {\n    if (R == 1)\n        return 1;\n    int result = 4 * (R / 2) + ((R % 2 != 0) ? 1 : 0);\n    return result;\n}\n\nint main() {\n    std::vector<int> testCases{1, 3, 5};\n    for (const auto& testCase : testCases) {\n        int result = countSpiralNumbers(testCase);\n        std::cout << \"Number of Spiral Numbers in a matrix of size \" << testCase << \"x\" << testCase << \": \" << result << std::endl;\n    }\n    return 0;\n}\n```",
  "884": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> uncommonFromSentences(string s1, string s2) {\n        map<string, int> wordCount;\n        vector<string> result;\n        \n        string temp = \"\";\n        for (char c : s1 + \" \" + s2) {\n            if (c == ' ') {\n                if (wordCount[temp] == 0) {\n                    result.push_back(temp);\n                }\n                temp = \"\";\n            } else {\n                temp += c;\n                wordCount[temp]++;\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    string s1 = \"this apple is good\";\n    string s2 = \"apple pen\";\n    vector<string> expectedResult = {\"good\", \"pen\"};\n    vector<string> actualResult = solution.uncommonFromSentences(s1, s2);\n    for (int i = 0; i < actualResult.size(); i++) {\n        if (actualResult[i] != expectedResult[i]) {\n            cout << \"Test Case 1 Failed\" << endl;\n            return -1;\n        }\n    }\n    cout << \"Test Case 1 Passed\" << endl;\n\n    // Test Case 2\n    s1 = \"\";\n    s2 = \"apple\";\n    expectedResult = vector<string> {\"apple\"};\n    actualResult = solution.uncommonFromSentences(s1, s2);\n    for (int i = 0; i < actualResult.size(); i++) {\n        if (actualResult[i] != expectedResult[i]) {\n            cout << \"Test Case 2 Failed\" << endl;\n            return -1;\n        }\n    }\n    cout << \"Test Case 2 Passed\" << endl;\n\n    // Test Case 3\n    s1 = \"\";\n    s2 = \"\";\n    expectedResult = vector<string> {};\n    actualResult = solution.uncommonFromSentences(s1, s2);\n    for (int i = 0; i < actualResult.size(); i++) {\n        if (actualResult[i] != expectedResult[i]) {\n            cout << \"Test Case 3 Failed\" << endl;\n            return -1;\n        }\n    }\n    cout << \"Test Case 3 Passed\" << endl;\n\n    return 0;\n}\n```",
  "887": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int superEggDrop(int K, int N) {\n        if (K == 1 || N == 1) return N;\n        vector<vector<int>> dp(K + 1, vector<int>(N + 1));\n        for (int i = 1; i <= K; ++i) {\n            dp[i][1] = 1;\n            dp[i][0] = 0;\n        }\n        for (int j = 1; j <= N; ++j) {\n            dp[1][j] = j;\n        }\n        for (int i = 2; i <= K; ++i) {\n            for (int j = 2; j <= N; ++j) {\n                int res = INT_MAX;\n                for (int x = 1; x <= min(j, i); ++x) {\n                    int temp = max(dp[i - 1][x - 1], dp[i][j - x]) + 1;\n                    if (temp < res) res = temp;\n                }\n                dp[i][j] = res;\n            }\n        }\n        return dp[K][N];\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test Case 1: \" << solution.superEggDrop(1, 2) << endl; // Output: 2\n    cout << \"Test Case 2: \" << solution.superEggDrop(2, 6) << endl; // Output: 4\n    cout << \"Test Case 3: \" << solution.superEggDrop(3, 14) << endl; // Output: 9\n    return 0;\n}\n```",
  "886": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isBipartite(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<bool> color(n, false);\n        \n        for (int i = 0; i < n; ++i) {\n            if (!color[i]) {\n                queue<int> q;\n                q.push(i);\n                color[i] = true;\n                \n                while (!q.empty()) {\n                    int node = q.front();\n                    q.pop();\n                    \n                    for (int neighbor : graph[node]) {\n                        if (!color[neighbor]) {\n                            color[neighbor] = !color[node];\n                            q.push(neighbor);\n                        } else if (color[neighbor] == color[node]) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<int>> graph1 = {{1, 2, 3}, {0, 2}, {0, 1, 3}};\n    cout << (solution.isBipartite(graph1) ? \"Possible\" : \"Not Possible\") << endl;\n\n    vector<vector<int>> graph2 = {{1, 2, 3}, {0, 1, 2}};\n    cout << (solution.isBipartite(graph2) ? \"Possible\" : \"Not Possible\") << endl;\n    \n    vector<vector<int>> graph3 = {{1, 2}, {0, 1, 3}, {0, 2}};\n    cout << (solution.isBipartite(graph3) ? \"Possible\" : \"Not Possible\") << endl;\n\n    return 0;\n}\n```",
  "888": "```\n#include <iostream>\n#include <vector>\n\nint fairCandySwap(std::vector<int>& candies) {\n    int alice = -1, bob = -1;\n    for (int i = 0; i < candies.size(); ++i) {\n        if (alice == -1) {\n            alice = candies[i];\n        } else if (bob == -1 && alice + candies[i] % 2 == 0) {\n            bob = candies[i];\n        }\n    }\n    return bob - alice;\n}\n\nint main() {\n    std::vector<int> test1({2, 1, 4});\n    int result1 = fairCandySwap(test1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> test2({3, 5, 8, 10});\n    int result2 = fairCandySwap(test2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> test3({1, 2, 4, 6, 8, 9, 12, 16});\n    int result3 = fairCandySwap(test3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "889": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {\n    if (preorder.empty()) return NULL;\n\n    TreeNode* root = new TreeNode(preorder[0]);\n    int preIndex = 1;\n    for (int i = 1; i < preorder.size(); ++i) {\n        if (postorder[i] == preorder[0]) {\n            root->left = constructFromPrePost({preorder.begin() + preIndex, preorder.end()}, \n                                              {postorder.begin(), postorder.begin() + i});\n            preIndex = i;\n            break;\n        }\n    }\n\n    int leftSize = 0;\n    for (int i = postorder.size()-1; i >= 0; --i) {\n        if (preorder[preIndex] == postorder[i]) {\n            leftSize = i + 1;\n            break;\n        }\n    }\n\n    root->right = constructFromPrePost({preorder.begin() + preIndex, preorder.end()}, \n                                      {postorder.begin() + leftSize, postorder.size()-1});\n    return root;\n}\n\nvoid printTree(TreeNode* node) {\n    if (!node) return;\n\n    cout << node->val << \" \";\n    printTree(node->left);\n    printTree(node->right);\n\n    cout << endl;\n}\n\nint main() {\n    vector<int> preorder1 = {1, 2, 4, 5, 3};\n    vector<int> postorder1 = {4, 5, 3, 2, 1};\n    TreeNode* root1 = constructFromPrePost(preorder1, postorder1);\n    cout << \"Tree 1: \";\n    printTree(root1);\n\n    vector<int> preorder2 = {1, 2, 3};\n    vector<int> postorder2 = {3, 2, 1};\n    TreeNode* root2 = constructFromPrePost(preorder2, postorder2);\n    cout << \"Tree 2: \";\n    printTree(root2);\n\n    vector<int> preorder3 = {1, 2};\n    vector<int> postorder3 = {2, 1};\n    TreeNode* root3 = constructFromPrePost(preorder3, postorder3);\n    cout << \"Tree 3: \";\n    printTree(root3);\n\n    return 0;\n}\n```",
  "890": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool findAndReplacePattern(std::vector<std::string>& words, std::string pattern) {\n    int n = words.size();\n    for (int i = 0; i < n; ++i) {\n        if (!match(words[i], pattern)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool match(const std::string& word, const std::string& pattern) {\n    int m = pattern.size();\n    int n = word.size();\n    if (m != n) {\n        return false;\n    }\n    unordered_map<char, char> map;\n    for (int i = 0; i < m; ++i) {\n        if (map.count(pattern[i])) {\n            if (map[pattern[i]] != word[i]) {\n                return false;\n            }\n        } else if (map.find(word[i]) != map.end()) {\n            if (map[word[i]] != pattern[i]) {\n                return false;\n            }\n        } else {\n            map[pattern[i]] = word[i];\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<std::string> words1 = {\"pattern\"};\n    bool result1 = findAndReplacePattern(words1, \"a\");\n    std::cout << result1 << std::endl;\n\n    std::vector<std::string> words2 = {\"dog\",\"cat\",\"cow\"};\n    bool result2 = findAndReplacePattern(words2, \"abba\");\n    std::cout << result2 << std::endl;\n\n    std::vector<std::string> words3 = {\"mass\",\"hamst\",\"hammer\",\"human\"};\n    bool result3 = findAndReplacePattern(words3, \"abc\");\n    std::cout << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "891": "```\n#include <iostream>\n#include <vector>\n\nint widthOfRings(int n, std::vector<int>& rings) {\n    int res = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (rings[i - 1]) res += min(rings[i - 1], abs(i - (n + 1)));\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> rings1 = {2, 3, 4};\n    int res1 = widthOfRings(5, rings1);\n    std::cout << \"Test case 1: Expected result = 3, Actual result = \" << res1 << std::endl;\n\n    std::vector<int> rings2 = {1, 1, 1, 1};\n    int res2 = widthOfRings(4, rings2);\n    std::cout << \"Test case 2: Expected result = 10, Actual result = \" << res2 << std::endl;\n\n    std::vector<int> rings3 = {0, 1, 0, 1};\n    int res3 = widthOfRings(4, rings3);\n    std::cout << \"Test case 3: Expected result = 8, Actual result = \" << res3 << std::endl;\n\n    return 0;\n}\n```",
  "892": "```\n#include <iostream>\n#include <vector>\n\nint surfaceArea(std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] > 0) {\n                int h = grid[i][j];\n                ans += 2 + h;\n                if (i > 0) ans += grid[i-1][j];\n                if (j > 0) ans += grid[i][j-1];\n                if (i < n - 1) ans += grid[i+1][j];\n                if (j < n - 1) ans += grid[i][j+1];\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::vector<std::vector<int>> grid1 = {{2}};\n    std::cout << surfaceArea(grid1) << std::endl;\n\n    std::vector<std::vector<int>> grid2 = {{1,1},{1,1}};\n    std::cout << surfaceArea(grid2) << std::endl;\n\n    std::vector<std::vector<int>> grid3 = {{0,0,1},{1,1,0},{1,0,0}};\n    std::cout << surfaceArea(grid3) << std::endl;\n    return 0;\n}\n```",
  "893": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> groupStrings(vector<string>& str) {\n        unordered_map<string, string> mp;\n        vector<vector<string>> res;\n        \n        for (const auto& s : str) {\n            string key = \"\";\n            for (char c : s) {\n                key += to_string(c);\n            }\n            \n            if (!mp.count(key)) {\n                mp[key] = \"\";\n                res.push_back({s});\n            } else {\n                mp[key].push_back(s);\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> str1 = {\"Hello\", \"Hi\", \"hive\"};\n    vector<vector<string>> expected1 = {{}, {\"Hi\", \"hive\"}};\n    cout << boolalpha << (solution.groupStrings(str1) == expected1) << endl;\n\n    vector<string> str2 = {\"apple\", \"app\", \"banana\"];\n    vector<vector<string>> expected2 = {{}, {\"apple\", \"app\"}, {\"banana\"}};\n    cout << boolalpha << (solution.groupStrings(str2) == expected2) << endl;\n\n    vector<string> str3 = {\"ab\", \"ba\", \"bca\"};\n    vector<vector<string>> expected3 = {{}, {\"ab\", \"ba\"}, {\"bca\"}};\n    cout << boolalpha << (solution.groupStrings(str3) == expected3) << endl;\n\n    return 0;\n}\n```",
  "894": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<std::vector<int>> allPossibleFBT(int N) {\n        if (N % 2 == 1) return {};\n        if (N == 0) return {{}};\n        \n        std::vector<std::vector<int>> result;\n        for (int i = 1; i < N; i += 2) {\n            int leftSize = i;\n            int rightSize = N - 1 - i;\n            \n            if (leftSize > 0 && rightSize > 0) {\n                std::vector<std::vector<int>> leftRes = allPossibleFBT(leftSize);\n                std::vector<std::vector<int>> rightRes = allPossibleFBT(rightSize);\n                \n                for (const auto& leftTree : leftRes) {\n                    for (const auto& rightTree : rightRes) {\n                        result.push_back({0});\n                        result.back().insert(result.back().begin(), leftTree.begin(), leftTree.end());\n                        result.back().push_back(0);\n                        result.back().insert(result.back().end() - 1, rightTree.begin(), rightTree.end());\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int N = 3; // Test case 1\n    std::vector<std::vector<int>> expected1 = {{0,1,2},{0,1},{0,2}};\n    std::vector<std::vector<int>> result1 = solution.allPossibleFBT(N);\n    for (const auto& tree : result1) {\n        for (int val : tree) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    N = 7; // Test case 2\n    std::vector<std::vector<int>> expected2 = {{0,1,3,4},{0,3},{0,2,4},{0,5},{0,6},{0}};\n    for (const auto& tree : solution.allPossibleFBT(N)) {\n        for (int val : tree) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    N = 2; // Test case 3\n    expected2.clear();\n    for (const auto& tree : solution.allPossibleFBT(N)) {\n        for (int val : tree) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```",
  "895": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nclass FreqStack {\npublic:\n    int push(int val) {\n        freq[val]++;\n        size++;\n    }\n\n    int pop() {\n        int maxFreq = 0;\n        for (auto& pair : freq) {\n            if (pair.second > maxFreq) {\n                maxFreq = pair.second;\n            }\n        }\n        for (auto& pair : freq) {\n            if (pair.second == maxFreq) {\n                val = pair.first;\n                size--;\n                freq.erase(val);\n                return val;\n            }\n        }\n        return -1;\n    }\n\nprivate:\n    int val, size = 0;\n    std::unordered_map<int, int> freq;\n\n};\n\nint main() {\n    FreqStack freqStack;\n    // Test Case 1\n    freqStack.push(5);\n    freqStack.push(6);\n    freqStack.push(5);\n    std::cout << \"Maximum frequency pop: \" << freqStack.pop() << std::endl; // Output: 5\n\n    // Test Case 2\n    freqStack = FreqStack();\n    freqStack.push(1);\n    freqStack.push(2);\n    freqStack.push(3);\n    freqStack.push(2);\n    freqStack.push(1);\n    freqStack.push(3);\n    std::cout << \"Maximum frequency pop: \" << freqStack.pop() << std::endl; // Output: 3\n    std::cout << \"Maximum frequency pop: \" << freqStack.pop() << std::endl; // Output: 1\n    std::cout << \"Maximum frequency pop: \" << freqStack.pop() << std::endl; // Output: 2\n\n    // Test Case 3\n    freqStack = FreqStack();\n    for (int i = 0; i < 10; ++i) {\n        freqStack.push(i);\n    }\n    for (int i = 9; i >= 0; --i) {\n        std::cout << \"Maximum frequency pop: \" << freqStack.pop() << std::endl;\n    }\n    return 0;\n}\n```",
  "896": "```\n#include <iostream>\n#include <vector>\n\nbool isMonotonic(std::vector<int>& nums) {\n    bool increasing = true;\n    bool decreasing = true;\n\n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] > nums[i - 1]) {\n            increasing = true;\n        } else if (nums[i] < nums[i - 1]) {\n            decreasing = true;\n        }\n    }\n\n    return increasing || decreasing;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 1, 1};\n    std::cout << \"Test case 1: \" << (isMonotonic(test1) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> test2 = {6, 5, 4, 3};\n    std::cout << \"Test case 2: \" << (isMonotonic(test2) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> test3 = {1, 3, 2};\n    std::cout << \"Test case 3: \" << (isMonotonic(test3) ? \"True\" : \"False\") << std::endl;\n}",
  "897": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* increasingBST(TreeNode* root) {\n        if (!root) return nullptr;\n        \n        TreeNode* dummy = new TreeNode();\n        TreeNode* curr = dummy;\n        inOrder(root);\n        \n        return dummy->right;\n    }\n    \n    void inOrder(TreeNode* node) {\n        if (!node) return;\n        inOrder(node->left);\n        node->val = curr->val + 1;\n        curr = node;\n        inOrder(node->right);\n    }\n};\n\nint main() {\n    Solution s;\n\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(6);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(4);\n    root1->right->left = new TreeNode(5);\n    root1->right->right = new TreeNode(7);\n\n    TreeNode* result1 = s.increasingBST(root1);\n    \n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(1);\n    root2->right = new TreeNode(4);\n\n    TreeNode* result2 = s.increasingBST(root2);\n\n    TreeNode* root3 = new TreeNode(7);\n    root3->left = new TreeNode(6);\n    root3->right = new TreeNode(8);\n    root3->left->left = new TreeNode(5);\n    root3->left->right = new TreeNode(6);\n\n    TreeNode* result3 = s.increasingBST(root3);\n\n    return 0;\n}\n```",
  "898": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximum_72(vector<int>& v) {\n        int res = 0;\n        for (int i = 0; i < v.size(); i++) {\n            int mask = 0;\n            for (int j = i; j < v.size(); j++) {\n                mask |= v[j];\n            }\n            res = max(res, mask);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> v1 = {2,1,3};\n    cout << \"Test case 1: \" << solution.maximum_72(v1) << endl; // Output: 7\n\n    vector<int> v2 = {7,2,12,3};\n    cout << \"Test case 2: \" << solution.maximum_72(v2) << endl; // Output: 27\n\n    vector<int> v3 = {1,2,3,4};\n    cout << \"Test case 3: \" << solution.maximum_72(v3) << endl; // Output: 7\n\n    return 0;\n}\n```",
  "899": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string orderlyQueue(vector<string>& words) {\n        sort(words.begin(), words.end());\n        for (int i = 0; i < words.size() - 1; ++i) {\n            if (words[i].substr(0, 1) == words[i + 1].substr(0, 1)) {\n                string temp;\n                for (char c : words[i]) {\n                    temp += c;\n                }\n                for (char c : words[i + 1]) {\n                    temp += c;\n                }\n                words.insert(words.begin() + i + 1, temp);\n                words.erase(words.begin() + i + 2);\n                break;\n            }\n        }\n        string result = \"\";\n        for (string s : words) {\n            result += s + \" \";\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> test1 = {\"shuji\",\"sujui\",\"sjujy\",\"sjujo\"};\n    cout << solution.orderlyQueue(test1) << endl;  // Output: \"sjuji sujjo sujuy shuji \"\n\n    vector<string> test2 = {\"abc\", \"bcd\", \"cba\"};\n    cout << solution.orderlyQueue(test2) << endl;  // Output: \"abc bcd cba \"\n\n    vector<string> test3 = {\"h\",\"ea\",\"eo\",\"eh\",\"ih\",\"ye\",\"yea\",\"yee\",\"yeh\"};\n    cout << solution.orderlyQueue(test3) << endl;  // Output: \"eaeiheeihhy yeee \"\n    \n    return 0;\n}\n```",
  "900": "```\n#include <iostream>\n#include <vector>\n\nclass RLEIterator {\npublic:\n    RLEIterator(std::vector<int>& encoding) : vec(encoding), i(0) {}\n\n    int next(int n) {\n        while (i < vec.size()) {\n            if (vec[i] == n) return vec[i + 1];\n            else if (n > vec[i]) return -1; // not found\n            else n = vec[i++];\n        }\n        return -1; // not found\n    }\n\nprivate:\n    std::vector<int>& vec;\n    int i;\n};\n\nint main() {\n    {\n        std::vector<int> encoding = {8, 13, 8};\n        RLEIterator it(encoding);\n        std::cout << it.next(5) << \" \" << it.next(2) << \" \" << it.next(4) << \" \" << it.next(3) << \" \" << it.next(6) << \" \" << it.next(1) << std::endl;\n    }\n\n    {\n        std::vector<int> encoding = {7, 8, 8};\n        RLEIterator it(encoding);\n        std::cout << it.next(4) << \" \" << it.next(3) << \" \" << it.next(2) << \" \" << it.next(1) << \" \" << it.next(5) << \" \" << it.next(6) << \" \" << it.next(9) << std::endl;\n    }\n\n    {\n        std::vector<int> encoding = {1, 3, 3, 7};\n        RLEIterator it(encoding);\n        std::cout << it.next(2) << \" \" << it.next(1) << \" \" << it.next(5) << std::endl;\n    }\n}\n```",
  "901": "```\n#include <iostream>\n#include <stack>\n#include <vector>\n\nclass StockSpanner {\npublic:\n    int next(int price) {\n        int days = 1;\n        while (!st.empty() && st.top() <= price) {\n            st.pop();\n            days++;\n        }\n        return days;\n    }\n\nprivate:\n    std::stack<int> st;\n};\n\nint main() {\n    StockSpanner ss;\n\n    // Test Case 1\n    std::cout << \"Test Case 1: \" << ss.next(100) << std::endl; // Output: 1\n    std::cout << \"Test Case 1: \" << ss.next(80) << std::endl; // Output: 2\n    std::cout << \"Test Case 1: \" << ss.next(120) << std::endl; // Output: 3\n\n    // Test Case 2\n    std::cout << \"\\nTest Case 2:\" << std::endl;\n    for (int i = 0; i < 5; ++i) {\n        if (i == 2 || i == 4) {\n            std::cout << \"Price: \" << i * 10 << \", Span: \" << ss.next(i * 10) << std::endl;\n        }\n    }\n\n    // Test Case 3\n    std::cout << \"\\nTest Case 3:\" << std::endl;\n    for (int i = 0; i < 4; ++i) {\n        if ((i == 1 || i == 2)) {\n            std::cout << \"Price: \" << (100 + i * 10) << \", Span: \" << ss.next(100 + i * 10) << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "902": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint atMostNGivenDigitSet(std::vector<std::string>& digits, int n) {\n    int res = 0;\n    for (int i = 1; ; ++i) {\n        if (i > n) break;\n        std::string s = std::to_string(i);\n        bool flag = false;\n        for (const auto& d : digits) {\n            if (s.find(d) == std::string::npos) {\n                res += digits.size();\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) ++res;\n    }\n    return res;\n}\n\nint main() {\n    int n1 = 2, n2 = 11, n3 = 25;\n    std::vector<std::string> d1 = {\"1\", \"2\"};\n    std::vector<std::string> d2 = {\"1\", \"10\", \"11\", \"12\"};\n    std::vector<std::string> d3 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\"};\n\n    std::cout << atMostNGivenDigitSet(d1, n1) << std::endl;\n    std::cout << atMostNGivenDigitSet(d2, n2) << std::endl;\n    std::cout << atMostNGivenDigitSet(d3, n3) << std::endl;\n\n    return 0;\n}\n```",
  "903": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> permute(string s) {\n        vector<vector<string>> result;\n        if (s.empty()) return result;\n        \n        vector<string> path;\n        backtrack(s, path, result);\n        return result;\n    }\n    \n    void backtrack(string s, vector<string>& path, vector<vector<string>>& result) {\n        int n = s.size();\n        if (n == 0) {\n            result.push_back(path);\n            return;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            string prefix = s.substr(0, i + 1);\n            string remaining = s.substr(i + 1);\n            \n            if (!isValid(prefix)) continue;\n            \n            path.push_back(to_string(stoi(prefix) - 1));\n            backtrack(remaining, path, result);\n            path.pop_back();\n        }\n    }\n    \n    bool isValid(string s) {\n        int sum = 0;\n        for (char c : s) {\n            sum += c - '0';\n        }\n        return sum == sum / (s.size() ? s.size() : 1);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<string>> result1 = solution.permute(\"0112\");\n    for (const auto& perm : result1) {\n        cout << \"[\";\n        for (const auto& str : perm) {\n            cout << str << \" \";\n        }\n        cout << \"]\" << endl;\n    }\n\n    vector<vector<string>> result2 = solution.permute(\"1234\");\n    for (const auto& perm : result2) {\n        cout << \"[\";\n        for (const auto& str : perm) {\n            cout << str << \" \";\n        }\n        cout << \"]\" << endl;\n    }\n\n    vector<vector<string>> result3 = solution.permute(\"\");\n    for (const auto& perm : result3) {\n        cout << \"[\";\n        for (const auto& str : perm) {\n            cout << str << \" \";\n        }\n        cout << \"]\" << endl;\n    }\n    \n    return 0;\n}\n```",
  "904": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int totalFruit(vector<vector<int>>& fruits) {\n        int maxCount = 0, curCount = 0;\n        unordered_map<int, int> fruitCounts;\n        \n        for (int i = 0; i < fruits.size(); i++) {\n            for (int j = 0; j < fruits[i].size(); j++) {\n                if (fruitCounts.find(fruits[i][j]) != fruitCounts.end()) {\n                    fruitCounts[fruits[i][j]]++;\n                } else {\n                    curCount = 1;\n                    fruitCounts[fruits[i][j]] = 1;\n                    maxCount = min(maxCount, curCount);\n                }\n            }\n            if (curCount > maxCount) maxCount = curCount;\n            curCount = 0;\n            fruitCounts.clear();\n        }\n        \n        return maxCount;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> fruits1 = {{1,2,1},{3,2,1},{2,3,1}};\n    cout << \"Test Case 1: \" << solution.totalFruit(fruits1) << endl; // Output: 3\n    \n    // Test case 2\n    vector<vector<int>> fruits2 = {{0,1,2,2}};\n    cout << \"Test Case 2: \" << solution.totalFruit(fruits2) << endl; // Output: 3\n    \n    // Test case 3\n    vector<vector<int>> fruits3 = {{1,2,3},{3,3}, {2,5,4}};\n    cout << \"Test Case 3: \" << solution.totalFruit(fruits3) << endl; // Output: 4\n    \n    return 0;\n}",
  "905": "```\n#include <iostream>\n#include <vector>\n\nvoid sortArrayByParity(std::vector<int>& nums) {\n    int left = 0;\n    int right = nums.size() - 1;\n\n    while (left < right) {\n        if (nums[left] % 2 == 0) {\n            left++;\n        } else if (nums[right] % 2 != 0) {\n            right--;\n        } else {\n            std::swap(nums[left], nums[right]);\n            left++;\n            right--;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> test1 = {3, 1};\n    sortArrayByParity(test1);\n    for (int num : test1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> test2 = {0, 1, 2};\n    sortArrayByParity(test2);\n    for (int num : test2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> test3 = {4, 2, 5, 7, 3, 1};\n    sortArrayByParity(test3);\n    for (int num : test3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "906": "```\n#include <iostream>\n#include <vector>\n\nbool checkPalindrome(std::string s) {\n    int left = 0;\n    int right = s.length() - 1;\n\n    while (left < right) {\n        if (s[left] != s[right]) return false;\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\nint findPairs(int n, std::vector<int>& nums) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (checkPalindrome(std::to_string(nums[i]) + std::to_string(nums[j]))) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    int testCases[] = {2, 3, 4};\n    int nums[] = {121, 1, 123, 1, 2};\n    for (int i = 0; i < sizeof(testCases) / sizeof(int); i++) {\n        std::cout << \"Test Case: \" << testCases[i] << std::endl;\n        std::cout << \"Number of pairs with super palindromes: \" << findPairs(testCases[i], &nums[0]) << std::endl;\n        std::cout << std::endl;\n    }\n    return 0;\n}\n```",
  "907": "```\n#include <iostream>\n#include <vector>\n\nint minSumOfSubarrays(std::vector<int>& arr) {\n    int n = arr.size();\n    std::vector<int> leftMin(n);\n    leftMin[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        leftMin[i] = std::min(leftMin[i - 1], arr[i]);\n    }\n\n    std::vector<int> rightMin(n);\n    rightMin[n - 1] = arr[n - 1];\n    for (int i = n - 2; i >= 0; i--) {\n        rightMin[i] = std::min(rightMin[i + 1], arr[i]);\n    }\n\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += leftMin[i];\n    }\n    for (int i = n - 1; i >= 0; i--) {\n        sum += rightMin[i];\n    }\n\n    return sum;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<int> arr1 = {3, 1, 2};\n    int result1 = minSumOfSubarrays(arr1);\n    if (result1 == 5) {\n        std::cout << \"Test Case 1: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1: Failed. Expected 5 but got \" << result1 << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<int> arr2 = {11, 81, 2, 94, 3};\n    int result2 = minSumOfSubarrays(arr2);\n    if (result2 == 100) {\n        std::cout << \"Test Case 2: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2: Failed. Expected 100 but got \" << result2 << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<int> arr3 = {16, 15, 5, 9};\n    int result3 = minSumOfSubarrays(arr3);\n    if (result3 == 21) {\n        std::cout << \"Test Case 3: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3: Failed. Expected 21 but got \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "908": "```\n#include <iostream>\n#include <vector>\n\nint smallestRange(std::vector<int>& nums) {\n    int min_val = *std::min_element(nums.begin(), nums.end());\n    int max_val = *std::max_element(nums.begin(), nums.end());\n    return (max_val - min_val);\n}\n\nint main() {\n    std::vector<int> nums1({0,10});\n    std::cout << \"Test case 1: \" << smallestRange(nums1) << std::endl;\n\n    std::vector<int> nums2({1,2,3,4});\n    std::cout << \"Test case 2: \" << smallestRange(nums2) << std::endl;\n\n    std::vector<int> nums3({1,3,6,10});\n    std::cout << \"Test case 3: \" << smallestRange(nums3) << std::endl;\n    \n    return 0;\n}\n```",
  "910": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint smallestRangeII(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int left = nums[0], right = nums.back();\n    for (int i : nums) {\n        left = std::min(left, i);\n        right = std::max(right, i);\n    }\n    return right - left;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> nums1 = {0,10};\n    std::cout << \"Test Case 1: \" << smallestRangeII(nums1) << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {-3,3];\n    std::cout << \"Test Case 2: \" << smallestRangeII(nums2) << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {1,0,-1,10,5};\n    std::cout << \"Test Case 3: \" << smallestRangeII(nums3) << std::endl;\n    \n    return 0;\n}\n```",
  "909": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int snakesAndLadders(vector<vector<int>>& board) {\n        int n = board.size();\n        vector<bool> visited(n + 1, false);\n        queue<pair<int, int>> q;\n        q.push({1, -1});\n        visited[1] = true;\n        \n        while (!q.empty()) {\n            auto [pos, prevPos] = q.front();\n            q.pop();\n            \n            if (pos == n) return prevPos + 1; // return the position where we got to the end\n            \n            for (int i = pos + 1; i <= n && i <= pos + 6; i++) {\n                if (i >= n || visited[i]) continue;\n                \n                int nextPos = i;\n                if (board[i - 1][0] != 0) nextPos = board[i - 1][0];\n                \n                q.push({nextPos, prevPos});\n                visited[nextPos] = true;\n            }\n        }\n        \n        return -1; // no solution\n    }\n};\n\nint main() {\n    vector<vector<int>> board1 {{-1}, {5, 1, 3}, {-1, 2, -1}, 7};\n    cout << Solution().snakesAndLadders(board1) << endl; // should print: 4\n\n    vector<vector<int>> board2 {{-1}, {6, 8, 16, 23, 31, -1}, \n                                {15, -1, -1, 0, -1, 13, 20, 25, -1}, \n                                {-1, -1, -1, -1, 9, -1, 2, 3, -1}, \n                                {30, -1, 8, 28, 11, 23, 26, -1}, \n                                {0, 5, 14, -1, -1, 6, 10, 4, 12}};\n    cout << Solution().snakesAndLadders(board2) << endl; // should print: 24\n\n    vector<vector<int>> board3 {{-1}, {7, 8, -1}, {1, 5, 15, 18, 20, 23, 26, 28, -1}};\n    cout << Solution().snakesAndLadders(board3) << endl; // should print: 14\n}\n```",
  "911": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass OnlineElection {\npublic:\n    vector<int> getWinner(vector<string>& votes) {\n        map<string, int> voteMap;\n        for (const auto& vote : votes) {\n            voteMap[vote]++;\n        }\n        \n        string winner = \"\";\n        int maxCount = 0;\n        for (const auto& pair : voteMap) {\n            if (pair.second > maxCount) {\n                winner = pair.first;\n                maxCount = pair.second;\n            } else if (pair.second == maxCount && pair.first != winner) {\n                return vector<int>{}; // In case of a tie, there is no unique winner\n            }\n        }\n        \n        return {1}; // Return 1 to indicate that the election has one winner\n    }\n};\n\nint main() {\n    OnlineElection onlineElection;\n    \n    // Test Case 1: Election with one candidate\n    vector<string> votes1 = {\"John\", \"John\"};\n    cout << \"Test Case 1: \";\n    for (const auto& vote : onlineElection.getWinner(votes1)) {\n        cout << vote << endl;\n    }\n    \n    // Test Case 2: Election with multiple candidates and no winner\n    vector<string> votes2 = {\"Alice\", \"Bob\", \"Charlie\", \"Alice\", \"Bob\"};\n    cout << \"\\nTest Case 2: \";\n    for (const auto& vote : onlineElection.getWinner(votes2)) {\n        cout << vote << endl;\n    }\n    \n    // Test Case 3: Election with multiple candidates and one winner\n    vector<string> votes3 = {\"David\", \"David\", \"David\"};\n    cout << \"\\nTest Case 3: \";\n    for (const auto& vote : onlineElection.getWinner(votes3)) {\n        cout << vote << endl;\n    }\n    \n    return 0;\n}\n```",
  "912": "```\n#include <iostream>\n#include <vector>\n\nvoid mergeSort(std::vector<int>& nums) {\n    if (nums.size() <= 1) return;\n    int mid = nums.size() / 2;\n    std::vector<int> left(nums.begin(), nums.begin() + mid);\n    std::vector<int> right(nums.begin() + mid, nums.end());\n    mergeSort(left);\n    mergeSort(right);\n    merge(left, right, nums);\n}\n\nvoid merge(std::vector<int>& left, std::vector<int>& right, std::vector<int>& nums) {\n    int i = 0, j = 0, k = 0;\n    while (i < left.size() && j < right.size()) {\n        if (left[i] <= right[j]) {\n            nums[k++] = left[i++];\n        } else {\n            nums[k++] = right[j++];\n        }\n    }\n    while (i < left.size()) {\n        nums[k++] = left[i++];\n    }\n    while (j < right.size()) {\n        nums[k++] = right[j++];\n    }\n}\n\nint main() {\n    std::vector<int> nums1 = {4, 2, 9, 6};\n    mergeSort(nums1);\n    for (int num : nums1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums2 = {5, 3, 8, 4, 2};\n    mergeSort(nums2);\n    for (int num : nums2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums3 = {1, 2, 3, 4, 5};\n    mergeSort(nums3);\n    for (int num : nums3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n}\n```",
  "914": "```\n#include <iostream>\n#include <vector>\n\nbool hasGroupsSizeX(std::vector<int>& deck) {\n    std::unordered_map<int, int> count;\n    for (int card : deck) {\n        count[card]++;\n    }\n    \n    int result = -1;\n    for (auto& pair : count) {\n        if (pair.second > 0) {\n            if (result == -1) {\n                result = pair.second;\n            } else {\n                if (__gcd(result, pair.second) != 1) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n\nint __gcd(int a, int b) {\n    while (b != 0) {\n        int t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\nint main() {\n    std::vector<int> deck1 = {1, 2, 3, 4};\n    std::cout << hasGroupsSizeX(deck1) << std::endl;\n\n    std::vector<int> deck2 = {1, 1, 2, 2, 3, 3};\n    std::cout << hasGroupsSizeX(deck2) << std::endl;\n\n    std::vector<int> deck3 = {1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5};\n    std::cout << hasGroupsSizeX(deck3) << std::endl;\n    \n    return 0;\n}\n```",
  "913": "```\n#include <iostream>\nusing namespace std;\n\nint minTime(int n, int edges[][2], int m) {\n    // Your code here\n}\n\nint main() {\n    int n1 = 5;\n    int m1 = 4;\n    int edges1[][] = {{0, 1}, {2, 3}, {0, 2}, {1, 3}};\n    cout << minTime(n1, edges1, m1) << endl;\n\n    int n2 = 6;\n    int m2 = 5;\n    int edges2[][] = {{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}};\n    cout << minTime(n2, edges2, m2) << endl;\n\n    int n3 = 10;\n    int m3 = 9;\n    int edges3[][] = {{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}, {6, 7}, {7, 8}, {8, 9}};\n    cout << minTime(n3, edges3, m3) << endl;\n\n    return 0;\n}\n```",
  "915": "```\n#include <iostream>\n#include <vector>\n\nbool isPossible(int mid, std::vector<int>& intervals) {\n    int sum = 0;\n    for (int i : intervals) {\n        if (i > mid) return false;\n        sum += i;\n    }\n    return true;\n}\n\nint maxEqualSum(std::vector<int>& nums) {\n    int n = nums.size();\n    int total = 0;\n    for (int num : nums) total += num;\n\n    if (total % n != 0) return -1;\n\n    int target = total / n;\n    int mid = target;\n\n    while (!isPossible(mid, nums)) mid++;\n    return mid;\n}\n\nint main() {\n    std::vector<int> test1 = {12};\n    std::cout << \"Test case 1: \" << maxEqualSum(test1) << std::endl; // Output: 12\n\n    std::vector<int> test2 = {9, 2, 5, 4, 23, 6, 11, 8};\n    std::cout << \"Test case 2: \" << maxEqualSum(test2) << std::endl; // Output: 9\n\n    std::vector<int> test3 = {1, 5, 7, 13};\n    std::cout << \"Test case 3: \" << maxEqualSum(test3) << std::endl; // Output: -1\n    return 0;\n}",
  "916": "```\n#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSubsets(vector<string>& words, string target) {\n        int count[10] = {0};\n        for (string word : words) {\n            for (char c : word) {\n                if (c >= 'a' && c <= 'z') {\n                    count[c - 'a']++;\n                } else if (c >= 'A' && c <= 'Z') {\n                    count[c - 'A']++;\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 1; i < (1 << 26); i++) {\n            bool isValid = true;\n            int c = 0;\n            for (int j = 0; j < 26; j++) {\n                if ((i & (1 << j)) && count[j]) {\n                    c++;\n                    if (c > target.length()) {\n                        isValid = false;\n                        break;\n                    }\n                    string subset = \"\";\n                    int k = 0;\n                    for (int m = 0; m < 26; m++) {\n                        if ((i & (1 << m)) && count[m]) {\n                            subset += 'a' + m;\n                        }\n                        else if (!((i & (1 << m)))) {\n                            subset += 'a' + m;\n                        }\n                    }\n                    while (k < target.length()) {\n                        if (subset.size() > k) {\n                            if (target[k] == subset[k]) {\n                                k++;\n                            } else {\n                                isValid = false;\n                                break;\n                            }\n                        } else {\n                            k++;\n                        }\n                    }\n                }\n            }\n            if (isValid) {\n                res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> words1 = {\"a\", \"ab\"};\n    string target1 = \"abc\";\n    cout << solution.numSubsets(words1, target1) << endl; // Output: 2\n\n    vector<string> words2 = {\"a\", \"b\", \"c\", \"ab\", \"bc\", \"ca\"};\n    string target2 = \"aabbccc\";\n    cout << solution.numSubsets(words2, target2) << endl; // Output: 16\n\n    vector<string> words3 = {\"word1\", \"word2\", \"word3\"};\n    string target3 = \"word\";\n    cout << solution.numSubsets(words3, target3) << endl; // Output: 1\n\n    return 0;\n}\n```",
  "917": "```\n#include <iostream>\n#include <string>\n\nstd::string reverseOnlyLetters(std::string s) {\n    int left = 0;\n    int right = s.size() - 1;\n\n    while (left <= right) {\n        if (!isalpha(s[left])) {\n            left++;\n        } else if (!isalpha(s[right])) {\n            right--;\n        } else {\n            char temp = s[left];\n            s[left] = s[right];\n            s[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    return s;\n}\n\nint main() {\n    std::cout << reverseOnlyLetters(\"a-bC-d\") << std::endl;  // \"adcB\"\n    std::cout << reverseOnlyLetters(\"ab-cd\") << std::endl;   // \"dc-ba\"\n    std::cout << reverseOnlyLetters(\"Test1ng-Leet-Coding-Help!\") << std::endl;  // \"Testing-See-Got-Coder-Elite!\"\n    \n    return 0;\n}\n```",
  "918": "```\n#include <iostream>\n#include <vector>\n\nint maxSubarraySumCircular(std::vector<int>& nums) {\n    int total = 0;\n    int currMax = 0;\n    int currMin = 0;\n\n    for (int num : nums) {\n        total += num;\n        currMax = std::max(num, currMax + num);\n        currMin = std::min(num, currMin + num);\n    }\n\n    if (total < 0) return max(currMax, 0);\n\n    int maxNonCircleSum = currMax;\n    int minNonCircleSum = currMin;\n\n    currMax = currMin = 0;\n    total = 0;\n\n    for (int i = nums.size() - 1; i >= 0; i--) {\n        total += nums[i];\n        currMax = std::max(nums[i], currMax + nums[i]);\n        currMin = std::min(nums[i], currMin + nums[i]);\n\n        if (total > maxNonCircleSum) {\n            maxNonCircleSum = total;\n        }\n    }\n\n    return std::max(maxNonCircleSum - minNonCircleSum, maxNonCircleSum);\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {-2,-3,-1};\n    std::cout << \"Test Case 1: \" << maxSubarraySumCircular(test1) << std::endl;\n\n    // Test case 2\n    std::vector<int> test2 = [1, 2];\n    std::cout << \"Test Case 2: \" << maxSubarraySumCircular(test2) << std::endl;\n\n    // Test case 3\n    std::vector<int> test3 = {-1,-2,3,2};\n    std::cout << \"Test Case 3: \" << maxSubarraySumCircular(test3) << std::endl;\n\n    return 0;\n}\n```",
  "919": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass CBTInserter {\npublic:\n    TreeNode* insertIntoBST(TreeNode* root, int val) {\n        if (!root) return new TreeNode(val);\n        TreeNode* cur = root;\n        while (true) {\n            if (val < cur->val) {\n                if (!cur->left) {\n                    cur->left = new TreeNode(val);\n                    break;\n                }\n                cur = cur->left;\n            } else {\n                if (!cur->right) {\n                    cur->right = new TreeNode(val);\n                    break;\n                }\n                cur = cur->right;\n            }\n        }\n        return root;\n    }\n};\n\nint main() {\n    CBTInserter inserter;\n\n    // Test case 1\n    TreeNode* root1 = NULL;\n    int val1 = 4;\n    TreeNode* result1 = inserter.insertIntoBST(root1, val1);\n    cout << \"Test Case 1: \";\n    if (result1) {\n        cout << \"Expected Result: [\" << val1 << \"] -> Success\" << endl;\n    } else {\n        cout << \"Expected Result: [\" << val1 << \"] -> Failure\" << endl;\n    }\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(4);\n    int val2 = 3;\n    TreeNode* result2 = inserter.insertIntoBST(root2, val2);\n    cout << \"Test Case 2: \";\n    if (result2) {\n        cout << \"Expected Result: [\" << val2 << \"] -> Success\" << endl;\n    } else {\n        cout << \"Expected Result: [\" << val2 << \"] -> Failure\" << endl;\n    }\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(4);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(6);\n    int val3 = 5;\n    TreeNode* result3 = inserter.insertIntoBST(root3, val3);\n    cout << \"Test Case 3: \";\n    if (result3) {\n        cout << \"Expected Result: [\" << val3 << \"] -> Success\" << endl;\n    } else {\n        cout << \"Expected Result: [\" << val3 << \"] -> Failure\" << endl;\n    }\n\n    return 0;\n}",
  "920": "```\n#include <iostream>\n#include <vector>\n\nint numMusicPlaylists(int n, int limit, int g) {\n    const int MOD = 1000000007;\n    std::vector<std::vector<long long>> dp(limit + 1, std::vector<long long>(g + 1, 0));\n    \n    for (int i = 1; i <= limit; i++) {\n        for (int j = 1; j <= g; j++) {\n            if (i > 1) {\n                dp[i][j] = (dp[i - 1][j] + (dp[i - 1][j % i] * (n - i + 1))) % MOD;\n            } else {\n                dp[i][j] = n;\n            }\n        }\n    }\n    \n    return dp[limit][g];\n}\n\nint main() {\n    std::cout << numMusicPlaylists(3, 5, 2) << std::endl; // expected output: 15\n    std::cout << numMusicPlaylists(4, 3, 1) << std::endl; // expected output: 40\n    std::cout << numMusicPlaylists(26, 100000, 25) << std::endl; // expected output: 130823288576\n\n    return 0;\n}\n```",
  "921": "```\n#include <iostream>\n#include <string>\n\nint minAddToMakeValid(std::string s) {\n    int res = 0;\n    int open = 0;\n\n    for (char c : s) {\n        if (c == '(') {\n            open++;\n        } else if (c == ')') {\n            if (open > 0) {\n                open--;\n            } else {\n                res++;\n            }\n        }\n    }\n\n    return res + open;\n}\n\nint main() {\n    std::cout << minAddToMakeValid(\"())\") << std::endl; // Output: 2\n    std::cout << minAddToMakeValid(\"((()))\") << std::endl; // Output: 0\n    std::cout << minAddToMakeValid(\"(a+b)\") << std::endl; // Output: 1\n\n    return 0;\n}\n```",
  "922": "```\n#include <iostream>\n#include <vector>\n\nvoid sortArrayByParityII(std::vector<int>& nums) {\n    int i = 0;\n    for (int j = 1; j < nums.size(); j++) {\n        if ((nums[i] & 1) == (nums[j] & 1)) {\n            std::swap(nums[i], nums[j]);\n            i += 2;\n            j -= 1;\n        } else {\n            i++;\n        }\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {0, 1};\n    sortArrayByParityII(test1);\n    for (auto num : test1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<int> test2 = {0, 1, 2};\n    sortArrayByParityII(test2);\n    for (auto num : test2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<int> test3 = {4, 2, 5, 3};\n    sortArrayByParityII(test3);\n    for (auto num : test3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "923": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint threeSumMulti(std::vector<int>& nums, int target) {\n    std::sort(nums.begin(), nums.end());\n    long long count = 0;\n    for (int i = 0; i < nums.size() - 2; ++i) {\n        if (i > 0 && nums[i] == nums[i - 1]) continue;\n        int left = i + 1, right = nums.size() - 1;\n        while (left < right) {\n            long long sum = static_cast<long long>(nums[i]) + nums[left] + nums[right];\n            if (sum > target) {\n                --right;\n            } else if (sum < target) {\n                ++left;\n            } else {\n                count += right - left + 1;\n                while (left < right && nums[left] == nums[left + 1]) {\n                    ++left;\n                }\n                while (left < right && nums[right] == nums[right - 1]) {\n                    --right;\n                }\n                left++;\n                right--;\n            }\n        }\n    }\n    return count % 1000000007;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 1, 2, 2, 3, 3, 4, 4, 5, 5};\n    int target1 = 9; \n    int result1 = threeSumMulti(nums1, target1);\n    std::cout << \"Test case 1: The count of triplets with sum 9 is \" << result1 << std::endl;\n\n    std::vector<int> nums2 = {1, 1, 2, 3, 3};\n    int target2 = 6;\n    int result2 = threeSumMulti(nums2, target2);\n    std::cout << \"Test case 2: The count of triplets with sum 6 is \" << result2 << std::endl;\n\n    std::vector<int> nums3 = {1, 1};\n    int target3 = 2;\n    int result3 = threeSumMulti(nums3, target3);\n    std::cout << \"Test case 3: The count of triplets with sum 2 is \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "924": "```\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMalwareSpread(vector<vector<int>>& M) {\n        int n = M.size();\n        vector<pair<int, int>> nodes;\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (!M[i][j])\n                    nodes.emplace_back(i, j);\n\n        unordered_set<int> infected;\n        int res = -1;\n        for (const auto& edge : nodes) {\n            unordered_set<int> curInfected(infected);\n            curInfected.insert(edge.first);\n            curInfected.insert(edge.second);\n\n            bool canSpread = true;\n            for (int i = 0; i < n; ++i)\n                if (!M[i][edge.first] && !M[i][edge.second]) {\n                    canSpread = false;\n                    break;\n                }\n\n            if (canSpread) {\n                int spread = 0;\n                for (int i = 0; i < n; ++i)\n                    if (!M[i][edge.first] || !M[i][edge.second])\n                        spread++;\n\n                if (spread > res) {\n                    res = spread;\n                    infected = curInfected;\n                }\n            }\n        }\n\n        return res == -1 ? -1 : *min_element(infected.begin(), infected.end());\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test case 1\n    vector<vector<int>> M1{{0, 1}, {1, 0}, {1, 2}, {2, 0}};\n    cout << \"Test case 1: \" << s.minMalwareSpread(M1) << endl;\n\n    // Test case 2\n    vector<vector<int>> M2{{0, 1}, {1, 0}, {1, 2}, {2, 3}, {3, 1}};\n    cout << \"Test case 2: \" << s.minMalwareSpread(M2) << endl;\n\n    // Test case 3\n    vector<vector<int>> M3{{0, 1}, {1, 0}, {1, 2}, {2, 3}, {4, 5}};\n    cout << \"Test case 3: \" << s.minMalwareSpread(M3) << endl;\n\n    return 0;\n}\n```",
  "925": "```\n#include <iostream>\n#include <string>\n\nbool isLongPressedName(std::string name) {\n    int i = 0;\n    for (int j = 1; j <= name.length(); j++) {\n        if (j < name.length() && name[j] == name[i]) {\n            i++;\n        } else if (i > 0 && name[j] != name[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test case 1: \" << isLongPressedName(\"alex\") << std::endl; // Expected: True\n    std::cout << \"Test case 2: \" << isLongPressedName(\"saeleeetcd\") << std::endl; // Expected: False\n    std::cout << \"Test case 3: \" << isLongPressedName(\"luffy\") << std::endl; // Expected: True\n    return 0;\n}\n```",
  "926": "```\n#include <iostream>\n#include <vector>\n\nbool canBeIncreasing(std::string s) {\n    int n = s.size();\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == 'N') continue;\n        bool canBe = true;\n        for (int j = i + 1; j < n; ++j) {\n            if ((s[i] - '0' > s[j] - '0') || (s[i] == '0' && s[j] != '0')) break;\n            if (s[j] == 'N') continue;\n            if (s[i] == '1' && s[j] < s[i]) canBe = false;\n        }\n        if (!canBe) return false;\n    }\n    return true;\n}\n\nint main() {\n    std::cout << canBeIncreasing(\"038\") << std::endl; // Expected output: 1\n    std::cout << canBeIncreasing(\"00110\") << std::endl; // Expected output: 0\n    std::cout << canBeIncreasing(\"0114625\") << std::endl; // Expected output: 1\n    return 0;\n}",
  "927": "```\n#include <iostream>\n#include <vector>\n\nbool makesEqual(std::vector<int>& arr) {\n    int n = arr.size();\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += arr[i];\n    }\n    \n    if (sum % 3 != 0) {\n        return false;\n    }\n\n    int target = sum / 3;\n    int start = 0, end = 0;\n\n    while (end < n) {\n        while (start <= end && (arr[start] > target || end - start + 1 > n / 3)) {\n            if (arr[start] > target) break;\n            start++;\n        }\n\n        while (end < n && (arr[end] > target || end - start + 1 > n / 3)) {\n            if (arr[end] > target) return false;\n            end++;\n        }\n\n        if (end - start + 1 == n / 3) {\n            for (int i = start; i <= end; i++) {\n                if (arr[i] != target) return false;\n            }\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    std::vector<int> arr1 = {5,17,-100};\n    std::cout << makesEqual(arr1) << std::endl;\n\n    std::vector<int> arr2 = {0,2,3,4,5,6};\n    std::cout << makesEqual(arr2) << std::endl;\n\n    std::vector<int> arr3 = {18,35,49,58};\n    std::cout << makesEqual(arr3) << std::endl;\n\n    return 0;\n}\n```",
  "928": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMalwareSpread(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<pair<int, int>> edges;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (graph[i][j] == 1) edges.emplace_back(i, j);\n        \n        sort(edges.begin(), edges.end());\n        vector<int> parent(n), rank(n);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n        function<int(int)> find = [&](int x) {\n            if (parent[x] != x)\n                parent[x] = find(parent[x]);\n            return parent[x];\n        };\n        function<void(int, int)> unionSet = [&](int x, int y) {\n            x = find(x);\n            y = find(y);\n            if (x < y) swap(x, y);\n            if (rank[x] > rank[y])\n                parent[y] = x;\n            else {\n                parent[x] = y;\n                if (rank[x] == rank[y]) rank[x]++;\n            }\n        };\n        \n        int ans = -1, minSize = n;\n        for (int i = 0; i < edges.size(); ++i) {\n            unionSet(edges[i].first, edges[i].second);\n            int setSize = 0;\n            for (int j = 0; j < n; ++j)\n                if (find(j) == find(0)) setSize++;\n            if (setSize < minSize) {\n                ans = edges[i].first;\n                minSize = setSize;\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<vector<int>> graph1 = {{1,1},{0,1},{5,2},{4,3},{3,4},{2,5}};\n    cout << \"Test Case 1: \" << solution.minMalwareSpread(graph1) << endl;\n    \n    // Test Case 2\n    vector<vector<int>> graph2 = {{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{10,11},{11,12},{13,14},{14,15},{15,16}};\n    cout << \"Test Case 2: \" << solution.minMalwareSpread(graph2) << endl;\n    \n    // Test Case 3\n    vector<vector<int>> graph3 = {{1,2,3,4},{0,1,2},{1,2},{2,3},{3,0,4},{0,4}};\n    cout << \"Test Case 3: \" << solution.minMalwareSpread(graph3) << endl;\n    \n    return 0;\n}",
  "929": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numUniqueEmails(vector<string>& emails) {\n        set<string> uniqueEmails;\n        for (string email : emails) {\n            string local = email.substr(0, email.find('@'));\n            string domain = email.substr(email.find('@') + 1);\n            string processedLocal = \"\";\n            bool dotFound = false;\n            for (char c : local) {\n                if (c == '.') {\n                    dotFound = true;\n                } else if (!dotFound) {\n                    processedLocal += c;\n                }\n            }\n            uniqueEmails.insert(processedLocal + \"@\" + domain);\n        }\n        return uniqueEmails.size();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> emails1 = {\"a@leetcode.com\", \"b@leetcode.com\", \"c@leetcode.com\"};\n    cout << \"Test case 1: \" << solution.numUniqueEmails(emails1) << endl;  // Output: 3\n\n    // Test case 2\n    vector<string> emails2 = {\"test.email+alex@leetcode.com\", \"test.e.mail+bob.c@leetcode.com\", \"testemail+david@lee.tcode.com\"};\n    cout << \"Test case 2: \" << solution.numUniqueEmails(emails2) << endl;  // Output: 2\n\n    // Test case 3\n    vector<string> emails3 = {\"a@leetcode.com\", \"b@leetcode.com\", \"c@leetcode.com\", \"d@leetcode.com\"};\n    cout << \"Test case 3: \" << solution.numUniqueEmails(emails3) << endl;  // Output: 4\n\n    return 0;\n}\n```",
  "930": "```\n#include <iostream>\n#include <vector>\n\nint numSubarraysWithSum(std::vector<int>& nums, int target) {\n    int n = nums.size();\n    int ans = 0;\n    int cur_sum = 0;\n\n    for (int i = 0; i < n; ++i) {\n        cur_sum += nums[i];\n        if (cur_sum == target)\n            ans++;\n        if ((cur_sum - target) >= 0)\n            ans += std::count(nums.begin(), nums.end(), target);\n        cur_sum -= nums[i];\n    }\n\n    return ans;\n}\n\nint main() {\n    std::vector<int> nums1 = {0,1};\n    int target1 = 0;\n    std::cout << \"Test case 1: \" << numSubarraysWithSum(nums1, target1) << std::endl;\n\n    std::vector<int> nums2 = {74,151,76};\n    int target2 = 200;\n    std::cout << \"Test case 2: \" << numSubarraysWithSum(nums2, target2) << std::endl;\n\n    std::vector<int> nums3 = [1,6];\n    int target3 = 8;\n    std::cout << \"Test case 3: \" << numSubarraysWithSum(nums3, target3) << std::endl;\n\n    return 0;\n}\n```",
  "931": "```\n#include <iostream>\n#include <vector>\n\nint minFallingPathSum(std::vector<std::vector<int>>& matrix) {\n    int m = matrix.size();\n    if (m == 0) return 0;\n\n    for (int i = 1; i < m; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (j == 0) {\n                matrix[i][j] += std::min(matrix[i - 1][j], matrix[i - 1][j + 1]);\n            } else if (j == m - 1) {\n                matrix[i][j] += std::min(matrix[i - 1][j], matrix[i - 1][j - 1]);\n            } else {\n                matrix[i][j] += std::min({matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i - 1][j + 1]});\n            }\n        }\n    }\n\n    int min_sum = INT_MAX;\n    for (int i = 0; i < m; ++i) {\n        if (min_sum > matrix[m - 1][i]) {\n            min_sum = matrix[m - 1][i];\n        }\n    }\n\n    return min_sum;\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix1 = {{2,1,3},{6,5,4},{7,8,9}};\n    std::cout << \"Test case 1: \" << minFallingPathSum(matrix1) << std::endl;\n\n    std::vector<std::vector<int>> matrix2 = {{3,2},{1,1}};\n    std::cout << \"Test case 2: \" << minFallingPathSum(matrix2) << std::endl;\n\n    std::vector<std::vector<int>> matrix3 = {{-19,78},{61,-35,84},{7,2,12}};\n    std::cout << \"Test case 3: \" << minFallingPathSum(matrix3) << std::endl;\n\n    return 0;\n}\n```",
  "932": "```\n#include <iostream>\n#include <vector>\n\nbool isBeautifulArray(std::vector<int>& nums) {\n    int max = *std::max_element(nums.begin(), nums.end());\n    std::vector<bool> exists(max + 1, false);\n    for (int num : nums) {\n        exists[num] = true;\n    }\n\n    for (int i = 1; i <= max; ++i) {\n        if (!exists[i]) continue;\n        int next = i * 2 % (max + 1);\n        if (next == 0) next = 1;\n        if (exists[next]) return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> nums1 = {1, 4, 6, 8, 15};\n    std::cout << isBeautifulArray(nums1) << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {1, 2, 3, 5};\n    std::cout << isBeautifulArray(nums2) << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {};\n    std::cout << isBeautifulArray(nums3) << std::endl;\n\n    return 0;\n}",
  "933": "```\n#include <iostream>\n#include <queue>\n\nclass RecentCounter {\npublic:\n    int ping(int t) {\n        q.push(t);\n        while (q.front() < t - 3000) {\n            q.pop();\n        }\n        return q.size();\n    }\n\nprivate:\n    std::queue<int> q;\n};\n\nint main() {\n    RecentCounter rc;\n\n    // Test case 1\n    int t1 = rc.ping(1002);\n    if (t1 != 2) {\n        std::cout << \"Test case 1 failed\" << std::endl;\n    }\n\n    // Test case 2\n    int t2 = rc.ping(1004);\n    if (t2 != 3) {\n        std::cout << \"Test case 2 failed\" << std::endl;\n    }\n\n    // Test case 3\n    int t3 = rc.ping(2001);\n    if (t3 != 1) {\n        std::cout << \"Test case 3 failed\" << std::endl;\n    }\n}\n```",
  "934": "```\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestBridge(vector<vector<int>>& M) {\n        // TO DO\n    }\n};\n\nint main() {\n    vector<vector<int>> M1 = {{0,1},{1,0}};\n    cout << Solution().shortestBridge(M1) << endl;\n    \n    vector<vector<int>> M2 = {{0,1,0},{0,1,0},{0,0,1}};\n    cout << Solution().shortestBridge(M2) << endl;\n    \n    vector<vector<int>> M3 = {{0,1,0},{0,1,0},{1,1,1}};\n    cout << Solution().shortestBridge(M3) << endl;\n\n    return 0;\n}\n```",
  "935": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int knightDialer(int n) {\n        if (n <= 0)\n            return 0;\n        \n        vector<vector<int>> dp(10, vector<int>(n+1));\n        dp[0][0] = 1;\n        \n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < 10; ++j) {\n                if (j == 0)\n                    dp[j][i] = dp[6][i-1];\n                else if (j == 9)\n                    dp[j][i] = dp[3][i-1];\n                else\n                    dp[j][i] = dp[(j+1)%10][i-1] + dp[(j+8)%10][i-1];\n            }\n        }\n        \n        int res = 0;\n        for (int i = 0; i < 10; ++i)\n            res += dp[i][n-1];\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1:\n    cout << \"Test case 1: \" << solution.knightDialer(1) << endl;\n    \n    // Test case 2:\n    cout << \"Test case 2: \" << solution.knightDialer(2) << endl;\n    \n    // Test case 3:\n    cout << \"Test case 3: \" << solution.knightDialer(3) << endl;\n    \n    return 0;\n}\n```",
  "936": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string findStamp(string s) {\n        int n = s.length();\n        stack<char> st;\n        \n        for(int i=n-1; i>=0; i--) {\n            if(s[i] == '1') {\n                while(!st.empty() && st.top() == '0') {\n                    st.pop();\n                }\n                if(st.empty()) {\n                    st.push('1');\n                } else {\n                    while(!st.empty() && st.top() == '1') {\n                        st.pop();\n                    }\n                    st.push('1');\n                }\n            } else {\n                while(!st.empty()) {\n                    st.pop();\n                }\n                st.push('0');\n            }\n        }\n        \n        string res = \"\";\n        while(!st.empty()) {\n            res += st.top();\n            st.pop();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    cout << \"Test case 1: \" << solution.findStamp(\"111110101\") << endl;\n\n    // Test case 2\n    cout << \"Test case 2: \" << solution.findStamp(\"01001111\") << endl;\n\n    // Test case 3\n    cout << \"Test case 3: \" << solution.findStamp(\"1111\") << endl;\n    \n    return 0;\n}\n```",
  "937": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> reorderLogFiles(vector<string>& logs) {\n        vector<string> letterLogs;\n        vector<string> digitLogs;\n        \n        for (const string& log : logs) {\n            if (log[log.length() - 1] == ' ') {\n                letterLogs.push_back(log);\n            } else {\n                digitLogs.push_back(log);\n            }\n        }\n        \n        sort(letterLogs.begin(), letterLogs.end(),\n             [](const string& a, const string& b) {\n                 size_t posA = a.find(' ');\n                 size_t posB = b.find(' ');\n                 string keyA = a.substr(posA + 1);\n                 string keyB = b.substr(posB + 1);\n                 \n                 if (keyA.compare(keyB) < 0) {\n                     return true;\n                 } else if (keyA.compare(keyB) > 0) {\n                     return false;\n                 } else {\n                     size_t posAManual = a.find(a, posA + 1);\n                     size_t posBManual = b.find(b, posB + 1);\n                     \n                     return posAManual < posBManual;\n                 }\n             });\n        \n        letterLogs.insert(letterLogs.end(), digitLogs.begin(), digitLogs.end());\n        \n        return letterLogs;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> logs1 = {\"a1.9 01\", \"log.goog 2020-08-14T23:59:59.999Z\", \"foo2.log 2018-03-27T15:51:45.555Z\", \"bar1.1 02\", \"hello\"};\n    vector<string> logs2 = {\"dig1 8 a07\", \"dog1 2\", \"log1 4\", \"o1 9 a2 5 d 1\", \"o1 9 a2 7 d 5\"};\n    vector<string> logs3 = {\"a1.1 02\", \"log.goog 2020-08-14T23:59:59.999Z\", \"foo2.log 2018-03-27T15:51:45.555Z\", \"bar1.1 02\"};\n\n    vector<string> result1 = solution.reorderLogFiles(logs1);\n    vector<string> result2 = solution.reorderLogFiles(logs2);\n    vector<string> result3 = solution.reorderLogFiles(logs3);\n\n    for (const string& log : result1) {\n        cout << log << endl;\n    }\n    cout << endl;\n\n    for (const string& log : result2) {\n        cout << log << endl;\n    }\n    cout << endl;\n\n    for (const string& log : result3) {\n        cout << log << endl;\n    }\n\n    return 0;\n}\n```",
  "938": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int rangeSumBST(TreeNode* root, int L, int R) {\n        int sum = 0;\n        std::function<void(TreeNode*)> dfs = [&](TreeNode* node) {\n            if (node == nullptr) return;\n            if (L <= node->val && node->val <= R) {\n                sum += node->val;\n            }\n            if (node->val > L) dfs(node->left);\n            if (node->val < R) dfs(node->right);\n        };\n        dfs(root);\n        return sum;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(10);\n    root1->left = new TreeNode(5);\n    root1->right = new TreeNode(15);\n    root1->left->left = new TreeNode(3);\n    root1->left->right = new TreeNode(8);\n    std::cout << \"Test case 1: \" << solution.rangeSumBST(root1, 7, 9) << std::endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(4);\n    root2->left = new TreeNode(1);\n    root2->right = new TreeNode(6);\n    std::cout << \"Test case 2: \" << solution.rangeSumBST(root2, 1, 3) << std::endl;\n\n    // Test case 3\n    TreeNode* root3 = nullptr;\n    std::cout << \"Test case 3: \" << solution.rangeSumBST(root3, 0, 5) << std::endl;\n\n    return 0;\n}\n```",
  "940": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int distinctSubseqII(string s) {\n        if (s.size() == 0) return 0;\n        \n        vector<int> dp(s.size(), 1);\n        vector<int> MOD = {1000000007};\n        int res = 1, mod = MOD[0];\n        \n        for (int i = 1; i < s.size(); ++i) {\n            if (s[i] == '0') continue;\n            \n            dp[i] = ((dp[i - 1] + 1) % mod + 1) * (res + 1) % mod - res;\n            for (int j = 0; j < i; ++j) {\n                if (s[j] != s[i]) dp[i] += dp[j];\n                else break;\n            }\n        }\n        \n        return (dp.back() + 1) % mod;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.distinctSubseqII(\"0\") << endl; // Expected output: 0\n    cout << \"Test case 2: \" << solution.distinctSubseqII(\"11\") << endl; // Expected output: 4\n    cout << \"Test case 3: \" << solution.distinctSubseqII(\"01\") << endl; // Expected output: 3\n\n    return 0;\n}\n```",
  "939": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minAreaRect(vector<vector<int>>& points) {\n        set<pair<int, int>> pointSet;\n        for (const auto& point : points) {\n            pointSet.insert({point[0], point[1]});\n        }\n\n        int minArea = INT_MAX;\n        for (int i = 0; i < pointSet.size(); ++i) {\n            for (int j = i + 1; j < pointSet.size(); ++j) {\n                pair<int, int> p1 = *pointSet.begin() + i;\n                pair<int, int> p2 = *pointSet.begin() + j;\n                if (p1.first == p2.second && p1.second == p2.first && \n                    pointSet.count({p1.first, p2.second}) && pointSet.count({p2.first, p1.second})) {\n                    minArea = min(minArea, abs(p1.first - p2.second) * abs(p1.second - p2.first));\n                }\n            }\n        }\n\n        return minArea == INT_MAX ? 0 : minArea;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> points1 = {{1,1},{1,3},{3,1},{3,3},{2,2}};\n    cout << \"Test case 1: \" << solution.minAreaRect(points1) << endl; // Output: 4\n\n    vector<vector<int>> points2 = {{1,1},{1,3},{2,2},{2,4}};\n    cout << \"Test case 2: \" << solution.minAreaRect(points2) << endl; // Output: 9\n\n    vector<vector<int>> points3 = {{1,1},{1,3},{2,2},{6,4},{5,6},{5,7}};\n    cout << \"Test case 3: \" << solution.minAreaRect(points3) << endl; // Output: 8\n\n    return 0;\n}\n```",
  "942": "```\n#include <iostream>\n#include <vector>\n\nstd::string diStringMatch(std::string s) {\n    int min = 0, max = s.length();\n    std::string result;\n    \n    for(int i=0; i<s.length(); i++) {\n        if(s[i] == 'I') {\n            result += (min++).to_string();\n        } else {\n            result += (max--).to_string();\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    std::cout << diStringMatch(\"IDIZI\") << std::endl;  // Expected: \"0-1-2-3\"\n    std::cout << diStringMatch(\"IED\") << std::endl;  // Expected: \"0-1-4\"\n    std::cout << diStringMatch(\"III\") << std::endl;  // Expected: \"0-1-2-2\"\n    \n    return 0;\n}\n```",
  "941": "```\n#include <iostream>\n#include <vector>\n\nbool validateMountain(std::vector<int>& arr) {\n    int peak = -1;\n    bool isMountain = false;\n\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > peak) {\n            peak = arr[i];\n        } else if (i == arr.size() - 1 || arr[i] <= arr[i + 1]) {\n            return false;\n        }\n    }\n\n    isMountain = true;\n\n    for (int i = arr.size() - 1; i >= 0; i--) {\n        if (arr[i] > peak) {\n            peak = arr[i];\n        } else if (!isMountain) {\n            return false;\n        }\n    }\n\n    return isMountain;\n}\n\nint main() {\n    std::vector<int> test1({2, 1});\n    std::cout << \"Test case 1: \" << (validateMountain(test1) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> test2({3, 5, 5});\n    std::cout << \"Test case 2: \" << (validateMountain(test2) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> test3({1, 2, 3, 4, 5});\n    std::cout << \"Test case 3: \" << (validateMountain(test3) ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n```",
  "944": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDeletions(vector<vector<int>>& rows) {\n        vector<int> colCounts;\n        for (int j = 0; j < rows[0].size(); j++) {\n            int count = 0;\n            for (int i = 0; i < rows.size(); i++) {\n                if (rows[i][j] == rows[0][j]) {\n                    count++;\n                }\n            }\n            colCounts.push_back(count);\n        }\n\n        int deletions = 0;\n        vector<bool> used(colCounts.size(), false);\n        for (int j = colCounts.size() - 1; j >= 0; j--) {\n            if (colCounts[j] == rows.size()) {\n                deletions++;\n                used[j] = true;\n            } else {\n                bool isUsed = false;\n                int maxCount = colCounts[j];\n                for (int k = j - 1; k >= 0 && !isUsed; k--) {\n                    if (!used[k]) {\n                        if (colCounts[k] > maxCount) {\n                            maxCount = colCounts[k];\n                            isUsed = true;\n                        } else if (colCounts[k] == maxCount && used[k]) {\n                            isUsed = true;\n                        }\n                    }\n                }\n                if (isUsed) {\n                    deletions++;\n                    used[j] = true;\n                }\n            }\n        }\n\n        return deletions;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> rows1 = {{1, 3}, {2, 4}};\n    cout << \"Test case 1: \" << solution.minDeletions(rows1) << endl; // Output: 0\n\n    vector<vector<int>> rows2 = {{1, 10, 3, 4}, {6, 8, 10, 5}, {9, 20, 15, 5}};\n    cout << \"Test case 2: \" << solution.minDeletions(rows2) << endl; // Output: 1\n\n    vector<vector<int>> rows3 = {{1, 2, 3, 4}, {5, 6, 7, 8}};\n    cout << \"Test case 3: \" << solution.minDeletions(rows3) << endl; // Output: 2\n\n    return 0;\n}\n```",
  "943": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint shortestSuperstring(const std::vector<std::string>& words) {\n    int n = words.size();\n    if (n == 0) return 0;\n\n    // Create a dp array to store the maximum length of the superstring\n    // for each subset of words.\n    std::vector<std::vector<int>> dp(1 << n, std::vector<int>(n));\n\n    // Initialize the dp array with values from the previous problem.\n    for (int mask = 0; mask < (1 << n); mask++) {\n        if (!(__builtin_popcount(mask) & 1)) continue;\n        int prev_mask = mask ^ ((mask >> 1) | (mask << 1));\n        for (int j = 0; j < n; j++) {\n            if (!(prev_mask & (1 << j))) {\n                dp[mask][j] = dp[prev_mask][j] + words[j].size();\n                break;\n            }\n        }\n    }\n\n    // Find the maximum length of the superstring.\n    int max_len = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        if (!(__builtin_popcount(mask) & 1)) continue;\n        int prev_mask = mask ^ ((mask >> 1) | (mask << 1));\n        for (int j = 0; j < n; j++) {\n            if (!(prev_mask & (1 << j))) {\n                dp[mask][j] = std::max(dp[prev_mask][j], dp[mask][j]);\n                break;\n            }\n        }\n    }\n\n    int res = 0;\n    for (int mask = (1 << n) - 1; mask >= 0; mask--) {\n        if (!(__builtin_popcount(mask) & 1)) continue;\n        for (int j = 0; j < n; j++) {\n            if (!(mask & (1 << j))) break;\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<std::string> words1 = {\"a\", \"b\", \"c\"};\n    int result1 = shortestSuperstring(words1);\n    std::cout << \"Test Case 1: \" << result1 << std::endl;\n\n    std::vector<std::string> words2 = {\"dog\", \"cat\", \"fish\", \"bird\"};\n    int result2 = shortestSuperstring(words2);\n    std::cout << \"Test Case 2: \" << result2 << std::endl;\n\n    std::vector<std::string> words3 = {\"alice\", \"bob\", \"charlie\", \"dave\", \"elvis\", \"frank\"};\n    int result3 = shortestSuperstring(words3);\n    std::cout << \"Test Case 3: \" << result3 << std::endl;\n}\n```",
  "945": "```\n#include <iostream>\n#include <vector>\n\nint minIncrementForUnique(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int res = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        if (nums[i] <= nums[i - 1]) {\n            int diff = nums[i - 1] - nums[i] + 1;\n            res += diff;\n            nums[i] += diff;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {4,2,3};\n    std::cout << \"Test Case 1: \" << minIncrementForUnique(test1) << std::endl;\n\n    std::vector<int> test2 = {1,2,2,3};\n    std::cout << \"Test Case 2: \" << minIncrementForUnique(test2) << std::endl;\n\n    std::vector<int> test3 = {0,1,2,3,4,5};\n    std::cout << \"Test Case 3: \" << minIncrementForUnique(test3) << std::endl;\n\n    return 0;\n}",
  "946": "```\n#include <iostream>\n#include <vector>\n#include <stack>\n\nbool validateStackSequences(std::vector<int>& pushed, std::vector<int>& popped) {\n    std::stack<int> stack;\n    int i = 0;\n\n    for (int j : popped) {\n        while (!stack.empty() && stack.top() != j) {\n            if ((int)i >= pushed.size()) return false; // If the top of the stack does not match the current pop operation and there are still elements to push, then the sequence is invalid.\n            stack.push(pushed[i]);\n            i++;\n        }\n        if (stack.empty()) continue;\n        stack.pop();\n    }\n\n    while (!stack.empty()) {\n        if ((int)i >= pushed.size()) return false; // If there are remaining elements in the stack after processing all pop operations, then the sequence is invalid.\n        if (stack.top() != pushed[i]) return false;\n        i++;\n        stack.pop();\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> pushed1 = {1, 2, 3};\n    std::vector<int> popped1 = [1, 2, 3];\n    if (validateStackSequences(pushed1, popped1)) {\n        std::cout << \"Case 1: Valid\" << std::endl;\n    } else {\n        std::cout << \"Case 1: Invalid\" << std::endl;\n    }\n\n    std::vector<int> pushed2 = {1, 2, 3, 4, 5};\n    std::vector<int> popped2 = [5, 3, 4, 2, 1];\n    if (validateStackSequences(pushed2, popped2)) {\n        std::cout << \"Case 2: Valid\" << std::endl;\n    } else {\n        std::cout << \"Case 2: Invalid\" << std::endl;\n    }\n\n    std::vector<int> pushed3 = {1};\n    std::vector<int> popped3 = [1];\n    if (validateStackSequences(pushed3, popped3)) {\n        std::cout << \"Case 3: Valid\" << std::endl;\n    } else {\n        std::cout << \"Case 3: Invalid\" << std::endl;\n    }\n\n    return 0;\n}",
  "948": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int bagOfTokensScore(vector<int>& tokens) {\n        sort(tokens.begin(), tokens.end());\n        int score = 0;\n        int left = 0, right = tokens.size() - 1;\n        \n        while (left <= right) {\n            if (tokens[left] == tokens[right]) {\n                score++;\n                left++;\n                right--;\n            } else if (tokens[left] < tokens[right]) {\n                score++;\n                left++;\n            } else {\n                score++;\n                right--;\n            }\n        }\n        return score;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> tokens1 = {8, 10, 6, 2, 7};\n    cout << \"Test case 1: \" << solution.bagOfTokensScore(tokens1) << endl;  // Output: 5\n\n    vector<int> tokens2 = {3, 4, 2};\n    cout << \"Test case 2: \" << solution.bagOfTokensScore(tokens2) << endl;  // Output: 3\n\n    vector<int> tokens3 = {10, 100};\n    cout << \"Test case 3: \" << solution.bagOfTokensScore(tokens3) << endl;  // Output: 1\n\n    return 0;\n}\n```",
  "947": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int removeStones(std::vector<std::vector<int>>& stones) {\n        int m = stones.size(), n = stones[0].size();\n        std::vector<std::vector<int>> rows(m, std::vector<int>(n, 0));\n        std::vector<std::vector<int>> cols(n, std::vector<int>(m, 0));\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                rows[i][j] = stones[i][j];\n                cols[j][i] = stones[i][j];\n            }\n        }\n\n        int removed = 0;\n        std::vector<int> rowGroups(m, 1), colGroups(n, 1);\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (rows[i][j] == 1) {\n                    int curRowGroup = rowGroups[i];\n                    int curColGroup = colGroups[j];\n\n                    while (curRowGroup > 1 && curColGroup > 1) {\n                        removed++;\n                        for (int k = i; k >= 0 && rows[k][j]; k--) {\n                            rows[k][j]--;\n                            if (--rowGroups[k] == 0) rows[k].clear();\n                        }\n                        for (int k = j; k >= 0 && cols[k][i]; k--) {\n                            cols[k][i]--;\n                            if (--colGroups[k] == 0) cols[k].clear();\n                        }\n                    }\n                }\n            }\n        }\n\n        return removed;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::vector<int>> stones1 = {{0, 0, 0, 0, 0}, {1, 1, 1, 0, 0}, {0, 1, 1, 1, 0}};\n    int result1 = solution.removeStones(stones1);\n    std::cout << \"Test case 1: Expected \" << 2 << \", got \" << result1 << \".\\n\";\n\n    std::vector<std::vector<int>> stones2 = {{0, 0, 0}, {1, 1, 0}, {1, 1, 1}};\n    int result2 = solution.removeStones(stones2);\n    std::cout << \"Test case 2: Expected \" << 3 << \", got \" << result2 << \".\\n\";\n\n    std::vector<std::vector<int>> stones3 = {{0, 1}, {1, 1}};\n    int result3 = solution.removeStones(stones3);\n    std::cout << \"Test case 3: Expected \" << 2 << \", got \" << result3 << \".\\n\";\n\n    return 0;\n}\n```",
  "949": "```\n#include <iostream>\n#include <vector>\n\nint largestTimeFromDigits(std::vector<int>& A) {\n    int maxTime = -1;\n    for (int i = 0; i <= 2 && i + 4 <= A.size() - 1; i++) {\n        for (int j = i + 1; j <= 3 && j + 3 <= A.size() - 1; j++) {\n            int hour = A[i] * 10 + A[j];\n            if (hour > 23) continue;\n            int minute = A[i + 2] * 10 + A[i + 3];\n            if (minute > 59) continue;\n            maxTime = std::max(maxTime, hour * 60 + minute);\n        }\n    }\n    return maxTime;\n}\n\nint main() {\n    std::vector<int> A1({1,2,3,4});\n    std::cout << \"Test case 1: \" << largestTimeFromDigits(A1) << std::endl;\n\n    std::vector<int> A2({5,9,9,23});\n    std::cout << \"Test case 2: \" << largestTimeFromDigits(A2) << std::endl;\n\n    std::vector<int> A3({1,5,0,0});\n    std::cout << \"Test case 3: \" << largestTimeFromDigits(A3) << std::endl;\n    \n    return 0;\n}\n```",
  "950": "```\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> deckRevealedIncreasing(vector<int>& deck) {\n        int n = deck.size();\n        vector<int> result(n);\n        priority_queue<int> pq(deck.begin(), deck.end());\n        \n        for (int i = 0; i < n - 1; ++i) {\n            result[i] = pq.top(); \n            pq.pop();\n        }\n        if (!pq.empty()) {\n            result[n-1] = pq.top();\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> deck1 = {17, 13, 11};\n    vector<int> expected1 = {11, 13, 17};\n    vector<int> actual1 = solution.deckRevealedIncreasing(deck1);\n    if (actual1 != expected1) {\n        cout << \"Test Case 1 failed.\" << endl;\n    } else {\n        cout << \"Test Case 1 passed.\" << endl;\n    }\n\n    // Test Case 2\n    vector<int> deck2 = {3, 5, 7};\n    vector<int> expected2 = [3, 5, 7];\n    vector<int> actual2 = solution.deckRevealedIncreasing(deck2);\n    if (actual2 != expected2) {\n        cout << \"Test Case 2 failed.\" << endl;\n    } else {\n        cout << \"Test Case 2 passed.\" << endl;\n    }\n\n    // Test Case 3\n    vector<int> deck3 = {1, 8, 12, 6, 7};\n    vector<int> expected3 = [1, 6, 7, 8, 12];\n    vector<int> actual3 = solution.deckRevealedIncreasing(deck3);\n    if (actual3 != expected3) {\n        cout << \"Test Case 3 failed.\" << endl;\n    } else {\n        cout << \"Test Case 3 passed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "952": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int largestComponentSize(vector<int>& A) {\n        unordered_map<int, vector<int>> graph;\n        for (int i = 0; i < A.size(); i++) {\n            for (int j = i + 1; j < A.size(); j++) {\n                if (A[i] != A[j]) {\n                    int commonFactor = findCommonFactor(A[i], A[j]);\n                    if (commonFactor > 1) {\n                        graph[A[i]].push_back(A[j]);\n                        graph[A[j]].push_back(A[i]);\n                    }\n                }\n            }\n        }\n\n        unordered_map<int, int> count;\n        for (int i = 0; i < A.size(); i++) {\n            vector<int> component = {A[i]};\n            bool visited[] = new bool[10001]();\n            DFS(graph, A[i], &component, visited);\n            count[max_element(component.begin(), component.end())]++;\n        }\n\n        return *max_element(count.begin(), count.end());\n    }\n\n    void DFS(unordered_map<int, vector<int>>& graph, int node, vector<int>* component, bool* visited) {\n        if (visited[node]) return;\n        visited[node] = true;\n        (*component).push_back(node);\n        for (int neighbor : graph[node]) {\n            DFS(graph, neighbor, component, visited);\n        }\n    }\n\n    int findCommonFactor(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> A1 = {4,13,2};\n    cout << solution.largestComponentSize(A1) << endl; // Output: 3\n\n    vector<int> A2 = {21, 32 };\n    cout << solution.largestComponentSize(A2) << endl; // Output: 2\n\n    vector<int> A3 = {16,17,18};\n    cout << solution.largestComponentSize(A3) << endl; // Output: 1\n    return 0;\n}\n```",
  "951": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<TreeNode*> flipEquiv(TreeNode* root) {\n        if (root == NULL)\n            return {};\n        vector<TreeNode*> result = {root};\n        helper(root, root, result);\n        return result;\n    }\n\nprivate:\n    void helper(TreeNode* t1, TreeNode* t2, vector<TreeNode*>& result) {\n        if ((t1 == NULL && t2 == NULL) || (t1 != NULL && t2 != NULL)) {\n            result.push_back(t1);\n            return;\n        }\n        if (t1 != NULL)\n            t1->val = t2->val;\n        if (t1 != NULL && t2 != NULL) {\n            TreeNode* temp = t1->left;\n            t1->left = t2->right;\n            t2->right = temp;\n        } else if (t1 == NULL && t2 != NULL) {\n            t1 = new TreeNode(t2->val);\n            t1->left = t2->left;\n            t1->right = t2->right;\n            result.push_back(t1);\n        }\n        helper(t1->left, t1->right, result);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    vector<TreeNode*> test1 = solution.flipEquiv(root1);\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(6);\n    root2->left->left = new TreeNode(3);\n    root2->left->right = new TreeNode(4);\n    vector<TreeNode*> test2 = solution.flipEquiv(root2);\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(4);\n    root3->right = new TreeNode(8);\n    root3->left->left = new TreeNode(5);\n    root3->left->right = new TreeNode(6);\n    root3->right->left = new TreeNode(7);\n    root3->right->right = new TreeNode(9);\n    vector<TreeNode*> test3 = solution.flipEquiv(root3);\n\n    cout << \"Test case 1:\" << endl;\n    for (TreeNode* node : test1) {\n        if (node != NULL)\n            cout << node->val << \" \";\n        else\n            cout << \"null \";\n    }\n    cout << endl;\n\n    cout << \"Test case 2:\" << endl;\n    for (TreeNode* node : test2) {\n        if (node != NULL)\n            cout << node->val << \" \";\n        else\n            cout << \"null \";\n    }\n    cout << endl;\n\n    cout << \"Test case 3:\" << endl;\n    for (TreeNode* node : test3) {\n        if (node != NULL)\n            cout << node->val << \" \";\n        else\n            cout << \"null \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "954": "```\n#include <iostream>\n#include <vector>\n\nbool canBeEqual(std::vector<int>& target) {\n    int ones = 0, twos = 0;\n    for (int num : target) {\n        if (num % 2 == 1) {\n            ones++;\n        } else {\n            twos++;\n        }\n    }\n    return ones == twos;\n}\n\nint main() {\n    std::vector<int> test1 = {1,2,3,4,5};\n    std::cout << (canBeEqual(test1) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> test2 = {3,1,3,1,2};\n    std::cout << (canBeEqual(test2) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> test3 = {7,4,5,6};\n    std::cout << (canBeEqual(test3) ? \"True\" : \"False\") << std::endl;\n    \n    return 0;\n}",
  "953": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isAlienSorted(string words[], int n) {\n        int len = words[0].size();\n        vector<pair<char, int>> dict(len);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 1; j <= words[i].size(); j++) {\n                if (words[i][j-1] > words[i][j]) {\n                    return false;\n                }\n                if (dict[words[i].size()-j].first == words[i][j-1] && dict[words[i].size()-j].second < i) {\n                    return false;\n                }\n                dict[words[i].size()-j].first = words[i][j-1];\n                dict[words[i].size()-j].second = i;\n            }\n        }\n        \n        for (int i = 0; i < len - 1; i++) {\n            if (dict[i].first > dict[i+1].first) {\n                return false;\n            } else if (dict[i].first == dict[i+1].first && dict[i].second > dict[i+1].second) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    string words1[] = {\"hello\",\"ihave\",\"hive\"};\n    cout << (solution.isAlienSorted(words1, 3) ? \"True\" : \"False\") << endl; // False\n\n    string words2[] = {\"kucuro\",\"cxqqxq\",\"kuqucu\",\"uququc\"};\n    cout << (solution.isAlienSorted(words2, 4) ? \"True\" : \"False\") << endl; // True\n\n    string words3[] = {\"aaa\",\"aa\",\"a\"};\n    cout << (solution.isAlienSorted(words3, 3) ? \"True\" : \"False\") << endl; // False\n\n    return 0;\n}\n```",
  "955": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint minDeletions(std::vector<std::string>& cols) {\n    int n = cols.size();\n    std::vector<int> dp(n + 1, 0);\n    \n    for (int i = 1; i <= n; ++i) {\n        int prev = 0;\n        for (int j = 1; j < i; ++j) {\n            if (cols[j - 1][j] <= cols[i - 1][j]) {\n                prev = dp[j];\n            }\n        }\n        dp[i] = prev + 1;\n    }\n    \n    int ans = 0;\n    for (int i = n; i >= 1; --i) {\n        if (dp[i] < dp[i - 1]) {\n            ans += dp[i] - 1;\n            break;\n        } else {\n            ans += dp[i];\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    std::vector<std::string> cols1 = {\"cba\",\"daf\",\"ghi\"};\n    std::cout << \"Test case 1: \" << minDeletions(cols1) << std::endl;\n\n    std::vector<std::string> cols2 = {\"a\",\"b\"};\n    std::cout << \"Test case 2: \" << minDeletions(cols2) << std::endl;\n\n    std::vector<std::string> cols3 = {\"aaa\",\"aaabaaaa\",\"baaab\",\"aba\",\"bbbbbbbbb\"};\n    std::cout << \"Test case 3: \" << minDeletions(cols3) << std::endl;\n\n    return 0;\n}",
  "956": "```\n#include <iostream>\n#include <vector>\n\nint tallestBillboard(int[] billboard) {\n    int n = billboard.length;\n    int maxArea = 0;\n\n    for (int i = 0; i < n - 1; ++i) {\n        int area = (billboard[i] + billboard[i+1]) * (n - 1);\n        if (area > maxArea)\n            maxArea = area;\n    }\n\n    return maxArea;\n}\n\nint main() {\n    int testCases[][] = {\n        {8, 4, 12}, // Expected output: 144\n        {10, 6, 13, 7, 8}, // Expected output: 192\n        {1, 2} // Expected output: 3\n    };\n\n    for (int i = 0; i < testCases.length; ++i) {\n        int result = tallestBillboard(testCases[i]);\n        System.out.println(\"Test case \" + i + \": \" + result);\n    }\n\n    return 0;\n}\n```",
  "958": "```\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    bool isCompleteTree(TreeNode* root) {\n        if (!root) return true;\n        queue<TreeNode*> q;\n        q.push(root);\n        bool noMoreNodes = false;\n        while (!q.empty()) {\n            TreeNode* node = q.front();\n            q.pop();\n            if (node->left) {\n                q.push(node->left);\n            } else {\n                noMoreNodes = true;\n            }\n            if (node->right) {\n                q.push(node->right);\n            } else {\n                noMoreNodes = true;\n            }\n            if (noMoreNodes && node->val != 0) return false;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->left->left = new TreeNode(4);\n    root1->left->right = new TreeNode(5);\n    cout << \"Test case 1: \" << (solution.isCompleteTree(root1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(3);\n    cout << \"Test case 2: \" << (solution.isCompleteTree(root2) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(3);\n    root3->right->left = new TreeNode(4);\n    cout << \"Test case 3: \" << (solution.isCompleteTree(root3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "957": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> prisonAfterNDays(int cells[50][50], int n) {\n        set<vector<int>> seen;\n        int cycle = -1;\n        while (n--) {\n            vector<int> newCells(8);\n            for (int i = 0; i < 8; i++) {\n                bool bothOn = (cells[i][0] == cells[i][1]);\n                bool bothOff = (cells[i][0] == 0 && cells[i][1] == 0);\n                if ((bothOn || bothOff) && i > 0 && i < 7)\n                    newCells[i] = cells[i][i-1] ? 1 : 0;\n                else\n                    newCells[i] = (cells[i][0] + cells[i][1]) % 2;\n            }\n            if (seen.find(newCells) != seen.end()) {\n                cycle = n;\n                break;\n            } else {\n                seen.insert(newCells);\n            }\n            for (int i = 0; i < 8; i++) {\n                cells[i][7] = newCells[i];\n            }\n        }\n        if (cycle == -1) return cells[0];\n        int result[50][50];\n        for (int i = 0; i < 50; i++)\n            for (int j = 0; j < 50; j++)\n                result[i][j] = cells[(i+j)%8][j];\n        vector<int> res;\n        while (cycle--) {\n            vector<int> newCells(8);\n            for (int i = 0; i < 8; i++) {\n                bool bothOn = (result[i][0] == result[i][1]);\n                bool bothOff = (result[i][0] == 0 && result[i][1] == 0);\n                if ((bothOn || bothOff) && i > 0 && i < 7)\n                    newCells[i] = result[i][i-1] ? 1 : 0;\n                else\n                    newCells[i] = (result[i][0] + result[i][1]) % 2;\n            }\n            for (int i = 0; i < 8; i++) {\n                cells[i][7] = newCells[i];\n            }\n        }\n        for (int i = 0; i < 50; i++)\n            for (int j = 0; j < 50; j++)\n                res.push_back(result[i][j]);\n        return res;\n    }\n};\n\nint main() {\n    Solution sol;\n    int cells1[50][50] = {{0,1,0,1,1,0,1,0},{0,0,1,0,1,1,1,0},{0,0,0,1,1,1,1,0},{1,0,1,1,1,1,1,0},{1,0,0,1,1,1,1,0},{1,0,0,0,1,1,1,0},{1,0,0,0,0,1,1,0},{1,0,0,0,0,0,1,0}};\n    int n1 = 7;\n    vector<int> res1 = sol.prisonAfterNDays(cells1, n1);\n    for (int i : res1)\n        cout << i << \" \";\n    cout << endl;\n\n    int cells2[50][50] = {{0,1},{0,0}};\n    int n2 = 14;\n    vector<int> res2 = sol.prisonAfterNDays(cells2, n2);\n    for (int i : res2)\n        cout << i << \" \";\n    cout << endl;\n\n    int cells3[50][50] = {{1,0,0},{0,1,1}};\n    int n3 = 10;\n    vector<int> res3 = sol.prisonAfterNDays(cells3, n3);\n    for (int i : res3)\n        cout << i << \" \";\n    cout << endl;\n\n    return 0;\n}",
  "960": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint deletionsRequired(vector<string>& strArr) {\n    int res = 0;\n    for (int i = 0; i < strArr[0].size(); i++) {\n        bool isSorted = true;\n        for (int j = 1; j < strArr.size(); j++) {\n            if (strArr[j][i] < strArr[j - 1][i]) {\n                isSorted = false;\n                break;\n            }\n        }\n        res += !isSorted;\n    }\n    return res;\n}\n\nint main() {\n    vector<string> strs1 = {\"cba\",\"daf\",\"ghi\"};\n    cout << deletionsRequired(strs1) << endl; // Expected output: 2\n\n    vector<string> strs2 = {\"a\",\"b\"};\n    cout << deletionsRequired(strs2) << endl; // Expected output: 0\n\n    vector<string> strs3 = {\"aaa\",\"bbb\",\"ccc\"};\n    cout << deletionsRequired(strs3) << endl; // Expected output: 1\n    return 0;\n}\n```",
  "959": "```\n#include <iostream>\n#include <vector>\n\nint regionsCutBySlashes(std::vector<std::vector<char>>& grid) {\n    int n = grid.size();\n    if (n == 0) return 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == '/') {\n                grid[i][j] = '\\\\';\n                if (i > 0) grid[i-1][j+1] = '/';\n                if (j < n-1 && i < n-1) grid[i+1][j] = '\\\\';\n            } else if (grid[i][j] == '\\\\') {\n                grid[i][j] = '/';\n                if (i > 0) grid[i-1][j+1] = '\\\\';\n                if (j < n-1 && i < n-1) grid[i+1][j] = '/';\n            }\n        }\n    }\n\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == '/') {\n                if (i > 0 && grid[i-1][j] == '\\\\') continue;\n                if (j < n-1 && grid[i][j+1] == '/') continue;\n                count++;\n            } else if (grid[i][j] == '\\\\') {\n                if (i > 0 && grid[i-1][j] == '/') continue;\n                if (j < n-1 && grid[i][j+1] == '\\\\') continue;\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    std::vector<std::vector<char>> grid1 = {{0,1},{1,1}};\n    std::cout << \"Test Case 1: \" << regionsCutBySlashes(grid1) << std::endl;\n\n    std::vector<std::vector<char>> grid2 = {{1,1},{1,1}};\n    std::cout << \"Test Case 2: \" << regionsCutBySlashes(grid2) << std::endl;\n\n    std::vector<std::vector<char>> grid3 = {{0,0,0,1},{1,1,0,1},{0,1,1,0}};\n    std::cout << \"Test Case 3: \" << regionsCutBySlashes(grid3) << std::endl;\n    \n    return 0;\n}\n```",
  "961": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint findDuplicate(std::vector<int>& nums) {\n    unordered_map<int, int> hash;\n    for (int num : nums) {\n        if (hash.find(num) != hash.end()) {\n            return num;\n        }\n        hash[num] = 1;\n    }\n    return -1;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {1, 3, 4, 2, 3};\n    int result1 = findDuplicate(test1);\n    if (result1 == 3) {\n        std::cout << \"Test case 1: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Fail\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> test2 = {1, 2, 3, 4};\n    int result2 = findDuplicate(test2);\n    if (result2 == -1) {\n        std::cout << \"Test case 2: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Fail\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> test3 = {0, 1, 3};\n    int result3 = findDuplicate(test3);\n    if (result3 == 0) {\n        std::cout << \"Test case 3: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Fail\" << std::endl;\n    }\n\n    return 0;\n}",
  "962": "```\n#include <iostream>\n#include <vector>\n\nint maxWidthRamp(std::vector<int>& ramp) {\n    int n = ramp.size();\n    std::vector<int> left(n);\n    std::vector<int> right(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if (!left[i]) left[i] = i;\n        for (int j = i - 1; j >= 0 && !left[j]; --j) left[i] = j + 1;\n    }\n    \n    for (int i = n - 1; i >= 0; --i) {\n        if (!right[i]) right[i] = i;\n        for (int j = i + 1; j < n && !right[j]; ++j) right[i] = j;\n    }\n    \n    int maxW = 0, w = 0;\n    for (int i = 0; i < n; ++i) {\n        if (ramp[i] == 0) w++;\n        else w--;\n        \n        if (w + left[i] > maxW) maxW = w + left[i];\n    }\n    \n    return maxW;\n}\n\nint main() {\n    std::vector<int> ramp1({6,12,5,9,5,4,3});\n    std::cout << \"Maximum width for ramp 1: \" << maxWidthRamp(ramp1) << std::endl;\n\n    std::vector<int> ramp2({9,7,5,3,2,1});\n    std::cout << \"Maximum width for ramp 2: \" << maxWidthRamp(ramp2) << std::endl;\n\n    std::vector<int> ramp3({1,6,8,10,5});\n    std::cout << \"Maximum width for ramp 3: \" << maxWidthRamp(ramp3) << std::endl;\n\n    return 0;\n}\n```",
  "963": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int minAreaRect(std::vector<std::vector<int>>& points) {\n        // your logic here\n        return 0;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::vector<int>> points1 = {{1,1},{1,3},{3,1},{3,3}};\n    std::cout << \"Test case 1: \" << solution.minAreaRect(points1) << std::endl;\n    \n    std::vector<std::vector<int>> points2 = {{0,1},{1,0},{1,2},{2,1}};\n    std::cout << \"Test case 2: \" << solution.minAreaRect(points2) << std::endl;\n\n    std::vector<std::vector<int>> points3 = {{1,2},{2,1},{2,4},{4,1}};\n    std::cout << \"Test case 3: \" << solution.minAreaRect(points3) << std::endl;\n    \n    return 0;\n}\n```",
  "964": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMinInsertOps(int n) {\n        if(n < 1) return 0;\n        vector<int> dp(n+1, INT_MAX);\n        dp[0] = 0;\n        for(int i=0; i<=n; i++) {\n            for(int j=i; j<=n; j++) {\n                int diff = j - i;\n                if(diff >= i) {\n                    dp[j] = min(dp[j], 1 + (i > 0 ? dp[i-1] : 0));\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\nint main() {\n    Solution sol;\n    cout << sol.findMinInsertOps(10) << endl; // Output: 4\n    cout << sol.findMinInsertOps(15) << endl; // Output: 6\n    cout << sol.findMinInsertOps(30) << endl; // Output: 12\n    return 0;\n}\n```",
  "965": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    bool isUnivalued(TreeNode* root) {\n        if (root == nullptr)\n            return true;\n\n        if ((root->left != nullptr && root->left->val != root->val) ||\n            (root->right != nullptr && root->right->val != root->val))\n            return false;\n\n        return isUnivalued(root->left) && isUnivalued(root->right);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1:\n    TreeNode* root = new TreeNode(0);\n    root->left = new TreeNode(0);\n    root->right = new TreeNode(0);\n    cout << \"Test Case 1: \" << (solution.isUnivalued(root) ? \"True\" : \"False\") << endl;\n\n    // Test Case 2:\n    root = new TreeNode(1);\n    root->left = new TreeNode(1);\n    root->right = new TreeNode(0);\n    cout << \"Test Case 2: \" << (solution.isUnivalued(root) ? \"True\" : \"False\") << endl;\n\n    // Test Case 3:\n    root = new TreeNode(4);\n    root->left = new TreeNode(2);\n    root->right = new TreeNode(4);\n    cout << \"Test Case 3: \" << (solution.isUnivalued(root) ? \"True\" : \"False\") << endl;\n    \n    return 0;\n}\n```",
  "966": "```\n#include <iostream>\n#include <unordered_map>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> spellchecker(vector<string>& wordlist, vector<string>& queries) {\n        unordered_map<string, string> words;\n        unordered_map<string, bool> hasVowel;\n        \n        for (const auto& w : wordlist) {\n            if (!hasVowel.count(w)) {\n                hasVowel[w] = true;\n            }\n            for (char c : w) {\n                if (isvowel(c)) {\n                    words[w] += tolower(c);\n                    break;\n                }\n            }\n        }\n        \n        vector<string> res;\n        for (const auto& q : queries) {\n            string queryLower = tolower(q);\n            if (words.count(queryLower)) {\n                res.push_back(words[queryLower]);\n            } else {\n                bool hasVowelInQuery = false;\n                for (char c : queryLower) {\n                    if (isvowel(c)) {\n                        hasVowelInQuery = true;\n                        break;\n                    }\n                }\n                if (!hasVowelInQuery) {\n                    res.push_back(query);\n                } else {\n                    res.push_back(\"\");\n                }\n            }\n        }\n        \n        return res;\n    }\n    \n    bool isvowel(char c) {\n        return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\n                || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n    }\n};\n\nint main() {\n    Solution s;\n    \n    vector<string> wordlist = {\"KiTe\",\"kite\",\"Havakespeare\"},\n                   queries = {\"What is the vowel spellchecker?\",\"letsclimbyou\"};\n    \n    vector<string> result = s.spellchecker(wordlist, queries);\n    \n    for (const auto& res : result) {\n        cout << res << endl;\n    }\n    \n    return 0;\n}\n```",
  "967": "```\n#include <iostream>\n#include <vector>\n\nbool dfs(int num, std::vector<int>& nums, int target) {\n    if (num > target) return false;\n    if (std::find(nums.begin(), nums.end(), num) != nums.end()) return true;\n    \n    for (int i = 1; i <= 9; i++) {\n        if (dfs(num * 10 + i, nums, target)) return true;\n    }\n    return false;\n}\n\nbool checkStraightLine(std::vector<int>& coordinates) {\n    int x0 = coordinates[0], y0 = coordinates[1];\n    int x1 = coordinates[2], y1 = coordinates[3];\n    \n    if ((x1 - x0) == 0) {\n        for (int i = 4; i < coordinates.size(); i += 2) {\n            if (coordinates[i] != x0 || coordinates[i + 1] != y0) return false;\n        }\n        return true;\n    } else {\n        for (int i = 4; i < coordinates.size(); i += 2) {\n            if ((coordinates[i] - x0) * (y1 - y0) != (x1 - x0) * (coordinates[i + 1] - y0)) return false;\n        }\n        return true;\n    }\n}\n\nint main() {\n    std::vector<int> nums1 = {2,6,4,8};\n    int ans1 = checkStraightLine(nums1);\n    std::cout << \"Test Case 1: \" << (ans1 ? \"True\" : \"False\") << std::endl;\n    \n    std::vector<int> nums2 = {3,1,2};\n    int ans2 = checkStraightLine(nums2);\n    std::cout << \"Test Case 2: \" << (ans2 ? \"True\" : \"False\") << std::endl;\n    \n    std::vector<int> nums3 = {4,7,9};\n    int ans3 = checkStraightLine(nums3);\n    std::cout << \"Test Case 3: \" << (ans3 ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n\n```",
  "968": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int watchTime(TreeNode* root) {\n        if (root == nullptr) return 0;\n        \n        if (root->val == 1) return 0; // already watched\n        \n        int time = 1 + watchTime(root->left) + watchTime(root->right); \n        // the camera at this node will spend one unit of time\n        \n        root->val = 1; // mark as watched\n        \n        return time;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1:\n    TreeNode* tree1 = new TreeNode(0);\n    tree1->left = new TreeNode(0);\n    tree1->right = new TreeNode(0);\n    cout << \"Test case 1: \" << s.watchTime(tree1) << endl; \n\n    // Test case 2:\n    TreeNode* tree2 = new TreeNode(0);\n    tree2->left = new TreeNode(0);\n    tree2->left->left = new TreeNode(0);\n    tree2->right = new TreeNode(0);\n    cout << \"Test case 2: \" << s.watchTime(tree2) << endl; \n\n    // Test case 3:\n    TreeNode* tree3 = new TreeNode(1);\n    tree3->left = new TreeNode(0);\n    tree3->right = new TreeNode(0);\n    tree3->left->left = new TreeNode(0);\n    cout << \"Test case 3: \" << s.watchTime(tree3) << endl; \n\n    return 0;\n}\n```",
  "969": "```\n#include <iostream>\n#include <vector>\n\nvoid pancakeSort(std::vector<int>& arr) {\n    int n = arr.size();\n    for (int i = n / 2; i > 0; --i) {\n        int maxIndex = getMax(arr, i);\n        if (maxIndex != i) {\n            reverse(arr, 0, i);\n            reverse(arr, 0, maxIndex);\n        }\n    }\n}\n\nint getMax(const std::vector<int>& arr, int n) {\n    int maxi = 0;\n    for (int i = 1; i < n; ++i)\n        if (arr[i] > arr[maxi])\n            maxi = i;\n    return maxi;\n}\n\nvoid reverse(std::vector<int>& arr, int start, int end) {\n    while (start < end) {\n        std::swap(arr[start], arr[end]);\n        start++;\n        end--;\n    }\n}\n\nint main() {\n    std::vector<int> test1({3, 2, 4, 1});\n    pancakeSort(test1);\n    for (auto x : test1) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<int> test2({1, 2, 3, 4, 5});\n    pancakeSort(test2);\n    for (auto x : test2) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<int> test3({6, 5, 4, 3, 2, 1});\n    pancakeSort(test3);\n    for (auto x : test3) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";\n}\n```",
  "970": "```\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nint numIdenticalPairs(std::vector<int>& nums) {\n    int count = 0;\n    std::unordered_set<int> seen;\n    for (int num : nums) {\n        if (seen.find(num) != seen.end()) {\n            count += seen.count(num);\n        }\n        seen.insert(num);\n    }\n    return count;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 3, 4};\n    int result1 = numIdenticalPairs(nums1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> nums2 = {1, 1, 1, 1};\n    int result2 = numIdenticalPairs(nums2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> nums3 = {2, 3, 4, 5};\n    int result3 = numIdenticalPairs(nums3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "972": "```\n#include <iostream>\n#include <vector>\n#include <sstream>\n\nbool canBeEqual(std::vector<std::string>& nums) {\n    std::map<int, int> map;\n    for (const auto& num : nums) {\n        if (num[0] == '-') {\n            map[-stoi(num.substr(1))]++;\n        } else {\n            map[stoi(num)]++;\n        }\n    }\n    return map.size() <= 2 && (!map.empty() || map.size() == 3);\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::string> nums1 = {\"0/1\",\"4/6\",\"7/8\"};\n    if (canBeEqual(nums1)) {\n        std::cout << \"Test case 1: Pass\\n\";\n    } else {\n        std::cout << \"Test case 1: Fail\\n\";\n    }\n\n    // Test case 2\n    std::vector<std::string> nums2 = {\"0/1\",\"4/2\"};\n    if (canBeEqual(nums2)) {\n        std::cout << \"Test case 2: Pass\\n\";\n    } else {\n        std::cout << \"Test case 2: Fail\\n\";\n    }\n\n    // Test case 3\n    std::vector<std::string> nums3 = {\"0/1\",\"5/25\",\"-3/7\"};\n    if (canBeEqual(nums3)) {\n        std::cout << \"Test case 3: Pass\\n\";\n    } else {\n        std::cout << \"Test case 3: Fail\\n\";\n    }\n\n    return 0;\n}\n```",
  "971": "```\n#include <iostream>\n#include <vector>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* flipEULER(TreeNode* root) {\n        if (root == NULL || (root->left == NULL && root->right == NULL)) {\n            return root;\n        }\n\n        root->left = flipEULER(root->left);\n        root->right = flipEULER(root->right);\n\n        TreeNode *temp = root->left;\n        root->left = root->right;\n        root->right = temp;\n\n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* test1_root = new TreeNode(1);\n    test1_root->left = new TreeNode(2);\n    test1_root->right = new TreeNode(3);\n    test1_root->left->left = new TreeNode(4);\n    test1_root->left->right = new TreeNode(5);\n\n    TreeNode* result1 = solution.flipEULER(test1_root);\n    std::cout << \"Test case 1: \";\n    printTree(result1);\n    deleteTreeNode(result1);\n\n    // Test case 2\n    TreeNode* test2_root = new TreeNode(1);\n    test2_root->left = new TreeNode(3);\n    test2_root->right = new TreeNode(4);\n    test2_root->left->left = new TreeNode(5);\n    test2_root->left->right = new TreeNode(6);\n\n    TreeNode* result2 = solution.flipEULER(test2_root);\n    std::cout << \"Test case 2: \";\n    printTree(result2);\n    deleteTreeNode(result2);\n\n    // Test case 3\n    TreeNode* test3_root = new TreeNode(1);\n\n    TreeNode* result3 = solution.flipEULER(test3_root);\n    std::cout << \"Test case 3: \";\n    printTree(result3);\n    deleteTreeNode(result3);\n\n    return 0;\n}\n\nvoid printTree(TreeNode* root) {\n    if (root == NULL) {\n        return;\n    }\n\n    std::cout << root->val << \" \";\n    printTree(root->left);\n    printTree(root->right);\n}\n\nvoid deleteTreeNode(TreeNode* node) {\n    if (node == NULL) {\n        return;\n    }\n\n    deleteTreeNode(node->left);\n    deleteTreeNode(node->right);\n\n    delete node;\n}",
  "973": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Point {\n    int x;\n    int y;\n};\n\nbool comparePoints(const Point& p1, const Point& p2) {\n    return (p1.x * p1.x + p1.y * p1.y) > (p2.x * p2.x + p2.y * p2.y);\n}\n\nint kClosest(std::vector<Point>& points, int K) {\n    std::nth_element(points.begin(), points.begin() + K, comparePoints);\n    return 0;\n}\n\nint main() {\n    std::vector<Point> points1 = {{1,3},{-2,-1}};\n    kClosest(points1, 1);\n    \n    std::vector<Point> points2 = {{3,3},{5,-1},{-2,4}};\n    kClosest(points2, 2);\n    \n    std::vector<Point> points3 = {{-5,-6},{-2,15},{10,12}};\n    kClosest(points3, 3);\n\n    return 0;\n}\n```",
  "974": "```\n#include <iostream>\n#include <vector>\n\nint subarraysDivByK(std::vector<int>& nums, int k) {\n    int count[1001] = {0}; // assume max sum less than 1000\n    int total = 0;\n    for (int i : nums) {\n        total += i;\n        int rem = (total % k + k) % k; // ensure rem in [0, k-1]\n        count[rem]++;\n    }\n    int res = 0;\n    count[0] = count[0] > 1 ? count[0] - 1 : 0;\n    for (int i = 1; i < k; i++) {\n        if (count[i]) res += count[i];\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {4,5,0,-2,-3};\n    int k1 = 5;\n    std::cout << subarraysDivByK(nums1, k1) << std::endl;\n\n    std::vector<int> nums2 = {6,11,null};\n    int k2 = 3;\n    try {\n        std::cout << subarraysDivByK(nums2, k2) << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << '\\n';\n    }\n\n    std::vector<int> nums3 = {23, 0};\n    int k3 = 7;\n    std::cout << subarraysDivByK(nums3, k3) << std::endl;\n\n    return 0;\n}",
  "975": "```\n#include <iostream>\n#include <vector>\n\nint oddEvenJump(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<bool> dp(n, false);\n    dp[0] = true;\n    \n    for (int i = 0; i < n; ++i) {\n        if (!dp[i]) continue;\n        \n        int j = i + 1;\n        while (j < n && nums[j] > nums[i]) j++;\n        for (; j >= 0; --j) {\n            if (!dp[j]) dp[j] = true;\n            else break;\n        }\n    }\n    \n    for (int i = n - 1; i >= 0; --i) {\n        if (!dp[i]) continue;\n        \n        int j = i - 1;\n        while (j >= 0 && nums[j] < nums[i]) j--;\n        for (; j >= 0; ++j) {\n            if (!dp[j]) dp[j] = true;\n            else break;\n        }\n    }\n    \n    int ans = 0;\n    for (int i = 0; i < n; ++i) if (dp[i]) ans++;\n    \n    return ans;\n}\n\nint main() {\n    std::vector<int> nums1 = {10,13,12,14,15};\n    std::cout << \"Test case 1: \" << oddEvenJump(nums1) << std::endl;\n\n    std::vector<int> nums2 = {3,5,8};\n    std::cout << \"Test case 2: \" << oddEvenJump(nums2) << std::endl;\n\n    std::vector<int> nums3 = {0,1,2,3,4};\n    std::cout << \"Test case 3: \" << oddEvenJump(nums3) << std::endl;\n    \n    return 0;\n}\n```",
  "976": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint largestPerimeter(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int max_perimeter = 0;\n    for (int i = nums.size() - 1; i >= 2; --i) {\n        if (nums[i] + nums[i-1] > nums[i-2]) {\n            return nums[i] + nums[i-1] + nums[i-2];\n        }\n    }\n    return max_perimeter;\n}\n\nint main() {\n    std::vector<int> test1 = {3, 2, 6, 8};\n    std::cout << \"Test case 1: \" << largestPerimeter(test1) << std::endl;\n\n    std::vector<int> test2 = {10, 2, 5, 11};\n    std::cout << \"Test case 2: \" << largestPerimeter(test2) << std::endl;\n\n    std::vector<int> test3 = {1, 2, 3};\n    std::cout << \"Test case 3: \" << largestPerimeter(test3) << std::endl;\n    return 0;\n}\n```",
  "977": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> sortedSquares(std::vector<int>& nums) {\n    std::vector<int> result;\n    int left = 0, right = nums.size() - 1;\n\n    while (left <= right) {\n        if (std::abs(nums[left]) > std::abs(nums[right])) {\n            result.push_back((nums[left] * nums[left]));\n            left++;\n        } else {\n            result.push_back((nums[right] * nums[right]));\n            right--;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> nums1 = {-4, -3, -2, -1, 0};\n    std::vector<int> result1 = sortedSquares(nums1);\n    for (int num : result1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {-1, 0, 1, 10};\n    std::vector<int> result2 = sortedSquares(nums2);\n    for (int num : result2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {1, 2, 3, 4, 5};\n    std::vector<int> result3 = sortedSquares(nums3);\n    for (int num : result3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "978": "```\n#include <iostream>\n#include <vector>\n\nint maxTurbulenceSize(std::vector<int>& arr) {\n    int n = arr.size();\n    if (n == 0) return 0;\n    \n    int ans = 1;\n    bool isTurbulent = false;\n    \n    for (int i = 1; i < n; ++i) {\n        if (std::abs(arr[i] - arr[i-1]) > 1 || (!isTurbulent && std::signbit(arr[i] - arr[i-1]))){\n            isTurbulent = !isTurbulent;\n            ans = std::max(ans, i+1);\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    std::vector<int> arr1 = {9, 4, 7, 2, 10};\n    std::cout << \"Test Case 1: Expected - 5, Got - \" << maxTurbulenceSize(arr1) << std::endl;\n\n    std::vector<int> arr2 = {9, 6, 8, 2, 1, 4};\n    std::cout << \"Test Case 2: Expected - 5, Got - \" << maxTurbulenceSize(arr2) << std::endl;\n\n    std::vector<int> arr3 = {4};\n    std::cout << \"Test Case 3: Expected - 1, Got - \" << maxTurbulenceSize(arr3) << std::endl;\n    \n    return 0;\n}\n```",
  "979": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int distributeCoins(TreeNode* root) {\n        if (!root) return 0;\n        int res = root->val;\n        if (root->left) res += distributeCoins(root->left);\n        if (root->right) res += distributeCoins(root->right);\n        return abs(res - 0x7fffffff);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(4, new TreeNode(2, new TreeNode(1), new TreeNode(3)), new TreeNode(6));\n    cout << \"Test case 1: \" << solution.distributeCoins(root1) << endl;\n    \n    // Test case 2\n    TreeNode* root2 = new TreeNode(0);\n    cout << \"Test case 2: \" << solution.distributeCoins(root2) << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(5, new TreeNode(1), new TreeNode(6));\n    cout << \"Test case 3: \" << solution.distributeCoins(root3) << endl;\n    \n    return 0;\n}\n```",
  "981": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass TimeMap {\npublic:\n    unordered_map<string, unordered_map<int, string>> data;\n    \n    void set(string key, int timestamp, string value) {\n        data[key][timestamp] = value;\n    }\n    \n    string get(string key, int timestamp) {\n        for (int i = timestamp; i >= 0; i--) {\n            if (data[key].find(i) != data[key].end()) {\n                return data[key][i];\n            }\n        }\n        return \"\";\n    }\n};\n\nint main() {\n    TimeMap tm;\n    \n    tm.set(\"foo\", 1, \"bar\");\n    tm.set(\"foo\", 3, \"baz\");\n    \n    cout << tm.get(\"foo\", 0) << endl; // returns \"\" because there is no value for \"foo\" at timestamp 0\n    cout << tm.get(\"foo\", 1) << endl; // returns \"bar\"\n    cout << tm.get(\"foo\", 2) << endl; // returns \"bar\"\n    cout << tm.get(\"foo\", 3) << endl; // returns \"baz\"\n    cout << tm.get(\"foo\", 4) << endl; // returns \"baz\"\n    \n    return 0;\n}\n```",
  "980": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int uniquePathsIII(int m, int n) {\n        if (m == 1 && n == 1) return 1;\n        \n        vector<vector<int>> grid(m, vector<int>(n));\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                grid[i][j] = -1;\n        \n        int res = explore(grid, 0, 0);\n        return res;\n    }\n    \n    int explore(vector<vector<int>>& grid, int x, int y) {\n        if (x >= grid.size() || y >= grid[0].size())\n            return 0;\n        \n        if (grid[x][y] == -1)\n            return 0;\n        \n        if (x == grid.size() - 1 && y == grid[0].size() - 1)\n            return 1;\n        \n        grid[x][y] = -1;\n        \n        int res = explore(grid, x + 1, y) + explore(grid, x, y + 1);\n        \n        grid[x][y] = 0;\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << solution.uniquePathsIII(3, 2) << endl;\n    cout << \"Test case 2: \" << solution.uniquePathsIII(7, 3) << endl;\n    cout << \"Test case 3: \" << solution.uniquePathsIII(11, 4) << endl;\n    \n    return 0;\n}\n```",
  "982": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPairs(vector<int>& arr) {\n        unordered_map<int, int> map;\n        for (int x : arr) {\n            map[x] = (map.find(x) == map.end()) ? 1 : map[x] + 1;\n        }\n        int res = 0;\n        for (auto& p : map) {\n            if ((p.second & 1) && p.second > 1)\n                res += (p.second - 1) / 2 * p.second;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1:\n    vector<int> arr1 = {4, 5, 6};\n    cout << \"Test case 1: \" << solution.countPairs(arr1) << endl;\n\n    // Test case 2:\n    vector<int> arr2 = {3, 5, 2, 6};\n    cout << \"Test case 2: \" << solution.countPairs(arr2) << endl;\n\n    // Test case 3:\n    vector<int> arr3 = {12, 7, 0, 8};\n    cout << \"Test case 3: \" << solution.countPairs(arr3) << endl;\n    \n    return 0;\n}",
  "983": "```\n#include <iostream>\n#include <vector>\n\nint mincostTickets(std::vector<int>& days, std::vector<int>& cost) {\n    int n = days.size();\n    int dp[n];\n    dp[0] = cost[0];\n\n    for (int i = 1; i < n; i++) {\n        if (i % 7 == 6 || i % 30 == 29) {\n            dp[i] = std::min(std::min(dp[i-1], cost[1]), cost[2]);\n        } else {\n            dp[i] = dp[i-1];\n        }\n    }\n\n    return dp[n-1];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> days1 = {3,5,1,9,28};\n    std::vector<int> cost1 = {2,7,14};\n    int result1 = mincostTickets(days1, cost1);\n    if (result1 == 17) {\n        std::cout << \"Test case 1: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Failed. Expected 17 but got \" << result1 << \".\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> days2 = {2,20};\n    std::vector<int> cost2 = {1,4,3};\n    int result2 = mincostTickets(days2, cost2);\n    if (result2 == 5) {\n        std::cout << \"Test case 2: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Failed. Expected 5 but got \" << result2 << \".\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> days3 = {1,4,6};\n    std::vector<int> cost3 = {2,7,15};\n    int result3 = mincostTickets(days3, cost3);\n    if (result3 == 10) {\n        std::cout << \"Test case 3: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Failed. Expected 10 but got \" << result3 << \".\" << std::endl;\n    }\n\n    return 0;\n}",
  "984": "```\n#include <iostream>\n#include <string>\n\nbool isGoodString(std::string s) {\n    int countA = 0;\n    int countB = 0;\n\n    for (char c : s) {\n        if (c == 'a') {\n            countA++;\n            countB = 0;\n        } else if (c == 'b') {\n            countB++;\n            countA = 0;\n        }\n\n        if (countA > 1 || countB > 1) return false;\n    }\n\n    return true;\n}\n\nint main() {\n    std::cout << isGoodString(\"aaabb\") << std::endl; // Expected: true\n    std::cout << isGoodString(\"abababa\") << std::endl; // Expected: true\n    std::cout << isGoodString(\"aabba\") << std::endl; // Expected: false\n\n    return 0;\n}\n```",
  "985": "```\n#include <iostream>\n#include <vector>\n\nint sumOfEvenNumbers(std::vector<int>& nums, std::vector<vector<int>>& queries) {\n    int n = nums.size();\n    for (const auto& query : queries) {\n        if (query[0] % 2 == 0 && query[1] > nums[query[0]] + query[2]) {\n            nums[query[0]] += query[2];\n        } else {\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                if (nums[i] % 2 == 0) {\n                    sum += nums[i];\n                }\n            }\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 3, 4};\n    std::vector<vector<int>> queries1 = {{0, 1}, {1, 10}};\n    std::cout << sumOfEvenNumbers(nums1, queries1) << std::endl;\n\n    std::vector<int> nums2 = {2, 7, 11, 90, 43};\n    std::vector<vector<int>> queries2 = {{2, 2}, {1, 13}};\n    std::cout << sumOfEvenNumbers(nums2, queries2) << std::endl;\n\n    std::vector<int> nums3 = {10, 12, 3, 5, 4};\n    std::vector<vector<int>> queries3 = {{4, 14}, {0, 8}};\n    std::cout << sumOfEvenNumbers(nums3, queries3) << std::endl;\n\n    return 0;\n}\n```",
  "986": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Interval {\n    int start;\n    int end;\n};\n\nbool compareIntervals(const Interval& a, const Interval& b) {\n    return a.start != b.start ? a.start - b.start : a.end - b.end;\n}\n\nstd::vector<Interval> intervalIntersection(std::vector<Interval>& firstList, std::vector<Interval>& secondList) {\n    std::vector<Interval> result;\n    int i = 0, j = 0;\n\n    while (i < firstList.size() && j < secondList.size()) {\n        Interval left = firstList[i];\n        Interval right = secondList[j];\n\n        int start = std::max(left.start, right.start);\n        int end = std::min(left.end, right.end);\n\n        if (start <= end) {\n            result.push_back({start, end});\n        }\n\n        if (left.end < right.end) {\n            j++;\n        } else {\n            i++;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<Interval> firstList1 = {{0, 2}, {5, 10}, {13, 23}, {24, 25}};\n    std::vector<Interval> secondList1 = {{1, 5}, {8, 22}};\n    std::cout << \"Test Case 1: \";\n    for (const auto& interval : intervalIntersection(firstList1, secondList1)) {\n        std::cout << \"(\" << interval.start << \", \" << interval.end << \") \";\n    }\n    std::cout << \"\\n\";\n\n    // Test Case 2\n    std::vector<Interval> firstList2 = {{1, 3}, {5, 7}};\n    std::vector<Interval> secondList2 = [];\n    std::cout << \"Test Case 2: \";\n    for (const auto& interval : intervalIntersection(firstList2, secondList2)) {\n        std::cout << \"(\" << interval.start << \", \" << interval.end << \") \";\n    }\n    std::cout << \"\\n\";\n\n    // Test Case 3\n    std::vector<Interval> firstList3 = [[1, 3], [5, 7]];\n    std::vector<Interval> secondList3 = [[2, 4]];\n    std::cout << \"Test Case 3: \";\n    for (const auto& interval : intervalIntersection(firstList3, secondList3)) {\n        std::cout << \"(\" << interval.start << \", \" << interval.end << \") \";\n    }\n    std::cout << \"\\n\";\n\n    return 0;\n}",
  "987": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    vector<vector<int>> verticalOrder(TreeNode* root) {\n        if (!root) return {};\n\n        map<int, vector<int>> columns;\n        queue<pair<TreeNode*, int>> q;\n        q.push({root, 0});\n\n        while (!q.empty()) {\n            TreeNode* node = q.front().first;\n            int column = q.front().second;\n            q.pop();\n\n            columns[column].push_back(node->val);\n\n            if (node->left) q.push({node->left, column - 1});\n            if (node->right) q.push({node->right, column + 1});\n        }\n\n        vector<vector<int>> result;\n        for (auto it = columns.begin(); it != columns.end(); ++it) {\n            result.push_back(it->second);\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(9);\n    root1->right = new TreeNode(20);\n    root1->right->left = new TreeNode(15);\n    root1->right->right = new TreeNode(7);\n\n    vector<vector<int>> result1 = solution.verticalOrder(root1);\n    for (const auto& row : result1) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(4);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(6);\n    root2->right->left = new TreeNode(5);\n    root2->right->right = new TreeNode(7);\n\n    vector<vector<int>> result2 = solution.verticalOrder(root2);\n    for (const auto& row : result2) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    TreeNode* root3 = nullptr;\n\n    vector<vector<int>> result3 = solution.verticalOrder(root3);\n    for (const auto& row : result3) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "988": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct TreeNode {\n    char val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nclass Solution {\npublic:\n    std::string smallestFromLeaf(TreeNode* root) {\n        if (!root) return \"\";\n        \n        std::string res = \"\";\n        dfs(root, res);\n        return res;\n    }\n    \nprivate:\n    void dfs(TreeNode* node, std::string path) {\n        if (!node) return;\n        \n        if (!node->left && !node->right) {\n            path += node->val;\n            std::cout << \"path: \" << path << std::endl;\n            std::cout << \"res: \" << smallestString(path) << std::endl;\n        }\n        \n        dfs(node->left, path + node->val);\n        dfs(node->right, path + node->val);\n    }\n    \n    std::string smallestString(std::string s) {\n        std::sort(s.begin(), s.end());\n        return s;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    TreeNode* root = new TreeNode('a');\n    root->left = new TreeNode('b');\n    root->right = new TreeNode('c');\n    root->left->left = new TreeNode('s');\n    root->left->right = new TreeNode('o');\n    root->right->left = new TreeNode('n');\n    root->right->right = new TreeNode('t');\n    std::cout << \"Test case 1: \" << solution.smallestFromLeaf(root) << std::endl;\n\n    // Test case 2:\n    root = new TreeNode('a');\n    root->left = new TreeNode('b');\n    root->right = new TreeNode('c');\n    root->left->left = new TreeNode('s');\n    root->left->right = new TreeNode('o');\n    root->right->left = new TreeNode('n');\n    root->right->right = new TreeNode('t');\n    root->left->left->left = new TreeNode('e');\n    std::cout << \"Test case 2: \" << solution.smallestFromLeaf(root) << std::endl;\n\n    // Test case 3:\n    root = nullptr;\n    std::cout << \"Test case 3: \" << solution.smallestFromLeaf(root) << std::endl;\n\n    return 0;\n}\n```",
  "989": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> addToArrayForm(std::vector<int>& num, int k) {\n    // Implementation for the problem: Add to Array-Form of Integer\n    return {};\n}\n\nint main() {\n    std::vector<int> num1 = {1, 2, 3};\n    int k1 = 34;\n    std::cout << \"Test case 1: \";\n    for (const auto& str : addToArrayForm(num1, k1)) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> num2 = {2};\n    int k2 = 37;\n    std::cout << \"Test case 2: \";\n    for (const auto& str : addToArrayForm(num2, k2)) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> num3 = {1, 2};\n    int k3 = 0;\n    std::cout << \"Test case 3: \";\n    for (const auto& str : addToArrayForm(num3, k3)) {\n        std::cout << str << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "990": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    UnionFind(int n) : parent(n), rank(n, 1) {\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n    \n    int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    \n    void unionSet(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY)\n            return;\n        \n        if (rank[rootX] < rank[rootY])\n            parent[rootX] = rootY;\n        else {\n            parent[rootY] = rootX;\n            if (rank[rootX] == rank[rootY])\n                rank[rootX]++;\n        }\n    }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n};\n\nbool equationsPossible(vector<string>& equations) {\n    UnionFind uf(equations.size());\n    \n    for (const auto& equation : equations) {\n        char x = equation[0], y = equation[3];\n        \n        if (equation[1] == '!') {\n            if (uf.find(x) != uf.find(y))\n                return false;\n        } else\n            uf.unionSet(x - 'a', y - 'a');\n    }\n    \n    for (const auto& equation : equations) {\n        char x = equation[0], y = equation[3];\n        \n        if (equation[1] == '=' && uf.find(x - 'a') != uf.find(y - 'a'))\n            return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    vector<string> equations1 = {\"a==b\",\"b!=c\"};\n    cout << boolalpha << equationsPossible(equations1) << endl;  // Output: true\n\n    vector<string> equations2 = {\"a==b\",\"b==c\",\"a!=c\"};\n    cout << boolalpha << equationsPossible(equations2) << endl;  // Output: false\n\n    vector<string> equations3 = {\"a==b\",\"b==b\",\"a==a\"};\n    cout << boolalpha << equationsPossible(equations3) << endl;  // Output: true\n\n    return 0;\n}\n```",
  "991": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int brokenCalc(int X, int Y) {\n        if(Y == X) return 0;\n        if((Y & 1)) return 1 + brokenCalc(X + 1, (Y - 1) / 2);\n        else return 1 + brokenCalc(X + 1, Y / 2);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test case 1: \";\n    int X = 5, Y = 3;\n    std::cout << solution.brokenCalc(X, Y) << std::endl;\n\n    std::cout << \"Test case 2: \";\n    X = 10; Y = 9;\n    std::cout << solution.brokenCalc(X, Y) << std::endl;\n\n    std::cout << \"Test case 3: \";\n    X = 1000; Y = 800;\n    std::cout << solution.brokenCalc(X, Y) << std::endl;\n\n    return 0;\n}\n```",
  "992": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSubarrayKDiff(int A[], int n, int K) {\n        int res = 0;\n        int start = 0;\n        unordered_map<int, int> freq;\n        \n        for (int end = 0; end < n; ++end) {\n            freq[A[end]]++;\n            \n            while (freq.size() > K)\n                freq[A[start++]]--;\n                \n            if (freq.size() == K)\n                res += n - end;\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int A1[] = {1, 2, 1, 3, 4};\n    cout << solution.numSubarrayKDiff(A1, sizeof(A1) / sizeof(A1[0]), 3) << endl; // Output: 23\n\n    int A2[] = {3, 2, 1, 2, 1, 7};\n    cout << solution.numSubarrayKDiff(A2, sizeof(A2) / sizeof(A2[0]), 3) << endl; // Output: 30\n\n    int A3[] = {1, 1, 1, 2, 2};\n    cout << solution.numSubarrayKDiff(A3, sizeof(A3) / sizeof(A3[0]), 2) << endl; // Output: 7\n\n    return 0;\n}\n```",
  "993": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    bool isCousin(TreeNode* root, int x, int y) {\n        if (root == NULL)\n            return false;\n\n        std::vector<TreeNode*> parentLevel = {root};\n        while (!parentLevel.empty()) {\n            std::vector<TreeNode*> children;\n            for (TreeNode* p : parentLevel) {\n                if (p->left) {\n                    children.push_back(p->left);\n                    if (p->left->val == x)\n                        return false;\n                }\n                if (p->right) {\n                    children.push_back(p->right);\n                    if (p->right->val == x)\n                        return false;\n                }\n            }\n            parentLevel = children;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->right->left = new TreeNode(4);\n    root1->right->right = new TreeNode(5);\n\n    std::cout << \"Test case 1: \" << (solution.isCousin(root1, 4, 5) ? \"True\" : \"False\") << std::endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(3);\n\n    std::cout << \"Test case 2: \" << (solution.isCousin(root2, 2, 3) ? \"True\" : \"False\") << std::endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(3);\n    root3->right->left = new TreeNode(4);\n\n    std::cout << \"Test case 3: \" << (solution.isCousin(root3, 2, 4) ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n```",
  "995": "```\n#include <iostream>\n#include <vector>\n\nint minKBitFlips(std::vector<int>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n; i++) {\n        if ((arr[i] & 1) == arr[i] % 2) {\n            for (int j = i + 1; j < n && j <= i + k; j++) {\n                arr[j]++;\n            }\n        }\n    }\n}\n\nint main() {\n    int testCases[] = {3, 4, 7};\n    int k = 2;\n    \n    std::cout << \"Test Case 1: \" << minKBitFlips({0, 1, 0}) << std::endl;\n    std::cout << \"Test Case 2: \" << minKBitFlips({1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0}) << std::endl;\n    std::cout << \"Test Case 3: \" << minKBitFlips({10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24}) << std::endl;\n    \n    return 0;\n}\n```",
  "994": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int orangesRotting(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        int ans = 0, tot = 0;\n        vector<pair<int, int>> q;\n        \n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 1)tot++;\n                else if(grid[i][j] == 2){\n                    q.push_back({i, j});\n                }\n            }\n        }\n\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n\n        while(!q.empty()){\n            for(int i = 0; i < (int)q.size(); i++){\n                int x = q[i].first;\n                int y = q[i].second;\n\n                for(int k = 0; k < 4; k++){\n                    int nx = x + dx[k];\n                    int ny = y + dy[k];\n\n                    if(nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] == 1){\n                        q.push_back({nx, ny});\n                        grid[nx][ny] = 2;\n                    }\n                }\n\n                tot--;\n            }\n\n            q.clear();\n        }\n\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 1)ans++;\n            }\n        }\n\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> grid1 = {{2,1,1},{1,1,0},{0,1,1}};\n    cout << \"Test Case 1: \" << solution.orangesRotting(grid1) << endl; // Output: 4\n\n    // Test Case 2\n    vector<vector<int>> grid2 = {{0,1,1},{1,1,0},{0,0,0}};\n    cout << \"Test Case 2: \" << solution.orangesRotting(grid2) << endl; // Output: 3\n\n    // Test Case 3\n    vector<vector<int>> grid3 = {{1,1,1},{0,1,0},{0,0,0}};\n    cout << \"Test Case 3: \" << solution.orangesRotting(grid3) << endl; // Output: 2\n\n    return 0;\n}\n```",
  "996": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSquarefulPerms(vector<vector<int>>& A) {\n        int n = A.size();\n        sort(A.begin(), A.end());\n        int res = 0;\n        for (int i = 0; i < (1 << n); ++i) {\n            bool squareful = true;\n            vector<int> perm;\n            for (int j = 0; j < n; ++j) {\n                if (i & (1 << j)) {\n                    perm.push_back(A[j][0]);\n                }\n            }\n            for (int j = 0; j < n - 1; ++j) {\n                if (isSquare(perm[j], perm[j + 1])) {\n                    squareful = false;\n                    break;\n                }\n            }\n            if (squareful) res++;\n        }\n        return res;\n    }\n\n    bool isSquare(int a, int b) {\n        int c = (int)sqrt((double)(a * a + b * b));\n        return c * c == a * a + b * b;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<vector<int>> A1{{1, 17}, {2, 18}};\n    cout << solution.numSquarefulPerms(A1) << endl;\n\n    vector<vector<int>> A2{{4, 13}, {5, 9}, {10, 7}};\n    cout << solution.numSquarefulPerms(A2) << endl;\n\n    vector<vector<int>> A3{{1, 0}, {2, 1}};\n    cout << solution.numSquarefulPerms(A3) << endl;\n}\n```",
  "997": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        unordered_map<int, int> inDegree;\n        unordered_map<int, int> outDegree;\n        \n        for (int i = 1; i <= n; i++) {\n            inDegree[i] = 0;\n            outDegree[i] = 0;\n        }\n        \n        for (const auto& edge : trust) {\n            outDegree[edge[0]]++;\n            inDegree[edge[1]]++;\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            if (inDegree[i] == n - 1 && outDegree[i] == 0) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int result1 = solution.findJudge(2, {{1, 2}});\n    cout << \"Test Case 1: \" << result1 << endl;\n\n    int result2 = solution.findJudge(3, {{1, 3}, {2, 3}});\n    cout << \"Test Case 2: \" << result2 << endl;\n\n    int result3 = solution.findJudge(4, {{1, 3}, {2, 3}, {3, 1}});\n    cout << \"Test Case 3: \" << result3 << endl;\n\n    return 0;\n}\n```",
  "998": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\n        if (!root) return new TreeNode(val);\n        if (val > root->val) root->right = insertIntoMaxTree(root->right, val);\n        else {\n            TreeNode* temp = root;\n            root = new TreeNode(val);\n            root->left = temp;\n        }\n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = nullptr;\n    int val1 = 3;\n    TreeNode* result1 = solution.insertIntoMaxTree(root1, val1);\n    cout << \"Test case 1: \";\n    if (result1) {\n        cout << result1->val;\n        while (result1->left) result1 = result1->left;\n        cout << \" \" << result1->val << endl;\n    } else cout << \"null\" << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(3);\n    int val2 = 4;\n    TreeNode* result2 = solution.insertIntoMaxTree(root2, val2);\n    cout << \"Test case 2: \";\n    if (result2) {\n        cout << result2->val;\n        while (result2->left) result2 = result2->left;\n        cout << \" \" << result2->val << endl;\n    } else cout << \"null\" << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    int val3 = 6;\n    TreeNode* result3 = solution.insertIntoMaxTree(root3, val3);\n    cout << \"Test case 3: \";\n    if (result3) {\n        cout << result3->val;\n        while (result3->left) result3 = result3->left;\n        cout << \" \" << result3->val << endl;\n    } else cout << \"null\" << endl;\n\n    return 0;\n}\n```",
  "999": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> availableCapturesForRook(vector<vector<int>>& board) {\n        int res[8][8] = {0};\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                if (board[i][j] == 1) {\n                    for (int k = -2; k <= 2; k++) {\n                        if (k != 0) {\n                            int dirX = abs(k);\n                            for (int l = -dirX; l <= dirX; l++) {\n                                int newX = i + k, newY = j + l;\n                                while ((newX >= 0 && newX < 8) &&\n                                       (newY >= 0 && newY < 8)) {\n                                    if ((k > 0 && l > 0) || (k < 0 && l < 0)) {\n                                        res[newX][newY] = 1;\n                                    } else {\n                                        res[newX][newY] = 2;\n                                    }\n                                    newX += k, newY += l;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        vector<vector<int>> result(8);\n        for (int i = 0; i < 8; i++) {\n            result[i] = &res[i][0];\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> board1 = {{0, 5}, {4, 3}};\n    vector<vector<int>> expected1 = {{0, 4, 2, 2, 2, 2, 2, 2},\n                                     {0, 0, 2, 0, 2, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 2, 0, 2, 0, 0, 0},\n                                     {0, 4, 2, 2, 2, 2, 2, 2},\n                                     {0, 0, 2, 0, 2, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0}};\n    vector<vector<int>> result1 = solution.availableCapturesForRook(board1);\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (result1[i][j] != expected1[i][j]) {\n                cout << \"Test case 1 failed\" << endl;\n                return 1;\n            }\n        }\n    }\n    cout << \"Test case 1 passed\" << endl;\n\n    // Test case 2\n    vector<vector<int>> board2 = {{0, 3}, {4, 5}};\n    vector<vector<int>> expected2 = {{0, 0, 2, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 2, 0, 2, 0, 2, 0, 0},\n                                     {4, 2, 2, 2, 2, 2, 2, 2},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0}};\n    vector<vector<int>> result2 = solution.availableCapturesForRook(board2);\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (result2[i][j] != expected2[i][j]) {\n                cout << \"Test case 2 failed\" << endl;\n                return 1;\n            }\n        }\n    }\n    cout << \"Test case 2 passed\" << endl;\n\n    // Test case 3\n    vector<vector<int>> board3 = {};\n    vector<vector<int>> expected3 = {{0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0},\n                                     {0, 0, 0, 0, 0, 0, 0, 0}};\n    vector<vector<int>> result3 = solution.availableCapturesForRook(board3);\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            if (result3[i][j] != expected3[i][j]) {\n                cout << \"Test case 3 failed\" << endl;\n                return 1;\n            }\n        }\n    }\n    cout << \"Test case 3 passed\" << endl;\n\n    return 0;\n}\n```",
  "1000": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int mergeStones(vector<int>& stones, int k) {\n        int n = stones.size();\n        vector<vector<long long>> dp(n + 1, vector<long long>(n + 1));\n        \n        for (int i = 0; i <= n; ++i) {\n            for (int j = 0; j <= n; ++j) {\n                if (i > j) {\n                    dp[i][j] = dp[j][i];\n                    continue;\n                }\n                \n                int res = INT_MAX;\n                for (int x = max(0, i - k + 1); x < min(j + 1, i + 1); ++x) {\n                    if (x > 0 && j >= i) {\n                        res = min(res, dp[x][i] + stones[x]);\n                    }\n                    else {\n                        res = min(res, dp[0][x - 1] + stones[x]);\n                    }\n                }\n                dp[i][j] = res;\n            }\n        }\n        \n        return dp[0][n - 1];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> stones1 = {3,5,1,2,3};\n    int k1 = 3;\n    cout << \"Test case 1: Minimum cost to merge stones is \" << solution.mergeStones(stones1, k1) << endl;\n\n    // Test case 2\n    vector<int> stones2 = {10,15,7,5,4};\n    int k2 = 3;\n    cout << \"Test case 2: Minimum cost to merge stones is \" << solution.mergeStones(stones2, k2) << endl;\n\n    // Test case 3\n    vector<int> stones3 = {1,3,6,2,5};\n    int k3 = 4;\n    cout << \"Test case 3: Minimum cost to merge stones is \" << solution.mergeStones(stones3, k3) << endl;\n\n    return 0;\n}\n```",
  "1002": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> commonChars(std::vector<std::string>& common) {\n    if (common.empty()) return {};\n\n    int minLen = *min_element(common.begin(), common.end(), [](const std::string& a, const std::string& b) { return a.size() < b.size(); }).size();\n    \n    std::vector<std::string> res;\n    for (char c='a'; c<='z'; ++c) {\n        int count = 0;\n        bool found = true;\n        for (const auto& str : common) {\n            int currCount = 0;\n            for (int i=0; i<minLen && found; ++i) {\n                if (str[i] == c) ++currCount;\n            }\n            if (found && currCount < minLen) found = false;\n            count += found ? currCount : 0;\n        }\n        while (count--) res.push_back(std::string(1, c));\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<std::string> common1 = {\"cool\", \"lock\", \"cook\"};\n    std::cout << \"[\";\n    for (const auto& str : commonChars(common1)) cout << \"'\" << str << \"', \";\n    cout << \"]\" << endl;\n\n    std::vector<std::string> common2 = {\"cool\", \"lock\", \"kook\"};\n    std::cout << \"[\";\n    for (const auto& str : commonChars(common2)) cout << \"'\" << str << \"', \";\n    cout << \"]\" << endl;\n\n    std::vector<std::string> common3 = {};\n    std::cout << \"[\";\n    for (const auto& str : commonChars(common3)) cout << \"'\" << str << \"', \";\n    cout << \"]\" << endl;\n    \n    return 0;\n}\n```",
  "1001": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countMinutes(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        vector<vector<bool>> visited(m, vector<bool>(n));\n        \n        int res = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!visited[i][j] && grid[i][j]) {\n                    queue<pair<int, int>> q;\n                    q.push({i, j});\n                    visited[i][j] = true;\n                    res += 1;\n                    \n                    while (!q.empty()) {\n                        pair<int, int> curr = q.front();\n                        q.pop();\n                        \n                        if (curr.first - 1 >= 0 && !visited[curr.first-1][curr.second] && grid[curr.first-1][curr.second]) {\n                            q.push({curr.first-1, curr.second});\n                            visited[curr.first-1][curr.second] = true;\n                        }\n                        if (curr.second + 1 < n && !visited[curr.first][curr.second+1] && grid[curr.first][curr.second+1]) {\n                            q.push({curr.first, curr.second+1});\n                            visited[curr.first][curr.second+1] = true;\n                        }\n                        if (curr.first + 1 < m && !visited[curr.first+1][curr.second] && grid[curr.first+1][curr.second]) {\n                            q.push({curr.first+1, curr.second});\n                            visited[curr.first+1][curr.second] = true;\n                        }\n                        if (curr.first - 1 >= 0 && !visited[curr.first-1][curr.second] && !grid[curr.first-1][curr.second]) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> grid1 = {{0,0,8},{0,1,6},{2,0,5}};\n    cout << \"Test Case 1: \" << solution.countMinutes(grid1) << endl;\n    \n    // Test Case 2\n    vector<vector<int>> grid2 = {{0,0,0},{0,0,0}};\n    cout << \"Test Case 2: \" << solution.countMinutes(grid2) << endl;\n\n    // Test Case 3\n    vector<vector<int>> grid3 = {{0,1,8},{1,0,6},{2,2,5}};\n    cout << \"Test Case 3: \" << solution.countMinutes(grid3) << endl;\n    \n    return 0;\n}\n```",
  "1004": "```\n#include <iostream>\n#include <vector>\n\nint findMaxConsecutiveOnes(std::vector<int>& nums) {\n    int maxCount = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        int count = 0;\n        for (int j = i; j < nums.size(); j++) {\n            if (nums[j] == 1) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        maxCount = std::max(maxCount, count);\n    }\n    return maxCount;\n}\n\nint main() {\n    std::vector<int> test1({8,2,1,3});\n    std::cout << \"Test 1: \" << findMaxConsecutiveOnes(test1) << std::endl;\n\n    std::vector<int> test2({1000000,0,1});\n    std::cout << \"Test 2: \" << findMaxConsecutiveOnes(test2) << std::endl;\n\n    std::vector<int> test3({1,1,1,1,1});\n    std::cout << \"Test 3: \" << findMaxConsecutiveOnes(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1003": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nbool wordPattern(std::string pattern, std::string s) {\n    int i = 0, j = 0;\n    std::unordered_map<char, char> map1, map2;\n\n    while (j < s.length()) {\n        if (i == 0 || s[j] != pattern[i - 1]) {\n            if (map1.find(pattern[i - 1]) != map1.end() || map2.find(s[j]) != map2.end()) {\n                return false;\n            }\n            map1[pattern[i++]] = s[j++];\n        } else {\n            j++;\n        }\n    }\n\n    while (i < pattern.length()) {\n        if (map1.find(pattern[i]) == map1.end() || map2.find(s[j - 1]) != map2.end() && map1[pattern[i]] != s[j - 1]) {\n            return false;\n        }\n        i++; j--;\n    }\n\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha << wordPattern(\"abba\", \"dog cat cat dog\") << std::endl; // returns true\n    std::cout << std::boolalpha << wordPattern(\"aabc\", \"cat cat dog fish\") << std::endl; // returns false\n    std::cout << std::boolalpha << wordPattern(\"aaaa\", \"dog cat dog dog\") << std::endl; // returns false\n}",
  "1005": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maximumSum(int arr[], int n, int k) {\n    for (int i = 0; i < k; i++) {\n        if (arr[i] < 0) {\n            arr[i] = -arr[i];\n        } else {\n            break;\n        }\n    }\n    std::sort(arr, arr + n);\n    return arr[n - 1];\n}\n\nint main() {\n    int testCases[3][5] = {{-2, 0, -1}, {0, -3, 2, -2, -1}, {-1, -2, 3, 0, 1}};\n    for (int i = 0; i < 3; i++) {\n        int n = sizeof(testCases[i]) / sizeof(int);\n        int k = i;\n        std::cout << \"Array: \";\n        for (int j = 0; j < n; j++) {\n            std::cout << testCases[i][j] << \" \";\n        }\n        std::cout << \"\\nMax Sum: \" << maximumSum(&testCases[i][0], n, k) << \"\\n\";\n    }\n    return 0;\n}",
  "1006": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int clumsyFactorial(int N) {\n        long res = 1;\n        for (int i = 1; i <= N; ++i) {\n            if (i % 4 == 0)\n                res *= i;\n            else if (i % 4 == 1)\n                res *= i + 2;\n            else if (i % 4 == 2)\n                res *= i * (i + 1) / 2;\n            else\n                res *= (long)(i - 1) * (i - 2) * (i - 3) + 6;\n        }\n        return (int)res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test case 1: \" << solution.clumsyFactorial(4) << std::endl; // Expected output: 40\n    std::cout << \"Test case 2: \" << solution.clumsyFactorial(10) << std::endl; // Expected output: 3742483162\n    std::cout << \"Test case 3: \" << solution.clumsyFactorial(20) << std::endl; // Expected output: 8159152832478977348513280429538501086428821102562\n\n    return 0;\n}\n```",
  "1007": "```\n#include <iostream>\n#include <vector>\n\nint minDominoRotations(std::vector<int>& A) {\n    int n = A.size();\n    std::vector<int> left(n), right(n);\n    \n    for (int i = 0; i < n; ++i) {\n        if (A[i] == 1) {\n            left[i] = 1;\n            right[n - 1 - i] = 1;\n        }\n        else {\n            left[i] = 2;\n            right[n - 1 - i] = 2;\n        }\n    }\n\n    int res = INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        if (left[i] == right[i]) {\n            res = std::min(res, i);\n            break;\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<int> A1({2, 1, 1, 5});\n    int result1 = minDominoRotations(A1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> A2({3, 5, 1, 4, 2, 3});\n    int result2 = minDominoRotations(A2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> A3({1, 2, 3, 4, 5, 6]);\n    int result3 = minDominoRotations(A3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1009": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findComplement(int num) {\n        return ~num;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \";\n    int result = solution.findComplement(5);\n    cout << result << endl; // Output: 2\n\n    cout << \"Test case 2: \";\n    result = solution.findComplement(8);\n    cout << result << endl; // Output: 7\n\n    cout << \"Test case 3: \";\n    result = solution.findComplement(10);\n    cout << result << endl; // Output: 5\n\n    return 0;\n}\n```",
  "1008": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* bstFromPreorder(vector<int>& preorder) {\n        if (preorder.empty()) return NULL;\n        \n        TreeNode* root = new TreeNode(preorder[0]);\n        TreeNode* curr = root;\n        for (int i = 1; i < preorder.size(); ++i) {\n            if (preorder[i] < root->val) {\n                root->left = new TreeNode(preorder[i]);\n                curr = root->left;\n            } else {\n                while (curr->right && preorder[i] > curr->right->val) {\n                    curr = curr->right;\n                }\n                if (!curr->right) {\n                    curr->right = new TreeNode(preorder[i]);\n                } else {\n                    curr = curr->right;\n                }\n            }\n        }\n        \n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> preorder1 = {8,5,3,2,6,4};\n    TreeNode* tree1 = solution.bstFromPreorder(preorder1);\n    cout << \"Test case 1: \";\n    if (tree1) {\n        // Print the constructed binary search tree\n        printTree(tree1);\n    } else {\n        cout << \"No tree constructed.\" << endl;\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<int> preorder2 = {10,5,3,2};\n    TreeNode* tree2 = solution.bstFromPreorder(preorder2);\n    cout << \"Test case 2: \";\n    if (tree2) {\n        printTree(tree2);\n    } else {\n        cout << \"No tree constructed.\" << endl;\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<int> preorder3 = {4,1,8,3};\n    TreeNode* tree3 = solution.bstFromPreorder(preorder3);\n    cout << \"Test case 3: \";\n    if (tree3) {\n        printTree(tree3);\n    } else {\n        cout << \"No tree constructed.\" << endl;\n    }\n    cout << endl;\n\n    return 0;\n}\n\nvoid printTree(TreeNode* root) {\n    if (!root) return;\n    \n    cout << \"In-order traversal: \";\n    inOrderTraversal(root);\n    cout << endl;\n}\n\nvoid inOrderTraversal(TreeNode* node) {\n    if (node) {\n        inOrderTraversal(node->left);\n        cout << node->val << \" \";\n        inOrderTraversal(node->right);\n    }\n}\n```",
  "1011": "```\n#include <iostream>\n#include <vector>\n\nint shipWithinDays(std::vector<int>& packets) {\n    int totalWeight = 0;\n    for (int weight : packets) {\n        totalWeight += weight;\n    }\n\n    int low = *max_element(packets.begin(), packets.end());\n    int high = totalWeight;\n\n    while (low < high) {\n        int mid = (low + high) / 2;\n        int dayCount = 1, currentWeight = 0;\n        for (int weight : packets) {\n            currentWeight += weight;\n            if (currentWeight > mid) {\n                dayCount++;\n                currentWeight = weight;\n            }\n        }\n\n        if (dayCount <= 7) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n\n    return low;\n}\n\nint main() {\n    std::vector<int> packets1 = {2, 2, 2, 4, 1, 4};\n    std::cout << \"Test case 1: \" << shipWithinDays(packets1) << std::endl;\n\n    std::vector<int> packets2 = {1, 2, 3, 4, 5};\n    std::cout << \"Test case 2: \" << shipWithinDays(packets2) << std::endl;\n\n    std::vector<int> packets3 = {15, 16, 17, 18};\n    std::cout << \"Test case 3: \" << shipWithinDays(packets3) << std::endl;\n\n    return 0;\n}\n```",
  "1010": "```\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numPairsDivisibleBy60(vector<int>& time) {\n        map<int, int> mp;\n        for (int i : time) {\n            mp[i % 60]++;\n        }\n        int res = 0;\n        if ((mp[0] > 1) || (mp[30] > 1)) {\n            res += mp[0] * (mp[0] - 1) / 2;\n            if (mp[30]) res += mp[0] * mp[30];\n        }\n        for (int i = 1; i <= 29; i++) {\n            if ((mp[i] > 1) || (mp[60 - i] > 1)) {\n                res += mp[i] * (mp[i] - 1) / 2;\n                if (mp[60 - i]) res += mp[i] * mp[60 - i];\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> time1 = {60, 120};\n    cout << \"Test case 1: \" << solution.numPairsDivisibleBy60(time1) << endl; // Output: 3\n\n    vector<int> time2 = {60};\n    cout << \"Test case 2: \" << solution.numPairsDivisibleBy60(time2) << endl; // Output: 0\n\n    vector<int> time3 = {90, 120, 150, 300};\n    cout << \"Test case 3: \" << solution.numPairsDivisibleBy60(time3) << endl; // Output: 3\n    return 0;\n}\n```",
  "1012": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        if (s.empty()) return 0;\n        \n        int n = s.length();\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        \n        for (int i = 1; i <= n; i++) {\n            if (s[i - 1] != '0') {\n                dp[i] += dp[i - 1];\n            }\n            if (i >= 2 && s.substr(i - 2, 2).compare(\"10\") > 0) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        \n        return dp[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << solution.numDecodings(\"123\") << endl; // Output: 3\n    cout << \"Test case 2: \" << solution.numDecodings(\"226\") << endl; // Output: 2\n    cout << \"Test case 3: \" << solution.numDecodings(\"0\") << endl; // Output: 0\n    \n    return 0;\n}\n```",
  "1013": "```\n#include <iostream>\n#include <vector>\n\nbool canPartition(std::vector<int>& nums) {\n    int totalSum = 0;\n    for (int num : nums) {\n        totalSum += num;\n    }\n    \n    if (totalSum % 3 != 0) return false;\n\n    int targetSum = totalSum / 3;\n    int currentSum = 0;\n    for (int num : nums) {\n        currentSum += num;\n        if (currentSum == targetSum) continue;\n        if (currentSum > targetSum) return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    std::vector<int> test1 = {0,2,3,-6,0,1,2};\n    std::cout << canPartition(test1) << std::endl; // Expected: 1\n\n    std::vector<int> test2 = {0,2,0};\n    std::cout << canPartition(test2) << std::endl; // Expected: 1\n\n    std::vector<int> test3 = {1,-1,2};\n    std::cout << canPartition(test3) << std::endl; // Expected: 0\n\n    return 0;\n}\n```",
  "1015": "```\n#include <iostream>\n#include <vector>\n\nint findSmallestInteger(int k) {\n    int result = 0;\n    while (true) {\n        result++;\n        if (result % k == 0) {\n            return result;\n        }\n    }\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << findSmallestInteger(3) << std::endl; // Expected output: 3\n    std::cout << \"Test case 2: \" << findSmallestInteger(4) << std::endl; // Expected output: 4\n    std::cout << \"Test case 3: \" << findSmallestInteger(6) << std::endl; // Expected output: 6\n\n    return 0;\n}\n```",
  "1014": "```\n#include <iostream>\n#include <vector>\n\nint maxSightseeing(int arr[], int n) {\n    int maxPos = 0;\n    int res = arr[0];\n    for (int i = 1; i < n; i++) {\n        if (arr[i] + i > res + maxPos) {\n            res = arr[i] + i;\n            maxPos = i;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int arr1[] = {8,2,5,3};\n    std::cout << \"Test case 1: \" << maxSightseeing(arr1, sizeof(arr1)/sizeof(arr1[0])) << std::endl;\n\n    int arr2[] = {1,3,2,4};\n    std::cout << \"Test case 2: \" << maxSightseeing(arr2, sizeof(arr2)/sizeof(arr2[0])) << std::endl;\n\n    int arr3[] = {7,5,9,6,1};\n    std::cout << \"Test case 3: \" << maxSightseeing(arr3, sizeof(arr3)/sizeof(arr3[0])) << std::endl;\n}\n```",
  "1016": "```\n#include <iostream>\n#include <string>\n\nbool validString(std::string s) {\n    int n = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == '1') {\n            n++;\n        } else if (n > 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::cout << validString(\"01\") << std::endl; // Expected: 1\n    std::cout << validString(\"10\") << std::endl; // Expected: 0\n    std::cout << validString(\"110\") << std::endl; // Expected: 1\n    return 0;\n}\n```",
  "1017": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    string baseNeg2(int N) {\n        if (N == 0)\n            return \"0\";\n        string result = \"\";\n        while (N > 0) {\n            int remainder = N % (-2);\n            if (remainder < 0) {\n                remainder += 2;\n                N--;\n            }\n            if (remainder != 0)\n                result = to_string(remainder) + result;\n            else\n                result = \"0\" + result;\n            N /= -2;\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.baseNeg2(2) << endl;  // Output: 10\n    cout << solution.baseNeg2(3) << endl;  // Output: 11\n    cout << solution.baseNeg2(4) << endl;  // Output: 100\n\n    return 0;\n}\n```",
  "1018": "```\n#include <iostream>\n#include <vector>\n\nbool checkBits(std::vector<int>& nums) {\n    int total = 0;\n    for (int num : nums) {\n        total ^= num;\n    }\n    return total % 5 == 0;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << \"Test case 1: \" << checkBits({0,1}) << std::endl;\n    std::cout << \"Test case 2: \" << checkBits({0,1,0,1}) << std::endl;\n    std::cout << \"Test case 3: \" << checkBits({4,5,6,7,8,9,10,11,12,13,14,15}) << std::endl;\n    return 0;\n}\n```",
  "1019": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* nextGreaterNodes(ListNode* head) {\n        if (!head) return NULL;\n        \n        stack<pair<int,ListNode*> > s;\n        ListNode* curr = head;\n        while (curr) {\n            s.push({curr->val, curr});\n            curr = curr->next;\n        }\n        \n        int val;\n        ListNode* temp = head;\n        while (temp) {\n            while (!s.empty() && s.top().first <= temp->val) {\n                s.pop();\n            }\n            if (!s.empty()) {\n                val = s.top().first;\n            } else {\n                val = -1; // no next greater node\n            }\n            temp->next = (temp->next ? temp->next : new ListNode(0))->next;\n            temp = temp->next;\n        }\n        \n        while (!s.empty()) {\n            s.pop();\n        }\n        \n        return head;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    ListNode* head1 = new ListNode(2);\n    head1->next = new ListNode(1);\n    head1->next->next = new ListNode(5);\n    head1 = solution.nextGreaterNodes(head1);\n    cout << \"Test case 1: \";\n    while (head1) {\n        cout << head1->val << \" \";\n        head1 = head1->next;\n    }\n    cout << endl;\n    \n    // Test case 2\n    ListNode* head2 = new ListNode(5);\n    head2->next = new ListNode(3);\n    head2->next->next = new ListNode(4);\n    head2->next->next->next = new ListNode(1);\n    head2 = solution.nextGreaterNodes(head2);\n    cout << \"Test case 2: \";\n    while (head2) {\n        cout << head2->val << \" \";\n        head2 = head2->next;\n    }\n    cout << endl;\n    \n    // Test case 3\n    ListNode* head3 = new ListNode(1);\n    head3->next = new ListNode(6);\n    head3->next->next = new ListNode(5);\n    head3->next->next->next = new ListNode(2);\n    head3 = solution.nextGreaterNodes(head3);\n    cout << \"Test case 3: \";\n    while (head3) {\n        cout << head3->val << \" \";\n        head3 = head3->next;\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1021": "```\n#include <iostream>\n#include <string>\n\nstd::string removeOuterParentheses(const std::string& s) {\n    int start = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == '(' && i > start)\n            start = i;\n        else if (s[i] == ')' && i < s.size() - 1 - start) {\n            int end = i + 1;\n            while (end < s.size() && s[end] == ')')\n                ++end;\n            return s.substr(start, end - start);\n        }\n    }\n    return \"\";\n}\n\nint main() {\n    std::cout << removeOuterParentheses(\"(()())(())\") << std::endl; // \"()()()\"\n    std::cout << removeOuterParentheses(\"(()())(!!)\" ) << std::endl; // \"()()!!\"\n    std::cout << removeOuterParentheses(\"(ab(c))\" ) << std::endl; // \"ab(c)\"\n    return 0;\n}\n```",
  "1020": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int numEnclaves(std::vector<std::vector<int>>& grid) {\n        int m = grid.size();\n        if (m == 0) return 0;\n        \n        int n = grid[0].size();\n        for(int i = 0; i < m; i++) {\n            for(int j = 0; j < n; j++) {\n                if(i == 0 || j == 0 || i == m - 1 || j == n - 1) {\n                    if(grid[i][j] == 1) {\n                        dfs(&grid, i, j);\n                    }\n                } else if (grid[i][j] == 1) {\n                    dfs(&grid, i, j);\n                }\n            }\n        }\n        \n        int count = 0;\n        for(int i = 1; i < m - 1; i++) {\n            for(int j = 1; j < n - 1; j++) {\n                if(grid[i][j] == 1) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    void dfs(std::vector<std::vector<int>>* grid, int i, int j) {\n        if(i < 0 || j < 0 || i >= (*grid).size() || j >= (*grid)[0].size()) {\n            return;\n        }\n        \n        if((*grid)[i][j] == 0) {\n            return;\n        }\n        \n        (*grid)[i][j] = 0;\n        \n        dfs(grid, i - 1, j);\n        dfs(grid, i + 1, j);\n        dfs(grid, i, j - 1);\n        dfs(grid, i, j + 1);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> grid1 = {{0,0,0,0},{1,0,1,0},{0,1,1,0},{0,0,0,0}};\n    std::cout << \"Test case 1: \" << solution.numEnclaves(grid1) << std::endl;\n\n    // Test case 2\n    std::vector<std::vector<int>> grid2 = {{1,1,1,1},{1,0,0,0},{1,1,1,0},{1,0,0,0}};\n    std::cout << \"Test case 2: \" << solution.numEnclaves(grid2) << std::endl;\n\n    // Test case 3\n    std::vector<std::vector<int>> grid3 = {{0,0,0,1},{1,1,0,1},{0,1,0,0},{0,0,1,0}};\n    std::cout << \"Test case 3: \" << solution.numEnclaves(grid3) << std::endl;\n\n    return 0;\n}\n```",
  "1023": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    bool cameraRansomNote(std::vector<std::string>& forbiddenWords) {\n        std::string note = \"A\";\n        for (const auto& word : forbiddenWords) {\n            int i = 0, j = 0;\n            while (i < note.size() && j < word.size()) {\n                if (note[i] == word[j]) {\n                    i++;\n                    j++;\n                } else if (note[i] >= 'a' && note[i] <= 'z') {\n                    i++;\n                } else if (word[j] >= 'a' && word[j] <= 'z') {\n                    j++;\n                } else {\n                    return false;\n                }\n            }\n            if (j == word.size()) {\n                note = \"\";\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::string> forbiddenWords1 = {\"To\", \"get\", \"an\", \"extra\", \"supplies\", \"asap\"};\n    bool result1 = solution.cameraRansomNote(forbiddenWords1);\n    if (result1) {\n        std::cout << \"Test Case 1: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1: Fail\" << std::endl;\n    }\n\n    std::vector<std::string> forbiddenWords2 = {\"Hello\", \"There\"};\n    bool result2 = solution.cameraRansomNote(forbiddenWords2);\n    if (result2) {\n        std::cout << \"Test Case 2: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2: Fail\" << std::endl;\n    }\n\n    std::vector<std::string> forbiddenWords3 = {\"CamelCase\", \"Matching\"};\n    bool result3 = solution.cameraRansomNote(forbiddenWords3);\n    if (result3) {\n        std::cout << \"Test Case 3: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3: Fail\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1022": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int sumRootToLeaf(TreeNode* root) {\n        if (!root)\n            return 0;\n        if (!root->left && !root->right)\n            return root->val;\n        return root->val + (root->left ? sumRootToLeaf(root->left) : 0) +\n                (root->right ? sumRootToLeaf(root->right) : 0);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(6);\n    root1->left = new TreeNode(4);\n    root1->right = new TreeNode(8);\n    root1->left->left = new TreeNode(1);\n    root1->left->right = new TreeNode(6);\n    cout << \"Test Case 1: Root to leaf sum is \" << solution.sumRootToLeaf(root1) << endl;\n\n    TreeNode* root2 = new TreeNode(100);\n    root2->left = new TreeNode(14);\n    root2->right = new TreeNode(200);\n    cout << \"Test Case 2: Root to leaf sum is \" << solution.sumRootToLeaf(root2) << endl;\n\n    TreeNode* root3 = new TreeNode(0);\n    root3->left = new TreeNode(1);\n    root3->right = new TreeNode(1);\n    cout << \"Test Case 3: Root to leaf sum is \" << solution.sumRootToLeaf(root3) << endl;\n\n    return 0;\n}",
  "1025": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool divisorGame(int n) {\n        vector<bool> dp(n+1, false);\n        for (int i = 2; i <= n; i++) {\n            if (i % 1 == 0 || i % 2 == 0 || i % 3 == 0 || i % 4 == 0 || i % 5 == 0) {\n                dp[i] = !dp[i-1];\n            } else {\n                for (int j = 1; j <= i/2; j++) {\n                    if (i % j == 0) {\n                        dp[i] = dp[j];\n                        break;\n                    }\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.divisorGame(1) << endl; // Expected: true\n    cout << solution.divisorGame(2) << endl; // Expected: false\n    cout << solution.divisorGame(4) << endl; // Expected: true\n    return 0;\n}",
  "1024": "```\n#include <iostream>\n#include <vector>\n\nint videoStitching(std::vector<std::vector<int>>& clips) {\n    int n = clips.size();\n    std::vector<int> dp(n, n);\n    dp[0] = 0;\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (clips[j][1] >= i && dp[j] + 1 > dp[i]) {\n                dp[i] = dp[j] + 1;\n            }\n        }\n    }\n\n    int ans = -1, prevEnd = -1;\n    for (int i = 0; i < n; ++i) {\n        if (dp[i] != n && (ans == -1 || i > prevEnd)) {\n            ans = i;\n            prevEnd = clips[ans][1];\n        }\n    }\n\n    return ans + 1;\n}\n\nint main() {\n    std::vector<std::vector<int>> clips1 {{0, 2}, {4, 8}, {10, 12}, {3, 5}};\n    std::cout << videoStitching(clips1) << std::endl; // Output: 4\n\n    std::vector<std::vector<int>> clips2 {{0, 3}, {4, 6}, {7, 8}, {9, 10}};\n    std::cout << videoStitching(clips2) << std::endl; // Output: 5\n\n    std::vector<std::vector<int>> clips3 {{0, 1}, {2, 4}, {0, 3}};\n    std::cout << videoStitching(clips3) << std::endl; // Output: -1\n}",
  "1027": "```\n#include <iostream>\n#include <vector>\n\nint longestArithSeqLength(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    std::map<int, std::map<int, int>> dp;\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            int diff = nums[i] - nums[j];\n            if (!dp.count(diff)) {\n                dp[diff][i] = 2;\n                ans = std::max(ans, 2);\n            } else {\n                dp[diff][i] = dp[diff][j] + 1;\n                ans = std::max(ans, dp[diff][i]);\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int test1[] = {3, 6, 9, 12};\n    std::vector<int> nums1(test1, test1 + sizeof(test1)/sizeof(test1[0]));\n    std::cout << \"Test 1: \" << longestArithSeqLength(nums1) << std::endl;\n\n    int test2[] = {3, 5, 6, 8};\n    std::vector<int> nums2(test2, test2 + sizeof(test2)/sizeof(test2[0]));\n    std::cout << \"Test 2: \" << longestArithSeqLength(nums2) << std::endl;\n\n    int test3[] = {1, 2, 4, 7};\n    std::vector<int> nums3(test3, test3 + sizeof(test3)/sizeof(test3[0]));\n    std::cout << \"Test 3: \" << longestArithSeqLength(nums3) << std::endl;\n\n    return 0;\n}",
  "1026": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxAncestorDiff(TreeNode* root, int MX, int MN) {\n        if (root == NULL)\n            return MX - MN;\n\n        int lMin = root->val;\n        int rMax = root->val;\n\n        if (root->left)\n            lMin = min(lMin, maxAncestorDiff(root->left, MN, MIN));\n        if (root->right)\n            rMax = max(rMax, maxAncestorDiff(root->right, MX, MAX));\n\n        return max(abs(MX - root->val), min(rMax - lMin, rMax - MN, MX - lMin));\n    }\n};\n\nint main() {\n    Solution solution;\n    TreeNode* root1 = new TreeNode(8);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(10);\n    root1->left->left = new TreeNode(1);\n    root1->left->right = new TreeNode(6);\n    root1->right->right = new TreeNode(14);\n    root1->right->right->left = new TreeNode(12);\n\n    int result1 = solution.maxAncestorDiff(root1, 10, 4);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->right = new TreeNode(5);\n    root2->right->left = new TreeNode(3);\n\n    int result2 = solution.maxAncestorDiff(root2, 6, 0);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    TreeNode* root3 = new TreeNode(4);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(7);\n\n    int result3 = solution.maxAncestorDiff(root3, 5, 0);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1029": "```\n#include <iostream>\n#include <vector>\n\nint twoCityCost(std::vector<std::vector<int>>& flights) {\n    int totalCost = 0;\n    for (const auto& flight : flights) {\n        if (flight[2] - flight[0] > flight[1] - flight[3]) {\n            totalCost += flight[2] + flight[3];\n        } else {\n            totalCost += flight[0] + flight[1];\n        }\n    }\n    return totalCost;\n}\n\nint main() {\n    std::vector<std::vector<int>> flights1 = {{10, 20}, {30, 40}};\n    std::cout << \"Test Case 1: \" << twoCityCost(flights1) << std::endl;\n\n    std::vector<std::vector<int>> flights2 = {{90, 40}, {70, 60}, {60, 70}, {80, 70}};\n    std::cout << \"Test Case 2: \" << twoCityCost(flights2) << std::endl;\n\n    std::vector<std::vector<int>> flights3 = {{5, 5}, {10, 15}, {20, 25}, {30, 35}};\n    std::cout << \"Test Case 3: \" << twoCityCost(flights3) << std::endl;\n    \n    return 0;\n}\n```",
  "1028": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* recoverFromPreorder(string s) {\n        // Your code here\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string test1 = \"1-2--3\";\n    TreeNode* result1 = solution.recoverFromPreorder(test1);\n    if (result1 == NULL || result1->val != 1) {\n        cout << \"Test case 1 failed.\" << endl;\n    } else if (result1->left->val != 2 || result1->right->val != 3) {\n        cout << \"Test case 1 failed.\" << endl;\n    }\n\n    // Test case 2\n    string test2 = \"1-2--4--5\";\n    TreeNode* result2 = solution.recoverFromPreorder(test2);\n    if (result2 == NULL || result2->val != 1) {\n        cout << \"Test case 2 failed.\" << endl;\n    } else if (result2->left->val != 2 || result2->right->val != 4) {\n        cout << \"Test case 2 failed.\" << endl;\n    }\n\n    // Test case 3\n    string test3 = \"1-2--3--4--5\";\n    TreeNode* result3 = solution.recoverFromPreorder(test3);\n    if (result3 == NULL || result3->val != 1) {\n        cout << \"Test case 3 failed.\" << endl;\n    } else if (result3->left->val != 2 || result3->right->val != 3) {\n        cout << \"Test case 3 failed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1030": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> allCellsDistOrder(int R, int C) {\n        vector<vector<int>> res;\n        for (int i = 0; i <= R; ++i) {\n            for (int j = 0; j <= C; ++j) {\n                res.push_back({i, j});\n            }\n        }\n        sort(res.begin(), res.end(), [](const auto& a, const auto& b) {\n            int d1 = abs(a[0] - a[1]);\n            int d2 = abs(b[0] - b[1]);\n            if (d1 == d2) return a[0] + a[1] < b[0] + b[1];\n            return d1 < d2;\n        });\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> test1 = solution.allCellsDistOrder(1, 2);\n    for (const auto& cell : test1) {\n        cout << \"(\" << cell[0] << \", \" << cell[1] << \") \";\n    }\n    cout << endl;\n\n    vector<vector<int>> test2 = solution.allCellsDistOrder(10, 10);\n    for (const auto& cell : test2) {\n        cout << \"(\" << cell[0] << \", \" << cell[1] << \") \";\n    }\n    cout << endl;\n\n    vector<vector<int>> test3 = solution.allCellsDistOrder(9, 9);\n    for (const auto& cell : test3) {\n        cout << \"(\" << cell[0] << \", \" << cell[1] << \") \";\n    }\n    cout << endl;\n}\n```",
  "1031": "```\n#include <iostream>\n#include <vector>\n\nint maxSumTwoNoOverlap(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> prefixSums(n + 1);\n    for (int i = 0; i < n; ++i)\n        prefixSums[i + 1] = prefixSums[i] + nums[i];\n\n    int maxSum = -n;\n    int start, end;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 2; j <= n; ++j) {\n            int sum1 = prefixSums[j] - prefixSums[i];\n            if (sum1 > maxSum) {\n                maxSum = sum1;\n                start = i;\n                end = j;\n            }\n        }\n    }\n\n    return nums[start] + nums[end];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {2, 1, 5, 6, 0};\n    int result1 = maxSumTwoNoOverlap(test1);\n    if (result1 != 9) {\n        std::cout << \"Test case 1 failed!\" << std::endl;\n        return -1;\n    }\n    std::cout << \"Test case 1 passed!\" << std::endl;\n\n    // Test case 2\n    std::vector<int> test2 = {3, 8, 1, 3, 2};\n    int result2 = maxSumTwoNoOverlap(test2);\n    if (result2 != 19) {\n        std::cout << \"Test case 2 failed!\" << std::endl;\n        return -1;\n    }\n    std::cout << \"Test case 2 passed!\" << std::endl;\n\n    // Test case 3\n    std::vector<int> test3 = {1, 4, 10, 2, 1};\n    int result3 = maxSumTwoNoOverlap(test3);\n    if (result3 != 24) {\n        std::cout << \"Test case 3 failed!\" << std::endl;\n        return -1;\n    }\n    std::cout << \"Test case 3 passed!\" << std::endl;\n\n    return 0;\n}",
  "1032": "```\n#include <iostream>\n#include <string>\n\nclass TrieNode {\npublic:\n    char val;\n    bool isEndOfWord;\n    TrieNode* children[26];\n\n    TrieNode(char c) {\n        val = c;\n        isEndOfWord = false;\n        for (int i = 0; i < 26; i++) {\n            children[i] = nullptr;\n        }\n    }\n};\n\nclass StreamChecker {\npublic:\n    TrieNode* root;\n\n    void insert(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c - 'a']) {\n                node->children[c - 'a'] = new TrieNode(c);\n            }\n            node = node->children[c - 'a'];\n        }\n        node->isEndOfWord = true;\n    }\n\n    bool query(string s) {\n        TrieNode* node = root;\n        for (char c : s) {\n            if (!node->children[c - 'a']) {\n                return false;\n            }\n            node = node->children[c - 'a'];\n        }\n        return node->isEndOfWord;\n    }\n};\n\nint main() {\n    StreamChecker sc = new StreamChecker();\n\n    sc.insert(\"apple\");\n    cout << sc.query(\"a\"); // true\n    cout << sc.query(\"app\"); // true\n    cout << sc.query(\"appl\"); // false\n\n    sc.insert(\"bannana\");\n    cout << sc.query(\"banana\"); // true\n    cout << sc.query(\"banan\"); // false\n    cout << sc.query(\"bana\"); // false\n\n    return 0;\n}\n```",
  "1033": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> movingStones(int a, int b, int c) {\n        if (a == b - 1 && b == c - 1) return {1, 3};\n        if (a == b - 1 || a == c - 1) return {1, 2};\n        if (b == c - 1) return {1, 2};\n        return {1, 1};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int a = 3;\n    int b = 4;\n    int c = 2;\n    vector<int> expected = {1, 1};\n    assert(solution.movingStones(a, b, c)[0] == expected[0]);\n    assert(solution.movingStones(a, b, c)[1] == expected[1]);\n\n    // Test case 2\n    a = 3;\n    b = 5;\n    c = 1;\n    expected = {1, 2};\n    assert(solution.movingStones(a, b, c)[0] == expected[0]);\n    assert(solution.movingStones(a, b, c)[1] == expected[1]);\n\n    // Test case 3\n    a = 1;\n    b = 5;\n    c = 2;\n    expected = {1, 3};\n    assert(solution.movingStones(a, b, c)[0] == expected[0]);\n    assert(solution.movingStones(a, b, c)[1] == expected[1]);\n\n    return 0;\n}\n```",
  "1034": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {\n        if (color == -1) return grid;\n        \n        int oldColor = grid[row][col];\n        if (oldColor != color) {\n            grid[row][col] = color;\n            dfs(grid, row, col, oldColor);\n        }\n        return grid;\n    }\n\nprivate:\n    void dfs(vector<vector<int>>& grid, int row, int col, int color) {\n        int directions[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        for (int i = 0; i < 4; ++i) {\n            int newRow = row + directions[i][0];\n            int newCol = col + directions[i][1];\n            if (newRow >= 0 && newRow < grid.size() && newCol >= 0 && newCol < grid[0].size()) {\n                if (grid[newRow][newCol] == color) continue;\n                if (grid[newRow][newCol] != -1) continue;\n                dfs(grid, newRow, newCol, color);\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1:\n    vector<vector<int>> grid1 = {{0, 1, 0, 0, 0}, {0, 1, 1, 1, 0}, {0, 0, 1, 0, 0}};\n    int row1 = 2;\n    int col1 = 3;\n    int color1 = 3;\n    vector<vector<int>> expected1 = {{0, 1, 2, 2, 0}, {0, 1, 1, 1, 0}, {0, 0, 1, 0, 0}};\n    cout << \"Test Case 1: \";\n    for (int i = 0; i < grid1.size(); ++i) {\n        for (int j = 0; j < grid1[0].size(); ++j) {\n            cout << grid1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n    cout << \"Expected: \";\n    for (int i = 0; i < expected1.size(); ++i) {\n        for (int j = 0; j < expected1[0].size(); ++j) {\n            cout << expected1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test Case 2:\n    vector<vector<int>> grid2 = {{0, 0, 0}, {0, 1, 1}};\n    int row2 = 0;\n    int col2 = 1;\n    int color2 = 2;\n    vector<vector<int>> expected2 = {{0, 0, 0}, {0, 2, 2}};\n    // Write your code here\n\n    // Test Case 3:\n    vector<vector<int>> grid3 = {{1, 1, 1}, {1, 1, 1}};\n    int row3 = 1;\n    int col3 = 0;\n    int color3 = -1;\n    vector<vector<int>> expected3 = {{1, 1, 1}, {1, 1, 1}};\n\n    return 0;\n}\n\n```",
  "1035": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint minSteps(vector<string>& line1, vector<string>& line2) {\n    int m = line1.size();\n    int n = line2.size();\n\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (line1[i - 1] == line2[j - 1]) {\n                dp[i][j] = 1 + dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    vector<string> line1 = {\"first4\", \"serve\"};\n    vector<string> line2 = {\"serve\", \"homeplate\"};\n\n    cout << minSteps(line1, line2) << endl;\n\n    line1 = {\"leet\", \"code\"};\n    line2 = {\"coode\", \"code\"};\n\n    cout << minSteps(line1, line2) << endl;\n\n    line1 = {\"hello\", \"world\"};\n    line2 = {\"world\", \"hello\"};\n\n    cout << minSteps(line1, line2) << endl;\n\n    return 0;\n}\n```",
  "1037": "```\n#include <iostream>\n#include <vector>\n\nbool isBoomerang(std::vector<std::vector<int>>& points) {\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    return (y2 - y1) * (x3 - x2) != (y3 - y1) * (x2 - x1);\n}\n\nint main() {\n    // Test case 1: Valid Boomerang\n    std::vector<std::vector<int>> points1 = {{0, 0}, {2, 2}, {5, 6}};\n    if (!isBoomerang(points1)) {\n        std::cout << \"Test case 1 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    }\n\n    // Test case 2: Invalid Boomerang\n    std::vector<std::vector<int>> points2 = {{0, 0}, {2, 2}, {2, 2}};\n    if (isBoomerang(points2)) {\n        std::cout << \"Test case 2 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    }\n\n    // Test case 3: Edge Case - All points are the same\n    std::vector<std::vector<int>> points3 = {{0, 0}, {0, 0}, {0, 0}};\n    if (isBoomerang(points3)) {\n        std::cout << \"Test case 3 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1036": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> wallsAndGates(vector<vector<int>>& rooms) {\n        if (rooms.empty()) return rooms;\n        \n        int rows = rooms.size();\n        int cols = rooms[0].size();\n        \n        for (int i = 0; i < rows; ++i)\n            for (int j = 0; j < cols; ++j)\n                if (rooms[i][j] == 0) dfs(rooms, i, j, -1);\n        \n        return rooms;\n    }\n    \nprivate:\n    void dfs(vector<vector<int>>& rooms, int i, int j, int dist) {\n        int rows = rooms.size();\n        int cols = rooms[0].size();\n        \n        if (i < 0 || i >= rows || j < 0 || j >= cols || rooms[i][j] != -1)\n            return;\n        \n        rooms[i][j] = dist;\n        \n        dfs(rooms, i + 1, j, dist + 1);\n        dfs(rooms, i - 1, j, dist + 1);\n        dfs(rooms, i, j + 1, dist + 1);\n        dfs(rooms, i, j - 1, dist + 1);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> test_case_1 = {{214,211,203,213},{122,105,110,115},{126,25,50,51},{28,27,26,2}};\n    vector<vector<int>> result = solution.wallsAndGates(test_case_1);\n    for (const auto &row : result) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    \n    // Test case 2\n    vector<vector<int>> test_case_2 = {{0,0}};\n    vector<vector<int>> result2 = solution.wallsAndGates(test_case_2);\n    for (const auto &row : result2) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    \n    // Test case 3\n    vector<vector<int>> test_case_3 = {{0,1},{1,2}};\n    vector<vector<int>> result3 = solution.wallsAndGates(test_case_3);\n    for (const auto &row : result3) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n    \n    return 0;\n}\n```",
  "1038": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* convertBST(TreeNode* root) {\n        if (!root)\n            return NULL;\n\n        if (root->right)\n            convertBST(root->right);\n\n        int temp = root->val;\n        root->val = 0;\n        while (root && !root->val) {\n            root->val += temp;\n            temp = root->val;\n            root = root->left;\n        }\n\n        if (root)\n            convertBST(root);\n\n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* node1 = new TreeNode(5);\n    node1->left = new TreeNode(2);\n    node1->right = new TreeNode(13);\n    node1->left->left = new TreeNode(1);\n    node1->left->right = new TreeNode(3);\n    solution.convertBST(node1);\n\n    // Test case 2\n    TreeNode* node2 = new TreeNode(4);\n    node2->left = new TreeNode(1);\n    node2->right = new TreeNode(7);\n    solution.convertBST(node2);\n\n    // Test case 3\n    TreeNode* node3 = new TreeNode(10);\n    node3->left = new TreeNode(5);\n    node3->right = new TreeNode(15);\n    solution.convertBST(node3);\n\n    return 0;\n}\n```",
  "1039": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minScoreTriangulation(vector<int>& A) {\n        int n = A.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        for (int i = 0; i < n; ++i) {\n            dp[i][i] = 0;\n        }\n        for (int len = 2; len <= n; ++len) {\n            for (int i = 0; i < n - len + 1; ++i) {\n                int j = i + len - 1;\n                dp[i][j] = INT_MAX;\n                for (int k = i; k < j; ++k) {\n                    dp[i][j] = min(dp[i][j], A[i] * A[k + 1] * A[j] + dp[i][k] + dp[k + 1][j]);\n                }\n            }\n        }\n        return dp[0][n - 1];\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> A1 = {2,5};\n    cout << \"Test case 1: \" << solution.minScoreTriangulation(A1) << endl;\n    \n    vector<int> A2 = {3,4,6};\n    cout << \"Test case 2: \" << solution.minScoreTriangulation(A2) << endl;\n\n    vector<int> A3 = {5,8,14,19};\n    cout << \"Test case 3: \" << solution.minScoreTriangulation(A3) << endl;\n    \n    return 0;\n}\n```",
  "1040": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> moveStones(vector<int>& stones) {\n        int n = stones.size();\n        vector<int> res;\n        \n        sort(stones.begin(), stones.end());\n        \n        for (int i = 0; i < n - 2; ++i) {\n            if (stones[i + 1] - stones[i] >= 2) {\n                res.push_back(1);\n                i++;\n            } else if (stones[n - 1] - stones[i] >= 2) {\n                res.push_back(2);\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> test1 = {6,4,8,7,9,2};\n    vector<int> expected1 = {1,2};\n    vector<int> result1 = solution.moveStones(test1);\n    if (result1 == expected1) {\n        cout << \"Test case 1: Passed\" << endl;\n    } else {\n        cout << \"Test case 1: Failed\" << endl;\n    }\n    \n    // Test case 2\n    vector<int> test2 = {7,1};\n    vector<int> expected2 = {};\n    vector<int> result2 = solution.moveStones(test2);\n    if (result2 == expected2) {\n        cout << \"Test case 2: Passed\" << endl;\n    } else {\n        cout << \"Test case 2: Failed\" << endl;\n    }\n    \n    // Test case 3\n    vector<int> test3 = {4,5,7};\n    vector<int> expected3 = {};\n    vector<int> result3 = solution.moveStones(test3);\n    if (result3 == expected3) {\n        cout << \"Test case 3: Passed\" << endl;\n    } else {\n        cout << \"Test case 3: Failed\" << endl;\n    }\n    \n    return 0;\n}",
  "1041": "```\n#include <iostream>\n#include <vector>\n\nbool isRobotBounded(std::string instructions) {\n    int x = 0, y = 0, dir = 0; // up, right, down, left\n    for (char i : instructions) {\n        if (i == 'L') {\n            if (dir == 0) dir = 3;\n            else --dir;\n        } else if (i == 'R') {\n            if (dir == 3) dir = 0;\n            else ++dir;\n        } else if (i == 'F') {\n            switch (dir) {\n                case 0: y++; break;\n                case 1: x++; break;\n                case 2: y--; break;\n                case 3: x--; break;\n            }\n        }\n    }\n    return x == 0 && y == 0;\n}\n\nint main() {\n    std::cout << (isRobotBounded(\"GGLLGG\") ? \"True\\n\" : \"False\\n\"); // false\n    std::cout << (isRobotBounded(\"LL\") ? \"True\\n\" : \"False\\n\"); // true\n    std::cout << (isRobotBounded(\"\") ? \"True\\n\" : \"False\\n\"); // true\n    return 0;\n}\n```",
  "1043": "```\n#include <iostream>\n#include <vector>\n\nint maxPartiton(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> dp(n, 1);\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < i; ++j) {\n            if (nums[i] > nums[j]) {\n                dp[i] = std::max(dp[i], dp[j] + 1);\n            }\n        }\n    }\n    return *std::max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    {\n        std::vector<int> nums1({10,6,8,10,6,8});\n        int res1 = maxPartiton(nums1);\n        if (res1 == 4) {\n            std::cout << \"Test case 1 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 1 failed.\" << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> nums2({49,98,62,24,15,25};\n        int res2 = maxPartiton(nums2);\n        if (res2 == 5) {\n            std::cout << \"Test case 2 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 2 failed.\" << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> nums3({1,4,10});\n        int res3 = maxPartiton(nums3);\n        if (res3 == 2) {\n            std::cout << \"Test case 3 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 3 failed.\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "1042": "```\n#include <vector>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    std::vector<int> gardenNoAdj(int n, std::vector<std::vector<int>>& paths) {\n        std::vector<int> result(n);\n        std::unordered_map<int, std::vector<int>> graph;\n        for (const auto& path : paths) {\n            int u = path[0] - 1;\n            int v = path[1] - 1;\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n        \n        for (int i = 0; i < n; ++i) {\n            if (!graph[i]) {\n                for (int j = 1; j <= 3; ++j) {\n                    result[i] = j;\n                    break;\n                }\n            } else {\n                for (int flower : graph[i]) {\n                    int sameFlower = -1;\n                    for (int k = 1; k <= 3; ++k) {\n                        if (!std::count(result.begin(), result.end(), k)) {\n                            if (sameFlower == -1) {\n                                sameFlower = k;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                    result[i] = sameFlower;\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    int n = 3;\n    std::vector<std::vector<int>> paths1 = {{1,2},{2,3}};\n    std::vector<int> expected1 = {1,2,3};\n    assert(std::equal(solution.gardenNoAdj(n, paths1).begin(), solution.gardenNoAdj(n, paths1).end(), expected1.begin()));\n    \n    int n2 = 4;\n    std::vector<std::vector<int>> paths2 = {{1,2},{2,3},{3,4}};\n    std::vector<int> expected2 = {1,2,1,2};\n    assert(std::equal(solution.gardenNoAdj(n2, paths2).begin(), solution.gardenNoAdj(n2, paths2).end(), expected2.begin()));\n    \n    int n3 = 5;\n    std::vector<std::vector<int>> paths3 = {{1,2},{2,3},{3,4},{4,5}};\n    std::vector<int> expected3 = {1,2,3,4,5};\n    assert(std::equal(solution.gardenNoAdj(n3, paths3).begin(), solution.gardenNoAdj(n3, paths3).end(), expected3.begin()));\n    \n    return 0;\n}\n```",
  "1044": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestDuplicateSubstring(string s) {\n        if (s.empty()) return \"\";\n        \n        int n = s.size();\n        vector<int> pos(n + 1);\n        for (int i = 0; i <= n; i++) pos[i] = i;\n        \n        for (int i = 0, j = 0; i < n; i++) {\n            if (j > 0 && i - pos[j - 1] >= s.size() - (n - i)) j--;\n            while (j > 0 && s.substr(i - j + 1, j) == s.substr(pos[j], j)) j--;\n            pos[i] = j;\n        }\n        \n        int maxLen = 0, lastPos = 0;\n        for (int i = 0; i < n; i++) {\n            if (pos[i] > 0 && i - pos[i] >= s.size() - (n - lastPos)) {\n                int len = i - lastPos;\n                if (len > maxLen) maxLen = len;\n            }\n        }\n        \n        return s.substr(lastPos, maxLen);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.longestDuplicateSubstring(\"abcabcabc\") << endl;  // Output: \"abc\"\n    cout << solution.longestDuplicateSubstring(\"aaabaaaabbbaa\") << endl;  // Output: \"aaaa\"\n    cout << solution.longestDuplicateSubstring(\"abcdefgabcdefg\") << endl;  // Output: \"\"\n\n    return 0;\n}\n```",
  "1045": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> customersWhoBoughtAllProducts(vector<vector<string>>& products) {\n        unordered_map<string, int> customerProducts;\n        \n        for (const auto& product : products) {\n            for (int i = 0; i < product.size(); i++) {\n                if (!customerProducts.count(product[i])) {\n                    customerProducts[product[i]] = 1;\n                } else {\n                    customerProducts[product[i]]++;\n                }\n            }\n        }\n\n        vector<string> result;\n        for (const auto& pair : customerProducts) {\n            if (pair.second == products.size()) {\n                result.push_back(pair.first);\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> products1 = {{ \"Levi's\", \"Gap\" }, { \"Levi's\", \"Gap\" }, {\"Dior\"}, {\"Apple\"}};\n    vector<string> expected1 = {\"Levi's\"};\n    assert(solution.customersWhoBoughtAllProducts(products1) == expected1);\n\n    // Test Case 2\n    vector<vector<string>> products2 = {{ \"Coca-Cola\", \"Pepsi\" }, { \"Coca-Cola\", \"Pepsi\" }, {\"Fanta\"}, {\"Nescafe\"}};\n    vector<string> expected2 = {};\n    assert(solution.customersWhoBoughtAllProducts(products2) == expected2);\n\n    // Test Case 3\n    vector<vector<string>> products3 = {{ \"Levi's\", \"Gap\" }, { \"Levi's\" }, {\"Apple\"}, {\"Dior\"}};\n    vector<string> expected3 = {\"Levi's\"};\n    assert(solution.customersWhoBoughtAllProducts(products3) == expected3);\n\n    return 0;\n}\n```",
  "1046": "```\n#include <iostream>\n#include <vector>\n\nint stoneGameII(std::vector<int>& stones) {\n    int n = stones.size();\n    std::vector<int> dp(2*n, 0);\n    for (int i = n - 1; i >= 0; --i) {\n        int sum = 0;\n        for (int j = i; j < n; ++j)\n            sum += stones[j];\n        if (i == n - 1)\n            dp[i] = sum;\n        else\n            dp[i] = std::max(sum, std::max(dp[2*i + 1], dp[2*i + 2]));\n    }\n    return dp[0];\n}\n\nint main() {\n    std::vector<int> testCases[] = {\n        {5},\n        {30,20,15,10},\n        {1,2}\n    };\n    \n    for (const auto& testCase : testCases) {\n        int result = stoneGameII(testCase);\n        std::cout << \"For stones: \";\n        for (int stone : testCase)\n            std::cout << stone << \" \";\n        std::cout << \"the last stone weight is: \" << result << \"\\n\";\n    }\n    \n    return 0;\n}\n```",
  "1047": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        if (s.empty()) return \"\";\n        \n        string result = \"\";\n        for (char c : s) {\n            if (!result.empty() && result.back() == c) {\n                result.pop_back();\n            } else {\n                result += c;\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.removeDuplicates(\"abcdefg\") << endl;  // Expected output: abcdefg\n    cout << \"Test case 2: \" << solution.removeDuplicates(\"azxxzy\") << endl;   // Expected output: azy\n    cout << \"Test case 3: \" << solution.removeDuplicates(\"wxyz\") << endl;       // Expected output: wxyz\n\n    return 0;\n}\n```",
  "1049": "```\n#include <iostream>\n#include <vector>\n\nint twoSum(std::vector<int>& stones, int W) {\n    std::sort(stones.begin(), stones.end());\n    int ans = 0;\n    int l = 0, r = stones.size() - 1;\n    \n    while (r > l) {\n        if ((stones[r] + stones[l]) <= W) {\n            ans += stones[r] + stones[l];\n            l++;\n            r--;\n        } else if (stones[r] > W) {\n            r--;\n        } else {\n            l++;\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> stones1 = {2,7,4,2};\n    int W1 = 10;\n    std::cout << \"Test case 1: \" << twoSum(stones1, W1) << std::endl;\n\n    // Test case 2\n    std::vector<int> stones2 = {3,5,6,4,8};\n    int W2 = 14;\n    std::cout << \"Test case 2: \" << twoSum(stones2, W2) << std::endl;\n\n    // Test case 3\n    std::vector<int> stones3 = {1,2,4,5};\n    int W3 = 7;\n    std::cout << \"Test case 3: \" << twoSum(stones3, W3) << std::endl;\n\n    return 0;\n}\n```",
  "1048": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestStrChain(vector<string>& words) {\n        if (words.empty()) return 0;\n        \n        unordered_map<string, int> dp;\n        int res = 0;\n        \n        for (const auto& word : words) {\n            int len = word.size();\n            for (int i = 1; i <= len; ++i) {\n                string prefix = word.substr(0, i);\n                if (dp.count(prefix)) {\n                    dp[word] = max(dp.count(word), dp[prefix] + 1);\n                    res = max(res, dp[word]);\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<string> words1 = {\"a\", \"ab\", \"abc\", \"abd\", \"abe\"};\n    cout << \"Test case 1: \" << solution.longestStrChain(words1) << endl;  // Expected output: 4\n\n    // Test case 2:\n    vector<string> words2 = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\"};\n    cout << \"Test case 2: \" << solution.longestStrChain(words2) << endl;  // Expected output: 1\n\n    // Test case 3:\n    vector<string> words3 = {};\n    cout << \"Test case 3: \" << solution.longestStrChain(words3) << endl;  // Expected output: 0\n}\n```",
  "1051": "```\n#include <iostream>\n#include <vector>\n\nint heightChecker(std::vector<int>& heights) {\n    std::vector<int> sortedHeights(heights);\n    std::sort(sortedHeights.begin(), sortedHeights.end());\n    \n    int res = 0;\n    for (int i = 0; i < heights.size(); i++) {\n        if (heights[i] != sortedHeights[i]) {\n            res++;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> v1 = {1, 1, 4, 2, 1, 3};\n    int res1 = heightChecker(v1);\n    std::cout << \"Test case 1: \" << res1 << std::endl;\n\n    std::vector<int> v2 = {5, 1, 2, 3, 4};\n    int res2 = heightChecker(v2);\n    std::cout << \"Test case 2: \" << res2 << std::endl;\n\n    std::vector<int> v3 = {6, 7, 10};\n    int res3 = heightChecker(v3);\n    std::cout << \"Test case 3: \" << res3 << std::endl;\n\n    return 0;\n}\n```",
  "1050": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n\nstruct Director {\n    std::string name;\n};\n\nbool operator<(const Director& d1, const Director& d2) {\n    return d1.name < d2.name;\n}\n\nstruct Actor {\n    std::string name;\n};\n\nbool operator<(const Actor& a1, const Actor& a2) {\n    return a1.name < a2.name;\n}\n\nclass Solution {\npublic:\n    std::vector<std::vector<string>> getCooperations(std::vector<pair<string, string>>& collaborations) {\n        std::map<Director, std::set<Actor>> directorActors;\n        \n        for (const auto& collaboration : collaborations) {\n            Director d = {\"director\" + to_string(stoi(collaboration.first.substr(7)) - 1)};\n            Actor a = {\"actor\" + to_string(stoi(collaboration.second.substr(6)) - 1)};\n            \n            directorActors[d].insert(a);\n        }\n        \n        std::vector<std::vector<string>> result;\n        \n        for (const auto& pair : directorActors) {\n            if (pair.second.size() >= 3) {\n                std::vector<string> cooperation = {pair.first.name};\n                for (const auto& actor : pair.second) {\n                    cooperation.push_back(actor.name);\n                }\n                result.push_back(cooperation);\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<pair<string, string>> collaborations = {{\"D1\", \"A1\"}, {\"D1\", \"A2\"}, {\"D1\", \"A3\"}, {\"D1\", \"A4\"}};\n    std::vector<std::vector<string>> expected = {{\"director0\", \"actor0\", \"actor1\", \"actor2\"}};\n    auto result = solution.getCooperations(collaborations);\n    for (int i = 0; i < result.size(); ++i) {\n        for (int j = 0; j < result[i].size(); ++j) {\n            std::cout << result[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    // Test Case 2\n    collaborations = {{\"D2\", \"A1\"}, {\"D2\", \"A2\"}, {\"D3\", \"A3\"}};\n    expected = {{}, {}};\n    result = solution.getCooperations(collaborations);\n    for (int i = 0; i < result.size(); ++i) {\n        for (int j = 0; j < result[i].size(); ++j) {\n            std::cout << result[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    // Test Case 3\n    collaborations = {{\"D1\", \"A1\"}, {\"D2\", \"A1\"}};\n    expected = {{}};\n    result = solution.getCooperations(collaborations);\n    for (int i = 0; i < result.size(); ++i) {\n        for (int j = 0; j < result[i].size(); ++j) {\n            std::cout << result[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1052": "```\n#include <iostream>\n#include <vector>\n\nint maxSatisfied(std::vector<int>& customers, int n) {\n    int maxSatisfied = 0;\n    for (int i = 0; i <= customers.size() - n; ++i) {\n        int sum = 0;\n        for (int j = i; j < i + n; ++j) {\n            if (customers[j] > 1) {\n                sum += 2;\n            } else {\n                sum += customers[j];\n            }\n        }\n        maxSatisfied = std::max(maxSatisfied, sum);\n    }\n    return maxSatisfied;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<int> customers1 = {1,0,1,2,3};\n    int n1 = 3;\n    std::cout << \"Test Case 1: \" << maxSatisfied(customers1, n1) << std::endl;\n\n    // Test Case 2\n    std::vector<int> customers2 = {0,1,1,2,5,0};\n    int n2 = 4;\n    std::cout << \"Test Case 2: \" << maxSatisfied(customers2, n2) << std::endl;\n\n    // Test Case 3\n    std::vector<int> customers3 = {7,2,1,2,8};\n    int n3 = 2;\n    std::cout << \"Test Case 3: \" << maxSatisfied(customers3, n3) << std::endl;\n\n    return 0;\n}\n```",
  "1053": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> prevPerm(vector<int>& arr) {\n        int i = arr.size() - 2;\n        while (i >= 0 && arr[i] <= arr[i + 1]) {\n            i--;\n        }\n        if (i < 0) return arr; // already the smallest permutation\n        for (int j = arr.size() - 1; j > i; j--) {\n            if (arr[j] < arr[i]) {\n                swap(arr[i], arr[j]);\n                break;\n            }\n        }\n        return arr;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> arr1 = {3,1,5,8};\n    cout << \"Previous Permutation With One Swap for arr1: \";\n    for (int num : solution.prevPerm(arr1)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<int> arr2 = {1,3,5,8};\n    cout << \"Previous Permutation With One Swap for arr2: \";\n    for (int num : solution.prevPerm(arr2)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<int> arr3 = {1,5,3,8};\n    cout << \"Previous Permutation With One Swap for arr3: \";\n    for (int num : solution.prevPerm(arr3)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1054": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint rearrangeBarcodes(vector<string>& barcodes) {\n    unordered_map<int, int> count;\n    for (string s : barcodes) {\n        for (char c : s) {\n            count[c]++;\n        }\n    }\n\n    vector<pair<char, int>> pq;\n    for (auto it = count.begin(); it != count.end(); ++it) {\n        pq.push_back({it->first, it->second});\n    }\n\n    sort(pq.rbegin(), pq.rend());\n    \n    string result = \"\";\n    priority_queue<int> q;\n    for (int i = 0; i < pq.size() && !q.empty(); ++i) {\n        while (!q.empty()) {\n            q.pop();\n        }\n        if (pq[i].second > 1) {\n            int x = pq[i].second - 1;\n            while (x--) {\n                q.push(pq[i].first);\n            }\n        } else {\n            result += pq[i].first;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    vector<string> barcodes1 = {\"123\",\"321\",\"412\"};\n    cout << \"Case 1: \" << rearrangeBarcodes(barcodes1) << endl;\n\n    vector<string> barcodes2 = {\"11112\",\"32223\",\"5111333333\"};\n    cout << \"Case 2: \" << rearrangeBarcodes(barcodes2) << endl;\n\n    vector<string> barcodes3 = {\"1234\",\"1432\",\"1002\"};\n    cout << \"Case 3: \" << rearrangeBarcodes(barcodes3) << endl;\n\n    return 0;\n}",
  "1055": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestWay(string s, string t) {\n        int res = INT_MAX;\n        for (int i = 0; i <= s.size() - t.size(); i++) {\n            bool found = true;\n            for (int j = 0; j < t.size(); j++) {\n                if (s[i + j] != t[j]) {\n                    found = false;\n                    break;\n                }\n            }\n            if (!found) continue;\n\n            int left = i, right = i + t.size() - 1;\n            while (left <= right) {\n                if (s[left] == s[right]) {\n                    left++;\n                    right--;\n                } else if (s[left] < s[right]) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n\n            res = min(res, i + t.size());\n        }\n        return res != INT_MAX ? res : -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s1 = \"abc\";\n    string t1 = \"ab\";\n    cout << \"Test case 1: \" << solution.shortestWay(s1, t1) << endl; // Output: 1\n\n    // Test case 2\n    string s2 = \"aaabaaaaa\";\n    string t2 = \"aab\";\n    cout << \"Test case 2: \" << solution.shortestWay(s2, t2) << endl; // Output: 3\n\n    // Test case 3\n    string s3 = \"leetcodele\";\n    string t3 = \"leet\";\n    cout << \"Test case 3: \" << solution.shortestWay(s3, t3) << endl; // Output: 1\n\n    return 0;\n}\n```",
  "1056": "```\n#include <iostream>\n#include <vector>\n\nbool hasConfusingNumber(int n) {\n    int count = 0;\n    while (n > 0) {\n        int digit = n % 10;\n        if (digit != 0 && !((digit & 1) == 1)) {\n            return false;\n        }\n        n /= 10;\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> testCases = {20, 21, 12345};\n    \n    for (const auto& testCase : testCases) {\n        if (hasConfusingNumber(testCase)) {\n            std::cout << \"The number \" << testCase << \" is a Confusing Number.\" << std::endl;\n        } else {\n            std::cout << \"The number \" << testCase << \" is not a Confusing Number.\" << std::endl;\n        }\n    }\n    \n    return 0;\n}\n```",
  "1058": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint totalMoney(int n) {\n    int result = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 4 == 1 || i % 4 == 2)\n            result += 5;\n        else\n            result += 10;\n    }\n    return result;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << totalMoney(4) << std::endl;  // Expected output: 20\n    std::cout << \"Test case 2: \" << totalMoney(10) << std::endl;   // Expected output: 100\n    std::cout << \"Test case 3: \" << totalMoney(15) << std::endl;   // Expected output: 150\n\n    return 0;\n}",
  "1057": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findCenter(vector<vector<int>>& edges) {\n        priority_queue<int> pq;\n        for (const auto& edge : edges) {\n            if (pq.empty() || pq.top() != edge[0] && pq.top() != edge[1]) {\n                pq.push(edge[0]);\n            }\n        }\n        return {pq.top(), pq.top()};\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<vector<int>> edges1 = {{0,1},{2,3}};\n    cout << \"Test Case 1: \";\n    for (const auto& node : solution.findCenter(edges1)) {\n        cout << node << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<vector<int>> edges2 = {{0,1},{1,2},{3,4}};\n    cout << \"Test Case 2: \";\n    for (const auto& node : solution.findCenter(edges2)) {\n        cout << node << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<vector<int>> edges3 = {{0,1},{1,2},{2,0}};\n    cout << \"Test Case 3: \";\n    for (const auto& node : solution.findCenter(edges3)) {\n        cout << node << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1060": "```\n#include <iostream>\n#include <vector>\n\nint searchInsert(std::vector<int>& nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return left;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 3};\n    int target1 = 2;\n    std::cout << \"Test case 1: \" << searchInsert(nums1, target1) << std::endl;\n\n    std::vector<int> nums2 = [0, 1, 2, 4];\n    int target2 = 3;\n    std::cout << \"Test case 2: \" << searchInsert(nums2, target2) << std::endl;\n\n    std::vector<int> nums3 = {1};\n    int target3 = 0;\n    std::cout << \"Test case 3: \" << searchInsert(nums3, target3) << std::endl;\n\n    return 0;\n}",
  "1059": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool leadsToDestination(int n, vector<vector<int>>& edges) {\n        vector<bool> visited(n, false);\n        for (int i = 0; i < n; ++i) {\n            if (!dfs(i, visited, edges)) return false;\n        }\n        return true;\n    }\n\n    bool dfs(int node, vector<bool>& visited, const vector<vector<int>>& edges) {\n        visited[node] = true;\n        for (const auto& edge : edges) {\n            if (edge[0] == node) {\n                int nextNode = edge[1];\n                if (!visited[nextNode]) {\n                    if (!dfs(nextNode, visited, edges)) return false;\n                } else if (!leadsToDestination(1, {{node, nextNode}})) return false;\n                return true;\n            }\n        }\n        return true;\n    }\n\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    int n1 = 2;\n    vector<vector<int>> edges1 = {{0,1},{1,2}};\n    cout << (solution.leadsToDestination(n1, edges1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    int n2 = 3;\n    vector<vector<int>> edges2 = {{0,1},{0,2}};\n    cout << (solution.leadsToDestination(n2, edges2) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    int n3 = 4;\n    vector<vector<int>> edges3 = {{0,1},{0,2},{3,2},{1,3}};\n    cout << (solution.leadsToDestination(n3, edges3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1062": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint longestRepeatingSubstring(const std::string& s) {\n    int n = s.length();\n    for (int len = 1; len <= n / 2; ++len) {\n        for (int i = 0; i + len <= n; ++i) {\n            if (s.substr(i, len) == s.substr(n - len, len)) {\n                return len;\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    std::cout << longestRepeatingSubstring(\"abcabc\") << std::endl; // Expected output: 3\n    std::cout << longestRepeatingSubstring(\"aaaaa\") << std::endl; // Expected output: 5\n    std::cout << longestRepeatingSubstring(\"abcdefghijklmnopqrstuvwxyz\") << std::endl; // Expected output: 0\n    return 0;\n}",
  "1061": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    string smallestString(int n, vector<vector<char>>& strs) {\n        vector<int> parent(n);\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n        \n        for (int i = 0; i < strs.size(); ++i) {\n            for (char c : strs[i]) {\n                int pos = c - 'a';\n                if (pos >= 0 && pos < n) {\n                    int x = find(pos, parent);\n                    for (char d : strs[i])\n                        if ((d - 'a') == x)\n                            strs[i].erase(remove(strs[i].begin(), strs[i].end(), d), strs[i].end());\n                }\n            }\n        }\n        \n        string res;\n        for (int i = 0; i < n; ++i) {\n            int pos = i;\n            while (pos > -1) {\n                char c = strs[pos][0];\n                res += c;\n                pos = find(pos, parent);\n            }\n        }\n        return res;\n    }\n    \n    int find(int x, vector<int>& parent) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x], parent);\n        return parent[x];\n    }\n};\n\nint main() {\n    Solution solution;\n    // Test case 1\n    vector<vector<char>> strs1{{\"ca\",\"cb\"}};\n    cout << \"Test Case 1: \" << solution.smallestString(2, strs1) << endl;\n    \n    // Test case 2\n    vector<vector<char>> strs2{{\"kiex\",\"kixu\",\"ucldd\"}};\n    cout << \"Test Case 2: \" << solution.smallestString(3, strs2) << endl;\n    \n    // Test case 3\n    vector<vector<char>> strs3{{\"ab\",\"cd\"}};\n    cout << \"Test Case 3: \" << solution.smallestString(2, strs3) << endl;\n    return 0;\n}\n```",
  "1063": "```\n#include <iostream>\n#include <vector>\n\nint numSubarray(const std::vector<int>& nums) {\n    int res = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        int cnt = 1, left = i + 1;\n        while (left < nums.size() && nums[left] <= nums[i]) {\n            ++cnt;\n            ++left;\n        }\n        res += cnt * (nums.size() - left);\n    }\n    return res;\n}\n\nint main() {\n    std::cout << numSubarray({2, 1, 10, 3, 1, 5, 8}) << std::endl; // Output: 14\n    std::cout << numSubarray({4, 2, 3, 1, 9, 3, 1, 5, 4, 8}) << std::endl; // Output: 31\n    std::cout << numSubarray({1, 2, 3, 4, 5}) << std::endl; // Output: 20\n\n    return 0;\n}\n```",
  "1064": "```\n#include <iostream>\n#include <vector>\n\nint fixedPoint(std::vector<int>& arr) {\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] == i) return i;\n    }\n    return -1;\n}\n\nint main() {\n    std::vector<int> arr1 = {0, 5, 3};\n    std::cout << \"Test case 1: \" << fixedPoint(arr1) << std::endl;\n\n    std::vector<int> arr2 = {2};\n    std::cout << \"Test case 2: \" << fixedPoint(arr2) << std::endl;\n\n    std::vector<int> arr3 = {0, 1, 5};\n    std::cout << \"Test case 3: \" << fixedPoint(arr3) << std::endl;\n\n    return 0;\n}\n```",
  "1065": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> indexPairs(string str) {\n        vector<vector<int>> result;\n        for (int i = 0; i < str.size(); i++) {\n            if (str[i] == ' ') {\n                int count = 1;\n                while (i + 1 < str.size() && str[i+1] == ' ') i++;\n                for (int j = i + 1; j < str.size(); j++) {\n                    if (str[j] == ' ') break;\n                    count++;\n                }\n                result.push_back({i, i + count - 1});\n                i += count - 1;\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> testCase1 = {{0,4},{20,25}};\n    cout << \"Test Case 1: \";\n    for (vector<int> pair : solution.indexPairs(\"Hello World\")) {\n        cout << \"(\" << pair[0] << \", \" << pair[1] << \") \";\n    }\n    cout << endl;\n\n    vector<vector<int>> testCase2 = {{0,5},{3,7}};\n    cout << \"Test Case 2: \";\n    for (vector<int> pair : solution.indexPairs(\"   Walk the    line\")) {\n        cout << \"(\" << pair[0] << \", \" << pair[1] << \") \";\n    }\n    cout << endl;\n\n    vector<vector<int>> testCase3 = {{0,10}};\n    cout << \"Test Case 3: \";\n    for (vector<int> pair : solution.indexPairs(\"   Hello   World   \")) {\n        cout << \"(\" << pair[0] << \", \" << pair[1] << \") \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1066": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector> dfs(vector<vector>& bikeStations, int start) {\n        vector<int> bikes = bikeStations[start];\n        int n = bikeStations.size();\n        vector<vector> res;\n        \n        for (int i = 0; i < n; ++i) {\n            if (i != start && !bitsMatch(bikes, bikeStations[i])) {\n                vector<int> bikesNext = bikes;\n                bikesNext[0] += bikeStations[i][0];\n                bikesNext[1] += bikeStations[i][1];\n                \n                res.push_back(bikeStations[i]);\n                res.push_back(dfs(bikeStations, i));\n                return res;\n            }\n        }\n        \n        return {{}, {}};\n    }\n    \n    bool bitsMatch(vector<int>& a, vector<int>& b) {\n        int mask = 0;\n        for (int i = 0; i < a.size(); ++i) {\n            if ((a[i] ^ b[i]) & 1)\n                mask |= 1 << i;\n        }\n        return !mask;\n    }\n\n    vector<vector> connect(vector<vector>& bikeStations, int start) {\n        if (start >= bikeStations.size())\n            return {{}, {}};\n        \n        vector<vector> res = dfs(bikeStations, start);\n        \n        for (int i = 0; i < bikeStations.size(); ++i) {\n            if (!bitsMatch(res[1][0], bikeStations[i])) {\n                res.push_back({res[1][0]});\n                res.push_back(dfs(bikeStations, i));\n                return res;\n            }\n        }\n        \n        return {{}, {}};\n    }\n\n    vector<vector> connectBikes(vector<vector>& bikeStations) {\n        int n = bikeStations.size();\n        for (int i = 0; i < n; ++i)\n            if (!bikeStations[i].size())\n                return {{}, {}};\n        \n        int start = -1;\n        for (int i = 0; i < n; ++i) {\n            if (!bitsMatch(bikeStations[0], bikeStations[i])) {\n                start = i;\n                break;\n            }\n        }\n        \n        return connect(bikeStations, start);\n    }\n\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> bikeStations1{{3,6},{4,5},{2,3}};\n    vector<vector> res1 = solution.connectBikes(bikeStations1);\n    for (auto &station : res1) {\n        for (int i = 0; i < station.size(); ++i) {\n            cout << station[i] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> bikeStations2{{1,2},{5,7}};\n    vector<vector> res2 = solution.connectBikes(bikeStations2);\n    for (auto &station : res2) {\n        for (int i = 0; i < station.size(); ++i) {\n            cout << station[i] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> bikeStations3{{10,20},{11,21},{12,22},{13,23},{14,24}};\n    vector<vector> res3 = solution.connectBikes(bikeStations3);\n    for (auto &station : res3) {\n        for (int i = 0; i < station.size(); ++i) {\n            cout << station[i] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
  "1067": "```\n#include <iostream>\nusing namespace std;\n\nint countDigits(int num) {\n    int count = 0;\n    while(num > 0) {\n        num /= 10;\n        count++;\n    }\n    return count;\n}\n\nint findDigitCountInRange(int low, int high) {\n    int count = 0;\n    for(int i = low; i <= high; i++) {\n        count += countDigits(i);\n    }\n    return count;\n}\n\nint main() {\n    cout << \"Test Case 1: \" << findDigitCountInRange(1, 13) << endl;\n    cout << \"Test Case 2: \" << findDigitCountInRange(100, 200) << endl;\n    cout << \"Test Case 3: \" << findDigitCountInRange(-10, -5) << endl;\n    return 0;\n}\n```",
  "1069": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> top5id(int num) {\n        if (num <= 0) return {};\n        int maxSales = 0;\n        string topId = \"\";\n        \n        for (int i = 1; i <= num; i++) {\n            int sales = rand() % 100 + 1; // random sales\n            if (sales > maxSales) {\n                maxSales = sales;\n                topId = to_string(i);\n            }\n        }\n        \n        vector<int> res;\n        for (int i = 1; i <= num; i++) {\n            int sales = rand() % 100 + 1; // random sales\n            if (sales == maxSales && i != stoi(topId)) {\n                res.push_back(i);\n                --maxSales;\n                --i;\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    int num = 5;\n    vector<int> result1 = solution.top5id(num);\n    cout << \"Top 5 IDs for products with most sales: \";\n    for (int id : result1) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    num = 10;\n    vector<int> result2 = solution.top5id(num);\n    cout << \"Top 5 IDs for products with most sales: \";\n    for (int id : result2) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    num = 15;\n    vector<int> result3 = solution.top5id(num);\n    cout << \"Top 5 IDs for products with most sales: \";\n    for (int id : result3) {\n        cout << id << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1068": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> productSalesAnalysis(vector<string>& salesData) {\n        vector<string> result;\n        for (int i = 0; i < salesData.size(); i++) {\n            string sale = salesData[i];\n            int pos1 = sale.find(\",\");\n            int pos2 = sale.find(\",\", pos1 + 1);\n            string product = sale.substr(0, pos1).substr(1);\n            int quantity = stoi(sale.substr(pos1 + 1, pos2 - (pos1 + 1)));\n            result.push_back(product + \" \" + to_string(quantity));\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<string> salesData1 = {\"Apple,3\", \"Banana,4\"};\n    vector<string> result1 = solution.productSalesAnalysis(salesData1);\n    for (string sale : result1) {\n        cout << sale << endl;\n    }\n\n    // Test Case 2\n    vector<string> salesData2 = {\"Mango,5\", \"Grapes,7\", \"Apple,3\"};\n    vector<string> result2 = solution.productSalesAnalysis(salesData2);\n    for (string sale : result2) {\n        cout << sale << endl;\n    }\n\n    // Test Case 3\n    vector<string> salesData3 = {\"Watermelon,10\", \"Cherry,8\"};\n    vector<string> result3 = solution.productSalesAnalysis(salesData3);\n    for (string sale : result3) {\n        cout << sale << endl;\n    }\n\n    return 0;\n}\n```",
  "1071": "```\n#include <iostream>\n#include <string>\n\nint gcdOfStrings(std::string str1, std::string str2) {\n    if (str1 + str2 != str2 + str1) return 0;\n    \n    int len = str1.length();\n    for (int i = len; i > 0; --i) {\n        if (str1.substr(0, i).length() * len % (i * 2) == 0 && \n            str2.substr(0, i).length() * len % (i * 2) == 0) {\n            return i;\n        }\n    }\n    \n    return len;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << gcdOfStrings(\"ABCABC\", \"ABC\") << std::endl; // Output: 3\n    std::cout << \"Test case 2: \" << gcdOfStrings(\"ABAB\", \"BABA\") << std::endl; // Output: 0\n    std::cout << \"Test case 3: \" << gcdOfStrings(\"\", \"\") << std::endl; // Output: 0\n    \n    return 0;\n}\n```",
  "1070": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> productSalesAnalysisIII(vector<vector<int>>& sales) {\n        int totalRevenue = 0;\n        int maxPrice = 0;\n        string bestSellingProduct = \"\";\n        \n        for (const auto& sale : sales) {\n            totalRevenue += sale[1];\n            if (sale[2] > maxPrice) {\n                maxPrice = sale[2];\n                bestSellingProduct = to_string(sale[0]);\n            }\n        }\n        \n        vector<string> result;\n        result.push_back(to_string(totalRevenue));\n        result.push_back(bestSellingProduct);\n        result.push_back(to_string(maxPrice));\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> sales1 = {{10, 1000, 50}, {20, 2000, 70}};\n    vector<string> expectedResult1 = {\"4000\", \"20\", \"70\"};\n    vector<string> actualResult1 = solution.productSalesAnalysisIII(sales1);\n    if (actualResult1 != expectedResult1) {\n        cout << \"Test Case 1 failed.\" << endl;\n    } else {\n        cout << \"Test Case 1 passed.\" << endl;\n    }\n\n    // Test Case 2\n    vector<vector<int>> sales2 = {{5, 5000, 30}, {10, 10000, 40}};\n    vector<string> expectedResult2 = {\"15000\", \"5\", \"40\"};\n    vector<string> actualResult2 = solution.productSalesAnalysisIII(sales2);\n    if (actualResult2 != expectedResult2) {\n        cout << \"Test Case 2 failed.\" << endl;\n    } else {\n        cout << \"Test Case 2 passed.\" << endl;\n    }\n\n    // Test Case 3\n    vector<vector<int>> sales3 = {{1, 1000, 20}, {2, 2000, 30}, {3, 3000, 40}};\n    vector<string> expectedResult3 = {\"6000\", \"1\", \"40\"};\n    vector<string> actualResult3 = solution.productSalesAnalysisIII(sales3);\n    if (actualResult3 != expectedResult3) {\n        cout << \"Test Case 3 failed.\" << endl;\n    } else {\n        cout << \"Test Case 3 passed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1072": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {\n    int maxCount = 0;\n    vector<string> rows(matrix.size());\n    for (int i = 0; i < matrix.size(); i++) {\n        string rowStr = \"\";\n        for (int j = 0; j < matrix[0].size(); j++) {\n            rowStr += to_string(matrix[i][j]);\n        }\n        rows[i] = rowStr;\n    }\n\n    int maxCountFlip = 0, countFlip = 0;\n    bool flipFlag = false;\n\n    for (int i = 0; i < matrix.size(); i++) {\n        vector<int> tempRow;\n        string rowStr = rows[i];\n\n        for (int j = 0; j < matrix[0].size() / 2; j++) {\n            if (rowStr[j] == '1' && !flipFlag) {\n                flipFlag = true;\n            } else if (rowStr[j] == '0' && flipFlag) {\n                flipFlag = false;\n            }\n        }\n\n        for (int j = 0; j < matrix[0].size(); j++) {\n            if (rowStr[j] == rowStr[j % 2]) {\n                tempRow.push_back(rowStr[j]);\n            } else {\n                tempRow.push_back(flipFlag ? '1' - rowStr[j] : rowStr[j]);\n            }\n        }\n\n        int countEqual = 0;\n        for (int j = 0; j < matrix[0].size() / 2; j++) {\n            if (tempRow[j] == tempRow[j + matrix[0].size() / 2]) {\n                countEqual++;\n            } else {\n                break;\n            }\n        }\n\n        if (countEqual > maxCountFlip) {\n            maxCountFlip = countEqual;\n            countFlip = 1;\n        } else if (countEqual == maxCountFlip) {\n            countFlip++;\n        }\n\n        maxCount = max(maxCount, countFlip);\n    }\n\n    return maxCount;\n}\n\nint main() {\n    vector<vector<int>> matrix1 = {{0,1},{1,1}};\n    cout << \"Test case 1: \" << maxEqualRowsAfterFlips(matrix1) << endl;\n\n    vector<vector<int>> matrix2 = {{0,1},{1,1},{1,0}};\n    cout << \"Test case 2: \" << maxEqualRowsAfterFlips(matrix2) << endl;\n\n    vector<vector<int>> matrix3 = {{0,1,0},{1,1,1},{0,1,0}};\n    cout << \"Test case 3: \" << maxEqualRowsAfterFlips(matrix3) << endl;\n    \n    return 0;\n}\n```",
  "1073": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string addNegabinary(vector<int>& nums) {\n        int i = 0, j = 0;\n        while (i < nums.size() && j < nums.size()) {\n            if (nums[i] == 1) {\n                nums.insert(nums.begin() + i, 0);\n                i++;\n            }\n            if (nums[j] == 1) {\n                nums.insert(nums.begin() + j, 0);\n                j++;\n            }\n            while (i > 0 && j > 0 && nums[i - 1] == 1 && nums[j - 1] == 1) {\n                nums[--j] += 2;\n                --i;\n            }\n            if (i > 0 && j > 0 && nums[i - 1] == 1 && nums[j - 1] == 0) {\n                nums[--j]++;\n            } else if (j > 0 && nums[j - 1] == 1) {\n                nums[--j]++;\n            }\n        }\n        vector<int> res;\n        for (; i < nums.size(); ++i) {\n            res.push_back(nums[i]);\n        }\n        string ans = \"\";\n        for (int num : res) {\n            ans += to_string(num);\n        }\n        return ans.empty() ? \"0\" : ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> nums1 = {1, 2};\n    cout << solution.addNegabinary(nums1) << endl; // Output: 11\n\n    vector<int> nums2 = {100, -101};\n    cout << solution.addNegabinary(nums2) << endl; // Output: 10000\n\n    vector<int> nums3 = {-1, -1};\n    cout << solution.addNegabinary(nums3) << endl; // Output: 10\n\n    return 0;\n}\n```",
  "1074": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSubmatrixSumTarget(vector<vector<int>>& mat, int target) {\n        int m = mat.size();\n        int n = mat[0].size();\n        \n        for (int i = 0; i < m; ++i) {\n            vector<int> sum(n);\n            for (int j = i; j < m; ++j) {\n                for (int k = 0; k < n; ++k) {\n                    sum[k] += mat[j][k];\n                }\n                \n                int count = 0;\n                int left = 0, right = n - 1;\n                while (left <= right) {\n                    int mid = (left + right) / 2;\n                    \n                    if (sum[mid] == target) {\n                        count += (right - left + 1);\n                        break;\n                    } else if (sum[mid] < target) {\n                        left = mid + 1;\n                    } else {\n                        right = mid - 1;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> mat1 = {{-1,-1,5},{-100,100},{1,2,3}};\n    int target1 = 0;\n    cout << \"Test case 1: \" << solution.numSubmatrixSumTarget(mat1, target1) << endl;\n\n    vector<vector<int>> mat2 = {{0,1,1},{1,1,1},{1,0,1}};\n    int target2 = 0;\n    cout << \"Test case 2: \" << solution.numSubmatrixSumTarget(mat2, target2) << endl;\n\n    vector<vector<int>> mat3 = {{23,-1,-5,60},{1,-6,10,12},{5,5,4,-2},{7,3,9,-4},{2,0,-9,-10}};\n    int target3 = 15;\n    cout << \"Test case 3: \" << solution.numSubmatrixSumTarget(mat3, target3) << endl;\n\n    return 0;\n}\n```",
  "1075": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Employee {\npublic:\n    int id;\n    string name;\n};\n\nbool compare(const Employee& e1, const Employee& e2) {\n    return e1.id < e2.id;\n}\n\nint main() {\n    vector<Employee> employees = {{1, \"John\"}, {4, \"Alice\"}, {3, \"Bob\"}, {2, \"Mike\"}};\n    \n    // Test case 1: Only one project\n    unordered_map<int, vector<string>> projects;\n    projects[1] = {\"John\", \"Alice\"};\n    sort(employees.begin(), employees.end(), compare);\n    vector<Employee> expectedEmployees = {{1, \"Alice\"}, {1, \"John\"}};\n    bool result1 = true;\n    for (int i = 0; i < employees.size(); i++) {\n        if (i >= projects[1].size()) break;\n        if (employees[i].id != 1 || employees[i].name != projects[1][i]) {\n            result1 = false;\n            break;\n        }\n    }\n    \n    // Test case 2: Two projects\n    projects.clear();\n    projects[1] = {\"John\", \"Alice\"};\n    projects[2] = {\"Bob\", \"Mike\"};\n    sort(employees.begin(), employees.end(), compare);\n    expectedEmployees = {{1, \"Alice\"}, {1, \"John\"}, {2, \"Bob\"}, {2, \"Mike\"}};\n    bool result2 = true;\n    for (int i = 0; i < employees.size(); i++) {\n        if (i >= projects[1].size()) break;\n        if (employees[i].id != 1 || employees[i].name != projects[1][i]) {\n            result2 = false;\n            break;\n        }\n    }\n    \n    // Test case 3: No project\n    projects.clear();\n    sort(employees.begin(), employees.end(), compare);\n    expectedEmployees = {{1, \"John\"}, {2, \"Mike\"}, {3, \"Bob\"}, {4, \"Alice\"}};\n    bool result3 = true;\n    for (int i = 0; i < employees.size(); i++) {\n        if (i >= expectedEmployees.size()) break;\n        if (employees[i].id != expectedEmployees[i].id || employees[i].name != expectedEmployees[i].name) {\n            result3 = false;\n            break;\n        }\n    }\n    \n    cout << \"Test case 1: \" << (result1 ? \"Pass\" : \"Fail\") << endl;\n    cout << \"Test case 2: \" << (result2 ? \"Pass\" : \"Fail\") << endl;\n    cout << \"Test case 3: \" << (result3 ? \"Pass\" : \"Fail\") << endl;\n    \n    return 0;\n}",
  "1076": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int numEomployees(int salary) {\n        if(salary >= 1000000) return 2;\n        else if(salary >= 50000 && salary < 1000000) return 3;\n        else if(salary >= 30000 && salary < 50000) return 1;\n        else return 0;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int result = solution.numEomployees(800000);\n    std::cout << \"Expected: 2, Actual: \" << result << std::endl;\n\n    // Test Case 2\n    result = solution.numEomployees(75000);\n    std::cout << \"Expected: 3, Actual: \" << result << std::endl;\n\n    // Test Case 3\n    result = solution.numEomployees(25000);\n    std::cout << \"Expected: 1, Actual: \" << result << std::endl;\n\n    return 0;\n}\n```",
  "1078": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findOCCurrences(string text, string pattern) {\n        vector<string> res;\n        for (int i = 0; i + pattern.length() <= text.length(); i++) {\n            if (text.substr(i, pattern.length()) == pattern) {\n                res.push_back(text.substr(i + pattern.length()));\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string text = \"alicehello\";\n    string pattern = \"ell\";\n    vector<string> res1 = solution.findOCCurrences(text, pattern);\n    for (string s : res1) {\n        cout << s << endl;\n    }\n\n    // Test case 2\n    text = \"lovelive\";\n    pattern = \"live\";\n    vector<string> res2 = solution.findOCCurrences(text, pattern);\n    for (string s : res2) {\n        cout << s << endl;\n    }\n\n    // Test case 3\n    text = \"abcabc\";\n    pattern = \"bc\";\n    vector<string> res3 = solution.findOCCurrences(text, pattern);\n    for (string s : res3) {\n        cout << s << endl;\n    }\n}\n```",
  "1077": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numEomployees(int employee_id, vector<vector<int>>& queries) {\n        // implement your solution here\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test Case 1\n    vector<vector<int>> queries1 = {{1},{2}};\n    cout << \"Test Case 1: \" << s.numEomployees(5, queries1) << endl;\n\n    // Test Case 2\n    vector<vector<int>> queries2 = {{3,2},{4,1}};\n    cout << \"Test Case 2: \" << s.numEomployees(7, queries2) << endl;\n\n    // Test Case 3\n    vector<vector<int>> queries3 = {{5,6},{10,20}};\n    cout << \"Test Case 3: \" << s.numEomployees(15, queries3) << endl;\n    \n    return 0;\n}\n```",
  "1079": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numTilePossibilities(string tiles) {\n        vector<string> res;\n        dfs(tiles, \"\", res);\n        return res.size();\n    }\n\n    void dfs(string s, string path, vector<string>& res) {\n        if (s.empty()) {\n            res.push_back(path);\n            return;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            string p = path + s[i];\n            s.erase(i, 1);\n            dfs(s, p, res);\n            s.insert(i, 1, s[i]);\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.numTilePossibilities(\"AAB\") << endl; // Output: 8\n    cout << solution.numTilePossibilities(\"\") << endl; // Output: 0\n    cout << solution.numTilePossibilities(\"AA\") << endl; // Output: 3\n    return 0;\n}\n```",
  "1081": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint minSteps(std::string s) {\n    std::vector<char> stack;\n    int res = 0;\n\n    for (char c : s) {\n        while (!stack.empty() && stack.back() == c) {\n            stack.pop_back();\n        }\n        if (!stack.empty()) {\n            res++;\n        }\n        stack.push_back(c);\n    }\n\n    return res;\n}\n\nint main() {\n    std::cout << minSteps(\"abac\") << std::endl;  // Output: 2\n    std::cout << minSteps(\"aa\") << std::endl;     // Output: 1\n    std::cout << minSteps(\"a\") << std::endl;       // Output: 0\n\n    return 0;\n}\n```",
  "1080": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int sufficientNodes(TreeNode* root) {\n        if (!root)\n            return 0;\n        else\n            return (1 + sufficientNodes(root->left) + sufficientNodes(root->right));\n    }\n};\n\nint main() {\n    // Test case 1: A simple tree with one node.\n    TreeNode* test1Root = new TreeNode(1);\n    cout << \"Test case 1: \" << Solution().sufficientNodes(test1Root) << endl;\n\n    // Test case 2: A tree with three nodes (root, left, right).\n    test1Root->left = new TreeNode(2);\n    test1Root->right = new TreeNode(3);\n    cout << \"Test case 2: \" << Solution().sufficientNodes(test1Root) << endl;\n\n    // Test case 3: A tree with four nodes (root, left-left, left-right, right).\n    test1Root->left->left = new TreeNode(4);\n    test1Root->left->right = new TreeNode(5);\n    test1Root->right = new TreeNode(6);\n    cout << \"Test case 3: \" << Solution().sufficientNodes(test1Root) << endl;\n    \n    return 0;\n}",
  "1083": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nclass Solution {\npublic:\n    int maxProfit(std::vector<std::string>& transactions) {\n        int totalProfit = 0;\n        for (int i = 1; i < transactions.size(); i++) {\n            if (transactions[i] == \"BUY\" && transactions[i - 1] == \"SELL\") {\n                totalProfit += 100;\n            } else if (transactions[i] == \"SELL\" && transactions[i - 1] == \"BUY\") {\n                totalProfit -= 100;\n            }\n        }\n        return totalProfit;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::string> test1 = {\"BUY\", \"SELL\", \"BUY\", \"SELL\"};\n    std::cout << \"Test 1: \" << solution.maxProfit(test1) << std::endl; // Output: 200\n\n    std::vector<std::string> test2 = {\"BUY\", \"SELL\", \"SELL\", \"BUY\"};\n    std::cout << \"Test 2: \" << solution.maxProfit(test2) << std::endl; // Output: 0\n\n    std::vector<std::string> test3 = {\"BUY\", \"BUY\", \"SELL\", \"BUY\", \"SELL\"};\n    std::cout << \"Test 3: \" << solution.maxProfit(test3) << std::endl; // Output: 200\n\n    return 0;\n}\n```",
  "1082": "```\n#include <iostream>\n#include <vector>\n\nclass SalesAnalysis {\npublic:\n    int totalMoney(int r, int c, std::vector<std::vector<int>>& sales) {\n        if (r <= 0 || c <= 0) return 0;\n        \n        long long total = 0;\n        for (int i = 0; i < r; ++i) {\n            for (int j = 0; j < c; ++j) {\n                total += sales[i][j];\n            }\n        }\n        return static_cast<int>(total);\n    }\n};\n\nint main() {\n    SalesAnalysis sa;\n    \n    // Test case 1\n    int r1 = 3, c1 = 2;\n    std::vector<std::vector<int>> sales1 = {{1000, 2000}, {3000, 4000}, {5000, 6000}};\n    std::cout << \"Test Case 1: \" << sa.totalMoney(r1, c1, sales1) << std::endl;\n\n    // Test case 2\n    int r2 = 4, c2 = 3;\n    std::vector<std::vector<int>> sales2 = {{100, 200, 300}, {400, 500, 600}, {700, 800, 900}, {1000, 1100, 1200}};\n    std::cout << \"Test Case 2: \" << sa.totalMoney(r2, c2, sales2) << std::endl;\n\n    // Test case 3\n    int r3 = 1, c3 = 5;\n    std::vector<std::vector<int>> sales3 = {{1000, 2000, 3000, 4000, 5000}};\n    std::cout << \"Test Case 3: \" << sa.totalMoney(r3, c3, sales3) << std::endl;\n\n    return 0;\n}\n```",
  "1085": "```\n#include <iostream>\n#include <vector>\n\nint minimumNumber(std::vector<int>& nums) {\n    int minNum = *std::min_element(nums.begin(), nums.end());\n    return std::accumulate(minNum, 0, [](int sum, int digit) {\n        return sum + digit;\n    });\n}\n\nint main() {\n    std::vector<int> test1 = {38, 19, 96};\n    std::cout << \"Test Case 1: \" << minimumNumber(test1) << std::endl;\n\n    std::vector<int> test2 = {10, 2};\n    std::cout << \"Test Case 2: \" << minimumNumber(test2) << std::endl;\n\n    std::vector<int> test3 = {50, 85, 18, 42, 94};\n    std::cout << \"Test Case 3: \" << minimumNumber(test3) << std::endl;\n\n    return 0;\n}\n```",
  "1084": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int totalProfit(std::vector<std::vector<int>>& transactions) {\n        int total_profit = 0;\n        for (int i = 1; i < transactions.size(); ++i) {\n            if (transactions[i][0] > transactions[i - 1][0]) {\n                total_profit += transactions[i][1] - transactions[i - 1][1];\n            }\n        }\n        return total_profit;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> transactions1 = {{100, 20}, {150, 25}, {160, 26}};\n    int result1 = solution.totalProfit(transactions1);\n    if (result1 == 2) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 2, Actual: \" << result1 << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::vector<int>> transactions2 = {{100, 20}, {150, 25}};\n    int result2 = solution.totalProfit(transactions2);\n    if (result2 == 0) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 0, Actual: \" << result2 << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::vector<int>> transactions3 = {{100, 20}, {150, 25}, {160, 30}};\n    int result3 = solution.totalProfit(transactions3);\n    if (result3 == 4) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 4, Actual: \" << result3 << std::endl;\n    }\n\n    return 0;\n}",
  "1086": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int highFive(std::vector<std::vector<int>>& scores) {\n        std::map<int, int> studentScore;\n        for (const auto& score : scores) {\n            if (studentScore.count(score[0])) {\n                studentScore[score[0]] += score[1];\n            } else {\n                studentScore[score[0]] = score[1];\n            }\n        }\n        \n        int result = 0;\n        for (const auto& pair : studentScore) {\n            if (pair.second / scores.size() >= 5) {\n                result++;\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::vector<int>> scores1 = {{1, 91}, {1, 92}, {2, 93}, {2, 91}};\n    std::cout << \"Test Case 1: \" << solution.highFive(scores1) << std::endl; // Output: 1\n\n    std::vector<std::vector<int>> scores2 = {{3, 70}, {4, 66}, {5, 72}, {5, 68}, {5, 57}};\n    std::cout << \"Test Case 2: \" << solution.highFive(scores2) << std::endl; // Output: 3\n\n    std::vector<std::vector<int>> scores3 = {{1, 100}, {2, 100}, {3, 100}};\n    std::cout << \"Test Case 3: \" << solution.highFive(scores3) << std::endl; // Output: 3\n\n    return 0;\n}\n```",
  "1087": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> expand(const string& S) {\n        vector<string> result;\n        for (int i = 0; i < S.size(); i++) {\n            if (S[i] == '{') {\n                int start = i + 1, end = i + 1;\n                while (end < S.size() && S[end] != '}' || S[end] == '\\\\') {\n                    end++;\n                }\n                string item = S.substr(start, end - start);\n                if (item.length() > 0) {\n                    for (int j = 0; j < i; j++) {\n                        result.push_back(S.substr(0, j) + \"{\" + item + \"}\" + S.substr(j));\n                    }\n                    i = end;\n                }\n            } else {\n                i++;\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string input1 = \"{{a,b},c{d,e,f}}\";\n    vector<string> expected1 = {\"ac{d,e,f}\", \"ac{d,e}f\", \"bc{d,e,f}\", \"bc{d,e}f\"};\n    vector<string> result1 = solution.expand(input1);\n    for (int i = 0; i < result1.size(); i++) {\n        cout << result1[i] << endl;\n    }\n    cout << endl;\n\n    // Test case 2\n    string input2 = \"a{b,c}d\";\n    vector<string> expected2 = {\"ab_cd\", \"ac_cd\"};\n    vector<string> result2 = solution.expand(input2);\n    for (int i = 0; i < result2.size(); i++) {\n        cout << result2[i] << endl;\n    }\n    cout << endl;\n\n    // Test case 3\n    string input3 = \"{a,b,c}\";\n    vector<string> expected3 = {\"{a,b,c}\"};\n    vector<string> result3 = solution.expand(input3);\n    for (int i = 0; i < result3.size(); i++) {\n        cout << result3[i] << endl;\n    }\n    return 0;\n}\n```",
  "1088": "```\n#include <iostream>\n#include <vector>\n\nbool confusingNumberII(int N) {\n    std::vector<int> res = {0};\n    for (int i = 1; i <= N; i++) {\n        bool valid = false;\n        for (auto &num : res) {\n            if (isValid(num, i)) {\n                res.push_back(i);\n                valid = true;\n                break;\n            }\n        }\n        if (!valid) return false;\n    }\n    return true;\n}\n\nbool isValid(int a, int b) {\n    if (a == 0 && b != 0) return false;\n    if (a > 9 || b > 9) return false;\n    if ((a % 10 == 7 && a / 10 != 7) ||\n        (b % 10 == 7 && b / 10 != 7)) return false;\n    if ((a % 11 == 8 && a / 11 != 8) ||\n        (b % 11 == 8 && b / 11 != 8)) return false;\n    return true;\n}\n\nint main() {\n    std::cout << confusingNumberII(2) << std::endl; // Expected output: 1\n    std::cout << confusingNumberII(4) << std::endl; // Expected output: 0\n    std::cout << confusingNumberII(10000) << std::endl; // Expected output: 1\n    return 0;\n}",
  "1089": "```\n#include <iostream>\n#include <vector>\n\nvoid duplicateZeros(std::vector<int>& arr) {\n    int n = arr.size();\n    for (int i = 0; i < n - 1; i++) {\n        if (arr[i] == 0) {\n            for (int j = n - 1; j > i; j--) {\n                std::swap(arr[j], arr[j - 1]);\n            }\n            arr[i + 1]++;\n        }\n    }\n}\n\nint main() {\n    std::vector<int> arr1 = {1, 0, 2, 3, 0, 4, 5};\n    duplicateZeros(arr1);\n    for (auto x : arr1) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<int> arr2 = {1, 2, 3};\n    duplicateZeros(arr2);\n    for (auto x : arr2) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<int> arr3 = {0, 1};\n    duplicateZeros(arr3);\n    for (auto x : arr3) {\n        std::cout << x << \" \";\n    }\n    std::cout << \"\\n\";\n    return 0;\n}\n```",
  "1090": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> largestValues(vector<vector<int>>& grid) {\n        if (grid.empty()) return {};\n        \n        int m = grid.size(), n = grid[0].size();\n        vector<int> res(m);\n        \n        for (int i = 0; i < m; i++) {\n            int maxVal = INT_MIN;\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] > maxVal) maxVal = grid[i][j];\n            }\n            res[i] = maxVal;\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> grid1{{10}};\n    vector<int> result1 = solution.largestValues(grid1);\n    for (int val : result1) cout << val << \" \";\n    cout << endl;  // Output: 10\n\n    // Test case 2\n    vector<vector<int>> grid2{{3,4},{5,5}};\n    vector<int> result2 = solution.largestValues(grid2);\n    for (int val : result2) cout << val << \" \";\n    cout << endl;  // Output: 5\n\n    // Test case 3\n    vector<vector<int>> grid3{{1,3,5},{-2,5,9}};\n    vector<int> result3 = solution.largestValues(grid3);\n    for (int val : result3) cout << val << \" \";\n    cout << endl;  // Output: 9\n\n    return 0;\n}",
  "1091": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint shortestPathBinaryMatrix(vector<vector<int>>& grid) {\n    int rows = grid.size();\n    if (rows == 0) return -1;\n    int cols = grid[0].size();\n\n    vector<vector<int>> dist(rows, vector<int>(cols, INT_MAX));\n    queue<pair<int, int>, deque<pair<int, int>>> q;\n\n    if (grid[0][0] == 0) {\n        q.push({0, 0});\n        dist[0][0] = 1;\n    } else return -1;\n\n    while (!q.empty()) {\n        pair<int, int> cur = q.front();\n        q.pop();\n\n        for (int d[] : {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {\n            int r = cur.first + d[0];\n            int c = cur.second + d[1];\n\n            if (r >= 0 && r < rows && c >= 0 && c < cols && grid[r][c] == 0 && dist[r][c] > dist[cur.first][cur.second] + 1) {\n                q.push({r, c});\n                dist[r][c] = dist[cur.first][cur.second] + 1;\n            }\n        }\n    }\n\n    return dist[rows - 1][cols - 1];\n}\n\nint main() {\n    vector<vector<int>> grid1 = {{0, 1}, {1, 0}};\n    cout << shortestPathBinaryMatrix(grid1) << endl;\n\n    vector<vector<int>> grid2 = {{0, 0, 0}, {1, 1, 0}, {1, 1, 1}};\n    cout << shortestPathBinaryMatrix(grid2) << endl;\n\n    vector<vector<int>> grid3 = {{1, 1}, {0, 1}};\n    cout << shortestPathBinaryMatrix(grid3) << endl;\n}\n```",
  "1092": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string shortestCommonSupersequence(string str1, string str2) {\n        int m = str1.length();\n        int n = str2.length();\n\n        // Create a table to store lengths of LCS of subproblems\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0)\n                    dp[i][j] = j;\n                else if (j == 0)\n                    dp[i][j] = i;\n                else if (str1[i - 1] == str2[j - 1])\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                else\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n\n        // Reconstruct the SCSS from the table\n        string scss;\n        int i = m, j = n;\n        while (i > 0 && j > 0) {\n            if (str1[i - 1] == str2[j - 1]) {\n                scss += str1[i - 1];\n                i--;\n                j--;\n            } else if (dp[i - 1][j] < dp[i][j - 1])\n                scss += str1[i - 1], --i;\n            else\n                scss += str2[j - 1], --j;\n        }\n\n        // Add remaining characters to SCSS\n        while (i > 0) {\n            scss += str1[i - 1];\n            i--;\n        }\n        while (j > 0) {\n            scss += str2[j - 1];\n            j--;\n        }\n\n        return scss;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string str1 = \"abc\";\n    string str2 = \"def\";\n    cout << \"Shortest Common Supersequence of \" << str1 << \" and \" << str2 << \": \"\n         << solution.shortestCommonSupersequence(str1, str2) << endl;\n\n    // Test case 2\n    str1 = \"adbd\";\n    str2 = \"dbdad\";\n    cout << \"Shortest Common Supersequence of \" << str1 << \" and \" << str2 << \": \"\n         << solution.shortestCommonSupersequence(str1, str2) << endl;\n\n    // Test case 3\n    str1 = \"a\";\n    str2 = \"\";\n    cout << \"Shortest Common Supersequence of \" << str1 << \" and \" << str2 << \": \"\n         << solution.shortestCommonSupersequence(str1, str2) << endl;\n\n    return 0;\n}\n```",
  "1093": "```\n#include <iostream>\n#include <vector>\n\ndouble average(std::vector<int>& salary) {\n    double sum = 0.0;\n    for (int i : salary) {\n        sum += i;\n    }\n    return sum / static_cast<double>(salary.size());\n}\n\nint median(std::vector<int>& salary) {\n    std::sort(salary.begin(), salary.end());\n    int size = salary.size();\n    if (size % 2 == 0) {\n        return (salary[size / 2 - 1] + salary[size / 2]) / 2;\n    } else {\n        return salary[size / 2];\n    }\n}\n\ndouble variance(std::vector<int>& salary, double averageVal) {\n    double sum = 0.0;\n    for (int i : salary) {\n        sum += pow(i - averageVal, 2);\n    }\n    return sum / static_cast<double>(salary.size());\n}\n\nint main() {\n    std::vector<int> salary1 = {400000, 300000, 500000};\n    double avg1 = average(salary1);\n    int med1 = median(salary1);\n    double var1 = variance(salary1, avg1);\n\n    std::cout << \"Test case 1: Average - \" << avg1 << \", Median - \" << med1\n              << \", Variance - \" << var1 << std::endl;\n\n    std::vector<int> salary2 = {2000000, 1000000, 1500000};\n    double avg2 = average(salary2);\n    int med2 = median(salary2);\n    double var2 = variance(salary2, avg2);\n\n    std::cout << \"Test case 2: Average - \" << avg2 << \", Median - \" << med2\n              << \", Variance - \" << var2 << std::endl;\n\n    std::vector<int> salary3 = {700000, 800000, 600000};\n    double avg3 = average(salary3);\n    int med3 = median(salary3);\n    double var3 = variance(salary3, avg3);\n\n    std::cout << \"Test case 3: Average - \" << avg3 << \", Median - \" << med3\n              << \", Variance - \" << var3 << std::endl;\n\n    return 0;\n}\n```",
  "1094": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool carPooling(vector<vector<int>>& trips, int capacity) {\n        vector<pair<int, int>> stops;\n        for (const auto& trip : trips) {\n            int start = trip[1], end = trip[2];\n            if (start > end) swap(start, end);\n            for (int i = start; i <= end; ++i) {\n                bool exist = false;\n                for (auto& stop : stops) {\n                    if (stop.first == i) {\n                        exist = true;\n                        break;\n                    }\n                }\n                if (!exist) {\n                    stops.emplace_back(i, 1);\n                } else {\n                    for (auto& stop : stops) {\n                        if (stop.first == i) {\n                            stop.second++;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (const auto& stop : stops) {\n            capacity -= stop.second;\n            if (capacity < 0) return false;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> trips1 = {{2,1,5},{3,3,7}};\n    int capacity1 = 4;\n    cout << (solution.carPooling(trips1, capacity1) ? \"True\" : \"False\") << endl; // Expected: True\n\n    // Test case 2\n    vector<vector<int>> trips2 = {{2,1,5},{3,3,7}};\n    int capacity2 = 2;\n    cout << (solution.carPooling(trips2, capacity2) ? \"True\" : \"False\") << endl; // Expected: False\n\n    // Test case 3\n    vector<vector<int>> trips3 = {{4,1,5},{2,3,7}};\n    int capacity3 = 6;\n    cout << (solution.carPooling(trips3, capacity3) ? \"True\" : \"False\") << endl; // Expected: True\n\n    return 0;\n}\n```",
  "1095": "```\n#include <iostream>\n#include <vector>\n\nint searchRange(std::vector<int>& nums, int target) {\n    if (nums.empty()) return -1;\n    \n    int left = 0;\n    int right = nums.size() - 1;\n    \n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        \n        if (nums[mid] == target) {\n            // If the target is found, try to find the first occurrence\n            if (mid == 0 || nums[mid-1] < target) return mid;\n            \n            // Try to find the last occurrence\n            right = mid - 1;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    std::vector<int> nums1 = {2, 2};\n    int target1 = 2;\n    std::cout << \"Test case 1: \" << searchRange(nums1, target1) << std::endl;\n\n    std::vector<int> nums2 = [4,5,6,7,0,1,2,3];\n    int target2 = 0;\n    std::cout << \"Test case 2: \" << searchRange(nums2, target2) << std::endl;\n\n    std::vector<int> nums3 = {1};\n    int target3 = 0;\n    std::cout << \"Test case 3: \" << searchRange(nums3, target3) << std::endl;\n\n    return 0;\n}",
  "1096": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> expand(const string& S) {\n        vector<string> res;\n        int n = S.size();\n        for (int i = 0; i < n; ++i) {\n            if (S[i] == '{') {\n                int start = i + 1, end = i + 1;\n                while (end <= n && S[end] != '}') {\n                    if (S[end] == ',') {\n                        res.push_back(expandBetween(S, start, end));\n                        start = end + 1;\n                    }\n                    ++end;\n                }\n                if (start < end) {\n                    res.push_back(expandBetween(S, start, end - 1));\n                }\n            } else if (S[i] == '}') {\n                if (res.empty()) {\n                    res.push_back(S.substr(i));\n                }\n            }\n        }\n        return res;\n    }\n\n    string expandBetween(const string& S, int start, int end) {\n        string res = \"\";\n        for (int i = 0; i < n - 1; ++i) {\n            if (S[i] == '{') {\n                res += '{';\n                for (int j = 0; j < i; ++j) {\n                    res += S[j];\n                }\n            } else if (S[i] == '}') {\n                for (int j = i + 1; j <= end; ++j) {\n                    res += S[j];\n                }\n                res += '}';\n            } else if (S[i] != '{' && S[i] != '}') {\n                res += S[i];\n            }\n        }\n    }\n\n};\n\nint main() {\n    Solution solution;\n    vector<string> result1 = solution.expand(\"{a,b,c{d,e,f}}\");\n    for (const auto &str : result1) {\n        cout << str << endl;\n    }\n    \n    cout << \"------------\" << endl;\n\n    vector<string> result2 = solution.expand(\"{{a},{b},{c}{d,e,f}}\");\n    for (const auto &str : result2) {\n        cout << str << endl;\n    }\n    \n    cout << \"------------\" << endl;\n\n    vector<string> result3 = solution.expand(\"{a,b,c}\");\n    for (const auto &str : result3) {\n        cout << str << endl;\n    }\n\n    return 0;\n}\n```",
  "1097": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMinAverage(vector<vector<int>>& accounts) {\n        int n = accounts.size();\n        vector<long long> total(n, 0);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 1; j <= accounts[i].size(); ++j) {\n                total[i] += accounts[i][j - 1];\n            }\n        }\n        int minAverage = INT_MAX;\n        for (long long sum : total) {\n            minAverage = min(minAverage, (sum + total[0]) / (n + 1));\n        }\n        return minAverage;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> accounts1{{10,20,30,40},{1,2,3,4}};\n    cout << \"Test case 1: \" << solution.findMinAverage(accounts1) << endl;\n\n    // Test case 2\n    vector<vector<int>> accounts2{{5},{10,15,20},{25}};\n    cout << \"Test case 2: \" << solution.findMinAverage(accounts2) << endl;\n\n    // Test case 3\n    vector<vector<int>> accounts3{{1,4,5},{7,8},{3}};\n    cout << \"Test case 3: \" << solution.findMinAverage(accounts3) << endl;\n\n    return 0;\n}\n```",
  "1099": "```\n#include <iostream>\n#include <vector>\n\nint twoSumLessThanEqual(std::vector<int>& nums, int k) {\n    int max_sum = -1;\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[i] + nums[j] < k && nums[i] + nums[j] > max_sum) {\n                max_sum = nums[i] + nums[j];\n            }\n        }\n    }\n    return max_sum;\n}\n\nint main() {\n    std::vector<int> nums1 = {10, 2, 7, 5};\n    int k1 = 15;\n    std::cout << \"Test Case 1: \" << twoSumLessThanEqual(nums1, k1) << std::endl;\n\n    std::vector<int> nums2 = {1, 2, 3, 4};\n    int k2 = 5;\n    std::cout << \"Test Case 2: \" << twoSumLessThanEqual(nums2, k2) << std::endl;\n\n    std::vector<int> nums3 = {50, 40, 30];\n    int k3 = 70;\n    std::cout << \"Test Case 3: \" << twoSumLessThanEqual(nums3, k3) << std::endl;\n\n    return 0;\n}\n```",
  "1098": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Book {\npublic:\n    string title;\n    int borrowCount;\n};\n\nbool compareBooks(const Book& book1, const Book& book2) {\n    return book1.borrowCount > book2.borrowCount;\n}\n\nvoid findUnpopularBooks(vector<Book>& books) {\n    sort(books.begin(), books.end(), compareBooks);\n    \n    for (int i = 0; i < 3 && i < books.size(); i++) {\n        cout << \"Title: \" << books[i].title << \", Borrow Count: \" << books[i].borrowCount << endl;\n    }\n}\n\nint main() {\n    vector<Book> books = {{\"Book1\", 10}, {\"Book2\", 5}, {\"Book3\", 7}, {\"Book4\", 15}, {\"Book5\", 12}};\n    \n    findUnpopularBooks(books);\n    \n    cout << endl;\n    \n    books = {{\"Book1\", 8}, {\"Book2\", 10}, {\"Book3\", 9}, {\"Book4\", 11}, {\"Book5\", 14}};\n    \n    findUnpopularBooks(books);\n    \n    cout << endl;\n    \n    books = {{\"Book1\", 15}, {\"Book2\", 12}, {\"Book3\", 10}, {\"Book4\", 7}, {\"Book5\", 5}};\n    \n    findUnpopularBooks(books);\n    \n    return 0;\n}\n```",
  "1100": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findSubstrings(string s, int k) {\n        vector<string> result;\n        for (int i = 0; i <= s.length() - k; i++) {\n            string sub = s.substr(i, k);\n            if (isUnique(sub)) {\n                result.push_back(sub);\n            }\n        }\n        return result;\n    }\n\n    bool isUnique(string s) {\n        unordered_map<char, int> charCount;\n        for (char c : s) {\n            charCount[c]++;\n            if (charCount[c] > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> test1 = solution.findSubstrings(\"aaabaabba\", 3);\n    for (string s : test1) {\n        cout << s << endl;\n    }\n\n    vector<string> test2 = solution.findSubstrings(\"abcdabc\", 4);\n    for (string s : test2) {\n        cout << s << endl;\n    }\n\n    vector<string> test3 = solution.findSubstrings(\"aaaaa\", 5);\n    for (string s : test3) {\n        cout << s << endl;\n    }\n\n    return 0;\n}\n```",
  "1101": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int earliestAcq(vector<int>& logs, int n) {\n        vector<pair<int, int>> events;\n        for (int i = 0; i < logs.size(); ++i) {\n            if (logs[i] == 1) {\n                events.push_back({-i, -1});\n            } else {\n                events.push_back({-i, 1});\n            }\n        }\n        sort(events.begin(), events.end());\n        int last = -1;\n        int friendCount = 0;\n        for (const auto& e : events) {\n            if (e.second == -1) {\n                friendCount++;\n            } else {\n                friendCount--;\n            }\n            if (friendCount > 0 && e.first < last) {\n                last = e.first;\n            }\n        }\n        return last;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> logs1 = {20190101, 20190104, 20190224, 20190309};\n    cout << \"Test case 1: \" << solution.earliestAcq(logs1, 5) << endl; // Output: 20190224\n\n    // Test case 2\n    vector<int> logs2 = {20170312, 20170428, 20170617, 20170713};\n    cout << \"Test case 2: \" << solution.earliestAcq(logs2, 4) << endl; // Output: 20170428\n\n    // Test case 3\n    vector<int> logs3 = {1, 4, 10, 20};\n    cout << \"Test case 3: \" << solution.earliestAcq(logs3, 5) << endl; // Output: 4\n\n    return 0;\n}\n```",
  "1102": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> maxMIN(vector<vector<int>>& grid) {\n        int m = grid.size();\n        if (m == 0) return {};\n\n        int n = grid[0].size();\n        if (n == 0) return {};\n\n        vector<vector<int>> dp(m, vector<int>(n));\n        dp[0][0] = grid[0][0];\n\n        for (int i = 1; i < m; ++i) {\n            dp[i][0] = min(dp[i-1][0], grid[i][0]);\n        }\n\n        for (int j = 1; j < n; ++j) {\n            dp[0][j] = min(dp[0][j-1], grid[0][j]);\n        }\n\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                if (grid[i][j] > dp[i-1][j]) {\n                    dp[i][j] = grid[i][j];\n                } else {\n                    int up = dp[i-1][j], left = dp[i][j-1];\n                    if (up <= left) {\n                        dp[i][j] = up;\n                    } else {\n                        dp[i][j] = left;\n                    }\n                }\n            }\n        }\n\n        vector<int> res;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == dp[m-1][n-1]) res.push_back(i*n + j);\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> grid1 = {{2,1,3},{5,9,10},{4,6,7}};\n    vector<int> expected1 = {0,1};\n    assert(solution.maxMIN(grid1) == expected1);\n\n    // Test case 2\n    vector<vector<int>> grid2 = {{1,2,3},{4,5,6}};\n    vector<int> expected2 = {};\n    assert(solution.maxMIN(grid2) == expected2);\n\n    // Test case 3\n    vector<vector<int>> grid3 = {{3,1},{1,2}};\n    vector<int> expected3 = {0};\n    assert(solution.maxMIN(grid3) == expected3);\n\n    return 0;\n}\n```",
  "1103": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int distributeCandies(std::vector<int>& ratings) {\n        int total = 0;\n        for (int rating : ratings) {\n            total += rating;\n        }\n        return total / ratings.size();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> ratings1 = {2,2,1};\n    int result1 = solution.distributeCandies(ratings1);\n    if (result1 != 1) {\n        std::cout << \"Test case 1 failed: expected \" << 1 << \", but got \" << result1 << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    std::vector<int> ratings2 = {1,3,2,2,5};\n    int result2 = solution.distributeCandies(ratings2);\n    if (result2 != 3) {\n        std::cout << \"Test case 2 failed: expected \" << 3 << \", but got \" << result2 << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    std::vector<int> ratings3 = {4,3};\n    int result3 = solution.distributeCandies(ratings3);\n    if (result3 != 3) {\n        std::cout << \"Test case 3 failed: expected \" << 3 << \", but got \" << result3 << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed.\" << std::endl;\n    return 0;\n}\n```",
  "1105": "```\n#include <iostream>\n#include <vector>\n\nint minHeightShelves(std::vector<std::vector<int>>& bookshelf) {\n    int n = bookshelf.size();\n    std::vector<int> dp(n + 1, 10000);\n    dp[0] = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int height = 0, weight = 0;\n        for (int j = i; j >= 0 && weight + bookshelf[j][1] <= bookshelf[i][1]; --j) {\n            height += bookshelf[j][0];\n            weight += bookshelf[j][1];\n            if (i == j) break;\n\n            dp[i + 1] = std::min(dp[i + 1], height > dp[j + 1] ? height : dp[j + 1]);\n        }\n    }\n\n    return dp[n - 1];\n}\n\nint main() {\n    std::vector<std::vector<int>> bookshelf1 = {{5,10},{1,2}};\n    std::cout << \"Test Case 1: \" << minHeightShelves(bookshelf1) << std::endl;\n\n    std::vector<std::vector<int>> bookshelf2 = {{5,5},{3,7},{2,4},{2,3}};\n    std::cout << \"Test Case 2: \" << minHeightShelves(bookshelf2) << std::endl;\n\n    std::vector<std::vector<int>> bookshelf3 = {{10,1000},{9,9000}};\n    std::cout << \"Test Case 3: \" << minHeightShelves(bookshelf3) << std::endl;\n}\n```",
  "1104": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    vector<int> pathInZigzagLabelledBinaryTree(TreeNode* tree, int label) {\n        vector<int> res;\n        int depth = 1;\n        bool isLeft = true;\n        TreeNode* node = tree;\n        \n        while (node != nullptr) {\n            if ((isLeft && node->val == label) || (!isLeft && node->val == label)) {\n                for (int i = 0; i < res.size(); i++) {\n                    cout << res[i] << \" \";\n                }\n                cout << endl;\n                return res;\n            }\n            \n            if (isLeft) {\n                if (node->right != nullptr) {\n                    node = node->right;\n                } else {\n                    for (int i = 0; i < depth - 1; i++) {\n                        if (i % 2 == 0) {\n                            node = node->left;\n                        } else {\n                            node = node->right;\n                        }\n                    }\n                    break;\n                }\n            } else {\n                if (node->left != nullptr) {\n                    node = node->left;\n                } else {\n                    for (int i = 0; i < depth - 1; i++) {\n                        if (i % 2 == 0) {\n                            node = node->right;\n                        } else {\n                            node = node->left;\n                        }\n                    }\n                    break;\n                }\n            }\n            \n            res.push_back(node->val);\n            isLeft = !isLeft;\n            node = (!isLeft && node->left != nullptr) ? node->left : (isLeft && node->right != nullptr) ? node->right : nullptr;\n            depth++;\n        }\n        \n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* tree1 = new TreeNode(1);\n    tree1->left = new TreeNode(3);\n    tree1->right = new TreeNode(2);\n    \n    cout << \"Test case 1: \";\n    vector<int> result1 = solution.pathInZigzagLabelledBinaryTree(tree1, 1);\n    for (int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    TreeNode* tree2 = new TreeNode(1);\n    tree2->left = new TreeNode(2);\n    \n    cout << \"Test case 2: \";\n    vector<int> result2 = solution.pathInZigzagLabelledBinaryTree(tree2, 1);\n    for (int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    TreeNode* tree3 = new TreeNode(1);\n    tree3->left = new TreeNode(2);\n    tree3->right = new TreeNode(3);\n\n    cout << \"Test case 3: \";\n    vector<int> result3 = solution.pathInZigzagLabelledBinaryTree(tree3, 1);\n    for (int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1106": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nusing namespace std;\n\nbool evaluate(string expression) {\n    stack<char> operators;\n    for (int i = 0; i < expression.length(); i++) {\n        char c = expression[i];\n        if (c == '(') {\n            operators.push(c);\n        } else if (c == ')') {\n            while (operators.top() != '(') {\n                operators.pop();\n            }\n            operators.pop();\n        } else if (c == 'T' || c == 'F') {\n            return c == 'T';\n        } else if (c == '|') {\n            while (!operators.empty() && operators.top() != '(') {\n                operators.pop();\n            }\n        } else if (c == '&') {\n            while (!operators.empty() && operators.top() != '(') {\n                operators.pop();\n            }\n        } else if (c == '!') {\n            operators.push(c);\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    cout << boolalpha << evaluate(\"T|F&!T\") << endl; // True\n    cout << boolalpha << evaluate(\"(T|F)&!(T&T)\") << endl; // False\n    cout << boolalpha << evaluate(\"((T)|F)&(T|T)!T\") << endl; // True\n\n    return 0;\n}\n```",
  "1108": "```\n#include <iostream>\n#include <string>\n\nstd::string defangIPaddr(std::string address) {\n    for (int i = 0; i < address.length(); i++) {\n        if (address[i] == '.') {\n            address.replace(i, 1, \"[.]\");\n            i++;\n        }\n    }\n    return address;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << defangIPaddr(\"1.1.1.1\") << std::endl;\n    std::cout << \"Expected Output: 1[.]1[.]1[.]1\" << std::endl;\n\n    std::cout << \"\\n\";\n    std::cout << \"Test Case 2: \" << defangIPaddr(\"255.100.500.0\") << std::endl;\n    std::cout << \"Expected Output: 255[.]100[.]500[.]0\" << std::endl;\n\n    std::cout << \"\\n\";\n    std::cout << \"Test Case 3: \" << defangIPaddr(\"192.168.1.1\") << std::endl;\n    std::cout << \"Expected Output: 192[.]168[.]1[.]1\" << std::endl;\n\n    return 0;\n}\n```",
  "1107": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> dailyUsers(vector<vector<string>>& logs) {\n        unordered_map<string, int> users;\n        for (const auto& log : logs) {\n            users[log[0]]++;\n        }\n        vector<int> result;\n        for (int i = 1; ; ++i) {\n            string dateStr = to_string(i);\n            if (users.count(dateStr)) {\n                result.push_back(users[dateStr]);\n            } else {\n                break;\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<string>> logs1 = {{ \"Jake\", \"2019-06-30\" }, { \"Steve\", \"2019-07-01\" }, \n                                    { \"Steve\", \"2019-07-02\" }, { \"Jake\", \"2019-07-04\" }};\n    vector<int> result1 = solution.dailyUsers(logs1);\n    for (int i : result1) {\n        cout << i << endl;\n    }\n    \n    vector<vector<string>> logs2 = {{ \"Jesse\", \"2020-01-01\" }, { \"Kathy\", \"2020-01-02\" }, \n                                    { \"Jake\", \"2020-01-03\" }, { \"Steve\", \"2020-01-04\" }};\n    vector<int> result2 = solution.dailyUsers(logs2);\n    for (int i : result2) {\n        cout << i << endl;\n    }\n    \n    vector<vector<string>> logs3 = {{ \"Alice\", \"2019-06-30\" }, { \"Bob\", \"2019-07-01\" }, \n                                    { \"Charlie\", \"2019-07-02\" }, { \"Alice\", \"2019-07-03\" }};\n    vector<int> result3 = solution.dailyUsers(logs3);\n    for (int i : result3) {\n        cout << i << endl;\n    }\n    \n    return 0;\n}\n```",
  "1109": "```\n#include <iostream>\n#include <vector>\n\nint maxBookings(std::vector<int>& bookings) {\n    int n = bookings.size();\n    std::vector<int> res(n, 0);\n    \n    for (int i = 0; i < n; i++) {\n        res[i] += bookings[i];\n    }\n    \n    for (int i = 1; i < n; i++) {\n        res[i] += res[i - 1];\n    }\n    \n    int maxBooked = 0;\n    for (int i = 0; i < n; i++) {\n        maxBooked = std::max(maxBooked, res[n - 1] - res[i]);\n    }\n    \n    return maxBooked;\n}\n\nint main() {\n    std::vector<int> bookings1 = {10,20};\n    std::cout << \"Test case 1: \" << maxBookings(bookings1) << std::endl;\n\n    std::vector<int> bookings2 = {90,10,10,1000,5,5,5};\n    std::cout << \"Test case 2: \" << maxBookings(bookings2) << std::endl;\n\n    std::vector<int> bookings3 = {1,2,3};\n    std::cout << \"Test case 3: \" << maxBookings(bookings3) << std::endl;\n    \n    return 0;\n}\n```",
  "1111": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint maxDepth(string s1, string s2) {\n    int depth = 0;\n    for (int i = 0; i < min(s1.length(), s2.length()); i++) {\n        if (s1[i] == '(' && s2[i] == ')') {\n            depth++;\n        }\n    }\n    return depth;\n}\n\nint main() {\n    cout << maxDepth(\"((()))\", \"(()())\") << endl; // Output: 3\n    cout << maxDepth(\"(())\", \"()()\") << endl; // Output: 1\n    cout << maxDepth(\"(\", \"()\") << endl; // Output: 0\n    return 0;\n}\n```",
  "1110": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<TreeNode*> deleteNodes(TreeNode* root, int m, int n) {\n        if (root == NULL) return {};\n        if (m > 0 && root->val % 2 != 0) {\n            root->left = deleteNodes(root->left, m - 1, n);\n            root->right = deleteNodes(root->right, m, n - 1);\n        } else {\n            if (root->left == NULL && root->right == NULL)\n                return {};\n            else if (root->left != NULL) {\n                root->left = deleteNodes(root->left, m, n - 1);\n            } else if (root->right != NULL) {\n                root->right = deleteNodes(root->right, m - 1, n);\n            }\n        }\n        return {root};\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(8);\n    root1->left->left = new TreeNode(7);\n    root1->left->right = new TreeNode(4);\n    root1->right->left = new TreeNode(9);\n    root1->right->right = new TreeNode(6);\n\n    vector<TreeNode*> result1 = solution.deleteNodes(root1, 2, 0);\n    for (TreeNode* node : result1) {\n        if (node != NULL) {\n            cout << node->val << \" \";\n        }\n    }\n    cout << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(5);\n    root2->left->left = new TreeNode(1);\n    root2->left->right = new TreeNode(4);\n\n    vector<TreeNode*> result2 = solution.deleteNodes(root2, 0, 1);\n    for (TreeNode* node : result2) {\n        if (node != NULL) {\n            cout << node->val << \" \";\n        }\n    }\n    cout << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(4);\n\n    vector<TreeNode*> result3 = solution.deleteNodes(root3, 1, 0);\n    for (TreeNode* node : result3) {\n        if (node != NULL) {\n            cout << node->val << \" \";\n        }\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1112": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> highestGradeForEachStudent(vector<vector<string>>& grades) {\n        map<string, string> studentGrades;\n        for (const auto& row : grades) {\n            string student = row[0];\n            string grade = row[1];\n            if (studentGrades.find(student) == studentGrades.end()) {\n                studentGrades[student] = grade;\n            } else {\n                studentGrades[student] = max(studentGrades[student], grade);\n            }\n        }\n        vector<string> result;\n        for (const auto& pair : studentGrades) {\n            result.push_back(pair.first + \" - \" + pair.second);\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> grades1 = {{\"Alice\", \"A\"}, {\"Bob\", \"B\"}, {\"Alice\", \"C\"}};\n    vector<string> expected1 = {\"Alice - C\", \"Bob - B\"};\n    assert(equal(solution.highestGradeForEachStudent(grades1).begin(), solution.highestGradeForEachStudent(grades1).end(), expected1.begin(), expected1.end()));\n\n    // Test Case 2\n    vector<vector<string>> grades2 = {{\"Charlie\", \"A\"}, {\"David\", \"B\"}, {\"Charlie\", \"C\"}};\n    vector<string> expected2 = {\"Charlie - C\", \"David - B\"};\n    assert(equal(solution.highestGradeForEachStudent(grades2).begin(), solution.highestGradeForEachStudent(grades2).end(), expected2.begin(), expected2.end()));\n\n    // Test Case 3\n    vector<vector<string>> grades3 = {{\"Eve\", \"A\"}, {\"Alice\", \"B\"}};\n    vector<string> expected3 = {\"Alice - B\", \"Eve - A\"};\n    assert(equal(solution.highestGradeForEachStudent(grades3).begin(), solution.highestGradeForEachStudent(grades3).end(), expected3.begin(), expected3.end()));\n\n    return 0;\n}\n```",
  "1113": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int mostReportedPosts(std::vector<std::vector<int>>& accounts, std::vector<std::string>& posts) {\n        int maxReports = 0;\n        std::string mostReportedPost = \"\";\n        \n        for (int i = 0; i < posts.size(); i++) {\n            int reports = 0;\n            for (const auto& account : accounts) {\n                if (std::find(account.begin(), account.end(), posts[i]) != account.end()) {\n                    reports++;\n                }\n            }\n            if (reports > maxReports) {\n                maxReports = reports;\n                mostReportedPost = posts[i];\n            }\n        }\n        \n        return maxReports;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> accounts1 = {{1, 2}, {2, 3}};\n    std::vector<std::string> posts1 = {\"A\", \"B\", \"C\"};\n    int maxReports1 = solution.mostReportedPosts(accounts1, posts1);\n    if (maxReports1 == 2) {\n        std::cout << \"Test case 1 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::vector<int>> accounts2 = {{1, 3}, {2}};\n    std::vector<std::string> posts2 = {\"A\", \"B\", \"C\", \"D\"};\n    int maxReports2 = solution.mostReportedPosts(accounts2, posts2);\n    if (maxReports2 == 2) {\n        std::cout << \"Test case 2 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::vector<int>> accounts3 = {{1, 2}, {2}};\n    std::vector<std::string> posts3 = {\"A\", \"B\"};\n    int maxReports3 = solution.mostReportedPosts(accounts3, posts3);\n    if (maxReports3 == 2) {\n        std::cout << \"Test case 3 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1114": "```\n#include <iostream>\n#include <vector>\n#include <thread>\n\nclass Foo {\npublic:\n    void first(int n) {\n        for (int i = 0; i < n; ++i) {\n            std::cout << \"First:\" << i << \"\\n\";\n        }\n    }\n\n    void fast(int n) {\n        for (int i = 0; i < n; ++i) {\n            std::cout << \"Fast: \" << i << \"\\n\";\n        }\n    }\n\n    void last(int n) {\n        for (int i = 0; i < n; ++i) {\n            std::cout << \"Last: \" << i << \"\\n\";\n        }\n    }\n};\n\nint main() {\n    Foo foo;\n    \n    // Test case 1\n    std::thread t1(&Foo::first, &foo, 3);\n    std::thread t2(&Foo::fast, &foo, 3);\n    t1.join();\n    t2.join();\n\n    // Test case 2\n    std::thread t3(&Foo::last, &foo, 2);\n    std::thread t4(&Foo::first, &foo, 2);\n    std::thread t5(&Foo::fast, &foo, 2);\n    t3.join();\n    t4.join();\n    t5.join();\n\n    // Test case 3\n    std::thread t6(&Foo::last, &foo, 1);\n    std::thread t7(&Foo::first, &foo, 1);\n    std::thread t8(&Foo::fast, &foo, 1);\n    t6.join();\n    t7.join();\n    t8.join();\n\n    return 0;\n}\n```",
  "1115": "```\n#include <iostream>\n#include <thread>\n\nvoid foo(int n) {\n    for (int i = 0; i < n; ++i) {\n        std::cout << \"foo\" << std::endl;\n    }\n}\n\nvoid bar(int n) {\n    for (int i = 0; i < n; ++i) {\n        std::cout << \"bar\" << std::endl;\n    }\n}\n\nint main() {\n    // Test case 1: Print foo and bar 3 times each\n    thread t1(foo, 3);\n    thread t2(bar, 3);\n    t1.join();\n    t2.join();\n\n    // Test case 2: Print foo 4 times and bar 5 times\n    thread t3(foo, 4);\n    thread t4(bar, 5);\n    t3.join();\n    t4.join();\n\n    // Test case 3: Print foo and bar 1 time each\n    thread t5(foo, 1);\n    thread t6(bar, 1);\n    t5.join();\n    t6.join();\n\n    return 0;\n}\n```",
  "1116": "```\n#include <iostream>\n#include <vector>\n\nvoid zeroEvenOdd(std::vector<int>& nums) {\n    int i = 0;\n    for (int num : nums) {\n        if (num % 2 == 0) {\n            for (; i < nums.size() && nums[i] % 2 != 0; i++);\n            std::cout << num << \" \";\n        } else {\n            while (i < nums.size() && nums[i] % 2 != 1) i++;\n            std::cout << num << \" \";\n        }\n    }\n    std::cout << \"\\n\";\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {4, 2, 0, 3, 1};\n    zeroEvenOdd(test1);\n    \n    // Test case 2\n    std::vector<int> test2 = {2, 4, 6};\n    zeroEvenOdd(test2);\n    \n    // Test case 3\n    std::vector<int> test3 = {1, 3, 5};\n    zeroEvenOdd(test3);\n    \n    return 0;\n}\n```",
  "1117": "```\n#include <iostream>\n#include <thread>\n#include <vector>\n\nclass H2O {\npublic:\n    void hydrogen(std::function<void()> f) { for (int i = 0; i < 2; ++i) f(); }\n    void oxygen(std::function<void()> f) { for (int i = 0; i < 4; ++i) f(); }\n};\n\nvoid printHydrogen() {\n    std::cout << \"H\";\n}\n\nvoid printOxygen() {\n    std::cout << \"O2\" << std::endl;\n}\n\nint main() {\n    H2O h2o;\n\n    // Test case 1\n    std::thread t1([&h2o] {\n        h2o.hydrogen(printHydrogen);\n    });\n    t1.join();\n\n    // Test case 2\n    h2o.oxygen([]{\n        printOxygen();\n    });\n\n    // Test case 3\n    std::thread t2([&h2o] {\n        h2o.hydrogen([this] {\n            this->printHydrogen();\n        });\n        h2o.oxygen([] {\n            printOxygen();\n        });\n    });\n    t2.join();\n\n    return 0;\n}\n```",
  "1118": "```\n#include <iostream>\n#include <vector>\n\nint dayOfYear(int year, int month) {\n    if (month < 1 || month > 12) return -1;\n    if (month == 2 && ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)) return 29;\n    else if (month in {1,3,5,7,8,10,12}) return 31;\n    else return 30;\n}\n\nint main() {\n    std::vector<std::pair<int,int>> testCases = {{2022, 6}, {2000, 2}, {1999, 11}};\n    \n    for (const auto& testCase : testCases) {\n        int year = testCase.first;\n        int month = testCase.second;\n        int result = dayOfYear(year, month);\n        \n        if (result == -1) std::cout << \"Invalid month. Year: \" << year << \", Month: \" << month << std::endl;\n        else std::cout << \"Number of days in month for year \" << year << \" and month \" << month << \": \" << result << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "1119": "```\n#include <iostream>\n#include <string>\n\nstd::string removeVowels(std::string s) {\n    for (int i = 0; i < s.length(); i++) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u' ||\n            s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            s.erase(i, 1);\n            i--;\n        }\n    }\n    return s;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << removeVowels(\"hello\") << std::endl;\n    std::cout << \"Test case 2: \" << removeVowels(\"aIeou\") << std::endl;\n    std::cout << \"Test case 3: \" << removeVowels(\"bcd\") << std::endl;\n    return 0;\n}\n```",
  "1121": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minElements(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n, 1);\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        int res = 0;\n        for (int x : dp) {\n            res = max(res, x);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> nums1 = {2, 5, 3};\n    cout << \"Test case 1: \" << solution.minElements(nums1) << endl; // Output: 2\n\n    vector<int> nums2 = {4, 3, 1, 2};\n    cout << \"Test case 2: \" << solution.minElements(nums2) << endl; // Output: 4\n\n    vector<int> nums3 = {1, 5, 2, 4, 3, 6};\n    cout << \"Test case 3: \" << solution.minElements(nums3) << endl; // Output: 7\n    return 0;\n}\n```",
  "1120": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    double maximumAverage(TreeNode* root) {\n        if (!root) return 0.0;\n        double sum = dfs(root);\n        return sum / (count(root));\n    }\n\n    int count(TreeNode *node) {\n        if (!node) return 0;\n        return 1 + count(node->left) + count(node->right);\n    }\n\n    double dfs(TreeNode* node) {\n        if (!node) return 0.0;\n        return (double)(node->val) + dfs(node->left) + dfs(node->right);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode *root1 = new TreeNode(4);\n    root1->left = new TreeNode(8);\n    root1->right = new TreeNode(5);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(7);\n    root1->right->left = new TreeNode(3);\n    cout << \"Test case 1: \" << solution.maximumAverage(root1) << endl;\n\n    // Test case 2\n    TreeNode *root2 = new TreeNode(-6);\n    root2->left = new TreeNode(-5);\n    root2->right = new TreeNode(4);\n    root2->left->left = new TreeNode(-3);\n    root2->left->right = new TreeNode(-4);\n    cout << \"Test case 2: \" << solution.maximumAverage(root2) << endl;\n\n    // Test case 3\n    TreeNode *root3 = new TreeNode(0);\n    cout << \"Test case 3: \" << solution.maximumAverage(root3) << endl;\n\n    return 0;\n}\n```",
  "1122": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\n\nstd::vector<int> relativeSortArray(std::vector<int>& arr) {\n    std::unordered_map<int, int> count;\n    for (int num : arr) {\n        count[num]++;\n    }\n    \n    std::vector<int> result;\n    for (int i = 0; i < 1001; i++) {\n        while (count[i]--) {\n            result.push_back(i);\n        }\n    }\n    \n    sort(result.begin(), result.end());\n    \n    return result;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> arr1 = {2,3,1,3,3,2};\n    std::vector<int> expected1 = {1,2,2,3,3,3};\n    for (int i : relativeSortArray(arr1)) {\n        std::cout << i << \" \";\n    }\n    std::cout << \"\\n\";\n    \n    // Test case 2\n    std::vector<int> arr2 = [4,5,8,6];\n    std::vector<int> expected2 = [3,4,5,6];\n    for (int i : relativeSortArray(arr2)) {\n        std::cout << i << \" \";\n    }\n    std::cout << \"\\n\";\n    \n    // Test case 3\n    std::vector<int> arr3 = [0,1];\n    std::vector<int> expected3 = [0,1];\n    for (int i : relativeSortArray(arr3)) {\n        std::cout << i << \" \";\n    }\n    std::cout << \"\\n\";\n    \n    return 0;\n}\n```",
  "1124": "```\n#include <iostream>\n#include <vector>\n\nint longestWPI(std::vector<int>& pins) {\n    int n = pins.size();\n    for (int i = 0; i < n; ++i)\n        pins[i] *= 2;\n\n    std::vector<int> prefixSum(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        prefixSum[i + 1] = prefixSum[i] + pins[i];\n    }\n\n    int wpi = -1;\n    for (int i = 0; i < n; ++i) {\n        if (prefixSum[i] > prefixSum[0]) {\n            wpi = i;\n            break;\n        }\n    }\n\n    return wpi;\n}\n\nint main() {\n    std::vector<int> pins1 = {2, 1, 3};\n    std::cout << longestWPI(pins1) << std::endl; // Output: 4\n\n    std::vector<int> pins2 = {1, 5, 7, 5};\n    std::cout << longestWPI(pins2) << std::endl; // Output: 3\n\n    std::vector<int> pins3 = {0, 10, 6, 0};\n    std::cout << longestWPI(pins3) << std::endl; // Output: 4\n\n    return 0;\n}\n```",
  "1123": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n    if (!root || root == p || root == q)\n        return root;\n\n    TreeNode* left = lowestCommonAncestor(root->left, p, q);\n    TreeNode* right = lowestCommonAncestor(root->right, p, q);\n\n    if (left && right)\n        return root;\n    else\n        return left ? left : right;\n}\n\nint main() {\n    // Test case 1\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(5);\n    root1->right = new TreeNode(1);\n    root1->left->left = new TreeNode(6);\n    root1->left->right = new TreeNode(2);\n    root1->right->left = new TreeNode(0);\n    root1->right->right = new TreeNode(8);\n    root1->left->left->left = new TreeNode(7);\n    root1->left->left->right = new TreeNode(4);\n\n    TreeNode* p1 = new TreeNode(5);\n    TreeNode* q1 = new TreeNode(1);\n\n    std::cout << \"Test case 1: The lowest common ancestor of the deepest leaves is \";\n    std::cout << lowestCommonAncestor(root1, p1, q1)->val;\n    std::cout << std::endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(4);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(7);\n    root2->left->left = new TreeNode(5);\n    root2->left->right = new TreeNode(6);\n\n    TreeNode* p2 = new TreeNode(1);\n    TreeNode* q2 = new TreeNode(8);\n\n    std::cout << \"Test case 2: The lowest common ancestor of the deepest leaves is \";\n    std::cout << lowestCommonAncestor(root2, p2, q2)->val;\n    std::cout << std::endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(4);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(7);\n\n    TreeNode* p3 = new TreeNode(1);\n    TreeNode* q3 = new TreeNode(5);\n\n    std::cout << \"Test case 3: The lowest common ancestor of the deepest leaves is \";\n    std::cout << lowestCommonAncestor(root3, p3, q3)->val;\n    std::cout << std::endl;\n\n    return 0;\n}",
  "1125": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> smallestSufficient(vector<vector<string>>& requests) {\n        int n = requests.size();\n        vector<bool> dp(1 << n);\n        vector<string> res;\n        for (int i = 0; i < n; ++i) {\n            int mask = 1 << i;\n            for (int j = 0; j < n; ++j) {\n                if (((mask & requests[j][0]) && !dp[requests[j][0]])) dp[mask | requests[j][0]] = true;\n            }\n        }\n        for (int i = 0; i < (1 << n); ++i) {\n            if (!dp[i]) break;\n        }\n        int cur = i - 1;\n        while (cur > 0) {\n            for (int j = 0; j < n; ++j) {\n                if (((cur & requests[j][0]) && !dp[requests[j][0]])) {\n                    res.push_back(requests[j][1]);\n                    cur ^= requests[j][0];\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> requests1 = {{5, \"cat\"}, {6, \"dog\"}, {8, \"bird\"}};\n    vector<string> result1 = solution.smallestSufficient(requests1);\n    cout << \"Test case 1: \";\n    for (const string& str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<vector<string>> requests2 = {{1, \"x\"}, {3, \"y\"}};\n    vector<string> result2 = solution.smallestSufficient(requests2);\n    cout << \"Test case 2: \";\n    for (const string& str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<vector<string>> requests3 = {{7, \"f\"}, {5, \"c\"}, {6, \"b\"}, {9, \"a\"}};\n    vector<string> result3 = solution.smallestSufficient(requests3);\n    cout << \"Test case 3: \";\n    for (const string& str : result3) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1126": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> activeBusinesses(vector<vector<string>>& log) {\n        map<string, int> businessCounts;\n        \n        for (const auto& entry : log) {\n            string business = entry[1];\n            if (businessCounts.find(business) == businessCounts.end()) {\n                businessCounts[business] = 0;\n            }\n            businessCounts[business]++;\n        }\n        \n        vector<string> activeBusinesses;\n        for (const auto& pair : businessCounts) {\n            if (pair.second > 1) {\n                activeBusinesses.push_back(pair.first);\n            }\n        }\n        \n        return activeBusinesses;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> log1 = {{\"2020-06-30 14:00\", \"Amazon\"}, {\"2020-07-01 10:00\", \"Google\"}};\n    vector<string> result1 = solution.activeBusinesses(log1);\n    cout << \"Test case 1: \";\n    for (const auto& business : result1) {\n        cout << business << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<vector<string>> log2 = {{\"2020-07-01 10:00\", \"Amazon\"}, {\"2020-08-01 14:00\", \"Apple\"}};\n    vector<string> result2 = solution.activeBusinesses(log2);\n    cout << \"Test case 2: \";\n    for (const auto& business : result2) {\n        cout << business << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<vector<string>> log3 = {{\"2020-06-30 14:00\", \"Amazon\"}, {\"2020-07-01 10:00\", \"Google\"}, {\"2020-08-01 14:00\", \"Apple\"}};\n    vector<string> result3 = solution.activeBusinesses(log3);\n    cout << \"Test case 3: \";\n    for (const auto& business : result3) {\n        cout << business << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1128": "```\n#include <iostream>\n#include <vector>\n\nint numEquivDominoPairs(std::vector<std::vector<int>>& dominoes) {\n    int count = 0;\n    std::unordered_map<std::pair<int, int>, int> map;\n\n    for (const auto& domino : dominoes) {\n        std::sort(domino.begin(), domino.end());\n        map[std::make_pair(domino[0], domino[1])]++;\n    }\n\n    for (const auto& pair : map) {\n        count += pair.second / 2;\n    }\n\n    return count;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> test1 = {{1,2},{1,1},{3,4},{3,3}};\n    std::cout << \"Test case 1: \" << numEquivDominoPairs(test1) << std::endl;\n\n    // Test case 2\n    std::vector<std::vector<int>> test2 = {{1,2},{5,6}};\n    std::cout << \"Test case 2: \" << numEquivDominoPairs(test2) << std::endl;\n\n    // Test case 3\n    std::vector<std::vector<int>> test3 = {{1,1},{2,2}};\n    std::cout << \"Test case 3: \" << numEquivDominoPairs(test3) << std::endl;\n}\n```",
  "1127": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> searchQueries(vector<vector<int>>& queries, vector<vector<int>>& products) {\n        unordered_map<int, string> productMap;\n        for (const auto& product : products) {\n            productMap[product[0]] = to_string(product[1]) + \" \" + product[2];\n        }\n        \n        vector<string> results;\n        for (const auto& query : queries) {\n            string result = \"\";\n            for (int i = 1; i < query.size(); ++i) {\n                if (productMap.find(query[i]) != productMap.end()) {\n                    result += productMap[query[i]] + \" \";\n                }\n            }\n            results.push_back(result);\n        }\n        \n        return results;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> queries1 = {{5, 3}, {7, 2}};\n    vector<vector<int>> products1 = {{1, \"apple\", \"phone\"}, {2, \"banana\", \"case\"}, {3, \"orange\", \"charger\"}, {4, \"grape\", \"phone\"}, {5, \"apricot\", \"charger\"}, {6, \"berry\", \"case\"}, {7, \"mango\", \"charger\"}};\n    vector<string> results1 = solution.searchQueries(queries1, products1);\n    for (const auto& result : results1) {\n        cout << result << endl;\n    }\n    \n    // Test Case 2\n    vector<vector<int>> queries2 = {{8, 4}, {9, 5}};\n    vector<vector<int>> products2 = {{1, \"apple\", \"phone\"}, {2, \"banana\", \"case\"}, {3, \"orange\", \"charger\"}, {4, \"grape\", \"phone\"}, {5, \"apricot\", \"charger\"}, {6, \"berry\", \"case\"}, {7, \"mango\", \"charger\"}, {8, \"peach\", \"phone\"}, {9, \"pear\", \"case\"}};\n    vector<string> results2 = solution.searchQueries(queries2, products2);\n    for (const auto& result : results2) {\n        cout << result << endl;\n    }\n    \n    // Test Case 3\n    vector<vector<int>> queries3 = {{1, 5}, {6, 8}};\n    vector<vector<int>> products3 = {{1, \"apple\", \"phone\"}, {2, \"banana\", \"case\"}, {3, \"orange\", \"charger\"}, {4, \"grape\", \"phone\"}, {5, \"apricot\", \"charger\"}, {6, \"berry\", \"case\"}, {7, \"mango\", \"charger\"}, {8, \"peach\", \"phone\"}};\n    vector<string> results3 = solution.searchQueries(queries3, products3);\n    for (const auto& result : results3) {\n        cout << result << endl;\n    }\n    \n    return 0;\n}\n```",
  "1130": "```\n#include <iostream>\n#include <vector>\n\nint mctFromLeafValues(std::vector<int>& arr) {\n    int n = arr.size();\n    std::vector<int> dp(n);\n    dp[0] = arr[0];\n    for (int i = 1; i < n; i++) {\n        dp[i] = arr[i];\n    }\n    for (int i = 1; i < n - 1; i++) {\n        if ((arr[i] > arr[i - 1]) && (arr[i] > arr[i + 1])) {\n            dp[i] += arr[i - 1];\n        } else if ((arr[i] < arr[i - 1]) && (arr[i] < arr[i + 1])) {\n            dp[i] += arr[i + 1];\n        }\n    }\n    int res = 0;\n    for (int i = 1; i < n - 1; i++) {\n        res += dp[i];\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> arr1 = {6,2,4};\n    std::cout << \"Test case 1: \" << mctFromLeafValues(arr1) << std::endl;\n\n    std::vector<int> arr2 = {4,11,n};\n    std::cout << \"Test case 2: \" << mctFromLeafValues(arr2) << std::endl;\n\n    std::vector<int> arr3 = {1,3,7};\n    std::cout << \"Test case 3: \" << mctFromLeafValues(arr3) << std::endl;\n}\n```",
  "1131": "```\n#include <iostream>\n#include <vector>\n\nint maximum69Interval(std::vector<int>& num) {\n    for (int i = 0; i < num.size(); ++i) {\n        if (num[i] == 6) {\n            num[i] = 9;\n            int sum = 0;\n            for (int j = 0; j < num.size(); ++j) {\n                sum += abs(num[j] - 9);\n            }\n            return sum;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    std::vector<int> test1 = {8, 2, 6, 9};\n    std::cout << \"Test Case 1: \" << maximum69Interval(test1) << std::endl;\n\n    std::vector<int> test2 = {200000, 100000};\n    std::cout << \"Test Case 2: \" << maximum69Interval(test2) << std::endl;\n\n    std::vector<int> test3 = {0, 0, 8, 5};\n    std::cout << \"Test Case 3: \" << maximum69Interval(test3) << std::endl;\n\n    return 0;\n}\n```",
  "1129": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPath(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<vector<pair<int, int>>> g(n);\n        for (int i = 0; i < n; i++) {\n            for (auto &edge : graph[i]) {\n                g[edge[0]].emplace_back(edge[1], edge[2]);\n            }\n        }\n\n        vector<int> res;\n        queue<pair<int, int>> q;\n        for (int i = 0; i < n; i++) {\n            if (g[i].size() > 0) {\n                q.emplace(i, 0);\n            }\n        }\n\n        while (!q.empty()) {\n            int node = q.front().first;\n            int step = q.front().second;\n            q.pop();\n\n            if (step > res.size()) {\n                continue;\n            }\n\n            for (auto &edge : g[node]) {\n                int nextNode = edge.first;\n                int color = edge.second;\n\n                if ((color == 0 && res.size() % 2 != 1) || (color == 1 && res.size() % 2 != 0)) {\n                    continue;\n                }\n\n                if (res.size() < step + 1) {\n                    res.resize(step + 1);\n                }\n                res[step] = nextNode;\n\n                q.emplace(nextNode, step + 1);\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    vector<vector<int>> graph1 = {{0,1,2},{1,2},{2,0,1,3}};\n    cout << \"Test case 1: \";\n    for (auto &x : Solution().shortestAlternatingPath(graph1)) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> graph2 = {{0,1,3},{1,2},{2,0,1,5}};\n    cout << \"Test case 2: \";\n    for (auto &x : Solution().shortestAlternatingPath(graph2)) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> graph3 = {{0,1,2},{1,2,3},{2,3},{3,0}};\n    cout << \"Test case 3: \";\n    for (auto &x : Solution().shortestAlternatingPath(graph3)) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1133": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint largestUniqueNumber(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int uniqueMax = -1;\n    for (int i = 0; i < nums.size() - 1; i++) {\n        if (nums[i] != nums[i + 1]) {\n            uniqueMax = nums[i];\n            break;\n        }\n    }\n    return uniqueMax;\n}\n\nint main() {\n    std::vector<int> testCases[] = {\n        {5, 7, 3, 9, 2, 9, 5, 7, 3}, \n        {6, 7, 3, 8, 4, 1, 2, 5, 3},\n        {1, 2, 3}\n    };\n    \n    for (int i = 0; i < sizeof(testCases) / sizeof(testCases[0]); i++) {\n        std::cout << \"Largest unique number in test case \" << i + 1 << \": \" << largestUniqueNumber(testCases[i]) << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "1132": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int getHelpfulCount(std::vector<std::vector<int>>& help, std::vector<std::vector<string>>& username) {\n        int total = 0;\n        for (int i = 0; i < help.size(); ++i) {\n            if (help[i][0] == 1) { // 1 means reported\n                total += 1;\n            } else if (help[i][0] == -1) { // -1 means not reported\n                for (int j = 1; j < help[i].size(); ++j) {\n                    if (help[i][j] > 0) { // user was helpful\n                        total += help[i][j];\n                    }\n                }\n            }\n        }\n        return total;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::vector<int>> help1 = {{-1, 1}, {-1, -1}, {1, 0}};\n    std::vector<std::vector<string>> username1 = {{\"user0\", \"user1\"}, {\"user2\", \"user3\"}, {\"user4\", \"user5\"}};\n    int expected1 = 2;\n    int result1 = solution.getHelpfulCount(help1, username1);\n    if (result1 == expected1) {\n        std::cout << \"Test case 1: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Fail. Expected \" << expected1 << \", got \" << result1 << std::endl;\n    }\n\n    std::vector<std::vector<int>> help2 = {{-1, 1}, {1, -1}};\n    std::vector<std::vector<string>> username2 = {{\"user0\", \"user1\"}, {\"user2\", \"user3\"}};\n    int expected2 = 1;\n    int result2 = solution.getHelpfulCount(help2, username2);\n    if (result2 == expected2) {\n        std::cout << \"Test case 2: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Fail. Expected \" << expected2 << \", got \" << result2 << std::endl;\n    }\n\n    std::vector<std::vector<int>> help3 = {{-1, -1}};\n    std::vector<std::vector<string>> username3 = {{\"user0\", \"user1\"}};\n    int expected3 = 0;\n    int result3 = solution.getHelpfulCount(help3, username3);\n    if (result3 == expected3) {\n        std::cout << \"Test case 3: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Fail. Expected \" << expected3 << \", got \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1134": "```\n#include <iostream>\n#include <cmath>\n\nbool isArmstrong(int n) {\n    int original = n;\n    int sum = 0;\n    int temp = n;\n\n    while (temp != 0) {\n        int digit = temp % 10;\n        sum += pow(digit, ceil(log10(original)));\n        temp /= 10;\n    }\n\n    return sum == original;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << (isArmstrong(153) ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test Case 2: \" << (isArmstrong(370) ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test Case 3: \" << (isArmstrong(9) ? \"Pass\" : \"Fail\") << std::endl;\n\n    return 0;\n}\n```",
  "1135": "```\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<vector<pair<int, int>>> graph(n);\n        for (auto& flight : flights) {\n            graph[flight[1]].push_back({flight[2], flight[0]});\n        }\n        \n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        pq.push({0, src});\n        vector<int> price(n);\n        while (!pq.empty()) {\n            int currPrice = pq.top().first;\n            int node = pq.top().second;\n            pq.pop();\n            if (node == dst) return currPrice;\n            for (auto& neighbor : graph[node]) {\n                if (currPrice + 1 <= k && price[neighbor.second] < currPrice + 1) {\n                    price[neighbor.second] = currPrice + 1;\n                    pq.push({price[neighbor.second], neighbor.second});\n                }\n            }\n        }\n        \n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int n1 = 3;\n    vector<vector<int>> flights1 = {{0,1,100},{1,2,200},{0,2,150}};\n    int src1 = 0, dst1 = 2, k1 = 50;\n    cout << \"Test Case 1: \" << solution.findCheapestPrice(n1, flights1, src1, dst1, k1) << endl;\n\n    int n2 = 3;\n    vector<vector<int>> flights2 = {{0,1,100},{1,2,200},{0,2,150},{1,3,250}};\n    int src2 = 0, dst2 = 2, k2 = 50;\n    cout << \"Test Case 2: \" << solution.findCheapestPrice(n2, flights2, src2, dst2, k2) << endl;\n\n    int n3 = 4;\n    vector<vector<int>> flights3 = {{0,1,100},{1,2,200},{0,3,20}};\n    int src3 = 0, dst3 = 3, k3 = 0;\n    cout << \"Test Case 3: \" << solution.findCheapestPrice(n3, flights3, src3, dst3, k3) << endl;\n\n    return 0;\n}\n```",
  "1136": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumTime(int n, vector<vector<int>>& relation) {\n        vector<int> in(n + 1, 0);\n        for (const auto& edge : relation) {\n            in[edge[1]]++;\n        }\n        \n        queue<int> q;\n        for (int i = 1; i <= n; i++) {\n            if (in[i] == 0) q.push(i);\n        }\n        \n        int res = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            res += node;\n            for (const auto& edge : relation) {\n                if (edge[0] == node) {\n                    in[edge[1]]--;\n                    if (in[edge[1]] == 0) q.push(edge[1]);\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.minimumTime(2, {{1,2},{2,3},{3,4}}) << endl;  // Output: 6\n    cout << \"Test Case 2: \" << solution.minimumTime(3, {{1,3},{2,3},{4,5},{5,2},{5,6},{6,3}}) << endl;  // Output: 11\n    cout << \"Test Case 3: \" << solution.minimumTime(4, {{1,2},{2,3},{3,4}}) << endl;  // Output: 7\n\n    return 0;\n}\n```",
  "1137": "```\n#include <iostream>\n#include <vector>\n\nint tribonacci(int n) {\n    if (n <= 0) return 0;\n    if (n == 1 || n == 2) return 1;\n    std::vector<int> dp(n + 1);\n    dp[0] = 0; dp[1] = 1; dp[2] = 1;\n    for (int i = 3; i <= n; ++i) {\n        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n    }\n    return dp[n];\n}\n\nint main() {\n    std::cout << tribonacci(4) << std::endl; // expected output: 7\n    std::cout << tribonacci(25) << std::endl; // expected output: 13885753\n    std::cout << tribonacci(11) << std::endl; // expected output: 144\n\n    return 0;\n}\n```",
  "1138": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string alphabetBoardPath(string target) {\n        int x = 0, y = 0;\n        string res = \"\";\n        for(int i = 0; i < target.length(); i++) {\n            char c = target[i];\n            if(c == 'a') x++;\n            else if(c >= 'b' && c <= 'z') x++, y++;\n            else if(c == 'z') x++;\n            while(x > 1) res += \"L\";\n            while(y < (c - 'a')) res += \"D\" + string(y++ - (c - 'a'));\n            while(x < (c - 'a' + 1)) res = \"U\" + res, x--;\n            res += \"R\" + string(c - 'a');\n        }\n        return \"LRDUURDLUU\".length() == target.length() ? \"\" : \"Invalid Input\";\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.alphabetBoardPath(\"zjgtmtdv\") << endl; // Output: \"LDLDRURUSDULULD\"\n    cout << solution.alphabetBoardPath(\"leet\") << endl; // Output: \"LRUURDLLU\"\n    cout << solution.alphabetBoardPath(\"code\") << endl; // Output: \"RULKLU\"\n    return 0;\n}\n```",
  "1139": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int m = grid.size();\n        if (m == 0) return 0;\n        int n = grid[0].size();\n        \n        vector<vector<int>> dp(m, vector<int>(n));\n        \n        int maxSide = 0;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((i > 0 || j > 0) && grid[i][j] == 1) {\n                    dp[i][j] = (i > 0 && j > 0 && grid[i-1][j-1] == 1)? min(dp[i-1][j-1], 1):1;\n                    if ((i > 0 && grid[i-1][j] == 1) || (j > 0 && grid[i][j-1] == 1))\n                        dp[i][j] = max(dp[i][j], min(dp[i-1][j], dp[i][j-1]) + 1);\n                    maxSide = max(maxSide, dp[i][j]);\n                }\n            }\n        }\n        \n        return maxSide * maxSide;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> grid1 {{0,1,0,1},{1,1,1,0},{0,1,1,1},{1,0,1,0}};\n    cout << \"Test case 1: \" << solution.largest1BorderedSquare(grid1) << endl;\n    \n    // Test case 2\n    vector<vector<int>> grid2 {{1,1,1},{1,0,1},{1,1,1}};\n    cout << \"Test case 2: \" << solution.largest1BorderedSquare(grid2) << endl;\n    \n    // Test case 3\n    vector<vector<int>> grid3 {{1,0,0},{1,1,0},{0,1,1}};\n    cout << \"Test case 3: \" << solution.largest1Bored",
  "1140": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int stoneGameII(vector<int>& piles) {\n        int n = piles.size();\n        long long total = 0;\n        for (int i = 0; i < n; i++) {\n            total += piles[i];\n        }\n        \n        vector<long long> prefixSum(n + 1);\n        prefixSum[0] = 0;\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + piles[i];\n        }\n        \n        function<int(int, int)> dfs = [&](int i, int M) {\n            if (i >= n) return 0;\n            long long take = min((long long)M * M, prefixSum[n] - prefixSum[i]) - (prefixSum[i] - prefixSum[max(0, i - M)]);\n            int res = INT_MAX;\n            for (int j = i; j < n && j + 2*M >= i; j++) {\n                res = min(res, dfs(j + 1, max(M, j + 1)));\n                take -= piles[j];\n            }\n            return res + (take > 0);\n        };\n        \n        return dfs(0, 1);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<int> piles1 = {5, 1, 2, 3};\n    cout << \"Test Case 1: \" << solution.stoneGameII(piles1) << endl;\n\n    // Test Case 2\n    vector<int> piles2 = {6, 4, 7, 11, 5, 9};\n    cout << \"Test Case 2: \" << solution.stoneGameII(piles2) << endl;\n\n    // Test Case 3\n    vector<int> piles3 = {10, 1, 10, 1, 10, 1, 10, 1};\n    cout << \"Test Case 3: \" << solution.stoneGameII(piles3) << endl;\n    \n    return 0;\n}\n```",
  "1141": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int getMaximumUsers(vector<vector<int>>& activities) {\n        vector<int> days;\n        for (const auto& activity : activities) {\n            days.push_back(activity[1] - activity[0]);\n        }\n        return *max_element(days.begin(), days.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> activities1 = {{1,3},{2,4},{7,10}};\n    cout << \"Test case 1: \" << solution.getMaximumUsers(activities1) << endl;\n    \n    // Test case 2\n    vector<vector<int>> activities2 = {{1,5},{2,8}};\n    cout << \"Test case 2: \" << solution.getMaximumUsers(activities2) << endl;\n\n    // Test case 3\n    vector<vector<int>> activities3 = {{1,10},{2,15},{7,12}};\n    cout << \"Test case 3: \" << solution.getMaximumUsers(activities3) << endl;\n    \n    return 0;\n}\n```",
  "1143": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint longestCommonSubsequence(std::string text1, std::string text2) {\n    int m = text1.length();\n    int n = text2.length();\n\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));\n\n    for (int i = 0; i <= m; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 0;\n            } else if (text1[i - 1] == text2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    int result = dp[m][n];\n    return result;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << longestCommonSubsequence(\"abcde\", \"ace\") << std::endl; // Output: 3\n    std::cout << \"Test case 2: \" << longestCommonSubsequence(\"foxjumpedoverthecrazydog\", \"woofwoofjumpsacross\") << std::endl; // Output: 7\n    std::cout << \"Test case 3: \" << longestCommonSubsequence(\"\", \"\") << std::endl; // Output: 0\n\n    return 0;\n}\n```",
  "1142": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<string> getSubIsland(std::vector<std::vector<char>>& grid, int i, int j) {\n        if (i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size()) return {};\n        if (grid[i][j] == '0') return {};\n\n        grid[i][j] = '0'; // mark as visited\n\n        std::vector<string> result;\n        for (int k = -1; k <= 1; ++k) {\n            for (int l = -1; l <= 1; ++l) {\n                if (k == 0 && l == 0) continue;\n                int ni = i + k;\n                int nj = j + l;\n                if (ni >= 0 && nj >= 0 && ni < grid.size() && nj < grid[0].size()) {\n                    std::vector<string> subIsland = getSubIsland(grid, ni, nj);\n                    if (!subIsland.empty()) result.push_back(std::move(subIsland[0]));\n                }\n            }\n        }\n\n        return result;\n    }\n\n    vector<vector<string>> subGridsInGrid(vector<vector<char>>& grid) {\n        std::vector<std::vector<string>> result;\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[0].size(); ++j) {\n                if (grid[i][j] == '1') {\n                    std::vector<string> subIsland = getSubIsland(grid, i, j);\n                    if (!subIsland.empty()) result.push_back(subIsland);\n                }\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::vector<char>> grid1 = {{'0', '0', '1'}, {'1', '1', '1'}, {'1', '1', '0'}};\n    std::vector<std::vector<string>> result1 = solution.subGridsInGrid(grid1);\n    for (const auto& subIsland : result1) {\n        for (char c : subIsland) {\n            std::cout << c;\n        }\n        std::cout << \"\\n\";\n    }\n\n    // Test Case 2\n    std::vector<std::vector<char>> grid2 = {{'0', '1'}, {'0', '0'}};\n    std::vector<std::vector<string>> result2 = solution.subGridsInGrid(grid2);\n    for (const auto& subIsland : result2) {\n        for (char c : subIsland) {\n            std::cout << c;\n        }\n        std::cout << \"\\n\";\n    }\n\n    // Test Case 3\n    std::vector<std::vector<char>> grid3 = {{'1', '0', '0'}, {'0', '1', '1'}, {'0', '0', '1'}};\n    std::vector<std::vector<string>> result3 = solution.subGridsInGrid(grid3);\n    for (const auto& subIsland : result3) {\n        for (char c : subIsland) {\n            std::cout << c;\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "1144": "```\n#include <iostream>\n#include <vector>\n\nint movesToMakeZigzag(int arr[]) {\n    int n = sizeof(arr) / sizeof(arr[0]);\n    if (n == 1) return 0;\n    \n    int res = 0, leftMax = 0, rightMax = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int left = max(0, i - 1), right = min(n - 1, i + 1);\n        \n        if (i % 2 == 0) {\n            res += (arr[i] <= leftMax ? 1 : arr[i] - leftMax) + (arr[i] <= rightMax ? 1 : arr[i] - rightMax);\n            leftMax = max(leftMax, arr[left]);\n            rightMax = max(rightMax, arr[right]);\n        } else {\n            res += (arr[i] <= leftMax ? 1 : arr[i] - leftMax) + (arr[i] <= rightMax ? 1 : arr[i] - rightMax);\n            leftMax = max(leftMax, arr[right]);\n            rightMax = max(rightMax, arr[left]);\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    int arr1[] = {9, 6, 4, 3, 5};\n    std::cout << \"Case 1: \" << movesToMakeZigzag(arr1) << std::endl;\n\n    int arr2[] = {1, 1};\n    std::cout << \"Case 2: \" << movesToMakeZigzag(arr2) << std::endl;\n\n    int arr3[] = {7, 6, 5, 4, 3, 2};\n    std::cout << \"Case 3: \" << movesToMakeZigzag(arr3) << std::endl;\n    \n    return 0;\n}\n```",
  "1145": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    bool btreeGameWinning(TreeNode* root, int firstPlayer) {\n        if (!root)\n            return false;\n        \n        int mx = max({abs(firstPlayer - root->left->val), abs(firstPlayer - root->right->val), abs(firstPlayer - root->val)});\n        return mx > 0;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(2);\n    cout << \"Test case 1: \" << (solution.btreeGameWinning(root1, 1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(2);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(1);\n    cout << \"Test case 2: \" << (solution.btreeGameWinning(root2, 1) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(5);\n    root3->left = new TreeNode(4);\n    root3->right = new TreeNode(6);\n    cout << \"Test case 3: \" << (solution.btreeGameWinning(root3, 2) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1147": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestDecomposition(string s) {\n        int n = s.size();\n        for (int i = n / 2; i >= 0; --i) {\n            string left = s.substr(0, i);\n            string right = s.substr(n - i, i);\n            if (left == reverse(right)) return 2 * i;\n        }\n        return 0;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.longestDecomposition(\"abcdabcd\") << endl; // Expected: 4\n    cout << solution.longestDecomposition(\"yzzzzy\") << endl;   // Expected: 7\n    cout << solution.longestDecomposition(\"abcbcd\") << endl;    // Expected: 0\n\n    return 0;\n}\n```",
  "1146": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nclass SnapshotArray {\npublic:\n    int snap();\n    void set(int index, int val);\n    int get(int index, int Snap);\nprivate:\n    std::vector<int> array;\n    int snapCount = 0;\n    std::unordered_map<int, std::vector<int>> snapshotMap;\n};\n\nint main() {\n    SnapshotArray sa;\n    \n    // Test case 1\n    sa.set(0, 5);\n    sa.set(1, 3);\n    sa.set(0, 6);\n    int snapId = sa.snap();\n    std::cout << \"Snap id: \" << snapId << std::endl;\n    for (int i = 0; i <= 1; ++i) {\n        if (i == 0)\n            std::cout << \"At index \" << i << \": \" << sa.get(i, snapId) << std::endl;\n        else\n            std::cout << \"At index \" << i << \": \" << sa.get(i, -1) << std::endl;\n    }\n\n    // Test case 2\n    sa.set(0, 5);\n    sa.set(1, 3);\n    int snapId2 = sa.snap();\n    std::cout << \"Snap id: \" << snapId2 << std::endl;\n    for (int i = 0; i <= 1; ++i) {\n        if (i == 0)\n            std::cout << \"At index \" << i << \": \" << sa.get(i, snapId2) << std::endl;\n        else\n            std::cout << \"At index \" << i << \": \" << sa.get(i, -1) << std::endl;\n    }\n\n    // Test case 3\n    sa.set(0, 5);\n    int snapId3 = sa.snap();\n    for (int i = 0; i <= 0; ++i) {\n        if (i == 0)\n            std::cout << \"At index \" << i << \": \" << sa.get(i, snapId3) << std::endl;\n        else\n            std::cout << \"At index \" << i << \": \" << sa.get(i, -1) << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1148": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Views {\npublic:\n    int getView(vector<string>& columns) {\n        if (columns.empty()) return 0;\n        for (auto column : columns) {\n            if (column == \"views\") return stoi(column);\n        }\n        return 0;\n    }\n};\n\nint main() {\n    Views views;\n    \n    // Test Case 1\n    vector<string> testCase1 = {\"100\", \"50\", \"views\"};\n    cout << \"Test Case 1: \" << views.getView(testCase1) << endl;  // Expected output: 100\n\n    // Test Case 2\n    vector<string> testCase2 = {\"0\", \"500\", \"views\"};\n    cout << \"Test Case 2: \" << views.getView(testCase2) << endl;  // Expected output: 0\n\n    // Test Case 3\n    vector<string> testCase3 = {\"1000\", \"\", \"views\"};\n    cout << \"Test Case 3: \" << views.getView(testCase3) << endl;  // Expected output: 0\n    \n    return 0;\n}\n```",
  "1149": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int mostReads(std::vector<std::vector<int>>& views) {\n        int maxViews = 0;\n        for (const auto& view : views) {\n            int articleId = view[0];\n            int day = view[1];\n            int viewsCount = view[2];\n            if (viewsCount > maxViews) {\n                maxViews = viewsCount;\n            }\n        }\n        return maxViews;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> views1 = {{1, 4}, {2, 3}, {5, 10}};\n    int result1 = solution.mostReads(views1);\n    if (result1 != 10) {\n        std::cout << \"Test case 1 failed: Expected 10, got \" << result1 << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::vector<int>> views2 = {{5, 6}, {7, 8}, {9, 10}};\n    int result2 = solution.mostReads(views2);\n    if (result2 != 10) {\n        std::cout << \"Test case 2 failed: Expected 10, got \" << result2 << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::vector<int>> views3 = {{1, 1}, {5, 6}};\n    int result3 = solution.mostReads(views3);\n    if (result3 != 6) {\n        std::cout << \"Test case 3 failed: Expected 6, got \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1150": "```\n#include <iostream>\nusing namespace std;\n\nbool isMajorityElement(int arr[], int n, int target) {\n    int left = 0;\n    int right = n - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (arr[mid] == target) {\n            // If the target is found at mid, check if it's a majority element\n            int count = 0;\n            for (int i = 0; i < n; i++) {\n                if (arr[i] == target) {\n                    count++;\n                }\n            }\n            return count > n / 2;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return false;\n}\n\nint main() {\n    int arr1[] = {2, 7, 11};\n    cout << isMajorityElement(arr1, sizeof(arr1) / sizeof(arr1[0]), 7) << endl;\n\n    int arr2[] = {1, 3, 4, 5};\n    cout << isMajorityElement(arr2, sizeof(arr2) / sizeof(arr2[0]), 5) << endl;\n\n    int arr3[] = {1, 2};\n    cout << isMajorityElement(arr3, sizeof(arr3) / sizeof(arr3[0]), 2) << endl;\n    return 0;\n}\n```",
  "1151": "```\n#include <iostream>\n#include <vector>\n\nint minSwaps(std::vector<int>& arr) {\n    int n = arr.size();\n    int ones = 0, swapCount = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] == 1)\n            ones++;\n    }\n    \n    int left = 0, right = 0;\n    while (right < n) {\n        if (arr[right] == 1) {\n            while (left < right && arr[left] != 1)\n                left++;\n            if (left >= right || arr[left] == 1)\n                right++;\n            else\n                swapCount += right - left, left = right;\n        } else\n            right++;\n    }\n    \n    return ones * 2 - 2 * swapCount;\n}\n\nint main() {\n    std::vector<int> arr1 = {0, 0, 1, 1};\n    std::cout << \"Test case 1: \" << minSwaps(arr1) << std::endl;\n\n    std::vector<int> arr2 = {0, 0, 0, 1, 1, 1, 1};\n    std::cout << \"Test case 2: \" << minSwaps(arr2) << std::endl;\n\n    std::vector<int> arr3 = {0, 0, 1, 0, 1};\n    std::cout << \"Test case 3: \" << minSwaps(arr3) << std::endl;\n\n    return 0;\n}\n```",
  "1152": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> mostVisited(int n, vector<vector<int>>& records) {\n        unordered_map<int, int> count;\n        for (const auto& record : records) {\n            int start = record[0], end = record[1];\n            for (int i = start; i <= end; i++) {\n                count[i]++;\n            }\n        }\n        vector<string> result(n, \"X\");\n        int maxCount = 0;\n        for (const auto& pair : count) {\n            if (pair.second > maxCount) {\n                maxCount = pair.second;\n                for (int i = 0; i < n; i++) {\n                    if (i == pair.first - 1) {\n                        result[i] = \"A\";\n                        break;\n                    }\n                }\n            } else if (pair.second == maxCount) {\n                for (int i = 0; i < n; i++) {\n                    if (i == pair.first - 1) {\n                        result[i] = \"A\";\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> records1 = {{5,8},{9,11},{12,15}};\n    vector<string> expected1 = {\"X\",\"X\",\"A\",\"X\",\"X\"};\n    for (const auto& record : solution.mostVisited(16, records1)) {\n        cout << record << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<vector<int>> records2 = {{1,3},{2,4},{5,6}};\n    vector<string> expected2 = {\"A\",\"A\",\"A\",\"A\",\"X\"};\n    for (const auto& record : solution.mostVisited(7, records2)) {\n        cout << record << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<vector<int>> records3 = {{1,11},{2,4},{6,10}};\n    vector<string> expected3 = {\"A\",\"A\",\"A\",\"A\",\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"};\n    for (const auto& record : solution.mostVisited(12, records3)) {\n        cout << record << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1153": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int stringTransformsToString(string s1, string s2) {\n        if (s1.size() != s2.size()) return 0;\n        \n        vector<char> diff(s1.size(), 0);\n        for (int i = 0; i < s1.size(); i++) {\n            if (s1[i] != s2[i]) diff[i] = 1;\n        }\n        \n        int res = 0;\n        for (int i = 0; i < s1.size(); i++) {\n            if (i == 0 || diff[i-1] == 0) {\n                int k = i;\n                while (k > 0 && diff[k-1] == 0) k--;\n                res++;\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.stringTransformsToString(\"aabcc\", \"dbcbba\") << endl;\n    cout << \"Expected Output: 3\" << endl;\n\n    cout << \"Test Case 2: \" << solution.stringTransformsToString(\"leetcode\", \"etcoaled\") << endl;\n    cout << \"Expected Output: 4\" << endl;\n\n    cout << \"Test Case 3: \" << solution.stringTransformsToString(\"dinitrofficient\", \"hitfineddistronic\") << endl;\n    cout << \"Expected Output: 5\" << endl;\n\n    return 0;\n}\n```",
  "1154": "```\n#include <iostream>\n#include <string>\n\nint dayOfYear(std::string date) {\n    int month[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    if (date.length() != 10) return -1;\n    int year = stoi(date.substr(5));\n    int monthIndex = stoi(date.substr(0, 3)) - 1;\n    int day = stoi(date.substr(4, 2));\n\n    if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)\n        month[2] = 29;\n\n    return (day + sum(month, 0, monthIndex)) % 7;\n}\n\nint sum(int months[], int start, int end) {\n    int total = 0;\n    for (int i = start; i < end; i++) {\n        total += months[i];\n    }\n    return total;\n}\n\nint main() {\n    std::cout << dayOfYear(\"2019-01-15\") << std::endl; // Output: 4\n    std::cout << dayOfYear(\"1990-07-04\") << std::endl; // Output: 1\n    std::cout << dayOfYear(\"2000-06-25\") << std::endl; // Output: 6\n    return 0;\n}\n```",
  "1155": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numRollsToTarget(int n, int k, int target) {\n        vector<vector<int>> dp(n + 1, vector<int>(target + 1));\n        for (int i = 0; i <= n; ++i) {\n            for (int j = 1; j <= target; ++j) {\n                if (i == 0 && j > 0) {\n                    dp[i][j] = 0;\n                } else if (i > 0) {\n                    int total = 0;\n                    for (int roll = 1; roll <= k; ++roll) {\n                        if (total + roll > target) break;\n                        if (j == total + roll) {\n                            dp[i][j] = i == 0 ? 1 : dp[i - 1][target];\n                        }\n                        total += roll;\n                    }\n                } else {\n                    dp[i][j] = 0;\n                }\n            }\n        }\n        return dp[n][target];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: n=2, k=6, target=7 => \" << solution.numRollsToTarget(2, 6, 7) << endl;\n    cout << \"Test case 2: n=5, k=3, target=13 => \" << solution.numRollsToTarget(5, 3, 13) << endl;\n    cout << \"Test case 3: n=1, k=4, target=10 => \" << solution.numRollsToTarget(1, 4, 10) << endl;\n\n    return 0;\n}\n```",
  "1156": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint maxRepeatingChars(std::string s) {\n    int n = s.length();\n    int ans = 0;\n    for (int i = 1; i <= n / 2; ++i) {\n        if (n % i == 0) {\n            std::vector<int> cnt(i, 0);\n            bool found = true;\n            for (int j = 0; j < n; j += i) {\n                int k = j;\n                do {\n                    cnt[k % i]++;\n                    k++;\n                } while (k % i != 0 && k < j + i);\n                if (cnt[k % i] > 1) {\n                    found = false;\n                    break;\n                }\n            }\n            if (found) ans = i;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::cout << maxRepeatingChars(\"aaabaaa\") << std::endl; // expected output: 3\n    std::cout << maxRepeatingChars(\"abcde\") << std::endl; // expected output: 1\n    std::cout << maxRepeatingChars(\"aaaa\") << std::endl; // expected output: 4\n\n    return 0;\n}\n```",
  "1157": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    vector<int> majority(nums) {\n        int count1 = 0;\n        int count2 = 0;\n        int candidate1 = 0;\n        int candidate2 = 0;\n\n        for (int num : nums) {\n            if (num == candidate1)\n                count1++;\n            else if (num == candidate2)\n                count2++;\n            else if (count1 > 0)\n                count1--;\n            else if (count2 > 0)\n                count2--;\n            else {\n                candidate1 = num;\n                count1 = 1;\n            } else if (candidate1 == candidate2) {\n                candidate1 = num;\n                count1 = 1;\n            } else {\n                count2++;\n                candidate2 = num;\n            }\n        }\n\n        // Check the candidates\n        int cnt1 = 0, cnt2 = 0;\n        for (int num : nums) {\n            if (num == candidate1)\n                cnt1++;\n            else if (num == candidate2)\n                cnt2++;\n        }\n\n        vector<int> result;\n        if (cnt1 > cnt2 && nums.count(candidate1)) {\n            result.push_back(candidate1);\n            int maxCount = 0, tempCount = 0;\n            for (int i = 0; i < nums.size(); i++) {\n                if (nums[i] == candidate1) {\n                    tempCount++;\n                } else {\n                    tempCount--;\n                    if (tempCount == 0) {\n                        maxCount++;\n                        tempCount = 0;\n                    }\n                }\n            }\n            for (int i = 0; i < nums.size(); i++) {\n                if (tempCount > 0) {\n                    result.push_back(candidate1);\n                    tempCount--;\n                } else {\n                    result.push_back(nums[i]);\n                }\n            }\n        } else if (cnt2 > cnt1 && nums.count(candidate2)) {\n            result.push_back(candidate2);\n            int maxCount = 0, tempCount = 0;\n            for (int i = 0; i < nums.size(); i++) {\n                if (nums[i] == candidate2) {\n                    tempCount++;\n                } else {\n                    tempCount--;\n                    if (tempCount == 0) {\n                        maxCount++;\n                        tempCount = 0;\n                    }\n                }\n            }\n            for (int i = 0; i < nums.size(); i++) {\n                if (tempCount > 0) {\n                    result.push_back(candidate2);\n                    tempCount--;\n                } else {\n                    result.push_back(nums[i]);\n                }\n            }\n        }\n    }\n\n};\n\nint main() {\n    Solution solution;\n    vector<int> test1 = {1, 2, -3, 3, 4};\n    vector<int> test2 = {1, 2, -3, -3, 4];\n    vector<int> test3 = {10, 20};\n\n    cout << \"Test Case 1: \";\n    solution.majority(test1);\n    for (int num : test1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test Case 2: \";\n    solution.majority(test2);\n    for (int num : test2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    cout << \"Test Case 3: \";\n    solution.majority(test3);\n    for (int num : test3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n```",
  "1158": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int maxProfit(std::vector<std::vector<int>>& transactions) {\n        if (transactions.empty()) return 0;\n        \n        int n = transactions.size();\n        int m = transactions[0].size();\n        std::vector<std::vector<int>> dp(n, std::vector<int>(m));\n        \n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                if (transactions[i][j] > transactions[0][j]) {\n                    dp[i][j] = std::max(dp[i-1][j], transactions[i][j]);\n                } else {\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        \n        int res = 0;\n        for (int j = 0; j < m; ++j) {\n            res = std::max(res, dp[n-1][j]);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test Case 1\n    std::vector<std::vector<int>> transactions1 = {{100, 50}, {60, 70}, {30, 40}};\n    int result1 = s.maxProfit(transactions1);\n    std::cout << \"Test Case 1: \" << result1 << std::endl;\n    \n    // Test Case 2\n    std::vector<std::vector<int>> transactions2 = {{100, 50}, {60, 70}, {30, 40}, {20, 10}};\n    int result2 = s.maxProfit(transactions2);\n    std::cout << \"Test Case 2: \" << result2 << std::endl;\n    \n    // Test Case 3\n    std::vector<std::vector<int>> transactions3 = {{100, 50}, {60, 70}, {30, 40}, {20, 10}, {0, 0}};\n    int result3 = s.maxProfit(transactions3);\n    std::cout << \"Test Case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1159": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> marketAnalysis(vector<vector<string>>& transactions) {\n        unordered_map<string, int> stockCounts;\n        for (const auto& transaction : transactions) {\n            string operation = transaction[1];\n            if (operation == \"buy\") {\n                stockCounts[transaction[0]]++;\n            } else if (operation == \"sell\" && stockCounts.count(transaction[0])) {\n                stockCounts[transaction[0]]--;\n            }\n        }\n        vector<vector<string>> results;\n        for (const auto& pair : stockCounts) {\n            if (pair.second > 0) {\n                results.push_back({pair.first, to_string(pair.second)});\n            }\n        }\n        return results;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> transactions1 = {{\"LEARN\", \"buy\"}, {\"APPLE\", \"sell\"}};\n    vector<vector<string>> expected1 = {{\"LEARN\", \"1\"}};\n    auto result1 = solution.marketAnalysis(transactions1);\n    if (result1 != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n    } else {\n        cout << \"Test case 1 passed.\" << endl;\n    }\n\n    // Test case 2\n    vector<vector<string>> transactions2 = {{\"GOOGL\", \"buy\"}, {\"MSFT\", \"sell\"}, {\"AAPL\", \"buy\"}};\n    vector<vector<string>> expected2 = {{\"GOOGL\", \"0\"}, {\"MSFT\", \"-1\"}, {\"AAPL\", \"1\"}};\n    auto result2 = solution.marketAnalysis(transactions2);\n    if (result2 != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n    } else {\n        cout << \"Test case 2 passed.\" << endl;\n    }\n\n    // Test case 3\n    vector<vector<string>> transactions3 = {{\"AMZN\", \"buy\"}, {\"AMZN\", \"sell\"}};\n    vector<vector<string>> expected3 = {{\"AMZN\", \"0\"}};\n    auto result3 = solution.marketAnalysis(transactions3);\n    if (result3 != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n    } else {\n        cout << \"Test case 3 passed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1160": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> wordSubsets(vector<string>& words1, vector<string>& words2) {\n        unordered_map<char, int> charCount1, charCount2;\n        \n        for (const string& word : words1) {\n            for (char c : word) {\n                charCount1[c]++;\n            }\n        }\n        \n        for (const string& word : words2) {\n            for (char c : word) {\n                charCount2[c]++;\n            }\n        }\n        \n        vector<string> result;\n        for (const auto& p : charCount1) {\n            if (charCount2.find(p.first) == charCount2.end() || p.second > charCount2[p.first]) continue;\n            int count = 0;\n            string word;\n            for (int i = 0; i < words2.size(); ++i) {\n                int j = 0;\n                bool found = true;\n                while (j < words2[i].size()) {\n                    if (words2[i][j] == p.first && p.second > count + 1) {\n                        found = false;\n                        break;\n                    }\n                    ++count;\n                    ++j;\n                }\n                if (!found) continue;\n                word = words2[i];\n                break;\n            }\n            result.push_back(word);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<string> words1 = {\"a\", \"b\", \"c\"};\n    vector<string> words2 = {\"aa\", \"bb\", \"ccc\"};\n    cout << \"[\";\n    for (const string& word : solution.wordSubsets(words1, words2)) {\n        cout << \"\\\"\" << word << \"\\\", \";\n    }\n    cout << \"]\" << endl;\n    \n    words1 = {\"a\", \"b\"};\n    words2 = {\"aa\", \"aaa\", \"aaaa\", \"aaaaa\"};\n    cout << \"[\";\n    for (const string& word : solution.wordSubsets(words1, words2)) {\n        cout << \"\\\"\" << word << \"\\\", \";\n    }\n    cout << \"]\" << endl;\n    \n    words1 = {\"ab\", \"c\"};\n    words2 = {\"aa\", \"aaa\", \"aaaa\", \"baa\", \"bab\"};\n    cout << \"[\";\n    for (const string& word : solution.wordSubsets(words1, words2)) {\n        cout << \"\\\"\" << word << \"\\\", \";\n    }\n    cout << \"]\" << endl;\n    \n    return 0;\n}\n```",
  "1161": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxLevelSum(TreeNode* root) {\n        if (!root) return 0;\n        \n        vector<vector<int>> levels;\n        int level = 0, maxSum = 0;\n        queue<TreeNode*> q;\n\n        q.push(root);\n        while (!q.empty()) {\n            int len = q.size();\n            int sum = 0;\n            for (int i = 0; i < len; ++i) {\n                TreeNode* node = q.front(); q.pop();\n                sum += node->val;\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            levels.push_back({level, sum});\n            level++;\n        }\n\n        for (auto &p : levels)\n            if (p[1] > maxSum) maxSum = p[1];\n\n        return levels.size() - (maxSum != 0);\n    }\n};\n\nint main() {\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(14);\n    root1->right = new TreeNode(0);\n    root1->left->left = new TreeNode(-3);\n    root1->left->right = new TreeNode(9);\n    root1->right->left = new TreeNode(4);\n    root1->right->right = new TreeNode(6);\n\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(-3);\n\n    TreeNode* root3 = new TreeNode(3);\n    root3->left = new TreeNode(0);\n    root3->right = new TreeNode(-1);\n    root3->left->left = new TreeNode(4);\n    root3->left->right = new TreeNode(7);\n\n    Solution s;\n    cout << \"Test 1: \" << s.maxLevelSum(root1) << endl; // Expected output: 2\n    cout << \"Test 2: \" << s.maxLevelSum(root2) << endl; // Expected output: 3\n    cout << \"Test 3: \" << s.maxLevelSum(root3) << endl; // Expected output: 2\n\n    return 0;\n}\n```",
  "1162": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> highAndLow(int grid[][]){\n        int m = sizeof(grid) / sizeof(grid[0]);\n        int n = grid[0].size();\n        vector<vector<int>> res(m, vector<int>(n));\n        queue<pair<int, int>> q;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    q.push({i, j});\n                    res[i][j] = 0;\n                } else {\n                    res[i][j] = INT_MAX;\n                }\n            }\n        }\n        \n        int dx[] = {-1, 1, 0, 0};\n        int dy[] = {0, 0, -1, 1};\n        \n        while (!q.empty()) {\n            pair<int, int> p = q.front();\n            q.pop();\n            \n            for (int i = 0; i < 4; i++) {\n                int x = p.first + dx[i];\n                int y = p.second + dy[i];\n                \n                if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 1) {\n                    res[x][y] = min(res[x][y], res[p.first][p.second] + 1);\n                    q.push({x, y});\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test case 1:\n    int grid1[][] = {{0,0,1,0},{0,0,1,0},{0,0,1,0}};\n    vector<vector<int>> res1 = s.highAndLow(grid1);\n    for (const auto& row : res1) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2:\n    int grid2[][] = {{0,1},{0,1}};\n    vector<vector<int>> res2 = s.highAndLow(grid2);\n    for (const auto& row : res2) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3:\n    int grid3[][] = {{0,1,1},{1,1,1},{1,1,1}};\n    vector<vector<int>> res3 = s.highAndLow(grid3);\n    for (const auto& row : res3) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1163": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint lastSubstrLex(std::string s) {\n    int n = s.size();\n    if (n == 0) return -1;\n    \n    int res = 0;\n    for (int i = 1; i <= n; ++i) {\n        std::string t = s.substr(0, i);\n        bool ok = true;\n        for (int j = 0; j < i; ++j) {\n            if (t[j] > t[i - 1]) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) res = i;\n    }\n    \n    return res;\n}\n\nint main() {\n    std::cout << lastSubstrLex(\"abc\") << std::endl; // Expected output: 3\n    std::cout << lastSubstrLex(\"abca\") << std::endl; // Expected output: 5\n    std::cout << lastSubstrLex(\"abcde\") << std::endl; // Expected output: 5\n\n    return 0;\n}\n```",
  "1165": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findShortestSubArray(vector<string>& nums) {\n        map<int, pair<int, int>> group;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (!group.count(nums[i][0])) {\n                group[nums[i][0]] = {i, i};\n            }\n            group[nums[i][0]].second = i;\n        }\n        \n        int minLen = INT_MAX;\n        for (auto& it : group) {\n            minLen = min(minLen, it.second.second - it.second.first + 1);\n        }\n        \n        return minLen;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> nums1 = {\"code\"};\n    cout << solution.findShortestSubArray(nums1) << endl; // Output: 5\n\n    vector<string> nums2 = {\"hello\", \"i\", \"am\", \"coding\", \"code\", \"fight\", \"cod\"};\n    cout << solution.findShortestSubArray(nums2) << endl; // Output: 3\n\n    vector<string> nums3 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\"};\n    cout << solution.findShortestSubArray(nums3) << endl; // Output: 1\n\n    return 0;\n}\n```",
  "1164": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct SalesData {\n    int id;\n    string date;\n    double price;\n};\n\nclass Solution {\npublic:\n    vector<double> productPrices(vector<SalesData>& sales, string date) {\n        vector<double> prices;\n        for (const auto& sale : sales) {\n            if (sale.date == date) {\n                prices.push_back(sale.price);\n            }\n        }\n        return prices;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<SalesData> sales1 = {{1, \"2022-01-01\", 10.0}, {2, \"2022-01-02\", 20.0}};\n    string date1 = \"2022-01-01\";\n    vector<double> prices1 = solution.productPrices(sales1, date1);\n    cout << \"Test Case 1: \";\n    for (const auto& price : prices1) {\n        cout << price << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<SalesData> sales2 = {{3, \"2022-01-03\", 30.0}, {4, \"2022-01-04\", 40.0}};\n    string date2 = \"2022-01-03\";\n    vector<double> prices2 = solution.productPrices(sales2, date2);\n    cout << \"Test Case 2: \";\n    for (const auto& price : prices2) {\n        cout << price << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<SalesData> sales3 = {{1, \"2022-01-02\", 20.0}, {5, \"2022-01-05\", 50.0}};\n    string date3 = \"2022-01-04\";\n    vector<double> prices3 = solution.productPrices(sales3, date3);\n    cout << \"Test Case 3: \";\n    for (const auto& price : prices3) {\n        cout << price << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1167": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int connectSticks(vector<int>& sticks) {\n        priority_queue<long long, vector<long long>, greater<long long>> pq;\n        \n        for (int stick : sticks) {\n            pq.push((long long)stick);\n        }\n        \n        long long cost = 0;\n        while (pq.size() > 1) {\n            long long a = pq.top();\n            pq.pop();\n            long long b = pq.top();\n            pq.pop();\n            \n            cost += a + b;\n            pq.push(a + b);\n        }\n        \n        return cost;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> sticks1 = {2,4,3};\n    cout << \"Minimum cost to connect sticks in test case 1: \" << solution.connectSticks(sticks1) << endl;\n\n    // Test case 2\n    vector<int> sticks2 = {1,8,2,4,7};\n    cout << \"Minimum cost to connect sticks in test case 2: \" << solution.connectSticks(sticks2) << endl;\n\n    // Test case 3\n    vector<int> sticks3 = {5};\n    cout << \"Minimum cost to connect sticks in test case 3: \" << solution.connectSticks(sticks3) << endl;\n\n    return 0;\n}\n```",
  "1166": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass FileSystem {\npublic:\n    void mkdir(string parentDir, string dir) {\n        if (parentDir.empty()) {\n            dirs[dir] = {};\n        } else {\n            auto& pdir = dirs[parentDir];\n            if (!pdir.count(dir)) pdir[dir] = {};\n        }\n    }\n\n    bool exists(string path) {\n        if (path.empty()) return true;\n        auto it = dirs.begin();\n        for (const auto& p : splitPath(path)) {\n            while (it != dirs.end() && !it->first.compare(p)) {\n                it++;\n            }\n            if (it == dirs.end()) return false;\n            it++;\n        }\n        return true;\n    }\n\nprivate:\n    unordered_map<string, unordered_map<string, void>> dirs;\n\n    vector<string> splitPath(string path) {\n        vector<string> res;\n        for (char c : path) {\n            if (c == '/') {\n                res.push_back(\"/\");\n            } else if (c != '\\\\') {\n                res.push_back(c + \"\");\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    FileSystem fs;\n\n    // Test Case 1\n    fs.mkdir(\"\", \"dir1\");\n    cout << fs.exists(\"\") << endl; // True\n    cout << fs.exists(\"/\") << endl; // True\n    cout << fs.exists(\"dir1\") << endl; // True\n    cout << fs.exists(\"/dir1\") << endl; // True\n\n    // Test Case 2\n    fs.mkdir(\"dir1\", \"subdir1\");\n    fs.mkdir(\"dir1\", \"subdir2\");\n    cout << fs.exists(\"\") << endl; // True\n    cout << fs.exists(\"/\") << endl; // True\n    cout << fs.exists(\"/dir1\") << endl; // True\n    cout << fs.exists(\"/dir1/subdir1\") << endl; // True\n    cout << fs.exists(\"/dir1/subdir2\") << endl; // True\n\n    // Test Case 3\n    cout << fs.exists(\"nonexistent/path\") << endl; // False\n    return 0;\n}",
  "1168": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCostToSupplyWater(int n, vector<vector<int>>& wells) {\n        vector<pair<int, int>> edges;\n        for (int i = 0; i < n; ++i) {\n            edges.emplace_back(i + 1, -wells[i][0], wells[i][1]);\n        }\n        \n        sort(edges.begin(), edges.end());\n        \n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n        for (const auto& edge : edges) {\n            int u = edge.second;\n            int v = edge.first;\n            \n            while (!pq.empty() && pq.top().first > u) {\n                v += pq.top().second;\n                pq.pop();\n            }\n            \n            if (v < n) {\n                pq.push({u + v, v});\n            }\n        }\n        \n        return accumulate(cbegin(pq), cend(pq), 0LL) / 2;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int n1 = 3;\n    vector<vector<int>> wells1 = {{1, 1}, {2, 2}, {3, 5}};\n    cout << \"Test case 1: \" << solution.minCostToSupplyWater(n1, wells1) << endl; // Output: 6\n\n    int n2 = 4;\n    vector<vector<int>> wells2 = {{1, 12}, {2, 6}, {3, 5}, {4, 11}};\n    cout << \"Test case 2: \" << solution.minCostToSupplyWater(n2, wells2) << endl; // Output: 17\n\n    int n3 = 5;\n    vector<vector<int>> wells3 = {{1, 100000}, {2, 90000}, {3, 75000}, {4, 60000}, {5, 50000}};\n    cout << \"Test case 3: \" << solution.minCostToSupplyWater(n3, wells3) << endl; // Output: 250000\n\n    return 0;\n}\n```",
  "1169": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nbool validTransaction(vector<vector<string>>& transactions) {\n    for (const auto& transaction : transactions) {\n        if (transaction.size() != 4 || \n            transaction[0].empty() || \n            transaction[1].empty() || \n            transaction[2].empty()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    vector<vector<string>> transactions1 = {{\"1\", \"John\", \"A\", \"3\"}, {\"2\", \"Alice\", \"B\", \"5\"}};\n    cout << (validTransaction(transactions1) ? \"Valid\" : \"Invalid\") << endl;\n\n    vector<vector<string>> transactions2 = {{\"1\", \"John\", \"A\", \"4\"}, {\"2\", \"Alice\", \"B\", \"3\"}};\n    cout << (validTransaction(transactions2) ? \"Valid\" : \"Invalid\") << endl;\n\n    vector<vector<string>> transactions3 = {{\"1\", \"\", \"A\", \"10\"}, {\"2\", \"Alice\", \"B\", \"\"}};\n    cout << (validTransaction(transactions3) ? \"Valid\" : \"Invalid\") << endl;\n    \n    return 0;\n}\n```",
  "1170": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool comparison(vector<string>& strings) {\n        map<char, int> freq;\n        for (auto str : strings) {\n            for (char c : str) {\n                freq[c]++;\n            }\n        }\n        \n        int minFreq = INT_MAX;\n        char smallestChar = 'a';\n        \n        for (auto p : freq) {\n            if (p.second < minFreq) {\n                minFreq = p.second;\n                smallestChar = p.first;\n            }\n        }\n        \n        for (auto str : strings) {\n            if (str.find(smallestChar) == string::npos || count(str.begin(), str.end(), smallestChar) != minFreq) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<string> strs1 = {\"apple\", \"app\", \"banana\"};\n    cout << (solution.comparison(strs1) ? \"true\" : \"false\") << endl;\n\n    vector<string> strs2 = {\"aaple\", \"app\", \"banaaa\"};\n    cout << (solution.comparison(strs2) ? \"true\" : \"false\") << endl;\n\n    vector<string> strs3 = {\"abc\", \"bcd\", \"cde\"};\n    cout << (solution.comparison(strs3) ? \"true\" : \"false\") << endl;\n    \n    return 0;\n}\n```",
  "1171": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* removeZeroSumConsecutiveNodes(ListNode* head) {\n    if (!head || !head->next) return head;\n\n    ListNode dummy(0);\n    dummy.next = head;\n    ListNode* prev = &dummy;\n    int sum = 0;\n\n    while (head) {\n        sum += head->val;\n        if (sum == 0) {\n            prev = head;\n        } else if (sum < 0) {\n            sum = 0;\n            prev = head;\n        } else {\n            head = head->next;\n        }\n    }\n\n    return dummy.next;\n}\n\nint main() {\n    // Test case 1\n    ListNode* head1 = new ListNode(3);\n    head1->next = new ListNode(-2);\n    head1->next->next = new ListNode(0);\n    head1->next->next->next = new ListNode(1);\n    head1->next->next->next->next = new ListNode(-7);\n    head1->next->next->next->next->next = new ListNode(12);\n\n    cout << \"Test case 1: \";\n    ListNode* result1 = removeZeroSumConsecutiveNodes(head1);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test case 2\n    head1 = new ListNode(0);\n    head1->next = new ListNode(0);\n\n    cout << \"Test case 2: \";\n    ListNode* result2 = removeZeroSumConsecutiveNodes(head1);\n    while (result2) {\n        cout << result2->val << \" \";\n        result2 = result2->next;\n    }\n    cout << endl;\n\n    // Test case 3\n    head1 = new ListNode(0);\n\n    cout << \"Test case 3: \";\n    ListNode* result3 = removeZeroSumConsecutiveNodes(head1);\n    while (result3) {\n        cout << result3->val << \" \";\n        result3 = result3->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1172": "```\n#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nclass DinnerPlates {\npublic:\n    stack<vector<int>> plates;\n    \n    void push(int val) {\n        for (auto& plate : plates) {\n            if (!plate.empty()) {\n                plate.push(val);\n                return;\n            }\n        }\n        vector<int> newPlate = {val};\n        plates.push(newPlate);\n    }\n    \n    int pop() {\n        while (!plates.empty() && plates.top().empty()) {\n            plates.pop();\n        }\n        if (plates.empty()) {\n            return -1;\n        }\n        auto plate = plates.top();\n        plates.pop();\n        int val = plate.back();\n        plate.pop();\n        if (plate.empty()) {\n            plates.pop();\n        }\n        return val;\n    }\n};\n\nint main() {\n    DinnerPlates dinnerPlates;\n\n    // Test Case 1\n    dinnerPlates.push(1);\n    dinnerPlates.push(2);\n    cout << \"Pop: \" << dinnerPlates.pop() << endl; // Output: 2\n    dinnerPlates.push(3);\n    cout << \"Pop: \" << dinnerPlates.pop() << endl; // Output: 3\n    dinnerPlates.push(4);\n    cout << \"Pop: \" << dinnerPlates.pop() << endl; // Output: 1\n\n    // Test Case 2\n    dinnerPlates = DinnerPlates();\n    dinnerPlates.push(10);\n    dinnerPlates.push(5);\n    dinnerPlates.push(12);\n    dinnerPlates.push(7);\n    cout << \"Pop: \" << dinnerPlates.pop() << endl; // Output: 12\n    dinnerPlates.push(3);\n    cout << \"Pop: \" << dinnerPlates.pop() << endl; // Output: 7\n    cout << \"Pop: \" << dinnerPlates.pop() << endl; // Output: 5\n    cout << \"Pop: \" << dinnerPlates.pop() << endl; // Output: 10\n    cout << \"Pop: \" << dinnerPlates.pop() << endl; // Output: 3\n\n    // Test Case 3\n    dinnerPlates = DinnerPlates();\n    for (int i = 1; i <= 5; ++i) {\n        dinnerPlates.push(i);\n    }\n    for (int i = 6; i <= 10; ++i) {\n        dinnerPlates.push(i);\n    }\n    while (!dinnerPlates.plates.empty()) {\n        cout << \"Pop: \" << dinnerPlates.pop() << endl;\n    }\n\n    return 0;\n}\n```",
  "1173": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minStones(int numOrders, vector<int>& dist) {\n        int n = numOrders;\n        vector<int> res(n);\n        \n        for (int i = 0; i < n; i++) {\n            res[i] = dist[(i + 1) % n];\n        }\n        \n        return *min_element(res.begin(), res.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    int numOrders1 = 3;\n    vector<int> dist1 = {1, 2, 3};\n    cout << \"Test case 1: Min stones for \" << numOrders1 << \" orders with distance \" << endl;\n    cout << \"Distance array: \";\n    for (int i : dist1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    cout << \"Result: \" << solution.minStones(numOrders1, dist1) << endl;\n    cout << endl;\n\n    // Test case 2:\n    int numOrders2 = 4;\n    vector<int> dist2 = {5, 3, 2, 6};\n    cout << \"Test case 2: Min stones for \" << numOrders2 << \" orders with distance \" << endl;\n    cout << \"Distance array: \";\n    for (int i : dist2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    cout << \"Result: \" << solution.minStones(numOrders2, dist2) << endl;\n    cout << endl;\n\n    // Test case 3:\n    int numOrders3 = 5;\n    vector<int> dist3 = {1, 3, 6, 7, 4};\n    cout << \"Test case 3: Min stones for \" << numOrders3 << \" orders with distance \" << endl;\n    cout << \"Distance array: \";\n    for (int i : dist3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    cout << \"Result: \" << solution.minStones(numOrders3, dist3) << endl;\n\n    return 0;\n}\n```",
  "1174": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minInitialEnergy(int initialEnergy, vector<vector<int>>& wounds) {\n        int total = 0;\n        for (auto& wound : wounds) {\n            total += wound[1];\n        }\n        return max(initialEnergy - total, 0);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int initialEnergy1 = 5;\n    vector<vector<int>> wounds1 = {{10, 5}, {3, 2}};\n    cout << \"Test Case 1: \" << solution.minInitialEnergy(initialEnergy1, wounds1) << endl; // Output: 0\n\n    // Test Case 2\n    int initialEnergy2 = 30;\n    vector<vector<int>> wounds2 = {{10, 5}, {3, 2}};\n    cout << \"Test Case 2: \" << solution.minInitialEnergy(initialEnergy2, wounds2) << endl; // Output: 25\n\n    // Test Case 3\n    int initialEnergy3 = 0;\n    vector<vector<int>> wounds3 = {{10, 5}, {3, 2}};\n    cout << \"Test Case 3: \" << solution.minInitialEnergy(initialEnergy3, wounds3) << endl; // Output: 0\n\n    return 0;\n}\n```",
  "1175": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numPrimeArrangements(int n) {\n        int res = 1;\n        for (int i = 2; i <= n; ++i) {\n            if (isPrime(i)) res *= i;\n        }\n        return res;\n    }\n\n    bool isPrime(int x) {\n        if (x < 2) return false;\n        for (int i = 2, sqrtX = (int)sqrt(x); i <= sqrtX; ++i)\n            if (x % i == 0) return false;\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int n1 = 10;\n    cout << \"For n=\" << n1 << \": \" << solution.numPrimeArrangements(n1) << endl;\n\n    int n2 = 25;\n    cout << \"For n=\" << n2 << \": \" << solution.numPrimeArrangements(n2) << endl;\n\n    int n3 = 100;\n    cout << \"For n=\" << n3 << \": \" << solution.numPrimeArrangements(n3) << endl;\n\n    return 0;\n}\n```",
  "1176": "```\n#include <iostream>\n#include <vector>\n\nint maxPerformance(int n, std::vector<int>& speed, int** efficiency) {\n    std::vector<std::pair<int, int>> players(n);\n    for (int i = 0; i < n; ++i) {\n        players[i] = {speed[i], efficiency[i][1]};\n    }\n    \n    std::sort(players.begin(), players.end(), [](const auto& a, const auto& b) {\n        return a.second > b.second;\n    });\n    \n    int maxPerf = 0;\n    long long sumSpeed = 0;\n    for (int i = n - 1; i >= 0; --i) {\n        sumSpeed += players[i].first;\n        maxPerf = std::max(maxPerf, (long long)players[i].second * sumSpeed);\n    }\n    \n    return maxPerf;\n}\n\nint main() {\n    int n1 = 4;\n    int speed1[] = {2, 6, 3, 4};\n    int efficiency1[][] = {{70, 180}, {60, 210}, {60, 120}, {50, 100}};\n    \n    std::cout << \"Test case 1: \" << maxPerformance(n1, speed1, efficiency1) << std::endl;\n    \n    int n2 = 3;\n    int speed2[] = {4, 5, 6};\n    int efficiency2[][] = {{70, 150}, {55, 125}, {40, 110}};\n    \n    std::cout << \"Test case 2: \" << maxPerformance(n2, speed2, efficiency2) << std::endl;\n    \n    int n3 = 1;\n    int speed3[] = {10};\n    int efficiency3[][] = {{50, 1000}};\n    \n    std::cout << \"Test case 3: \" << maxPerformance(n3, speed3, efficiency3) << std::endl;\n    \n    return 0;\n}",
  "1177": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canMakePalindrome(string s) {\n        vector<int> count(128, 0);\n        for (char c : s) {\n            count[c]++;\n        }\n        int oddCount = 0;\n        for (int i = 97; i <= 122; i++) { // ASCII values of 'a' to 'z'\n            if ((count[i] % 2) != 0) {\n                oddCount++;\n                if (oddCount > 1) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s1 = \"abcba\";\n    cout << \"Test case 1: \" << (solution.canMakePalindrome(s1) ? \"True\" : \"False\") << endl; // Output: True\n\n    // Test case 2\n    string s2 = \"abccba\";\n    cout << \"Test case 2: \" << (solution.canMakePalindrome(s2) ? \"True\" : \"False\") << endl; // Output: False\n\n    // Test case 3\n    string s3 = \"abcde\";\n    cout << \"Test case 3: \" << (solution.canMakePalindrome(s3) ? \"True\" : \"False\") << endl; // Output: True\n\n    return 0;\n}\n```",
  "1179": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Department {\n    std::string name;\n    std::vector<std::string> employees;\n};\n\nvoid reformatTable(std::vector<Department>& departments) {\n    for (auto& department : departments) {\n        int i = 0;\n        std::string tempName = \"\";\n        for (const auto& employee : department.employees) {\n            if (i >= tempName.length()) {\n                tempName += employee + \" \";\n            } else {\n                tempName.insert(i, \" - \") + employee;\n                i++;\n            }\n        }\n        department.name = tempName;\n    }\n}\n\nint main() {\n    std::vector<Department> departments;\n\n    // Test case 1\n    Department d1;\n    d1.name = \"Sales\";\n    d1.employees = {\"John\", \"Mike\", \"Emma\"};\n    departments.push_back(d1);\n\n    // Test case 2\n    Department d2;\n    d2.name = \"IT\";\n    d2.employees = {\"Sarah\", \"Tom\", \"Olivia\"};\n    departments.push_back(d2);\n\n    // Test case 3\n    Department d3;\n    d3.name = \"Marketing\";\n    d3.employees = {\"James\", \"Nancy\", \"Robert\"};\n    departments.push_back(d3);\n\n    reformatTable(departments);\n\n    for (const auto& department : departments) {\n        std::cout << department.name << \"\\n\";\n        for (const auto& employee : department.employees) {\n            std::cout << employee << \"\\n\";\n        }\n        std::cout << \"---------------------------------\\n\";\n    }\n\n    return 0;\n}",
  "1178": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findNumOfValidWords(vector<string>& puzzles, vector<string[]> wordList) {\n        unordered_map<char, int> puzzleMap;\n        for (string& p : puzzles) {\n            for (char c : p) {\n                puzzleMap[c]++;\n            }\n        }\n\n        vector<int> result(wordList.size(), 0);\n        for (int i = 0; i < wordList.size(); i++) {\n            string& word = wordList[i][0];\n            bool isValid = true;\n            unordered_map<char, int> wordMap;\n            for (char c : word) {\n                wordMap[c]++;\n                if (!puzzleMap.count(c) || wordMap[c] > puzzleMap[c]) {\n                    isValid = false;\n                    break;\n                }\n            }\n            if (isValid) {\n                result[i] = 1;\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<string> puzzles1 = {\"abc\", \"def\"};\n    vector<string[]> wordList1 = {{\"word\",\"world\"}, {\"apple\",\"apply\",\"apricot\"}};\n    vector<int> expectedResult1 = {1, 2};\n    vector<int> actualResult1 = solution.findNumOfValidWords(puzzles1, wordList1);\n    if (actualResult1 == expectedResult1) {\n        cout << \"Test Case 1: Passed\" << endl;\n    } else {\n        cout << \"Test Case 1: Failed\" << endl;\n    }\n\n    // Test Case 2\n    vector<string> puzzles2 = {\"a\", \"b\"};\n    vector<string[]> wordList2 = {{\"a\",\"ab\"}, {\"advice\",\"adive\"}};\n    vector<int> expectedResult2 = {0, 1};\n    vector<int> actualResult2 = solution.findNumOfValidWords(puzzles2, wordList2);\n    if (actualResult2 == expectedResult2) {\n        cout << \"Test Case 2: Passed\" << endl;\n    } else {\n        cout << \"Test Case 2: Failed\" << endl;\n    }\n\n    // Test Case 3\n    vector<string> puzzles3 = {\"h\",\"o\"};\n    vector<string[]> wordList3 = {{\"hello\",\"hold\",\"home\"}};\n    vector<int> expectedResult3 = {1};\n    vector<int> actualResult3 = solution.findNumOfValidWords(puzzles3, wordList3);\n    if (actualResult3 == expectedResult3) {\n        cout << \"Test Case 3: Passed\" << endl;\n    } else {\n        cout << \"Test Case 3: Failed\" << endl;\n    }\n\n    return 0;\n}",
  "1180": "```\n#include <iostream>\n#include <string>\n\nint countSubstrings(const std::string& s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        char c = s[i];\n        bool isUnique = true;\n        for (int j = i; j < s.length() && s[j] == c; ++j) {\n            if (s.find(s[j]) != s.find(c)) {\n                isUnique = false;\n                break;\n            }\n        }\n        if (!isUnique) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << countSubstrings(\"abc\") << std::endl; // expected output: 2\n    std::cout << \"Test case 2: \" << countSubstrings(\"aaa\") << std::endl; // expected output: 0\n    std::cout << \"Test case 3: \" << countSubstrings(\"aaabbbccc\") << std::endl; // expected output: 3\n    \n    return 0;\n}",
  "1181": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool areSentencesSimilar(std::vector<std::string>& sentences, int a, int b) {\n    if (a > b) std::swap(a, b);\n    for (int i = 0; i <= b - a; ++i) {\n        if (sentences[a + i] != sentences[b - i]) return false;\n    }\n    return true;\n}\n\nint main() {\n    std::vector<std::string> sentences1 = {\"great\", \"working\", \"good\"};\n    int a1 = 0, b1 = 2;\n    std::cout << (areSentencesSimilar(sentences1, a1, b1) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<std::string> sentences2 = {\"great\", \"working\", \"good\", \"best\"};\n    int a2 = 0, b2 = 3;\n    std::cout << (areSentencesSimilar(sentences2, a2, b2) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<std::string> sentences3 = {\"1-ok\", \"1-optional\", \"1-required\", \"2-ok\", \"2-optional\", \"2-required\"};\n    int a3 = 4, b3 = 5;\n    std::cout << (areSentencesSimilar(sentences3, a3, b3) ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n```",
  "1183": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxOnes(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int ones = 0, zeros = 0;\n    for (auto num : nums) {\n        if (num == 1) ones++;\n        else zeros++;\n    }\n    return std::min(ones, zeros);\n}\n\nint main() {\n    std::vector<int> test1({0, 1});\n    std::cout << \"Test Case 1: \" << maxOnes(test1) << std::endl;\n    \n    std::vector<int> test2({0, 1, 0, 0, 1});\n    std::cout << \"Test Case 2: \" << maxOnes(test2) << std::endl;\n    \n    std::vector<int> test3({1, 1, 1, 1, 0, 0, 0, 0, 0, 1});\n    std::cout << \"Test Case 3: \" << maxOnes(test3) << std::endl;\n\n    return 0;\n}\n```",
  "1182": "```\n#include <iostream>\n#include <vector>\n\nint findShortestSubArray(std::vector<int>& arr) {\n    int start = -1, end = -1, minLen = arr.size();\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] != arr[0]) {\n            if (start == -1) {\n                start = i;\n            }\n            end = i;\n            minLen = std::min(minLen, end - start + 1);\n        } else {\n            start = -1;\n            end = -1;\n        }\n    }\n    return minLen;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> arr1({1,2,3,4});\n    int result1 = findShortestSubArray(arr1);\n    std::cout << \"Test case 1: The shortest distance is \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<int> arr2({4,2,0,3,2,5,3});\n    int result2 = findShortestSubArray(arr2);\n    std::cout << \"Test case 2: The shortest distance is \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<int> arr3({1,2,2,3,5});\n    int result3 = findShortestSubArray(arr3);\n    std::cout << \"Test case 3: The shortest distance is \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1184": "```\n#include <iostream>\n#include <vector>\n\nint distanceBetweenBusStops(std::vector<int>& stops) {\n    int totalDistance = 0;\n    for (int i = 0; i < stops.size() - 1; i++) {\n        totalDistance += stdishes[i] + stops[i + 1];\n    }\n    return totalDistance;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {1,2,3,4};\n    std::cout << \"Test Case 1: \" << distanceBetweenBusStops(test1) << std::endl;\n\n    // Test case 2\n    std::vector<int> test2 = {4,5,6,7};\n    std::cout << \"Test Case 2: \" << distanceBetweenBusStops(test2) << std::endl;\n\n    // Test case 3\n    std::vector<int> test3 = {1,100000};\n    std::cout << \"Test Case 3: \" << distanceBetweenBusStops(test3) << std::endl;\n\n    return 0;\n}",
  "1185": "```\n#include <iostream>\n#include <string>\n\nint dayOfWeek(int year, int month, int day) {\n    if (month < 3)\n        month += 12;\n    int q = day + ((13 * (month + 1)) / 5);\n    int y = year - (q > 119 || q <= 244 ? 1 : 0);\n    int d = q % 7;\n\n    if (d < 0)\n        d += 7;\n    \n    return d;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << dayOfWeek(1992, 6, 11) << \" - Expected result: 4\\n\";\n    std::cout << \"Test Case 2: \" << dayOfWeek(2000, 2, 29) << \" - Expected result: 3\\n\";\n    std::cout << \"Test Case 3: \" << dayOfWeek(1988, 1, 12) << \" - Expected result: 0\\n\";\n\n    return 0;\n}\n```",
  "1187": "```\n#include <iostream>\n#include <vector>\n\nint minSteps(std::vector<int>& arr) {\n    int n = arr.size();\n    if (n == 1) return 0;\n\n    std::vector<int> dp(n);\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] <= arr[i - 1]) {\n            dp[i] = dp[i - 1] + (arr[i] - arr[i - 1] + 1);\n        } else {\n            dp[i] = 0;\n        }\n    }\n\n    int minSteps = dp[0];\n    for (int i = 1; i < n; ++i) {\n        if (dp[i] > 0) {\n            minSteps = std::min(minSteps, dp[i]);\n        }\n    }\n\n    return minSteps;\n}\n\nint main() {\n    {\n        std::vector<int> arr1({1, 5, 2, 4, 3});\n        int res1 = minSteps(arr1);\n        if (res1 == 14) {\n            std::cout << \"Test case 1 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 1 failed. Expected: 14, Got: \" << res1 << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> arr2({3, 6, 7, 10});\n        int res2 = minSteps(arr2);\n        if (res2 == 4) {\n            std::cout << \"Test case 2 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 2 failed. Expected: 4, Got: \" << res2 << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> arr3({1});\n        int res3 = minSteps(arr3);\n        if (res3 == 0) {\n            std::cout << \"Test case 3 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 3 failed. Expected: 0, Got: \" << res3 << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "1186": "```\n#include <iostream>\n#include <vector>\n\nint maximumSum(vector<int>& nums) {\n    int n = nums.size();\n    vector<vector<int>> dp(n, vector<int>(n));\n    \n    for (int i = 0; i < n; ++i) {\n        dp[i][i] = nums[i];\n    }\n    \n    for (int len = 2; len <= n; ++len) {\n        for (int i = 0; i < n - len + 1; ++i) {\n            int j = i + len - 1;\n            if (nums[j] > 0) {\n                dp[i][j] = max(dp[i][j-1], nums[j]) + nums[j];\n            } else {\n                dp[i][j] = max(dp[i+1][j], nums[i]);\n            }\n        }\n    }\n    \n    int sum = -INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] > 0) {\n            int left_sum = dp[0][i];\n            int right_sum = 0;\n            for (int j = i+1; j < n; ++j) {\n                right_sum += nums[j];\n            }\n            sum = max(sum, left_sum + right_sum);\n        }\n    }\n    \n    return sum;\n}\n\nint main() {\n    vector<int> nums1 = {-2,3,-1,5,-3};\n    cout << \"Test case 1: \" << maximumSum(nums1) << endl;\n    \n    vector<int> nums2 = [1,-2,3,10,-4,7,6];\n    cout << \"Test case 2: \" << maximumSum(nums2) << endl;\n    \n    vector<int> nums3 = {1,-5,7,3,-2};\n    cout << \"Test case 3: \" << maximumSum(nums3) << endl;\n    \n    return 0;\n}\n```",
  "1189": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint maxNumberOfBalloons(std::string text) {\n    int bCount = 0;\n    int aCount = 0;\n    int lCount = 0;\n    int oCount = 0;\n\n    for (char c : text) {\n        if (c == 'b') bCount++;\n        else if (c == 'a') aCount++;\n        else if (c == 'l') lCount++;\n        else if (c == 'o') oCount++;\n    }\n\n    int minCount = std::min({bCount, aCount, lCount / 2, oCount * 2});\n    return minCount;\n}\n\nint main() {\n    std::vector<std::string> testCases = {\"loonbalxvalg\", \"leetcode\", \"ballon\"};\n    \n    for (const auto& testCase : testCases) {\n        std::cout << \"Test Case: \" << testCase << \", Max Number of Balloons: \" << maxNumberOfBalloons(testCase) << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1188": "```\n#include <iostream>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <queue>\n\nclass BoundedBlockingQueue {\nprivate:\n    std::queue<int> queue;\n    int capacity;\n    std::mutex mtx;\n    std::condition_variable cv;\n\npublic:\n    BoundedBlockingQueue(int capacity) : capacity(capacity) {}\n\n    void enqueue(int item) {\n        std::unique_lock<stdlock_guard<std::mutex>> lock(mtx);\n        while (queue.size() == capacity) {\n            cv.wait(lock);\n        }\n        queue.push(item);\n    }\n\n    int dequeue() {\n        std::unique_lock<std::mutex> lock(mtx);\n        if (queue.empty()) {\n            cv.wait(lock);\n        }\n        int item = queue.front();\n        queue.pop();\n        return item;\n    }\n};\n\nint main() {\n    BoundedBlockingQueue queue(3);\n\n    // Test case 1: Enqueue, dequeue, enqueue\n    std::thread t1([&queue]() {\n        queue.enqueue(1);\n        int value = queue.dequeue();\n        std::cout << \"Thread 1: dequeued value \" << value << std::endl;\n        queue.enqueue(2);\n    });\n\n    // Test case 2: Enqueue, dequeue, enqueue, dequeue\n    std::thread t2([&queue]() {\n        queue.enqueue(3);\n        int value = queue.dequeue();\n        std::cout << \"Thread 2: dequeued value \" << value << std::endl;\n        queue.enqueue(4);\n        int value2 = queue.dequeue();\n        std::cout << \"Thread 2: dequeued value \" << value2 << std::endl;\n    });\n\n    // Test case 3: Try to enqueue when full\n    std::thread t3([&queue]() {\n        for (int i = 5; i <= 10; ++i) {\n            queue.enqueue(i);\n            int value = queue.dequeue();\n            std::cout << \"Thread 3: dequeued value \" << value << std::endl;\n        }\n    });\n\n    t1.join();\n    t2.join();\n    t3.join();\n\n    return 0;\n}\n```",
  "1190": "```\n#include <iostream>\n#include <string>\n#include <stack>\n\nstd::string reverseParentheses(std::string s) {\n    std::stack<std::string> stack;\n    std::string result = \"\";\n    \n    for (char c : s) {\n        if (c == '(') {\n            if (!result.empty()) {\n                stack.push(result);\n                result = \"\";\n            }\n        } else if (c == ')') {\n            if (!result.empty()) {\n                std::string temp = result;\n                for (int i = temp.size() - 1; i >= 0; --i) {\n                    result += temp[i];\n                }\n                result = temp;\n                stack.pop();\n            }\n        } else {\n            if (!stack.empty()) {\n                result += c;\n            } else {\n                result += c;\n            }\n        }\n    }\n    \n    if (!stack.empty()) {\n        while (!stack.empty()) {\n            std::string temp = stack.top();\n            for (int i = temp.size() - 1; i >= 0; --i) {\n                result += temp[i];\n            }\n            stack.pop();\n        }\n    }\n    \n    return result;\n}\n\nint main() {\n    std::cout << reverseParentheses(\"a(bcdefghijkl(mno)p)\") << std::endl;\n    std::cout << reverseParentheses(\"abc(cba)\" << std::endl;\n    std::cout << reverseParentheses(\"(abcd)\") << std::endl;\n    \n    return 0;\n}\n```",
  "1191": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxResult(vector<int>& nums, int k) {\n        vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            dp[i] = max(dp[i - 1], nums[i]);\n            if (i >= k) {\n                dp[i] = max(dp[i], dp[i - k] + nums[i]);\n            }\n        }\n        return dp.back();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {1, -2, 3, 10};\n    int k1 = 2;\n    cout << \"Test case 1: \" << solution.maxResult(nums1, k1) << endl; // Output: 19\n\n    // Test case 2\n    vector<int> nums2 = [0, 9, 6, 10, -7, 4, -5, 7, -3];\n    int k2 = 3;\n    cout << \"Test case 2: \" << solution.maxResult(nums2, k2) << endl; // Output: 16\n\n    // Test case 3\n    vector<int> nums3 = {1};\n    int k3 = 1;\n    cout << \"Test case 3: \" << solution.maxResult(nums3, k3) << endl; // Output: 1\n\n    return 0;\n}\n```",
  "1193": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Transaction {\n    int day;\n    double amount;\n};\n\ndouble averageTransactionAmount(const std::vector<Transaction>& transactions) {\n    if (transactions.empty()) {\n        return 0.0;\n    }\n\n    double total = 0.0;\n    for (const auto& transaction : transactions) {\n        total += transaction.amount;\n    }\n    return total / transactions.size();\n}\n\nint main() {\n    // Test Case 1\n    std::vector<Transaction> transactions1 = {{31, 100.0}, {28, 50.0}};\n    double result1 = averageTransactionAmount(transactions1);\n    if (std::abs(result1 - 75.0) > 0.01) {\n        std::cerr << \"Test Case 1 failed: expected 75.0, got \" << result1 << std::endl;\n        return 1;\n    }\n\n    // Test Case 2\n    std::vector<Transaction> transactions2 = {{10, 20.0}, {15, 30.0}, {20, 40.0}};\n    double result2 = averageTransactionAmount(transactions2);\n    if (std::abs(result2 - 33.33) > 0.01) {\n        std::cerr << \"Test Case 2 failed: expected 33.33, got \" << result2 << std::endl;\n        return 1;\n    }\n\n    // Test Case 3\n    std::vector<Transaction> transactions3 = {};\n    double result3 = averageTransactionAmount(transactions3);\n    if (std::abs(result3 - 0.0) > 0.01) {\n        std::cerr << \"Test Case 3 failed: expected 0.0, got \" << result3 << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed.\" << std::endl;\n    return 0;\n}\n```",
  "1192": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {\n        vector<vector<int>> res;\n        vector<vector<int>> graph(n);\n        for (auto& edge : connections) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        \n        int time = 0;\n        vector<int> visited(n, -1), low(n, -1), disc(n, -1);\n        \n        for (int i = 0; i < n; ++i) {\n            if (visited[i] == -1)\n                dfs(i, time, visited, low, disc, graph, res);\n        }\n        \n        return res;\n    }\n\nprivate:\n    void dfs(int u, int& time, vector<int>& visited, vector<int>& low, vector<int>& disc, vector<vector<int>>& graph, vector<vector<int>>& res) {\n        visited[u] = time++;\n        low[u] = time++;\n        disc[u] = time++;\n        \n        for (int v : graph[u]) {\n            if (visited[v] == -1) {\n                dfs(v, time, visited, low, disc, graph, res);\n                low[u] = min(low[u], low[v]);\n                \n                if (low[v] > disc[u])\n                    res.push_back({u, v});\n            }\n            else if (v != disc[v]) \n                low[u] = min(low[u], disc[v]);\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    int n1 = 4;\n    vector<vector<int>> connections1 = {{0,1},{1,2},{2,3}};\n    vector<vector<int>> res1 = solution.criticalConnections(n1, connections1);\n    for (auto& edge : res1) {\n        cout << \"(\" << edge[0] << \", \" << edge[1] << \") \";\n    }\n    cout << endl;\n\n    // Test case 2\n    int n2 = 10;\n    vector<vector<int>> connections2 = {{5,6},{5,7},{6,8},{6,9},{7,8},{7,9},{0,1},{2,3}};\n    vector<vector<int>> res2 = solution.criticalConnections(n2, connections2);\n    for (auto& edge : res2) {\n        cout << \"(\" << edge[0] << \", \" << edge[1] << \") \";\n    }\n    cout << endl;\n\n    // Test case 3\n    int n3 = 9;\n    vector<vector<int>> connections3 = {{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{7,8}};\n    vector<vector<int>> res3 = solution.criticalConnections(n3, connections3);\n    for (auto& edge : res3) {\n        cout << \"(\" << edge[0] << \", \" << edge[1] << \") \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1194": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> findWinners(const std::vector<std::vector<int>>& edges) {\n    // Your solution here\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> edges1 = {{2, 3}, {1, 3}, {5, 4}};\n    auto winners1 = findWinners(edges1);\n    for (const auto& winner : winners1) {\n        std::cout << winner << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<std::vector<int>> edges2 = {{3, 4}, {5, 6}};\n    auto winners2 = findWinners(edges2);\n    for (const auto& winner : winners2) {\n        std::cout << winner << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<std::vector<int>> edges3 = {};\n    auto winners3 = findWinners(edges3);\n    for (const auto& winner : winners3) {\n        std::cout << winner << \" \";\n    }\n    std::cout << std::endl;\n}\n```",
  "1195": "```\n#include <iostream>\n#include <thread>\n#include <mutex>\n\nclass FizzBuzz {\nprivate:\n    int n;\n    std::mutex mtx;\n\npublic:\n    FizzBuzz(int n) : n(n) {}\n\n    void run() {\n        for (int i = 1; i <= n; ++i) {\n            std::string result;\n            if (i % 3 == 0)\n                result += \"Fizz\";\n            if (i % 5 == 0)\n                result += \"Buzz\";\n            if (result.empty())\n                result = std::to_string(i);\n\n            {\n                std::lock_guard<std::mutex> lock(mtx);\n                std::cout << result << \"\\n\";\n            }\n        }\n    }\n};\n\nint main() {\n    FizzBuzz fb1(15);\n    std::thread t1(&FizzBuzz::run, &fb1);\n\n    FizzBuzz fb2(5);\n    std::thread t2(&FizzBuzz::run, &fb2);\n\n    FizzBuzz fb3(10);\n    std::thread t3(&FizzBuzz::run, &fb3);\n\n    t1.join();\n    t2.join();\n    t3.join();\n\n    return 0;\n}\n```",
  "1196": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxApples(int rows, int cols) {\n    if (rows == 0 || cols == 0) return 0;\n    \n    std::vector<int> rowSizes(cols + 1);\n    for (int i = 0; i <= cols; ++i) rowSizes[i] = i;\n\n    for (int i = 1; i < rows; ++i) {\n        int prevRowSize = rowSizes[cols];\n        if (prevRowSize > cols) break;\n        int currentRowSize = 2 * prevRowRow + 3;\n        while (currentRowSize > cols) {\n            --currentRowSize;\n            ++rowSizes[cols - 1];\n        }\n    }\n\n    return rowSizes[cols] * rows;\n}\n\nint main() {\n    std::cout << maxApples(4, 2) << std::endl; // Output: 8\n    std::cout << maxApples(5, 3) << std::endl; // Output: 18\n    std::cout << maxApples(10, 6) << std::endl; // Output: 60\n\n    return 0;\n}\n```",
  "1197": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint minKnightMoves(int x1, int y1, int x2, int y2) {\n    if (x1 == x2 && y1 == y2) return 0;\n    \n    vector<vector<int>> dirs = {{-2, -1}, {-2, 1}, {-1, -2}, {1, -2}, \n                                 {-2, -2}, {2, -2}, {2, 2}, {-2, 2}, \n                                 {1, 2}, {2, 1}};\n    \n    queue<pair<int, int>> q;\n    q.push({x1, y1});\n    vector<vector<bool>> visited(8, vector<bool>(8, false));\n    visited[x1][y1] = true;\n    int moves = 0;\n    \n    while (!q.empty()) {\n        int x, y;\n        tie(x, y) = q.front(); q.pop();\n        \n        if (x == x2 && y == y2) return moves;\n        \n        for (auto dir : dirs) {\n            int newX = x + dir[0], newY = y + dir[1];\n            \n            if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8 \n                && !visited[newX][newY]) {\n                q.push({newX, newY});\n                visited[newX][newY] = true;\n            }\n        }\n        \n        moves++;\n    }\n    \n    return -1;\n}\n\nint main() {\n    cout << minKnightMoves(0, 0, 2, 3) << endl; // Output: 5\n    cout << minKnightMoves(4, 3, 3, 2) << endl; // Output: 2\n    cout << minKnightMoves(7, 7, 1, 6) << endl; // Output: 8\n    \n    return 0;\n}\n```",
  "1198": "```\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findSmallestCommonElement(vector<vector<int>>& matrix) {\n        if (matrix.empty()) return -1;\n        \n        set<int> rows;\n        for (const auto& row : matrix) {\n            set<int> rowSet(row.begin(), row.end());\n            rows.insert(rowSet.begin(), rowSet.end());\n        }\n        \n        int smallest = INT_MAX;\n        for (int num : rows) {\n            bool isCommon = true;\n            for (const auto& row : matrix) {\n                if (find(row.begin(), row.end(), num) == row.end()) {\n                    isCommon = false;\n                    break;\n                }\n            }\n            if (isCommon && num < smallest) {\n                smallest = num;\n            }\n        }\n        \n        return smallest;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> matrix1 = {{1, 2, 3}, {1, 4, 5}};\n    cout << \"Test case 1: \" << solution.findSmallestCommonElement(matrix1) << endl;\n\n    // Test case 2\n    vector<vector<int>> matrix2 = {{1, 2, 3, 4}, {2, 4, 5, 6}};\n    cout << \"Test case 2: \" << solution.findSmallestCommonElement(matrix2) << endl;\n\n    // Test case 3\n    vector<vector<int>> matrix3 = {{1, 2}, {1, 3}};\n    cout << \"Test case 3: \" << solution.findSmallestCommonElement(matrix3) << endl;\n    \n    return 0;\n}\n```",
  "1199": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minTime(int n, vector<vector<int>>& req) {\n        priority_queue<pair<int,int>> pq;\n        for (int i = 1; i <= n; i++) {\n            pq.push({req[i-1][0], i});\n        }\n        \n        int time = 0;\n        while (!pq.empty()) {\n            pair<int,int> p = pq.top();\n            pq.pop();\n            \n            if (p.second > 1) {\n                int newTime = p.first + min(p.second - 1, n - p.second);\n                time += newTime;\n                \n                for (int i = 1; i <= n; i++) {\n                    if (i != p.second) {\n                        pq.push({req[i-1][0], i});\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n        \n        return time;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int n = 5;\n    vector<vector<int>> req = {{4,3},{2,3},{1,1}};\n    cout << \"Test case 1: \" << solution.minTime(n,req) << endl; // Expected output: 13\n\n    n = 5;\n    req = {{7,7},{1,1},{5,6},{3,3}};\n    cout << \"Test case 2: \" << solution.minTime(n,req) << endl; // Expected output: 21\n\n    n = 4;\n    req = {{9,8},{5,6},{10,5},{12,7}};\n    cout << \"Test case 3: \" << solution.minTime(n,req) << endl; // Expected output: 26\n\n    return 0;\n}\n```",
  "1200": "```\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> arr1 = {3, 2, 1};\n    int result1 = minimumAbsoluteDifference(arr1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> arr2 = {1, 3, 5];\n    int result2 = minimumAbsoluteDifference(arr2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> arr3 = [4, 5, 6, 7, 8];\n    int result3 = minimumAbsoluteDifference(arr3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n}\n\nint findMinValue(int arr[], int size) {\n    int minVal = INT_MAX;\n\n    for (int i = 0; i < size; i++) {\n        if (arr[i] < minVal) {\n            minVal = arr[i];\n        }\n    }\n\n    return minVal;\n}\n\nint minimumAbsoluteDifference(std::vector<int>& arr) {\n    sort(arr.begin(), arr.end());\n\n    int minDiff = INT_MAX;\n\n    for (int i = 1; i < arr.size(); i++) {\n        int diff = arr[i] - arr[i - 1];\n        if (diff < minDiff) {\n            minDiff = diff;\n        }\n    }\n\n    return minDiff;\n}\n```",
  "1201": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        vector<long long> ugly;\n        ugly.push_back(1);\n        for (int i = 1; i < n; ++i) {\n            long long next = -1;\n            for (const auto &x : ugly) {\n                if (x * 2 > ugly.back()) {\n                    next = x * 2;\n                    break;\n                } else if (x * 3 > ugly.back()) {\n                    next = x * 3;\n                } else if (x * 5 > ugly.back()) {\n                    next = x * 5;\n                } else {\n                    if (x * 2 == x * 3 && x * 2 == x * 5) {\n                        long long prev = x / 2;\n                        while (prev * 2 <= x) prev /= 2;\n                        if (x - prev * 2 > ugly.back()) next = x - prev * 2;\n                    }\n                    for (long long j : {2, 3, 5}) {\n                        if (next < ugly.back() && x * j > ugly.back()) {\n                            next = x * j;\n                        }\n                    }\n                }\n            }\n            ugly.push_back(next);\n        }\n        return ugly.back();\n    }\n};\n\nint main() {\n    Solution solution;\n    std::cout << solution.nthUglyNumber(10) << std::endl;  // Output: 12\n    std::cout << solution.nthUglyNumber(3) << std::endl;   // Output: 4\n    std::cout << solution.nthUglyNumber(6) << std::endl;   // Output: 8\n\n    return 0;\n}\n```",
  "1202": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string smallestStringWithSwaps(vector<string>& s, vector<vector<int>>& pairs) {\n        int n = s.size();\n        vector<vector<int>> graph(n);\n        for (auto& pair : pairs) {\n            graph[pair[0]].push_back(pair[1]);\n            graph[pair[1]].push_back(pair[0]);\n        }\n        \n        vector<bool> visited(n, false);\n        string ans = \"\";\n        for (int i = 0; i < n; ++i) {\n            if (!visited[i]) {\n                dfs(graph, visited, s, i, ans);\n            }\n        }\n        \n        return ans;\n    }\n\n    void dfs(vector<vector<int>>& graph, vector<bool>& visited, vector<string>& s, int node, string& ans) {\n        visited[node] = true;\n        vector<char> chars(s[node].begin(), s[node].end());\n        for (auto& neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                dfs(graph, visited, s, neighbor, ans);\n            }\n        }\n        \n        sort(chars.begin(), chars.end());\n        ans += string(chars.begin(), chars.end());\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<string> s1 = {\"dcce\",\"cad\"};\n    vector<vector<int>> pairs1 = {{0,1}};\n    cout << \"Test Case 1: \" << solution.smallestStringWithSwaps(s1, pairs1) << endl;\n\n    // Test Case 2\n    vector<string> s2 = {\"ka\",\"sb\",\"pq\",\"ay\"};\n    vector<vector<int>> pairs2 = {{0,1},{1,2}};\n    cout << \"Test Case 2: \" << solution.smallestStringWithSwaps(s2, pairs2) << endl;\n\n    // Test Case 3\n    vector<string> s3 = {\"a\",\"ccbda\"};\n    vector<vector<int>> pairs3 = {{0,7},{6,1},{4,2},{_3,9},{8,5}};\n    cout << \"Test Case 3: \" << solution.smallestStringWithSwaps(s3, pairs3) << endl;\n\n    return 0;\n}\n```",
  "1204": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int lastRemaining(int n) {\n        bool left = true;\n        int step = 1, remain = n;\n        while (remain > 1) {\n            if ((left && remain % 2 == 1) || (!left && remain % 2 == 0)) {\n                remain /= 2;\n            } else {\n                left = !left;\n                remain--;\n            }\n            step++;\n        }\n        return step * (left ? 1 : -1);\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test case 1: n = 1, expected: 0, got: \" << solution.lastRemaining(1) << endl;\n    cout << \"Test case 2: n = 10, expected: 5, got: \" << solution.lastRemaining(10) << endl;\n    cout << \"Test case 3: n = 20, expected: 11, got: \" << solution.lastRemaining(20) << endl;\n    return 0;\n}\n```",
  "1203": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> groupThePeople(int n, vector<vector<int>>& groupSizes) {\n        unordered_map<int, vector<vector<int>>> groups;\n        for (int i = 0; i < n; i++) {\n            int size = groupSizes[i];\n            if (!groups.count(size)) {\n                groups[size] = vector<vector<int>>();\n            }\n            groups[size].push_back({i});\n        }\n\n        vector<vector<int>> result;\n        for (auto& group : groups) {\n            sort(group.second.begin(), group.second.end());\n            for (int i = 0; i < group.second.size(); ) {\n                int start = i;\n                while (start + group.second[i].size() - 1 < group.second.size()) {\n                    result.push_back({group.second[start], group.second[start + 1]});\n                    start += group.second[start + 1].size();\n                }\n                if (i == start) {\n                    result.push_back(group.second[i]);\n                } else {\n                    for (int j = i; j < start; j++) {\n                        result.push_back({group.second[j], group.second[j + 1]});\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n1 = 3;\n    vector<vector<int>> groupSizes1 = {{2, 1, 3}, {1, 2}};\n    cout << \"Test case 1: \";\n    for (const auto& group : solution.groupThePeople(n1, groupSizes1)) {\n        cout << \"[\";\n        for (int person : group) {\n            cout << person;\n            if (&person != &group.back()) {\n                cout << \", \";\n            }\n        }\n        cout << \"]\";\n    }\n    cout << endl;\n\n    // Test case 2\n    int n2 = 4;\n    vector<vector<int>> groupSizes2 = {{3, 6, 7}, {9, 1, 2, 3, 4}};\n    cout << \"Test case 2: \";\n    for (const auto& group : solution.groupThePeople(n2, groupSizes2)) {\n        cout << \"[\";\n        for (int person : group) {\n            cout << person;\n            if (&person != &group.back()) {\n                cout << \", \";\n            }\n        }\n        cout << \"]\";\n    }\n    cout << endl;\n\n    // Test case 3\n    int n3 = 2;\n    vector<vector<int>> groupSizes3 = {{1, 1}};\n    cout << \"Test case 3: \";\n    for (const auto& group : solution.groupThePeople(n3, groupSizes3)) {\n        cout << \"[\";\n        for (int person : group) {\n            cout << person;\n            if (&person != &group.back()) {\n                cout << \", \";\n            }\n        }\n        cout << \"]\";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1205": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include \"solution.h\"\n\nint main() {\n    Solution solution;\n    \n    std::vector<std::vector<int>> accounts1 = {{1,2,10}, {2,5,20}};\n    int expect1 = 60;\n    std::cout << \"Test case 1: \" << solution.monthlyTransactions(accounts1) << \" Expected: \" << expect1 << std::endl;\n    if (solution.monthlyTransactions(accounts1) == expect1)\n        std::cout << \"Test Case 1 Passed\" << std::endl;\n    else\n        std::cout << \"Test Case 1 Failed\" << std::endl;\n\n    \n    std::vector<std::vector<int>> accounts2 = {{1,3,40},{4,8,70},{7,14,60}};\n    int expect2 = 160;\n    std::cout << \"Test case 2: \" << solution.monthlyTransactions(accounts2) << \" Expected: \" << expect2 << std::endl;\n    if (solution.monthlyTransactions(accounts2) == expect2)\n        std::cout << \"Test Case 2 Passed\" << std::endl;\n    else\n        std::cout << \"Test Case 2 Failed\" << std::endl;\n\n    \n    std::vector<std::vector<int>> accounts3 = {{1,2,5},{4,5,6},{10,11,12}};\n    int expect3 = 21;\n    std::cout << \"Test case 3: \" << solution.monthlyTransactions(accounts3) << \" Expected: \" << expect3 << std::endl;\n    if (solution.monthlyTransactions(accounts3) == expect3)\n        std::cout << \"Test Case 3 Passed\" << std::endl;\n    else\n        std::cout << \"Test Case 3 Failed\" << std:: endl;\n    \n    return 0;\n}\n```",
  "1207": "```\n#include <iostream>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int singleNonDuplicate(vector<int>& nums) {\n        unordered_map<int, int> count;\n        for (int num : nums) {\n            count[num]++;\n        }\n        for (auto& pair : count) {\n            if (pair.second == 1) {\n                return pair.first;\n            }\n        }\n        return -1; // should never happen\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> test1 = {1, 2, 3, 2};\n    cout << \"Test 1: \" << solution.singleNonDuplicate(test1) << endl; // Output: 3\n\n    vector<int> test2 = {5, 7, 8, 7, 3, 7];\n    cout << \"Test 2: \" << solution.singleNonDuplicate(test2) << endl; // Output: 5\n\n    vector<int> test3 = [1, 1, 2, 3, 3];\n    cout << \"Test 3: \" << solution.singleNonDuplicate(test3) << endl; // Output: 2\n\n    return 0;\n}\n```",
  "1206": "```\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int val;\n    vector<int> skip;\n\n    Node(int _val) : val(_val) {}\n};\n\nclass SkipList {\nprivate:\n    Node* head;\n    int maxLevel;\n\n    void insert(Node* node, int level);\n    bool search(Node* node, int target);\n\npublic:\n    SkipList();\n\n    void add(int num);\n    bool search(int target);\n};\n\nSkipList::SkipList() : head(new Node(0)), maxLevel(16) {\n    for (int i = 1; i <= maxLevel; i++) {\n        head->skip.push_back(i - 1);\n    }\n}\n\nvoid SkipList::insert(Node* node, int level) {\n    while (level > 0 && rand() % 2 != 0) {\n        level--;\n    }\n    node->skip = vector<int>(level + 1);\n    for (int i = 0; i <= level; i++) {\n        if (i < node->skip.size()) {\n            node->skip[i] = i;\n        } else {\n            node->skip.push_back(0);\n        }\n    }\n}\n\nbool SkipList::search(Node* node, int target) {\n    Node* current = head;\n    while (current != nullptr && node->val <= target) {\n        if (current->val == target) {\n            return true;\n        }\n        for (int i = maxLevel - 1; i >= 0; i--) {\n            if (i < current->skip.size() && current->skip[i] > 0\n                && current->skip[i] <= target) {\n                current = node->skip[i];\n                break;\n            } else if (i == 0) {\n                return false;\n            }\n        }\n    }\n    return false;\n}\n\nvoid SkipList::add(int num) {\n    Node* newNode = new Node(num);\n    insert(newNode, rand() % maxLevel + 1);\n}\n\nbool SkipList::search(int target) {\n    return search(head, target);\n}\n\nint main() {\n    SkipList s1;\n\n    // Test case 1\n    for (int i = 0; i < 10; i++) {\n        s1.add(i);\n    }\n    cout << \"Search for 5: \" << (s1.search(5) ? \"true\" : \"false\") << endl;\n    cout << \"Search for 15: \" << (s1.search(15) ? \"true\" : \"false\") << endl;\n\n    // Test case 2\n    s1.add(10);\n    s1.add(11);\n    cout << \"Search for 9: \" << (s1.search(9) ? \"true\" : \"false\") << endl;\n    cout << \"Search for 12: \" << (s1.search(12) ? \"true\" : \"false\") << endl;\n\n    // Test case 3\n    s1.add(-10);\n    s1.add(-5);\n    s1.add(0);\n    cout << \"Search for -15: \" << (s1.search(-15) ? \"true\" : \"false\") << endl;\n    cout << \"Search for 2: \" << (s1.search(2) ? \"true\" : \"false\") << endl;\n\n    return 0;\n}\n```",
  "1208": "```\n#include <iostream>\n#include <string>\n\nbool canEqual(std::string s, int budget) {\n    int n = s.length();\n    for (int i = 0; i <= n - budget; ++i) {\n        bool equal = true;\n        for (int j = 0; j < budget; ++j) {\n            if (s[i + j] != s[i + j % budget]) {\n                equal = false;\n                break;\n            }\n        }\n        if (equal) return true;\n    }\n    return false;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << canEqual(\"abcba\", 1) << std::endl;  // true\n    std::cout << canEqual(\"abca\", 2) << std::endl;   // false\n    std::cout << canEqual(\"axbxbax\", 4) << std::endl; // true\n    return 0;\n}\n```",
  "1209": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nstd::string removeDuplicates(std::string s) {\n    std::stack<char> stack;\n    \n    for (char c : s) {\n        if (!stack.empty() && stack.top() == c) {\n            stack.pop();\n        } else {\n            stack.push(c);\n        }\n    }\n    \n    std::string result;\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    \n    return result;\n}\n\nint main() {\n    std::cout << removeDuplicates(\"abcba\") << std::endl;  // Output: \"abc\"\n    std::cout << removeDuplicates(\"azxxzy\") << std::endl;  // Output: \"ayz\"\n    std::cout << removeDuplicates(\"a\") << std::endl;       // Output: \"a\"\n\n    return 0;\n}\n```",
  "1210": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint minMovesToReachTarget(vector<vector<int>>& target) {\n    int m = target.size();\n    int n = target[0].size();\n    \n    vector<vector<bool>> visited(m, vector<bool>(n));\n    queue<pair<int, int>> q;\n    pair<int, int> start = {0, 0};\n    visited[start.first][start.second] = true;\n    q.push(start);\n    \n    int moves = 0;\n    while (!q.empty()) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n        \n        if (x == target.size() - 1 && y == target[0].size() - 1) return moves;\n        \n        for (int dx : {-1, 0, 1}) {\n            for (int dy : {-1, 0, 1}) {\n                int newX = x + dx;\n                int newY = y + dy;\n                \n                if (newX >= 0 && newX < m && newY >= 0 && newY < n) {\n                    if (!visited[newX][newY] && target[newX][newY] == 0) {\n                        visited[newX][newY] = true;\n                        q.push({newX, newY});\n                    }\n                }\n            }\n        }\n        \n        moves++;\n    }\n    \n    return -1; // unreachable\n}\n\nint main() {\n    vector<vector<int>> target1{{0,0,0},{0,1,0}};\n    cout << minMovesToReachTarget(target1) << endl;\n    \n    vector<vector<int>> target2{{0,0,0,0},{0,1,0,0},{0,0,0,0}};\n    cout << minMovesToReachTarget(target2) << endl;\n    \n    vector<vector<int>> target3{{0,0,0,0,0,0,0,0,0,0},\n                                {0,0,1,1,1,1,0,0,0,0},\n                                {0,0,1,1,1,1,0,0,0,0},\n                                {0,0,1,1,1,1,0,0,0,0},\n                                {0,0,0,0,0,0,0,0,0,0}};\n    cout << minMovesToReachTarget(target3) << endl;\n    \n    return 0;\n}\n```",
  "1211": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<int> diffQuality(std::vector<std::vector<int>>& accounts, int loginTimes) {\n        int n = accounts.size();\n        std::vector<int> res;\n        \n        for (int i = 0; i < n; i++) {\n            int quality = 0;\n            for (int j = 0; j < loginTimes; j++) {\n                if (accounts[i][j] > 1) {\n                    quality++;\n                }\n            }\n            res.push_back(quality);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::vector<int>> accounts1 = {{10,20},{30,40}};\n    int loginTimes1 = 2;\n    std::vector<int> result1 = solution.diffQuality(accounts1, loginTimes1);\n    for (int i : result1) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test Case 2\n    std::vector<std::vector<int>> accounts2 = {{10},{20}};\n    int loginTimes2 = 2;\n    std::vector<int> result2 = solution.diffQuality(accounts2, loginTimes2);\n    for (int i : result2) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test Case 3\n    std::vector<std::vector<int>> accounts3 = {{10,20,30},{40,50}};\n    int loginTimes3 = 3;\n    std::vector<int> result3 = solution.diffQuality(accounts3, loginTimes3);\n    for (int i : result3) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1212": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<std::string> getTournamentStats(std::vector<std::vector<int>>& logs) {\n        // Your solution logic here\n        std::vector<std::string> result;\n        for (const auto& log : logs) {\n            int team1Score = log[0];\n            int team2Score = log[1];\n            if (team1Score > team2Score) {\n                result.push_back(\"Team 1 win\");\n            } else if (team2Score > team1Score) {\n                result.push_back(\"Team 2 win\");\n            } else {\n                result.push_back(\"Tie\");\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::vector<int>> logs1 = {{0, 3}, {4, 5}};\n    auto result1 = solution.getTournamentStats(logs1);\n    for (const auto& stat : result1) {\n        std::cout << stat << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test Case 2\n    std::vector<std::vector<int>> logs2 = {{0, 5}, {3, 4}};\n    auto result2 = solution.getTournamentStats(logs2);\n    for (const auto& stat : result2) {\n        std::cout << stat << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test Case 3\n    std::vector<std::vector<int>> logs3 = {{1, 0}, {5, 5}};\n    auto result3 = solution.getTournamentStats(logs3);\n    for (const auto& stat : result3) {\n        std::cout << stat << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1213": "```\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> threeSumMulti(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\n        set<vector<int>> result;\n        \n        for (int i = 0; i < nums1.size(); i++) {\n            for (int j = 0; j < nums2.size(); j++) {\n                int t = nums1[i] + nums2[j];\n                auto it = upper_bound(nums3.begin(), nums3.end(), t);\n                \n                if (it != nums3.end()) {\n                    result.insert({nums1[i], nums2[j], *it});\n                }\n            }\n        }\n        \n        vector<int> res;\n        for (auto v : result) {\n            res.push_back(v[0]);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<int> nums1 = {1,2};\n    vector<int> nums2 = {1,3};\n    vector<int> nums3 = {2};\n    vector<int> result = solution.threeSumMulti(nums1, nums2, nums3);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 2:\n    nums1 = {1,2};\n    nums2 = {2,4};\n    nums3 = [1,3];\n    result = solution.threeSumMulti(nums1, nums2, nums3);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 3:\n    nums1 = {1,2};\n    nums2 = [1,2];\n    nums3 = [1,2,3];\n    result = solution.threeSumMulti(nums1, nums2, nums3);\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1214": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    bool findTarget(vector<int>& root, int k) {\n        vector<int> left;\n        while (root.size()) {\n            if (root[0] == k) return true;\n            if (k > root[0]) root.pop_back();\n            else break;\n            left.push_back(root[0]);\n            for (int i = 1; i < root.size(); ++i) {\n                if (root[i] == root[0]) root.erase(root.begin() + i);\n                else if (root[i] > root[0]) {\n                    root.erase(root.begin());\n                    break;\n                } else if (k > root[i]) {\n                    for (; i < root.size() && root[i] <= root[0]; ++i) {\n                        root.erase(root.begin());\n                    }\n                    break;\n                } else return true;\n            }\n        }\n        while (root.size()) {\n            if (root[0] == k) return true;\n            if (k > root[0]) root.pop_back();\n            else break;\n            for (int i = 1; i < root.size(); ++i) {\n                if (root[i] == root[0]) root.erase(root.begin() + i);\n                else if (root[i] > root[0]) {\n                    root.erase(root.begin());\n                    break;\n                } else return true;\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> root1 = {4,6,5,3,2};\n    int k1 = 9;\n    cout << (solution.findTarget(root1, k1) ? \"True\" : \"False\") << endl; // Output: True\n\n    // Test Case 2\n    vector<int> root2 = {10,5,20};\n    int k2 = 15;\n    cout << (solution.findTarget(root2, k2) ? \"True\" : \"False\") << endl; // Output: True\n\n    // Test Case 3\n    vector<int> root3 = {5,1,4};\n    int k3 = 8;\n    cout << (solution.findTarget(root3, k3) ? \"True\" : \"False\") << endl; // Output: False\n\n    return 0;\n}\n```",
  "1215": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findSteppingNumbers(int left, int right) {\n        vector<int> result;\n        for (int i = left; i <= right; i++) {\n            bool stepping = true;\n            string strI = to_string(i);\n            if (strI.length() > 1 && strI[0] == '0') continue;\n            for (int j = 1; j < strI.length(); j++) {\n                int diff = abs(strI[j-1] - strI[j]);\n                if ((strI[j-1] > strI[j] && diff != 1) || (strI[j-1] < strI[j] && diff > 1)) {\n                    stepping = false;\n                    break;\n                }\n            }\n            if (stepping) result.push_back(i);\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    int left1 = 0, right1 = 9;\n    vector<int> result1 = solution.findSteppingNumbers(left1, right1);\n    for (int num : result1) cout << num << \" \";\n    cout << endl;\n\n    // Test case 2\n    int left2 = 100, right2 = 200;\n    vector<int> result2 = solution.findSteppingNumbers(left2, right2);\n    for (int num : result2) cout << num << \" \";\n    cout << endl;\n\n    // Test case 3\n    int left3 = 0, right3 = 25;\n    vector<int> result3 = solution.findSteppingNumbers(left3, right3);\n    for (int num : result3) cout << num << \" \";\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1216": "```\n#include <iostream>\n#include <string>\n\nbool isPalindrome(std::string s) {\n    int left = 0;\n    int right = s.size() - 1;\n\n    while (left < right) {\n        if (!isalnum(s[left])) {\n            left++;\n            continue;\n        }\n        if (!isalnum(s[right])) {\n            right--;\n            continue;\n        }\n\n        if (tolower(s[left]) != tolower(s[right])) {\n            return false;\n        }\n\n        left++;\n        right--;\n    }\n\n    return true;\n}\n\nint main() {\n    std::cout << isPalindrome(\"A man, a plan, a canal: Panama\") << std::endl;  // Expected output: true\n    std::cout << isPalindrome(\"Not a palindrome\") << std::endl;  // Expected output: false\n    std::cout << isPalindrome(\" \") << std::endl;  // Expected output: true\n\n    return 0;\n}\n```",
  "1217": "```\n#include <iostream>\n#include <vector>\n\nint minCost(int n, std::vector<int>& chips) {\n    int total = 0;\n    for (int i : chips) {\n        if ((i % 2 == 1 && n % 2 == 0) || (i % 2 == 0 && n % 2 == 1)) {\n            total += std::min(i, n - i);\n        } else {\n            total += std::abs(i - n);\n        }\n    }\n    return total;\n}\n\nint main() {\n    // Test case 1\n    int n = 3;\n    std::vector<int> chips1 = {1, 2};\n    std::cout << \"Test case 1: \" << minCost(n, chips1) << std::endl;\n\n    // Test case 2\n    int n2 = 4;\n    std::vector<int> chips2 = {2, 3, 5};\n    std::cout << \"Test case 2: \" << minCost(n2, chips2) << std::endl;\n\n    // Test case 3\n    int n3 = 6;\n    std::vector<int> chips3 = {1, 2, 4, 7};\n    std::cout << \"Test case 3: \" << minCost(n3, chips3) << std::endl;\n\n    return 0;\n}\n```",
  "1218": "```\n#include <iostream>\n#include <vector>\n\nint longestArithSeq(int n, std::vector<int>& arr) {\n    if (n == 0 || arr.empty()) return 0;\n    \n    int maxLen = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        std::unordered_map<int, int> map;\n        map[arr[i]] = 1;\n        int curLen = 1;\n        for (int j = i + 1; j < arr.size(); j++) {\n            if (arr[j] - arr[j - 1] == arr[i] - arr[i - 1]) {\n                if (map.find(arr[j]) != map.end()) {\n                    curLen += map[arr[j]] + 1;\n                    map[arr[j]] = curLen;\n                }\n            } else {\n                curLen++;\n                map[arr[j]] = curLen;\n            }\n        }\n        maxLen = std::max(maxLen, curLen);\n    }\n    \n    return maxLen;\n}\n\nint main() {\n    int n;\n    std::vector<int> arr;\n\n    // Test case 1:\n    n = 10;\n    arr = {2,4,5,6,7,10};\n    if (longestArithSeq(n, arr) == 3)\n        std::cout << \"Test case 1: Passed\" << std::endl;\n    else\n        std::cout << \"Test case 1: Failed\" << std::endl;\n\n    // Test case 2:\n    n = 15;\n    arr = {5,7,10,13};\n    if (longestArithSeq(n, arr) == 5)\n        std::cout << \"Test case 2: Passed\" << std::endl;\n    else\n        std::cout << \"Test case 2: Failed\" << std::endl;\n\n    // Test case 3:\n    n = 10;\n    arr = {0,1,3,4,6,8,10,12};\n    if (longestArithSeq(n, arr) == 5)\n        std::cout << \"Test case 3: Passed\" << std::endl;\n    else\n        std::cout << \"Test case 3: Failed\" << std::endl;\n\n    return 0;\n}\n```",
  "1219": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int getMaximumGold(vector<vector<int>>& grid) {\n        int n = grid.size();\n        if (n == 0) return 0;\n        \n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    dfs(grid, i, j, 0);\n                }\n            }\n        }\n        \n        return ans;\n    }\n    \nprivate:\n    void dfs(vector<vector<int>>& grid, int i, int j, int gold) {\n        int n = grid.size();\n        if (i < 0 || i >= n || j < 0 || j >= n || grid[i][j] == 0) return;\n        \n        grid[i][j] = 0; // mark as visited\n        \n        gold += grid[i][j];\n        \n        if (gold > ans) {\n            ans = gold;\n        }\n        \n        int dx[] = {-1, 1, 0, 0};\n        int dy[] = {0, 0, -1, 1};\n        \n        for (int k = 0; k < 4; ++k) {\n            int x = i + dx[k];\n            int y = j + dy[k];\n            \n            if (x >= 0 && x < n && y >= 0 && y < n) {\n                dfs(grid, x, y, gold);\n            }\n        }\n    }\n};\n\nint main() {\n    vector<vector<int>> grid1 = {{0,6,0},{5,8,7},{0,9,0}};\n    cout << Solution().getMaximumGold(grid1) << endl;\n    \n    vector<vector<int>> grid2 = {{1,0,7},{3,4,5},{2,3,2}};\n    cout << Solution().getMaximumGold(grid2) << endl;\n    \n    vector<vector<int>> grid3 = {{2,1,0},{0,7,4},{0,8,6}};\n    cout << Solution().getMaximumGold(grid3) << endl;\n    \n    return 0;\n}\n```",
  "1220": "```\n#include <iostream>\n#include <vector>\n\nint vowelPermutation(int n) {\n    if (n == 1) return 0;\n    int mod = 1000000007;\n    std::vector<int> a(2, 5), b(2, 1);\n    for (int i = 3; i <= n; ++i) {\n        int sum = (a[1] * i + b[1]) % mod;\n        a[0] = b[1];\n        b[0] = sum;\n    }\n    return ((b[0] - 1) + mod) % mod;\n}\n\nint main() {\n    std::cout << vowelPermutation(5) << std::endl; // expected output: 2\n    std::cout << vowelPermutation(30) << std::endl; // expected output: 8\n    std::cout << vowelPermutation(5000) << std::endl; // expected output: 246\n\n    return 0;\n}\n```",
  "1221": "```\n#include <iostream>\n#include <string>\n\nint balancedStringSplit(std::string s) {\n    int count = 0;\n    int left = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == 'L') {\n            left++;\n        } else {\n            if (left % 2 != 0) {\n                return -1;\n            }\n            count++;\n            left = 0;\n        }\n    }\n    if (left % 2 != 0) {\n        return -1;\n    }\n    return count;\n}\n\nint main() {\n    std::cout << balancedStringSplit(\"RLRRLLRLRL\") << std::endl; // Expected output: 4\n    std::cout << balancedStringSplit(\"RLLLLRLRL\") << std::endl; // Expected output: -1\n    std::cout << balancedStringSplit(\"LLLLRRRR\") << std::endl; // Expected output: 0\n    return 0;\n}\n```",
  "1223": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int rollDice(int n) {\n        vector<int> dp(n + 1);\n        dp[0] = 1;\n        \n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= 6; ++j) {\n                if (i - j >= 0) {\n                    dp[i] += dp[i - j];\n                }\n            }\n        }\n        \n        return dp[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << solution.rollDice(2) << endl; // Output: 6\n    cout << \"Test case 2: \" << solution.rollDice(3) << endl; // Output: 25\n    cout << \"Test case 3: \" << solution.rollDice(4) << endl; // Output: 74\n    \n    return 0;\n}\n```",
  "1222": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> queensAttacktheKing(vector<vector<string>>& positions) {\n        int rows = positions.size();\n        int cols = positions[0].size();\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (positions[i][j] == \"king\") {\n                    kingRow = i;\n                    kingCol = j;\n                }\n            }\n        }\n\n        vector<vector<string>> res;\n\n        for (int i = 1; i <= rows - kingRow; i++) {\n            int row = kingRow + i;\n            int col = kingCol;\n            bool canAttack = true;\n            while (col >= 0 && col < cols) {\n                if (positions[row][col] == \"king\") {\n                    canAttack = false;\n                    break;\n                }\n                if (positions[row][col] != \".\") {\n                    res.push_back({{\"queen\", row, string(1, to_string(col))}});\n                    break;\n                }\n                col--;\n            }\n            for (int j = 1; j <= kingCol; j++) {\n                int row = kingRow;\n                int col = j;\n                bool canAttack2 = true;\n                while (row >= 0 && row < rows) {\n                    if (positions[row][col] == \"king\") {\n                        canAttack2 = false;\n                        break;\n                    }\n                    if (positions[row][col] != \".\") {\n                        res.push_back({{\"queen\", string(1, to_string(row)), string(1, to_string(col))}});\n                        break;\n                    }\n                    row--;\n                }\n                for (int k = 1; k <= kingRow; k++) {\n                    int row = k;\n                    int col = kingCol;\n                    bool canAttack3 = true;\n                    while (row >= 0 && row < rows) {\n                        if (positions[row][col] == \"king\") {\n                            canAttack3 = false;\n                            break;\n                        }\n                        if (positions[row][col] != \".\") {\n                            res.push_back({{\"queen\", string(1, to_string(row)), string(1, to_string(col))}});\n                            break;\n                        }\n                        row--;\n                    }\n                    for (int l = 1; l <= kingCol; l++) {\n                        int row = kingRow;\n                        int col = l;\n                        bool canAttack4 = true;\n                        while (row >= 0 && row < rows) {\n                            if (positions[row][col] == \"king\") {\n                                canAttack4 = false;\n                                break;\n                            }\n                            if (positions[row][col] != \".\") {\n                                res.push_back({{\"queen\", string(1, to_string(row)), string(1, to_string(col))}});\n                                break;\n                            }\n                            row--;\n                        }\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n\n    int kingRow, kingCol;\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<vector<string>> positions1 = {{\"0,0\"}, {\"4,6\"}};\n    auto result1 = solution.queensAttacktheKing(positions1);\n    for (auto row : result1) {\n        cout << \"[\";\n        for (int i = 0; i < row.size(); i++) {\n            cout << \"\\\"\" + row[i] + \"\\\",\";\n        }\n        cout << \"]\\n\";\n    }\n\n    // Test case 2:\n    vector<vector<string>> positions2 = {{\"5,6\"}, {\"5,7\"}};\n    auto result2 = solution.queensAttacktheKing(positions2);\n    for (auto row : result2) {\n        cout << \"[\";\n        for (int i = 0; i < row.size(); i++) {\n            cout << \"\\\"\" + row[i] + \"\\\",\";\n        }\n        cout << \"]\\n\";\n    }\n\n    // Test case 3:\n    vector<vector<string>> positions3 = {{\"1,2\"}, {\"4,5\"}};\n    auto result3 = solution.queensAttacktheKing(positions3);\n    for (auto row : result3) {\n        cout << \"[\";\n        for (int i = 0; i < row.size(); i++) {\n            cout << \"\\\"\" + row[i] + \"\\\",\";\n        }\n        cout << \"]\\n\";\n    }\n\n    return 0;\n}\n```",
  "1224": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint maxEqualFrequency(std::vector<int>& nums) {\n    std::unordered_map<int, int> frequency;\n    for (int num : nums) {\n        frequency[num]++;\n    }\n    \n    int maxCount = 0;\n    for (const auto& pair : frequency) {\n        if (pair.second > maxCount && pair.first == pair.second) {\n            maxCount = pair.second;\n        }\n    }\n    \n    return maxCount;\n}\n\nint main() {\n    std::vector<int> nums1 = {2,1,3};\n    std::cout << \"Test case 1: \" << maxEqualFrequency(nums1) << std::endl;\n\n    std::vector<int> nums2 = {3,6,1,4,5};\n    std::cout << \"Test case 2: \" << maxEqualFrequency(nums2) << std::endl;\n\n    std::vector<int> nums3 = {7,7,7,7};\n    std::cout << \"Test case 3: \" << maxEqualFrequency(nums3) << std::endl;\n\n    return 0;\n}\n```",
  "1225": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> contiguousDates(vector<vector<string>>& intervals) {\n        // your logic here\n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<string>> intervals1 = {{ \"01-Jan-2020\", \"03-Jan-2020\" }, { \"04-Jan-2020\", \"07-Jan-2020\" }, { \"08-Jan-2020\", \"10-Jan-2020\" }};\n    vector<string> result1 = solution.contiguousDates(intervals1);\n    \n    for (string s : result1) {\n        cout << s << endl;\n    }\n    cout << endl;\n\n    vector<vector<string>> intervals2 = {{ \"07-Nov-2019\", \"16-Nov-2019\" }, { \"17-Nov-2019\", \"20-Nov-2019\" }, { \"21-Nov-2019\", \"23-Nov-2019\" }};\n    vector<string> result2 = solution.contiguousDates(intervals2);\n    \n    for (string s : result2) {\n        cout << s << endl;\n    }\n    cout << endl;\n\n    vector<vector<string>> intervals3 = {{ \"01-Jan-2021\", \"03-Jan-2021\" }, { \"04-Jan-2021\", \"08-Jan-2021\" }};\n    vector<string> result3 = solution.contiguousDates(intervals3);\n    \n    for (string s : result3) {\n        cout << s << endl;\n    }\n    return 0;\n}\n```",
  "1227": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ndouble nthPersonWins(int n) {\n    double p = 0.5;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 1) {\n            p *= (1 - 0.5);\n        } else {\n            p *= 0.5;\n        }\n    }\n    return p;\n}\n\nint main() {\n    cout << fixed << setprecision(10);\n    cout << \"Test case 1: n = 10, expected output = 0.7733247674795576\\n\";\n    cout << \"Actual output: \" << nthPersonWins(10) << endl;\n\n    cout << \"Test case 2: n = 50, expected output = 0.6743353144541218\\n\";\n    cout << \"Actual output: \" << nthPersonWins(50) << endl;\n\n    cout << \"Test case 3: n = 100, expected output = 0.6531841451743421\\n\";\n    cout << \"Actual output: \" << nthPersonWins(100) << endl;\n    \n    return 0;\n}\n```",
  "1226": "```\n#include <iostream>\n#include <thread>\n#include <mutex>\n\nclass Philosophers {\npublic:\n    void think(int id) {\n        for (int i = 0; i < 5; ++i) {\n            if (!takeChopsticks(id)) return;\n            eat();\n            releaseChopsticks(id);\n        }\n    }\n\nprivate:\n    bool takeChopsticks(int id) {\n        std::lock_guard<std::mutex> lock(mutex);\n        if (id % 2 == 0 && !forks[0]) forks[0] = true;\n        else if (!forks[1]) forks[1] = true;\n        return forks[0] && forks[1];\n    }\n\n    void eat() {\n        std::this_thread::sleep_for(std::chrono::milliseconds(10));\n    }\n\n    void releaseChopsticks(int id) {\n        std::lock_guard<std::mutex> lock(mutex);\n        forks[0] = false;\n        forks[1] = false;\n    }\n\n    bool forks[2];\n    std::mutex mutex;\n};\n\nint main() {\n    Philosophers philosophers;\n\n    // Test case 1\n    std::thread t1(&Philosophers::think, &philosophers, 0);\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    t1.join();\n\n    // Test case 2\n    Philosophers anotherPhilosopher;\n    std::thread t2(&anotherPhilosopher.think, &anotherPhilosopher, 1);\n    std::this_thread::sleep_for(std::chrono::milliseconds(50));\n    t2.join();\n\n    // Test case 3\n    Philosophers philosopher;\n    for (int i = 0; i < 5; ++i) {\n        philosopher.think(i % 2);\n    }\n\n    return 0;\n}\n```",
  "1228": "```\n#include <iostream>\n#include <vector>\n\nint findMissingNumber(std::vector<int>& nums) {\n    int n = nums.size();\n    for (int i = 0; i < n - 1; i++) {\n        if (nums[i + 1] - nums[i] > 1) {\n            return nums[i] + 1;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    std::vector<int> test1 = {3, 7, 11};\n    int missingNumberTest1 = findMissingNumber(test1);\n    if (missingNumberTest1 == 5) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 5, Found: \" << missingNumberTest1 << std::endl;\n    }\n\n    std::vector<int> test2 = {1, 2, 4};\n    int missingNumberTest2 = findMissingNumber(test2);\n    if (missingNumberTest2 == 3) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 3, Found: \" << missingNumberTest2 << std::endl;\n    }\n\n    std::vector<int> test3 = {0, 1, 5};\n    int missingNumberTest3 = findMissingNumber(test3);\n    if (missingNumberTest3 == 2) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 2, Found: \" << missingNumberTest3 << std::endl;\n    }\n\n    return 0;\n}",
  "1229": "```\n#include <iostream>\n#include <vector>\n\nbool canAttendMeetings(std::vector<std::pair<int, int>>& intervals) {\n    if (intervals.empty()) return true;\n\n    std::sort(intervals.begin(), intervals.end(), [](const auto& a, const auto& b) {\n        return a.first < b.first;\n    });\n\n    for (size_t i = 0; i < intervals.size() - 1; ++i) {\n        if (intervals[i].second > intervals[i + 1].first) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::pair<int, int>> meetings1 = {{0, 30}, {5, 10}, {15, 20}};\n    std::cout << (canAttendMeetings(meetings1) ? \"Yes\" : \"No\") << std::endl;\n\n    std::vector<std::pair<int, int>> meetings2 = {{7, 10}, {2, 4}};\n    std::cout << (canAttendMeetings(meetings2) ? \"Yes\" : \"No\") << std::endl;\n\n    std::vector<std::pair<int, int>> meetings3 = {{1, 5}, {8, 11}, {15, 20}};\n    std::cout << (canAttendMeetings(meetings3) ? \"Yes\" : \"No\") << std::endl;\n\n    return 0;\n}\n```",
  "1230": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint numRollsToTarget(int n, int target) {\n    vector<vector<int>> dp(n + 1, vector<int>(target + 1));\n    \n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= target; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j] = 1;\n            } else if (i > 0) {\n                if (j >= 1)\n                    dp[i][j] += dp[i - 1][j - 1];\n                if (j <= i + 1)\n                    dp[i][j] += dp[i - 1][j];\n            }\n        }\n    }\n    \n    return dp[n][target];\n}\n\nint main() {\n    cout << numRollsToTarget(2, 3) << endl; // Output: 4\n    cout << numRollsToTarget(5, 10) << endl; // Output: 184\n    cout << numRollsToTarget(1, 1) << endl; // Output: 1\n    \n    return 0;\n}\n```",
  "1231": "```\n#include <iostream>\n#include <vector>\n\nint maxChocolates(int maxAllowed, int* chocolates) {\n    if (maxAllowed <= 0 || *chocolates <= 0)\n        return 0;\n    \n    int start = 1;\n    int end = *chocolates;\n\n    while (start <= end) {\n        int mid = start + (end - start) / 2;\n        int totalChocolates = 0, leftOver = 0;\n        \n        for (int i = 0; i < maxAllowed; ++i) {\n            totalChocolates += mid;\n            if ((leftOver += mid) > *chocolates)\n                break;\n        }\n\n        if (totalChocolates >= *chocolates && leftOver <= *chocolates)\n            return mid;\n\n        if (totalChocolates < *chocolates)\n            start = mid + 1;\n        else\n            end = mid - 1;\n    }\n    \n    return 0;\n}\n\nint main() {\n    int maxAllowed[] = {2, 4, 7};\n    int chocolates[] = {5, 8, 10};\n\n    std::cout << \"Test Case 1: Expected 2, got \" << maxChocolates(2, &chocolates[0]) << std::endl;\n    std::cout << \"Test Case 2: Expected 3, got \" << maxChocolates(4, &chocolates[1]) << std::endl;\n    std::cout << \"Test Case 3: Expected 3, got \" << maxChocolates(7, &chocolates[2]) << std::endl;\n\n    return 0;\n}\n```",
  "1232": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool checkStraightLine(vector<vector<int>>& coordinates) {\n        int x1 = coordinates[0][0];\n        int y1 = coordinates[0][1];\n        for (int i = 1; i < coordinates.size(); ++i) {\n            int x2 = coordinates[i][0];\n            int y2 = coordinates[i][1];\n            if ((y2 - y1) * (coordinates[i][0] - coordinates[0][0]) != (x2 - x1) * (y1 - y1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> coordinates1 = {{0, 0}, {0, 3}};\n    cout << \"Case 1: \" << (solution.checkStraightLine(coordinates1) ? \"True\" : \"False\") << endl;\n\n    vector<vector<int>> coordinates2 = {{1, 1}, {5, 5}, {5, -5}};\n    cout << \"Case 2: \" << (solution.checkStraightLine(coordinates2) ? \"True\" : \"False\") << endl;\n\n    vector<vector<int>> coordinates3 = {{0, 0}, {4, 0}, {8, 0}};\n    cout << \"Case 3: \" << (solution.checkStraightLine(coordinates3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1233": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> removeSubfolders(vector<string>& folder) {\n        sort(folder.begin(), folder.end());\n        vector<string> res;\n        for (int i = 0; i < folder.size(); i++) {\n            if (res.empty() || folder[i].compare(0, folder[i].size() - folder[i].rfind('/') + 1, res.back()) > 0) {\n                res.push_back(folder[i]);\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<string> folders1 = {\"/a\",\"/a/b\",\"/c/d\"};\n    vector<string> expected1 = {\"/a\", \"/c/d\"};\n    if (solution.removeSubfolders(folders1) != expected1) {\n        cout << \"Test Case 1 failed!\" << endl;\n        return -1;\n    }\n    \n    // Test Case 2\n    vector<string> folders2 = [\"/a\",\"/same/asdf/asdf\", \"/same/newfile\"];\n    vector<string> expected2 = {\"/a\", \"/same/newfile\"};\n    if (solution.removeSubfolders(folders2) != expected2) {\n        cout << \"Test Case 2 failed!\" << endl;\n        return -1;\n    }\n    \n    // Test Case 3\n    vector<string> folders3 = {\"/home/a/1.txt\",\"/home/a/b/d/1.txt\"};\n    vector<string> expected3 = {\"/home/a\", \"/home/a/b/d\"};\n    if (solution.removeSubfolders(folders3) != expected3) {\n        cout << \"Test Case 3 failed!\" << endl;\n        return -1;\n    }\n    \n    cout << \"All test cases passed!\" << endl;\n    return 0;\n}\n```",
  "1234": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string balancedStringSplit(string s) {\n        int res = 0;\n        int bal = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == 'B') bal++;\n            else if (s[i] == 'L') bal--;\n            if (bal == 0) res++, bal = 0;\n        }\n        return to_string(res);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.balancedStringSplit(\"WAAAABBBOWAAA\") << endl; // Expected output: \"3\"\n    cout << solution.balancedStringSplit(\"BBBBBBBBBBBBBBBBAAAAA\") << endl; // Expected output: \"12\"\n    cout << solution.balancedStringSplit(\"B\") << endl; // Expected output: \"1\"\n\n    return 0;\n}\n```",
  "1235": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxProfitAssignment(std::vector<int>& startAtTime, int startTime, int endTime) {\n    int n = startAtTime.size();\n    std::vector<std::pair<int, int>> jobs;\n    for (int i = 0; i < n; ++i) {\n        jobs.emplace_back(startAtTime[i], startAtTime[i]);\n    }\n\n    std::sort(jobs.begin(), jobs.end());\n\n    int maxProfit = 0;\n    int maxEnd = 0;\n    for (const auto& job : jobs) {\n        if (job.second >= endTime) break;\n        if (job.first > startTime && job.second <= endTime) {\n            maxProfit = std::max(maxProfit, job.second - job.first);\n            maxEnd = job.second;\n        }\n    }\n\n    return maxProfit;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<int> startAtTime1 = {100,200,300,400};\n    int startTime1 = 150;\n    int endTime1 = 250;\n    int result1 = maxProfitAssignment(startAtTime1, startTime1, endTime1);\n    std::cout << \"Test Case 1: \" << result1 << \"\\n\";\n\n    // Test Case 2\n    std::vector<int> startAtTime2 = {1,2,4,8};\n    int startTime2 = 0;\n    int endTime2 = 10;\n    int result2 = maxProfitAssignment(startAtTime2, startTime2, endTime2);\n    std::cout << \"Test Case 2: \" << result2 << \"\\n\";\n\n    // Test Case 3\n    std::vector<int> startAtTime3 = {1};\n    int startTime3 = 0;\n    int endTime3 = 5;\n    int result3 = maxProfitAssignment(startAtTime3, startTime3, endTime3);\n    std::cout << \"Test Case 3: \" << result3 << \"\\n\";\n\n    return 0;\n}\n```",
  "1236": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    string val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(string x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<string> crawl(vector<TreeNode*> root, int limit) {\n        vector<string> result;\n        queue<TreeNode*> q;\n        for (TreeNode* node : root) {\n            q.push(node);\n        }\n        \n        while (!q.empty()) {\n            int levelSize = q.size();\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                \n                if (i < limit) {\n                    result.push_back(node->val);\n                }\n                \n                if (node->left) {\n                    q.push(node->left);\n                }\n                \n                if (node->right) {\n                    q.push(node->right);\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<TreeNode*> root = {new TreeNode(\"A\"), new TreeNode(\"B\"), new TreeNode(\"C\"), \n                                new TreeNode(\"D\"), new TreeNode(\"E\"), new TreeNode(\"F\")};\n    root[0]->left = root[1];\n    root[0]->right = root[2];\n    root[1]->left = root[3];\n    root[1]->right = root[4];\n    root[2]->right = root[5];\n    \n    vector<string> result1 = solution.crawl(root, 3);\n    for (string s : result1) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<TreeNode*> root2 = {new TreeNode(\"A\"), new TreeNode(\"B\"), new TreeNode(\"C\")};\n    root2[0]->left = root2[1];\n    root2[0]->right = root2[2];\n\n    vector<string> result2 = solution.crawl(root2, 2);\n    for (string s : result2) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<TreeNode*> root3 = {new TreeNode(\"A\")};\n    \n    vector<string> result3 = solution.crawl(root3, 1);\n    for (string s : result3) {\n        cout << s << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1237": "```\n#include <iostream>\n#include <vector>\n\nint myPow(int x, int n) {\n    if (n == 0) return 1;\n    if (n % 2 == 0)\n        return myPow(x * x, n / 2);\n    else\n        return x * myPow(x, n - 1);\n}\n\nbool judgeSquareSum(int c) {\n    for (int a = 0; ; a++) {\n        int b = (int)pow(c - a * a, .5f);\n        if ((a * a + b * b == c)) return true;\n        else if (b < a) break;\n    }\n    return false;\n}\n\nint main() {\n    std::cout << judgeSquareSum(5) << std::endl;  // True\n    std::cout << judgeSquareSum(3) << std::endl;  // False\n    std::cout << judgeSquareSum(12) << std::endl;  // True\n\n    return 0;\n}\n```",
  "1238": "```\n#include <iostream>\n#include <vector>\n\nint findCircularPermutation(int n) {\n    std::vector<std::string> res;\n    for (int i = 0; i < (1 << n); i++) {\n        int x = i ^ (i >> 1);\n        if ((x & 1) && !((x >> 1) & 1)) continue;\n        if (!((x >> 1) & 1)) break;\n        res.push_back(std::to_string(x));\n    }\n    return res.size();\n}\n\nint main() {\n    int n1 = 3;\n    std::cout << \"Number of circular permutations for \" << n1 << \": \" << findCircularPermutation(n1) << std::endl;\n\n    int n2 = 4;\n    std::cout << \"Number of circular permutations for \" << n2 << \": \" << findCircularPermutation(n2) << std::endl;\n\n    int n3 = 5;\n    std::cout << \"Number of circular permutations for \" << n3 << \": \" << findCircularPermutation(n3) << std::endl;\n\n    return 0;\n}\n```",
  "1239": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumUniqueSubarray(vector<string>& inputs) {\n        int n = inputs.size();\n        set<char> st;\n        vector<int> last(n, -1);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (last[i] == -1 || inputs[i][0] != inputs[last[i]][inputs[last[i]].size() - 1]) {\n                st.clear();\n                for (char c : inputs[i])\n                    st.insert(c);\n                res += inputs[i].size();\n            } else {\n                set<char> temp(st);\n                temp.erase(inputs[i][0]);\n                res += (int)temp.size();\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> inputs1 = {\"aacqua\", \"aa\"};\n    cout << \"Test case 1: \" << solution.maximumUniqueSubarray(inputs1) << endl; // Output: 7\n\n    vector<string> inputs2 = {\"abacaba\", \"abcba\", \"bcbab\"};\n    cout << \"Test case 2: \" << solution.maximumUniqueSubarray(inputs2) << endl; // Output: 12\n\n    vector<string> inputs3 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\"};\n    cout << \"Test case 3: \" << solution.maximumUniqueSubarray(inputs3) << endl; // Output: 10\n}\n```",
  "1241": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint totalComments(std::vector<std::vector<int>>& post) {\n    int total = 0;\n    for (const auto& comments : post) {\n        total += comments[1];\n    }\n    return total;\n}\n\nint main() {\n    std::vector<std::vector<int>> posts = {\n        {1, 5},\n        {2, 3},\n        {4, 8}\n    };\n\n    int result1 = totalComments(posts);\n    int result2 = totalComments({{1, 0}, {2, 10}});\n    int result3 = totalComments({});\n\n    std::cout << \"Test case 1: Total comments for posts are \" << result1 << std::endl;\n    std::cout << \"Test case 2: Total comments for posts are \" << result2 << std::endl;\n    std::cout << \"Test case 3: Total comments for posts are \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1240": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int tilingRectangle(int w, int h) {\n        if (w == 0 || h == 0)\n            return 0;\n        \n        int result = INT_MAX;\n        for (int i = 1; i <= w && i <= h; i++) {\n            int a = w / i;\n            int b = h / i;\n            int count = a * b + (w % i != 0 ? a : 0) + (h % i != 0 ? b : 0);\n            result = min(result, count);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: w=10, h=15, expected result: 20\" << endl;\n    cout << \"Actual result: \" << solution.tilingRectangle(10, 15) << endl;\n    cout << \"Pass?\" << (solution.tilingRectangle(10, 15) == 20 ? \"Yes\" : \"No\") << endl;\n\n    cout << \"Test case 2: w=3, h=12, expected result: 6\" << endl;\n    cout << \"Actual result: \" << solution.tilingRectangle(3, 12) << endl;\n    cout << \"Pass?\" << (solution.tilingRectangle(3, 12) == 6 ? \"Yes\" : \"No\") << endl;\n\n    cout << \"Test case 3: w=5, h=8, expected result: 4\" << endl;\n    cout << \"Actual result: \" << solution.tilingRectangle(5, 8) << endl;\n    cout << \"Pass?\" << (solution.tilingRectangle(5, 8) == 4 ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}\n```",
  "1242": "```\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n\nusing namespace std;\n\nclass WebCrawler {\npublic:\n    vector<string> crawl(vector<vector<string>>& graph, string start, int depth) {\n        vector<string> visited;\n        queue<pair<string, int>> q;\n        q.push({start, 0});\n        \n        while (!q.empty()) {\n            pair<string, int> node = q.front();\n            q.pop();\n            \n            if (node.second <= depth && find(visited.begin(), visited.end(), node.first) == visited.end()) {\n                visited.push_back(node.first);\n                \n                for (string neighbor : graph[node.first]) {\n                    q.push({neighbor, node.second + 1});\n                }\n            }\n        }\n        \n        return visited;\n    }\n};\n\nint main() {\n    WebCrawler crawler;\n    \n    // Test case 1\n    vector<vector<string>> graph1 = {{\"A\", \"B\", \"C\"}, {\"D\", \"E\"}};\n    vector<string> result1 = crawler.crawl(graph1, \"A\", 2);\n    for (string node : result1) {\n        cout << node << \" \";\n    }\n    cout << endl;\n    \n    // Test case 2\n    vector<vector<string>> graph2 = {{\"F\", \"G\"}, {\"H\", \"I\"}};\n    vector<string> result2 = crawler.crawl(graph2, \"F\", 2);\n    for (string node : result2) {\n        cout << node << \" \";\n    }\n    cout << endl;\n    \n    // Test case 3\n    vector<vector<string>> graph3 = {{\"J\"}, {\"K\", \"L\"}};\n    vector<string> result3 = crawler.crawl(graph3, \"J\", 1);\n    for (string node : result3) {\n        cout << node << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1243": "```\n#include <iostream>\n#include <vector>\n\nint arrayTransform(std::vector<int>& nums) {\n    int n = nums.size();\n    for (int i = 1; i < n; i++) {\n        if (nums[i] != nums[i - 1]) {\n            nums[i]++;\n        }\n    }\n    return nums[0];\n}\n\nint main() {\n    std::vector<int> test1 = {5, 6, 7};\n    std::cout << \"Test 1: \" << arrayTransform(test1) << std::endl;\n    \n    std::vector<int> test2 = {1, 1, 2, 3, 4, 5};\n    std::cout << \"Test 2: \" << arrayTransform(test2) << std::endl;\n\n    std::vector<int> test3 = {100, 101, 102, 103};\n    std::cout << \"Test 3: \" << arrayTransform(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1244": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass Leaderboard {\npublic:\n    map<int, int> scoreMap;\n    \n    void addScore(string username, int score) {\n        if (scoreMap.find(score) == scoreMap.end()) {\n            scoreMap[score] = 1;\n        } else {\n            scoreMap[score]++;\n        }\n    }\n    \n    vector<vector<string>> getScores(int k) {\n        vector<vector<string>> result;\n        for (auto it = scoreMap.rbegin(); it != scoreMap.rend() && result.size() < k; ++it) {\n            int score = it->first;\n            int count = it->second;\n            result.push_back({to_string(score), to_string(count)});\n        }\n        return result;\n    }\n};\n\nint main() {\n    Leaderboard lb;\n\n    // Test case 1\n    lb.addScore(\"bob\", 100);\n    lb.addScore(\"alice\", 100);\n    lb.addScore(\"bob\", 200);\n    vector<vector<string>> scores = lb.getScores(2);\n    for (auto &score : scores) {\n        cout << \"[\" << score[0] << \", \" << score[1] << \"], \";\n    }\n    cout << endl;\n\n    // Test case 2\n    lb.addScore(\"charlie\", 300);\n    vector<vector<string>> scores2 = lb.getScores(3);\n    for (auto &score : scores2) {\n        cout << \"[\" << score[0] << \", \" << score[1] << \"], \";\n    }\n    cout << endl;\n\n    // Test case 3\n    lb.addScore(\"bob\", 100);\n    vector<vector<string>> scores3 = lb.getScores(3);\n    for (auto &score : scores3) {\n        cout << \"[\" << score[0] << \", \" << score[1] << \"], \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1245": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int treeDiameter(TreeNode* root) {\n        if (!root) return 0;\n        int diameter = 0, maxDepth = 0;\n        function<int(TreeNode*)> dfs = [&](TreeNode* node) {\n            if (!node) return 0;\n            int left = dfs(node->left);\n            int right = dfs(node->right);\n            diameter = max(diameter, left + right);\n            return max(left, right) + 1;\n        };\n        maxDepth = dfs(root);\n        root = root ? root->left : root->right;\n        return max(0, treeDiameter(root));\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1:\n    TreeNode* node4 = new TreeNode(3);\n    TreeNode* node5 = new TreeNode(5);\n    TreeNode* node6 = new TreeNode(2);\n    node4->left = node5;\n    node4->right = node6;\n    cout << \"Test case 1: \" << solution.treeDiameter(node4) << endl;\n\n    // Test case 2:\n    TreeNode* node7 = new TreeNode(0);\n    TreeNode* node8 = new TreeNode(3);\n    TreeNode* node9 = new TreeNode(2);\n    TreeNode* node10 = new TreeNode(1);\n    node7->left = node8;\n    node8->right = node9;\n    node9->left = node10;\n    cout << \"Test case 2: \" << solution.treeDiameter(node7) << endl;\n\n    // Test case 3:\n    TreeNode* node11 = new TreeNode(1);\n    TreeNode* node12 = new TreeNode(0);\n    TreeNode* node13 = new TreeNode(-2);\n    node11->left = node12;\n    node12->right = node13;\n    cout << \"Test case 3: \" << solution.treeDiameter(node11) << endl;\n\n    return 0;\n}\n```",
  "1246": "```\n#include <iostream>\n#include <vector>\n\nint minSteps(std::vector<std::string>& s) {\n    int n = s.size();\n    std::vector<int> prefix(n), suffix(n);\n    prefix[0] = (s[0].size() == 0 ? 1 : 0);\n    for (int i = 1; i < n; ++i) {\n        prefix[i] = prefix[i - 1] + (s[i].size() > 0);\n    }\n    suffix[n - 1] = (s[n - 1].size() == 0 ? 1 : 0);\n    for (int i = n - 2; i >= 0; --i) {\n        suffix[i] = suffix[i + 1] + (s[i].size() > 0);\n    }\n    int total = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i].size() == 0) {\n            total += prefix[i];\n            total += suffix[i];\n        } else {\n            total += min(prefix[i], suffix[n - i - 1]);\n        }\n    }\n    return total;\n}\n\nint main() {\n    std::vector<std::string> s1 = {\"leet\", \"code\"};\n    std::cout << \"Test case 1: \" << minSteps(s1) << std::endl;\n\n    std::vector<std::string> s2 = {\"\"};\n    std::cout << \"Test case 2: \" << minSteps(s2) << std::endl;\n\n    std::vector<std::string> s3 = {\"good\", \"live\", \"evil\", \"noon\"};\n    std::cout << \"Test case 3: \" << minSteps(s3) << std::endl;\n    \n    return 0;\n}",
  "1247": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint minSwaps(string s1, string s2) {\n    int n = s1.size();\n    vector<int> cnt(26, 0);\n    for (int i = 0; i < n; ++i)\n        cnt[s1[i] - 'a']++, cnt[s2[i] - 'a']--;\n\n    int swaps = 0;\n    for (int i = 0; i < 26; ++i) {\n        if (cnt[i] > 0) {\n            --cnt[i];\n            while (n-- > 0 && s1[n] != 'a' + i)\n                --n;\n            if (n >= 0)\n                swaps += n;\n            else\n                return -1; // impossible to achieve equality\n        }\n    }\n\n    int diff = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s1[i] != s2[i]) {\n            if (diff > 0)\n                diff--;\n            else\n                diff++;\n        }\n    }\n\n    return min(swaps, diff);\n}\n\nint main() {\n    cout << minSwaps(\"dcce\", \"cced\") << endl;\n    cout << minSwaps(\"foot\", \"toot\") << endl;\n    cout << minSwaps(\"abc\", \"bac\") << endl;\n\n    return 0;\n}\n```",
  "1248": "```\n#include <iostream>\n#include <vector>\n\nint numberOfSubarrays(std::vector<int>& nums) {\n    int n = nums.size();\n    int res = 0;\n    for (int l = 0, r = 0; r < n; ++r) {\n        if ((r > l && nums[r] % 2 == 1) || l == r) {\n            ++l;\n            continue;\n        }\n        while (l <= r && (nums[l] % 2 == 1)) {\n            ++l;\n        }\n        res += r - l + 1;\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {2, 2, 0};\n    std::cout << \"Test Case 1: \" << numberOfSubarrays(test1) << std::endl; // Output: 8\n\n    std::vector<int> test2 = {0, 0, 4, 22, 6};\n    std::cout << \"Test Case 2: \" << numberOfSubarrays(test2) << std::endl; // Output: 12\n\n    std::vector<int> test3 = {1, 1, 1, 1, 1};\n    std::cout << \"Test Case 3: \" << numberOfSubarrays(test3) << std::endl; // Output: 10\n\n    return 0;\n}\n```",
  "1249": "```\n#include <iostream>\n#include <string>\n\nint minRemoveToMakeValid(std::string s) {\n    int left = 0;\n    for (char c : s) {\n        if (c == '(') {\n            left++;\n        } else if (c == ')') {\n            if (left > 0) {\n                left--;\n            } else {\n                return s.size() - s.find(c);\n            }\n        }\n    }\n    return left;\n}\n\nint main() {\n    std::cout << minRemoveToMakeValid(\"lee(t(c)odes)((((\")) << std::endl; // Expected output: 1\n    std::cout << minRemoveToMakeValid(\"a(b(c)d)\"\")\" << std::endl; // Expected output: 0\n    std::cout << minRemoveToMakeValid(\"))(]\" << std::endl; // Expected output: 4\n\n    return 0;\n}\n```",
  "1250": "```\n#include <iostream>\n#include <vector>\n\nbool CheckGoodArray(std::vector<int>& nums) {\n    int n = nums.size();\n    for (int i = 0; i < n - 1; ++i) {\n        if (nums[i] + 1 != nums[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> test1 = {10,12,15,20};\n    std::cout << \"Test Case 1: \" << (CheckGoodArray(test1) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> test2 = {7,8,9,11,12};\n    std::cout << \"Test Case 2: \" << (CheckGoodArray(test2) ? \"True\" : \"False\") << std::endl;\n\n    std::vector<int> test3 = {1,5,6,10,20,21};\n    std::cout << \"Test Case 3: \" << (CheckGoodArray(test3) ? \"True\" : \"False\") << std::endl;\n    \n    return 0;\n}\n```",
  "1251": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\ndouble average(int[] prices) {\n    double sum = 0;\n    for (int price : prices) {\n        sum += price;\n    }\n    return sum / prices.size();\n}\n\nint main() {\n    // Test case 1\n    int[] prices1 = {10, 7, 5, 8, 11};\n    std::cout << \"Average selling price of \" << std::endl;\n    for (int price : prices1) {\n        std::cout << price << \" \";\n    }\n    std::cout << std::endl;\n    double avg1 = average(prices1);\n    std::cout << \"is \" << avg1 << \".\\n\";\n\n    // Test case 2\n    int[] prices2 = {10, 5};\n    std::cout << \"Average selling price of \" << std::endl;\n    for (int price : prices2) {\n        std::cout << price << \" \";\n    }\n    std::cout << std::endl;\n    double avg2 = average(prices2);\n    std::cout << \"is \" << avg2 << \".\\n\";\n\n    // Test case 3\n    int[] prices3 = {10};\n    std::cout << \"Average selling price of \" << std::endl;\n    for (int price : prices3) {\n        std::cout << price << \" \";\n    }\n    std::cout << std::endl;\n    double avg3 = average(prices3);\n    std::cout << \"is \" << avg3 << \".\\n\";\n\n    return 0;\n}\n```",
  "1252": "```\n#include <iostream>\n#include <vector>\n\nint oddCells(int m, int n, std::vector<std::vector<int>>& indices) {\n    std::vector<int> row(m, 0);\n    std::vector<int> col(n, 0);\n\n    for (const auto& index : indices) {\n        row[index[0]]++;\n        col[index[1]]++;\n    }\n\n    int count = 0;\n    for (int i = 0; i < m; ++i) {\n        if (row[i] % 2 != 0) {\n            for (int j = 0; j < n; ++j) {\n                if (col[j] % 2 != 0) {\n                    count++;\n                    break;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    int m1 = 3, n1 = 3;\n    std::vector<std::vector<int>> indices1 = {{0, 2}, {1, 1}};\n    std::cout << \"Test Case 1: \" << oddCells(m1, n1, indices1) << std::endl;\n\n    int m2 = 2, n2 = 3;\n    std::vector<std::vector<int>> indices2 = {{1, 2}};\n    std::cout << \"Test Case 2: \" << oddCells(m2, n2, indices2) << std::endl;\n\n    int m3 = 5, n3 = 4;\n    std::vector<std::vector<int>> indices3 = {{0, 0}, {1, 1}, {4, 3}};\n    std::cout << \"Test Case 3: \" << oddCells(m3, n3, indices3) << std::endl;\n\n    return 0;\n}\n```",
  "1253": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& cols) {\n        vector<vector<int>> res(2, vector<int>(cols.size(), 0));\n        \n        for (int i = 0; i < cols.size(); ++i) {\n            if (cols[i] == 1) {\n                if (upper > lower) {\n                    --upper;\n                    for (int j = 0; j < 2; ++j) {\n                        res[j][i] = 1;\n                    }\n                } else {\n                    --lower;\n                    for (int j = 0; j < 2; ++j) {\n                        res[j][i] = 1;\n                    }\n                }\n            }\n        }\n        \n        if (upper > 0) {\n            for (int i = 0; i < cols.size(); ++i) {\n                if (!res[0][i]) {\n                    res[0][i] = 1;\n                    --upper;\n                    if (upper == 0) break;\n                }\n            }\n        }\n        \n        if (lower > 0) {\n            for (int i = 0; i < cols.size(); ++i) {\n                if (!res[1][i]) {\n                    res[1][i] = 1;\n                    --lower;\n                    if (lower == 0) break;\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int upper1 = 2, lower1 = 3, size1 = 4;\n    vector<int> cols1({1, 1, 1, 0});\n    vector<vector<int>> result1 = solution.reconstructMatrix(upper1, lower1, cols1);\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < size1; ++j) {\n            cout << result1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test Case 2\n    int upper2 = 3, lower2 = 2, size2 = 5;\n    vector<int> cols2({0, 1, 1, 0, 0});\n    vector<vector<int>> result2 = solution.reconstructMatrix(upper2, lower2, cols2);\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < size2; ++j) {\n            cout << result2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test Case 3\n    int upper3 = 1, lower3 = 1, size3 = 6;\n    vector<int> cols3({0, 0, 0, 1, 1, 1});\n    vector<vector<int>> result3 = solution.reconstructMatrix(upper3, lower3, cols3);\n    for (int i = 0; i < 2; ++i) {\n        for (int j = 0; j < size3; ++j) {\n            cout << result3[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1254": "```\n#include <iostream>\n#include <vector>\n\nint closedIsland(std::vector<std::vector<int>>& grid) {\n    if (grid.empty()) return 0;\n\n    int m = grid.size(), n = grid[0].size();\n    for (int i = 0; i < m; ++i)\n        for (int j = 0; j < n; ++j)\n            if (grid[i][j] == 1) break;\n    for (int i = m - 1; i >= 0; --i)\n        for (int j = 0; j < n; ++j)\n            if (grid[i][j] == 1) break;\n\n    int count = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) continue;\n            bool isIsland = true;\n            dfs(grid, i, j);\n            if (!isIsland) count++;\n        }\n    }\n\n    return count;\n}\n\nvoid dfs(std::vector<std::vector<int>>& grid, int i, int j) {\n    int m = grid.size(), n = grid[0].size();\n    if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0)\n        return;\n\n    grid[i][j] = 0;\n    dfs(grid, i - 1, j);\n    dfs(grid, i + 1, j);\n    dfs(grid, i, j - 1);\n    dfs(grid, i, j + 1);\n}\n\nint main() {\n    std::vector<std::vector<int>> grid1{{0,1},{0,1}};\n    std::cout << closedIsland(grid1) << std::endl;\n\n    std::vector<std::vector<int>> grid2{{1,1,1,1,0},{1,1,0,1,0},{1,1,1,1,0},{1,0,0,0,0}};\n    std::cout << closedIsland(grid2) << std::endl;\n\n    std::vector<std::vector<int>> grid3{{0,0,0},{1,1,0},{0,0,0}};\n    std::cout << closedIsland(grid3) << std::endl;\n\n    return 0;\n}",
  "1255": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxScoreWords(vector<string>& words, vector<char>& chars) {\n        unordered_map<int, int> scoreMap;\n        for (int i = 0; i < (1 << words.size()); ++i) {\n            int score = 0;\n            string word = \"\";\n            for (int j = 0; j < words.size(); ++j) {\n                if ((i & (1 << j)) != 0) {\n                    word += words[j];\n                    for (char c : words[j]) {\n                        chars[find(c, 'a', 'z') - 'a']--;\n                    }\n                    score++;\n                }\n            }\n            scoreMap[i] = score;\n        }\n        return *max_element(scoreMap.begin(), scoreMap.end());\n    }\n\n    int find(char c, char start, char end) {\n        for (char i = start; i <= end; ++i) {\n            if (c == i) {\n                return i - start;\n            }\n        }\n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> words1 = {\"dog\", \"cat\", \"dad\", \"good\"};\n    vector<char> chars1 = {'a', 'a', 'c', 'd', 'd', 'd', 'g', 'o', 'o'};\n    cout << solution.maxScoreWords(words1, chars1) << endl;\n\n    // Test case 2\n    vector<string> words2 = {\"aaa\", \"bbb\", \"cc\"};\n    vector<char> chars2 = {'a', 'b', 'b', 'c', 'c'};\n    cout << solution.maxScoreWords(words2, chars2) << endl;\n\n    // Test case 3\n    vector<string> words3 = {};\n    vector<char> chars3 = {};\n    cout << solution.maxScoreWords(words3, chars3) << endl;\n\n    return 0;\n}\n```",
  "1256": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string encodeNumber(int num) {\n        if (num == 0) return \"0\";\n        \n        std::string result = \"\";\n        bool isNegative = false;\n        \n        if (num < 0) {\n            isNegative = true;\n            num *= -1;\n        }\n        \n        while (num > 0) {\n            int digit = num % 10;\n            num /= 10;\n            \n            for (int i = 0; i < digit; ++i) {\n                result.push_back('1');\n            }\n            \n            if (digit == 0) {\n                result.push_back('0');\n            } else {\n                result.push_back('2' + '0' - '0' + digit);\n            }\n        }\n        \n        if (isNegative) {\n            result = '-' + result;\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int num1 = 4;\n    std::string expected1 = \"1000\";\n    std::cout << (solution.encodeNumber(num1) == expected1) << std::endl; // True\n\n    int num2 = -14;\n    std::string expected2 = \"-3-22\";\n    std::cout << (solution.encodeNumber(num2) == expected2) << std::endl; // True\n\n    int num3 = 0;\n    std::string expected3 = \"0\";\n    std::cout << (solution.encodeNumber(num3) == expected3) << std::endl; // True\n\n    return 0;\n}\n```",
  "1257": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    string largestRegion(vector<vector<char>>& grid) {\n        if(grid.empty()) return \"\";\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n));\n        vector<pair<int, int>> directions={{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        int maxRegion = 0;\n        for(int i=0; i<m; i++){\n            for(int j=0; j<n; j++){\n                if(!visited[i][j] && grid[i][j] == 'O'){\n                    int regionSize = dfs(grid, visited, directions, i, j);\n                    maxRegion = max(maxRegion, regionSize);\n                }\n            }\n        }\n        return to_string(maxRegion);\n    }\n\n    int dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, vector<pair<int, int>>& directions, int i, int j){\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() || !visited[i][j] || grid[i][j] != 'O'){\n            return 0;\n        }\n        visited[i][j] = true;\n        int regionSize = 1;\n        for(auto dir: directions){\n            int ni = i + dir.first, nj = j + dir.second;\n            if(ni>=0 && ni<grid.size() && nj>=0 && nj<grid[0].size()){\n                if(grid[ni][nj] == 'O' && !visited[ni][nj]){\n                    regionSize += dfs(grid, visited, directions, ni, nj);\n                }\n            }\n        }\n        return regionSize;\n    }\n\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<char>> grid1 = {{'O','O','O','O','O'},\n                                  {'O','O','O','O','O'},\n                                  {'O','O','O','O','O'},\n                                  {'O','O','O','O','O'},\n                                  {'O','O','O','O','S'}};\n    cout << solution.largestRegion(grid1) << endl;  // Output: 5\n\n    // Test case 2\n    vector<vector<char>> grid2 = {{'O','O','O','O','O'},\n                                  {'O','O','O','O','O'},\n                                  {'O','O','O','O','S'},\n                                  {'O','O','O','O','S'},\n                                  {'O','O','O','O','S'}};\n    cout << solution.largestRegion(grid2) << endl;  // Output: 4\n\n    // Test case 3\n    vector<vector<char>> grid3 = {{'O','O','O','O','O'},\n                                  {'O','O','O','O','O'},\n                                  {'O','O','S','O','S'},\n                                  {'O','O','S','O','S'},\n                                  {'O','O','S','O','S'}};\n    cout << solution.largestRegion(grid3) << endl;  // Output: 5\n\n    return 0;\n}\n```",
  "1258": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass UnionFind {\npublic:\n    void unionElements(int x, int y) {\n        if (parent[x] != -1 && parent[y] != -1)\n            return;\n        if (parent[x] == -1) parent[x] = y;\n        else if (parent[y] == -1) parent[y] = x;\n        else {\n            parent[x] = parent[y];\n        }\n    }\n\n    bool isConnected(int x, int y) {\n        if (parent[x] == parent[y])\n            return true;\n        return false;\n    }\n\n    vector<int> groupMembers(int x) {\n        vector<int> memberList;\n        while (x != -1) {\n            memberList.push_back(x);\n            x = parent[x];\n        }\n        return memberList;\n    }\n\nprivate:\n    int* parent;\n};\n\nclass Solution {\npublic:\n    vector<string> groupStrings(vector<string>& strArr) {\n        int n = strArr.size();\n        UnionFind uf = UnionFind();\n        uf.parent = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            uf.parent[i] = -1;\n        }\n\n        for (auto s : strArr) {\n            vector<int> indices;\n            for (int i = 0; i < s.length(); i++) {\n                if (s[i] == ' ') continue;\n                int asciiVal = (int)s[i];\n                indices.push_back(asciiVal);\n            }\n            for (int i = 1; i < indices.size(); i++) {\n                uf.unionElements(indices[i - 1], indices[i]);\n            }\n        }\n\n        vector<string> groups;\n        for (int i = 0; i < n; i++) {\n            if (uf.isConnected(0, i)) continue;\n            vector<int> groupMembers = uf.groupMembers(i);\n            string groupStr;\n            for (int x : groupMembers) {\n                int asciiVal = x;\n                groupStr += (char)asciiVal;\n            }\n            groups.push_back(groupStr);\n        }\n\n        return groups;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> strArr1 = {\"This\", \"is\", \"an\", \"example\"};\n    vector<string> strArr2 = {\"hello\", \"world\", \"test\"};\n    vector<string> strArr3 = {\"apple\", \"banana\", \"grapes\"};\n\n    vector<string> result1 = solution.groupStrings(strArr1);\n    vector<string> result2 = solution.groupStrings(strArr2);\n    vector<string> result3 = solution.groupStrings(strArr3);\n\n    for (auto s : result1) {\n        cout << s << endl;\n    }\n    cout << \"----------------------------\" << endl;\n\n    for (auto s : result2) {\n        cout << s << endl;\n    }\n    cout << \"----------------------------\" << endl;\n\n    for (auto s : result3) {\n        cout << s << endl;\n    }\n\n    return 0;\n}\n```",
  "1259": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint maxHappyFriends(int n) {\n    if (n == 1)\n        return 0;\n    vector<int> dp(n+1);\n    for (int i = 2; i <= n; i++) {\n        dp[i] = min(i-1, dp[i-1] + i);\n    }\n    return dp[n];\n}\n\nint main() {\n    cout << maxHappyFriends(3) << endl;\n    cout << maxHappyFriends(4) << endl;\n    cout << maxHappyFriends(5) << endl;\n}\n```",
  "1260": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int>> shiftGrid(std::vector<std::vector<int>>& grid, int k) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    // Calculate the total number of elements\n    int totalElements = rows * cols;\n    \n    // Shift each element 'k' times\n    for (int i = 0; i < k % totalElements; i++) {\n        // Store the last row in a temp variable\n        std::vector<int> temp = grid[rows - 1];\n        \n        // Shift elements from right to left\n        for (int j = cols - 1; j > 0; j--) {\n            grid[j] = grid[j-1];\n        }\n        \n        // Add the temp element at the beginning\n        grid[0] = temp;\n    }\n    \n    return grid;\n}\n\nint main() {\n    std::vector<std::vector<int>> grid1 = {{1,2,3},{4,5,6}};\n    int k1 = 1;\n    std::cout << \"Test case 1: \";\n    for (const auto& row : shiftGrid(grid1, k1)) {\n        for (int col : row) {\n            std::cout << col << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> grid2 = {{1, 2, 3}, {4, 5, 6}};\n    int k2 = 2;\n    std::cout << \"Test case 2: \";\n    for (const auto& row : shiftGrid(grid2, k2)) {\n        for (int col : row) {\n            std::cout << col << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> grid3 = {{1, 2}, {4, 8}};\n    int k3 = 1;\n    std::cout << \"Test case 3: \";\n    for (const auto& row : shiftGrid(grid3, k3)) {\n        for (int col : row) {\n            std::cout << col << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "1261": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<int> findClosestElements(TreeNode root, int target) {\n        vector<int> res;\n        if (root == NULL)\n            return res;\n\n        map<TreeNode*, pair<int, int>> mp;\n        queue<TreeNode*> q;\n        q.push(root);\n        mp[root] = make_pair(INT_MAX, INT_MIN);\n\n        while (!q.empty()) {\n            TreeNode* t = q.front();\n            q.pop();\n\n            if (t->val <= target) {\n                res.push_back(t->val);\n                if (res.size() == k)\n                    break;\n            }\n\n            if (t->left && mp.find(t->left) == mp.end())\n                q.push(t->left), mp[t->left] = make_pair(INT_MAX, INT_MIN);\n\n            if (t->right && mp.find(t->right) == mp.end())\n                q.push(t->right), mp[t->right] = make_pair(INT_MAX, INT_MIN);\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test Case 1:\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(3);\n    root1->left->left = new TreeNode(2);\n    root1->right = new TreeNode(6);\n    root1->right->right = new TreeNode(7);\n    cout << \"Test Case 1: \";\n    for (int x : s.findClosestElements(root1, 5.5)) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2:\n    TreeNode* root2 = new TreeNode(10);\n    root2->left = new TreeNode(6);\n    root2->right = new TreeNode(15);\n    root2->right->left = new TreeNode(12);\n    root2->right->right = new TreeNode(20);\n    cout << \"Test Case 2: \";\n    for (int x : s.findClosestElements(root2, 12.6)) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3:\n    TreeNode* root3 = new TreeNode(3);\n    root3->left = new TreeNode(1);\n    root3->right = new TreeNode(4);\n    cout << \"Test Case 3: \";\n    for (int x : s.findClosestElements(root3, 2.5)) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1262": "```\n#include <iostream>\n#include <vector>\n\nint maximumSumDivByThree(std::vector<int>& nums) {\n    int dp[] = {0, 0, 0}; // dp[i] is the maximum sum that ends at i % 3 == 0\n    for (int num : nums) {\n        std::vector<int> nextDp({dp[1], dp[2], (dp[0] + num) % 3});\n        dp = nextDp;\n    }\n    return std::max({dp[0], dp[1], dp[2]});\n}\n\nint main() {\n    std::cout << maximumSumDivByThree({2,1,10,1}) << std::endl; // Output: 12\n    std::cout << maximumSumDivByThree({1,2,-5,7,9,4,8,6}) << std::endl; // Output: 24\n    std::cout << maximumSumDivByThree({0}) << std::endl; // Output: 0\n    return 0;\n}",
  "1263": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMovesToTarget(int target[], vector<vector<int>>& arr) {\n        int n = arr.size();\n        int res = INT_MAX;\n        \n        for (int i = 0; i < n; ++i) {\n            priority_queue<pair<int, int>> q;\n            int pos = -1, moves = 0;\n            for (int j = 0; j < n; ++j) {\n                if (arr[j][1] == target[0]) pos = j;\n                else if (arr[j][1] < target[0]) q.push({-arr[j][1], j});\n            }\n            \n            while (!q.empty()) {\n                int move = q.top().first, box = q.top().second;\n                q.pop();\n                \n                if (box == pos) break;\n                moves += move;\n                \n                for (int j = 0; j < n; ++j) {\n                    if (arr[j][1] < target[0]) {\n                        int newMove = max(0, -arr[j][1]);\n                        q.push({newMove, box + arr[j][0]});\n                    }\n                }\n            }\n            \n            res = min(res, moves);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int target[] = {3, 5};\n    vector<vector<int>> arr = {{1, 1}, {2, 5}, {4, 6}};\n    cout << \"Test case 1: \" << solution.minMovesToTarget(target, arr) << endl;\n\n    // Test case 2\n    target[0] = 1; target[1] = 3;\n    arr = {{0, 3}, {1, 1}};\n    cout << \"Test case 2: \" << solution.minMovesToTarget(target, arr) << endl;\n\n    // Test case 3\n    target[0] = 4; target[1] = 7;\n    arr = {{2, 5}, {3, 8}, {6, 9}};\n    cout << \"Test case 3: \" << solution.minMovesToTarget(target, arr) << endl;\n\n    return 0;\n}\n```",
  "1264": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> pageRecommendations(vector<vector<string>>& pages, string user) {\n        map<string, int> likes;\n        for (const auto& page : pages) {\n            if (page[1] == user) {\n                likes[page[0]] = 1;\n            }\n        }\n\n        vector<vector<string>> recommendations;\n        for (const auto& page : pages) {\n            if (!likes.count(page[0])) {\n                recommendations.push_back({page[0], user});\n            }\n        }\n\n        return sortRecommendations(recommendations);\n    }\n\n    vector<vector<string>> sortRecommendations(vector<vector<string>>& recommendations) {\n        vector<vector<string>> sortedRecs;\n        for (const auto& rec : recommendations) {\n            bool inserted = false;\n            for (auto it = sortedRecs.begin(); it != sortedRecs.end(); ++it) {\n                if (rec[0] > (*it)[0]) {\n                    sortedRecs.insert(it, {rec});\n                    inserted = true;\n                    break;\n                }\n            }\n            if (!inserted) {\n                sortedRecs.push_back(rec);\n            }\n        }\n\n        return sortedRecs;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> pages1 = {{\"A\", \"John\"}, {\"B\", \"Jane\"}, {\"C\", \"John\"}};\n    string user1 = \"John\";\n    vector<vector<string>> recommendations1 = solution.pageRecommendations(pages1, user1);\n    cout << \"Test Case 1: \";\n    for (const auto& rec : recommendations1) {\n        cout << \"(\" << rec[0] << \", \" << rec[1] << \") \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<vector<string>> pages2 = {{\"D\", \"Jane\"}, {\"E\", \"John\"}, {\"F\", \"Jane\"}};\n    string user2 = \"Jane\";\n    vector<vector<string>> recommendations2 = solution.pageRecommendations(pages2, user2);\n    cout << \"Test Case 2: \";\n    for (const auto& rec : recommendations2) {\n        cout << \"(\" << rec[0] << \", \" << rec[1] << \") \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<vector<string>> pages3 = {{\"G\", \"John\"}, {\"H\", \"Jane\"}, {\"I\", \"John\"}};\n    string user3 = \"Alice\";\n    vector<vector<string>> recommendations3 = solution.pageRecommendations(pages3, user3);\n    cout << \"Test Case 3: \";\n    for (const auto& rec : recommendations3) {\n        cout << \"(\" << rec[0] << \", \" << rec[1] << \") \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1265": "```\n#include <iostream>\n#include <vector>\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode* next;\n\n    ListNode() : val(0), next(nullptr) {}\n\n    ListNode(int x) : val(x), next(nullptr) {}\n\n    ListNode(int x, ListNode *next) : val(x), next(next) {}\n};\n\nclass Solution {\npublic:\n    void printList(ListNode* head) {\n        while (head) {\n            std::cout << head->val << \" \";\n            head = head->next;\n        }\n        std::cout << \"\\n\";\n    }\n\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n\n        while (curr) {\n            ListNode* nextTemp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n\n    void printReverse(ListNode* head) {\n        ListNode* reversedHead = reverseList(head);\n        printList(reversedHead);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    ListNode* list1 = new ListNode(1, new ListNode(2, new ListNode(3)));\n    solution.printReverse(list1);\n\n    // Test case 2:\n    ListNode* list2 = new ListNode(4, new ListNode(5));\n    solution.printReverse(list2);\n\n    // Test case 3:\n    ListNode* list3 = nullptr;\n    solution.printReverse(list3);\n    \n    return 0;\n}\n```",
  "1266": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint minTimeVisitingAllPoints(std::vector<std::pair<int, int>>& points) {\n    int ans = 0;\n    for (int i = 1; i < points.size(); ++i) {\n        int dx = abs(points[i].first - points[i-1].first);\n        int dy = abs(points[i].second - points[i-1].second);\n        ans += std::max(dx, dy);\n    }\n    return ans;\n}\n\nint main() {\n    std::vector<std::pair<int, int>> points1 {{0, 0}, {2, 2}};\n    std::cout << \"Test case 1: \" << minTimeVisitingAllPoints(points1) << std::endl;\n\n    std::vector<std::pair<int, int>> points2 {{3, 2}, {-4, 5}, {6, -10}};\n    std::cout << \"Test case 2: \" << minTimeVisitingAllPoints(points2) << std::endl;\n\n    std::vector<std::pair<int, int>> points3 {{1, 1}, {2, 2}, {0, 0}};\n    std::cout << \"Test case 3: \" << minTimeVisitingAllPointsss(points3) << std::endl;\n\n    return 0;\n}\n```",
  "1267": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countServers(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        vector<bool> rows(m, false);\n        vector<bool> cols(n, false);\n\n        int result = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    rows[i] = true;\n                    cols[j] = true;\n                }\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1 && (rows[i] || cols[j])) {\n                    result++;\n                }\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> grid1 = {{0,0,0},{1,1,1},{2,2,2}};\n    cout << \"Test Case 1: \" << solution.countServers(grid1) << endl;  // Expected output: 5\n\n    // Test Case 2\n    vector<vector<int>> grid2 = {{1,1}, {1,6}};\n    cout << \"Test Case 2: \" << solution.countServers(grid2) << endl;  // Expected output: 5\n\n    // Test Case 3\n    vector<vector<int>> grid3 = {{0,0,0},{1,1,1},{2,0,2}};\n    cout << \"Test Case 3: \" << solution.countServers(grid3) << endl;  // Expected output: 3\n\n    return 0;\n}\n```",
  "1269": "```\n#include <iostream>\n#include <vector>\n\nint numWays(int n) {\n    if (n == 0) return 1;\n    if (n < 0) return 0;\n\n    std::vector<int> dp(n + 1);\n    dp[0] = 1;\n\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= i; ++j) {\n            if (2 * j == i) {\n                dp[i] += dp[j];\n            }\n        }\n    }\n\n    return dp[n];\n}\n\nint main() {\n    std::cout << \"Test Case 1: numWays(3) = \" << numWays(3) << std::endl;\n    std::cout << \"Test Case 2: numWays(4) = \" << numWays(4) << std::endl;\n    std::cout << \"Test Case 3: numWays(10) = \" << numWays(10) << std::endl;\n\n    return 0;\n}",
  "1268": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass TrieNode {\npublic:\n    char c;\n    bool isWord;\n    TrieNode* children[26];\n\n    TrieNode() : isWord(false) {\n        for (int i = 0; i < 26; i++) {\n            children[i] = NULL;\n        }\n    }\n};\n\nclass Trie {\npublic:\n    TrieNode* root;\n\n    Trie() {\n        root = new TrieNode();\n    }\n\n    void insert(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children[c - 'a']) {\n                node->children[c - 'a'] = new TrieNode();\n            }\n            node = node->children[c - 'a'];\n        }\n        node->isWord = true;\n    }\n\n    vector<string> searchSuggestions(string sentence, int numRows) {\n        vector<string> result;\n        TrieNode* node = root;\n        for (char c : sentence) {\n            if (!node->children[c - 'a']) return result; // no more words\n            node = node->children[c - 'a'];\n        }\n\n        priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> pq;\n        queue<TrieNode*> q;\n        q.push(node);\n        while (!q.empty()) {\n            TrieNode* node = q.front();\n            q.pop();\n\n            if (node->isWord) {\n                pair<int, string> p(-1 * wordLength(node), getWord(node));\n                pq.push(p);\n            }\n\n            for (int i = 0; i < 26; i++) {\n                if (node->children[i]) {\n                    q.push(node->children[i]);\n                }\n            }\n        }\n\n        vector<string> words;\n        while (!pq.empty()) {\n            words.push_back(pq.top().second);\n            pq.pop();\n        }\n\n        for (int i = 0; i < numRows && i < words.size(); i++) {\n            result.push_back(words[i]);\n        }\n\n        return result;\n    }\n};\n\nvector<string> wordSuggest(vector<string>& sentence, int numRows) {\n    Trie trie;\n    vector<string> result;\n    for (string word : sentence) {\n        trie.insert(word);\n    }\n    return trie.searchSuggestions(sentence[0], numRows);\n}\n\nint main() {\n    vector<string> sentence = {\"i love you\", \"isabella\", \"i\", \"love\"};\n    int numRows = 3;\n\n    // Test case 1\n    cout << \"Test Case 1: \";\n    vector<string> result1 = wordSuggest(sentence, numRows);\n    for (string str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n    \n    sentence.clear();\n    sentence.push_back(\"abc\");\n    sentence.push_back(\"defghijklmno\");\n    sentence.push_back(\"bc\");\n\n    // Test case 2\n    cout << \"Test Case 2: \";\n    vector<string> result2 = wordSuggest(sentence, numRows);\n    for (string str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    sentence.clear();\n    sentence.push_back(\"app\");\n    sentence.push_back(\"apple\");\n    sentence.push_back(\"ap\");\n\n    // Test case 3\n    cout << \"Test Case 3: \";\n    vector<string> result3 = wordSuggest(sentence, numRows);\n    for (string str : result3) {\n        cout << str << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1271": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string toHexspeak(std::string s) {\n        std::string result = \"\";\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                result += \"0\";\n            } else if (!isalnum(c)) {\n                result += \"%\";\n                result += ((int)c + 32) % 58;\n            } else {\n                result += tolower((char)toupper(c));\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::cout << \"Test case 1: \" << solution.toHexspeak(\"3e\") << std::endl;\n    if (solution.toHexspeak(\"3e\") != \"3%e5\") {\n        std::cerr << \"Test case 1 failed\" << std::endl;\n    }\n\n    // Test case 2\n    std::cout << \"Test case 2: \" << solution.toHexspeak(\"1234ab\") << std::endl;\n    if (solution.toHexspeak(\"1234ab\") != \"%12%34%4b\") {\n        std::cerr << \"Test case 2 failed\" << std::endl;\n    }\n\n    // Test case 3\n    std::cout << \"Test case 3: \" << solution.toHexspeak(\"0a\") << std::endl;\n    if (solution.toHexspeak(\"0a\") != \"00%a5\") {\n        std::cerr << \"Test case 3 failed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1270": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> report(int n, vector<vector<int>>& personnel):\n\n        {\n            vector<string> res;\n            unordered_map<int, string> m;\n            for (int i = 0; i < n; i++) {\n                int manager_id = personnel[i][1];\n                if (m.find(manager_id) == m.end()) {\n                    m[manager_id] = to_string(i);\n                }\n            }\n\n            for (const auto& p : personnel) {\n                res.push_back(m[to_string(p[1])]);\n            }\n            return res;\n        }\n};\n\nint main() {\n\n    Solution solution;\n\n    int n = 7; // number of employees\n    vector<vector<int>> personnel {{1, 2}, {2, 3}, {4, 5}, {6, 7}, {6, 8}};\n    \n    // Test case 1: \n    cout << \"Test Case 1: \";\n    vector<string> result1 = solution.report(n, personnel);\n    for (const auto& str : result1) {\n        cout << str << \" \";\n    }\n    cout << endl;\n    \n    // Test case 2:\n    n = 4; // number of employees\n    personnel.clear();\n    personnel = {{1, 3}, {2, 3}};\n    \n    cout << \"Test Case 2: \";\n    vector<string> result2 = solution.report(n, personnel);\n    for (const auto& str : result2) {\n        cout << str << \" \";\n    }\n    cout << endl;\n    \n    // Test case 3:\n    n = 5; // number of employees\n    personnel.clear();\n    personnel = {{1, 1}, {2, 1}, {3, 2}, {4, 3}, {5, 3}};\n    \n    cout << \"Test Case 3: \";\n    vector<string> result3 = solution.report(n, personnel);\n    for (const auto& str : result3) {\n        cout << str << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1272": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> removeInterval(vector<vector<int>>& intervals, int left, int right) {\n        vector<vector<int>> res;\n        for (auto &interval : intervals) {\n            if ((interval[0] > right || interval[1] < left)) {\n                res.push_back(interval);\n            } else if (interval[0] <= left && left <= interval[1]) {\n                if (left <= right) {\n                    vector<int> temp = {left, min(right, interval[1])};\n                    res.push_back(temp);\n                }\n            } else if (interval[0] < left && interval[1] > right) {\n                continue;\n            } else {\n                if (interval[0] <= left) {\n                    res.push_back({interval[0], left});\n                }\n                if (left <= right && right <= interval[1]) {\n                    res.push_back({left, right});\n                }\n                if (right < interval[1]) {\n                    res.push_back({right, interval[1]});\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<vector<int>> intervals = {{0,2},{3,5},{6,7},{8,10},{11,15}};\n    int left = 1;\n    int right = 3;\n    vector<vector<int>> expected = {{0,1},{6,7},{8,10},{11,15}};\n    for (auto &interval : solution.removeInterval(intervals, left, right)) {\n        cout << \"[\";\n        for (int i = 0; i < interval.size(); i++) {\n            if (i == 0) {\n                cout << interval[i];\n            } else {\n                cout << \",\" << interval[i];\n            }\n        }\n        cout << \"],\";\n    }\n    cout << endl;\n    \n    intervals = {{0,10},{5,15}};\n    left = 3;\n    right = 4;\n    expected = {{0,2},{5,5}};\n    for (auto &interval : solution.removeInterval(intervals, left, right)) {\n        cout << \"[\";\n        for (int i = 0; i < interval.size(); i++) {\n            if (i == 0) {\n                cout << interval[i];\n            } else {\n                cout << \",\" << interval[i];\n            }\n        }\n        cout << \"],\";\n    }\n    cout << endl;\n    \n    intervals = {{1,2}};\n    left = 1;\n    right = 3;\n    expected = {};\n    for (auto &interval : solution.removeInterval(intervals, left, right)) {\n        cout << \"[\";\n        for (int i = 0; i < interval.size(); i++) {\n            if (i == 0) {\n                cout << interval[i];\n            } else {\n                cout << \",\" << interval[i];\n            }\n        }\n        cout << \"],\";\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1273": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> pruneTree(vector<vector<int>>& roots) {\n        if (roots.empty()) return {};\n        vector<int> result;\n        for (int i = 0; i < roots.size(); i++) {\n            for (int j = 0; j < roots[i].size(); j++) {\n                if (j == 0 && roots[i][j] == 0) break;\n                if (j > 0 && roots[i][j] == 0) continue;\n                if (j == 0) result.push_back(roots[i][j]);\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> roots1 = {{1,0,1},{0,0,0},{1,0,1}};\n    vector<int> expected1 = {1};\n    if (solution.pruneTree(roots1) != expected1)\n        return 1;\n\n    // Test case 2\n    vector<vector<int>> roots2 = {{1,0,1,0}};\n    vector<int> expected2 = {1};\n    if (solution.pruneTree(roots2) != expected2)\n        return 1;\n\n    // Test case 3\n    vector<vector<int>> roots3 = {{0,1,0},{0,0,0}};\n    vector<int> expected3 = {};\n    if (solution.pruneTree(roots3) != expected3)\n        return 1;\n\n    cout << \"All test cases pass.\" << endl;\n    return 0;\n}\n```",
  "1274": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countGoodTriplets(vector<int>& arr, int r, int c) {\n        int n = arr.size();\n        vector<vector<int>> goodTriplets;\n        \n        for (int i = 0; i < n - 2; i++) {\n            for (int j = i + 1; j < n - 1; j++) {\n                if ((arr[i] % r == 0 && arr[j] % r == 0) || (arr[i] % c == 0 && arr[j] % c == 0)) continue;\n                int k = j + 1;\n                while (k < n && (arr[k] % r != 0 || arr[k] % c != 0)) k++;\n                if (k - j > 2) goodTriplets.push_back({i, j, k - 1});\n            }\n        }\n        \n        return goodTriplets.size();\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> arr1 = {3, 5, 8};\n    int r1 = 2;\n    int c1 = 4;\n    cout << \"Test case 1: \" << solution.countGoodTriplets(arr1, r1, c1) << endl;\n\n    // Test case 2\n    vector<int> arr2 = {10, 5, 3};\n    int r2 = 6;\n    int c2 = 7;\n    cout << \"Test case 2: \" << solution.countGoodTriplets(arr2, r2, c2) << endl;\n\n    // Test case 3\n    vector<int> arr3 = {1, 1, 1};\n    int r3 = 2;\n    int c3 = 2;\n    cout << \"Test case 3: \" << solution.countGoodTriplets(arr3, r3, c3) << endl;\n\n    return 0;\n}\n```",
  "1275": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findWinner(vector<vector<int>>& moves) {\n        int player1 = 0;\n        int player2 = 0;\n        \n        for (int i = 0; i < moves.size(); i++) {\n            if (moves[i][0] == 1) player1++;\n            else player2++;\n        }\n        \n        return (player1 > player2) ? 1 : 2;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> test1 = {{1, 2}, {2, 1}};\n    cout << \"Test case 1: \" << solution.findWinner(test1) << endl;\n\n    // Test case 2\n    vector<vector<int>> test2 = {{1, 2}, {1, 2}};\n    cout << \"Test case 2: \" << solution.findWinner(test2) << endl;\n\n    // Test case 3\n    vector<vector<int>> test3 = {{1, 2}, {2, 1}, {1, 2}};\n    cout << \"Test case 3: \" << solution.findWinner(test3) << endl;\n    \n    return 0;\n}\n```",
  "1276": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numBurger(int n, int k) {\n        return (k + k - 1) / (2 * k) * min(n, k);\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test case 1: \" << solution.numBurger(4, 2) << endl; // expected output: 2\n    cout << \"Test case 2: \" << solution.numBurger(9, 3) << endl; // expected output: 6\n    cout << \"Test case 3: \" << solution.numBurger(12, 5) << endl; // expected output: 10\n    return 0;\n}\n```",
  "1277": "```\n#include <iostream>\n#include <vector>\n\nint countGoodSquare(std::vector<std::vector<int>>& mat) {\n    int n = mat.size();\n    int ans = 0;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= n - i; j++) {\n            int x = i, y = j;\n            while (x < n && y < n && mat[x][y] == 1) {\n                x++;\n                y++;\n            }\n            \n            if (i + y >= j + x) ans += (x - y + 1) * (x - y + 1);\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    std::vector<std::vector<int>> mat1 = {{0,1},{1,1}};\n    std::cout << countGoodSquare(mat1) << std::endl;\n\n    std::vector<std::vector<int>> mat2 = {{0, 1, 0, 0}, {1, 1, 1, 1}, {0, 0, 0, 0}};\n    std::cout << countGoodSquare(mat2) << std::endl;\n\n    std::vector<std::vector<int>> mat3 = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n    std::cout << countGoodSquare(mat3) << std::endl;\n\n    return 0;\n}\n```",
  "1278": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int palindromePartition(string s) {\n        int n = s.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (s[i] == s[j]) {\n                    if (j - i <= 1) {\n                        dp[i][j] = 0;\n                    } else {\n                        int k = 0, left = i, right = j;\n                        while (left < right && s[left] == s[right]) {\n                            left++;\n                            right--;\n                        }\n                        dp[i][j] = (k + 1);\n                    }\n                } else {\n                    dp[i][j] = INT_MAX - 1;\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (dp[0][i] == INT_MAX - 1) return -1;\n            ans += dp[0][i];\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1:\n    string s1 = \"aba\";\n    cout << solution.palindromePartition(s1) << endl;  // Output: 1\n\n    // Test Case 2:\n    string s2 = \"aabbaa\";\n    cout << solution.palindromePartition(s2) << endl;  // Output: 3\n\n    // Test Case 3:\n    string s3 = \"abc\";\n    cout << solution.palindromePartition(s3) << endl;   // Output: -1\n\n    return 0;\n}\n```",
  "1279": "```\n#include <iostream>\n#include <thread>\n#include <vector>\n\nclass TrafficLight {\npublic:\n    void start() {\n        for (int i = 0; i < 6; ++i) {\n            std::this_thread::sleep_for(std::chrono::seconds(2));\n            if (i == 3) {\n                for (auto & light : lights) {\n                    light = false;\n                }\n                std::this_thread::sleep_for(std::chrono::seconds(4));\n            }\n        }\n    }\n\nprivate:\n    bool lights[6] = {true, true, true, true, false, false};\n};\n\nvoid test1() {\n    TrafficLight trafficLight;\n    trafficLight.start();\n}\n\nvoid test2() {\n    TrafficLight trafficLight;\n    std::thread t(&TrafficLight::start, &trafficLight);\n    t.join();\n}\n\nvoid test3() {\n    TrafficLight trafficLight;\n    for (int i = 0; i < 6; ++i) {\n        if (i == 3) {\n            for (auto & light : trafficLight.lights) {\n                light = false;\n            }\n            std::this_thread::sleep_for(std::chrono::seconds(4));\n        }\n        std::this_thread::sleep_for(std::chrono::seconds(2));\n    }\n}\n\nint main() {\n    test1();\n    test2();\n    test3();\n    return 0;\n}",
  "1280": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numStudents(string s) {\n        int res = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '0') {\n                res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.numStudents(\"100000010111011\") << endl;\n    // expected output: 3\n    cout << \"Test case 2: \" << solution.numStudents(\"10100110101001111\") << endl;\n    // expected output: 5\n    cout << \"Test case 3: \" << solution.numStudents(\"0\") << endl;\n    // expected output: 1\n\n    return 0;\n}\n```",
  "1281": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int product = 1;\n        int sum = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            product *= digit;\n            sum += digit;\n            n /= 10;\n        }\n        return product - sum;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.subtractProductAndSum(123) << endl; // expected output: 6\n    cout << \"Test case 2: \" << solution.subtractProductAndSum(36) << endl; // expected output: 0\n    cout << \"Test case 3: \" << solution.subtractProductAndSum(999) << endl; // expected output: -12\n\n    return 0;\n}\n```",
  "1282": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nvoid groupThePeople(std::vector<int>& groupSizes) {\n    std::unordered_map<int, std::vector<int>> groups;\n    for (int i = 0; i < groupSizes.size(); ++i) {\n        int size = groupSizes[i];\n        if (!groups.count(size)) {\n            groups[size] = {};\n        }\n        groups[size].push_back(i);\n    }\n\n    for (const auto& pair : groups) {\n        int size = pair.first;\n        std::vector<int> people = pair.second;\n        for (int i = 0; i < people.size(); i += size) {\n            if (i + size > people.size()) {\n                break;\n            }\n            std::cout << \"[\";\n            for (int j = 0; j < size; ++j) {\n                std::cout << people[i + j];\n                if (j != size - 1) {\n                    std::cout << \", \";\n                } else {\n                    std::cout << \"]\\n\";\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int testCases = 3;\n    for (int i = 0; i < testCases; ++i) {\n        if (i == 0) {\n            // Test case 1\n            std::vector<int> groupSizes = {2, 1, 3, 3, 2};\n            std::cout << \"Test case \" << i + 1 << \": \";\n            groupThePeople(groupSizes);\n        } else if (i == 1) {\n            // Test case 2\n            std::vector<int> groupSizes = {5, 1, 4, 3, 2};\n            std::cout << \"Test case \" << i + 1 << \": \";\n            groupThePeople(groupSizes);\n        } else {\n            // Test case 3\n            std::vector<int> groupSizes = {3, 2, 1, 3, 2, 2};\n            std::cout << \"Test case \" << i + 1 << \": \";\n            groupThePeople(groupSizes);\n        }\n    }\n    return 0;\n}\n```",
  "1283": "```\n#include <iostream>\n#include <vector>\n\nint smallestDivisor(std::vector<int>& nums, int threshold) {\n    if (nums.empty()) return -1;\n\n    int left = 1;\n    int right = *std::max_element(nums.begin(), nums.end());\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        long long sum = 0;\n        for (int num : nums) {\n            sum += (long long)num / mid;\n        }\n        if (sum * mid > threshold) {\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n\n    return left - 1;\n}\n\nint main() {\n    std::vector<int> nums1 = {6,5,4,3};\n    int threshold1 = 9;\n    std::cout << \"Test case 1: \" << smallestDivisor(nums1, threshold1) << std::endl;\n\n    std::vector<int> nums2 = {10};\n    int threshold2 = 5;\n    std::cout << \"Test case 2: \" << smallestDivisor(nums2, threshold2) << std::endl;\n\n    std::vector<int> nums3 = {4,8};\n    int threshold3 = 14;\n    std::cout << \"Test case 3: \" << smallestDivisor(nums3, threshold3) << std::endl;\n\n    return 0;\n}\n```",
  "1284": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minFlips(vector<vector<int>>& mat) {\n        int m = mat.size();\n        int n = mat[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n));\n        int flips = 0;\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (mat[i][j] == 1 && !visited[i][j]) {\n                    queue<pair<int, int>> q;\n                    q.push({i, j});\n                    visited[i][j] = true;\n                    \n                    while (!q.empty()) {\n                        pair<int, int> cur = q.front();\n                        q.pop();\n                        \n                        for (int x = -1; x <= 1; ++x) {\n                            for (int y = -1; y <= 1; ++y) {\n                                int nx = cur.first + x;\n                                int ny = cur.second + y;\n                                \n                                if (nx >= 0 && nx < m && ny >= 0 && ny < n \n                                    && !visited[nx][ny] && mat[nx][ny] == 1) {\n                                    q.push({nx, ny});\n                                    visited[nx][ny] = true;\n                                } else if (nx >= 0 && nx < m && ny >= 0 && ny < n \n                                               && !visited[nx][ny] && mat[nx][ny] == 0) {\n                                    ++flips;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return flips;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> mat1 = {{0, 0}, {1, 1}};\n    cout << \"Test case 1: \" << solution.minFlips(mat1) << endl;\n\n    vector<vector<int>> mat2 = {{0, 0, 0}, {1, 1, 1}, {1, 0, 0}};\n    cout << \"Test case 2: \" << solution.minFlips(mat2) << endl;\n\n    vector<vector<int>> mat3 = {{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 0, 0, 1}, {1, 1, 1, 1}};\n    cout << \"Test case 3: \" << solution.minFlips(mat3) << endl;\n\n    return 0;\n}",
  "1285": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> findErrorNums(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> res;\n        \n        for(int i = 0; i < n; i++){\n            while(nums[abs(nums[i]) - 1] != abs(nums[i])){\n                nums[abs(nums[i]) - 1] += (i+1);\n            }\n        }\n        \n        for(int i = 0; i < n; i++){\n            if(nums[i] > n || nums[i] <= 0){\n                continue;\n            }\n            if(nums[i] != i + 1){\n                res.push_back({i+1, nums[i]});\n                break;\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> nums1 = {1,2,3};\n    cout << \"Test case 1: \";\n    for (const auto &pair : solution.findErrorNums(nums1)) {\n        cout << \"(\" << pair[0] << \",\" << pair[1] << \") \";\n    }\n    cout << endl;\n\n    vector<int> nums2 = {1,3,4,2];\n    cout << \"Test case 2: \";\n    for (const auto &pair : solution.findErrorNums(nums2)) {\n        cout << \"(\" << pair[0] << \",\" << pair[1] << \") \";\n    }\n    cout << endl;\n\n    vector<int> nums3 = {1,2};\n    cout << \"Test case 3: \";\n    for (const auto &pair : solution.findErrorNums(nums3)) {\n        cout << \"(\" << pair[0] << \",\" << pair[1] << \") \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1287": "```\n#include <iostream>\n#include <vector>\n\nint findSpecialInteger(std::vector<int>& arr) {\n    for (int i = 0; i + 1 < arr.size(); i++) {\n        if (arr[i] != arr[i + 1]) {\n            return arr[i];\n        }\n    }\n    return arr[0];\n}\n\nint main() {\n    std::vector<int> arr1 = {1, 2, 2, 4, 5};\n    std::cout << \"Test case 1: \" << findSpecialInteger(arr1) << std::endl;\n\n    std::vector<int> arr2 = {1, 3, 3, 3, 7, 8, 9, 10};\n    std::cout << \"Test case 2: \" << findSpecialInteger(arr2) << std::endl;\n\n    std::vector<int> arr3 = {1, 1, 2, 3, 3};\n    std::cout << \"Test case 3: \" << findSpecialInteger(arr3) << std::endl;\n}\n```",
  "1286": "```\n#include <iostream>\n#include <vector>\n\nclass CombinationIterator {\npublic:\n    CombinationIterator(std::string str, int start) : str(str), start(start) {}\n\n    ~CombinationIterator() {}\n\n    std::string next() {\n        if (start > str.size()) {\n            return \"\";\n        }\n        std::string res = str.substr(start);\n        start += 1;\n        for (; start < str.size(); ++start) {\n            if (res.find(str[start]) == -1) {\n                res += str[start];\n                break;\n            }\n        }\n        return res;\n    }\n\n    bool hasNext() {\n        return start <= str.size();\n    }\n\nprivate:\n    std::string str;\n    int start;\n};\n\nint main() {\n    CombinationIterator* it = new CombinationIterator(\"abc\", 0);\n    \n    // Test case 1\n    while (it->hasNext()) {\n        std::cout << it->next() << \" \";\n    }\n    delete it;\n\n    it = new CombinationIterator(\"abc\", 2);\n    \n    // Test case 2\n    while (it->hasNext()) {\n        std::cout << it->next() << \" \";\n    }\n    delete it;\n\n    it = new CombinationIterator(\"abcd\", 1);\n    \n    // Test case 3\n    while (it->hasNext()) {\n        std::cout << it->next() << \" \";\n    }\n    delete it;\n    return 0;\n}\n```",
  "1288": "```\n#include <iostream>\n#include <vector>\n\nint removeCoveredIntervals(std::vector<std::vector<int>>& intervals) {\n    if (intervals.empty()) return 0;\n\n    std::sort(intervals.begin(), intervals.end(), \n            [](const auto& a, const auto& b) { return a[0] < b[0]; });\n\n    int res = 0;\n    for (size_t i = 1; i < intervals.size(); ++i) {\n        if (intervals[i][0] <= intervals[i - 1][1]) {\n            --res;\n        } else {\n            --res;\n            --i;\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<std::vector<int>> intervals1 = {{1,4},{3,5},{6,7}};\n    int result1 = removeCoveredIntervals(intervals1);\n    if (result1 != 2) {\n        std::cout << \"Test case 1 failed\" << std::endl;\n        return 1;\n    }\n\n    std::vector<std::vector<int>> intervals2 = {{0,10},{5,12},{13,15},{3,8}};\n    int result2 = removeCoveredIntervals(intervals2);\n    if (result2 != 2) {\n        std::cout << \"Test case 2 failed\" << std::endl;\n        return 1;\n    }\n\n    std::vector<std::vector<int>> intervals3 = {{1,2},{1,3}};\n    int result3 = removeCoveredIntervals(intervals3);\n    if (result3 != 1) {\n        std::cout << \"Test case 3 failed\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed\" << std::endl;\n\n    return 0;\n}\n```",
  "1289": "```\n#include <iostream>\n#include <vector>\n\nint minFallingPathSum(std::vector<std::vector<int>>& matrix) {\n    int n = matrix.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n\n    for (int i = 0; i < n; i++) {\n        dp[0][i] = matrix[0][i];\n    }\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (j == 0) {\n                dp[i][j] = matrix[i][j] + std::min({dp[i-1][j], dp[i-1][j+1]});\n            } else if (j == n - 1) {\n                dp[i][j] = matrix[i][j] + std::min({dp[i-1][j-1], dp[i-1][j]});\n            } else {\n                dp[i][j] = matrix[i][j] + std::min({dp[i-1][j-1], dp[i-1][j], dp[i-1][j+1]});\n            }\n        }\n    }\n\n    int minSum = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        if (dp[n-1][i] < minSum) {\n            minSum = dp[n-1][i];\n        }\n    }\n\n    return minSum;\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix1 = {{2,1,3},{6,5,4},{7,8,9}};\n    std::cout << \"Test case 1: \" << minFallingPathSum(matrix1) << std::endl;\n\n    std::vector<std::vector<int>> matrix2 = {{-19,78,24},{15,66,-64},{50,-40,31}};\n    std::cout << \"Test case 2: \" << minFallingPathSum(matrix2) << std::endl;\n\n    std::vector<std::vector<int>> matrix3 = {{1,2},{4,5}};\n    std::cout << \"Test case 3: \" << minFallingPathSum(matrix3) << std::endl;\n\n    return 0;\n}\n```",
  "1290": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n        int decimal = 0;\n        while (head != NULL) {\n            decimal = (decimal << 1) | head->val;\n            head = head->next;\n        }\n        return decimal;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    ListNode* list1 = new ListNode(1);\n    list1->next = new ListNode(0);\n    cout << \"Test case 1: \" << solution.getDecimalValue(list1) << endl; // Output: 5\n\n    // Test case 2\n    ListNode* list2 = new ListNode(0);\n    list2->next = new ListNode(1);\n    cout << \"Test case 2: \" << solution.getDecimalValue(list2) << endl; // Output: 1\n\n    // Test case 3\n    ListNode* list3 = new ListNode(1);\n    list3->next = new ListNode(1);\n    list3->next->next = new ListNode(0);\n    cout << \"Test case 3: \" << solution.getDecimalValue(list3) << endl; // Output: 6\n\n    return 0;\n}\n```",
  "1291": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> sequentialDigits(int low, int high) {\n        std::vector<int> result;\n        for (int i = 1; ; i++) {\n            long curNum = 0;\n            bool firstDigitFound = false;\n            for (int j = i; ; j++) {\n                if (curNum >= high) break;\n                if (!firstDigitFound) {\n                    if (j < 10 && curNum * 10 + j <= low) continue;\n                    firstDigitFound = true;\n                }\n                curNum = curNum * 10 + j;\n                result.push_back(curNum);\n                if (curNum >= high) break;\n            }\n        }\n        return std::vector<int>(result.begin() + (low - 1), result.end());\n    }\n};\n\nint main() {\n    Solution solution;\n    int low1 = 100, high1 = 300;\n    int low2 = 500, high2 = 700;\n    int low3 = 1700, high3 = 2100;\n\n    std::vector<int> result1 = solution.sequentialDigits(low1, high1);\n    for (int num : result1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> result2 = solution.sequentialDigits(low2, high2);\n    for (int num : result2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> result3 = solution.sequentialDigits(low3, high3);\n    for (int num : result3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1292": "```\n#include <iostream>\n#include <vector>\n\nint maxSideLength(std::vector<std::vector<int>>& mat, int threshold) {\n    int m = mat.size();\n    int n = mat[0].size();\n    std::vector<std::vector<int>> prefixSum(m + 1, std::vector<int>(n + 1, 0));\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            prefixSum[i][j] = mat[i - 1][j - 1] + prefixSum[i - 1][j] + prefixSum[i][j - 1] - prefixSum[i - 1][j - 1];\n        }\n    }\n\n    int res = 0;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            int rightBottom = prefixSum[i][j];\n            for (int k = min(i, j); k >= 1; k--) {\n                int leftTop = rightBottom - prefixSum[i - k][j] - prefixSum[i][j - k] + prefixSum[i - k][j - k];\n                if (leftTop <= threshold) {\n                    res = max(res, k);\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<std::vector<int>> mat1 = {{1, 0, 1}, {0, 5, 0}, {1, 0, 1}};\n    int threshold1 = 6;\n    std::cout << \"Test case 1: \" << maxSideLength(mat1, threshold1) << std::endl;\n\n    std::vector<std::vector<int>> mat2 = {{2, 1, 1}, {1, 3, 1}, {0, 1, 4}};\n    int threshold2 = 8;\n    std::cout << \"Test case 2: \" << maxSideLength(mat2, threshold2) << std::endl;\n\n    std::vector<std::vector<int>> mat3 = {{23, 21, 12}, {15, 14, 20}, {22, 10, 9}};\n    int threshold3 = 39;\n    std::cout << \"Test case 3: \" << maxSideLength(mat3, threshold3) << std::endl;\n\n    return 0;\n}\n```",
  "1293": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nstruct Point {\n    int x;\n    int y;\n};\n\nclass Solution {\npublic:\n    int shortestPath(vector<vector<int>>& grid, int k) {\n        int m = grid.size();\n        int n = grid[0].size();\n        queue<Point> q;\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        int dx[] = {-1, 0, 1, 0};\n        int dy[] = {0, -1, 0, 1};\n        Point p;\n        p.x = 0; p.y = 0;\n        q.push(p);\n        visited[0][0] = true;\n        int res = 0;\n        while (!q.empty()) {\n            int sz = q.size();\n            for (int i = 0; i < sz; i++) {\n                p = q.front(); q.pop();\n                if (p.x == m - 1 && p.y == n - 1) return res + 1;\n                for (int j = 0; j < 4; j++) {\n                    int newX = p.x + dx[j];\n                    int newY = p.y + dy[j];\n                    if (newX >= 0 && newX < m && newY >= 0 && newY < n \n                        && grid[newX][newY] == 1\n                        && visited[newX][newY] == false) {\n                        visited[newX][newY] = true;\n                        p.x = newX; p.y = newY;\n                        q.push(p);\n                    }\n                }\n            }\n            res++;\n        }\n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> grid1 = {{0,0,0},{1,1,0},{0,0,0}};\n    int k1 = 3;\n    cout << \"Test case 1: \" << solution.shortestPath(grid1, k1) << endl;\n\n    // Test case 2\n    vector<vector<int>> grid2 = {{0,1},{0,0}};\n    int k2 = 2;\n    cout << \"Test case 2: \" << solution.shortestPath(grid2, k2) << endl;\n\n    // Test case 3\n    vector<vector<int>> grid3 = {{0,0,0,0},{1,1,1,0},{0,0,0,0},{0,0,1,0}};\n    int k3 = 4;\n    cout << \"Test case 3: \" << solution.shortestPath(grid3, k3) << endl;\n\n    return 0;\n}\n```",
  "1294": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> weatherTypeInEachCountry(vector<vector<string>>& weather) {\n        unordered_map<string, string> countryWeather;\n        for (const auto& w : weather) {\n            countryWeather[w[1]] = w[0];\n        }\n        return vector<string>(countryWeather.begin(), countryWeather.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> weather1 = {{\"Sunny\", \"USA\"}, {\"Rainy\", \"Canada\"}};\n    vector<string> result1 = solution.weatherTypeInEachCountry(weather1);\n    for (const auto& w : result1) {\n        cout << w << endl;\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<vector<string>> weather2 = {{\"Cloudy\", \"USA\"}, {\"Sunny\", \"Mexico\"}};\n    vector<string> result2 = solution.weatherTypeInEachCountry(weather2);\n    for (const auto& w : result2) {\n        cout << w << endl;\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<vector<string>> weather3 = {{\"Windy\", \"USA\"}, {\"Snowy\", \"Canada\"}, {\"Foggy\", \"Mexico\"}};\n    vector<string> result3 = solution.weatherTypeInEachCountry(weather3);\n    for (const auto& w : result3) {\n        cout << w << endl;\n    }\n    return 0;\n}\n```",
  "1295": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> findEvenNumbers(const std::vector<int>& numbers) {\n    std::vector<int> result;\n    for (int num : numbers) {\n        if ((num >= 10 && (num % 100).digits() % 2 == 0) || (num < 10)) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n\nint main() {\n    int test1[] = {12, 13, 14};\n    std::vector<int> nums1(test1, test1 + sizeof(test1)/sizeof(test1[0]));\n    auto res1 = findEvenNumbers(nums1);\n    for (auto num : res1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    int test2[] = {555};\n    std::vector<int> nums2(test2, test2 + sizeof(test2)/sizeof(test2[0]));\n    auto res2 = findEvenNumbers(nums2);\n    for (auto num : res2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    int test3[] = {10200};\n    std::vector<int> nums3(test3, test3 + sizeof(test3)/sizeof(test3[0]));\n    auto res3 = findEvenNumbers(nums3);\n    for (auto num : res3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1296": "```\n#include <iostream>\n#include <vector>\n\nint maxEqualFreq(std::vector<int>& nums, int k) {\n    std::vector<int> count(100001, 0);\n    for (int i = 0; i < nums.size(); i++) {\n        count[nums[i]]++;\n    }\n    \n    int res = 1;\n    for (int i = 0; i <= 100000; i++) {\n        if (count[i] > 0) {\n            if (res == 1 || count[i - k + 1] < count[i]) {\n                res++;\n            }\n        } else {\n            return res;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {3, 2, 3, 2, 4};\n    int k1 = 4;\n    std::cout << maxEqualFreq(nums1, k1) << std::endl;\n\n    std::vector<int> nums2 = {5, 17, 100, 101};\n    int k2 = 7;\n    std::cout << maxEqualFreq(nums2, k2) << std::endl;\n\n    std::vector<int> nums3 = {1, 4, 10, 14, 40};\n    int k3 = 3;\n    std::cout << maxEqualFreq(nums3, k3) << std::endl;\n\n    return 0;\n}\n```",
  "1297": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint maxFrequency(std::string s, std::vector<std::string>& words) {\n    int res = 0;\n    for (const auto& word : words) {\n        size_t pos = 0;\n        while ((pos = s.find(word)) != std::string::npos) {\n            s.erase(pos, word.length());\n            res++;\n        }\n    }\n    return res;\n}\n\nint main() {\n    {\n        std::string s = \"bb\";\n        std::vector<std::string> words = {\"a\", \"b\", \"c\"};\n        int expected = 2;\n        int result = maxFrequency(s, words);\n        if (result == expected) {\n            std::cout << \"Test case 1 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 1 failed. Expected: \" << expected << \", Got: \" << result << std::endl;\n        }\n    }\n\n    {\n        std::string s = \"abacbb\";\n        std::vector<std::string> words = {\"a\", \"b\", \"c\"};\n        int expected = 2;\n        int result = maxFrequency(s, words);\n        if (result == expected) {\n            std::cout << \"Test case 2 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 2 failed. Expected: \" << expected << \", Got: \" << result << std::endl;\n        }\n    }\n\n    {\n        std::string s = \"abacbb\";\n        std::vector<std::string> words = {\"a\", \"b\"};\n        int expected = 3;\n        int result = maxFrequency(s, words);\n        if (result == expected) {\n            std::cout << \"Test case 3 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 3 failed. Expected: \" << expected << \", Got: \" << result << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "1298": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumCandies(vector<vector<int>>& boxes) {\n        vector<pair<int, int>> boxSizes;\n        for (int i = 0; i < boxes.size(); i++) {\n            for (int j = 0; j < boxes[i].size(); j++) {\n                boxSizes.push_back({boxes[i][j], i});\n            }\n        }\n        sort(boxSizes.begin(), boxSizes.end());\n        \n        int maxCandies = 0;\n        queue<int> q;\n        for (int i = boxSizes.size() - 1; i >= 0; i--) {\n            if (boxSizes[i].first > 0) {\n                q.push(boxSizes[i].second);\n                boxSizes[i].first--;\n            } else if (!q.empty()) {\n                int boxIndex = q.front();\n                q.pop();\n                maxCandies += boxes[boxIndex][0];\n                boxes[boxIndex][1] -= boxes[boxIndex][0];\n            }\n        }\n        \n        return maxCandies;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> box1 = {{2, 3}, {4, 5}};\n    cout << \"Test case 1: \" << solution.maximumCandies(box1) << endl;  // Output: 14\n\n    // Test case 2\n    vector<vector<int>> box2 = {{1, 1}, {2, 2}, {3, 3}};\n    cout << \"Test case 2: \" << solution.maximumCandies(box2) << endl;  // Output: 12\n\n    // Test case 3\n    vector<vector<int>> box3 = {{5, 0}, {4, 1}, {3, 2}, {2, 3}};\n    cout << \"Test case 3: \" << solution.maximumCandies(box3) << endl;  // Output: 14\n\n    return 0;\n}\n```",
  "1299": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> replaceElements(std::vector<int>& arr) {\n    int n = arr.size();\n    std::vector<int> res(arr.size());\n    \n    int maxR = arr[n - 1];\n    for (int i = n - 2; i >= 0; --i) {\n        res[i] = maxR;\n        if (arr[i] > maxR) {\n            maxR = arr[i];\n        }\n    }\n    \n    maxR = arr[0];\n    for (int i = 1; i < n; ++i) {\n        res[i] = (res[i - 1] > arr[i]) ? res[i - 1] : arr[i];\n        if (arr[i] > maxR) {\n            maxR = arr[i];\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> v1 = {17,18,5,4,3,6};\n    std::vector<int> result1 = replaceElements(v1);\n    for (int i : result1) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> v2 = {0,0};\n    std::vector<int> result2 = replaceElements(v2);\n    for (int i : result2) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> v3 = {1,2,3};\n    std::vector<int> result3 = replaceElements(v3);\n    for (int i : result3) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```",
  "1300": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findBestIndex(vector<int>& nums, int target) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        \n        if (target > nums.back()) return -1;\n        \n        if (target < nums.front()) return 0;\n        \n        auto left = lower_bound(nums.begin(), nums.end(), target);\n        if (*left == target) return distance(nums.begin(), left);\n        \n        int a = *prev(left, 1) + *left;\n        int b = *left + *(next(left));\n        \n        return abs(target - a) <= abs(target - b) ? distance(nums.begin(), left) : 1 + distance(next(left), nums.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> test1 = {2,5,6,8};\n    int target1 = 7;\n    cout << \"Test case 1: \" << solution.findBestIndex(test1, target1) << endl;\n\n    // Test case 2\n    vector<int> test2 = {0,1,1,4};\n    int target2 = 5;\n    cout << \"Test case 2: \" << solution.findBestIndex(test2, target2) << endl;\n\n    // Test case 3\n    vector<int> test3 = {1,2,3,8,9};\n    int target3 = 4.5;\n    cout << \"Test case 3: \" << solution.findBestIndex(test3, target3) << endl;\n\n    return 0;\n}\n```",
  "1301": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxScoreSensors(vector<int>& sensors) {\n        int n = sensors.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == 0) {\n                    dp[i][j] = accumulate(sensors.begin() + i, sensors.begin() + j + 1, 0);\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], sensors[j] + (dp[i - 1][j - 1] > 0 ? dp[i - 1][j - 1] : 0));\n                }\n            }\n        }\n        \n        return dp[n - 1][n - 1];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<int> sensors1 = {3,2};\n    cout << \"Test Case 1: Expected Output - 2, Actual Output - \" << solution.maxScoreSensors(sensors1) << endl;\n    \n    vector<int> sensors2 = {5,4,6,7};\n    cout << \"Test Case 2: Expected Output - 6, Actual Output - \" << solution.maxScoreSensors(sensors2) << endl;\n    \n    vector<int> sensors3 = {8,9,10,1,3,2,4,5};\n    cout << \"Test Case 3: Expected Output - 7, Actual Output - \" << solution.maxScoreSensors(sensors3) << endl;\n    \n    return 0;\n}\n```",
  "1302": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    int deepestLeavesSum(TreeNode* root) {\n        if (!root) return 0;\n\n        vector<TreeNode*> queue({root});\n        int sum = root->val;\n        while (queue.size()) {\n            int size = queue.size();\n            sum = 0;\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = queue[i];\n                if (!node->left && !node->right) return sum;\n                if (node->left) queue.push_back(node->left);\n                if (node->right) queue.push_back(node->right);\n                sum += node->val;\n            }\n            queue.erase(queue.begin(), queue.end());\n        }\n        return sum;\n    }\n};\n\nint main() {\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(5);\n    root1->right = new TreeNode(1);\n    root1->left->left = new TreeNode(6);\n    root1->left->right = new TreeNode(2);\n\n    cout << \"Test case 1: \" << Solution().deepestLeavesSum(root1) << endl; // Output: 7\n\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(3);\n    root2->left->left = new TreeNode(4);\n    root2->left->right = new TreeNode(5);\n\n    cout << \"Test case 2: \" << Solution().deepestLeavesSum(root2) << endl; // Output: 6\n\n    TreeNode* root3 = new TreeNode(1);\n\n    cout << \"Test case 3: \" << Solution().deepestLeavesSum(root3) << endl; // Output: 1\n\n    return 0;\n}\n```",
  "1303": "```\n#include <iostream>\n#include <vector>\n\nint numTeams(std::vector<int>& salary) {\n    int n = salary.size();\n    int res = 0;\n    for (int i = 1; i <= n - 2; i++) {\n        int leftCount = 0, rightCount = 0;\n        for (int j = i - 1; j >= 1; j--) {\n            if (salary[j] <= salary[i]) {\n                leftCount++;\n            } else {\n                break;\n            }\n        }\n        for (int j = i + 1; j <= n - 1; j++) {\n            if (salary[j] <= salary[i]) {\n                rightCount++;\n            } else {\n                break;\n            }\n        }\n        res += leftCount + rightCount;\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {16,17,18};\n    std::cout << \"Test 1: \" << numTeams(test1) << std::endl;\n\n    std::vector<int> test2 = {1,2,3,4,5};\n    std::cout << \"Test 2: \" << numTeams(test2) << std::endl;\n\n    std::vector<int> test3 = {12,8,17,15,-3};\n    std::cout << \"Test 3: \" << numTeams(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1304": "```\n#include <iostream>\n#include <vector>\n\nint arrayPairSum(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int sum = 0;\n    for (int i = 0; i < nums.size(); i += 2) {\n        sum += nums[i];\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \";\n    std::vector<int> test1 = {1, 4, 3, 2};\n    std::cout << arrayPairSum(test1) << std::endl;\n\n    std::cout << \"Test Case 2: \";\n    std::vector<int> test2 = {5, -5, 10, 10, -10, 5};\n    std::cout << arrayPairSum(test2) << std::endl;\n\n    std::cout << \"Test Case 3: \";\n    std::vector<int> test3 = {-1, 0, -2, 2, -4, 4};\n    std::cout << arrayPairSum(test3) << std::endl;\n    return 0;\n}\n```",
  "1306": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int maxResult(std::vector<int>& nums) {\n        if (nums.size() == 0) return 0;\n        \n        std::vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        \n        for (int i = 1; i < nums.size(); ++i) {\n            int maxVal = -INT_MAX;\n            for (int j = 0; j <= i && j + nums[j] >= i; ++j) {\n                if (dp[j] > maxVal) {\n                    maxVal = dp[j];\n                }\n            }\n            dp[i] = nums[i] + maxVal;\n        }\n        \n        return *std::max_element(dp.begin(), dp.end());\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::vector<int> nums1 = {4, 2, -3};\n    std::cout << \"Test case 1: \" << solution.maxResult(nums1) << std::endl;\n    \n    std::vector<int> nums2 = {-1,-2,-3,1,1,-1,3,-1};\n    std::cout << \"Test case 2: \" << solution.maxResult(nums2) << std::endl;\n    \n    std::vector<int> nums3 = [0, -1, -2, -6, 0, 1, 5];\n    std::cout << \"Test case 3: \" << solution.maxResult(nums3) << std::endl;\n    \n    return 0;\n}\n```",
  "1305": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {\n        vector<int> result;\n        dfs(root1, root2, result);\n        return result;\n    }\n\nprivate:\n    void dfs(TreeNode* node1, TreeNode* node2, vector<int>& result) {\n        if (node1 == NULL && node2 == NULL) return;\n        if (node1 != NULL) {\n            dfs(node1->left, node2, result);\n            while (node1 != NULL) {\n                result.push_back(node1->val);\n                node1 = node1->right;\n            }\n            dfs(NULL, node2, result);\n        } else if (node2 != NULL) {\n            dfs(NULL, node2, result);\n            while (node2 != NULL) {\n                result.push_back(node2->val);\n                node2 = node2->right;\n            }\n            dfs(node1, NULL, result);\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(2);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(4);\n\n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(5);\n\n    vector<int> result1 = solution.getAllElements(root1, root2);\n    for (int num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    root1 = NULL;\n    root2 = new TreeNode(3);\n    root2->left = new TreeNode(1);\n    root2->right = new TreeNode(4);\n\n    vector<int> result2 = solution.getAllElements(root1, root2);\n    for (int num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    root1 = new TreeNode(1);\n    root1->left = new TreeNode(0);\n    root1->right = new TreeNode(3);\n\n    root2 = NULL;\n    vector<int> result3 = solution.getAllElements(root1, root2);\n    for (int num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1307": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findDiscussions(string equation) {\n        unordered_map<char, int> posMap;\n        vector<int> result;\n        \n        for (int i = 0; i < equation.length(); i++) {\n            if (isalpha(equation[i])) {\n                posMap[.equation[i]] = i;\n            }\n        }\n        \n        for (auto p : posMap) {\n            int left = 0, right = 0;\n            \n            for (int i = 0; i < equation.length(); i++) {\n                if (equation[i] == ' ') continue;\n                \n                if (!isalpha(equation[i])) {\n                    if (isdigit(equation[i])) right++;\n                    else left++;\n                }\n                else {\n                    if (equation[i] == p.first) {\n                        int start = posMap[p.first];\n                        int end = i;\n                        \n                        if (start > 0 && isdigit(equation[start - 1])) left++;\n                        if (end < equation.length() - 1 && isdigit(equation[end + 1])) right++;\n                    }\n                }\n            }\n            \n            result.push_back(left);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string equation1 = \"2+3*4\";\n    vector<int> expected1 = {9};\n    vector<int> result1 = solution.findDiscussions(equation1);\n    if (result1 == expected1) cout << \"Test case 1 passed.\" << endl;\n    else cout << \"Test case 1 failed.\" << endl;\n\n    // Test case 2\n    string equation2 = \"11*2+3\";\n    vector<int> expected2 = {14};\n    vector<int> result2 = solution.findDiscussions(equation2);\n    if (result2 == expected2) cout << \"Test case 2 passed.\" << endl;\n    else cout << \"Test case 2 failed.\" << endl;\n\n    // Test case 3\n    string equation3 = \"10+1*2\";\n    vector<int> expected3 = {13};\n    vector<int> result3 = solution.findDiscussions(equation3);\n    if (result3 == expected3) cout << \"Test case 3 passed.\" << endl;\n    else cout << \"Test case 3 failed.\" << endl;\n\n    return 0;\n}\n```",
  "1308": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> runningSum(vector<vector<int>>& nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = 0; j < nums[0].size(); j++) {\n                if (j > 0) {\n                    nums[i][j] += nums[i][j - 1];\n                }\n            }\n        }\n        return nums;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> test1 = {{1,3},{5,9}};\n    vector<vector<int>> result1 = solution.runningSum(test1);\n    for (auto row : result1) {\n        for (int col : row) {\n            cout << col << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> test2 = {{4,9,10},{3,5,7}};\n    vector<vector<int>> result2 = solution.runningSum(test2);\n    for (auto row : result2) {\n        for (int col : row) {\n            cout << col << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> test3 = {{1,2},{3,4}};\n    vector<vector<int>> result3 = solution.runningSum(test3);\n    for (auto row : result3) {\n        for (int col : row) {\n            cout << col << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1309": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string frequencySort(string s) {\n        unordered_map<char, int> freq;\n        for (char c : s) {\n            freq[c]++;\n        }\n        priority_queue<pair<int, char>> pq;\n        for (auto p : freq) {\n            pq.push({p.second, p.first});\n        }\n        string result = \"\";\n        while (!pq.empty()) {\n            int n = pq.top().first;\n            char c = pq.top().second;\n            while (n--) {\n                result += c;\n            }\n            pq.pop();\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \";\n    string s1 = \"aabba\";\n    cout << solution.frequencySort(s1) << endl; // Output: aabba\n\n    cout << \"Test case 2: \";\n    string s2 = \"leetcode\";\n    cout << solution.frequencySort(s2) << endl; // Output: llllooeettt\n\n    cout << \"Test case 3: \";\n    string s3 = \"okleleiteodn\";\n    cout << solution.frequencySort(s3) << endl; // Output: okleleetdn\n\n    return 0;\n}\n```",
  "1310": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> getSubarrayXOR(const std::vector<int>& nums) {\n        int n = nums.size();\n        std::vector<int> prefix(n + 1, 0);\n        for (int i = 1; i <= n; ++i) {\n            prefix[i] = prefix[i - 1] ^ nums[i - 1];\n        }\n\n        std::vector<int> result;\n        for (int i = 0; i < n; ++i) {\n            int left, right;\n            cin >> left >> right;\n            if (left > right) {\n                std::swap(left, right);\n            }\n            int res = prefix[right + 1] ^ (left > 0 ? prefix[left - 1] : 0);\n            result.push_back(res);\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> nums1 = {4,2,3,1};\n    std::vector<int> expected1 = {8,4,2,4};\n    std::vector<int> result1 = solution.getSubarrayXOR(nums1);\n    for (int i = 0; i < result1.size(); ++i) {\n        if (result1[i] != expected1[i]) {\n            std::cout << \"Test case 1 failed.\" << std::endl;\n            return -1;\n        }\n    }\n    std::cout << \"Test case 1 passed.\" << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {0};\n    std::vector<int> expected2 = {0};\n    std::vector<int> result2 = solution.getSubarrayXOR(nums2);\n    for (int i = 0; i < result2.size(); ++i) {\n        if (result2[i] != expected2[i]) {\n            std::cout << \"Test case 2 failed.\" << std::endl;\n            return -1;\n        }\n    }\n    std::cout << \"Test case 2 passed.\" << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {1,1};\n    std::vector<int> expected3 = {0};\n    std::vector<int> result3 = solution.getSubarrayXOR(nums3);\n    for (int i = 0; i < result3.size(); ++i) {\n        if (result3[i] != expected3[i]) {\n            std::cout << \"Test case 3 failed.\" << std::endl;\n            return -1;\n        }\n    }\n    std::cout << \"Test case 3 passed.\" << std::endl;\n\n    return 0;\n}\n```",
  "1312": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minInsertions(string s) {\n        int n = s.length();\n        string t = \"#\" + s + \"#\";\n        int res = 0, pos = 0;\n        for (int i = 1; i <= n * 2 + 1; i++) {\n            if (pos > i - pos) {\n                pos -= res;\n            } else if (i < pos + 2 * res || t[i] == t[n * 2 + 1 - i]) {\n                pos++;\n            } else {\n                res += 2;\n                pos = i;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.minInsertions(\"zzazz\") << endl; // expected output: 0\n    cout << \"Test Case 2: \" << solution.minInsertions(\"mbadm\") << endl; // expected output: 4\n    cout << \"Test Case 3: \" << solution.minInsertions(\"leetcode\") << endl; // expected output: 5\n\n    return 0;\n}\n```",
  "1311": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass WatchedVideos {\npublic:\n    vector<vector<string>> watchedVideosByFriends(vector<vector<string>>& watchedVideos, int friendId) {\n        unordered_map<int, vector<string>> res;\n        for (int i = 0; i < watchedVideos.size(); i++) {\n            if (watchedVideos[i][0] == to_string(friendId)) {\n                res[friendId] = watchedVideos[i];\n            }\n        }\n        \n        // sort videos\n        for (auto &video : res) {\n            sort(video.second.begin(), video.second.end());\n        }\n\n        return vector<vector<string>>(res.begin(), res.end());\n    }\n};\n\nint main() {\n    WatchedVideos wv;\n    \n    int friendId = 0;\n    vector<vector<string>> watchedVideos1 = {{\"A\", \"D\", \"J\"}, {\"A\", \"B\", \"C\"}};\n    vector<vector<string>> expectedOutput1 = {{\"A\", \"B\", \"C\", \"D\", \"J\"}};\n    cout << \"Test Case 1: \";\n    if (wv.watchedVideosByFriends(watchedVideos1, friendId) == expectedOutput1)\n        cout << \"Pass\" << endl;\n    else\n        cout << \"Fail\" << endl;\n\n    int friendId2 = 1;\n    vector<vector<string>> watchedVideos2 = {{\"A\", \"B\"}, {\"C\", \"D\"}, {\"T\", \"V\"}};\n    vector<vector<string>> expectedOutput2 = {{\"A\", \"B\"}, {\"C\", \"D\"}, {\"T\", \"V\"}};\n    cout << \"Test Case 2: \";\n    if (wv.watchedVideosByFriends(watchedVideos2, friendId2) == expectedOutput2)\n        cout << \"Pass\" << endl;\n    else\n        cout << \"Fail\" << endl;\n\n    int friendId3 = 0;\n    vector<vector<string>> watchedVideos3 = {{}, {\"A\"}, {\"B\", \"C\"}};\n    vector<vector<string>> expectedOutput3 = {{\"A\"}, {\"B\", \"C\"}};\n    cout << \"Test Case 3: \";\n    if (wv.watchedVideosByFriends(watchedVideos3, friendId3) == expectedOutput3)\n        cout << \"Pass\" << endl;\n    else\n        cout << \"Fail\" << endl;\n\n    return 0;\n}",
  "1313": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> decompressRLElist(std::vector<int>& nums) {\n    std::vector<int> result;\n    for (int i = 0; i < nums.size(); i += 2) {\n        int times = nums[i];\n        int value = nums[i + 1];\n        for (int j = 0; j < times; j++) {\n            result.push_back(value);\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 2, 3, 4};\n    std::cout << \"Test Case 1: \";\n    for (int num : decompressRLElist(test1)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> test2 = {1, 1, 2, 3};\n    std::cout << \"Test Case 2: \";\n    for (int num : decompressRLElist(test2)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> test3 = {10, 1, 2, 4, 4, 3};\n    std::cout << \"Test Case 3: \";\n    for (int num : decompressRLElist(test3)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1314": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> sumRegions(vector<vector<int>>& matrix, int row1, int col1, int row2, int col2) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i >= row1 && i <= row2 && j >= col1 && j <= col2) {\n                    matrix[i][j] += matrix[i - row1][j];\n                } else if (i < row1) {\n                    matrix[i][j] += matrix[i][j];\n                } \n            }\n        }\n        \n        vector<vector<int>> result;\n        for (int i = 0; i <= row2 - row1; i++) {\n            vector<int> temp;\n            for (int j = 0; j <= col2 - col1; j++) {\n                int sum = 0;\n                for (int k = 0; k < m; k++) {\n                    sum += matrix[k][j + col1];\n                }\n                temp.push_back(sum);\n            }\n            result.push_back(temp);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> matrix1 = {{0,1,2,3},{4,5,6,7},{8,9,10,11},{12,13,14,15}};\n    int row1 = 1;\n    int col1 = 1;\n    int row2 = 3;\n    int col2 = 3;\n    vector<vector<int>> expected1 = {{12,13,14,15},{19,22,24,26},{21,25,29,32},{30,34,38,41}};\n    for (int i = 0; i < matrix1.size(); i++) {\n        for (int j = 0; j < matrix1[0].size(); j++) {\n            cout << \"Expected: \" << expected1[i][j] << endl;\n        }\n    }\n    vector<vector<int>> result1 = solution.sumRegions(matrix1, row1, col1, row2, col2);\n    for (int i = 0; i < result1.size(); i++) {\n        for (int j = 0; j < result1[0].size(); j++) {\n            cout << \"Result: \" << result1[i][j] << endl;\n        }\n    }\n\n    // Test case 2\n    vector<vector<int>> matrix2 = {{1,2,3},{4,5,6}};\n    row1 = 0;\n    col1 = 0;\n    row2 = 1;\n    col2 = 2;\n    expected1 = {{10,11,12},{15,16,17}};\n    result1 = solution.sumRegions(matrix2, row1, col1, row2, col2);\n    \n    // Test case 3\n    vector<vector<int>> matrix3 = {{0,0,0},{0,7,8},{0,9,10}};\n    row1 = 0;\n    col1 = 0;\n    row2 = 2;\n    col2 = 2;\n    expected1 = {{0,7,8},{12,26,30},{15,34,40}};\n    result1 = solution.sumRegions(matrix3, row1, col1, row2, col2);\n\n    return 0;\n}\n```",
  "1315": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int sum = 0;\n    void dfs(TreeNode* node, TreeNode* parent, TreeNode* grandparent) {\n        if (node == NULL) return;\n        if (grandparent != NULL && grandparent->val % 2 == 0) {\n            sum += node->val;\n        }\n        dfs(node->left, node, parent);\n        dfs(node->right, node, parent);\n    }\n\npublic:\n    int sumOfGrandparentEvenNodes(TreeNode* root) {\n        if (root == NULL) return 0;\n        TreeNode* dummy = new TreeNode(0);\n        dummy->left = root;\n        dfs(root, NULL, dummy);\n        return sum;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    TreeNode* test1_root = new TreeNode(6);\n    test1_root->left = new TreeNode(7);\n    test1_root->right = new TreeNode(14);\n    test1_root->left->left = new TreeNode(2);\n    test1_root->left->right = new TreeNode(11);\n    test1_root->right->left = new TreeNode(1);\n    test1_root->right->right = new TreeNode(0);\n    cout << \"Sum of nodes with even-valued grandparent for test case 1: \"\n         << solution.sumOfGrandparentEvenNodes(test1_root) << endl;\n\n    // Test case 2:\n    TreeNode* test2_root = new TreeNode(5);\n    test2_root->left = new TreeNode(3);\n    test2_root->right = new TreeNode(8);\n    test2_root->left->left = new TreeNode(2);\n    test2_root->left->right = new TreeNode(4);\n    test2_root->right->left = new TreeNode(1);\n    cout << \"Sum of nodes with even-valued grandparent for test case 2: \"\n         << solution.sumOfGrandparentEvenNodes(test2_root) << endl;\n\n    // Test case 3:\n    TreeNode* test3_root = new TreeNode(10);\n    test3_root->left = new TreeNode(5);\n    test3_root->right = new TreeNode(15);\n    test3_root->left->left = new TreeNode(1);\n    test3_root->left->right = new TreeNode(2);\n    cout << \"Sum of nodes with even-valued grandparent for test case 3: \"\n         << solution.sumOfGrandparentEvenNodes(test3_root) << endl;\n\n    return 0;\n}\n```",
  "1316": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass TrieNode {\npublic:\n    char c;\n    bool is_end_of_word;\n    TrieNode* children[26];\n\n    TrieNode(char c) : c(c), is_end_of_word(false) {\n        for (int i = 0; i < 26; i++) {\n            children[i] = nullptr;\n        }\n    }\n};\n\nclass Trie {\npublic:\n    TrieNode* root;\n\n    Trie() : root(new TrieNode('.')) {}\n\n    void insert(const string& s) {\n        TrieNode* current = root;\n        for (char c : s) {\n            if (current->children[c - 'a'] == nullptr) {\n                current->children[c - 'a'] = new TrieNode(c);\n            }\n            current = current->children[c - 'a'];\n        }\n        current->is_end_of_word = true;\n    }\n\n    bool contains(const string& s) {\n        TrieNode* current = root;\n        for (char c : s) {\n            if (current->children[c - 'a'] == nullptr) {\n                return false;\n            }\n            current = current->children[c - 'a'];\n        }\n        return current->is_end_of_word;\n    }\n};\n\nint distinctEchoSubstrings(string text) {\n    Trie trie;\n    int count = 0;\n    for (int i = 0; i < text.size(); i++) {\n        string s = text.substr(i);\n        if (contains(s)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    cout << distinctEchoSubstrings(\"aba\") << endl; // Expected output: 4\n    cout << distinctEchoSubstrings(\"aaa\") << endl; // Expected output: 3\n    cout << distinctEchoSubstrings(\"abcba\") << endl; // Expected output: 5\n\n    return 0;\n}\n```",
  "1317": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int sumOfLeftToInts(int num) {\n        int res = 0;\n        while (num > 0) {\n            int lastDigit = num % 10;\n            if (lastDigit != 0) {\n                res += lastDigit * 10 + (num / 10);\n                break;\n            }\n            num /= 10;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.sumOfLeftToInts(1000000000) << endl; // Expected Output: 1000000000\n    cout << \"Test Case 2: \" << solution.sumOfLeftToInts(10101010) << endl; // Expected Output: 20202020\n    cout << \"Test Case 3: \" << solution.sumOfLeftToInts(12345) << endl; // Expected Output: 24690\n\n    return 0;\n}\n```",
  "1318": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minFlips(int a, int b, int c) {\n        return (a | b) ^ c;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n\n    // Test case 1\n    int a1 = 3;\n    int b1 = 5;\n    int c1 = 2;\n    cout << \"Test case 1: \" << solution.minFlips(a1, b1, c1) << endl;\n\n    // Test case 2\n    int a2 = 10;\n    int b2 = 15;\n    int c2 = 14;\n    cout << \"Test case 2: \" << solution.minFlips(a2, b2, c2) << endl;\n\n    // Test case 3\n    int a3 = 1;\n    int b3 = 4;\n    int c3 = 7;\n    cout << \"Test case 3: \" << solution.minFlips(a3, b3, c3) << endl;\n\n    return 0;\n}\n```",
  "1319": "```\n#include <iostream>\n#include <vector>\n\nclass UnionFind {\npublic:\n    UnionFind(int n) : parent_(n), size_(n, 1) {\n        for (int i = 0; i < n; ++i) {\n            parent_[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent_[x] != x) {\n            parent_[x] = find(parent_[x]);\n        }\n        return parent_[x];\n    }\n\n    void unionSet(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (size_[rootX] < size_[rootY]) {\n                std::swap(rootX, rootY);\n            }\n            parent_[rootY] = rootX;\n            size_[rootX] += size_[rootY];\n        }\n    }\n\nprivate:\n    int* parent_;\n    std::vector<int> size_;\n};\n\nint findCenter(std::vector<std::vector<int>>& edges) {\n    int n = edges.size();\n    UnionFind uf(n);\n\n    for (const auto& edge : edges) {\n        uf.unionSet(edge[0], edge[1]);\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (uf.find(i) == i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    std::vector<std::vector<int>> edges1{{0, 1}, {1, 2}};\n    int result1 = findCenter(edges1);\n    std::cout << \"Number of operations to make network connected for test case 1: \" << result1 << std::endl;\n\n    std::vector<std::vector<int>> edges2{{0, 1}, {1, 2}, {3, 4}};\n    int result2 = findCenter(edges2);\n    std::cout << \"Number of operations to make network connected for test case 2: \" << result2 << std::endl;\n\n    std::vector<std::vector<int>> edges3{{0, 1}, {0, 2}, {0, 3}};\n    int result3 = findCenter(edges3);\n    std::cout << \"Number of operations to make network connected for test case 3: \" << result3 << std::endl;\n\n    return 0;\n}",
  "1320": "```\n#include <iostream>\n#include <vector>\n\nint minSteps(std::string t, std::string c) {\n    int n = t.length();\n    int m = c.length();\n    if (n != m) return -1;\n    \n    std::vector<int> dp(n + 1);\n    for (int i = 0; i <= n; ++i) {\n        dp[i] = i;\n    }\n    \n    for (int i = 0; i < n; ++i) {\n        if (t[i] == c[0]) {\n            int j = 0;\n            while (j < m && t[i + j] == c[j]) {\n                j++;\n            }\n            dp[i + j] = std::min(dp[i + j], i - (m - j));\n        }\n    }\n    \n    int ans = n;\n    for (int i = 1; i <= n; ++i) {\n        ans = std::min(ans, dp[i]);\n    }\n    \n    return ans;\n}\n\nint main() {\n    std::cout << minSteps(\"abc\", \"def\") << std::endl; // Output: 3\n    std::cout << minSteps(\"abccba\", \"covfefe\") << std::endl; // Output: 5\n    std::cout << minSteps(\"aaabaabaaa\", \"abcdefg\") << std::endl; // Output: 7\n\n    return 0;\n}\n```",
  "1322": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint getPerformance(std::vector<std::string>& click, std::vector<std::string>& mouse) {\n    int totalClick = 0;\n    int totalMouse = 0;\n\n    for (const auto& c : click) {\n        totalClick +=stoi(c);\n    }\n\n    for (const auto& m : mouse) {\n        totalMouse += stoi(m);\n    }\n\n    return static_cast<int>((totalClick + totalMouse) / 2.0f);\n}\n\nint main() {\n    std::vector<std::string> click1 = {\"100\", \"200\", \"300\"};\n    std::vector<std::string> mouse1 = {\"150\", \"250\", \"350\"};\n\n    int result1 = getPerformance(click1, mouse1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<std::string> click2 = {\"500\", \"400\"};\n    std::vector<std::string> mouse2 = {\"600\", \"550\"};\n\n    int result2 = getPerformance(click2, mouse2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<std::string> click3 = {\"1000\", \"500\"};\n    std::vector<std::string> mouse3 = {\"800\", \"750\"};\n\n    int result3 = getPerformance(click3, mouse3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1321": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int maxIncringOrder(std::vector<std::vector<int>>& orders) {\n        if (orders.empty()) return 0;\n        \n        std::sort(orders.begin(), orders.end());\n        \n        int maxCount = 1;\n        int currentCount = 1;\n        \n        for (int i = 1; i < orders.size(); i++) {\n            if (orders[i][1] > orders[i-1][1]) {\n                currentCount++;\n            } else {\n                maxCount = std::max(maxCount, currentCount);\n                currentCount = 1;\n            }\n        }\n        \n        return std::max(maxCount, currentCount);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> orders1 = {{1,2},{2,3},{4,5}};\n    std::cout << \"Test Case 1: \" << solution.maxIncringOrder(orders1) << std::endl;\n    \n    // Test case 2\n    std::vector<std::vector<int>> orders2 = {{1,2},{2,3},{3,4},{5,6}};\n    std::cout << \"Test Case 2: \" << solution.maxIncringOrder(orders2) << std::endl;\n    \n    // Test case 3\n    std::vector<std::vector<int>> orders3 = {{1,1},{2,2},{3,3},{4,4}};\n    std::cout << \"Test Case 3: \" << solution.maxIncringOrder(orders3) << std::endl;\n    \n    return 0;\n}\n```",
  "1323": "```\n#include <iostream>\n#include <vector>\n\nint max6969(int num) {\n    int count = 0;\n    while (num > 0) {\n        if ((num % 10) == 6 || (num % 10) == 9) {\n            num /= 10;\n            count++;\n        } else {\n            break;\n        }\n    }\n    return count * 2 + (num > 0);\n}\n\nint main() {\n    std::vector<int> testCases = {8, 690, 1669};\n    for (int testCase : testCases) {\n        int result = max6969(testCase);\n        std::cout << \"Maximum69Number: \" << testCase << \" = \" << result << std::endl;\n    }\n    return 0;\n}\n```",
  "1324": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> printVertically(std::vector<std::string>& words) {\n    int maxLength = 0;\n    for (const auto& word : words) {\n        maxLength = std::max(maxLength, word.size());\n    }\n    \n    std::vector<std::string> result;\n    for (int i = 0; i < maxLength; i++) {\n        std::string line;\n        for (const auto& word : words) {\n            if (i >= word.size()) {\n                line += \" \";\n            } else {\n                line += word[i];\n            }\n        }\n        result.push_back(line);\n    }\n    \n    return result;\n}\n\nint main() {\n    std::vector<std::string> words1 = {\"This\", \"is\", \"an\", \"example\"};\n    std::vector<std::string> words2 = {\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"};\n    std::vector<std::string> words3 = {\"Hello\", \"world\"};\n\n    std::vector<std::string> result1 = printVertically(words1);\n    for (const auto& line : result1) {\n        std::cout << line << std::endl;\n    }\n\n    std::vector<std::string> result2 = printVertically(words2);\n    for (const auto& line : result2) {\n        std::cout << line << std::endl;\n    }\n\n    std::vector<std::string> result3 = printVertically(words3);\n    for (const auto& line : result3) {\n        std::cout << line << std::endl;\n    }\n\n    return 0;\n}",
  "1325": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* removeLeafNodes(TreeNode* root, int target) {\n        if (root == nullptr)\n            return nullptr;\n        root->left = removeLeafNodes(root->left, target);\n        root->right = removeLeafNodes(root->right, target);\n        \n        if (root->val == target && root->left == nullptr && root->right == nullptr)\n            return nullptr; // If the current node is a leaf and its value equals to the target, then delete it.\n        \n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* root1 = new TreeNode(48);\n    root1->left = new TreeNode(94);\n    root1->right = new TreeNode(97);\n    root1->left->left = new TreeNode(11);\n    root1->left->right = new TreeNode(12);\n    int targetValue1 = 12;\n    TreeNode* expectedRoot1 = solution.removeLeafNodes(root1, targetValue1);\n\n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(5);\n    root2->right = new TreeNode(6);\n    root2->right->right = new TreeNode(7);\n    int targetValue2 = 6;\n    TreeNode* expectedRoot2 = solution.removeLeafNodes(root2, targetValue2);\n\n    TreeNode* root3 = new TreeNode(1);\n    int targetValue3 = 0;\n    TreeNode* expectedRoot3 = solution.removeLeafNodes(root3, targetValue3);\n\n    return 0;\n}",
  "1326": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minTaps(vector<int>& r) {\n        int n = r.size();\n        vector<int> dp(n + 1, -1);\n        dp[0] = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (dp[i] == -1)\n                continue;\n            int j = upper_bound(r.begin(), r.end(), r[i]) - r.begin();\n            while (j <= n && r[j] - r[i] > dp[i]) {\n                dp[j] = i;\n                j++;\n            }\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            if (dp[i] == -1)\n                return -1;\n        }\n        \n        int res = 0, pre = 0;\n        for (int i = 1; i <= n; i++) {\n            if (pre != dp[i]) {\n                res++;\n                pre = dp[i];\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> r1 = {1,2,3,4};\n    cout << \"For array: \" << endl;\n    cout << \"Result: \" << solution.minTaps(r1) << endl;\n    cout << \"Expected result: 3\" << endl;\n    cout << endl;\n\n    vector<int> r2 = {1,2,3,5,6};\n    cout << \"For array: \" << endl;\n    cout << \"Result: \" << solution.minTaps(r2) << endl;\n    cout << \"Expected result: 3\" << endl;\n    cout << endl;\n\n    vector<int> r3 = {1,2,4};\n    cout << \"For array: \" << endl;\n    cout << \"Result: \" << solution.minTaps(r3) << endl;\n    cout << \"Expected result: 2\" << endl;\n    return 0;\n}\n```",
  "1328": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string breakPalindrome(std::string palindromic) {\n        int n = palindromic.length();\n        for (int i = 0; i < n / 2; ++i) {\n            if (palindromic[i] != 'a') {\n                return palindromic.substr(0, i) + \"a\" + palindromic.substr(i);\n            }\n        }\n        return \"a\" + std::string(n - 1, 'a');\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::cout << \"Test Case 1: \" << solution.breakPalindrome(\"a\") << std::endl; // Expected output: \"a\"\n    std::cout << \"Test Case 2: \" << solution.breakPalindrome(\"abba\") << std::endl; // Expected output: \"abbca\"\n    std::cout << \"Test Case 3: \" << solution.breakPalindrome(\"racecar\") << std::endl; // Expected output: \"racacar\"\n\n    return 0;\n}\n```",
  "1327": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Record {\n    int id;\n    std::string product;\n    int quantity;\n};\n\nclass Solution {\npublic:\n    std::vector<std::string> getProducts(std::vector<Record>& records, int low, int high) {\n        std::vector<std::string> products;\n        for (const auto& record : records) {\n            if (record.quantity > 0 && record.id >= low && record.id <= high) {\n                products.push_back(record.product);\n            }\n        }\n        return products;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<Record> records1 = {{1, \"Product A\", 2}, {2, \"Product B\", 3}, {3, \"Product C\", 0}, {4, \"Product D\", 1}};\n    int low1 = 1;\n    int high1 = 3;\n    std::vector<std::string> products1 = solution.getProducts(records1, low1, high1);\n    for (const auto& product : products1) {\n        std::cout << product << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<Record> records2 = {{5, \"Product E\", 4}, {6, \"Product F\", 0}, {7, \"Product G\", 1}};\n    int low2 = 5;\n    int high2 = 7;\n    std::vector<std::string> products2 = solution.getProducts(records2, low2, high2);\n    for (const auto& product : products2) {\n        std::cout << product << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<Record> records3 = {{8, \"Product H\", 1}, {9, \"Product I\", 0}, {10, \"Product J\", 2}};\n    int low3 = 8;\n    int high3 = 10;\n    std::vector<std::string> products3 = solution.getProducts(records3, low3, high3);\n    for (const auto& product : products3) {\n        std::cout << product << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1330": "```\n#include <iostream>\n#include <vector>\n\nint maximumEqualParts(std::vector<int>& arr) {\n    int n = arr.size();\n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] == 1) {\n            bool isContiguous = true;\n            while (i + 1 < n && arr[i + 1] == 0) {\n                i++;\n            }\n            ans++;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::vector<int> arr1({1, 0, 1, 0, 1});\n    std::cout << \"Array 1: \" << maximumEqualParts(arr1) << std::endl;\n\n    std::vector<int> arr2({0, 1, 1, 1, 0, 1, 0, 0});\n    std::cout << \"Array 2: \" << maximumEqualParts(arr2) << std::endl;\n\n    std::vector<int> arr3({1, 1, 1, 1, 1, 0, 1, 1});\n    std::cout << \"Array 3: \" << maximumEqualParts(arr3) << std::endl;\n\n    return 0;\n}",
  "1329": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n        int m = mat.size(), n = mat[0].size();\n        for (int k = 0; k < m + n - 1; ++k) {\n            vector<int> temp;\n            int i = max(0, k - n + 1), j = min(k, n - 1);\n            while (i < m && j >= 0) {\n                temp.push_back(mat[i][j]);\n                i++; j--;\n            }\n            sort(temp.begin(), temp.end());\n            i = max(0, k - n + 1); j = min(k, n - 1);\n            for (; i < m && j >= 0; ++i, --j) {\n                mat[i][j] = temp.back();\n                temp.pop_back();\n            }\n        }\n        return mat;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> test1 = {{3, 3, 1, 2}, {1, 4, 2, 3}, {2, 2, 4, 1}};\n    for (vector<int>& row : solution.diagonalSort(test1)) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> test2 = {{1, 3}, {6, 3}};\n    for (vector<int>& row : solution.diagonalSort(test2)) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> test3 = {{1, 4}, {4, 1}};\n    for (vector<int>& row : solution.diagonalSort(test3)) {\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1332": "```\n#include <iostream>\n#include <string>\n\nstd::string removePalindromeSub(std::string s) {\n    int left = 0;\n    int right = s.length() - 1;\n    \n    while (left < right && s[left] == s[right]) {\n        left++;\n        right--;\n    }\n    \n    return s.substr(0, left) + s.substr(left);\n}\n\nint main() {\n    std::cout << removePalindromeSub(\"bapnbagpn\") << std::endl;  // expected \"nap\"\n    std::cout << removePalindromeSub(\"cbbd\") << std::endl;      // expected \"bd\"\n    std::cout << removePalindromeSub(\"a\") << std::endl;         // expected \"a\"\n\n    return 0;\n}\n```",
  "1331": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> arrayRankTransform(std::vector<int>& arr) {\n    std::vector<int> res(arr.size());\n    std::map<int, int> mp;\n    for(int i = 0; i < arr.size(); i++) {\n        if(mp.count(arr[i])) mp[arr[i]]++;\n        else mp[arr[i]] = 1;\n    }\n    int cnt = 1;\n    for(auto &it : mp) {\n        res[it.second - 1] = it.first;\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> arr1 = {40,10,20};\n    std::cout << \"[\";\n    for(int i : arrayRankTransform(arr1)) {\n        std::cout << i << \", \";\n    }\n    std::cout << \"]\";\n\n    std::cout << \"\\n\\n\";\n\n    std::vector<int> arr2 = {100, 1, 3, 10};\n    std::cout << \"[\";\n    for(int i : arrayRankTransform(arr2)) {\n        std::cout << i << \", \";\n    }\n    std::cout << \"]\";\n\n    std::cout << \"\\n\\n\";\n\n    std::vector<int> arr3 = {20, 1, 15};\n    std::cout << \"[\";\n    for(int i : arrayRankTransform(arr3)) {\n        std::cout << i << \", \";\n    }\n    std::cout << \"]\";\n\n    return 0;\n}",
  "1334": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findSmallestCity(vector<vector<string>>& edges, int n, int threshold) {\n        unordered_map<string, vector<pair<string, int>>> graph;\n        for (const auto& edge : edges) {\n            string u = edge[0], v = edge[1];\n            graph[u].push_back({v, stoi(edge[2])});\n            graph[v].push_back({u, stoi(edge[2])});\n        }\n        \n        vector<int> res;\n        int minCount = n, ans;\n        for (const auto& city : graph) {\n            int count = 0;\n            for (const auto& neighbor : city.second) {\n                if (neighbor.second <= threshold) count++;\n            }\n            if (count < minCount) {\n                minCount = count;\n                ans = stoi(city.first);\n            } else if (count == minCount && stoi(city.first) < ans) {\n                ans = stoi(city.first);\n            }\n        }\n        \n        res.push_back(ans);\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<string>> edges1 = {{\"New York\", \"Los Angeles\", \"200\"}, {\"New York\", \"Chicago\", \"100\"}};\n    int n1 = 3; \n    int threshold1 = 150;\n    vector<int> res1 = solution.findSmallestCity(edges1, n1, threshold1);\n    cout << \"Test case 1: \";\n    for (const auto& city : res1) {\n        cout << city << \" \";\n    }\n    cout << endl;\n\n    vector<vector<string>> edges2 = {{\"B\", \"C\", \"10\"}, {\"A\", \"B\", \"5\"}, {\"C\", \"D\", \"4\"}};\n    int n2 = 4; \n    int threshold2 = 6;\n    vector<int> res2 = solution.findSmallestCity(edges2, n2, threshold2);\n    cout << \"Test case 2: \";\n    for (const auto& city : res2) {\n        cout << city << \" \";\n    }\n    cout << endl;\n\n    vector<vector<string>> edges3 = {{\"A\", \"B\", \"1\"}, {\"C\", \"D\", \"1\"}};\n    int n3 = 4; \n    int threshold3 = 2;\n    vector<int> res3 = solution.findSmallestCity(edges3, n3, threshold3);\n    cout << \"Test case 3: \";\n    for (const auto& city : res3) {\n        cout << city << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1333": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Restaurant {\n    std::string name;\n    bool isVeganFriendly;\n    double price;\n    int distance;\n\n    Restaurant(std::string name, bool isVeganFriendly, double price, int distance)\n        : name(name), isVeganFriendly(isVeganFriendly), price(price), distance(distance) {}\n};\n\nbool compareRestaurants(const Restaurant& a, const Restaurant& b) {\n    if (a.isVeganFriendly != b.isVeganFriendly)\n        return a.isVeganFriendly;\n    else if (std::abs(a.price - b.price) > 0.01)\n        return a.price < b.price;\n    else\n        return a.distance < b.distance;\n}\n\nvoid filterRestaurants(std::vector<Restaurant>& restaurants, bool veganOnly, double maxPrice, int maxDistance) {\n    std::sort(restaurants.begin(), restaurants.end(), compareRestaurants);\n\n    for (auto& restaurant : restaurants) {\n        if (!veganOnly || restaurant.isVeganFriendly)\n            continue;\n        if (restaurant.price > maxPrice || restaurant.distance > maxDistance)\n            continue;\n        restaurants.erase(std::remove_and_destroy_at(restaurants.begin(), restaurants.end(), restaurant), restaurants.end());\n    }\n}\n\nint main() {\n    std::vector<Restaurant> restaurants = {\n        {\"Bistro\", true, 15.0, 2},\n        {\"Vegan Cafe\", true, 10.0, 1},\n        {\"Steak House\", false, 25.0, 3},\n        {\"Pizza Place\", false, 12.0, 4}\n    };\n\n    filterRestaurants(restaurants, false, 15.0, 2);\n\n    for (const auto& restaurant : restaurants) {\n        std::cout << \"Name: \" << restaurant.name << \", Vegan Friendly: \" << (restaurant.isVeganFriendly ? \"yes\" : \"no\") << \", Price: $\" << restaurant.price << \", Distance: \" << restaurant.distance << \" blocks\\n\";\n    }\n\n    std::cout << \"\\n\";\n\n    restaurants = {\n        {\"Bistro\", true, 15.0, 2},\n        {\"Vegan Cafe\", true, 10.0, 1},\n        {\"Steak House\", false, 25.0, 3},\n        {\"Pizza Place\", false, 12.0, 4}\n    };\n\n    filterRestaurants(restaurants, true, 15.0, 2);\n\n    for (const auto& restaurant : restaurants) {\n        std::cout << \"Name: \" << restaurant.name << \", Vegan Friendly: \" << (restaurant.isVeganFriendly ? \"yes\" : \"no\") << \", Price: $\" << restaurant.price << \", Distance: \" << restaurant.distance << \" blocks\\n\";\n    }\n\n    std::cout << \"\\n\";\n\n    restaurants = {\n        {\"Bistro\", true, 15.0, 2},\n        {\"Vegan Cafe\", true, 10.0, 1},\n        {\"Steak House\", false, 25.0, 3},\n        {\"Pizza Place\", false, 12.0, 4}\n    };\n\n    filterRestaurants(restaurants, true, 10.0, 2);\n\n    for (const auto& restaurant : restaurants) {\n        std::cout << \"Name: \" << restaurant.name << \", Vegan Friendly: \" << (restaurant.isVeganFriendly ? \"yes\" : \"no\") << \", Price: $\" << restaurant.price << \", Distance: \" << restaurant.distance << \" blocks\\n\";\n    }\n\n    return 0;\n}",
  "1335": "```\n#include <iostream>\n#include <vector>\n\nint minDifficulty(std::vector<int>& jobDifficulty) {\n    int n = jobDifficulty.size();\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1, 0));\n    for (int i = 1; i <= n; i++) {\n        dp[i][i] = jobDifficulty[i - 1];\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i + len - 1 <= n; i++) {\n            int j = i + len - 1;\n            dp[i][j] = std::max(dp[i][i - 1], jobDifficulty[i - 1]) +\n                std::min({dp[k][j - 1] + jobDifficulty[k] for k in range(i, j + 1)});\n        }\n    }\n    return dp[1][n];\n}\n\nint main() {\n    std::vector<int> jobDifficulty1 = {6, 2, 7, 1};\n    std::cout << minDifficulty(jobDifficulty1) << std::endl; // Output: 7\n\n    std::vector<int> jobDifficulty2 = {9, 3, 1, 4, 8, 5};\n    std::cout << minDifficulty(jobDifficulty2) << std::endl; // Output: 12\n\n    std::vector<int> jobDifficulty3 = {10, 11, 12};\n    std::cout << minDifficulty(jobDifficulty3) << std::endl; // Output: 22\n}",
  "1336": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint numFriendVisits(std::vector<std::vector<int>>& friends) {\n    int n = friends.size();\n    std::unordered_map<int, int> visitCount;\n    for (const auto& friendList : friends) {\n        for (int friendId : friendList) {\n            visitCount[friendId]++;\n        }\n    }\n\n    int totalTransactions = 0;\n    for (const auto& pair : visitCount) {\n        totalTransactions += pair.second * (pair.second - 1) / 2;\n    }\n\n    return totalTransactions;\n}\n\nint main() {\n    std::vector<std::vector<int>> friends1 = {{1, 2}, {3, 4}};\n    std::cout << numFriendVisits(friends1) << std::endl; // Output: 6\n\n    std::vector<std::vector<int>> friends2 = {{1, 2, 3}, {2, 3, 4}};\n    std::cout << numFriendVisits(friends2) << std::endl; // Output: 9\n\n    std::vector<std::vector<int>> friends3 = {};\n    std::cout << numFriendVisits(friends3) << std::endl; // Output: 0\n    return 0;\n}\n```",
  "1338": "```\n#include <iostream>\n#include <vector>\n\nint minSetSize(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n    int n = arr.size();\n    int i = 0;\n    while (i < n && arr[i] == arr[0]) i++;\n    if (n % 2 == 1) n--;\n    for (int j = i; j < n; j++) {\n        if (arr[j] != arr[i]) break;\n        n /= 2;\n    }\n    return n / 2 + 1;\n}\n\nint main() {\n    std::vector<int> arr1 = {10,6,5,4,3,2,15};\n    std::cout << \"Test case 1: \" << minSetSize(arr1) << std::endl;\n\n    std::vector<int> arr2 = {8};\n    std::cout << \"Test case 2: \" << minSetSize(arr2) << std::endl;\n\n    std::vector<int> arr3 = {7,1};\n    std::cout << \"Test case 3: \" << minSetSize(arr3) << std::endl;\n    \n    return 0;\n}\n```",
  "1337": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> kWeakestRows(vector<vector<int>>& mat, int k) {\n        vector<pair<int, int>> rows;\n        for (int i = 0; i < mat.size(); ++i) {\n            rows.push_back({count(mat[i]), i});\n        }\n        \n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        for (const auto& row : rows) {\n            pq.push(row);\n        }\n        \n        vector<vector<int>> result;\n        while (!pq.empty() && k--) {\n            const auto& [weakness, index] = pq.top();\n            pq.pop();\n            if (result.size() < index + 1) {\n                result.resize(index + 1);\n            }\n            result[index].push_back(weakness);\n        }\n        \n        return result;\n    }\n\n    int count(const vector<int>& row) {\n        int sum = 0, ones = 0;\n        for (int val : row) {\n            sum += val;\n            if (val == 1) {\n                ++ones;\n            }\n        }\n        return min(sum, ones);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> mat1 = {{1, 1}, 0};\n    int k1 = 2;\n    cout << \"Expected: [[1], [0]]\" << endl;\n    for (const auto& row : solution.kWeakestRows(mat1, k1)) {\n        cout << row.size() << \": \";\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> mat2 = {{0, 0}, {1, 0}};\n    int k2 = 3;\n    cout << \"Expected: [[1], [0]]\" << endl;\n    for (const auto& row : solution.kWeakestRows(mat2, k2)) {\n        cout << row.size() << \": \";\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> mat3 = {{0, 1}, {1, 1}};\n    int k3 = 2;\n    cout << \"Expected: [[0, 1], [1, 1]]\" << endl;\n    for (const auto& row : solution.kWeakestRows(mat3, k3)) {\n        cout << row.size() << \": \";\n        for (int val : row) {\n            cout << val << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1339": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    int maxProduct(TreeNode* root) {\n        long long sum = dfs(root);\n        return (int)(sum*(sum-1)*(sum+1));\n    }\n    \n    long long dfs(TreeNode* node) {\n        if (!node) return 0;\n        long long leftSum = dfs(node->left);\n        long long rightSum = dfs(node->right);\n        return node->val + leftSum + rightSum;\n    }\n};\n\nint main() {\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(5);\n    root1->right = new TreeNode(4);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(3);\n\n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(9);\n    root2->right = new TreeNode(0);\n    root2->left->left = new TreeNode(7);\n    root2->left->right = new TreeNode(2);\n\n    TreeNode* root3 = new TreeNode(4);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(0);\n\n    Solution solution;\n    cout << \"Test case 1: \" << solution.maxProduct(root1) << endl; // expected output: 14\n    cout << \"Test case 2: \" << solution.maxProduct(root2) << endl; // expected output: 18\n    cout << \"Test case 3: \" << solution.maxProduct(root3) << endl; // expected output: 6\n\n    return 0;\n}\n```",
  "1340": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canReach(vector<int>& arr) {\n        int n = arr.size();\n        vector<bool> dp(n, false);\n        dp[0] = true;\n        for (int i = 1; i < n; i++) {\n            if (!dp[i]) continue;\n            for (int j = min(i + arr[i], n - 1); j >= 0 && j > i; j--) {\n                if (j - arr[j] >= 0 && dp[j - arr[j]]) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp.back();\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1\n    vector<int> arr1 = {2,3,1,1,4};\n    cout << (s.canReach(arr1) ? \"True\" : \"False\") << endl; // True\n    \n    // Test case 2\n    vector<int> arr2 = {3,0,2,8,7,17};\n    cout << (s.canReach(arr2) ? \"True\" : \"False\") << endl; // False\n    \n    // Test case 3\n    vector<int> arr3 = {1, 2, 3, 4, 5};\n    cout << (s.canReach(arr3) ? \"True\" : \"False\") << endl; // True\n\n    return 0;\n}\n```",
  "1342": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSteps(int steps) {\n        int ans = 0;\n        while (steps > 0) {\n            if ((steps & 1) == 0)\n                steps /= 2;\n            else\n                steps--;\n            ans++;\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << solution.numSteps(14) << endl; // expected output: 6\n    cout << \"Test case 2: \" << solution.numSteps(8) << endl;   // expected output: 4\n    cout << \"Test case 3: \" << solution.numSteps(123456789) << endl; // expected output: 31\n\n    return 0;\n}\n```",
  "1341": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Movie {\npublic:\n    string title;\n    int rating;\n};\n\nclass Rating {\npublic:\n    vector<Movie> movies;\n};\n\nint getMovieRating(vector<Rating>& ratings, string movieTitle) {\n    for (auto& rating : ratings) {\n        for (auto& movie : rating.movies) {\n            if (movie.title == movieTitle) {\n                return movie.rating;\n            }\n        }\n    }\n    return -1;  // Not found\n}\n\nint main() {\n    vector<Rating> ratings = {{{\"MovieA\", 4}, {\"MovieB\", 3}}, \n                               {{\"MovieC\", 5}, {\"MovieD\", 2}},\n                               {{}}};\n\n    cout << \"Test Case 1: Get rating for MovieA - Expected: 4, Actual: \" << getMovieRating(ratings, \"MovieA\") << endl;\n    if (getMovieRating(ratings, \"MovieA\") == 4) {\n        cout << \"PASS\" << endl;\n    } else {\n        cout << \"FAIL\" << endl;\n    }\n\n    cout << \"Test Case 2: Get rating for MovieD - Expected: 2, Actual: \" << getMovieRating(ratings, \"MovieD\") << endl;\n    if (getMovieRating(ratings, \"MovieD\") == 2) {\n        cout << \"PASS\" << endl;\n    } else {\n        cout << \"FAIL\" << endl;\n    }\n\n    cout << \"Test Case 3: Get rating for MovieE - Expected: -1, Actual: \" << getMovieRating(ratings, \"MovieE\") << endl;\n    if (getMovieRating(ratings, \"MovieE\") == -1) {\n        cout << \"PASS\" << endl;\n    } else {\n        cout << \"FAIL\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1344": "```\n#include <iostream>\nusing namespace std;\n\ndouble findAngle(int hour, int minute) {\n    double hourAngle = (hour % 12 + minute * 0.5) * 30;\n    double minuteAngle = minute * 6;\n    return abs(hourAngle - minuteAngle);\n}\n\nint main() {\n    cout << fixed << setprecision(2);\n    \n    // Test Case 1\n    int hour1 = 3, minute1 = 25;\n    cout << \"Test case 1: Hour - \" << hour1 << \", Minute - \" << minute1 << endl;\n    cout << \"Angle between hands of the clock: \" << findAngle(hour1, minute1) << \" degrees\" << endl;\n\n    // Test Case 2\n    int hour2 = 9, minute2 = 45;\n    cout << \"Test case 2: Hour - \" << hour2 << \", Minute - \" << minute2 << endl;\n    cout << \"Angle between hands of the clock: \" << findAngle(hour2, minute2) << \" degrees\" << endl;\n\n    // Test Case 3\n    int hour3 = 12, minute3 = 30;\n    cout << \"Test case 3: Hour - \" << hour3 << \", Minute - \" << minute3 << endl;\n    cout << \"Angle between hands of the clock: \" << findAngle(hour3, minute3) << \" degrees\" << endl;\n\n    return 0;\n}\n```",
  "1343": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int numSubarraysKthDivide(std::vector<int>& nums, int k, int threshold) {\n        long long res = 0;\n        for (int i = 0; i <= nums.size() - k; i++) {\n            long long sum = 0;\n            for (int j = i; j < i + k; j++) {\n                sum += nums[j];\n            }\n            if (sum * k >= threshold) {\n                res++;\n            }\n        }\n        return static_cast<int>(res);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> nums1 = {2, 4, 3};\n    int k1 = 2;\n    int threshold1 = 3;\n    std::cout << \"Test case 1: \" << solution.numSubarraysKthDivide(nums1, k1, threshold1) << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {5};\n    int k2 = 1;\n    int threshold2 = 6;\n    std::cout << \"Test case 2: \" << solution.numSubarraysKthDivide(nums2, k2, threshold2) << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {5, 4};\n    int k3 = 2;\n    int threshold3 = 8;\n    std::cout << \"Test case 3: \" << solution.numSubarraysKthDivide(nums3, k3, threshold3) << std::endl;\n\n    return 0;\n}",
  "1345": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxResult(vector<int>& nums) {\n        vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            dp[i] = nums[i];\n            for (int j = 1; j <= min(i, i - 1 + nums[i - 1]); j++) {\n                if (j < i) {\n                    dp[i] = max(dp[i], dp[j - 1] + nums[j]);\n                }\n            }\n        }\n        return dp.back();\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> test1 = {2,3,-1,5,-2,6};\n    cout << \"Test case 1: \" << solution.maxResult(test1) << endl; // Output: 8\n    \n    vector<int> test2 = {-10,-12,-4,-20};\n    cout << \"Test case 2: \" << solution.maxResult(test2) << endl; // Output: -6\n\n    vector<int> test3 = {0,1,2,3,4};\n    cout << \"Test case 3: \" << solution.maxResult(test3) << endl; // Output: 12\n    return 0;\n}\n```",
  "1346": "```\n#include <iostream>\n#include <vector>\n\nbool exists(std::vector<int>& nums, int n) {\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] == n || nums[i] == 2 * n) return true;\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 3, 4, 2, 3};\n    std::cout << \"Test case 1: \" << (exists(test1, 3) ? \"Yes\" : \"No\") << std::endl;\n\n    std::vector<int> test2 = {5, 6, 7, 8, 9};\n    std::cout << \"Test case 2: \" << (exists(test2, 5) ? \"Yes\" : \"No\") << std::endl;\n\n    std::vector<int> test3 = {1, 2, 3, 4, 10};\n    std::cout << \"Test case 3: \" << (exists(test3, 5) ? \"Yes\" : \"No\") << std::endl;\n    \n    return 0;\n}\n```",
  "1347": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSteps(string s, string t) {\n        unordered_map<char, int> countS, countT;\n        \n        for (char c : s) {\n            countS[c]++;\n        }\n        \n        for (char c : t) {\n            countT[c]++;\n        }\n        \n        int steps = 0;\n        for (auto p : countS) {\n            if (countT.find(p.first) == countT.end()) {\n                steps += p.second;\n            } else {\n                steps += abs(p.second - countT[p.first]);\n            }\n        }\n        \n        return steps;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test Case 1: \";\n    string s1 = \"ezupfgov\", t1 = \"vzuhiagop\"; \n    cout << solution.minSteps(s1, t1) << endl;\n\n    cout << \"\\nTest Case 2: \";\n    string s2 = \"aui\", t2 = \"idap\"; \n    cout << solution.minSteps(s2, t2) << endl;\n\n    cout << \"\\nTest Case 3: \";\n    string s3 = \"abcdefghijklmnopqrstuvwxyz\", t3 = \"zyxwvutsrqponmlkjihgfedcba\"; \n    cout << solution.minSteps(s3, t3) << endl;\n    \n    return 0;\n}\n```",
  "1348": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass TweetCounts {\npublic:\n    map<string, vector<int>> freqTweets;\n    \n    void recordTweet(string tweetName, int time) {\n        if (!freqTweets.count(tweetName)) {\n            freqTweets[tweetName] = vector<int>();\n        }\n        freqTweets[tweetName].push_back(time);\n    }\n\n    vector<vector<int>> getTweetCounts() {\n        vector<vector<int>> result;\n        for (auto it = freqTweets.begin(); it != freqTweets.end(); ++it) {\n            sort(it->second.begin(), it->second.end());\n            int i = 0, j = 0;\n            while (i < it->second.size()) {\n                if (j >= it->second.size() || it->second[i] == it->second[j]) {\n                    result.push_back({it->first, it->second[i]});\n                    i++;\n                    j = i;\n                } else {\n                    j++;\n                }\n            }\n        }\n        return result;\n    }\n\nint main() {\n    TweetCounts tweetCounts;\n\n    // Test Case 1\n    tweetCounts.recordTweet(\"tweet1\", 0);\n    tweetCounts.recordTweet(\"tweet2\", 5);\n    tweetCounts.recordTweet(\"tweet3\", 10);\n    vector<vector<int>> res1 = tweetCounts.getTweetCounts();\n    for (auto it : res1) {\n        cout << \"Frequency: \" << it[1] << \", Count: \" << it[0].size() << endl;\n    }\n\n    // Test Case 2\n    tweetCounts.recordTweet(\"tweet4\", 15);\n    tweetCounts.recordTweet(\"tweet5\", 20);\n    tweetCounts.recordTweet(\"tweet6\", 25);\n    vector<vector<int>> res2 = tweetCounts.getTweetCounts();\n    for (auto it : res2) {\n        cout << \"Frequency: \" << it[1] << \", Count: \" << it[0].size() << endl;\n    }\n\n    // Test Case 3\n    tweetCounts.recordTweet(\"tweet7\", 10);\n    tweetCounts.recordTweet(\"tweet8\", 15);\n    tweetCounts.recordTweet(\"tweet9\", 20);\n    vector<vector<int>> res3 = tweetCounts.getTweetCounts();\n    for (auto it : res3) {\n        cout << \"Frequency: \" << it[1] << \", Count: \" << it[0].size() << endl;\n    }\n\n    return 0;\n}\n```",
  "1349": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxStudents(vector<vector<char>>& seats) {\n        int n = seats.size();\n        int m = seats[0].size();\n        vector<int> dp(n, 1 << m);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (seats[i][j] == 'N') continue;\n                \n                int nextLeft = i > 0 ? dp[i - 1] : 0;\n                int nextRight = i < n - 1 && j < m - 1 ? (seats[i + 1][j + 1] == 'N' ? dp[i + 1] : 0) : 0;\n                \n                if ((nextLeft | nextRight) != 0) {\n                    dp[i] &= ~(1 << j);\n                } else {\n                    dp[i] |= 1 << j;\n                }\n            }\n        }\n        \n        int maxStudents = 0;\n        for (int i = 0; i < n; i++) {\n            maxStudents = max(maxStudents, bitcount(dp[i]));\n        }\n        \n        return maxStudents;\n    }\n    \n    int bitcount(int x) {\n        int count = 0;\n        while (x > 0) {\n            x &= ~(x & -x);\n            count++;\n        }\n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<char>> seats1 = {{1,0},{2,0}};\n    cout << \"Maximum students in test case 1: \" << solution.maxStudents(seats1) << endl; \n\n    // Test case 2\n    vector<vector<char>> seats2 = {{0,1},{1,0},{1,0},{1,1},{1,1},{1,0}};\n    cout << \"Maximum students in test case 2: \" << solution.maxStudents(seats2) << endl; \n\n    // Test case 3\n    vector<vector<char>> seats3 = {{1,0},{0,1},{1,0},{1,1},{1,0},{1,1}};\n    cout << \"Maximum students in test case 3: \" << solution.maxStudents(seats3) << endl; \n\n    return 0;\n}\n```",
  "1350": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int checkStudents(std::vector<std::string>& columns) {\n        int count = 0;\n        for (const auto &column : columns) {\n            if (!isValidDepartment(column)) {\n                ++count;\n            }\n        }\n        return count;\n    }\n\n    bool isValidDepartment(const std::string& department) {\n        // Add your validation logic here\n        return true; // or false, depending on the actual condition\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1: Valid departments\n    std::vector<std::string> columns1 = {\"Science\", \"Engineering\", \"Math\"};\n    int result1 = solution.checkStudents(columns1);\n    std::cout << \"Test case 1: Expected 0, got \" << result1 << std::endl;\n\n    // Test case 2: Invalid departments\n    std::vector<std::string> columns2 = {\"Computer Science\", \"Invalid Department\", \"Math\"};\n    int result2 = solution.checkStudents(columns2);\n    std::cout << \"Test case 2: Expected 1, got \" << result2 << std::endl;\n\n    // Test case 3: Multiple invalid departments\n    std::vector<std::string> columns3 = {\"Computer Science\", \"Invalid Department 1\", \"Invalid Department 2\", \"Math\"};\n    int result3 = solution.checkStudents(columns3);\n    std::cout << \"Test case 3: Expected 2, got \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1351": "```\n#include <iostream>\n#include <vector>\n\nint countNegatives(std::vector<std::vector<int>>& grid) {\n    int m = grid.size();\n    int n = grid[0].size();\n    int count = 0;\n    \n    for (int i = 0; i < m; i++) {\n        int j = -1;\n        while (++j <= n && (grid[i][j] > 0)) {\n            // nothing\n        }\n        if (j > 0) {\n            count += j;\n        } else {\n            count += n;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    std::vector<std::vector<int>> grid1 = {{4, 3, 2, -1}, {3, 2, 1, -1}, {1, -1, -1, -1}, {-1, -1, -1, -1}};\n    int res1 = countNegatives(grid1);\n    std::cout << \"Test case 1: \" << res1 << std::endl;\n    \n    std::vector<std::vector<int>> grid2 = {{1, -1}, {1, -1}};\n    int res2 = countNegatives(grid2);\n    std::cout << \"Test case 2: \" << res2 << std::endl;\n    \n    std::vector<std::vector<int>> grid3 = {{1, 1, 0, -1}, {1, 2, 2, -1}, {4, 3, 2, -1}, {3, 2, 1, -1}};\n    int res3 = countNegatives(grid3);\n    std::cout << \"Test case 3: \" << res3 << std::endl;\n    \n    return 0;\n}\n```",
  "1352": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass ProductOfLastKNumbers {\npublic:\n    vector<int> product(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> res(n);\n        res[0] = 1;\n        for (int i = 1; i < n; i++) {\n            res[i] = res[i - 1] * nums[i - 1];\n        }\n        long long temp = 1;\n        for (int i = n - 2; i >= 0; i--) {\n            temp *= nums[i + 1];\n            res[i] *= temp;\n        }\n        return res;\n    }\n};\n\nint main() {\n    ProductOfLastKNumbers solution;\n\n    // Test case 1\n    vector<int> test1 = {10};\n    for (int num : solution.product(test1)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<int> test2 = {0, 0, 0, 2, 3, 4);\n    for (int num : solution.product(test2)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<int> test3 = {5, 7, 8, 13};\n    for (int num : solution.product(test3)) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    return 0;\n}\n```",
  "1353": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxEvents(std::vector<std::vector<int>>& events) {\n    std::sort(events.begin(), events.end(), [](const auto& a, const auto& b) {\n        return a[1] < b[1];\n    });\n    \n    int mx = 0;\n    for (int i = 0; i < events.size(); ++i) {\n        mx++;\n        for (int j = i + 1; j < events.size() && events[i][1] >= events[j][0]; ++j) {\n            mx++;\n        }\n    }\n    \n    return mx;\n}\n\nint main() {\n    std::vector<std::vector<int>> events1 = {{1,4},{2,3},{5,7}};\n    std::cout << \"Test Case 1: \" << maxEvents(events1) << std::endl;\n\n    std::vector<std::vector<int>> events2 = {{1,2},{2,3},{3,4},{4,5},{5,6},{2,5},{3,4}};\n    std::cout << \"Test Case 2: \" << maxEvents(events2) << std::endl;\n\n    std::vector<std::vector<int>> events3 = {{1,4},{4,4}};\n    std::cout << \"Test Case 3: \" << maxEvents(events3) << std::endl;\n    \n    return 0;\n}\n```",
  "1354": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> constructArray(int n, int k) {\n        vector<int> res;\n        for (int i = 0; i <= k; i++) {\n            res.push_back(i);\n        }\n        for (int i = k + 1; i < n; i++) {\n            if (k % 2 == 0) {\n                res.push_back(i);\n            } else {\n                res.push_back(n - i);\n            }\n            k--;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n = 5, k = 3;\n    vector<int> expected = {0, 4, 1, 3, 2};\n    if (solution.constructArray(n, k) != expected) {\n        cout << \"Test case 1 failed.\" << endl;\n    }\n\n    // Test case 2\n    n = 10, k = 9;\n    expected = {0, 9, 1, 8, 4, 7, 2, 6, 3, 5};\n    if (solution.constructArray(n, k) != expected) {\n        cout << \"Test case 2 failed.\" << endl;\n    }\n\n    // Test case 3\n    n = 7, k = 6;\n    expected = {0, 6, 1, 5, 4, 3, 2};\n    if (solution.constructArray(n, k) != expected) {\n        cout << \"Test case 3 failed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1356": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nclass Solution {\npublic:\n    std::vector<int> sortArrayByParityII(std::vector<int>& nums) {\n        int i = 0, j = 1;\n        while (j < nums.size()) {\n            if ((nums[i] & 1) == 0 && (nums[j] & 1) != 0) {\n                std::swap(nums[i], nums[j]);\n                i++;\n                j++;\n            } else if ((nums[i] & 1) == 0) {\n                i++;\n            } else if ((nums[j] & 1) != 0) {\n                j++;\n            } else {\n                i++;\n                j++;\n            }\n        }\n        return nums;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::vector<int> test1 = {0, 1};\n    auto result1 = solution.sortArrayByParityII(test1);\n    for (int num : result1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> test2 = {2, 3, 0, 1};\n    auto result2 = solution.sortArrayByParityII(test2);\n    for (int num : result2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> test3 = {4, 5, 0, 1};\n    auto result3 = solution.sortArrayByParityII(test3);\n    for (int num : result3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1355": "```\n#include <iostream>\n#include <vector>\n#include <set>\n\nclass Solution {\npublic:\n    std::vector<int> findParticipants(int n, const std::vector<std::string>& activities) {\n        std::set<std::string> participantSet;\n        for (const auto& activity : activities) {\n            int start = 0, end = 0;\n            for (char c : activity) {\n                if (c == 's') {\n                    start++;\n                } else {\n                    end++;\n                }\n            }\n            for (int i = start; i <= end; ++i) {\n                participantSet.insert(std::to_string(i));\n            }\n        }\n        std::vector<int> participants;\n        for (const auto& participant : participantSet) {\n            participants.push_back(stoi(participant));\n        }\n        return participants;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n = 5;\n    std::vector<std::string> activities = {\"Alice:4-6\", \"Bob:3-4\", \"Charlie:1-2\"};\n    std::vector<int> expectedParticipants = {1, 2, 3, 4, 5};\n    auto participants = solution.findParticipants(n, activities);\n    for (const auto& participant : participants) {\n        std::cout << participant << \" \";\n    }\n    std::cout << std::endl;\n    if (participants == expectedParticipants) {\n        std::cout << \"Test case 1: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Failed\" << std::endl;\n    }\n\n    // Test case 2\n    n = 4;\n    activities = {\"Alice:1-3\", \"Bob:1-2\"};\n    expectedParticipants = {1, 2, 3};\n    participants = solution.findParticipants(n, activities);\n    for (const auto& participant : participants) {\n        std::cout << participant << \" \";\n    }\n    std::cout << std::endl;\n    if (participants == expectedParticipants) {\n        std::cout << \"Test case 2: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Failed\" << std::endl;\n    }\n\n    // Test case 3\n    n = 6;\n    activities = {\"Alice:1-2\", \"Bob:5-6\"};\n    expectedParticipants = {1, 2, 5, 6};\n    participants = solution.findParticipants(n, activities);\n    for (const auto& participant : participants) {\n        std::cout << participant << \" \";\n    }\n    std::cout << std::endl;\n    if (participants == expectedParticipants) {\n        std::cout << \"Test case 3: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Failed\" << std::endl;\n    }\n\n    return 0;\n}",
  "1358": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSubstrings(string s) {\n        int n = s.length();\n        int ans = 0;\n        unordered_map<char, pair<int, int>> mp;\n        for (int i = 0; i < n; i++) {\n            mp[s[i]].second = i;\n        }\n        for (char c : s) {\n            if (!mp.count(c)) continue;\n            pair<int, int> p = mp[c];\n            ans += p.second - mp[c].first;\n            mp.erase(c);\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: s = \\\"abcabc\\\", expected output = 10, actual output = \";\n    cout << solution.numSubstrings(\"abcabc\") << endl;\n\n    cout << \"Test case 2: s = \\\"abca\\\", expected output = 4, actual output = \";\n    cout << solution.numSubstrings(\"abca\") << endl;\n\n    cout << \"Test case 3: s = \\\"aabbaa\\\", expected output = 12, actual output = \";\n    cout << solution.numSubstrings(\"aabbaa\") << endl;\n}\n```",
  "1357": "```\n#include <iostream>\n#include <vector>\n\nclass Discount {\npublic:\n    int applyDiscount(std::vector<int>& customers, int n) {\n        int total = 0;\n        for (int i = 0; i < customers.size(); i++) {\n            if ((i + 1) % n == 0) {\n                total += customers[i];\n            }\n        }\n        return total;\n    }\n};\n\nint main() {\n    Discount discount;\n\n    // Test Case 1\n    std::vector<int> customers1 = {10, 20, 30, 40, 50};\n    int testResult1 = discount.applyDiscount(customers1, 2);\n    if (testResult1 == 60) {\n        std::cout << \"Test Case 1: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1: Fail\" << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<int> customers2 = {10, 20, 30};\n    int testResult2 = discount.applyDiscount(customers2, 3);\n    if (testResult2 == 60) {\n        std::cout << \"Test Case 2: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2: Fail\" << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<int> customers3 = {10, 20};\n    int testResult3 = discount.applyDiscount(customers3, 4);\n    if (testResult3 == 30) {\n        std::cout << \"Test Case 3: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3: Fail\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1359": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countOrders(int n) {\n        if (n == 1)\n            return 0;\n        long long res = 1, MOD = 1000000007;\n        for (int i = 2; i <= n; ++i) {\n            res = (res * i) % MOD;\n        }\n        return int(res);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    int n1 = 2;\n    cout << \"Test case 1: Count of valid pickup and delivery options for n = \" << n1 << \" is \" << solution.countOrders(n1) << endl;\n    \n    // Test case 2\n    int n2 = 3;\n    cout << \"Test case 2: Count of valid pickup and delivery options for n = \" << n2 << \" is \" << solution.countOrders(n2) << endl;\n    \n    // Test case 3\n    int n3 = 4;\n    cout << \"Test case 3: Count of valid pickup and delivery options for n = \" << n3 << \" is \" << solution.countOrders(n3) << endl;\n\n    return 0;\n}\n```",
  "1360": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    int daysBetweenDates(std::string date1, std::string date2) {\n        // Your logic here\n        return 0;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::cout << \"Test Case 1: \" << solution.daysBetweenDates(\"2019-01-01\", \"2019-07-31\") << std::endl;\n\n    // Test Case 2\n    std::cout << \"Test Case 2: \" << solution.daysBetweenDates(\"2020-03-15\", \"2020-04-01\") << std::endl;\n\n    // Test Case 3\n    std::cout << \"Test Case 3: \" << solution.daysBetweenDates(\"1999-06-30\", \"2000-01-01\") << std::endl;\n\n    return 0;\n}\n```",
  "1361": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int sum) {\n        if (!root)\n            return false;\n        \n        sum -= root->val;\n        if (!root->left && !root->right)\n            return sum == 0;\n        \n        return hasPathSum(root->left, sum) || hasPathSum(root->right, sum);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    TreeNode* root1 = new TreeNode(5);\n    root1->left = new TreeNode(4);\n    root1->right = new TreeNode(8);\n    root1->left->left = new TreeNode(11);\n    root1->left->right = new TreeNode(7);\n    root1->right->left = new TreeNode(4);\n    root1->right->right = new TreeNode(2);\n    \n    std::cout << \"Test Case 1: \" << solution.hasPathSum(root1, 22) << std::endl;\n    \n    // Test Case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(2);\n    \n    std::cout << \"Test Case 2: \" << solution.hasPathSum(root2, 5) << std::endl;\n    \n    // Test Case 3\n    TreeNode* root3 = nullptr;\n    \n    std::cout << \"Test Case 3: \" << solution.hasPathSum(root3, 1) << std::endl;\n    \n    return 0;\n}\n```",
  "1362": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<long long> closestDivisors(long long num) {\n        vector<long long> res;\n        for (long long i = sqrt(num); i >= 1; --i) {\n            if (num % i == 0) {\n                res.push_back(i);\n                res.push_back(num / i);\n                break;\n            }\n        }\n        if (res.empty()) {\n            res.push_back(1);\n            res.push_back(num);\n        }\n        sort(res.begin(), res.end());\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    long long num = 43;\n    vector<long long> expected = {1, 43};\n    vector<long long> result = solution.closestDivisors(num);\n    if (result == expected) {\n        cout << \"Test case 1 passed.\" << endl;\n    } else {\n        cout << \"Test case 1 failed. Expected: \" << expected[0] << \", \" << expected[1] << \". Got: \";\n        for (long long i : result) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    num = 555;\n    expected = {5, 111};\n    result = solution.closestDivisors(num);\n    if (result == expected) {\n        cout << \"Test case 2 passed.\" << endl;\n    } else {\n        cout << \"Test case 2 failed. Expected: \" << expected[0] << \", \" << expected[1] << \". Got: \";\n        for (long long i : result) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    num = 625;\n    expected = {5, 125};\n    result = solution.closestDivisors(num);\n    if (result == expected) {\n        cout << \"Test case 3 passed.\" << endl;\n    } else {\n        cout << \"Test case 3 failed. Expected: \" << expected[0] << \", \" << expected[1] << \". Got: \";\n        for (long long i : result) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1363": "```\n#include <iostream>\n#include <vector>\n\nint largestMultipleOfThree(std::vector<int>& digits) {\n    int sum = 0;\n    int zeroCount = 0;\n\n    for (int digit : digits) {\n        sum += digit;\n        if (digit == 0) {\n            zeroCount++;\n        }\n    }\n\n    while (sum % 3 != 0 && zeroCount > 0) {\n        sum -= 0;\n        zeroCount--;\n    }\n\n    if (sum % 3 != 0) {\n        for (int i = digits.size() - 1; i >= 0; i--) {\n            if ((sum + digits[i]) % 3 == 0 || (sum + digits[i] + 9) % 3 == 0) {\n                sum += digits[i];\n                break;\n            }\n        }\n    }\n\n    return sum;\n}\n\nint main() {\n    std::vector<int> test1 = {8, 1, 2, 5};\n    std::cout << \"Test case 1: \" << largestMultipleOfThree(test1) << std::endl;\n\n    std::vector<int> test2 = {9, 5, 4, 0};\n    std::cout << \"Test case 2: \" << largestMultipleOfThree(test2) << std::endl;\n\n    std::vector<int> test3 = {12};\n    std::cout << \"Test case 3: \" << largestMultipleOfThree(test3) << std::endl;\n\n    return 0;\n}",
  "1364": "```\n#include <iostream>\n#include <vector>\n\nint numTrustedContacts(std::vector<std::string>& trustedContacts) {\n    int count = 0;\n    for (const auto& contact : trustedContacts) {\n        if (contact.size() > 1) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::string> contacts1 = {\"John\", \"Jane\"};\n    int result1 = numTrustedContacts(contacts1);\n    std::cout << \"Test Case 1: \" << result1 << \"\\n\";\n\n    // Test Case 2\n    std::vector<std::string> contacts2 = {\"Alice\", \"Bob\", \"Eve\"};\n    int result2 = numTrustedContacts(contacts2);\n    std::cout << \"Test Case 2: \" << result2 << \"\\n\";\n\n    // Test Case 3\n    std::vector<std::string> contacts3 = {};\n    int result3 = numTrustedContacts(contacts3);\n    std::cout << \"Test Case 3: \" << result3 << \"\\n\";\n\n    return 0;\n}\n```",
  "1365": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint smallerNumbersThanCurrent(std::vector<int>& nums) {\n    std::vector<int> result(nums.size(), 0);\n    for (int i = 0; i < nums.size(); ++i) {\n        for (int j = 0; j < nums.size(); ++j) {\n            if (nums[j] < nums[i]) {\n                result[i]++;\n            }\n        }\n    }\n    return std::accumulate(result.begin(), result.end(), 0);\n}\n\nint main() {\n    {\n        std::vector<int> nums1 = {8, 1, 2, 2, 3};\n        int res1 = smallerNumbersThanCurrent(nums1);\n        if (res1 == 4) {\n            std::cout << \"Test case 1 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 1 failed. Expected: 4, got: \" << res1 << \".\" << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> nums2 = {6, 5, 4, 8];\n        int res2 = smallerNumbersThanCurrent(nums2);\n        if (res2 == 2) {\n            std::cout << \"Test case 2 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 2 failed. Expected: 2, got: \" << res2 << \".\" << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> nums3 = [1, 0];\n        int res3 = smallerNumbersThanCurrent(nums3);\n        if (res3 == 1) {\n            std::cout << \"Test case 3 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 3 failed. Expected: 1, got: \" << res3 << \".\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "1366": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> rankTeams(vector<string>& voted) {\n        map<char, int> cnt;\n        vector<pair<int, string>> res;\n        \n        for (const auto &v: voted) {\n            ++cnt[v[0]];\n        }\n        \n        for (auto it = cnt.begin(); it != cnt.end(); ++it) {\n            res.push_back({it->second, it->first});\n        }\n        \n        sort(res.rbegin(), res.rend());\n        \n        vector<vector<string>> ans;\n        for (const auto &p: res) {\n            vector<string> team(p.second + 1, string(1, p.second));\n            ans.push_back(team);\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<string> voted1 = {\"WMB\", \"MBC\", \"WBC\", \"WMC\", \"MBW\", \"BWM\"};\n    vector<vector<string>> result1 = solution.rankTeams(voted1);\n    for (const auto &team : result1) {\n        cout << team.size() << \": \";\n        for (const auto &player : team) {\n            cout << player;\n        }\n        cout << endl;\n    }\n\n    // Test Case 2\n    vector<string> voted2 = {\"WXYZ\", \"XZY\", \"YZW\"};\n    vector<vector<string>> result2 = solution.rankTeams(voted2);\n    for (const auto &team : result2) {\n        cout << team.size() << \": \";\n        for (const auto &player : team) {\n            cout << player;\n        }\n        cout << endl;\n    }\n\n    // Test Case 3\n    vector<string> voted3 = {\"ABCDEF\", \"BCEFA\", \"AEBFC\", \"AEFBC\", \"FABCE\", \"EAFDB\"};\n    vector<vector<string>> result3 = solution.rankTeams(voted3);\n    for (const auto &team : result3) {\n        cout << team.size() << \": \";\n        for (const auto &player : team) {\n            cout << player;\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1367": "```\n#include <iostream>\n#include \"TreeNode.h\"\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isSubtree(TreeNode* s, TreeNode* t) {\n        if (!s) return !t;\n        if (isIdentical(s, t)) return true;\n        return isSubtree(s->left, t) || isSubtree(s->right, t);\n    }\n\n    bool isIdentical(TreeNode* p, TreeNode* q) {\n        if (!p && !q) return true;\n        if (!p || !q) return false;\n        return (p->val == q->val) && isIdentical(p->left, q->left) && isIdentical(p->right, q->right);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* s1 = new TreeNode(3);\n    s1->left = new TreeNode(4);\n    s1->right = new TreeNode(5);\n    TreeNode* t1 = new TreeNode(4);\n    t1->left = new TreeNode(1);\n    t1->right = new TreeNode(6);\n    cout << (solution.isSubtree(s1, t1) ? \"True\" : \"False\") << endl;\n\n    // Test Case 2\n    TreeNode* s2 = nullptr;\n    TreeNode* t2 = new TreeNode(4);\n    t2->left = new TreeNode(1);\n    t2->right = new TreeNode(6);\n    cout << (solution.isSubtree(s2, t2) ? \"True\" : \"False\") << endl;\n\n    // Test Case 3\n    TreeNode* s3 = new TreeNode(4);\n    s3->left = new TreeNode(1);\n    s3->right = new TreeNode(6);\n    TreeNode* t3 = new TreeNode(5);\n    t3->left = new TreeNode(2);\n    t3->right = new TreeNode(7);\n    cout << (solution.isSubtree(s3, t3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1368": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCost(int grid[18][18], int k) {\n        // write your solution here\n    }\n};\n\nint main() {\n    vector<vector<int>> grid1 = {{3, 5}, {1, 2}};\n    cout << \"Test case 1: \" << Solution().minCost(&grid1[0][0], 10) << endl;\n\n    vector<vector<int>> grid2 = {{17, 9, 25, 12}, {14, 7, 23, 16}, {18, 13, 20, 5}, {19, 6, 22, 11}};\n    cout << \"Test case 2: \" << Solution().minCost(&grid2[0][0], 15) << endl;\n\n    vector<vector<int>> grid3 = {{1, 10, 4}, {8, 7, 5}, {9, 6, 3}};\n    cout << \"Test case 3: \" << Solution().minCost(&grid3[0][0], 20) << endl;\n\n    return 0;\n}\n```",
  "1369": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstruct Activity {\n    std::string name;\n    int timestamp;\n};\n\nstd::vector<Activity> getSecondMostRecentActivities(std::vector<Activity>& activities) {\n    if (activities.empty()) return {};\n\n    auto mostRecent = *std::max_element(activities.begin(), activities.end(),\n        [](const auto& a, const auto& b) { return a.timestamp < b.timestamp; });\n\n    auto secondMostRecent = *std::min_element(std::vector<Activity>(activities.begin() + 1, activities.end()),\n        [mostRecent](const auto& a, const auto& b) {\n            if (a.timestamp == mostRecent.timestamp) return true;\n            return a.timestamp > b.timestamp;\n        });\n\n    std::vector<Activity> result;\n    for (auto& activity : activities) {\n        if (activity.timestamp == mostRecent.timestamp || activity.timestamp == secondMostRecent.timestamp)\n            result.push_back(activity);\n    }\n\n    return result;\n}\n\nint main() {\n    // Test case 1\n    std::vector<Activity> activities1 = {{ \"A\", 10 }, { \"B\", 5 }, { \"C\", 15 }};\n    auto result1 = getSecondMostRecentActivities(activities1);\n    for (const auto& activity : result1) {\n        std::cout << activity.name << \" - \" << activity.timestamp << \"\\n\";\n    }\n\n    // Test case 2\n    std::vector<Activity> activities2 = {{ \"D\", 20 }, { \"E\", 10 }, { \"F\", 5 }};\n    auto result2 = getSecondMostRecentActivities(activities2);\n    for (const auto& activity : result2) {\n        std::cout << activity.name << \" - \" << activity.timestamp << \"\\n\";\n    }\n\n    // Test case 3\n    std::vector<Activity> activities3 = {{ \"G\", 25 }, { \"H\", 15 }, { \"I\", 20 }};\n    auto result3 = getSecondMostRecentActivities(activities3);\n    for (const auto& activity : result3) {\n        std::cout << activity.name << \" - \" << activity.timestamp << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "1370": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool isIncreasingDecreasing(string s) {\n    int count[26] = {0};\n    for (int i = 0; i < s.length(); i++) {\n        count[s[i] - 'a']++;\n    }\n    \n    for (int i = 1; i <= 25; i++) {\n        if ((count[i-1] > count[i]) && (count[i+1] > count[i])) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n\nint main() {\n    cout << boolalpha;\n    cout << isIncreasingDecreasing(\"aaa\") << endl; // false\n    cout << isIncreasingDecreasing(\"abcba\") << endl; // true\n    cout << isIncreasingDecreasing(\"abcbca\") << endl; // false\n    return 0;\n}\n```",
  "1371": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findEvenOdd(string s) {\n        int n = s.length();\n        vector<int> count(26, 0);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n                count[s[i] - 'a']++;\n            }\n        }\n        int ans = 0, last = 0;\n        for (int i = 0; i < 26; i++) {\n            if ((count[i] & 1) != (i & 1)) {\n                return last;\n            }\n            last += count[i];\n        }\n        return n;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.findEvenOdd(\"leetcode\") << endl;  // Output: 4\n    cout << solution.findEvenOdd(\"aeiou\") << endl;     // Output: 2\n    cout << solution.findEvenOdd(\"evenodd\") << endl;   // Output: 7\n\n    return 0;\n}\n```",
  "1372": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int longestZigZag(TreeNode* root) {\n        if (!root)\n            return 0;\n        \n        int res = 0;\n        vector<vector<int>> dp({{0, 1}, {1, 0}});\n        function<void(TreeNode*, int, int)> dfs = [&] (TreeNode* node, int left, int right) {\n            if (!node)\n                return;\n            \n            if (left > 0) {\n                res = max(res, right + 1);\n                dp[0][0] = right;\n            } else {\n                res = max(res, left + 1);\n                dp[1][0] = left;\n            }\n            \n            dfs(node->right, right + 1, 0);\n            dfs(node->left, 0, left + 1);\n        };\n        \n        dfs(root, 1, 0);\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->right = new TreeNode(3);\n    root1->left = new TreeNode(2);\n    cout << \"Test Case 1: \" << solution.longestZigZag(root1) << endl; // Output: 3\n\n    // Test Case 2\n    TreeNode* root2 = new TreeNode(4);\n    root2->right = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->left->left = new TreeNode(2);\n    cout << \"Test Case 2: \" << solution.longestZigZag(root2) << endl; // Output: 4\n\n    // Test Case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->right = new TreeNode(1);\n    root3->left = new TreeNode(1);\n    cout << \"Test Case 3: \" << solution.longestZigZag(root3) << endl; // Output: 2\n\n    return 0;\n}\n```",
  "1373": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxSumBST(TreeNode* root) {\n        if (root == NULL) return 0;\n        long l = dfs(root);\n        long r = dfs(root->right);\n        return l + r;\n    }\n\n    long dfs(TreeNode* node) {\n        if (node == NULL) return 0;\n        long res = node->val;\n        res += dfs(node->left);\n        res += dfs(node->right);\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(4);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(7);\n    root1->left->left = new TreeNode(1);\n    root1->left->right = new TreeNode(3);\n    cout << solution.maxSumBST(root1) << endl;  // Output: 15\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(4);\n    root2->right = new TreeNode(8);\n    root2->left->left = new TreeNode(3);\n    root2->left->right = new TreeNode(6);\n    cout << solution.maxSumBST(root2) << endl;  // Output: 18\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(0);\n    root3->right = new TreeNode(1);\n    root3->left->left = new TreeNode(-1);\n    root3->right->left = new TreeNode(5);\n    cout << solution.maxSumBST(root3) << endl;  // Output: 6\n\n    return 0;\n}\n```",
  "1374": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nvoid generateOddCountString(std::vector<std::pair<char, int>>& countMap) {\n    std::string result;\n    for (auto& pair : countMap) {\n        char ch = pair.first;\n        int count = pair.second;\n        while (count > 0) {\n            if (count & 1) {\n                result.push_back(ch);\n            }\n            --count;\n        }\n    }\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::pair<char, int>> test1CountMap = {{'a', 5}, {'b', 3}, {'c', 2}};\n    generateOddCountString(test1CountMap);\n    for (auto& pair : test1CountMap) {\n        char ch = pair.first;\n        int count = pair.second;\n        while (count > 0) {\n            if (count & 1) {\n                std::cout << ch;\n            }\n            --count;\n        }\n        std::cout << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<std::pair<char, int>> test2CountMap = {{'x', 7}, {'y', 1}};\n    generateOddCountString(test2CountMap);\n    for (auto& pair : test2CountMap) {\n        char ch = pair.first;\n        int count = pair.second;\n        while (count > 0) {\n            if (count & 1) {\n                std::cout << ch;\n            }\n            --count;\n        }\n        std::cout << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<std::pair<char, int>> test3CountMap = {{'z', 9}, {'a', 1}};\n    generateOddCountString(test3CountMap);\n    for (auto& pair : test3CountMap) {\n        char ch = pair.first;\n        int count = pair.second;\n        while (count > 0) {\n            if (count & 1) {\n                std::cout << ch;\n            }\n            --count;\n        }\n        std::cout << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1375": "```\n#include <iostream>\n#include <vector>\n\nint prefixCount(std::string s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); i++) {\n        if (i == 0 || s[i] == s[i - 1]) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << prefixCount(\"00\") << std::endl; // Expected output: 1\n    std::cout << \"Test case 2: \" << prefixCount(\"10101\") << std::endl; // Expected output: 5\n    std::cout << \"Test case 3: \" << prefixCount(\"1000101\") << std::endl; // Expected output: 6\n\n    return 0;\n}\n```",
  "1376": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numMinutes(vector<vector<int>>& employees, int employeeID) {\n        if (employeeID == -1) return 0;\n        \n        vector<int> parent = {employees[0][i] for i in range(1)};\n        vector<int> depth({-1} * len(parent));\n        \n        function<void(int)> dfs = [&](int x) {\n            if (x != -1) {\n                depth[x] = depth[parent[x]] + 1;\n                for (y in range(len(parent))):\n                    if (parent[y] == x):\n                        dfs(y)\n            }\n        };\n        dfs(employeeID);\n        \n        int minDepth = maxDepth;\n        for (int i in range(1, len(parent))):\n            if (depth[i] > minDepth): minDepth = depth[i];\n        \n        return minDepth * 5;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test case 1\n    vector<vector<int>> employees1 = {{0,2},{3},{1}};\n    int employeeID1 = 0;\n    cout << \"Test case 1: \" << s.numMinutes(employees1, employeeID1) << endl;\n\n    // Test case 2\n    vector<vector<int>> employees2 = {{0,2},{0,6,5,4},{1},{7},{5,4},{2,3,1}};\n    int employeeID2 = 4;\n    cout << \"Test case 2: \" << s.numMinutes(employees2, employeeID2) << endl;\n\n    // Test case 3\n    vector<vector<int>> employees3 = {{0,2},{0,6,5,4},{1},{7},{5,4},{2,3,1}};\n    int employeeID3 = -1;\n    cout << \"Test case 3: \" << s.numMinutes(employees3, employeeID3) << endl;\n\n    return 0;\n}\n```",
  "1377": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int numTiltingNodes(TreeNode* root, int t) {\n        if (!root)\n            return 0;\n        return dfs(root, t);\n    }\n\nprivate:\n    int dfs(TreeNode* node, int t) {\n        if (!node)\n            return 0;\n        int res = 1;\n        queue<TreeNode*> q;\n        q.push(node);\n\n        while (!q.empty()) {\n            TreeNode* curr = q.front();\n            q.pop();\n\n            if (curr->val % 2 == 1 && t > 0) {\n                res += dfs(curr->left, t - 1);\n                res += dfs(curr->right, t - 1);\n            } else {\n                if (t > 0) {\n                    res += dfs(curr->left, t - 1);\n                    res += dfs(curr->right, t - 1);\n                }\n            }\n\n            q.push(curr->left);\n            q.push(curr->right);\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    cout << \"Test case 1: \" << solution.numTiltingNodes(root1, 0) << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(4);\n    root2->left = new TreeNode(5);\n    root2->right = new TreeNode(6);\n    cout << \"Test case 2: \" << solution.numTiltingNodes(root2, 1) << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(8);\n    root3->left = new TreeNode(9);\n    root3->right = new TreeNode(10);\n    cout << \"Test case 3: \" << solution.numTiltingNodes(root3, 2) << endl;\n\n    return 0;\n}\n```",
  "1378": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Employee {\npublic:\n    std::string id;\n    std::string name;\n\n    Employee(std::string e, std::string n) : id(e), name(n) {}\n};\n\nvoid replaceEmployeeIDWithUniqueIdentifier(std::vector<Employee>& employees) {\n    for (auto& employee : employees) {\n        employee.id = \"employee_\" + employee.id;\n    }\n}\n\nint main() {\n    std::vector<Employee> employees;\n\n    // Test case 1\n    employees.push_back(Employee(\"12345\", \"John\"));\n    replaceEmployeeIDWithUniqueIdentifier(employees);\n    for (const auto& employee : employees) {\n        std::cout << \"Id: \" << employee.id << \", Name: \" << employee.name << std::endl;\n    }\n    \n    // Test case 2\n    employees.clear();\n    employees.push_back(Employee(\"67890\", \"Jane\"));\n    replaceEmployeeIDWithUniqueIdentifier(employees);\n    for (const auto& employee : employees) {\n        std::cout << \"Id: \" << employee.id << \", Name: \" << employee.name << std::endl;\n    }\n\n    // Test case 3\n    employees.clear();\n    employees.push_back(Employee(\"11111\", \"John\"));\n    employees.push_back(Employee(\"22222\", \"Jane\"));\n    replaceEmployeeIDWithUniqueIdentifier(employees);\n    for (const auto& employee : employees) {\n        std::cout << \"Id: \" << employee.id << \", Name: \" << employee.name << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1379": "```\n#include <iostream>\n#include <vector>\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned) {\n    if (!original) return NULL;\n\n    if (original->left && !getTargetCopy(original->left, cloned->left)) return NULL;\n    if (original->right && !getTargetCopy(original->right, cloned->right)) return NULL;\n\n    return cloned;\n}\n\nint main() {\n    TreeNode* root1 = new TreeNode(7);\n    root1->left = new TreeNode(4);\n    root1->right = new TreeNode(3);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(6);\n\n    TreeNode* cloneRoot1 = new TreeNode(7);\n    cloneRoot1->left = new TreeNode(4);\n    cloneRoot1->right = new TreeNode(3);\n    cloneRoot1->left->left = new TreeNode(2);\n    cloneRoot1->left->right = new TreeNode(6);\n\n    TreeNode* root2 = new TreeNode(8);\n    root2->left = new TreeNode(5);\n    root2->right = new TreeNode(9);\n    root2->left->left = new TreeNode(3);\n    root2->left->right = new TreeNode(4);\n    root2->right->left = new TreeNode(7);\n\n    TreeNode* cloneRoot2 = new TreeNode(8);\n    cloneRoot2->left = new TreeNode(5);\n    cloneRoot2->right = new TreeNode(9);\n    cloneRoot2->left->left = new TreeNode(3);\n    cloneRoot2->left->right = new TreeNode(4);\n    cloneRoot2->right->left = new TreeNode(7);\n\n    TreeNode* root3 = NULL;\n\n    TreeNode* cloneRoot3 = NULL;\n\n    TreeNode* result1 = getTargetCopy(root1, cloneRoot1);\n    std::cout << \"Test Case 1: Expected Root Node Val is 4, Got \" << (result1 ? result1->val : -1) << std::endl;\n\n    TreeNode* result2 = getTargetCopy(root2, cloneRoot2);\n    std::cout << \"Test Case 2: Expected Root Node Val is 5, Got \" << (result2 ? result2->val : -1) << std::endl;\n\n    TreeNode* result3 = getTargetCopy(root3, cloneRoot3);\n    std::cout << \"Test Case 3: Expected Root Node Val is -1, Got \" << (result3 ? result3->val : -1) << std::endl;\n\n    return 0;\n}\n```",
  "1380": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> luckyNumbers(const std::vector<std::vector<int>>& matrix) {\n    int m = matrix.size(), n = matrix[0].size();\n    std::vector<bool> rowVisited(m, false);\n    std::vector<bool> colVisited(n, false);\n\n    std::vector<int> result;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            int maxRowVal = -1;\n            for (int k = 0; k < n; ++k) {\n                if (!rowVisited[i] && matrix[i][k] > maxRowVal) {\n                    maxRowVal = matrix[i][k];\n                }\n            }\n\n            int minColVal = INT_MAX;\n            for (int k = 0; k < m; ++k) {\n                if (!colVisited[k] && matrix[k][j] < minColVal) {\n                    minColVal = matrix[k][j];\n                }\n            }\n\n            if (maxRowVal == minColVal) {\n                result.push_back(maxRowVal);\n                rowVisited[i] = colVisited[m - 1] = true;\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix1{{3,7,8},{9,11,10},{19,5,6}};\n    std::cout << \"Matrix 1: \";\n    for (const auto& num : luckyNumbers(matrix1)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> matrix2{{1,10,3},{7,8,9}};\n    std::cout << \"Matrix 2: \";\n    for (const auto& num : luckyNumbers(matrix2)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> matrix3{{7,8},{1,9}};\n    std::cout << \"Matrix 3: \";\n    for (const auto& num : luckyNumbers(matrix3)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1381": "```\n#include <iostream>\n#include <vector>\n\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : max_size(maxSize), stack({}), top(-1) {}\n\n    ~CustomStack() = default;\n\n    void push(int x) {\n        if (top + 1 >= max_size) return;\n        stack.push_back(x);\n        top++;\n    }\n\n    int pop() {\n        if (top < 0) return -1;\n        int val = stack[top--];\n        stack.pop_back();\n        return val;\n    }\n\n    void increment(int k, int val) {\n        for (int i = 0; i < min(k + 1, top + 1); ++i) {\n            stack[i] += val;\n        }\n    }\n\nprivate:\n    int max_size;\n    std::vector<int> stack;\n    int top;\n};\n\nint main() {\n    CustomStack customStack(3);\n\n    // Test case 1: Push and pop elements\n    for (int i = 0; i < 3; ++i) {\n        customStack.push(i);\n    }\n    for (int i = 2; i >= 0; --i) {\n        std::cout << \"Popped element: \" << customStack.pop() << std::endl;\n    }\n\n    // Test case 2: Push and pop elements, then increment some\n    customStack.push(1);\n    customStack.push(2);\n    customStack.increment(1, 3);\n\n    for (int i = 0; i < 2; ++i) {\n        std::cout << \"Popped element: \" << customStack.pop() << std::endl;\n    }\n\n    // Test case 3: Push and pop elements, then increment some\n    customStack.push(1);\n    customStack.push(2);\n    customStack.increment(2, 4);\n\n    for (int i = 0; i < 2; ++i) {\n        std::cout << \"Popped element: \" << customStack.pop() << std::endl;\n    }\n\n    return 0;\n}",
  "1382": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nTreeNode* increasingBST(TreeNode* root, TreeNode** pprev, TreeNode** prev) {\n    if (!root)\n        return nullptr;\n\n    TreeNode* res = increasingBST(root->right, prev, prev);\n    *prev = root;\n    root->left = res;\n    return root;\n}\n\nvoid test() {\n    cout << \"Test 1: \" << endl;\n    {\n        TreeNode* root = new TreeNode(4);\n        root->left = new TreeNode(2);\n        root->right = new TreeNode(6);\n        root->left->left = new TreeNode(1);\n        root->left->right = new TreeNode(3);\n\n        TreeNode* newRoot = increasingBST(root, nullptr, &root);\n        cout << \"New Root: \" << newRoot->val << endl;\n    }\n\n    cout << \"\\nTest 2: \" << endl;\n    {\n        TreeNode* root = new TreeNode(1);\n        TreeNode* newRoot = increasingBST(root, nullptr, &root);\n        cout << \"New Root: \" << newRoot->val << endl;\n    }\n\n    cout << \"\\nTest 3: \" << endl;\n    {\n        TreeNode* root = NULL;\n        TreeNode* newRoot = increasingBST(root, nullptr, &root);\n        cout << \"New Root: \" << newRoot->val << endl;\n    }\n}\n\nint main() {\n    test();\n    return 0;\n}\n```",
  "1383": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxPerformance(int n, vector<int>& speed, vector<int>& efficiency) {\n        vector<pair<int, int>> team(n);\n        for (int i = 0; i < n; ++i) {\n            team[i] = {efficiency[i], speed[i]};\n        }\n        sort(team.begin(), team.end());\n        \n        long long totalSpeed = 0;\n        long long maxEff = 0;\n        int slowestIndex = -1;\n        for (int i = n - 1; i >= 0; --i) {\n            if (totalSpeed + team[i].second > maxEff * speed[slowestIndex]) {\n                totalSpeed += team[i].second;\n                slowestIndex = i;\n            }\n            else break;\n        }\n        \n        return totalSpeed * maxEff;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int n1 = 6;\n    vector<int> speed1 = {2,10,3,1,5,5};\n    vector<int> efficiency1 = {30,350,400,200,500,300};\n    cout << \"Test case 1: \" << solution.maxPerformance(n1, speed1, efficiency1) << endl;\n    \n    int n2 = 4;\n    vector<int> speed2 = {70,800,100,500};\n    vector<int> efficiency2 = {1200,1100,900,700};\n    cout << \"Test case 2: \" << solution.maxPerformance(n2, speed2, efficiency2) << endl;\n\n    int n3 = 1;\n    vector<int> speed3 = {5};\n    vector<int> efficiency3 = {10};\n    cout << \"Test case 3: \" << solution.maxPerformance(n3, speed3, efficiency3) << endl;\n    \n    return 0;\n}\n```",
  "1384": "```\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> totalSalesAmountByYear(vector<vector<string>>& accounts, int transactions) {\n        map<int, map<string, int>> customers;\n        \n        for (int i = 0; i < transactions; i++) {\n            string name, year, type;\n            int amount;\n            \n            cin >> name >> year >> type >> amount;\n            \n            if (type == \"deposit\") {\n                customers[stoi(year)][name] += amount;\n            }\n        }\n        \n        vector<vector<int>> result;\n        \n        for (auto &yearCustomers : customers) {\n            vector<int> row = {yearCustomers.first};\n            for (auto &customer : yearCustomers.second) {\n                row.push_back(customer.second);\n            }\n            result.push_back(row);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int transactions1 = 5;\n    vector<vector<string>> accounts1 = {{\"John\", \"2016-08-01\", \"deposit\", \"100.0\"}, {\"John\", \"2016-09-01\", \"withdrawal\", \"-50.0\"}, {\"Alice\", \"2017-02-01\", \"deposit\", \"200.0\"}, {\"John\", \"2017-03-01\", \"deposit\", \"150.0\"}, {\"Bob\", \"2018-04-01\", \"deposit\", \"500.0\"}};\n    vector<vector<int>> expected1 = {{2016, 50}, {2017, 350}, {2018, 500}};\n    assert(equal(solution.totalSalesAmountByYear(accounts1, transactions1).begin(), solution.totalSalesAmountByYear(accounts1, transactions1).end(), expected1.begin(), expected1.end()));\n\n    // Test case 2\n    int transactions2 = 3;\n    vector<vector<string>> accounts2 = {{\"Alice\", \"2020-01-01\", \"deposit\", \"100.0\"}, {\"Bob\", \"2020-02-01\", \"withdrawal\", \"-50.0\"}, {\"John\", \"2021-03-01\", \"deposit\", \"200.0\"}};\n    vector<vector<int>> expected2 = {{2020, 50}, {2021, 200}};\n    assert(equal(solution.totalSalesAmountByYear(accounts2, transactions2).begin(), solution.totalSalesAmountByYear(accounts2, transactions2).end(), expected2.begin(), expected2.end()));\n\n    // Test case 3\n    int transactions3 = 2;\n    vector<vector<string>> accounts3 = {{\"John\", \"2019-01-01\", \"deposit\", \"100.0\"}, {\"Alice\", \"2021-02-01\", \"withdrawal\", \"-50.0\"}};\n    vector<vector<int>> expected3 = {{2019, 100}, {2021, -50}};\n    assert(equal(solution.totalSalesAmountByYear(accounts3, transactions3).begin(), solution.totalSalesAmountByYear(accounts3, transactions3).end(), expected3.begin(), expected3.end()));\n\n    cout << \"All test cases passed!\" << endl;\n    return 0;\n}\n```",
  "1386": "```\n#include <iostream>\n#include <vector>\n\nint maxCoins(std::vector<std::string>& wants) {\n    int total = 0;\n    for (const auto& s : wants) {\n        total += std::stoi(s);\n    }\n    return total;\n}\n\nint main() {\n    std::vector<std::string> wants1 = {\"10\", \"20\"};\n    std::cout << maxCoins(wants1) << std::endl;\n\n    std::vector<std::string> wants2 = {\"3\", \"5\", \"8\"};\n    std::cout << maxCoins(wants2) << std::endl;\n\n    std::vector<std::string> wants3 = {\"15\", \"20\", \"10\", \"5\"};\n    std::cout << maxCoins(wants3) << std::endl;\n    \n    return 0;\n}\n```",
  "1385": "```\n#include <iostream>\n#include <vector>\n\nint findRadius(std::vector<int>& nums1, std::vector<int>& nums2) {\n    int maxDist = 0;\n    for (int i = 0; i < nums1.size(); i++) {\n        auto it = std::lower_bound(nums2.begin(), nums2.end(), nums1[i]);\n        if (it == nums2.end()) {\n            maxDist = std::max(maxDist, (nums2.size() - 1) - i);\n        } else if (it == nums2.begin()) {\n            maxDist = std::max(maxDist, i);\n        } else {\n            maxDist = std::max(maxDist, std::abs(i - (it - nums2.begin())));\n        }\n    }\n    return maxDist;\n}\n\nint main() {\n    std::vector<int> nums1 = {0, 4, 6, 8, 12};\n    std::vector<int> nums2 = {1, 2, 3, 5, 7, 9, 10};\n    int radius1 = findRadius(nums1, nums2);\n    std::cout << \"Test Case 1: Radius between arrays is \" << radius1 << std::endl;\n\n    nums1 = {0, 6, 8, 12};\n    nums2 = {1, 3, 5, 7, 9, 10};\n    int radius2 = findRadius(nums1, nums2);\n    std::cout << \"Test Case 2: Radius between arrays is \" << radius2 << std::endl;\n\n    nums1 = {0, 1};\n    nums2 = {1, 3};\n    int radius3 = findRadius(nums1, nums2);\n    std::cout << \"Test Case 3: Radius between arrays is \" << radius3 << std::endl;\n    \n    return 0;\n}\n```",
  "1388": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSlices(vector<int>& slices) {\n        int res = 0;\n        for (int i = 0; i < slices.size(); i += 3) {\n            if (i + 2 >= slices.size()) break;\n            res += min(slices[i], min(slices[i+1], slices[i+2]));\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> test1 = {3,6,7,10};\n    cout << \"Test 1: \" << solution.numSlices(test1) << endl; // Output: 12\n\n    vector<int> test2 = {11,13,20,15,10,5,16,8};\n    cout << \"Test 2: \" << solution.numSlices(test2) << endl; // Output: 24\n\n    vector<int> test3 = {1,4,6,10,7,40};\n    cout << \"Test 3: \" << solution.numSlices(test3) << endl; // Output: 16\n\n    return 0;\n}\n```",
  "1387": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> getPower(int n) {\n        vector<vector<int>> res;\n        for (int i = 0; i <= 9; i++) {\n            int num = 1;\n            while (n >= i) {\n                res.push_back({i, num});\n                num *= 10;\n            }\n        }\n        return res;\n    }\n\n    vector<int> modifiedArray(int n, vector<vector<int>>& expressions) {\n        sort(expressions.begin(), expressions.end());\n        for (int i = 0; i < expressions.size(); i++) {\n            for (int j = i + 1; j < expressions.size(); j++) {\n                if (expressions[i][1] == expressions[j][1]) {\n                    expressions.erase(expressions.begin() + j);\n                    j--;\n                }\n            }\n        }\n        return vector<int>(n, 0);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1:\n    int n = 3;\n    vector<vector<int>> expressions = {{2, 1}, {4, 3}, {5, 1}};\n    vector<int> res = solution.modifiedArray(n, expressions);\n    for (auto x : res) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2:\n    n = 5;\n    expressions = {{3, 4}, {5, 6}, {7, 8}, {9, 10}};\n    res = solution.modifiedArray(n, expressions);\n    for (auto x : res) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3:\n    n = 2;\n    expressions = {{1, 2}, {4, 5}};\n    res = solution.modifiedArray(n, expressions);\n    for (auto x : res) {\n        cout << x << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1389": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> createTargetArray(std::vector<int>& nums, std::vector<int>& targetIndex) {\n    std::vector<int> res;\n    for (int i = 0; i < nums.size(); ++i) {\n        res.push_back(nums[targetIndex[i]]);\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {0, 1, 2, 3, 4};\n    std::vector<int> targetIndex1 = {0, 1, 2, 2, 1};\n    std::cout << \"[\";\n    for (int i : createTargetArray(nums1, targetIndex1)) {\n        std::cout << i << \" \";\n    }\n    std::cout << \"]\" << std::endl;\n\n    std::vector<int> nums2 = {1, 2, 3, 4, 5};\n    std::vector<int> targetIndex2 = {0, 1, 2, 3, 4};\n    std::cout << \"[\";\n    for (int i : createTargetArray(nums2, targetIndex2)) {\n        std::cout << i << \" \";\n    }\n    std::cout << \"]\" << std::endl;\n\n    std::vector<int> nums3 = {1};\n    std::vector<int> targetIndex3 = {0};\n    std::cout << \"[\";\n    for (int i : createTargetArray(nums3, targetIndex3)) {\n        std::cout << i << \" \";\n    }\n    std::cout << \"]\" << std::endl;\n    \n    return 0;\n}",
  "1390": "```\n#include <iostream>\n#include <vector>\n\nbool hasFourDivisors(int num) {\n    int count = 0;\n    for (int i = 1; i * i <= num; i++) {\n        if (num % i == 0) {\n            int j = num / i;\n            if (i * i == j || j * j == i) continue;\n            count += 2;\n        }\n    }\n    return count >= 4;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << (hasFourDivisors(25) ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 2: \" << (hasFourDivisors(10) ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 3: \" << (hasFourDivisors(7) ? \"Pass\" : \"Fail\") << std::endl;\n    return 0;\n}\n```",
  "1392": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestHappyPrefix(string s) {\n        int n = s.size();\n        for (int i = 0; i < n; i++) {\n            int j = i;\n            while (j + 1 <= n && s[j] == s[i]) {\n                j++;\n            }\n            if (isHappy(s.substr(0, j))) {\n                return s.substr(0, j);\n            }\n        }\n        return \"\";\n    }\n\n    bool isHappy(string s) {\n        int n = s.size();\n        for (int i = 0; i < n / 2; i++) {\n            if (s[i] != s[n - i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.longestHappyPrefix(\"abcdef\") << endl;\n    cout << solution.longestHappyPrefix(\"a\") << endl;\n    cout << solution.longestHappyPrefix(\"abca\") << endl;\n    return 0;\n}\n```",
  "1391": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    if (!dfs(grid, visited, i, j)) return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    bool dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {\n        int m = grid.size(), n = grid[0].size();\n        if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) return true;\n        visited[x][y] = true;\n        if (grid[x][y] == 1) {\n            for (int i = -1; i <= 1; ++i) {\n                for (int j = -1; j <= 1; ++j) {\n                    int nx = x + i, ny = y + j;\n                    if ((i || j) && (0 <= nx && nx < m) && (0 <= ny && ny < n) && grid[nx][ny] == 2) return dfs(grid, visited, nx, ny);\n                }\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> grid1 = {{0,0,1},{0,0,1},{0,0,0}};\n    cout << (solution.hasValidPath(grid1) ? \"true\" : \"false\") << endl;  // Output: true\n\n    // Test case 2\n    vector<vector<int>> grid2 = {{0,1},{1,0}};\n    cout << (solution.hasValidPath(grid2) ? \"true\" : \"false\") << endl;  // Output: false\n\n    // Test case 3\n    vector<vector<int>> grid3 = {{0,0,0},{1,1,0},{1,1,0}};\n    cout << (solution.hasValidPath(grid3) ? \"true\" : \"false\") << endl;  // Output: true\n\n    return 0;\n}\n```",
  "1393": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    double calculateCapitalGainLoss(std::vector<std::pair<int, int>>& transactions) {\n        double totalProfit = 0;\n        for (int i = 1; i < transactions.size(); ++i) {\n            if (transactions[i].first > transactions[i-1].second) {\n                totalProfit += (double)(transactions[i].first - transactions[i-1].second);\n            } else if (transactions[i].second < transactions[i-1].first) {\n                totalProfit -= (double)(transactions[i-1].first - transactions[i].second);\n            }\n        }\n        return totalProfit;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::pair<int, int>> test1 = {{100, 50}, {30, 70}};\n    double result1 = solution.calculateCapitalGainLoss(test1);\n    if (result1 != 40.0) {\n        std::cout << \"Test Case 1 failed: expected 40.0 but got \" << result1 << std::endl;\n        return 1;\n    }\n\n    // Test Case 2\n    std::vector<std::pair<int, int>> test2 = {{10, 20}, {30, 40}};\n    double result2 = solution.calculateCapitalGainLoss(test2);\n    if (result2 != -10.0) {\n        std::cout << \"Test Case 2 failed: expected -10.0 but got \" << result2 << std::endl;\n        return 1;\n    }\n\n    // Test Case 3\n    std::vector<std::pair<int, int>> test3 = {{100, 50}, {80, 60}, {70, 90}};\n    double result3 = solution.calculateCapitalGainLoss(test3);\n    if (result3 != -20.0) {\n        std::cout << \"Test Case 3 failed: expected -20.0 but got \" << result3 << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed.\" << std::endl;\n    return 0;\n}\n```",
  "1394": "```\n#include <iostream>\n#include <vector>\n\nint findLucky(const std::vector<int>& arr) {\n    std::vector<int> count(201, 0);\n    for (int num : arr) {\n        count[num]++;\n    }\n    \n    int lucky = -1;\n    for (int i = 100; i >= 1; i--) {\n        if (count[i] > 0 && i == count[i]) {\n            lucky = i;\n            break;\n        }\n    }\n    \n    return lucky;\n}\n\nint main() {\n    std::vector<int> arr1 = {2,7,13,23,202};\n    std::cout << \"Test case 1: \" << findLucky(arr1) << std::endl; // Output: 23\n\n    std::vector<int> arr2 = {4,8,15,16,23,42};\n    std::cout << \"Test case 2: \" << findLucky(arr2) << std::endl; // Output: 23\n\n    std::vector<int> arr3 = {2,7,13,14,22};\n    std::cout << \"Test case 3: \" << findLucky(arr3) << std::endl; // Output: -1\n\n    return 0;\n}\n```",
  "1395": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numTeams(vector<int>& preference) {\n        int n = preference.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        \n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if ((preference[i] - preference[j]) * (preference[i] - preference[j]) <= 9) \n                    dp[i][j] = 1;\n        \n        int res = 0;\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j) \n                if (dp[i][j]) \n                    res += (preference[j] - preference[i]);\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test case 1\n    vector<int> test1 = {2,5,3};\n    cout << \"Test case 1: \" << s.numTeams(test1) << endl; \n\n    // Test case 2\n    vector<int> test2 = {6,4,10};\n    cout << \"Test case 2: \" << s.numTeams(test2) << endl;\n\n    // Test case 3\n    vector<int> test3 = {1,4,9};\n    cout << \"Test case 3: \" << s.numTeams(test3) << endl;\n\n    return 0;\n}\n```",
  "1396": "```\n#include <iostream>\n#include <unordered_map>\n\nclass UndergroundSystem {\npublic:\n    unordered_map<string, pair<double, double>> idToTrip;\n    unordered_map<string, pair<double, double>> fromToAvg;\n\n    void checkIn(int id, string stationName, int t) {\n        idToTrip[string(to_string(id)) + \"_\" + stationName] = {0.0, (double)t};\n    }\n\n    void checkOut(int id, string stationName, int t) {\n        pair<string, double> inKey = make_pair(string(to_string(id)) + \"_\" + idToTrip.begin()->first.substr(1), 0.0);\n        pair<string, double> outKey = make_pair(string(to_string(id)) + \"_\" + stationName, (double)t);\n\n        pair<double, double>& from = idToTrip[inKey.first];\n        pair<double, double>& to = idToTrip[outKey.first];\n\n        from.first += t - from.second;\n        from.second = t;\n\n        to.first += to.second;\n        to.second = 0.0;\n\n        if (idToTrip.find(inKey.first) == idToTrip.end()) {\n            idToTrip[inKey.first] = from;\n        }\n        if (idToTrip.find(outKey.first) == idToTrip.end()) {\n            idToTrip[outKey.first] = to;\n        }\n\n        pair<string, double> key1 = make_pair(\"From_\" + idToTrip.begin()->first.substr(1), 0.0);\n        pair<string, double> key2 = make_pair(\"To_\" + stationName, (double)t);\n\n        if (fromToAvg.find(key1.first) == fromToAvg.end()) {\n            fromToAvg[key1.first] = {0.0, 0.0};\n        }\n        if (fromToAvg.find(key2.first) == fromToAvg.end()) {\n            fromToAvg[key2.first] = {0.0, 0.0};\n        }\n\n        pair<double, double>& avgFrom = fromToAvg[key1.first];\n        pair<double, double>& avgTo = fromToAvg[key2.first];\n\n        avgFrom.first += t - avgFrom.second;\n        avgFrom.second = t;\n\n        avgTo.first += avgTo.second;\n        avgTo.second = 0.0;\n    }\n\n    vector<vector<int>> getAverageTime(string start, string end) {\n        pair<string, double> inKey = make_pair(\"From_\" + start, 0.0);\n        pair<string, double> outKey = make_pair(\"To_\" + end, (double)0);\n\n        pair<double, double>& from = fromToAvg[inKey.first];\n        pair<double, double>& to = fromToAvg[outKey.first];\n\n        return {{from.second / from.first, to.second / to.first}};\n    }\n};\n\nint main() {\n    UndergroundSystem us;\n\n    us.checkIn(45, \"Newark Penn Station\", 3);\n    us.checkOut(45, \"Rahway\", 11);\n\n    vector<vector<int>> res1 = us.getAverageTime(\"Newark Penn Station\", \"Rahway\");\n    for (int i : res1[0]) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    us.checkIn(102, \"Los Angeles\", 0);\n    us.checkOut(102, \"Laguna Hills\", 5);\n\n    vector<vector<int>> res2 = us.getAverageTime(\"Los Angeles\", \"Laguna Hills\");\n    for (int i : res2[0]) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    us.checkIn(103, \"Newark Penn Station\", 10);\n    us.checkOut(103, \"Rahway\", 20);\n\n    vector<vector<int>> res3 = us.getAverageTime(\"Newark Penn Station\", \"Rahway\");\n    for (int i : res3[0]) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1397": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> camenderMatch(vector<string>& words, string pattern) {\n        vector<string> res;\n        int n = words.size();\n        for (int i = 0; i < n; i++) {\n            if (match(words[i], pattern)) {\n                res.push_back(words[i]);\n            }\n        }\n        return res;\n    }\n\n    bool match(string s, string p) {\n        int m = s.length(), n = p.length();\n        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n        dp[0][0] = true;\n\n        for (int i = 1; i <= m; i++) {\n            dp[i][0] = (s[i - 1] == p[0]) && dp[i - 1][0];\n        }\n\n        for (int j = 1; j <= n; j++) {\n            dp[0][j] = (p[j - 1] == '*') ? dp[0][j - 1] : false;\n        }\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if ((s[i - 1] == p[j - 1]) || (p[j - 1] == '.')) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (p[j - 1] == '*') {\n                    dp[i][j] = dp[i][j - 1] || ((s[i - 1] == p[0]) && dp[i - 1][j]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> words1 = {\"abc\", \"bcd\", \"acef\", \"xyz\", \"az\", \"ba\", \"a\"};\n    string pattern1 = \"a.c*\";\n    vector<string> res1 = solution.camenderMatch(words1, pattern1);\n    for (auto str : res1) {\n        cout << str << endl;\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<string> words2 = {\"dog\", \"cat\", \"fish\"};\n    string pattern2 = \".*\";\n    vector<string> res2 = solution.camenderMatch(words2, pattern2);\n    for (auto str : res2) {\n        cout << str << endl;\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<string> words3 = {\"abc\", \"abcd\", \"abcde\"};\n    string pattern3 = \".*c*e\";\n    vector<string> res3 = solution.camenderMatch(words3, pattern3);\n    for (auto str : res3) {\n        cout << str << endl;\n    }\n    return 0;\n}\n```",
  "1398": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> customersWhoBoughtProductsAandNotC(vector<vector<string>>& products) {\n        unordered_map<string, set<string>> productCustomers;\n        for (const auto& product : products) {\n            for (const auto& customer : product) {\n                productCustomers[customer].insert(product[0]);\n            }\n        }\n\n        vector<string> result;\n        for (const auto& pair : productCustomers) {\n            if (pair.second.count(\"A\") && !pair.second.count(\"C\")) {\n                result.push_back(pair.first);\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> products1 = {{\"John\", \"A\"}, {\"Jane\", \"B\"}, {\"Bob\", \"A\"}, {\"Alice\", \"C\"}};\n    vector<string> expected1 = {\"John\", \"Bob\"};\n    vector<string> result1 = solution.customersWhoBoughtProductsAandNotC(products1);\n    if (result1 != expected1) {\n        cout << \"Test Case 1 failed\" << endl;\n        return 0;\n    }\n\n    // Test Case 2\n    vector<vector<string>> products2 = {{\"John\", \"A\"}, {\"Jane\", \"B\"}, {\"Bob\", \"C\"}};\n    vector<string> expected2 = {};\n    vector<string> result2 = solution.customersWhoBoughtProductsAandNotC(products2);\n    if (result2 != expected2) {\n        cout << \"Test Case 2 failed\" << endl;\n        return 0;\n    }\n\n    // Test Case 3\n    vector<vector<string>> products3 = {{\"John\", \"A\"}, {\"Jane\", \"B\"}, {\"Bob\", \"A\"}, {\"Alice\", \"A\"}, {\"Bob\", \"C\"}};\n    vector<string> expected3 = {\"John\", \"Jane\", \"Bob\"};\n    vector<string> result3 = solution.customersWhoBoughtProductsAandNotC(products3);\n    if (result3 != expected3) {\n        cout << \"Test Case 3 failed\" << endl;\n        return 0;\n    }\n\n    cout << \"All test cases passed\" << endl;\n\n    return 0;\n}\n```",
  "1399": "```\n#include <iostream>\n#include <unordered_map>\n\nint countLargestGroup(int n) {\n    int maxCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        std::string str = std::to_string(i);\n        std::unordered_map<char, int> countMap;\n        for (char c : str) {\n            countMap[c]++;\n        }\n        int curCount = 0;\n        bool isSame = true;\n        for (auto& pair : countMap) {\n            if (pair.second > 1) {\n                isSame = false;\n                break;\n            }\n            curCount += pair.second;\n        }\n        maxCount = std::max(maxCount, curCount);\n    }\n    return maxCount;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << countLargestGroup(2) << std::endl; // Output: 1\n    std::cout << \"Test Case 2: \" << countLargestGroup(3) << std::endl; // Output: 2\n    std::cout << \"Test Case 3: \" << countLargestGroup(4) << std::endl; // Output: 3\n    return 0;\n}\n```",
  "1400": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<std::string> generatePalindromes(signed int N) {\n        // Your implementation here.\n        // This is just a placeholder to demonstrate the return type and function name.\n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::vector<std::string> result1 = solution.generatePalindromes(1);\n    for (const auto& s : result1) {\n        std::cout << \"Test Case 1: \" << s << std::endl;\n    }\n\n    std::vector<std::string> result2 = solution.generatePalindromes(3);\n    for (const auto& s : result2) {\n        std::cout << \"Test Case 2: \" << s << std::endl;\n    }\n\n    std::vector<std::string> result3 = solution.generatePalindromes(4);\n    for (const auto& s : result3) {\n        std::cout << \"Test Case 3: \" << s << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "1401": "```\n#include <iostream>\nusing namespace std;\n\nstruct Point {\n    int x;\n    int y;\n};\n\nclass Solution {\npublic:\n    bool isOverlapped(Point circleCenter, int radius, Point rectTopLeft, Point rectBottomRight) {\n        // Calculate the distance between the center of the circle and the top-left corner of the rectangle\n        int dx = abs(circleCenter.x - rectTopLeft.x);\n        int dy = abs(circleCenter.y - rectTopLeft.y);\n\n        if (dx > radius || dy > radius) {\n            return false;\n        }\n\n        // Calculate the distance between the center of the circle and the bottom-right corner of the rectangle\n        dx = abs(circleCenter.x - rectBottomRight.x);\n        dy = abs(circleCenter.y - rectBottomRight.y);\n\n        if (dx > radius || dy > radius) {\n            return false;\n        }\n\n        // If both distances are less than or equal to the radius, then they overlap\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    Point circleCenter = {0, 0};\n    int radius = 2;\n    Point rectTopLeft = {-1, -1};\n    Point rectBottomRight = {1, 1};\n    cout << (solution.isOverlapped(circleCenter, radius, rectTopLeft, rectBottomRight) ? \"true\" : \"false\") << endl;\n\n    circleCenter.x = 2;\n    circleCenter.y = 2;\n    radius = 3;\n    rectTopLeft.x = -4;\n    rectTopLeft.y = -2;\n    rectBottomRight.x = 1;\n    rectBottomRight.y = 0;\n    cout << (solution.isOverlapped(circleCenter, radius, rectTopLeft, rectBottomRight) ? \"true\" : \"false\") << endl;\n\n    circleCenter.x = 5;\n    circleCenter.y = 3;\n    radius = 2;\n    rectTopLeft.x = -6;\n    rectTopLeft.y = -1;\n    rectBottomRight.x = 0;\n    rectBottomRight.y = 4;\n    cout << (solution.isOverlapped(circleCenter, radius, rectTopLeft, rectBottomRight) ? \"true\" : \"false\") << endl;\n\n    return 0;\n}\n```",
  "1402": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint totalArea = 0;\n\nclass Solution {\npublic:\n    int maxTraps(int height[]) {\n        int n = height.size();\n        std::vector<int> leftMax(n);\n        std::vector<int> rightMax(n);\n        \n        leftMax[0] = height[0];\n        for (int i = 1; i < n; i++) {\n            leftMax[i] = std::max(leftMax[i-1], height[i]);\n        }\n        \n        rightMax[n-1] = height[n-1];\n        for (int i = n-2; i >= 0; i--) {\n            rightMax[i] = std::max(rightMax[i+1], height[i]);\n        }\n        \n        int waterTrapped = 0;\n        for (int i = 0; i < n; i++) {\n            waterTrapped += (std::min(leftMax[i], rightMax[i]) - height[i]);\n        }\n        \n        totalArea = waterTrapped;\n        return waterTrapped;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int height[] = {2,1,1,5};\n    std::cout << \"Test case 1: \" << solution.maxTraps(height) << std::endl; // Expected output: 6\n\n    int height2[] = {4,2,0,3,2,5};\n    std::cout << \"Test case 2: \" << solution.maxTraps(height2) << std::endl; // Expected output: 9\n\n    int height3[] = {1,7,5,9,2,1,3};\n    std::cout << \"Test case 3: \" << solution.maxTraps(height3) << std::endl; // Expected output: 10\n\n    return 0;\n}\n```",
  "1403": "```\n#include <iostream>\n#include <vector>\n\nint minSubsequence(std::vector<int>& nums) {\n    int total = 0;\n    for (int num : nums) {\n        total += num;\n    }\n    \n    std::sort(nums.begin(), nums.end(), [](int a, int b){ return a >= b; });\n    \n    int res = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        if ((total - res) % (nums[i] + 1) == 0) {\n            res += nums[i];\n        } else {\n            break;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {4, 3, 10, 2, 8};\n    std::cout << \"Test case 1: \" << minSubsequence(test1) << std::endl;\n\n    std::vector<int> test2 = {5, 5, 6];\n    std::cout << \"Test case 2: \" << minSubsequence(test2) << std::endl;\n\n    std::vector<int> test3 = [10, 8, 5, 7, 9];\n    std::cout << \"Test case 3: \" << minSubsequence(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1404": "```\n#include <iostream>\n#include <string>\n\nint countSteps(std::string num) {\n    int steps = 0;\n    while (num != \"1\") {\n        if (num.back() == '1') {\n            num.pop_back();\n        } else {\n            int i = num.find('1');\n            num.erase(i, 1);\n            steps++;\n        }\n    }\n    return steps;\n}\n\nint main() {\n    std::cout << countSteps(\"0\") << std::endl; // Expected output: 0\n    std::cout << countSteps(\"100\") << std::endl; // Expected output: 2\n    std::cout << countSteps(\"11010\") << std::endl; // Expected output: 3\n\n    return 0;\n}\n```",
  "1405": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestDiverseString(string s) {\n        int n = s.length();\n        priority_queue<int> p;\n        for(int i=0; i<n; i++){\n            p.push((int)s[i]);\n        }\n        char lastChar = ' ';\n        string res = \"\";\n        while(p.size() > 2){\n            int a = p.top(); p.pop();\n            res += (char)a;\n            if(a-1 != lastChar && a+1 != lastChar){\n                p.push(a-1);\n                p.push(a+1);\n                lastChar = (a>='a' && a<='z') ? (char)(a + 1) : (char)(a - 1);\n            }\n            else if(a-1 != lastChar){\n                p.push(a-1);\n                lastChar = (char)(a - 1);\n            }\n            else if(a+1 != lastChar){\n                p.push(a+1);\n                lastChar = (char)(a + 1);\n            }\n        }\n        \n        int remain = p.size();\n        for(int i=0; i<remain; i++){\n            res += (char)p.top(); p.pop();\n        }\n        if(res.length() < n){\n            if(lastChar > 'z' || lastChar < 'a'){\n                while(p.size()){\n                    res += (char)p.top(); p.pop();\n                }\n                return res;\n            }\n            else{\n                int a = p.top(); p.pop();\n                int b = p.top(); p.pop();\n                if(a<lastChar && a+1 != lastChar){\n                    res += (char)(a + 1);\n                    p.push((int)'z');\n                    while(p.size()){\n                        res += (char)p.top(); p.pop();\n                    }\n                    return res;\n                }\n                else{\n                    res += (char)a; res += (char)b;\n                    p.push((int)'z');\n                    while(p.size()){\n                        res += (char)p.top(); p.pop();\n                    }\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n    cout << solution.longestDiverseString(\"aba\") << endl; // \"cdn\"\n    cout << solution.longestDiverseString(\"leetcode\") << endl; // \"lceou\"\n    cout << solution.longestDiverseString(\"vov\") << endl; // \"vov\"\n    return 0;\n}\n```",
  "1406": "```\n#include <iostream>\n#include <vector>\n\nint stoneGameIII(std::vector<int>& pile) {\n    int n = pile.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n    \n    for (int i = 0; i < n; ++i) {\n        if (i > 0) {\n            for (int j = 0; j <= i; ++j) {\n                if (j > 0) {\n                    dp[i][j] = std::max(dp[i-1][j-1] + pile[i-j], dp[i-1][j] - pile[i-1]);\n                } else {\n                    dp[i][j] = pile[i];\n                }\n            }\n        }\n    }\n    \n    return dp[n-1][0];\n}\n\nint main() {\n    std::vector<int> pile1 = {5, 3, 4, 2};\n    std::cout << \"Test case 1: \" << stoneGameIII(pile1) << std::endl;\n    \n    std::vector<int> pile2 = {1, 2, 3, 1, 2, 1, 2, 1};\n    std::cout << \"Test case 2: \" << stoneGameIII(pile2) << std::endl;\n    \n    std::vector<int> pile3 = {10};\n    std::cout << \"Test case 3: \" << stoneGameIII(pile3) << std::endl;\n    \n    return 0;\n}\n```",
  "1407": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass TopTravelers {\npublic:\n    vector<string> findTopTravelers(vector<vector<int>>& idBaggagePairs) {\n        map<int, int> baggageCounts;\n        for (const auto& pair : idBaggagePairs) {\n            baggageCounts[pair[0]] += pair[1];\n        }\n        \n        priority_queue<pair<int, string>> pq;\n        for (const auto& person : baggageCounts) {\n            pq.push({person.second, to_string(person.first)});\n        }\n        \n        vector<string> result;\n        while (!pq.empty()) {\n            result.push_back(pq.top().second);\n            pq.pop();\n        }\n        return result;\n    }\n};\n\nint main() {\n    TopTravelers topTravelers;\n\n    // Test case 1\n    vector<vector<int>> test1 = {{1, 2}, {2, 3}, {3, 4}};\n    vector<string> expected1 = {\"1\", \"2\"};\n    vector<string> result1 = topTravelers.findTopTravelers(test1);\n    if (result1 != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n    } else {\n        cout << \"Test case 1 passed.\" << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> test2 = {{1, 5}, {2, 3}, {4, 7}};\n    vector<string> expected2 = {\"1\"};\n    vector<string> result2 = topTravelers.findTopTravelers(test2);\n    if (result2 != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n    } else {\n        cout << \"Test case 2 passed.\" << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> test3 = {{1, 4}, {2, 3}, {3, 5}};\n    vector<string> expected3 = {\"1\", \"3\"};\n    vector<string> result3 = topTravelers.findTopTravelers(test3);\n    if (result3 != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n    } else {\n        cout << \"Test case 3 passed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1408": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint countMatches(std::vector<std::vector<std::string>>& items, char target, int attribute) {\n    int count = 0;\n    for (const auto& item : items) {\n        if ((attribute == 0 && item[0] == std::to_string(target)) ||\n            (attribute == 1 && item[1] == std::to_string(target)) ||\n            (attribute == 2 && item[2] == std::to_string(target))) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::vector<std::vector<std::string>> items = {{\"shirt\", \"blue\", \"red\"}, {\"dress\", \"white\", \"black\"}, {\"socks\", \"green\", \"pink\"}};\n    \n    // Test case 1\n    char target1 = 'b';\n    int attribute1 = 1;\n    std::cout << \"Count of matches for target '\" << target1 << \"' and attribute \" << attribute1 << \": \" << countMatches(items, target1, attribute1) << std::endl;\n\n    // Test case 2\n    char target2 = 'r';\n    int attribute2 = 0;\n    std::cout << \"Count of matches for target '\" << target2 << \"' and attribute \" << attribute2 << \": \" << countMatches(items, target2, attribute2) << std::endl;\n\n    // Test case 3\n    char target3 = 'p';\n    int attribute3 = 2;\n    std::cout << \"Count of matches for target '\" << target3 << \"' and attribute \" << attribute3 << \": \" << countMatches(items, target3, attribute3) << std::endl;\n\n    return 0;\n}",
  "1409": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> processQueries(vector<int>& queries, int m) {\n        vector<int> res;\n        for (int query : queries) {\n            int pos = upper_bound(res.begin(), res.end(), query) - res.begin();\n            if (pos == res.size()) {\n                res.push_back(query);\n            } else {\n                res.insert(res.begin() + pos, query);\n            }\n            res.push_back(m--);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> queries1 = {7,5};\n    int m1 = 3;\n    vector<int> result1 = solution.processQueries(queries1, m1);\n    for (int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<int> queries2 = {1,5};\n    int m2 = 4;\n    vector<int> result2 = solution.processQueries(queries2, m2);\n    for (int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<int> queries3 = {1,5,8};\n    int m3 = 3;\n    vector<int> result3 = solution.processQueries(queries3, m3);\n    for (int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1410": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    std::string parseTernary(int num) {\n        if (num == 0) return \"0\";\n        if (num == 1) return \"1\";\n        if (num == -2) return \"2\";\n        if (num == -1) return \"-1\";\n        \n        std::unordered_map<int, std::string> map = {{3, \"3\"}, {4, \"4\"}, {5, \"5\"},\n            {-3, \"for\", -2, \"to\", -1, \"get\", 0, \"0\",\n            1, \"1\", 2, \"2\", 27, \"twenty-seven\", 26, \"twenty-six\", \n            25, \"twenty-five\", 24, \"twenty-four\", 23, \"twenty-three\", \n            22, \"twenty-two\", 21, \"twenty-one\", 20, \"twenty\", \n            19, \"nineteen\", 18, \"eighteen\", 17, \"seventeen\", 16, \"sixteen\",\n            15, \"fifteen\", 14, \"fourteen\", 13, \"thirteen\", 12, \"twelve\", \n            11, \"eleven\", 10, \"ten\", 9, \"nine\", 8, \"eight\", 7, \"seven\", \n            6, \"six\", 5, \"five\", 4, \"four\", 3, \"three\", 2, \"two\", 1, \"one\"};\n        \n        if (num > 0) {\n            if (num >= 100) {\n                return map[num / 100] + \" hundred\" \n                    + (num % 100 ? \" and \" : \"\") \n                    + parseTernary(num % 100);\n            } else if (num >= 20) {\n                return map[num];\n            } else {\n                return map[num];\n            }\n        } else {\n            if (num == -0) return \"0\";\n            if (num > -10) {\n                return \"-\" + parseTernary(-num);\n            } else {\n                return \"- \" + parseTernary(-num);\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::cout << solution.parseTernary(123) << std::endl; // Expected: one hundred and twenty three\n    std::cout << solution.parseTernary(-12) << std::endl; // Expected: negative twelve\n    std::cout << solution.parseTernary(0) << std::endl; // Expected: 0\n    \n    return 0;\n}\n```",
  "1411": "```\n#include <iostream>\n#include <vector>\n\nint numWays(int n) {\n    if (n == 1) return 3;\n    if (n == 2) return 9;\n\n    int mod = 1000000007;\n    std::vector<int> dp(n + 1);\n    dp[0] = 1;\n    dp[1] = 3;\n\n    for (int i = 2; i <= n; i++) {\n        dp[i] = (dp[i - 1] * 3) % mod;\n    }\n\n    return dp[n];\n}\n\nint main() {\n    std::cout << numWays(1) << std::endl; // Output: 3\n    std::cout << numWays(2) << std::endl; // Output: 9\n    std::cout << numWays(4) << std::endl; // Output: 270\n\n    return 0;\n}\n```",
  "1412": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findQuietStudents(vector<vector<string>>& exams) {\n        int quietCount = 0;\n        for (int i = 0; i < exams.size(); i++) {\n            for (const auto& exam : exams[i]) {\n                if (!exam.empty()) {\n                    quietCount = 0;\n                    break;\n                }\n                quietCount++;\n            }\n            if (quietCount == exams[i].size()) {\n                return vector<int>(1, i);\n            }\n        }\n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> exams1 = {{\"John\", \"Alice\", \"\"}, {\"Bob\", \"\", \"Charlie\"}};\n    cout << \"[\";\n    for (const auto& quietStudent : solution.findQuietStudents(exams1)) {\n        cout << quietStudent << \" \";\n    }\n    cout << \"]\" << endl;\n\n    // Test case 2\n    vector<vector<string>> exams2 = {{\"Alice\", \"\"}, {\"Bob\", \"\", \"Charlie\"}, {\"John\", \"\", \"\"}};\n    cout << \"[\";\n    for (const auto& quietStudent : solution.findQuietStudents(exams2)) {\n        cout << quietStudent << \" \";\n    }\n    cout << \"]\" << endl;\n\n    // Test case 3\n    vector<vector<string>> exams3 = {{\"Alice\", \"\", \"Bob\"}, {\"John\", \"\"}, {\"Charlie\", \"\", \"David\"}};\n    cout << \"[\";\n    for (const auto& quietStudent : solution.findQuietStudents(exams3)) {\n        cout << quietStudent << \" \";\n    }\n    cout << \"]\" << endl;\n\n    return 0;\n}\n```",
  "1413": "```\n#include <iostream>\n#include <vector>\n\nint minStartValue(std::vector<int>& arr) {\n    int total = 0;\n    for (int num : arr) {\n        total += num;\n    }\n    \n    if (total > 0) return 1;\n    \n    int start = 1;\n    while (true) {\n        total -= start;\n        if (total <= 0) break;\n        start++;\n    }\n    \n    return start;\n}\n\nint main() {\n    std::vector<int> arr1 = { -3,2,-1,4,-2,5 };\n    std::cout << minStartValue(arr1) << std::endl; // prints: 6\n\n    std::vector<int> arr2 = { -10,1,3,1,-4,7,2,-9 };\n    std::cout << minStartValue(arr2) << std::endl; // prints: 7\n\n    std::vector<int> arr3 = [1,4,3];\n    std::cout << minStartValue(arr3) << std::endl; // prints: 10\n}\n```",
  "1414": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMinFibonacciSum(int K) {\n        if (K == 0) return 0;\n        int n = 1, m = 1;\n        while (true) {\n            int next = n + m;\n            if (next >= K) break;\n            n = m;\n            m = next;\n        }\n        int ret = 1;\n        for (int i = 2; ; i++) {\n            if ((K - m) * (i + 1) <= m) {\n                ret += i;\n                break;\n            }\n            K -= m;\n            ret++;\n            m = n + m;\n            n = m;\n        }\n        return ret;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.findMinFibonacciSum(7) << endl; // Output: 2\n    cout << solution.findMinFibonacciSum(10) << endl; // Output: 3\n    cout << solution.findMinFibbonaciSum(19) << endl; // Output: 5\n    return 0;\n}",
  "1415": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string getHappyString(int n, int k) {\n    std::vector<std::string> happyStrings;\n    \n    for (int i = 1; i <= n; i++) {\n        for (char c = 'a'; c <= 'c'; c++) {\n            if (i == 1 || c > (happyStrings.back().back() - 'a' + 1) % 3) {\n                happyStrings.push_back(std::string(1, c));\n                for (int j = i + 1; j <= n; j++) {\n                    if (j % 2 == 0 && j != n) {\n                        happyStrings.back() += 'b';\n                    } else {\n                        happyStrings.back() += ('a' + (happyStrings.back().back() - 'a' + 1) % 3);\n                    }\n                }\n            }\n        }\n    }\n\n    return happyStrings[k - 1];\n}\n\nint main() {\n    std::cout << getHappyString(1, 1) << std::endl; // Output: a\n    std::cout << getHappyString(2, 7) << std::endl; // Output: caaab\n    std::cout << getHappyString(3, 13) << std::endl; // Output: caaaabbbbab\n\n    return 0;\n}\n```",
  "1416": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSteps(string s) {\n        int res = 0;\n        bool hasZero = false;\n        for (char c : s) {\n            if (c == '1') {\n                res++;\n            } else if (c == '0' && !hasZero) {\n                res += 2;\n                hasZero = true;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    string s1 = \"100000100\";\n    cout << \"Test case 1: \" << solution.numSteps(s1) << endl; // Output: 5\n\n    string s2 = \"1100\";\n    cout << \"Test case 2: \" << solution.numSteps(s2) << endl; // Output: 3\n\n    string s3 = \"0\";\n    cout << \"Test case 3: \" << solution.numSteps(s3) << endl; // Output: 1\n\n    return 0;\n}\n```",
  "1417": "```\n#include <iostream>\n#include <string>\n\nbool reformatString(std::string s) {\n    int maxCount = 0;\n    char prevChar = '\\0';\n    for (int i = 0; i < s.length(); ++i) {\n        if (s[i] == prevChar) {\n            continue;\n        }\n        int count = 1;\n        for (int j = i + 1; j < s.length(); ++j) {\n            if (s[j] == s[i]) {\n                ++count;\n            } else {\n                break;\n            }\n        }\n        if (count > maxCount) {\n            maxCount = count;\n            prevChar = s[i];\n        }\n    }\n    for (int i = 0; i < s.length(); ++i) {\n        while (maxCount-- > 0) {\n            std::cout << s[i];\n            i++;\n        }\n        if (i < s.length()) {\n            std::cout << \"\\n\";\n        }\n    }\n}\n\nint main() {\n    reformatString(\"a32b4cd\"); // Output: abacdc\n    reformatString(\"cccddddd\"); // Output: cccdddddd\n    reformatString(\"aa22bb33\"); // Output: aabbcccc\n    return 0;\n}\n```",
  "1419": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSteps(string s) {\n        int steps = 0;\n        int croakCount[2] = {0, 0};\n        \n        for (char c : s) {\n            if (c == 'o') {\n                croakCount[1]++;\n            } else {\n                croakCount[0]++;\n            }\n        }\n        \n        while (croakCount[0] > croakCount[1]) {\n            steps++;\n            croakCount[0]--;\n            croakCount[1]++;\n        }\n        \n        return steps;\n    }\n};\n\nint main() {\n    Solution sol = Solution();\n    \n    cout << \"Test case 1: \" << sol.minSteps(\"croak\") << endl; // Expected output: 1\n    cout << \"Test case 2: \" << sol.minSteps(\"car\") << endl; // Expected output: 4\n    cout << \"Test case 3: \" << sol.minSteps(\"tooc\") << endl; // Expected output: 0\n    \n    return 0;\n}\n```",
  "1418": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> displayTable(vector<vector<string>>& orders) {\n        map<int, map<string, int>> tableOrders;\n        \n        for (const auto& order : orders) {\n            int tableNumber = stoi(order[1]);\n            string dishName = order[2];\n            int quantity = 0;\n            \n            if (order.size() > 3) {\n                quantity = stoi(order[3]);\n            }\n            \n            if (!tableOrders.count(tableNumber)) {\n                tableOrders[tableNumber] = map<string, int>();\n            }\n            \n            if (!tableOrders[tableNumber].count(dishName)) {\n                tableOrders[tableNumber][dishName] = 0;\n            }\n            \n            tableOrders[tableNumber][dishName] += quantity;\n        }\n        \n        vector<vector<string>> result;\n        for (const auto& table : tableOrders) {\n            vector<string> row;\n            row.push_back(to_string(table.first));\n            \n            for (const auto& dish : table.second) {\n                row.push_back(to_string(dish.second));\n            }\n            \n            result.push_back(row);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> orders1 = {{\"Luke\",\"Table 1\",\"Coffee\", \"2\"}, {\"Jen\",\"Table 2\",\"Water\", \"3\"}};\n    vector<vector<string>> expected1 = {{\"Table 1\",\"Coffee:2\",\"Water:0\"},\n                                         {\"Table 2\",\"Coffee:0\",\"Water:3\"}};\n\n    for (const auto& row : solution.displayTable(orders1)) {\n        for (const auto& cell : row) {\n            cout << cell << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<string>> orders2 = {{\"Alice\",\"Table 3\",\"Burger\", \"4\"}, {\"Bob\",\"Table 3\",\"Fries\", \"5\"},\n                                       {\"Charlie\",\"Table 3\",\"Coke\", \"6\"}};\n    vector<vector<string>> expected2 = {{\"Table 3\",\"Burger:4,Fries:0,Coke:0\"},\n                                         {\"Table 3\",\"Burger:0,Fries:5,Coke:6\"}};\n\n    for (const auto& row : solution.displayTable(orders2)) {\n        for (const auto& cell : row) {\n            cout << cell << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<string>> orders3 = {{\"John\",\"Table 1\",\"Soda\", \"2\"}, {\"Mary\",\"Table 2\",\"Soda\", \"3\"}};\n    vector<vector<string>> expected3 = {{\"Table 1\",\"Coffee:0,Water:0,Soda:2\"},\n                                         {\"Table 2\",\"Coffee:0,Water:3,Soda:3\"}};\n\n    for (const auto& row : solution.displayTable(orders3)) {\n        for (const auto& cell : row) {\n            cout << cell << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
  "1420": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> maxEqualFreq(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<vector<int>> cnt(100001);\n        for (int i = 0; i < n; ++i) {\n            cnt[nums[i]].push_back(i);\n        }\n        \n        vector<int> res;\n        for (int i = 0; i < n; ++i) {\n            if (cnt[nums[i]].size() > k) {\n                while (cnt[nums[i]].size() > k && res.size() >= k) {\n                    res.pop_back();\n                }\n            } else {\n                for (int j = nums[i] + 1; j <= 100000; ++j) {\n                    if (res.size() < k || res.back() != j - 1) {\n                        res.push_back(j - 1);\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<int> nums1 = {2,3,5};\n    int k1 = 2;\n    vector<int> expected1 = {2,3,-1,5};\n    if (solution.maxEqualFreq(nums1, k1) != expected1)\n        return 1;\n    \n    // Test Case 2\n    vector<int> nums2 = [1,3,0,5,0];\n    int k2 = 3;\n    vector<int> expected2 = [5,3,10};\n    if (solution.maxEqualFreq(nums2, k2) != expected2)\n        return 1;\n    \n    // Test Case 3\n    vector<int> nums3 = [0, 2];\n    int k3 = 3;\n    vector<int> expected3 = [];\n    if (solution.maxEqualFreq(nums3, k3) != expected3)\n        return 1;\n    \n    cout << \"All test cases passed!\" << endl;\n    return 0;\n}\n```",
  "1421": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nclass NPVQueries {\npublic:\n    double calculateNpv(const std::vector<int>& cashflows) {\n        int sum = 0;\n        for (int i = 0; i < cashflows.size(); ++i) {\n            sum += cashflows[i] / pow(1 + 0.05, i);\n        }\n        return static_cast<double>(sum);\n    }\n};\n\nint main() {\n    NPVQueries queries;\n\n    // Test Case 1\n    std::vector<int> testCashFlows1 = {1000, -500, 300};\n    double result1 = queries.calculateNpv(testCashFlows1);\n    if (result1 == 933.333333) {\n        std::cout << \"Test Case 1 Passed\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1 Failed: Expected 933.333333, got \" << result1 << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<int> testCashFlows2 = {5000, -1000, 2000};\n    double result2 = queries.calculateNpv(testCashFlows2);\n    if (result2 == 4444.44444) {\n        std::cout << \"Test Case 2 Passed\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2 Failed: Expected 4444.44444, got \" << result2 << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<int> testCashFlows3 = {2000, -500, -1000};\n    double result3 = queries.calculateNpv(testCashFlows3);\n    if (result3 == 1333.33333) {\n        std::cout << \"Test Case 3 Passed\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3 Failed: Expected 1333.33333, got \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1422": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxScore(string s) {\n        vector<int> prefixSum(1 + s.size());\n        for (int i = 0; i < s.size(); ++i) {\n            if (s[i] == '1') {\n                prefixSum[i + 1] = prefixSum[i] + 1;\n            }\n        }\n\n        int maxScore = 0, left, right;\n        for (int i = 1; i < s.size() - 1; ++i) {\n            left = prefixSum[i];\n            right = prefixSum[s.size()] - (prefixSum[s.size() - 1] - prefixSum[i]);\n            if (left + right > maxScore) {\n                maxScore = left + right;\n            }\n        }\n\n        return maxScore;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.maxScore(\"011101\") << endl; // Output: 5\n    cout << solution.maxScore(\"1001\") << endl; // Output: 4\n    cout << solution.maxScore(\"0001100100\") << endl; // Output: 7\n\n    return 0;\n}\n```",
  "1423": "```\n#include <iostream>\n#include <vector>\n\nint maxPoints(std::vector<std::string>& cardPackets) {\n    int n = cardPackets.size();\n    if (n == 0) return 0;\n\n    std::vector<int> cards(n);\n    for (int i = 0; i < n; ++i) {\n        for (char c : cardPackets[i]) {\n            cards[i] += c - '0';\n        }\n    }\n\n    int ans = 0;\n    for (int left = 0, right = 0; right < n; ++right) {\n        long long sum = 0;\n        for (int i = left; i <= right; ++i) {\n            sum += cards[i];\n        }\n        ans = std::max(ans, static_cast<int>(sum - (cards[left] + cards[right])));\n        if (right == n - 1) break;\n        while (cards[right] < cards[left]) {\n            sum -= cards[left++];\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n    {\n        std::vector<std::string> cardPackets = {\"111\",\"2222\"};\n        int result = maxPoints(cardPackets);\n        std::cout << \"Test case 1: \" << result << std::endl;\n    }\n    \n    {\n        std::vector<std::string> cardPackets = {\"1234\",\"4567\"};\n        int result = maxPoints(cardPackets);\n        std::cout << \"Test case 2: \" << result << std::endl;\n    }\n    \n    {\n        std::vector<std::string> cardPackets = {\"1010\",\"1111\"};\n        int result = maxPoints(cardPackets);\n        std::cout << \"Test case 3: \" << result << std::endl;\n    }\n}\n```",
  "1424": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findDiagonalOrder(vector<vector<int>>& nums) {\n        if (nums.empty()) return {};\n        int m = nums.size(), n = 0;\n        for (const auto& row : nums) n = max(n, (int)row.size());\n        vector<int> res;\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<> > pq;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                pq.push({nums[i][j], {i, j}});\n            }\n        }\n        while (!pq.empty()) {\n            int val = pq.top().first;\n            pair<int, int> pos = pq.top().second;\n            pq.pop();\n            if (pos.second == 0 || (pos.first + pos.second) % 2 == 1) {\n                res.push_back(val);\n            } else {\n                res.push_back(val);\n                break;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<int>> mat1 = {{1, 2, 3}, {4, 5, 6}};\n    vector<int> result1 = solution.findDiagonalOrder(mat1);\n    for (int i : result1) cout << i << \" \";\n    cout << endl;\n    \n    vector<vector<int>> mat2 = {{1, 2, 3, 4}, {5, 6, 7, 8}};\n    vector<int> result2 = solution.findDiagonalOrder(mat2);\n    for (int i : result2) cout << i << \" \";\n    cout << endl;\n    \n    vector<vector<int>> mat3 = {{1, 2}, {3, 4}, {5, 6}, {7, 8}};\n    vector<int> result3 = solution.findDiagonalOrder(mat3);\n    for (int i : result3) cout << i << \" \";\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1425": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxConsecutiveSum(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> prefixSum(n + 1);\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n\n        int maxSum = INT_MIN;\n        for (int i = k; i <= n; i++) {\n            for (int j = 0; j < i - k + 1; j++) {\n                maxSum = max(maxSum, prefixSum[i] - prefixSum[j]);\n            }\n        }\n\n        return maxSum;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {5, 6, 1, 10, 0, 2};\n    int k1 = 4;\n    cout << \"Test case 1: \" << solution.maxConsecutiveSum(nums1, k1) << endl;\n\n    // Test case 2\n    vector<int> nums2 = {3, 5, -9, 8, 10};\n    int k2 = 3;\n    cout << \"Test case 2: \" << solution.maxConsecutiveSum(nums2, k2) << endl;\n\n    // Test case 3\n    vector<int> nums3 = {-1, -2, 3, 4, -5};\n    int k3 = 5;\n    cout << \"Test case 3: \" << solution.maxConsecutiveSum(nums3, k3) << endl;\n\n    return 0;\n}\n```",
  "1426": "```\n#include <iostream>\n#include <vector>\n\nint countElements(std::vector<int>& arr) {\n    std::unordered_map<int, int> map;\n    for (int num : arr) {\n        map[num]++;\n    }\n    int maxCount = -1;\n    for (auto& pair : map) {\n        if (pair.second > 0 && pair.first == *std::max_element(map.begin(), map.end()) - 1) {\n            maxCount = pair.second;\n        }\n    }\n    return maxCount;\n}\n\nint main() {\n    std::vector<int> arr1 = {1, 2, 3, 4};\n    int result1 = countElements(arr1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> arr2 = {1, 1, 2, 2};\n    int result2 = countElements(arr2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> arr3 = {8, 10, 8, 7, 6, 8};\n    int result3 = countElements(arr3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1427": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    string stringShift(string s, vector<vector<int>>& shift) {\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            if (i == 0 || s[i-1] != 'a' && i - shift[i][1]%n == 0) {\n                return s;\n            }\n            s = s.substr(shift[i][1]%n, 1) + s.substr(0, shift[i][1]%n);\n        }\n        return s;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s1 = \"abc\";\n    vector<vector<int>> shift1 = {{0,1},{1,2}};\n    cout << solution.stringShift(s1, shift1) << endl;  // Output: cab\n\n    // Test case 2\n    string s2 = \"aaa\";\n    vector<vector<int>> shift2 = {{0,7},{1,3}};\n    cout << solution.stringShift(s2, shift2) << endl;  // Output: cabaa\n\n    // Test case 3\n    string s3 = \"aaaa\";\n    vector<vector<int>> shift3 = {{5,3},{1,2},{3,1},{9,1}};\n    cout << solution.stringShift(s3, shift3) << endl;  // Output: aaaa\n\n    return 0;\n}\n```",
  "1428": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int leftMostColumnWithOne(vector<vector<int>>& binaryMatrix) {\n        int res = -1;\n        for (int i = 0; i < binaryMatrix.size(); ++i) {\n            for (int j = 0; j < binaryMatrix[0].size(); ++j) {\n                if (binaryMatrix[i][j] == 1) {\n                    res = min(res, j);\n                    break;\n                }\n            }\n            if (~res)\n                break;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> matrix1 = {{0,1},{1,0}};\n    cout << \"Test case 1: \" << solution.leftMostColumnWithOne(matrix1) << endl;  // Expected output: 1\n\n    // Test case 2\n    vector<vector<int>> matrix2 = {{0,0,0,1},{0,0,0,1},{0,0,0,1},{0,0,0,1}};\n    cout << \"Test case 2: \" << solution.leftMostColumnWithOne(matrix2) << endl;  // Expected output: 3\n\n    // Test case 3\n    vector<vector<int>> matrix3 = {{1,0,1,1},{0,0,1,0},{1,1,1,1},{0,0,0,1}};\n    cout << \"Test case 3: \" << solution.leftMostColumnWithOne(matrix3) << endl;  // Expected output: 0\n\n    return 0;\n}\n```",
  "1429": "```\n#include <iostream>\n#include <unordered_map>\n#include <queue>\n\nclass Node {\npublic:\n    int val;\n    bool isUnique;\n\n    Node(int val) : val(val), isUnique(true) {}\n};\n\nclass FirstUniqueNumber {\npublic:\n    unordered_map<int, Node*> ump;\n    queue<int> q;\n\n    void addNum(int num) {\n        if (!ump.count(num)) {\n            ump[num] = new Node(num);\n            q.push(num);\n        }\n    }\n\n    int showFirstUnique() {\n        while (!q.empty()) {\n            int num = q.front();\n            q.pop();\n            if (ump[num]->isUnique) {\n                return num;\n            } else {\n                ump.erase(num);\n            }\n        }\n        return -1; // or throw exception\n    }\n};\n\nint main() {\n    FirstUniqueNumber fu;\n    fu.addNum(5);\n    cout << \"First Unique Number: \" << fu.showFirstUnique() << endl;\n    fu.addNum(7);\n    fu.addNum(3);\n    fu.addNum(3);\n    cout << \"First Unique Number: \" << fu.showFirstUnique() << endl;\n    fu.addNum(5);\n    cout << \"First Unique Number: \" << fu.showFirstUnique() << endl;\n    return 0;\n}\n```",
  "1430": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    bool isValidSequence(TreeNode* root, string s) {\n        if (!root) return false;\n        if (s.length() == 0) return true;\n        if (root->val != s[0]) return false;\n        \n        return isValidSequence(root->left, s.substr(1)) || isValidSequence(root->right, s.substr(1));\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    TreeNode* root = new TreeNode('a');\n    root->left = new TreeNode('b');\n    root->right = new TreeNode('c');\n    root->left->left = new TreeNode('d');\n    root->left->right = new TreeNode('e');\n    \n    cout << solution.isValidSequence(root, \"badb\") << endl;  // Expected: true\n    cout << solution.isValidSequence(root, \"bade\") << endl;  // Expected: false\n    cout << solution.isValidSequence(root, \"a\") << endl;     // Expected: true\n    \n    return 0;\n}\n```",
  "1431": "```\n#include <iostream>\n#include <vector>\n\nint childrenWithCandies(std::vector<int>& ratings, std::vector<int>& candies) {\n    int max_candies = *std::max_element(candies.begin(), candies.end());\n    for (size_t i = 0; i < ratings.size(); ++i) {\n        if (candies[i] >= (max_candies - ratings[i])) {\n            candies[i] = 1;\n        } else {\n            candies[i] = 0;\n        }\n    }\n    return *std::accumulate(candies.begin(), candies.end(), 0);\n}\n\nint main() {\n    std::vector<int> ratings1 = {2,3,5,1,3};\n    std::vector<int> candies1 = {2,1,1,1,2};\n    int result1 = childrenWithCandies(ratings1, candies1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> ratings2 = {4,5,6};\n    std::vector<int> candies2 = {3,7,10};\n    int result2 = childrenWithCandies(ratings2, candies2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> ratings3 = {1,5,4,2};\n    std::vector<int> candies3 = {7,6,8,6};\n    int result3 = childrenWithCandies(ratings3, candies3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1432": "```\n#include <iostream>\n#include <vector>\n\nint maximum69Number(std::string num) {\n    int maxDiff = 0;\n    for (int i = 0; i < num.length(); ++i) {\n        if (num[i] == '6') {\n            int diff = std::stoi(num.substr(0, i)) * 10 + std::stoi(num.substr(i + 1));\n            if (diff > maxDiff) {\n                maxDiff = diff;\n            }\n        }\n    }\n    return maxDiff;\n}\n\nint main() {\n    std::cout << maximum69Number(\"9663\") << std::endl; // Output: 703\n    std::cout << maximum69Number(\"9996\") << std::endl; // Output: 9945\n    std::cout << maximum69Number(\"9999\") << std::endl; // Output: 9998\n\n    return 0;\n}\n```",
  "1433": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nbool canBreak(std::string s1, std::string s2) {\n    for (int i = 0; i < s1.size(); ++i) {\n        if (s2.find(s1.substr(i)) != std::string::npos) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \";\n    if (canBreak(\"abc\", \"def\")) {\n        std::cout << \"Pass\\n\";\n    } else {\n        std::cout << \"Fail\\n\";\n    }\n\n    std::cout << \"Test Case 2: \";\n    if (canBreak(\"a\", \"aa\")) {\n        std::cout << \"Fail\\n\";\n    } else {\n        std::cout << \"Pass\\n\";\n    }\n\n    std::cout << \"Test Case 3: \";\n    if (canBreak(\"xyz\", \"abc\")) {\n        std::cout << \"Pass\\n\";\n    } else {\n        std::cout << \"Fail\\n\";\n    }\n\n    return 0;\n}",
  "1434": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numberWays(vector<vector<int>>& firstTeam, vector<vector<int>>& secondTeam) {\n        int n = firstTeam.size();\n        vector<vector<int>> dp(n + 1, vector<int>(1 << n));\n        dp[0][0] = 1;\n        \n        for (int i = 0; i < n; i++) {\n            for (int mask = 0; mask < (1 << n); mask++) {\n                if (!dp[i][mask]) continue;\n                for (int j = 0; j < firstTeam.size(); j++) {\n                    if (((mask >> j) & 1) && (firstTeam[j].size() > i)) {\n                        int newMask = mask | (1 << j);\n                        dp[i + 1][newMask] += dp[i][mask];\n                    }\n                }\n            }\n        }\n        \n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            for (int mask = 0; mask < (1 << n); mask++) {\n                if (!dp[n - 1][mask]) continue;\n                for (int j = 0; j < secondTeam.size(); j++) {\n                    if (((mask >> j) & 1) && (secondTeam[j].size() > i)) {\n                        int newMask = mask | (1 << n + j);\n                        res += dp[n - 1][mask];\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> firstTeam1 = {{1, 2}, {3, 4}};\n    vector<vector<int>> secondTeam1 = {{5, 6}, {7, 8}};\n    cout << \"Test case 1: \" << solution.numberWays(firstTeam1, secondTeam1) << endl;\n\n    // Test case 2\n    vector<vector<int>> firstTeam2 = {{1, 3, 4}};\n    vector<vector<int>> secondTeam2 = {{2, 5, 6}};\n    cout << \"Test case 2: \" << solution.numberWays(firstTeam2, secondTeam2) << endl;\n\n    // Test case 3\n    vector<vector<int>> firstTeam3 = {{1}, {2, 3}, {4, 5, 6}};\n    vector<vector<int>> secondTeam3 = {{7, 8, 9}, {10, 11, 12}};\n    cout << \"Test case 3: \" << solution.numberWays(firstTeam3, secondTeam3) << endl;\n\n    return 0;\n}\n```",
  "1435": "```\n#include <iostream>\n#include <vector>\n\nstruct Range {\n    int start;\n    int end;\n};\n\nint totalTime(std::vector<Range>& ranges) {\n    int time = 0;\n    for (const auto& range : ranges) {\n        time += range.end - range.start + 1;\n    }\n    return time;\n}\n\nint main() {\n    // Test case 1\n    std::vector<Range> ranges1 = {{1, 3}, {2, 4}};\n    int result1 = totalTime(ranges1);\n    if (result1 == 5) {\n        std::cout << \"Test case 1 passed.\\n\";\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 5, got: \" << result1 << \".\\n\";\n    }\n\n    // Test case 2\n    std::vector<Range> ranges2 = {{0, 10}, {11, 15}};\n    int result2 = totalTime(ranges2);\n    if (result2 == 16) {\n        std::cout << \"Test case 2 passed.\\n\";\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 16, got: \" << result2 << \".\\n\";\n    }\n\n    // Test case 3\n    std::vector<Range> ranges3 = {{1, 5}, {6, 10}};\n    int result3 = totalTime(ranges3);\n    if (result3 == 11) {\n        std::cout << \"Test case 3 passed.\\n\";\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 11, got: \" << result3 << \".\\n\";\n    }\n\n    return 0;\n}\n```",
  "1436": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string findDestination(vector<vector<string>>& paths) {\n        unordered_map<string, string> cityToDestination;\n        \n        for (const auto& path : paths) {\n            cityToDestination[path[0]] = path[1];\n        }\n        \n        for (const auto& pair : cityToDestination) {\n            if (!pair.second.empty()) {\n                return pair.second;\n            }\n        }\n        \n        return \"\";\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<string>> test1{{\"London\",\"New York\"},{\"New York\",\"Los Angeles\"}};\n    cout << \"Test 1: \" << solution.findDestination(test1) << endl; // Los Angeles\n\n    vector<vector<string>> test2{{\"Washington\",\"New York\"},{\"New York\",\"Los Angeles\"},{\"Philadelphia\",\"Los Angeles\"}};\n    cout << \"Test 2: \" << solution.findDestination(test2) << endl; // Los Angeles\n\n    vector<vector<string>> test3{{\"A\",\"B\"},{\"B\",\"C\"}};    \n    cout << \"Test 3: \" << solution.findDestination(test3) << endl; // C\n\n    return 0;\n}\n```",
  "1437": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool kLengthApart(vector<int>& nums, int k) {\n        for (int i = 0; i < nums.size() - 1; i++) {\n            if (nums[i] == 1 && i - k <= i) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {1, 0, 0, 1};\n    int k1 = 2;\n    cout << (solution.kLengthApart(nums1, k1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    vector<int> nums2 = {1, 0, 10, 4, 10, 3};\n    int k2 = 2;\n    cout << (solution.kLengthApart(nums2, k2) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    vector<int> nums3 = {1, 1, 0, 1};\n    int k3 = 2;\n    cout << (solution.kLengthApart(nums3, k3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1438": "```\n#include <iostream>\n#include <vector>\n\nint longestSubarray(std::vector<int>& nums, int limit) {\n    std::multimap<int, int> increasing;\n    std::multimap<int, int> decreasing;\n\n    for (size_t i = 0; i < nums.size(); ++i) {\n        if (increasing.empty() || *increasing.rbegin() <= nums[i]) {\n            increasing.emplace(nums[i], i);\n        } else {\n            decreasing.emplace(*decreasing.rbegin(), i);\n        }\n    }\n\n    int maxLen = 0;\n    for (int num : increasing) {\n        auto itDecreasing = decreasing.upper_bound(num.second);\n        while (itDecreasing != decreasing.end() && *itDecreasing->second - num.second <= limit) {\n            ++maxLen;\n            --itDecreasing;\n        }\n    }\n\n    return maxLen;\n}\n\nint main() {\n    std::cout << longestSubarray({1, 2, 3, 4}, 2) << std::endl; // Output: 4\n    std::cout << longestSubarray({8, 2, 6, 2}, 1) << std::endl; // Output: 7\n    std::cout << longestSubarray({10, 1, 2, 5, 7, 2, 3}, 6) << std::endl; // Output: 9\n    return 0;\n}\n```",
  "1439": "```\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Vector {\n    int x, y;\n};\n\nint findKth(vector<vector<int>>& mat, int k) {\n    priority_queue<Vector> pq;\n    for (int i = 0; i < mat.size(); ++i)\n        pq.push({mat[i][0], i});\n    \n    while (!pq.empty()) {\n        Vector v = pq.top();\n        pq.pop();\n        \n        if (k-- == 1) return v.x;\n        \n        int nx = v.x + mat[v.y][1];\n        if (nx != 0)\n            pq.push({nx, v.y});\n    }\n    \n    return -1; // Not found\n}\n\nint main() {\n    vector<vector<int>> mat1 = {{4,6},{3,5},{2,4},{7,8}};\n    cout << \"Kth smallest sum for mat1: \" << findKth(mat1, 2) << endl;\n\n    vector<vector<int>> mat2 = {{1,10},{2,9},{3,8},{4,7}};\n    cout << \"Kth smallest sum for mat2: \" << findKth(mat2, 1) << endl;\n\n    vector<vector<int>> mat3 = {{5,13},{6,14},{7,15}};\n    cout << \"Kth smallest sum for mat3: \" << findKth(mat3, 3) << endl;\n    \n    return 0;\n}\n```",
  "1440": "```\n#include <iostream>\n#include <vector>\n\nbool parseBoolExpr(std::string expression) {\n    // Your implementation here\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << (parseBoolExpr(\"!(t-falseb)\") ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test case 2: \" << (parseBoolExpr(\"!(true&&false||false&&true)\") ? \"True\" : \"False\") << std::endl;\n    std::cout << \"Test case 3: \" << (parseBoolExpr(\"(a||b)&&(c||d)\") ? \"True\" : \"False\") << std::endl;\n    return 0;\n}",
  "1441": "```\n#include <iostream>\n#include <vector>\n#include <stack>\n\nint minAddToMakeValid(std::vector<char>& S) {\n    std::stack<char> stack;\n    int res = 0;\n\n    for (char c : S) {\n        if (c == '(') {\n            stack.push(c);\n        } else {\n            if (!stack.empty()) {\n                stack.pop();\n            } else {\n                res++;\n            }\n        }\n    }\n\n    return res + stack.size();\n}\n\nint main() {\n    std::vector<char> s1 = {'('};\n    std::cout << minAddToMakeValid(s1) << std::endl;\n\n    std::vector<char> s2 = {')', '(', '('};\n    std::cout << minAddToMakeValid(s2) << std::endl;\n\n    std::vector<char> s3 = {'(', ')', ')'};\n    std::cout << minAddToMakeValid(s3) << std::endl;\n}\n```",
  "1442": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countTriplets(vector<int>& arr) {\n        int n = arr.size();\n        long long res = 0;\n        vector<long long> prefixXOR(n + 1, 0);\n        for (int i = 0; i < n; i++) {\n            prefixXOR[i + 1] = prefixXOR[i] ^ arr[i];\n        }\n        map<long long, int> countMap;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                long long xorVal = prefixXOR[j + 1] - prefixXOR[i];\n                res += countMap[xorVal]++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> arr1 = {2,3,1,6,5};\n    cout << \"Test case 1: \" << solution.countTriplets(arr1) << endl;\n\n    // Test case 2\n    vector<int> arr2 = {0,0,0,0,0};\n    cout << \"Test case 2: \" << solution.countTriplets(arr2) << endl;\n\n    // Test case 3\n    vector<int> arr3 = {1,1,1,1,1};\n    cout << \"Test case 3: \" << solution.countTriplets(arr3) << endl;\n    \n    return 0;\n}\n```",
  "1444": "```\n#include <iostream>\n#include <vector>\n\nint waysToCutPizza(int n, int m, std::vector<std::vector<int>>& pieces) {\n    int ans = 0;\n    for (int i = 0; i <= m; ++i) {\n        int j = m - i;\n        if (j > 0 && i < n) {\n            int total = i * j;\n            if (total == n) {\n                ans += pieces[i][0] + pieces[0][j];\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << waysToCutPizza(3, 3, { { 2, 1 }, { 1, 2 }, { 1, 1 } }) << std::endl; // Expected output: 8\n    std::cout << \"Test case 2: \" << waysToCutPizza(5, 6, { { 4, 3 }, { 2, 2 }, { 1, 3 }, { 3, 2 }, { 2, 1 } }) << std::endl; // Expected output: 24\n    std::cout << \"Test case 3: \" << waysToCutPizza(5, 6, { { 4, 4 }, { 2, 2 }, { 1, 3 }, { 3, 2 }, { 2, 1 } }) << std::endl; // Expected output: 12\n    return 0;\n}",
  "1443": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumTime(int n, vector<vector<int>>& edges, vector<bool>& hasApple) {\n        vector<vector<int>> tree(n);\n        for (int i = 0; i < edges.size(); ++i) {\n            tree[edges[i][0]].push_back(edges[i][1]);\n            if (hasApple[edges[i][0]] || hasApple[edges[i][1]]) {\n                parent[edges[i][0]] = edges[i][1];\n                childCount[edges[i][0]]++;\n            }\n        }\n\n        int ans = dfs(0, -1);\n        return ans;\n    }\n\nprivate:\n    vector<int> parent(n, -1);\n    vector<int> childCount(n);\n\n    int dfs(int node, int parentNode) {\n        if (hasApple[node]) return 2;\n\n        int time = 0;\n        for (int neighbor : tree[node]) {\n            if (neighbor != parentNode && childCount[neighbor] > 0) {\n                time += max(2, dfs(neighbor, node));\n            }\n        }\n\n        return time;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int n = 7;\n    vector<vector<int>> edges = {{0, 1}, {0, 6}, {1, 2}, {1, 4}, {5, 6}};\n    vector<bool> hasApple = {true, false, true, true, true, false, true};\n    cout << solution.minimumTime(n, edges, hasApple) << endl;\n\n    // Test Case 2\n    n = 11;\n    edges = {{0, 1}, {0, 5}, {3, 4}, {5, 6}};\n    hasApple = {true, false, true, true, false, false, true, true, true, false};\n    cout << solution.minimumTime(n, edges, hasApple) << endl;\n\n    // Test Case 3\n    n = 2;\n    edges = {{0, 1}];\n    hasApple = {false, false};\n    cout << solution.minimumTime(n, edges, hasApple) << endl;\n\n    return 0;\n}\n```",
  "1446": "```\n#include <iostream>\n#include <string>\n\nint lengthOfLongestSubstring(std::string s) {\n    int n = s.length();\n    int ans = 0;\n    int i = 0, j = 0;\n\n    while (i < n && j < n) {\n        if (s[j] == s[i]) {\n            ans = std::max(ans, j - i + 1);\n            i++;\n        } else\n            j++;\n    }\n\n    return ans;\n}\n\nint main() {\n    std::cout << \"Test Case 1: Expected '3', got \" << lengthOfLongestSubstring(\"aab\") << std::endl;\n    std::cout << \"Test Case 2: Expected '7', got \" << lengthOfLongestSubstring(\"abcba\") << std::endl;\n    std::cout << \"Test Case 3: Expected '1', got \" << lengthOfLongestSubstring(\"aaaaa\") << std::endl;\n\n    return 0;\n}\n```",
  "1445": "```\n#include <iostream>\n#include <vector>\n\nint totalApplesAndOranges(int m, int appleCount[], int p, int orangeCount[]) {\n    int total = 0;\n    for (int i = 0; i < m; i++) {\n        total += appleCount[i] + orangeCount[(p - 1) % m];\n    }\n    return total;\n}\n\nint main() {\n    std::vector<int> appleCounts = {2, 3};\n    std::vector<int> orangeCounts = {4, 5};\n    \n    int result1 = totalApplesAndOranges(2, &appleCounts[0], 2, &orangeCounts[0]);\n    std::cout << \"Test Case 1: \" << result1 << std::endl;\n    \n    appleCounts = {3, 2, 1};\n    orangeCounts = {4, 5, 6};\n    \n    int result2 = totalApplesAndOranges(3, &appleCounts[0], 3, &orangeCounts[0]);\n    std::cout << \"Test Case 2: \" << result2 << std::endl;\n    \n    appleCounts = {1, 2, 3, 4};\n    orangeCounts = {5, 6, 7, 8};\n    \n    int result3 = totalApplesAndOranges(4, &appleCounts[0], 4, &orangeCounts[0]);\n    std::cout << \"Test Case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1447": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> simplifiedFractions(int n) {\n        vector<string> res;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = i + 1; j <= n; ++j) {\n                bool isSimplified = true;\n                for (int k = 2; k <= gcd(i, j); ++k) {\n                    if (i % k == 0 && j % k == 0) {\n                        isSimplified = false;\n                        break;\n                    }\n                }\n                if (isSimplified) res.push_back(to_string(i) + \"/\" + to_string(j));\n            }\n        }\n        return res;\n    }\n\n    int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int n1 = 2;\n    vector<string> result1 = solution.simplifiedFractions(n1);\n    for (const string& s : result1) cout << s << endl;\n\n    // Test Case 2\n    int n2 = 3;\n    vector<string> result2 = solution.simplifiedFractions(n2);\n    for (const string& s : result2) cout << s << endl;\n\n    // Test Case 3\n    int n3 = 4;\n    vector<string> result3 = solution.simplifiedFractions(n3);\n    for (const string& s : result3) cout << s << endl;\n\n    return 0;\n}\n```",
  "1448": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int goodNodes(TreeNode* root, int maxi = INT_MIN) {\n        if (root == NULL)\n            return 0;\n        \n        int res = (root->val >= maxi) ? 1 : 0;\n        \n        res += goodNodes(root->left, max(root->val, maxi));\n        res += goodNodes(root->right, max(root->val, maxi));\n        \n        return res;\n    }\n};\n\nint main() {\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(4);\n    root1->left->left = new TreeNode(3);\n    root1->left->right = new TreeNode(0);\n    root1->right->left = new TreeNode(1);\n    root1->right->right = new TreeNode(1);\n\n    Solution s;\n    cout << \"Test Case 1: \" << s.goodNodes(root1) << endl; // Output: 4\n\n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(4);\n    root2->left->left = new TreeNode(2);\n    root2->left->right = new TreeNode(1);\n\n    Solution s2;\n    cout << \"Test Case 2: \" << s2.goodNodes(root2) << endl; // Output: 3\n\n    TreeNode* root3 = new TreeNode(4);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(6);\n    root3->left->left = new TreeNode(1);\n\n    Solution s3;\n    cout << \"Test Case 3: \" << s3.goodNodes(root3) << endl; // Output: 4\n\n    return 0;\n}",
  "1449": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumSum(vector<int>& arr) {\n        vector<vector<int>> dp(arr.size() + 1, vector<int>(10001));\n        \n        for (int i = 0; i <= arr.size(); i++) {\n            dp[i][0] = 0;\n        }\n        \n        for (int i = 1; i <= arr.size(); i++) {\n            for (int j = 1; j <= 10000; j++) {\n                if (arr[i - 1] > j) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], arr[i - 1] + dp[i - 1][j - arr[i - 1]]);\n                }\n            }\n        }\n        \n        int res = 0;\n        for (int i = 10000; i >= 0; i--) {\n            if (dp[arr.size()][i] > res) {\n                res = dp[arr.size()][i];\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test case 1\n    vector<int> arr1 = {3,4,7,5};\n    cout << \"Test Case 1: \" << s.maximumSum(arr1) << endl;  // Output: 9\n\n    // Test case 2\n    vector<int> arr2 = {1,2,3,4,5};\n    cout << \"Test Case 2: \" << s.maximumSum(arr2) << endl;  // Output: 12\n\n    // Test case 3\n    vector<int> arr3 = {10};\n    cout << \"Test Case 3: \" << s.maximumSum(arr3) << endl;  // Output: 10\n\n    return 0;\n}\n```",
  "1451": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nvoid processSentence(std::vector<std::string>& words) {\n    std::sort(words.begin(), words.end());\n}\n\nint main() {\n    // Test case 1: Simple example\n    std::vector<std::string> test1 = {\"cat\", \"window\", \"the\"};\n    processSentence(test1);\n    for (const auto& word : test1) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2: Example with duplicates\n    std::vector<std::string> test2 = {\"apple\", \"banana\", \"apple\"};\n    processSentence(test2);\n    for (const auto& word : test2) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3: Example with a single word\n    std::vector<std::string> test3 = {\"hello\"};\n    processSentence(test3);\n    for (const auto& word : test3) {\n        std::cout << word << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1450": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countStudents(int start, int end, vector<int>& homeworkTime) {\n        int students = 0;\n        for (int i = start; i <= end; i++) {\n            if (homeworkTime[i % homeworkTime.size()] == 1) {\n                students++;\n            }\n        }\n        return students;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> homeworkTime = {0, 1, 0, 1, 0, 1};\n    int start = 2, end = 3;\n    cout << \"Test Case 1: \" << solution.countStudents(start, end, homeworkTime) << endl; // Output: 2\n\n    homeworkTime = {9, 10, 6, 6, 10, 7, 9, 8, 10};\n    start = 3;\n    end = 4;\n    cout << \"Test Case 2: \" << solution.countStudents(start, end, homeworkTime) << endl; // Output: 1\n\n    homeworkTime = {0, 1, 1, 1, 0};\n    start = 1;\n    end = 3;\n    cout << \"Test Case 3: \" << solution.countStudents(start, end, homeworkTime) << endl; // Output: 3\n\n    return 0;\n}\n```",
  "1452": "```\n#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> peopleIndexes(vector<vector<string>>& favoriteCompanies) {\n        unordered_map<int, unordered_set<string>> companyIndex;\n        for (int i = 0; i < favoriteCompanies.size(); i++) {\n            for (const string& company : favoriteCompanies[i]) {\n                companyIndex[company].insert(i);\n            }\n        }\n\n        vector<vector<string>> result;\n        for (auto it = companyIndex.begin(); it != companyIndex.end(); it++) {\n            int idx = -1;\n            for (int j = 0; j < favoriteCompanies.size(); j++) {\n                unordered_set<string> set2(favoriteCompanies[j].begin(), favoriteCompanies[j].end());\n                if (set2.issubset(it->second)) {\n                    idx = j;\n                    break;\n                }\n            }\n\n            if (idx == -1) {\n                result.push_back({it->first});\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<string>> favoriteCompanies1 = {{\"leetcode\", \"google\", \"facebook\"}, {\"facebook\", \"google\"}};\n    vector<vector<string>> expectedResult1 = {{\"facebook\"}};\n    assert(solution.peopleIndexes(favoriteCompanies1) == expectedResult1);\n\n    vector<vector<string>> favoriteCompanies2 = {{}, {\"leetcode\", \"google\"}}; \n    vector<vector<string>> expectedResult2 = {};\n    assert(solution.peopleIndexes(favoriteCompanies2) == expectedResult2);\n\n    vector<vector<string>> favoriteCompanies3 = {{\"leetcode\"}, {\"facebook\", \"google\"}};\n    vector<vector<string>> expectedResult3 = {{\"leetcode\"}};\n    assert(solution.peopleIndexes(favoriteCompanies3) == expectedResult3);\n\n    cout << \"All test cases passed.\" << endl;\n    return 0;\n}\n```",
  "1453": "```\n#include <iostream>\n#include <vector>\n\nint maxDarts(std::vector<std::pair<int, int>>& points) {\n    int n = points.size();\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        bool flag = false;\n        for (int j = 0; j < n; j++) {\n            if (i != j && ((points[i].first * points[j].first + points[i].second * points[j].second) > 10000)) {\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) res++;\n    }\n    return res;\n}\n\nint main() {\n    std::vector<std::pair<int, int>> points1 {{0, 0}, {3, 4}, {-2, -5}};\n    std::cout << \"Test case 1: \" << maxDarts(points1) << std::endl;\n\n    std::vector<std::pair<int, int>> points2 {{-1, 0}, {0, 1}, {1, 0}};\n    std::cout << \"Test case 2: \" << maxDarts(points2) << std::endl;\n\n    std::vector<std::pair<int, int>> points3 {{10, 20}, {30, 40}, {-20, -10}};\n    std::cout << \"Test case 3: \" << maxDarts(points3) << std::endl;\n    \n    return 0;\n}\n```",
  "1455": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool isPrefixOf(std::string sentence) {\n    std::vector<std::string> words = {\"cat\", \"dog\", \"bird\"};\n    for (const auto& word : words) {\n        if (sentence.find(word) == 0) return true;\n    }\n    return false;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << isPrefixOf(\"cat bird\") << std::endl;  // Expected: true\n    std::cout << isPrefixOf(\"dog running\") << std::endl;  // Expected: true\n    std::cout << isPrefixOf(\"hello world\") << std::endl;  // Expected: false\n    return 0;\n}",
  "1454": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int activeUsers(vector<vector<int>>& logs) {\n        unordered_map<string, vector<int>> userLogs;\n        for (auto log : logs) {\n            string userId = to_string(log[0]);\n            userLogs[userId].push_back(log[1]);\n        }\n        \n        int result = 0;\n        for (auto& userLog : userLogs) {\n            sort(userLog.second.begin(), userLog.second.end());\n            for (int i = 0; i < userLog.second.size(); i++) {\n                if (i == 0 || userLog.second[i] != userLog.second[i-1]) {\n                    result++;\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<int>> logs1 = {{0,500},{1,400},{5,700},{3,600}};\n    cout << \"Test case 1: \" << solution.activeUsers(logs1) << endl;\n    \n    vector<vector<int>> logs2 = {{1,1000},{2,2000},{0,300},{4,500}];\n    cout << \"Test case 2: \" << solution.activeUsers(logs2) << endl;\n    \n    vector<vector<int>> logs3 = {{1,5},{1,6},{2,7}};\n    cout << \"Test case 3: \" << solution.activeUsers(logs3) << endl;\n    \n    return 0;\n}\n```",
  "1456": "```\n#include <iostream>\n#include <vector>\n\nint maxVowels(std::string word, int k) {\n    int n = word.length();\n    if(k > n)\n        return 0;\n\n    int maxCount = 0;\n    std::vector<int> vowelCount(n + 1, 0);\n\n    for(int i = 0; i < n; i++) {\n        if(word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u') \n            vowelCount[i + 1] = vowelCount[i] + (word[i] == 'a' || word[i] == 'e' || word[i] == 'i' || word[i] == 'o' || word[i] == 'u');\n        else\n            vowelCount[i + 1] = vowelCount[i];\n    }\n\n    for(int i = k; i <= n; i++) {\n        maxCount = std::max(maxCount, vowelCount[i] - vowelCount[i - k]);\n    }\n    return maxCount;\n}\n\nint main() {\n    int result1 = maxVowels(\"abciiideeds\", 3);\n    int result2 = maxVowels(\"everybodypeelstheirsoybeans\", 4);\n    int result3 = maxVowels(\"hello\", 5);\n\n    std::cout << \"Test case 1: The maximum number of vowels in a substring of length 3 is: \" << result1 << std::endl;\n    std::cout << \"Test case 2: The maximum number of vowels in a substring of length 4 is: \" << result2 << std::endl;\n    std::cout << \"Test case 3: The maximum number of vowels in a substring of length 5 is: \" << result3 << std::endl;\n\n    return 0;\n}",
  "1457": "```\n#include <iostream>\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nbool hasPath(TreeNode* root, string path, int start, int end) {\n    if (root == NULL)\n        return false;\n\n    for (int i = start; i <= end; i++) {\n        int len = path.length();\n        if ((path[i] - '0') != root->val)\n            break;\n        if (i == end && (len % 2) == 1) \n            return true;\n    }\n    return false;\n}\n\nvoid helper(TreeNode* root, string path, bool &hasP) {\n    if (root == NULL || hasPath(root, path, 0, path.length() - 1))\n        hasP = true;\n\n    if (root != NULL) {\n        string leftPath = path + to_string(root->val);\n        helper(root->left, leftPath, hasP);\n\n        string rightPath = path + to_string(root->val);\n        helper(root->right, rightPath, hasP);\n    }\n}\n\nbool pseudoPalindromicPaths(TreeNode* root) {\n    bool hasP = false;\n    string path = \"\";\n    helper(root, path, hasP);\n    return hasP;\n}\n\nint main() {\n    TreeNode* root1 = new TreeNode(2);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(1);\n\n    TreeNode* root2 = new TreeNode(2);\n    root2->right = new TreeNode(3);\n    root2->left = new TreeNode(1);\n\n    TreeNode* root3 = new TreeNode(1);\n    root3->right = new TreeNode(0);\n\n    cout << pseudoPalindromicPaths(root1) << endl; // 1\n    cout << pseudoPalindromicPaths(root2) << endl; // 0\n    cout << pseudoPalindromicPaths(root3) << endl; // 1\n\n    return 0;\n}\n```",
  "1458": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxDotProduct(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size();\n        int m = nums2.size();\n        \n        if (n == 0 || m == 0)\n            return 0;\n        \n        vector<vector<int>> dp(n+1, vector<int>(m+1));\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (nums1[i-1] > nums2[j-1])\n                    dp[i][j] = dp[i-1][j];\n                else\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n        \n        return dp[n][m];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<int> nums1 = {2,1,-3,5};\n    vector<int> nums2 = {-2,5,0,-1,7};\n    cout << \"Test case 1: \" << solution.maxDotProduct(nums1, nums2) << endl;\n\n    // Test case 2:\n    nums1.clear(); nums1.push_back(-4); nums1.push_back(3);\n    nums2.clear(); nums2.push_back(5); nums2.push_back(0); nums2.push_back(-3);\n    cout << \"Test case 2: \" << solution.maxDotProduct(nums1, nums2) << endl;\n\n    // Test case 3:\n    nums1.clear(); nums1.push_back(1); nums1.push_back(-4); nums1.push_back(7);\n    nums2.clear(); nums2.push_back(5); nums2.push_back(-6); nums2.push_back(-2);\n    cout << \"Test case 3: \" << solution.maxDotProduct(nums1, nums2) << endl;\n\n    return 0;\n}\n```",
  "1459": "```\n#include <iostream>\n#include <vector>\n\nlong long rectangleArea(std::vector<std::vector<int>>& points) {\n    int n = points.size();\n    if (n < 2)\n        return 0;\n\n    std::sort(points.begin(), points.end(),\n              [](const auto& p1, const auto& p2) { \n                  return p1[0] == p2[0] ? p1[1] < p2[1] : p1[0] < p2[0];\n              });\n\n    long long res = 0;\n    for (int i = 0; i < n - 3; i++) {\n        if ((points[i][0] == points[i + 1][0] && \n             points[i][1] != points[i + 1][1]) || \n            (points[i][0] != points[i + 1][0] && \n             points[i][1] == points[i + 1][1])) {\n            long long width = i > 0 ? points[i][0] - points[i - 1][0] : points[i][0];\n            for (int j = i + 2; j < n - 1; j++) {\n                if ((points[j][0] == points[j + 1][0] && \n                     points[j][1] != points[j + 1][1]) || \n                    (points[j][0] != points[j + 1][0] && \n                     points[j][1] == points[j + 1][1])) {\n                    long long height = j > i + 1 ? points[j][1] - points[i + 1][1] : points[j][1];\n                    res += width * height;\n                    break;\n                }\n            }\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<std::vector<int>> points1 = {{0,9},{2,6},{4,5},{7,3},{8,1}};\n    std::cout << \"Test case 1: \" << rectangleArea(points1) << std::endl;\n\n    std::vector<std::vector<int>> points2 = {{1,1},{2,2},{4,4},{4,8},{10,10}};\n    std::cout << \"Test case 2: \" << rectangleArea(points2) << std::endl;\n\n    std::vector<std::vector<int>> points3 = {{0,0},{9,6}};\n    std::cout << \"Test case 3: \" << rectangleArea(points3) << std::endl;\n\n    return 0;\n}\n```",
  "1461": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool hasAllCodes(string s, int k) {\n        set<string> codes;\n        for (int i = 0; i <= s.length() - k; i++) {\n            string code = s.substr(i, k);\n            codes.insert(code);\n        }\n        return codes.size() == (1 << k);\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.hasAllCodes(\"00110100\", 4) << endl; // true\n    cout << solution.hasAllCodes(\"011011\", 2) << endl; // true\n    cout << solution.hasAllCodes(\"011100\", 3) << endl; // false\n    return 0;\n}\n```",
  "1460": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool canBeEqual(const std::vector<int>& target, const std::vector<int>& arr) {\n    if (target.size() != arr.size()) return false;\n\n    int oneCount = 0;\n    for (int i = 0; i < target.size(); ++i) {\n        if (target[i] != arr[i]) {\n            if ((target[i] | arr[i]) == target[i]) oneCount++;\n            else oneCount--;\n        }\n    }\n\n    return oneCount == 0;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << canBeEqual({1,2,3,4}, {1,3,2,4}) << \"\\n\"; // true\n    std::cout << canBeEqual({1,1,1,1}, {1,5,9,12}) << \"\\n\"; // false\n    std::cout << canBeEqual({3,7,1}, {3,2,1,4,7}) << \"\\n\"; // true\n    return 0;\n}\n```",
  "1462": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int n = numCourses;\n        vector<int> in(n, 0);\n        vector<int> out(n, 0);\n        unordered_map<int, vector<int>> graph;\n\n        for (auto& p : prerequisites) {\n            int x = p[1], y = p[0];\n            graph[x].push_back(y);\n            out[y]++;\n        }\n\n        queue<int> q;\n        for (int i = 0; i < n; ++i)\n            if (!out[i])\n                q.push(i);\n\n        while (q.size()) {\n            int x = q.front();\n            q.pop();\n            --in[x];\n            for (auto y : graph[x]) {\n                --out[y];\n                if (!--in[y])\n                    q.push(y);\n            }\n        }\n\n        for (int i = 0; i < n; ++i)\n            if (in[i])\n                return false;\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    int numCourses1 = 2;\n    vector<vector<int>> prerequisites1 = {{1, 0}};\n    cout << \"Test Case 1: \" << (solution.canFinish(numCourses1, prerequisites1) ? \"True\" : \"False\") << endl;\n\n    // Test Case 2\n    int numCourses2 = 3;\n    vector<vector<int>> prerequisites2 = {{0, 2}, {2, 0}};\n    cout << \"Test Case 2: \" << (solution.canFinish(numCourses2, prerequisites2) ? \"True\" : \"False\") << endl;\n\n    // Test Case 3\n    int numCourses3 = 4;\n    vector<vector<int>> prerequisites3 = {{1, 3}, {0, 2}};\n    cout << \"Test Case 3: \" << (solution.canFinish(numCourses3, prerequisites3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1463": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int cherryPickup(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<vector<vector<vector<int>>>> dp(m, vector<vector<vector<int>>>(n, vector<vector<int>>(2)));\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    int left = dp[i][min(j, n - 1)][0];\n                    int right = dp[i][max(0, min(j + 1, n - 1))][1];\n\n                    for (int k = i - 1; k >= 0; --k) {\n                        if (grid[k][j] == 1) {\n                            left = max(left, grid[k][min(j, n - 1)] + dp[k][min(j, n - 1)][0]);\n                        }\n                        if (grid[k][n - j - 1] == 1) {\n                            right = max(right, grid[k][max(0, min(j + 1, n - 1)) - 1] + dp[k][max(0, min(j + 1, n - 1)) - 1][1]);\n                        }\n                    }\n\n                    int res = left + right;\n                    if (i > 0) {\n                        res += grid[i - 1][j];\n                    }\n                    if (n - j - 1 > 0) {\n                        res += grid[i - 1][n - j - 1];\n                    }\n                    dp[i][j][0] = max(left, right);\n                    dp[i][j][1] = res;\n                } else {\n                    dp[i][j][0] = 0;\n                    dp[i][j][1] = 0;\n                }\n            }\n        }\n\n        return dp[m - 1][n / 2][1];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> grid1 = {{0, 1, 1}, {1, 0, 0}, {0, 0, 0}};\n    cout << \"Test case 1: \" << solution.cherryPickup(grid1) << endl;\n    \n    // Test case 2\n    vector<vector<int>> grid2 = {{1, 1, 1, 1}, {1, 0, 0, 1}, {1, 0, 0, 1}, {1, 0, 0, 1}};\n    cout << \"Test case 2: \" << solution.cherryPickup(grid2) << endl;\n    \n    // Test case 3\n    vector<vector<int>> grid3 = {{0, 0, 1}, {1, 0, 0}, {0, 0, 0}};\n    cout << \"Test case 3: \" << solution.cherryPickup(grid3) << endl;\n\n    return 0;\n}\n```",
  "1464": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxProduct(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    return (nums[nums.size() - 1] - 1) * (nums[nums.size() - 2] - 1);\n}\n\nint main() {\n    std::vector<int> test1 = {3, 2};\n    std::cout << \"Test 1: \" << maxProduct(test1) << std::endl;\n\n    std::vector<int> test2 = {1, 5, 10};\n    std::cout << \"Test 2: \" << maxProduct(test2) << std::endl;\n\n    std::vector<int> test3 = {4, 2, 5, 6};\n    std::cout << \"Test 3: \" << maxProduct(test3) << std::endl;\n}",
  "1465": "```\n#include <iostream>\n#include <vector>\n\nint maxArea(std::vector<int>& height) {\n    int n = height.size();\n    int left = 0, right = n - 1;\n    int max_area = 0;\n\n    while (left < right) {\n        int area = (right - left) * std::min(height[left], height[right]);\n        if (area > max_area) {\n            max_area = area;\n        }\n\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return max_area;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> height1 = {1,8,0,2};\n    int result1 = maxArea(height1);\n    if (result1 != 4) {\n        std::cout << \"Test case 1 failed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 passed\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> height2 = {5};\n    int result2 = maxArea(height2);\n    if (result2 != 0) {\n        std::cout << \"Test case 2 failed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 passed\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> height3 = {1,1};\n    int result3 = maxArea(height3);\n    if (result3 != 1) {\n        std::cout << \"Test case 3 failed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 passed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1467": "```\n#include <iostream>\n#include <vector>\n\ndouble getProbability(std::vector<int>& n) {\n    int sum = 0;\n    for (int i : n) {\n        sum += i;\n    }\n    \n    double total = static_cast<double>(pow(sum, 2)) / pow(2.0, sum);\n    \n    return total;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {10};\n    double result1 = getProbability(test1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<int> test2 = {1, 2, 3};\n    double result2 = getProbability(test2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<int> test3 = {5, 5};\n    double result3 = getProbability(test3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1466": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findOrder(vector<vector<string>>& orders) {\n        int cityCount = 0;\n        for (const auto& order : orders) {\n            cityCount = max(cityCount, static_cast<int>(order.size()));\n        }\n        \n        if (cityCount == 0) return {};\n        vector<string> res(cityCount, \"0\");\n        for (const auto& order : orders) {\n            for (int i = 1; i < order.size(); ++i) {\n                int src = -1;\n                int dest = -1;\n                for (int j = 0; j < order[i].size() && (src == -1 || dest == -1); ++j) {\n                    if (order[i][j] == ' ') break;\n                    if (isalpha(order[i][j])) src = j;\n                    else dest = j;\n                }\n                while (res[src[0] - '0'] != \"0\" && res[src[0] - '0'] != order[src].substr(1)) {\n                    for (int i = cityCount - 2; i > 0; --i) {\n                        if (res[i] == \"0\") res[i] = to_string(cityCount - 1);\n                        else if (order.find(res[i]) != string::npos) {\n                            res[i] = order[stoi(res[i].substr(1))].substr(0, 1);\n                            for (int j = i + 1; j < cityCount; ++j) res[j] = to_string(stoi(res[j].substr(1)) - 1);\n                        }\n                    }\n                    res[0] = \"0\";\n                }\n                res[src[0] - '0'] = order[dest];\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<string>> orders1 = {{\"E2\", \"E1\", \"E4\", \"E5\"}, {\"E5\", \"E7\"}, {\"E6\", \"E7\", \"E8\"}};\n    cout << \"[\";\n    for (const auto& order : solution.findOrder(orders1)) {\n        cout << \"\\\"\" << order << \"\\\", \";\n    }\n    cout << \"]\" << endl;\n\n    vector<vector<string>> orders2 = {{\"A1\", \"B2\"}, {\"C4\", \"D3\", \"E2\"}, {\"E5\"}};\n    cout << \"[\";\n    for (const auto& order : solution.findOrder(orders2)) {\n        cout << \"\\\"\" << order << \"\\\", \";\n    }\n    cout << \"]\" << endl;\n\n    vector<vector<string>> orders3 = {{\"E1\"}};\n    cout << \"[\";\n    for (const auto& order : solution.findOrder(orders3)) {\n        cout << \"\\\"\" << order << \"\\\", \";\n    }\n    cout << \"]\" << endl;\n    \n    return 0;\n}",
  "1468": "```\n#include <iostream>\n#include <vector>\n\nclass Salary {\npublic:\n    int id;\n    double salary;\n\n    Salary(int id, double salary) : id(id), salary(salary) {}\n};\n\nint calculateSalaries(std::vector<Salary>& salaries, int threshold) {\n    int total = 0;\n    for (const auto& salary : salaries) {\n        if (salary.salary > threshold) {\n            total += static_cast<int>(salary.salary);\n        }\n    }\n    return total;\n}\n\nint main() {\n    std::vector<Salary> salaries1 = {{1, 10000.0}, {2, 20000.0}};\n    int result1 = calculateSalaries(salaries1, 15000.0);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<Salary> salaries2 = {{3, 30000.0}, {4, 40000.0}};\n    int result2 = calculateSalaries(salaries2, 35000.0);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<Salary> salaries3 = {{5, 5000.0}, {6, 6000.0}};\n    int result3 = calculateSalaries(salaries3, 5500.0);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1469": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    vector<TreeNode*> getLonelyNodes(TreeNode* root) {\n        if (!root) return {};\n        vector<TreeNode*> res;\n        if (root->left && !root->right) res.push_back(root->left);\n        else if (!root->left && root->right) res.push_back(root->right);\n        for (TreeNode *node : getLonelyNodes(root->left)) res.push_back(node);\n        for (TreeNode *node : getLonelyNodes(root->right)) res.push_back(node);\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(3);\n    root1->left->left = new TreeNode(4);\n    root1->left->right = new TreeNode(5);\n\n    vector<TreeNode*> res1 = solution.getLonelyNodes(root1);\n    for (TreeNode* node : res1) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(5);\n    root2->right = new TreeNode(7);\n\n    vector<TreeNode*> res2 = solution.getLonelyNodes(root2);\n    for (TreeNode* node : res2) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n\n    vector<TreeNode*> res3 = solution.getLonelyNodes(root3);\n    for (TreeNode* node : res3) {\n        cout << node->val << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1470": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> shuffle(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> res(n);\n        for (int i = 0; i < n; i++) {\n            res[i] = nums[(i + rand() % n) % n];\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    \n    // Test Case 1\n    vector<int> test1 = {1,2,3};\n    vector<int> result1 = s.shuffle(test1);\n    for (auto num : result1) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<int> test2 = {1,1,2,2};\n    vector<int> result2 = s.shuffle(test2);\n    for (auto num : result2) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<int> test3 = {1,1,1,1};\n    vector<int> result3 = s.shuffle(test3);\n    for (auto num : result3) {\n        cout << num << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1471": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint myCompare(int a, int b) {\n    return b - a;\n}\n\nstd::vector<int> kStrongest(std::vector<int>& arr, int k) {\n    std::vector<std::pair<int, int>> pairs;\n    for (int val : arr) {\n        pairs.push_back({val, 1});\n    }\n    std::sort(pairs.begin(), pairs.end(), myCompare);\n    \n    std::vector<int> result;\n    for (int i = 0; i < k && i < pairs.size(); i++) {\n        result.push_back(pairs[i].first);\n    }\n    return result;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> arr1 = {5,4,9,3};\n    int k1 = 1;\n    auto res1 = kStrongest(arr1, k1);\n    for (auto val : res1) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<int> arr2 = {5,7,3,9,2};\n    int k2 = 3;\n    auto res2 = kStrongest(arr2, k2);\n    for (auto val : res2) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<int> arr3 = {1};\n    int k3 = 1;\n    auto res3 = kStrongest(arr3, k3);\n    for (auto val : res3) {\n        std::cout << val << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1472": "```\n#include <iostream>\n#include <vector>\n\nclass BrowserHistory {\npublic:\n    BrowserHistory(int start) {\n        curr = new Node(start);\n        end = curr;\n    }\n    \n    void visit(int url) {\n        Node* newNode = new Node(url);\n        end->next = newNode;\n        end = newNode;\n    }\n    \n    string back(int steps) {\n        for (int i = 0; i < steps && curr != end; i++) {\n            end = end->prev;\n        }\n        return to_string(end->val);\n    }\n    \n    string forward(int steps) {\n        for (int i = 0; i < steps && curr != end; i++) {\n            Node* temp = curr;\n            curr = curr->next;\n            delete temp;\n        }\n        return to_string(curr->val);\n    }\n\nprivate:\n    struct Node {\n        int val;\n        Node* next;\n        Node* prev;\n\n        Node(int x) : val(x), next(NULL), prev(NULL) {}\n    };\n    \n    Node* curr;\n    Node* end;\n};\n\nint main() {\n    BrowserHistory browser(1);\n    \n    browser.visit(3);\n    cout << browser.back(2) << endl;  // returns \"2\"\n    cout << browser.forward(1) << endl;  // returns \"3\"\n    cout << browser.visit(6);\n    cout << browser.forward(1) << endl;  // returns \"6\"\n    cout << browser.visit(8);\n    cout << browser.back(1) << endl;  // returns \"6\"\n    cout << browser.forward(2) << endl;  // returns \"8\"\n    \n    return 0;\n}",
  "1473": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCostII(vector<vector<int>>& costs) {\n        if (costs.empty()) return 0;\n        int n = costs.size();\n        vector<int> dp(n);\n        \n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                dp[i] = min(costs[0][0], costs[0][1]);\n            } else {\n                int prevMin = min(dp[i - 1]);\n                dp[i] = costs[i][0] + prevMin;\n                for (int j = 1; j < 3; j++) {\n                    if (costs[i][j] > prevMin) break;\n                    dp[i] = min(dp[i], costs[i][j] + prevMin);\n                }\n            }\n        }\n        \n        return *min_element(dp.begin(), dp.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> costs1 = {{17, 2, 17}, {16, 16, 5}, {14, 7, 15}};\n    cout << \"Test Case 1: \" << solution.minCostII(costs1) << endl;\n    \n    vector<vector<int>> costs2 = {{3, 4}, {2, 1}, {1, 2}};\n    cout << \"Test Case 2: \" << solution.minCostII(costs2) << endl;\n\n    vector<vector<int>> costs3 = {{10}};\n    cout << \"Test Case 3: \" << solution.minCostII(costs3) << endl;\n    \n    return 0;\n}\n```",
  "1474": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nListNode* removeNthFromEnd(ListNode* head, int m, int n) {\n    ListNode* dummy = new ListNode(0);\n    dummy->next = head;\n    ListNode* first = dummy;\n    for (int i = 0; i < n + m; i++) {\n        first = first->next;\n    }\n    while (first->next != NULL) {\n        first = first->next;\n    }\n    ListNode* temp = head;\n    while (temp.next != first->next) {\n        temp = temp->next;\n    }\n    temp->next = temp->next->next;\n    delete first;\n    return dummy->next;\n}\n\nint main() {\n    // Test Case 1\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(4);\n    head1->next->next->next->next = new ListNode(5);\n    ListNode* result1 = removeNthFromEnd(head1, 2, 1);\n    while (result1 != NULL) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test Case 2\n    head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    ListNode* result2 = removeNthFromEnd(head1, 4, 2);\n    while (result2 != NULL) {\n        cout << result2->val << \" \";\n        result2 = result2->next;\n    }\n    cout << endl;\n\n    // Test Case 3\n    head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    ListNode* result3 = removeNthFromEnd(head1, 1, 1);\n    while (result3 != NULL) {\n        cout << result3->val << \" \";\n        result3 = result3->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1475": "```\n#include <iostream>\n#include <vector>\n\nint finalPrices(std::vector<int>& prices) {\n    int n = prices.size();\n    std::stack<int> s;\n    for (int i = 0; i < n; i++) {\n        while (!s.empty() && s.top() >= prices[i]) {\n            s.pop();\n        }\n        if (!s.empty()) {\n            prices[s.top()] -= prices[i];\n        }\n        s.push(i);\n    }\n    return 0;\n}\n\nint main() {\n    std::vector<int> prices1 = {10, 1, 5, 3};\n    finalPrices(prices1);\n    for (int price : prices1) {\n        std::cout << price << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<int> prices2 = {100};\n    finalPrices(prices2);\n    for (int price : prices2) {\n        std::cout << price << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<int> prices3 = {10, 5, 3, 3, 2, 8, 1};\n    finalPrices(prices3);\n    for (int price : prices3) {\n        std::cout << price << \" \";\n    }\n    std::cout << \"\\n\";\n    return 0;\n}\n```",
  "1476": "```\n#include <iostream>\nusing namespace std;\n\nclass SubrectangleQueries {\npublic:\n    vector<vector<int>> allValues;\n    \n    void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for (int i = row1; i <= row2; ++i) {\n            for (int j = col1; j <= col2; ++j) {\n                allValues[i][j] = newValue;\n            }\n        }\n    }\n    \n    int sumRegions(int row1, int col1, int row2, int col2) {\n        int sum = 0;\n        for (int i = row1; i <= row2; ++i) {\n            for (int j = col1; j <= col2; ++j) {\n                sum += allValues[i][j];\n            }\n        }\n        return sum;\n    }\n};\n\nint main() {\n    SubrectangleQueries sr;\n\n    sr.updateSubrectangle(0, 0, 3, 3, 1);\n    cout << \"Test case 1: Expected 9, got \" << sr.sumRegions(0, 0, 3, 3) << endl; // Test case 1\n    sr.updateSubrectangle(1, 1, 2, 2, 2);\n    cout << \"Test case 2: Expected 4, got \" << sr.sumRegions(0, 0, 3, 3) << endl; // Test case 2\n    sr.updateSubrectangle(2, 2, 4, 4, 3);\n    cout << \"Test case 3: Expected 9, got \" << sr.sumRegions(2, 2, 4, 4) << endl; // Test case 3\n\n    return 0;\n}\n```",
  "1477": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> findSubarrays(vector<int>& nums, int target) {\n        int n = nums.size();\n        vector<vector<int>> res;\n        \n        for (int i = 0; i < n; i++) {\n            int leftSum = 0;\n            for (int j = i; j < n; j++) {\n                leftSum += nums[j];\n                if (leftSum == target) {\n                    vector<int> leftArr;\n                    for (int k = i; k <= j; k++) {\n                        leftArr.push_back(nums[k]);\n                    }\n                    res.push_back(leftArr);\n                    \n                    int rightSum = 0;\n                    for (int j2 = i + j + 1; j2 < n; j2++) {\n                        rightSum += nums[j2];\n                        if (rightSum == target) {\n                            vector<int> rightArr;\n                            for (int k = i + j + 1; k <= j2; k++) {\n                                rightArr.push_back(nums[k]);\n                            }\n                            res.push_back(rightArr);\n                            return res;\n                        }\n                    }\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> nums1 = {0, 1, 1, 1, 1, 0, 1, 1};\n    int target1 = 2;\n    vector<vector<int>> result1 = solution.findSubarrays(nums1, target1);\n    for (const auto& subarray : result1) {\n        cout << \"[\";\n        for (int num : subarray) {\n            cout << num << \" \";\n        }\n        cout << \"]\" << endl;\n    }\n\n    // Test Case 2\n    vector<int> nums2 = {0, 0, 0};\n    int target2 = 0;\n    vector<vector<int>> result2 = solution.findSubarrays(nums2, target2);\n    for (const auto& subarray : result2) {\n        cout << \"[\";\n        for (int num : subarray) {\n            cout << num << \" \";\n        }\n        cout << \"]\" << endl;\n    }\n\n    // Test Case 3\n    vector<int> nums3 = {1, -1, 1};\n    int target3 = 0;\n    vector<vector<int>> result3 = solution.findSubarrays(nums3, target3);\n    for (const auto& subarray : result3) {\n        cout << \"[\";\n        for (int num : subarray) {\n            cout << num << \" \";\n        }\n        cout << \"]\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1478": "```\n#include <iostream>\n#include <vector>\n\nint maxEquationOfMailboxes(std::vector<int>& distance) {\n    int n = distance.size();\n    std::vector<std::pair<int, int>> mailboxes(n);\n    \n    for (int i = 0; i < n; i++) {\n        mailboxes[i].first = i;\n        mailboxes[i].second = distance[i];\n    }\n    \n    std::sort(mailboxes.begin(), mailboxes.end(), [](const auto& a, const auto& b) {\n        return a.second > b.second;\n    });\n    \n    int mailboxesCount = 0;\n    for (int i = 0; i < n; ) {\n        if (mailboxes[i].second >= i + 1) {\n            mailboxesCount++;\n            i += min((n - i), mailboxes[i].second - i);\n        } else {\n            i++;\n        }\n    }\n    \n    return mailboxesCount;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> distance1 = {4, 3};\n    int result1 = maxEquationOfMailboxes(distance1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<int> distance2 = {6, 5, 4};\n    int result2 = maxEquationOfMailboxes(distance2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<int> distance3 = {10, 9, 8, 7};\n    int result3 = maxEquationOfMailboxes(distance3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1480": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> runningSum(std::vector<int>& nums) {\n    for (int i = 1; i < nums.size(); i++) {\n        nums[i] += nums[i - 1];\n    }\n    return nums;\n}\n\nint main() {\n    std::vector<int> nums1 = {1,2,3,4};\n    std::cout << \"Test Case 1: \";\n    for (int num : runningSum(nums1)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums2 = {1,1,1,1};\n    std::cout << \"Test Case 2: \";\n    for (int num : runningSum(nums2)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> nums3 = {3,6,9};\n    std::cout << \"Test Case 3: \";\n    for (int num : runningSum(nums3)) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```",
  "1479": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass SalesByDay {\npublic:\n    vector<int> dailyTemperatures(vector<string>& T) {\n        int n = T.size();\n        vector<int> res(n);\n        for (int i = 0; i < n; ++i) {\n            while (i + 1 < n && T[i][T[i].size() - 1] == T[i+1][0]) {\n                i++;\n            }\n            res[i] = i + 1 - (i > 0 ? res[i-1] : 0);\n        }\n        return res;\n    }\n};\n\nint main() {\n    SalesByDay salesByDay;\n\n    // Test Case 1\n    vector<string> T1 = {\"18:00\", \"09:00\", \"15:00\", \"16:00\"};\n    vector<int> result1 = salesByDay.dailyTemperatures(T1);\n    for (int i : result1) {\n        cout << i << endl;\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<string> T2 = {\"1:01\", \"4:00\", \"3:00\", \"0:59\"};\n    vector<int> result2 = salesByDay.dailyTemperatures(T2);\n    for (int i : result2) {\n        cout << i << endl;\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<string> T3 = {\"20:00\", \"10:00\"};\n    vector<int> result3 = salesByDay.dailyTemperatures(T3);\n    for (int i : result3) {\n        cout << i << endl;\n    }\n\n    return 0;\n}\n```",
  "1481": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findLeastNumOfUniqueInts(vector<int>& arr, int k) {\n        unordered_map<int, int> count;\n        for (int num : arr) {\n            count[num]++;\n        }\n        \n        sort(count.begin(), count.end());\n        \n        while (k > 0) {\n            if (count.begin()->second <= k) {\n                k -= count.begin()->second;\n                count.erase(count.begin());\n            } else {\n                break;\n            }\n        }\n        \n        return count.size();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> arr1 = {5,7,3,9,2,5,8};\n    int k1 = 2;\n    cout << \"Test case 1: \" << solution.findLeastNumOfUniqueInts(arr1, k1) << endl;\n\n    // Test case 2\n    vector<int> arr2 = {4,3,1,1,3,3};\n    int k2 = 3;\n    cout << \"Test case 2: \" << solution.findLeastNumOfUniqueInts(arr2, k2) << endl;\n\n    // Test case 3\n    vector<int> arr3 = {1,1,2,3,5};\n    int k3 = 6;\n    cout << \"Test case 3: \" << solution.findLeastNumOfUniqueInts(arr3, k3) << endl;\n\n    return 0;\n}\n```",
  "1482": "```\n#include <iostream>\n#include <vector>\n\nint minDays(std::vector<int>& bloomDay) {\n    int n = bloomDay.size();\n    int res = INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        int left = i, right = n - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (bloomDay[mid] > bloomDay[i]) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        res = std::min(res, left);\n    }\n    return res + 1;\n}\n\nint main() {\n    std::vector<int> bloomDay1 = {1,4,3};\n    std::cout << \"Minimum days for \" << bloomDay1.size() << \" bouquets: \" << minDays(bloomDay1) << std::endl;\n\n    std::vector<int> bloomDay2 = {2,6,8,5,4,3};\n    std::cout << \"Minimum days for \" << bloomDay2.size() << \" bouquets: \" << minDays(bloomDay2) << std::endl;\n\n    std::vector<int> bloomDay3 = {9};\n    std::cout << \"Minimum days for \" << bloomDay3.size() << \" bouquet: \" << minDays(bloomDay3) << std::endl;\n\n    return 0;\n}\n```",
  "1483": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* getKthParent(TreeNode* root, int k) {\n        if (!root)\n            return NULL;\n\n        if (k == 1) \n            return root; \n\n        TreeNode* curr = root;\n        while (curr && k > 1) {\n            if (curr->left && k % 2 == 1) {\n                curr = curr->right;\n                k--;\n            } else {\n                curr = curr->left;\n                k /= 2;\n            }\n        }\n\n        return curr;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root = new TreeNode(0);\n    root->left = new TreeNode(1);\n    root->right = new TreeNode(2);\n    root->left->left = new TreeNode(3);\n    root->left->right = new TreeNode(4);\n\n    TreeNode* kthParent = solution.getKthParent(root, 3);\n    if (kthParent)\n        cout << \"Kth parent is: \" << kthParent->val << endl;\n    else\n        cout << \"No such parent exists.\" << endl;\n\n    // Test case 2\n    root = new TreeNode(0);\n\n    kthParent = solution.getKthParent(root, 1);\n    if (kthParent)\n        cout << \"Kth parent is: \" << kthParent->val << endl;\n    else\n        cout << \"No such parent exists.\" << endl;\n\n    // Test case 3\n    root = new TreeNode(0);\n\n    kthParent = solution.getKthParent(root, 4);\n    if (kthParent)\n        cout << \"Kth parent is: \" << kthParent->val << endl;\n    else\n        cout << \"No such parent exists.\" << endl;\n\n    return 0;\n}",
  "1484": "```\n#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nstruct Solution {\n    vector<vector<string>> groupThePeople(vector<int> age, int numGroups) {\n        map<int, vector<string>> res;\n        for (int i = 0; i < age.size(); ++i) {\n            if (res.find(age[i] % numGroups) == res.end()) {\n                res[age[i] % numGroups].push_back(to_string(i + 1));\n            } else {\n                res[age[i] % numGroups].back() += \", \" + to_string(i + 1);\n            }\n        }\n        vector<vector<string>> result;\n        for (auto& x : res) {\n            result.push_back(x.second);\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> age1 = {4,5,6,10,11};\n    int numGroups1 = 5;\n    vector<vector<string>> res1 = solution.groupThePeople(age1, numGroups1);\n    for (auto& group : res1) {\n        cout << \"[\";\n        for (auto& person : group) {\n            cout << person << \" \";\n        }\n        cout << \"]\\n\";\n    }\n\n    // Test case 2\n    vector<int> age2 = {1,1,3,4};\n    int numGroups2 = 3;\n    vector<vector<string>> res2 = solution.groupThePeople(age2, numGroups2);\n    for (auto& group : res2) {\n        cout << \"[\";\n        for (auto& person : group) {\n            cout << person << \" \";\n        }\n        cout << \"]\\n\";\n    }\n\n    // Test case 3\n    vector<int> age3 = {1};\n    int numGroups3 = 10;\n    vector<vector<string>> res3 = solution.groupThePeople(age3, numGroups3);\n    for (auto& group : res3) {\n        cout << \"[\";\n        for (auto& person : group) {\n            cout << person << \" \";\n        }\n        cout << \"]\\n\";\n    }\n\n    return 0;\n}\n```",
  "1486": "```\n#include <iostream>\n#include <vector>\n\nint singleNumber(std::vector<int>& nums) {\n    int result = 0;\n    for (int num : nums) {\n        result ^= num;\n    }\n    return result;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \";\n    std::vector<int> test1 = {2, 2, 3, 2};\n    std::cout << singleNumber(test1) << std::endl; // Output: 3\n\n    std::cout << \"Test Case 2: \";\n    std::vector<int> test2 = {0};\n    std::cout << singleNumber(test2) << std::endl; // Output: 0\n\n    std::cout << \"Test Case 3: \";\n    std::vector<int> test3 = {9, 1, 7, 3, 5, 9, 4, 2];\n    std::cout << singleNumber(test3) << std::endl; // Output: 9\n    return 0;\n}\n```",
  "1485": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    Node* left;\n    Node* right;\n    Node* random;\n};\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        if (head == nullptr) return nullptr;\n\n        // Step 1: Create a copy for each node\n        Node* current = head;\n        while (current != nullptr) {\n            Node* newNode = new Node();\n            newNode->val = current->val;\n            newNode->left = current->left;\n            newNode->right = current->right;\n            newNode->random = nullptr; // We will update this later\n\n            if (current->left != nullptr) {\n                newNode->left = new Node();\n                (newNode->left)->val = current->left->val;\n                (newNode->left)->left = current->left->left;\n                (newNode->left)->right = current->left->right;\n                (newNode->left)->random = nullptr; // We will update this later\n            }\n\n            if (current->right != nullptr) {\n                newNode->right = new Node();\n                (newNode->right)->val = current->right->val;\n                (newNode->right)->left = current->right->left;\n                (newNode->right)->right = current->right->right;\n                (newNode->right)->random = nullptr; // We will update this later\n            }\n\n            current = current->next;\n        }\n\n        // Step 2: Update the random pointer for each node\n        current = head;\n        while (current != nullptr) {\n            if (current->random != nullptr) {\n                (current->copy)->random = current->random->copy;\n            }\n            current = current->next;\n        }\n\n        return head->copy;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    Node* head1 = new Node();\n    head1->val = 1;\n    head1->left = new Node();\n    head1->left->val = 2;\n    head1->right = new Node();\n    head1->right->val = 3;\n\n    head1->left->random = head1->right;\n    head1->right->random = head1->left;\n\n    Node* copyHead1 = solution.copyRandomList(head1);\n    // Your code here\n\n    // Test case 2\n    Node* head2 = new Node();\n    head2->val = 4;\n    head2->left = new Node();\n    head2->left->val = 5;\n\n    head2->right = new Node();\n    head2->right->val = 6;\n    head2->right->random = head2->left;\n\n    Node* copyHead2 = solution.copyRandomList(head2);\n    // Your code here\n\n    // Test case 3\n    Node* head3 = nullptr; // Empty tree, just return null\n\n    Node* copyHead3 = solution.copyRandomList(head3);\n\n    return 0;\n}",
  "1487": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool makeUnique(std::vector<std::string>& folders) {\n    std::unordered_map<std::string, int> dirMap;\n    for (int i = 0; i < folders.size(); i++) {\n        if (!dirMap.count(folders[i])) {\n            dirMap[folders[i]] = 1;\n        } else {\n            int index = dirMap[folders[i]];\n            while (true) {\n                folders[i] += to_string(index);\n                if (!dirMap.count(folders[i])) {\n                    dirMap[folders[i]] = index + 1;\n                    break;\n                }\n                index++;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<std::string> folders1 = {\"root/a\", \"root/c\", \"root\"};\n    makeUnique(folders1);\n    for (const auto& folder : folders1) {\n        std::cout << folder << std::endl;\n    }\n    std::cout << std::endl;\n\n    std::vector<std::string> folders2 = {\"/a\", \"/c\", \"/\", \"/a\", \"/b\"};\n    makeUnique(folders2);\n    for (const auto& folder : folders2) {\n        std::cout << folder << std::endl;\n    }\n    std::cout << std::endl;\n\n    std::vector<std::string> folders3 = {\"/root/a\", \"/root/c\", \"/root/d\", \"/root/e\"};\n    makeUnique(folders3);\n    for (const auto& folder : folders3) {\n        std::cout << folder << std::endl;\n    }\n    return 0;\n}\n```",
  "1488": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findPeople(int heightMap[1001][1001], int startRow, int startCol, int endRow, int endCol) {\n        queue<pair<int, pair<int, int>>> q;\n        vector<vector<bool>> visited(1001, vector<bool>(1001));\n        vector<int> result;\n        \n        // Start from the start point\n        for (int i = -1; i <= 1; ++i) {\n            for (int j = -1; j <= 1; ++j) {\n                if (i == 0 && j == 0) continue;\n                int newRow = startRow + i, NewCol = startCol + j;\n                if (newRow >= 0 && newRow < 1001 && NewCol >= 0 && NewCol < 1001 \n                    && heightMap[newRow][NewCol] <= heightMap[startRow][startCol]) {\n                    q.push({heightMap[newRow][NewCol], {newRow, NewCol}});\n                    visited[newRow][NewCol] = true;\n                }\n            }\n        }\n        \n        while (!q.empty()) {\n            pair<int, int> curr = q.front(); q.pop();\n            if (curr.second == endRow && curr.first == heightMap[endRow][endCol]) return result;\n            \n            for (int i = -1; i <= 1; ++i) {\n                for (int j = -1; j <= 1; ++j) {\n                    if (i == 0 && j == 0) continue;\n                    int newRow = curr.second.first + i, NewCol = curr.second.second + j;\n                    if (newRow >= 0 && newRow < 1001 && NewCol >= 0 && NewCol < 1001 \n                        && heightMap[newRow][NewCol] <= heightMap[curr.second.first][curr.second.second] \n                        && !visited[newRow][NewCol]) {\n                        q.push({heightMap[newRow][NewCol], {newRow, NewCol}});\n                        visited[newRow][NewCol] = true;\n                    }\n                }\n            }\n        }\n        \n        return vector<int>();\n    }\n\n};\n\nint main() {\n    Solution solution;\n\n    int heightMap1[1001][1001] = {{0, 2, 0}, {0, 1, 0}};\n    int startRow1 = 0, startCol1 = 0, endRow1 = 1, endCol1 = 1;\n    vector<int> result1 = solution.findPeople(heightMap1, startRow1, startCol1, endRow1, endCol1);\n    cout << \"Test Case 1: \";\n    for (int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    int heightMap2[1001][1001] = {{0, 4, 3}, {0, 2, 0}};\n    int startRow2 = 0, startCol2 = 0, endRow2 = 1, endCol2 = 2;\n    vector<int> result2 = solution.findPeople(heightMap2, startRow2, startCol2, endRow2, endCol2);\n    cout << \"Test Case 2: \";\n    for (int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    int heightMap3[1001][1001] = {{0, 1, 2, 3}, {0, 4, 5, 6}};\n    int startRow3 = 0, startCol3 = 0, endRow3 = 1, endCol3 = 3;\n    vector<int> result3 = solution.findPeople(heightMap3, startRow3, startCol3, endRow3, endCol3);\n    cout << \"Test Case 3: \";\n    for (int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1489": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {\n        vector<pair<int, pair<int, int>>> edgeList;\n        for (const auto& e : edges) {\n            edgeList.emplace_back(e[2], make_pair(e[0], e[1]));\n        }\n        sort(edgeList.begin(), edgeList.end());\n\n        vector<int> parent(n);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n\n        int pseudoCriticalEdges = 0;\n        for (const auto& e : edgeList) {\n            if (find(parent, make_pair(e.second.first)) == find(parent, make_pair(e.second.second))) {\n                continue;\n            }\n            if (find(parent, make_pair(e.second.first)) != find(parent, make_pair(e.second.second))) {\n                pseudoCriticalEdges++;\n                unionSet(parent, e.second.first, e.second.second);\n            } else {\n                int root = find(parent, e.second.first);\n                for (int i = 0; i < n; ++i) {\n                    if (find(parent, make_pair(i)) == root) {\n                        parent[i] = e.second.second;\n                    }\n                }\n            }\n        }\n\n        vector<vector<int>> criticalEdges;\n        int criticalEdgesCount = 0;\n        for (int i = 1; i < edgeList.size(); ++i) {\n            if (find(parent, make_pair(edgeList[i-1].second.first)) != find(parent, make_pair(edgeList[i].second.second))) {\n                criticalEdges.emplace_back({edgeList[i-1][2], edgeList[i][2]});\n                criticalEdgesCount++;\n            }\n        }\n\n        vector<vector<int>> result = {{criticalEdgesCount}, {pseudoCriticalEdges}};\n        return {{result.begin(), result.end()}};\n    }\n\nprivate:\n    int find(vector<int>& parent, pair<int, int> node) {\n        if (parent[node.first] == node.second) {\n            return node.first;\n        }\n        parent[node.first] = node.second;\n        return node.second;\n    }\n\n    void unionSet(vector<int>& parent, int a, int b) {\n        a = find(parent, make_pair(a, a));\n        b = find(parent, make_pair(b, b));\n        if (a != b) {\n            parent[b] = a;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> edges1 = {{0,1,10},{5,2,15},{6,3,4},{8,7,6},{1,2,3}};\n    vector<vector<int>> expected1 = {{1}, {1}};\n    auto result1 = solution.findCriticalAndPseudoCriticalEdges(8, edges1);\n    for (int i = 0; i < result1.size(); ++i) {\n        for (int j = 0; j < result1[i].size(); ++j) {\n            cout << result1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> edges2 = {{0,1,4},{1,2,5},{2,3,1},{1,3,5},{10,2,7}};\n    vector<vector<int>> expected2 = {{1}, {2}};\n    auto result2 = solution.findCriticalAndPseudoCriticalEdges(6, edges2);\n    for (int i = 0; i < result2.size(); ++i) {\n        for (int j = 0; j < result2[i].size(); ++j) {\n            cout << result2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> edges3 = {{1,2,6},{2,5,10},{4,5,8},{3,7,14},{0,2,4},{1,4,7},{4,3,9}};\n    vector<vector<int>> expected3 = {{2}, {1}};\n    auto result3 = solution.findCriticalAndPseudoCriticalEdges(11, edges3);\n    for (int i = 0; i < result3.size(); ++i) {\n        for (int j = 0; j < result3[i].size(); ++j) {\n            cout << result3[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1490": "```\n#include <iostream>\n#include <vector>\n\nstruct Node {\n    int val;\n    std::vector<Node*> children;\n\n    Node(int _val) : val(_val) {}\n};\n\nNode* cloneTree(Node* root) {\n    if (!root)\n        return nullptr;\n    \n    Node* cloned = new Node(root->val);\n    for (auto child : root->children) {\n        cloned->children.push_back(cloneTree(child));\n    }\n    return cloned;\n}\n\nvoid printTree(Node* root, int depth = 0) {\n    std::cout << \"Depth \" << depth << \": \" << root->val << std::endl;\n    for (int i = 0; i < depth; ++i)\n        std::cout << \" \";\n    for (auto child : root->children) {\n        printTree(child, depth + 1);\n    }\n}\n\nint main() {\n    Node* root = new Node(1);\n    root->children.push_back(new Node(2));\n    root->children.push_back(new Node(3));\n    root->children[0]->children.push_back(new Node(4));\n    root->children[0]->children.push_back(new Node(5));\n\n    Node* clonedRoot = cloneTree(root);\n\n    std::cout << \"Original Tree:\" << std::endl;\n    printTree(root);\n    std::cout << std::endl;\n\n    std::cout << \"Cloned Tree:\" << std::endl;\n    printTree(clonedRoot);\n    std::cout << std::endl;\n\n    root = new Node(1);\n    root->children.push_back(new Node(2));\n    root->children[0]->children.push_back(new Node(3));\n\n    clonedRoot = cloneTree(root);\n\n    std::cout << \"Original Tree:\" << std::endl;\n    printTree(root);\n    std::cout << std::endl;\n\n    std::cout << \"Cloned Tree:\" << std::endl;\n    printTree(clonedRoot);\n    std::cout << std::endl;\n\n    root = nullptr;\n\n    clonedRoot = cloneTree(root);\n\n    std::cout << \"Original Tree:\" << std::endl;\n    printTree(root);\n    std::cout << std::endl;\n\n    std::cout << \"Cloned Tree:\" << std::endl;\n    printTree(clonedRoot);\n    std::cout << std::endl;\n\n    return 0;\n}",
  "1491": "```\n#include <iostream>\n#include <vector>\n\ndouble averageSalary(std::vector<int>& salary) {\n    int total = 0;\n    for (int i : salary) {\n        total += i;\n    }\n    return (total - *(salary.begin()) - *std::max_element(salary.begin(), salary.end())) / (salary.size() - 2.0);\n}\n\nint main() {\n    std::vector<int> salary1 = {100000, 200000, 30000};\n    double result1 = averageSalary(salary1);\n    if (result1 == 200000) {\n        std::cout << \"Test case 1 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 200000, Got: \" << result1 << std::endl;\n    }\n\n    std::vector<int> salary2 = {50000, 50000};\n    double result2 = averageSalary(salary2);\n    if (result2 == 50000) {\n        std::cout << \"Test case 2 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 50000, Got: \" << result2 << std::endl;\n    }\n\n    std::vector<int> salary3 = {1, 12};\n    double result3 = averageSalary(salary3);\n    if (std::abs(result3 - 10.5) < 0.01) {\n        std::cout << \"Test case 3 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 10.5, Got: \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1492": "```\n#include <iostream>\n#include <vector>\n\nint findKthFactor(int n, int k) {\n    for (long long i = 1; ; i++) {\n        if (n % i == 0) {\n            if (++k == 1)\n                return i;\n        } else\n            break;\n    }\n    return -1;\n}\n\nint main() {\n    std::cout << \"Test case 1: n = 4, k = 2. Expected result: 2. Actual result: \" << findKthFactor(4, 2) << std::endl;\n    if (findKthFactor(4, 2) == 2)\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    else\n        std::cout << \"Test case 1 failed.\" << std::endl;\n\n    std::cout << \"Test case 2: n = 7, k = 3. Expected result: 3 or 7. Actual result: \" << findKthFactor(7, 3) << std::endl;\n    if (findKthFactor(7, 3) == 3 || findKthFactor(7, 3) == 7)\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    else\n        std::cout << \"Test case 2 failed.\" << std::endl;\n\n    std::cout << \"Test case 3: n = 13, k = 4. Expected result: 13. Actual result: \" << findKthFactor(13, 4) << std::endl;\n    if (findKthFactor(13, 4) == 13)\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    else\n        std::cout << \"Test case 3 failed.\" << std::endl;\n\n    return 0;\n}\n```",
  "1493": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        \n        int n = nums.size();\n        int maxLen = 0, lastZeroIndex = -1;\n        \n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) {\n                lastZeroIndex = i;\n                break;\n            }\n        }\n        \n        int left = 0, right = 0;\n        while (right < n) {\n            if (nums[right] == 1) {\n                right++;\n            } else {\n                left = right + 1;\n                right = lastZeroIndex;\n            }\n            \n            maxLen = max(maxLen, right - left);\n        }\n        \n        return maxLen;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<int> nums1 = {1,1,0,1};\n    cout << \"Test Case 1: \" << solution.longestSubarray(nums1) << endl;  // Output: 3\n    \n    vector<int> nums2 = {0,1,1,1,0,1,1,1};\n    cout << \"Test Case 2: \" << solution.longestSubarray(nums2) << endl;  // Output: 5\n    \n    vector<int> nums3 = {1,0,1,1,0,1};\n    cout << \"Test Case 3: \" << solution.longestSubarray(nums3) << endl;  // Output: 4\n    \n    return 0;\n}\n```",
  "1494": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint minimumTime(int n, vector<vector<int>>& relation) {\n    vector<int> indegree(n + 1);\n    for (auto& pair : relation) {\n        int u = pair[0], v = pair[1];\n        indegree[v]++;\n    }\n    int time = 0;\n    queue<int> q;\n    for (int i = 1; i <= n; i++) {\n        if (indegree[i] == 0) {\n            q.push(i);\n        }\n    }\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        time++;\n        for (auto& pair : relation) {\n            if (pair[0] == u) {\n                indegree[pair[1]]--;\n                if (indegree[pair[1]] == 0) {\n                    q.push(pair[1]);\n                }\n            }\n        }\n    }\n    return time;\n}\n\nint main() {\n    // Test Case 1\n    int n = 3;\n    vector<vector<int>> relation = {{1,2},{2,3}};\n    cout << minimumTime(n, relation) << endl; // Output: 3\n\n    // Test Case 2\n    n = 4;\n    relation = {{1,2},{2,3},{3,4}};\n    cout << minimumTime(n, relation) << endl; // Output: 4\n\n    // Test Case 3\n    n = 5;\n    relation = {{1,2},{2,3},{3,4},{4,5}};\n    cout << minimumTime(n, relation) << endl; // Output: 5\n}\n```",
  "1495": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint totalFruit(std::vector<std::string> fruits) {\n    if (fruits.empty()) return 0;\n    \n    int maxCount = 0, currentCount = 1, uniqueFruits = 1;\n    char prevFruit = fruits[0][0];\n    \n    for (int i = 1; i < fruits.size(); ++i) {\n        char fruit = fruits[i][0];\n        \n        if (fruit == prevFruit)\n            currentCount++;\n        else {\n            maxCount = std::max(maxCount, currentCount);\n            currentCount = 1;\n            uniqueFruits++;\n            prevFruit = fruit;\n        }\n    }\n    \n    return std::max(maxCount, currentCount);\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::string> fruits1 = {\"apple\", \"apple\", \"banana\"};\n    std::cout << totalFruit(fruits1) << std::endl; // Output: 2\n\n    // Test case 2\n    std::vector<std::string> fruits2 = {\"apple\", \"banana\", \"apple\", \"banana\", \"banana\"};\n    std::cout << totalFruit(fruits2) << std::endl; // Output: 3\n\n    // Test case 3\n    std::vector<std::string> fruits3 = {\"apple\", \"apple\", \"apple\", \"orange\", \"orange\", \"banana\", \"banana\", \"banana\"};\n    std::cout << totalFruit(fruits3) << std::endl; // Output: 4\n\n    return 0;\n}\n```",
  "1496": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nbool isPathCrossing(string path) {\n    unordered_map<char, int> dirCount;\n    int x = 0, y = 0;\n\n    for (char c : path) {\n        if (c == 'N') y++;\n        else if (c == 'S') y--;\n        else if (c == 'E') x++;\n        else if (c == 'W') x--;\n\n        dirCount[c] = (dirCount.find(c) != dirCount.end()) ? dirCount[c] + 1 : 1;\n    }\n\n    return !((x == 0 && y == 0) || any_of(dirCount.begin(), dirCount.end(), [](auto& p) { return p.second > 1; }));\n}\n\nint main() {\n    cout << isPathCrossing(\"NESWW\") << endl; // Expected: true\n    cout << isPathCrossing(\"WNEESWNW\") << endl; // Expected: false\n    cout << isPathCrossing(\"WNWWN\") << endl; // Expected: true\n\n    return 0;\n}\n```",
  "1497": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canArrange(vector<int>& arr, int k) {\n        int n = arr.size();\n        vector<int> odd(2*k + 1, 0);\n        vector<int> even(2*k + 1, 0);\n\n        for (int i : arr) {\n            if (i % 2 == 0) even[i%k]++; \n            else odd[i%k]++;\n        }\n        \n        if (odd[0] > 0 || even[k%k] > 0)\n            return false;\n        \n        for (int i = 1; i < k; i++) {\n            if ((odd[i] + even[k-i]) % 2 != 0) \n                return false;\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> arr1 = {1,2,3,4,5};\n    int k1 = 3;\n    cout << \"Test case 1: \" << (solution.canArrange(arr1, k1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    vector<int> arr2 = {0,2,4};\n    int k2 = 3;\n    cout << \"Test case 2: \" << (solution.canArrange(arr2, k2) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    vector<int> arr3 = {18,35,47,11};\n    int k3 = 10;\n    cout << \"Test case 3: \" << (solution.canArrange(arr3, k3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1498": "```\n#include <iostream>\n#include <vector>\n\nint numSubseqs(std::vector<int>& nums, int target) {\n    int n = nums.size();\n    std::sort(nums.begin(), nums.end());\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        int left = i, right = n - 1;\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] + nums[i] > target) {\n                right = mid - 1;\n            } else {\n                res += pow(2, right - left + 1);\n                left = mid + 1;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {4,6,5,5};\n    int target1 = 6;\n    std::cout << numSubseqs(nums1, target1) << \"\\n\";\n\n    std::vector<int> nums2 = {3,5,7,9};\n    int target2 = 12;\n    std::cout << numSubseqs(nums2, target2) << \"\\n\";\n\n    std::vector<int> nums3 = {1,2,3,4};\n    int target3 = 8;\n    std::cout << numSubseqs(nums3, target3) << \"\\n\";\n    \n    return 0;\n}\n\n#include <cmath>\n```",
  "1499": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxValue(int n, std::vector<int>& indices, int maxSum) {\n    std::vector<int> sortedIndices = indices;\n    std::sort(sortedIndices.begin(), sortedIndices.end());\n    \n    for (int i = 0; i < n; i++) {\n        if (sortedIndices[i] - i > maxSum) {\n            return i + 1;\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int n1 = 5;\n    std::vector<int> indices1 = {2, 10, 6, 4, 8};\n    int maxSum1 = 10;  \n    std::cout << \"Test case 1: \" << maxValue(n1, indices1, maxSum1) << std::endl;\n\n    int n2 = 9;\n    std::vector<int> indices2 = {7, 3, 8, 5, 4, 2};\n    int maxSum2 = 11;  \n    std::cout << \"Test case 2: \" << maxValue(n2, indices2, maxSum2) << std::endl;\n\n    int n3 = 10;\n    std::vector<int> indices3 = {5, 1, 9, 7, 4, 6, 8};\n    int maxSum3 = 13;  \n    std::cout << \"Test case 3: \" << maxValue(n3, indices3, maxSum3) << std::endl;\n    \n    return 0;\n}",
  "1500": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass FileSharingSystem {\npublic:\n    unordered_map<string, int> files;\n    priority_queue<pair<int, string>, vector<pair<int, string>>, greater<pair<int, string>>> pq;\n\n    void createFile(string filename) {\n        files[filename] = 0;\n        pq.push({0, filename});\n    }\n\n    void deleteUser(string filename) {\n        if (files.find(filename) != files.end()) {\n            files.erase(filename);\n            pq.remove({0, filename}); // Remove the file from priority queue\n        }\n    }\n\n    int getMostVisitedPage() {\n        return pq.top().first;\n    }\n};\n\nint main() {\n    FileSharingSystem system;\n\n    // Test Case 1: Create a file and get most visited page\n    system.createFile(\"file1\");\n    cout << \"Most visited page for file1: \" << system.getMostVisitedPage() << endl; // Output: 0\n\n    // Test Case 2: Add users to multiple files\n    system.createFile(\"file2\");\n    system.createFile(\"file3\");\n\n    system.files[\"file1\"].++;\n    system.files[\"file2\"].++;\n\n    cout << \"Most visited page for file1: \" << system.getMostVisitedPage() << endl; // Output: 1\n    cout << \"Most visited page for file2: \" << system.getMostVisitedPage() << endl; // Output: 1\n\n    system.files[\"file3\"]++;\n    cout << \"Most visited page for file3: \" << system.getMostVisitedPage() << endl; // Output: 2\n\n    // Test Case 3: Delete a user and check most visited page\n    system.deleteUser(\"file1\");\n    cout << \"Most visited page for remaining files: \" << system.getMostVisitedPage() << endl; // Output: 2\n\n    return 0;\n}",
  "1501": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> findCountries(std::vector<std::vector<int>>& data) {\n    std::vector<std::string> safeCountries;\n    for (int i = 0; i < data.size(); i++) {\n        if (data[i][1] >= 5 && data[i][2] <= 20) {\n            safeCountries.push_back(std::to_string(data[i][0]));\n        }\n    }\n    return safeCountries;\n}\n\nint main() {\n    std::vector<std::vector<int>> data = {{1, 10, 15}, {2, 12, 18}, {3, 6, 16}, {4, 8, 19}, {5, 14, 11}};\n\n    std::vector<std::string> result = findCountries(data);\n\n    if (result.size() == 1) {\n        std::cout << \"The only safe country is: \" << result[0] << std::endl;\n    } else if (result.size() > 1) {\n        std::cout << \"The safe countries are: \";\n        for (int i = 0; i < result.size(); i++) {\n            std::cout << result[i] << \" \";\n        }\n        std::cout << std::endl;\n    } else {\n        std::cout << \"No country is safe.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1502": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool canMakeArithmeticProgression(vector<int>& arr) {\n    if (arr.size() < 3)\n        return true;\n    sort(arr.begin(), arr.end());\n    for (int i = 2; i < arr.size(); i++) {\n        if (arr[i] - arr[i-1] != arr[1] - arr[0])\n            return false;\n    }\n    return true;\n}\n\nint main() {\n    vector<int> testArr1 = {3,5,1};\n    cout << \"Test case 1: \" << (canMakeArithmeticProgression(testArr1) ? \"Pass\" : \"Fail\") << endl;\n\n    vector<int> testArr2 = {1,2,4};\n    cout << \"Test case 2: \" << (canMakeArithmeticProgression(testArr2) ? \"Pass\" : \"Fail\") << endl;\n\n    vector<int> testArr3 = {0,-1,2};\n    cout << \"Test case 3: \" << (canMakeArithmeticProgression(testArr3) ? \"Pass\" : \"Fail\") << endl;\n    \n    return 0;\n}\n```",
  "1503": "```\n#include <iostream>\n#include <vector>\n\nint lastMomentBeforeAllAntsFallOutOfAPLANK(std::vector<int>& positions) {\n    int n = positions.size();\n    int left = 0, right = n - 1;\n    while (left < right) {\n        if (positions[left] >= positions[right]) {\n            --right;\n        } else {\n            ++left;\n        }\n    }\n    return left;\n}\n\nint main() {\n    std::vector<int> positions1 = {2, 5, 3};\n    int result1 = lastMomentBeforeAllAntsFallOutOfAPLANK(positions1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> positions2 = {4, 6, 7, 11};\n    int result2 = lastMomentBeforeAllAntsFallOutOfAPLANK(positions2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> positions3 = {1, 3, 5};\n    int result3 = lastMomentBeforeAllAntsFallOutOfAPLANK(positions3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1504": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countGoodSubarrays(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int res = 0;\n        \n        for (int i = 0; i < m; i++) {\n            vector<int> ones;\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 1) {\n                    ones.push_back(j);\n                }\n            }\n            int prev = -1;\n            for (int j : ones) {\n                res += (j - prev);\n                prev = j;\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> testMatrix1{{1, 1}, {1, 1}};\n    cout << \"Test case 1: \" << solution.countGoodSubarrays(testMatrix1) << endl;  // Expected output: 6\n\n    // Test case 2\n    vector<vector<int>> testMatrix2{{0, 1}, {1, 1}};\n    cout << \"Test case 2: \" << solution.countGoodSubarrays(testMatrix2) << endl;  // Expected output: 2\n\n    // Test case 3\n    vector<vector<int>> testMatrix3{{1, 0, 1}, {1, 1, 1}, {0, 1, 1}};\n    cout << \"Test case 3: \" << solution.countGoodSubarrays(testMatrix3) << endl;  // Expected output: 13\n\n    return 0;\n}\n```",
  "1505": "```\n#include <iostream>\n#include <string>\n\nint minSteps(std::string s, int k) {\n    int res = 0;\n    for (int i = 0; i < s.length(); i++) {\n        if ((s[i] - '0') % 2 == (k / (i + 1)) % 2) {\n            res += k / (i + 1);\n            break;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << minSteps(\"001104\", 5) << std::endl; // Output: 0\n    std::cout << minSteps(\"21522\", 3) << std::endl; // Output: 3\n    std::cout << minSteps(\"00000000\", 4) << std::endl; // Output: 4\n\n    return 0;\n}\n```",
  "1507": "```\n#include <iostream>\n#include <string>\n\nstd::string reformatDate(std::string date) {\n    std::string result;\n    size_t pos = 0;\n\n    while ((pos = date.find('-')) != std::string::npos) {\n        result += date.substr(0, pos);\n        date.erase(0, pos + 1);\n    }\n\n    if (!date.empty()) {\n        result += '-';\n        result += date;\n    }\n\n    return result;\n}\n\nint main() {\n    std::cout << reformatDate(\"2025-01-15\") << std::endl; // Expected output: \"20250115\"\n    std::cout << reformatDate(\"2017-07-22\") << std::endl; // Expected output: \"20170722\"\n    std::cout << reformatDate(\"2009-02-03\") << std::endl; // Expected output: \"20090203\"\n\n    return 0;\n}\n```",
  "1506": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Node {\n    int val;\n    vector<Node*> children;\n};\n\nNode* findRoot(vector<Node*>& tree) {\n    for (int i = 0; i < tree.size(); i++) {\n        if (tree[i]->children.empty()) {\n            return tree[i];\n        }\n    }\n    return nullptr;\n}\n\nvoid printTree(Node* root, int depth = 0) {\n    cout << string(depth * 4) << root->val << endl;\n    for (Node* child : root->children) {\n        printTree(child, depth + 1);\n    }\n}\n\nint main() {\n    vector<Node*> tree;\n\n    Node* nodeA = new Node{1};\n    tree.push_back(nodeA);\n\n    Node* nodeB = new Node{3};\n    tree.push_back(nodeB);\n\n    Node* nodeC = new Node{4};\n    tree.push_back(nodeC);\n\n    Node* nodeD = new Node{5};\n    nodeB->children.push_back(nodeD);\n\n    Node* nodeE = new Node{6};\n    nodeB->children.push_back(new Node{7});\n    nodeB->children.push_back(nodeE);\n\n    Node* nodeF = new Node{8};\n    nodeA->children.push_back(new Node{9});\n    nodeA->children.push_back(new Node{10});\n    nodeA->children.push_back(nodeF);\n\n    Node* nodeG = new Node{11};\n    nodeC->children.push_back(new Node{12});\n    nodeC->children.push_back(nodeG);\n\n    cout << \"Root of the tree: \";\n    if (Node* root = findRoot(tree)) {\n        printTree(root);\n    } else {\n        cout << \"No root found.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1509": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint minDifference(std::vector<int>& nums) {\n    std::sort(nums.begin(), nums.end());\n    int smallest = nums[0], largest = nums.back();\n    for (int i = 1; i < nums.size() - 1; ++i) {\n        if (nums[i] - smallest > largest - nums[i-1]) {\n            smallest = nums[i];\n            largest = nums[nums.size() - 2];\n        }\n    }\n    return largest - smallest;\n}\n\nint main() {\n    std::vector<int> test1 = {5,19,-48,6,200,107};\n    std::cout << \"Test case 1: \" << minDifference(test1) << std::endl;\n\n    std::vector<int> test2 = {3,99,40};\n    std::cout << \"Test case 2: \" << minDifference(test2) << std::endl;\n\n    std::vector<int> test3 = {7,8,9};\n    std::cout << \"Test case 3: \" << minDifference(test3) << std::endl;\n\n    return 0;\n}\n```",
  "1508": "```\n#include <iostream>\n#include <vector>\n\nint rangeSum(vector<int>& nums, int n, int left, int right) {\n    int sum = 0;\n    for (int i : nums) {\n        sum += i;\n    }\n    \n    vector<long long> prefixSum(nums.size() + 1);\n    for (int i = 0; i < nums.size(); i++) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n    \n    int res = 0;\n    int leftIndex = lower_bound(prefixSum.begin(), prefixSum.end(), left) - prefixSum.begin();\n    for (int i = leftIndex; i <= min(right, static_cast<int>(nums.size())); i++) {\n        res += prefixSum[i] - prefixSum[leftIndex];\n        left++;\n    }\n    \n    return res;\n}\n\nint main() {\n    vector<int> nums1 = {3, 1};\n    int n1 = 2;\n    int left1 = 2;\n    int right1 = 5;\n    cout << rangeSum(nums1, n1, left1, right1) << endl;\n\n    vector<int> nums2 = {7,4,6,8};\n    int n2 = 4;\n    int left2 = 3;\n    int right2 = 9;\n    cout << rangeSum(nums2, n2, left2, right2) << endl;\n\n    vector<int> nums3 = {10, 2, -2, -20};\n    int n3 = 4;\n    int left3 = -5;\n    int right3 = 5;\n    cout << rangeSum(nums3, n3, left3, right3) << endl;\n\n    return 0;\n}\n```",
  "1510": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int stoneGameIV(vector<int>& A) {\n        int n = A.size();\n        vector<vector<int>> dp(n+1, vector<int>(n+1));\n        \n        for (int i = 0; i < n; ++i) {\n            if (A[i] > 0) {\n                dp[i][i] = A[i];\n                for (int j = i + 1; j <= n; ++j) {\n                    dp[i][j] = A[j] - dp[i][j-1];\n                }\n            }\n        }\n        \n        int res = 0;\n        for (int i = 0; i < n; ++i) {\n            if (A[i] > 0) {\n                for (int j = i; j <= n; ++j) {\n                    if (dp[i][j] % A[i] == 0) res++;\n                }\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> A1 = {5,1,3};\n    cout << \"Test case 1: \" << solution.stoneGameIV(A1) << endl;\n    \n    vector<int> A2 = {6,2,7,3};\n    cout << \"Test case 2: \" << solution.stoneGameIV(A2) << endl;\n\n    vector<int> A3 = {5};\n    cout << \"Test case 3: \" << solution.stoneGameIV(A3) << endl;\n    \n    return 0;\n}\n```",
  "1511": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Order {\n    std::string customerId;\n    int orderCount;\n};\n\nclass Solution {\npublic:\n    static std::vector<std::string> customerOrderFrequency(std::vector<Order>& orders) {\n        std::map<std::string, int> frequencyMap;\n        for (const auto& order : orders) {\n            frequencyMap[order.customerId]++;\n        }\n        std::vector<std::string> result;\n        for (const auto& pair : frequencyMap) {\n            result.push_back(pair.first + \": \" + std::to_string(pair.second));\n        }\n        return result;\n    }\n};\n\nint main() {\n    std::vector<Order> orders1 = {{\"John\", 2}, {\"Mary\", 3}};\n    std::cout << \"Test case 1: \";\n    for (const auto& order : Solution::customerOrderFrequency(orders1)) {\n        std::cout << order << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<Order> orders2 = {{\"John\", 3}, {\"Mary\", 2}};\n    std::cout << \"Test case 2: \";\n    for (const auto& order : Solution::customerOrderFrequency(orders2)) {\n        std::cout << order << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<Order> orders3 = {{\"John\", 1}, {\"Mary\", 1}};\n    std::cout << \"Test case 3: \";\n    for (const auto& order : Solution::customerOrderFrequency(orders3)) {\n        std::cout << order << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1512": "```\n#include <iostream>\n#include <vector>\n\nint numIdenticalPairs(std::vector<int>& nums) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        for (int j = i + 1; j < nums.size(); j++) {\n            if (nums[i] == nums[j]) {\n                count++;\n            }\n        }\n    }\n    return count / 2;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 1, 1, 1};\n    std::cout << \"Test case 1: \" << numIdenticalPairs(test1) << std::endl;\n\n    std::vector<int> test2 = {1, 2, 3, 4};\n    std::cout << \"Test case 2: \" << numIdenticalPairs(test2) << std::endl;\n\n    std::vector<int> test3 = {1, 1};\n    std::cout << \"Test case 3: \" << numIdenticalPairs(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1513": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int numSubs(std::string s) {\n        int count = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '1') {\n                count++;\n                for (int j = i + 1; j < s.size() && s[j] == '1'; j++) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    std::string test1 = \"111\";\n    std::cout << \"Number of substrings with only 1s for test case 1: \" << solution.numSubs(test1) << std::endl;\n\n    // Test Case 2\n    std::string test2 = \"01110\";\n    std::cout << \"Number of substrings with only 1s for test case 2: \" << solution.numSubs(test2) << std::endl;\n\n    // Test Case 3\n    std::string test3 = \"00000\";\n    std::cout << \"Number of substrings with only 1s for test case 3: \" << solution.numSubs(test3) << std::endl;\n    \n    return 0;\n}",
  "1515": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minTotalTravel(int n, vector<vector<int>>& flights) {\n        vector<int> res(n + 1, INT_MAX / 2);\n        for (auto &flight : flights) {\n            int start = flight[0], end = flight[1], cost = flight[2];\n            for (int i = start; i <= n; i++) {\n                res[i] = min(res[i], res[i - 1] + cost);\n            }\n        }\n        return accumulate(res.begin() + 1, res.end(), 0) - min({res[i] for int i : range(1, n + 1)}) * (n - 1);\n    }\n\n    vector<int> range(int start, int end) {\n        vector<int> r;\n        for (int i = start; i < end; ++i)\n            r.push_back(i);\n        return r;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    cout << sol.minTotalTravel(4, {{1, 2, 10}, {3, 4, 20}}) << endl;\n    cout << sol.minTotalTravel(5, {{0, 1, 3}, {1, 2, 5}, {2, 3, 2}, {3, 4, 6}}) << endl;\n    cout << sol.minTotalTravel(3, {{0, 1, 10}, {1, 2, 15}}) << endl;\n\n    return 0;\n}\n```",
  "1514": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nstruct Edge {\n    int node;\n    double probability;\n};\n\ndouble maxProbability(vector<vector<Edge>>& edges, int n, vector<pair<int, int>> &connections) {\n    vector<double> probabilities(n + 1);\n    for (int i = 0; i <= n; i++) {\n        probabilities[i] = 1.0;\n    }\n\n    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<pair<double, int>>> pq;\n\n    for (pair<int, int> conn : connections) {\n        pq.push({1.0, conn.first});\n    }\n\n    while (!pq.empty()) {\n        double prob = pq.top().first;\n        int node = pq.top().second;\n        pq.pop();\n\n        if (prob < probabilities[node]) continue;\n\n        for (Edge edge : edges[node]) {\n            int nextNode = edge.node;\n            double nextProb = prob * edge.probability;\n            if (nextProb > probabilities[nextNode]) {\n                probabilities[nextNode] = nextProb;\n                pq.push({nextProb, nextNode});\n            }\n        }\n    }\n\n    return *max_element(probabilities.begin(), probabilities.end());\n}\n\nint main() {\n    vector<vector<Edge>> edges = {{}, { {0, 1.0} }, { {}, {1, 2.0}, {3, 0.5} },\n                                    {{}, {0, 0.7}, {1, 0.6}, {2, 0.9} }};\n\n    vector<pair<int, int>> connections = {{0, 1}, {1, 2}, {1, 3}};\n    cout << maxProbability(edges, edges.size() - 1, connections) << endl;\n\n    edges = {{}, { {0, 1.0} }, {}};\n    connections = {{0, 1}};\n    cout << maxProbability(edges, edges.size() - 1, connections) << endl;\n\n    edges = {{}, {}, {}};\n    connections = {};\n    cout << maxProbability(edges, edges.size() - 1, connections) << endl;\n}\n```",
  "1516": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for an N-Ary Tree.\nstruct Node {\n    int val;\n    vector<Node*> children;\n};\n\nclass Solution {\npublic:\n    Node* cloneTree(Node* root) {\n        if (root == NULL) return NULL;\n        \n        Node* copy = new Node();\n        copy->val = root->val;\n        for (Node* child : root->children) {\n            copy->children.push_back(cloneTree(child));\n        }\n        return copy;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    Node* root1 = new Node();\n    root1->val = 1;\n    vector<Node*> children1 = {new Node(), new Node()};\n    for (Node* child : children1) {\n        child->val = i++;\n        i++;\n        root1->children.push_back(child);\n    }\n    cout << \"Test Case 1: \";\n    Node* copyRoot1 = solution.cloneTree(root1);\n    // Output the copied tree\n    cout << endl;\n\n    // Test Case 2\n    Node* root2 = new Node();\n    root2->val = 3;\n    vector<Node*> children2 = {new Node()};\n    for (Node* child : children2) {\n        child->val = 4;\n        root2->children.push_back(child);\n    }\n    cout << \"Test Case 2: \";\n    Node* copyRoot2 = solution.cloneTree(root2);\n    // Output the copied tree\n    cout << endl;\n\n    // Test Case 3\n    Node* root3 = new Node();\n    root3->val = 5;\n    vector<Node*> children3 = {};\n    cout << \"Test Case 3: \";\n    Node* copyRoot3 = solution.cloneTree(root3);\n    // Output the copied tree\n    cout << endl;\n\n    return 0;\n}\n```",
  "1517": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool validateEmail(std::string email) {\n    std::string localPart = email.substr(0, email.find('@'));\n    std::string domain = email.substr(email.find('@') + 1);\n    \n    if (localPart.empty() || domain.empty()) {\n        return false;\n    }\n    \n    if (!std::any_of(localPart.begin(), localPart.end(), ::isalnum) && localPart[0] != '.') {\n        return false;\n    }\n    \n    if (!std::all_of(domain.begin(), domain.end(), ::isalnum) && !std::count(domain.begin(), domain.end(), '.') > 1) {\n        return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    std::vector<std::string> emails = {\"test@gmail.com\", \"test..@gmail.com\", \"test@gm ail.com\"};\n    \n    for (const auto& email : emails) {\n        if (validateEmail(email)) {\n            std::cout << \"Valid: \" << email << std::endl;\n        } else {\n            std::cout << \"Invalid: \" << email << std::endl;\n        }\n    }\n    \n    return 0;\n}\n```",
  "1518": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numWaterBottles(int numBottles, int numIntervalBottles) {\n        return (numBottles + numIntervalBottles * (numBottles > 0 ? 1 : 0));\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    int numBottles1 = 9, numIntervalBottles1 = 1;\n    cout << \"Expected: 12, Got: \" << solution.numWaterBottles(numBottles1, numIntervalBottles1) << endl;\n\n    // Test Case 2\n    int numBottles2 = 0, numIntervalBottles2 = 8;\n    cout << \"Expected: 8, Got: \" << solution.numWaterBottles(numBottles2, numIntervalBottles2) << endl;\n\n    // Test Case 3\n    int numBottles3 = 1, numIntervalBottles3 = 5;\n    cout << \"Expected: 7, Got: \" << solution.numWaterBottles(numBottles3, numIntervalBottles3) << endl;\n\n    return 0;\n}\n```",
  "1519": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int sameTree(TreeNode* p, TreeNode* q) {\n        if (p == NULL && q == NULL) return 1;\n        if (p == NULL || q == NULL) return 0;\n        \n        if (p->val != q->val) return 0;\n        \n        return sameTree(p->left, q->left) && sameTree(p->right, q->right);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* p1 = new TreeNode(3);\n    p1->left = new TreeNode(4);\n    p1->right = new TreeNode(5);\n    p1->left->left = new TreeNode(1);\n    p1->left->right = new TreeNode(2);\n\n    TreeNode* q1 = new TreeNode(3);\n    q1->left = new TreeNode(4);\n    q1->right = new TreeNode(5);\n    q1->left->left = new TreeNode(1);\n    q1->left->right = new TreeNode(2);\n\n    cout << \"Test case 1: \" << solution.sameTree(p1, q1) << endl; // Expected output: 1\n\n    // Test case 2\n    p1 = new TreeNode(1);\n    p1->left = new TreeNode(2);\n    p1->right = new TreeNode(3);\n\n    q1 = new TreeNode(1);\n    q1->left = new TreeNode(2);\n    q1->right = new TreeNode(4);\n\n    cout << \"Test case 2: \" << solution.sameTree(p1, q1) << endl; // Expected output: 0\n\n    // Test case 3\n    p1 = NULL;\n    q1 = NULL;\n\n    cout << \"Test case 3: \" << solution.sameTree(p1, q1) << endl; // Expected output: 1\n\n    return 0;\n}",
  "1520": "```\n#include <iostream>\n#include <vector>\n\nint maxNonOverlappingSubstr(std::string s) {\n    int n = s.length();\n    int res = 0, last = -1;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == '0') {\n            if (last == -1 || i - last > 1) {\n                res++;\n                last = i;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << maxNonOverlappingSubstr(\"00111\") << std::endl; // Output: 3\n    std::cout << maxNonOverlappingSubstr(\"10101\") << std::endl; // Output: 2\n    std::cout << maxNonOverlappingSubstr(\"1101\") << std::endl; // Output: 1\n\n    return 0;\n}",
  "1521": "```\n#include <iostream>\n#include <vector>\n\nint closestDivisor(int num, std::vector<int>& divisors) {\n    int closest = INT_MAX;\n    for (int divisor : divisors) {\n        if (std::abs(num - divisor) < std::abs(num - closest)) {\n            closest = divisor;\n        }\n    }\n    return closest;\n}\n\nint main() {\n    int num1, target1, res1;\n    num1 = 12; target1 = 10; res1 = closestDivisor(num1, {3, 5, 9});\n    std::cout << \"For \" << num1 << \" and \" << target1 << \", the closest divisor is: \" << res1 << std::endl;\n\n    int num2, target2, res2;\n    num2 = 25; target2 = 23; res2 = closestDivisor(num2, {3, 9, 12});\n    std::cout << \"For \" << num2 << \" and \" << target2 << \", the closest divisor is: \" << res2 << std::endl;\n\n    int num3, target3, res3;\n    num3 = 100; target3 = 97; res3 = closestDivisor(num3, {1, 7, 49});\n    std::cout << \"For \" << num3 << \" and \" << target3 << \", the closest divisor is: \" << res3 << std::endl;\n\n    return 0;\n}\n```",
  "1523": "```\n#include <iostream>\n#include <vector>\n\nint countOdds(int low, int high) {\n    return (high % 2 != 0 || low % 2 != 0) ? (high - low) / 2 + 1 : (high - low) / 2;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << countOdds(3, 7) << std::endl; // Expected output: 3\n    std::cout << \"Test case 2: \" << countOdds(8, 10) << std::endl; // Expected output: 1\n    std::cout << \"Test case 3: \" << countOdds(1, 13) << std::endl; // Expected output: 7\n\n    return 0;\n}\n```",
  "1522": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Node {\n    int val;\n    vector<Node*> children;\n};\n\nclass Solution {\npublic:\n    int diameterNArvore(Node* root) {\n        if (root == NULL)\n            return 0;\n        \n        int diameter = 0, depthLeft, depthRight;\n        \n        for (Node* child : root->children) {\n            depthLeft = diameterNArvore(child);\n            depthRight = diameterNArvore(child);\n            \n            if (depthLeft + depthRight > diameter) \n                diameter = depthLeft + depthRight;\n        }\n        \n        return diameter;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    Node* node1 = new Node();\n    node1->val = 1;\n    \n    Node* node2 = new Node();\n    node2->val = 3;\n    Node* node21 = new Node();\n    node21->val = 5;\n    node2->children.push_back(node21);\n    \n    Node* node3 = new Node();\n    node3->val = 2;\n    Node* node31 = new Node();\n    node31->val = 4;\n    node3->children.push_back(node31);\n    node1->children.push_back(node2);\n    node1->children.push_back(node3);\n\n    cout << \"Diameter of N-ary tree: \" << solution.diameterNArvore(node1) << endl;\n\n    Node* node11 = new Node();\n    node11->val = 1;\n    \n    Node* node12 = new Node();\n    node12->val = 2;\n    Node* node121 = new Node();\n    node121->val = 3;\n    node12->children.push_back(node121);\n    \n    Node* node13 = new Node();\n    node13->val = 4;\n    node1->children.push_back(node12);\n    node1->children.push_back(node13);\n\n    cout << \"Diameter of N-ary tree: \" << solution.diameterNArvore(node11) << endl;\n\n    Node* node5 = new Node();\n    node5->val = 1;\n    \n    Node* node51 = new Node();\n    node51->val = 2;\n    \n    node5->children.push_back(node51);\n\n    cout << \"Diameter of N-ary tree: \" << solution.diameterNArvore(node5) << endl;\n\n    return 0;\n}\n```",
  "1525": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numWays(string s) {\n        int n = s.length();\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            if (s[i - 1] == 'x') {\n                dp[i] += dp[i - 1];\n                for (int j = i - 2; j >= 0 && s[j] != 'x'; j--) {\n                    dp[i] += dp[j];\n                }\n            } else {\n                dp[i] = dp[i - 1];\n            }\n        }\n        return dp[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.numWays(\"aaa\") << endl; // 2\n    cout << solution.numWays(\"abcxx\") << endl; // 8\n    cout << solution.numWays(\"aaaaa\") << endl; // 15\n    return 0;\n}\n```",
  "1524": "```\n#include <iostream>\n#include <vector>\n\nint numSubArraysWithOddSum(std::vector<int>& nums) {\n    int n = nums.size();\n    long long oddCount = 0, evenCount = 0;\n    long long currentSum = 0;\n\n    for (int i = 0; i < n; i++) {\n        currentSum += nums[i];\n        if ((currentSum & 1) == 1) {\n            oddCount++;\n        } else {\n            evenCount++;\n        }\n    }\n\n    return oddCount;\n}\n\nint main() {\n    std::vector<int> nums1 = {2,4,6};\n    std::cout << \"Test case 1: \" << numSubArraysWithOddSum(nums1) << std::endl;\n\n    std::vector<int> nums2 = {1,0,1};\n    std::cout << \"Test case 2: \" << numSubArraysWithOddSum(nums2) << std::endl;\n\n    std::vector<int> nums3 = {0,0,1};\n    std::cout << \"Test case 3: \" << numSubArraysWithOddSum(nums3) << std::endl;\n    \n    return 0;\n}\n```",
  "1526": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minNumber(int target[], int n) {\n        vector<int> res;\n        for (int i = 0; i < n; i++) {\n            while (!res.empty() && res.back() > target[i]) {\n                if (res.back() - target[i] == 1)\n                    res.pop_back();\n                else\n                    break;\n            }\n            if (res.empty() || res.back() < target[i])\n                res.push_back(target[i]);\n        }\n        return res.size();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    int target1[] = {3,5,2,4};\n    cout << \"Test case 1: \" << solution.minNumber(target1, 4) << endl; // Expected output: 3\n\n    int target2[] = {1,6,3,4};\n    cout << \"Test case 2: \" << solution.minNumber(target2, 4) << endl; // Expected output: 5\n\n    int target3[] = {100};\n    cout << \"Test case 3: \" << solution.minNumber(target3, 1) << endl; // Expected output: 0\n\n    return 0;\n}\n```",
  "1527": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::vector<std::string> patientsWithCondition(std::vector<std::vector<std::string>>& dischargeSummary) {\n        std::vector<std::string> result;\n        for (const auto& summary : dischargeSummary) {\n            if (summary.size() > 0 && summary[1] == \"Condition_A\") {\n                result.push_back(summary[0]);\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::vector<std::string>> dischargeSummary1 = {{\"John\", \"Condition_A\"}, {\"Jane\", \"Condition_B\"}};\n    auto result1 = solution.patientsWithCondition(dischargeSummary1);\n    for (const auto& patient : result1) {\n        std::cout << patient << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test Case 2\n    std::vector<std::vector<std::string>> dischargeSummary2 = {{\"Alice\", \"Condition_A\"}, {\"Bob\", \"Condition_B\"}};\n    auto result2 = solution.patientsWithCondition(dischargeSummary2);\n    for (const auto& patient : result2) {\n        std::cout << patient << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test Case 3\n    std::vector<std::vector<std::string>> dischargeSummary3 = {{\"Charlie\", \"Condition_A\"}, {\"David\", \"Condition_C\"}};\n    auto result3 = solution.patientsWithCondition(dischargeSummary3);\n    for (const auto& patient : result3) {\n        std::cout << patient << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1529": "```\n#include <iostream>\n#include <string>\n\nint minFlips(std::string s) {\n    int flips = 0;\n    for (int i = s.length() - 1; i >= 0; --i) {\n        if ((s[i] - '0') % 2 != 0) {\n            flips++;\n        }\n    }\n    return flips;\n}\n\nint main() {\n    std::cout << minFlips(\"00111\") << \"\\n\";\n    std::cout << minFlips(\"10101\") << \"\\n\";\n    std::cout << minFlips(\"11100\") << \"\\n\";\n    return 0;\n}\n```",
  "1528": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::string shuffleString(std::string s) {\n        int n = s.length();\n        char str[n];\n        for (int i = 0; i < n; i++) {\n            str[i] = s[i];\n        }\n        \n        for (int i = 1; i < n; i *= 2) {\n            std::vector<char> temp;\n            int j = 0, k = i;\n            while (k < n) {\n                temp.push_back(str[j]);\n                j++;\n                if (j >= k) break;\n                temp.push_back(str[k]);\n                k++;\n            }\n            for (int l = 0; l < i; l++) {\n                str[l] = temp[l];\n            }\n        }\n        \n        std::string result = \"\";\n        for (char c : str) {\n            result += c;\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::cout << \"Test case 1: \" << solution.shuffleString(\"abc\") << std::endl;  // Output: \"acb\"\n\n    // Test case 2\n    std::cout << \"Test case 2: \" << solution.shuffleString(\"aaabbbcc\") << std::endl;  // Output: \"aabbccabaaccb\"\n\n    // Test case 3\n    std::cout << \"Test case 3: \" << solution.shuffleString(\"Codeforce\") << std::endl;  // Output: \"CodforecfroeC\"\n\n    return 0;\n}\n```",
  "1531": "```\n#include <iostream>\n#include <string>\n\nint getLengthOfOptimalCompression(const std::string& s) {\n    int n = s.size();\n    if (n == 0) return 0;\n\n    int res = 1;\n    for (int i = 1; i <= n; ++i) {\n        int k = 0, cnt = 0;\n        for (; k < i && i + k <= n; ++k) {\n            if (s[k] == s[i - 1]) {\n                ++cnt;\n            } else {\n                break;\n            }\n        }\n        res = std::max(res, 1 + getLengthOfOptimalCompression(s.substr(0, i - 1)) + k + cnt);\n    }\n\n    return res;\n}\n\nint main() {\n    std::cout << getLengthOfOptimalCompression(\"aabb\") << std::endl; // Expected output: 4\n    std::cout << getLengthOfOptimalCompression(\"abcd\") << std::endl; // Expected output: 4\n    std::cout << getLengthOfOptimalCompression(\"aaaabbbcccd\") << std::endl; // Expected output: 9\n\n    return 0;\n}\n```",
  "1530": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countGoodLeafNodes(TreeNode* root) {\n        if (!root) return 0;\n        if (!root->left && !root->right) return 1;\n        \n        int leftCount = 0, rightCount = 0;\n        if (root->left) leftCount = countGoodLeafNodes(root->left);\n        if (root->right) rightCount = countGoodLeafNodes(root->right);\n        \n        return leftCount + rightCount;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(4);\n    root1->right = new TreeNode(7);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(6);\n    root1->right->left = new TreeNode(5);\n    root1->right->right = new TreeNode(4);\n\n    cout << solution.countGoodLeafNodes(root1) << endl;  // Output: 3\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(1);\n    root2->left = new TreeNode(1);\n    root2->right = new TreeNode(1);\n\n    cout << solution.countGoodLeafNodes(root2) << endl;  // Output: 0\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(3);\n    root3->left->left = new TreeNode(4);\n\n    cout << solution.countGoodLeafNodes(root3) << endl;  // Output: 0\n\n    return 0;\n}\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n};\n```",
  "1533": "```\n#include <iostream>\n#include <vector>\n\nint searchInsert(std::vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<int> nums1 = {1, 3, 5, 6};\n    int target1 = 5;\n    int result1 = searchInsert(nums1, target1);\n    if (result1 != 2) {\n        std::cout << \"Test Case 1 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1 passed.\" << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<int> nums2 = [0, 9];\n    int target2 = 5;\n    int result2 = searchInsert(nums2, target2);\n    if (result2 != 1) {\n        std::cout << \"Test Case 2 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2 passed.\" << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<int> nums3 = [1];\n    int target3 = 0;\n    int result3 = searchInsert(nums3, target3);\n    if (result3 != 0) {\n        std::cout << \"Test Case 3 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3 passed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1532": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Order {\n    int id;\n    std::string customer;\n};\n\nclass Solution {\npublic:\n    std::vector<Order> getOrders(std::vector<Order>& orders) {\n        if (orders.size() <= 3) return orders;\n        return std::vector<Order>(orders.begin() + orders.size() - 3, orders.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1: More than three orders\n    std::vector<Order> orders1 = {{1, \"John\"}, {2, \"Jane\"}, {3, \"Jim\"}, {4, \"Jen\"}, {5, \"Joe\"}};\n    auto result1 = solution.getOrders(orders1);\n    for (const auto& order : result1) {\n        std::cout << \"Order ID: \" << order.id << \", Customer: \" << order.customer << \"\\n\";\n    }\n    std::cout << \"\\n\";\n\n    // Test case 2: Exactly three orders\n    std::vector<Order> orders2 = {{1, \"Alice\"}, {2, \"Bob\"}, {3, \"Charlie\"}};\n    auto result2 = solution.getOrders(orders2);\n    for (const auto& order : result2) {\n        std::cout << \"Order ID: \" << order.id << \", Customer: \" << order.customer << \"\\n\";\n    }\n    std::cout << \"\\n\";\n\n    // Test case 3: Less than three orders\n    std::vector<Order> orders3 = {{1, \"David\"}};\n    auto result3 = solution.getOrders(orders3);\n    for (const auto& order : result3) {\n        std::cout << \"Order ID: \" << order.id << \", Customer: \" << order.customer << \"\\n\";\n    }\n    return 0;\n}\n```",
  "1535": "```\n#include <iostream>\n#include <vector>\n\nint firstUniqChar(const std::string& s) {\n    for (char c : s) {\n        int count = 0;\n        for (char cc : s) {\n            if (cc == c)\n                count++;\n        }\n        if (count == 1) return s.find(c);\n    }\n    return -1;\n}\n\nint main() {\n    std::cout << firstUniqChar(\"aaa\") << std::endl; // expected: 0\n    std::cout << firstUniqChar(\"abca\") << std::endl; // expected: 2\n    std::cout << firstUniqChar(\"abcba\") << std::endl; // expected: 1\n\n    return 0;\n}\n```",
  "1534": "```\n#include <iostream>\n#include <vector>\n\nint goodTriplets(std::vector<int>& root, std::vector<std::vector<int>>& triples) {\n    int count = 0;\n    for (int i = 0; i < triples.size(); i++) {\n        for (int j = i + 1; j < triples.size(); j++) {\n            if (triples[i][0] == triples[j][0]) {\n                for (int k = 0; k < triples.size(); k++) {\n                    if (k != i && k != j) {\n                        if (triples[i][0] == triples[k][0] && \n                            triples[i][1] + 1 == triples[k][1] &&\n                            triples[j][1] - 1 == triples[k][1]) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::vector<int> root = {1,2,3,4,5};\n    std::vector<std::vector<int>> triples = {{1,2},{2,3},{3,4}};\n    \n    int result1 = goodTriplets(root, triples);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n    \n    root = {1,2};\n    triples = {{1,2},{2,3}};\n    \n    int result2 = goodTriplets(root, triples);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n    \n    root = {1,1,1,2,2,3,4,4,4};\n    triples = {{1,1,1},{1,2,2},{2,2,3},{2,3,4}};\n    \n    int result3 = goodTriplets(root, triples);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1536": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSwaps(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<int> row(n, -1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) row[j]++;\n            }\n        }\n        int swaps = 0;\n        for (int i = 0; i < n; i++) {\n            while (row[i] > 0) {\n                for (int j = i + 1; j < n; j++) {\n                    if (row[j] == i) {\n                        swap(row[i], row[j]);\n                        swaps++;\n                        break;\n                    }\n                }\n            }\n        }\n        return swaps;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> grid1 = {{0,1},{1,0}};\n    cout << \"Minimum Swaps for Grid1: \" << solution.minSwaps(grid1) << endl;\n\n    // Test Case 2\n    vector<vector<int>> grid2 = {{0,0,1},{1,1,0},{1,0,0}};\n    cout << \"Minimum Swaps for Grid2: \" << solution.minSwaps(grid2) << endl;\n\n    // Test Case 3\n    vector<vector<int>> grid3 = {{0,1,1},{1,0,1},{1,1,1}};\n    cout << \"Minimum Swaps for Grid3: \" << solution.minSwaps(grid3) << endl;\n\n    return 0;\n}\n```",
  "1537": "```\n#include <iostream>\n#include <vector>\n\nint maxScore(std::vector<int>& w) {\n    int n = w.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            if (i == j) {\n                dp[i][j] = w[i];\n            } else {\n                dp[i][j] = std::max(dp[i][j-1], w[j] + (i > 0 ? dp[i-1][j-1] : 0));\n            }\n        }\n    }\n    \n    return dp[0][n-1];\n}\n\nint main() {\n    int testCases = 3;\n    for (int i = 0; i < testCases; i++) {\n        std::vector<int> w;\n        \n        if (i == 0) {\n            // Test Case 1\n            w = {100, 200, 300};\n        } else if (i == 1) {\n            // Test Case 2\n            w = {3, 4, 5};\n        } else {\n            // Test Case 3\n            w = {10, 20, 30};\n        }\n        \n        std::cout << \"Maximum score for test case \" << i + 1 << \": \" << maxScore(w) << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "1538": "```\n#include <iostream>\n#include <vector>\n\nint majorityElement(std::vector<int>& nums) {\n    int count = 0;\n    int candidate = 0;\n\n    for (int num : nums) {\n        if (count == 0) {\n            candidate = num;\n        }\n        count += (num == candidate) ? 1 : -1;\n    }\n\n    return candidate;\n}\n\nint main() {\n    std::vector<int> test1 = {2, 2, 1, 1, 1, 2, 2};\n    std::cout << \"Test case 1: \" << majorityElement(test1) << std::endl;\n\n    std::vector<int> test2 = {3, 3, 4, 2, 3};\n    std::cout << \"Test case 2: \" << majorityElement(test2) << std::endl;\n\n    std::vector<int> test3 = {1};\n    std::cout << \"Test case 3: \" << majorityElement(test3) << std::endl;\n\n    return 0;\n}\n```",
  "1539": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int findKthPositive(std::vector<int>& arr, int k) {\n        int n = arr.size();\n        for (int i = 1; ; ++i) {\n            if (std::binary_search(arr.begin(), arr.end(), i)) continue;\n            if (++k == n + 1) return i;\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<int> arr1 = {2,3,4,5};\n    int k1 = 2; // Expected: 5\n    std::cout << \"Test case 1: \" << solution.findKthPositive(arr1, k1) << std::endl;\n    \n    std::vector<int> arr2 = {};\n    int k2 = 3; // Expected: 3\n    std::cout << \"Test case 2: \" << solution.findKthPositive(arr2, k2) << std::endl;\n\n    std::vector<int> arr3 = {1};\n    int k3 = 3; // Expected: 3\n    std::cout << \"Test case 3: \" << solution.findKthPositive(arr3, k3) << std::endl;\n    \n    return 0;\n}\n```",
  "1540": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canConvertString(int k, string s) {\n        unordered_map<char, int> charCount;\n        for (char c : s) {\n            charCount[c]++;\n        }\n        \n        int maxCount = 0;\n        for (auto& pair : charCount) {\n            if (pair.second > 1 && pair.second % 2 != 0) {\n                return false;\n            }\n            maxCount = max(maxCount, pair.second);\n        }\n        \n        return maxCount <= k / 26 + (k % 26 != 0);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int k1 = 3;\n    string s1 = \"leet\";\n    cout << solution.canConvertString(k1, s1) << endl; // Expected output: true\n\n    // Test case 2\n    int k2 = 4;\n    string s2 = \"code\";\n    cout << solution.canConvertString(k2, s2) << endl; // Expected output: false\n\n    // Test case 3\n    int k3 = 5;\n    string s3 = \"aabb\";\n    cout << solution.canConvertString(k3, s3) << endl; // Expected output: true\n\n    return 0;\n}\n```",
  "1541": "```\n#include <iostream>\n#include <stack>\n\nint minAdditions(std::string s) {\n    int ans = 0;\n    stack<char> st;\n    \n    for(int i=0; i<s.size();i++){\n        if(s[i] == '('){\n            st.push('(');\n        }else{\n            if(!st.empty()){\n                st.pop();\n            }else{\n                ans++;\n            }\n        }\n    }\n    \n    while(!st.empty()){\n        st.pop();\n        ans+=2;\n    }\n    \n    return ans;\n}\n\nint main() {\n    std::cout << minAdditions(\"())\") << std::endl; // 3\n    std::cout << minAdditions(\"(\") << std::endl; // 1\n    std::cout << minAddions(\"(())\") << std::endl; // 0\n\n    return 0;\n}\n```",
  "1543": "```\n#include <iostream>\n#include <string>\n\nclass Solution {\npublic:\n    std::string capitalizeProductName(std::string product_name) {\n        std::string result = \"\";\n        bool is_upper = false;\n        for (char c : product_name) {\n            if (is_upper) {\n                result += tolower(c);\n                is_upper = false;\n            } else if (c == ' ') {\n                result += c;\n                is_upper = true;\n            } else {\n                result += toupper(c);\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    std::cout << \"Test Case 1: \" << solution.capitalizeProductName(\"first product\") << std::endl;\n    \n    // Test Case 2\n    std::cout << \"Test Case 2: \" << solution.capitalizeProductName(\"second   product   test\") << std::endl;\n    \n    // Test Case 3\n    std::cout << \"Test Case 3: \" << solution.capitalizeProductName(\"all lower case string\") << std::endl;\n    \n    return 0;\n}\n```",
  "1542": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestAwesome(string s) {\n        int maxLen = 0;\n        string res = \"\";\n        for (int i = 0; i < s.size(); ++i) {\n            int val = 0;\n            for (int j = 0; j <= i; ++j) {\n                val ^= (s[j] - 'a');\n            }\n            if (val & (val - 1)) continue;\n            for (int j = i + 1; j < s.size(); ++j) {\n                val ^= (s[j] - 'a');\n                if ((val & (val - 1)) || j - i + 1 > maxLen) {\n                    if (j - i + 1 > maxLen) {\n                        res = s.substr(i, j - i + 1);\n                        maxLen = j - i + 1;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution sol;\n    cout << \"Test Case 1: \" << sol.longestAwesome(\"LEA\") << endl;\n    cout << \"Test Case 2: \" << sol.longestAwesome(\"NIALPls\") << endl;\n    cout << \"Test Case 3: \" << sol.longestAwesome(\"EnchantedLlama\") << endl;\n    return 0;\n}\n```",
  "1544": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nbool makeGood(std::string s) {\n    std::stack<char> st;\n    for (char c : s) {\n        if (!st.empty() && st.top() == tolower(c) - 32 && c >= 'a' && c <= 'z') {\n            st.pop();\n        } else {\n            st.push(c);\n        }\n    }\n    return st.empty();\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << makeGood(\"leEe\") << std::endl;  // Expected: true\n    std::cout << makeGood(\"a1c1m5p2\") << std::endl;  // Expected: false\n    std::cout << makeGood(\"aBcD\")) << std::endl;  // Expected: true\n}\n```",
  "1545": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findKthBit(int n, int k) {\n        if (n == 1)\n            return k % 2;\n        else {\n            if (k <= pow(2, n - 1))\n                return findKthBit(n - 1, k);\n            else\n                return 1 - findKthBit(n - 1, k - pow(2, n - 1));\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << solution.findKthBit(3, 4) << endl; // Output: 0\n    cout << solution.findKthBit(4, 11) << endl; // Output: 1\n    cout << solution.findKthBit(10, 2) << endl; // Output: 1\n    \n    return 0;\n}\n```",
  "1546": "```\n#include <iostream>\n#include <vector>\n\nint maxNonOverlapping(std::vector<int>& nums, int target) {\n    int n = nums.size();\n    std::vector<int> sum(n + 1);\n    for (int i = 0; i < n; i++) {\n        sum[i + 1] = sum[i] + nums[i];\n    }\n    \n    int res = 0;\n    int end = -target;\n    for (int start = 0, end = -target; start <= n; start++) {\n        while (sum[start] > end) {\n            end++;\n            start++;\n        }\n        if (start < n && sum[start] == end) {\n            res++;\n            end++;\n            start++;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {0, 1, -2, 10, -10, 10};\n    std::cout << \"Test case 1: \" << maxNonOverlapping(nums1, 5) << std::endl;\n\n    std::vector<int> nums2 = {4, 2, 2, -1, 3};\n    std::cout << \"Test case 2: \" << maxNonOverlapping(nums2, 8) << std::endl;\n\n    std::vector<int> nums3 = [0, 5];\n    std::cout << \"Test case 3: \" << maxNonOverlapping(nums3, 0) << std::endl;\n}\n```",
  "1547": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCostCuttingSticks(vector<int>& sticks) {\n        int n = sticks.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\n        \n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0) {\n                    dp[i][j] = INT_MAX;\n                } else if (j == 0) {\n                    dp[i][j] = 0;\n                } else {\n                    int minCut = INT_MAX;\n                    for (int k = i - 1; k >= 0 && j - k >= 0; k--) {\n                        int cost = sticks[k] * j + dp[k][j - k];\n                        if (cost < minCut) {\n                            minCut = cost;\n                        }\n                    }\n                    dp[i][j] = minCut;\n                }\n            }\n        }\n        \n        return dp[n][n];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> sticks1 = {9};\n    cout << \"Minimum cost for 9-stick: \" << solution.minCostCuttingSticks(sticks1) << endl; // Expected output: 0\n\n    vector<int> sticks2 = {10, 5, 3};\n    cout << \"Minimum cost for (10, 5, 3)-stick: \" << solution.minCostCuttingSticks(sticks2) << endl; // Expected output: 15\n\n    vector<int> sticks3 = {1, 4, 6, 8, 12, 14};\n    cout << \"Minimum cost for (1, 4, 6, 8, 12, 14)-stick: \" << solution.minCostCuttingSticks(sticks3) << endl; // Expected output: 21\n\n    return 0;\n}\n```",
  "1549": "```\n#include <iostream>\n#include <vector>\n#include <map>\n\nstruct Order {\n    int product;\n    int id;\n};\n\nstd::vector<std::pair<int, int>> mostRecentOrders(std::vector<Order>& orders) {\n    std::map<int, int> recentOrders;\n    for (const auto& order : orders) {\n        if (!recentOrders.count(order.product)) {\n            recentOrders[order.product] = order.id;\n        } else if (order.id > recentOrders.at(order.product)) {\n            recentOrders[order.product] = order.id;\n        }\n    }\n    std::vector<std::pair<int, int>> result(recentOrders.begin(), recentOrders.end());\n    return result;\n}\n\nint main() {\n    Order orders[] = {{1, 5}, {1, 3}, {2, 6}, {4, 8}};\n    std::vector<Order> orderVector(orders, orders + sizeof(orders) / sizeof(orders[0]));\n\n    for (const auto& test : {\n        // Test case 1\n        mostRecentOrders(orderVector),\n        // Test case 2\n        mostRecentOrders(std::vector<Order>() {{10, 100}, {11, 101}}),\n        // Test case 3\n        mostRecentOrders(std::vector<Order>() {{20, 200}, {21, 201}})\n    }) {\n        for (const auto& order : test) {\n            std::cout << \"Product: \" << order.first << \", Most Recent Order: \" << order.second << std::endl;\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1548": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string mostSimilarPath(vector<vector<string>>& edges) {\n        int n = edges.size();\n        vector<vector<int>> graph(n);\n        for (int i = 0; i < n; i++) {\n            for (const auto& edge : edges[i]) {\n                int from = stoi(edge.substr(0, edge.find(\" \")));\n                int to = stoi(edge.substr(edge.find(\" \") + 1));\n                graph[from].push_back(to);\n                graph[to].push_back(from); // Assuming the graph is undirected\n            }\n        }\n\n        vector<string> res;\n        dfs(graph, n - 1, 0, \"\", &res);\n\n        return res.size() > 0 ? res[0] : \"\";\n    }\n\nprivate:\n    void dfs(vector<vector<int>>& graph, int end, int start, string path, vector<string>* res) {\n        if (start == end) {\n            (*res).push_back(path);\n            return;\n        }\n\n        for (const auto& neighbor : graph[start]) {\n            if (!path.empty() && !contains(*res, path + \" -> \" + to_string(neighbor))) {\n                dfs(graph, end, neighbor, path + \" -> \" + to_string(neighbor), res);\n            }\n        }\n    }\n\n    bool contains(const vector<string>& vec, const string& target) {\n        for (const auto& str : vec) {\n            if (str == target) return true;\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> edges1 = {{\"0 1\"}, {\"0 2\"}, {\"1 3\"}, {\"2 4\"}};\n    cout << \"Test case 1: \" << solution.mostSimilarPath(edges1) << endl; // Output: \"0 -> 1 -> 3\"\n\n    // Test case 2\n    vector<vector<string>> edges2 = {{\"0 1\"}, {\"1 2\"}, {\"2 3\"}, {\"3 4\"}};\n    cout << \"Test case 2: \" << solution.mostSimilarPath(edges2) << endl; // Output: \"0 -> 1 -> 2 -> 3\"\n\n    // Test case 3\n    vector<vector<string>> edges3 = {{\"0 1\"}, {\"1 2\"}, {\"2 3\"}};\n    cout << \"Test case 3: \" << solution.mostSimilarPath(edges3) << endl; // Output: \"\"\n\n    return 0;\n}\n```",
  "1550": "```\n#include <iostream>\n#include <vector>\n\nbool threeConsecutiveOdds(std::vector<int>& nums) {\n    for (int i = 0; i < nums.size() - 2; i++) {\n        if ((nums[i] % 2 == 1) && (nums[i + 1] % 2 == 1) && (nums[i + 2] % 2 == 1)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 3, 5};\n    std::cout << \"Test case 1: \" << (threeConsecutiveOdds(test1) ? \"Pass\" : \"Fail\") << std::endl;\n\n    std::vector<int> test2 = {1, 2, 4};\n    std::cout << \"Test case 2: \" << (threeConsecutiveOdds(test2) ? \"Pass\" : \"Fail\") << std::endl;\n\n    std::vector<int> test3 = {1, 1, 3};\n    std::cout << \"Test case 3: \" << (threeConsecutiveOdds(test3) ? \"Pass\" : \"Fail\") << std::endl;\n\n    return 0;\n}\n```",
  "1551": "```\n#include <iostream>\n#include <vector>\n\nint minOperations(std::vector<int>& target) {\n    int n = target.size();\n    std::vector<int> count(60, 0);\n    for (int x : target) {\n        count[x]++;\n    }\n    int res = 0;\n    for (int i = 1; i <= 59; ++i) {\n        res += abs(count[i] - (n / 60));\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> target1({10,6,5,4});\n    std::cout << \"Test Case 1: \" << minOperations(target1) << std::endl;\n\n    std::vector<int> target2({3,18,94,13,43,26});\n    std::cout << \"Test Case 2: \" << minOperations(target2) << std::endl;\n\n    std::vector<int> target3({23,24,36,10,1,6});\n    std::cout << \"Test Case 3: \" << minOperations(target3) << std::endl;\n\n    return 0;\n}\n```",
  "1553": "```\n#include <iostream>\n#include <vector>\n\nint minDays(int n) {\n    std::vector<int> dp(n + 1, -1);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            dp[i] = dp[i / 2] + 1;\n        } else {\n            for (int j = 1; j * j <= i; j++) {\n                if (dp[j * j - 1] != -1) {\n                    dp[i] = std::min(dp[i], dp[j * j - 1] + 1);\n                }\n            }\n        }\n    }\n    \n    return dp[n];\n}\n\nint main() {\n    int n;\n    n = 100; // Test case 1: n = 100\n    std::cout << \"Minimum number of days to eat \" << n << \" oranges is \" << minDays(n) << \".\\n\";\n    \n    n = 14; // Test case 2: n = 14\n    std::cout << \"Minimum number of days to eat \" << n << \" oranges is \" << minDays(n) << \".\\n\";\n    \n    n = 6; // Test case 3: n = 6\n    std::cout << \"Minimum number of days to eat \" << n << \" oranges is \" << minDays(n) << \".\\n\";\n    \n    return 0;\n}\n```",
  "1552": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxDistance(std::vector<std::pair<int, int>>& balls) {\n    std::sort(balls.begin(), balls.end());\n    \n    int left = 0;\n    int right = balls.size() - 1;\n    \n    while (left <= right) {\n        if ((balls[right].second - balls[left].second) * 2 > 10e6) {\n            return balls.size();\n        }\n        \n        int mid = left + (right - left) / 2;\n        \n        if (abs(balls[mid].first - balls[mid].second) >= 1000000) {\n            right = mid - 1;\n        } else if (abs(balls[mid].first - balls[mid].second) < 500000) {\n            left = mid + 1;\n        } else {\n            return balls.size() - mid;\n        }\n    }\n    \n    return 0;\n}\n\nint main() {\n    std::vector<std::pair<int, int>> testCases[] = {\n        {{1, 2}, {4, 6}, {5, 8}, {7, 10}},\n        {{-1, -3}, {-2, -4}, {0, 1}, {4, 7}, {5, 9}},\n        {{1000000, 2000000}, {1100000, 2100000}, {1200000, 2200000}}\n    };\n    \n    for (int i = 0; i < sizeof(testCases) / sizeof(testCases[0]); i++) {\n        int result = maxDistance(testCases[i]);\n        \n        std::cout << \"Test Case \" << i << \": Result: \" << result << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "1554": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nbool areAlmostEqual(string s1, string s2) {\n    if (s1.size() != s2.size()) return false;\n    for (int i = 0; i < s1.size(); ++i) {\n        if (s1[i] != s2[i]) return false;\n    }\n    return true;\n}\n\nbool oneEditAway(string s1, string s2) {\n    int len1 = s1.length();\n    int len2 = s2.length();\n    \n    if (abs(len1 - len2) > 1)\n        return false;\n\n    bool sameSize = (len1 == len2);\n\n    for (int i = 0; i < len1 && i < len2; ++i) {\n        if (s1[i] != s2[i]) {\n            // If strings differ by one character\n            if (!sameSize && i == len1 - 1)\n                return areAlmostEqual(s1, s2.substr(0, i) + s2[i] + s2.substr(i + 1));\n            else if (i < len1 - 1 || i < len2 - 1)\n                return false;\n            else\n                return areAlmostEqual(s1, s2);\n        }\n    }\n\n    // If strings differ by one character and one of them is empty string\n    if (!sameSize && (len1 == 0 || len2 == 0))\n        return true;\n\n    return false;\n}\n\nint main() {\n    cout << boolalpha;\n    \n    cout << \"Test case 1: \" << oneEditAway(\"pleasing\", \"please\") << endl; // Expected: true\n    cout << \"Test case 2: \" << oneEditAway(\"sunday\", \"sanda\") << endl; // Expected: true\n    cout << \"Test case 3: \" << oneEditAway(\"test\", \"tett\") << endl; // Expected: false\n    \n    return 0;\n}\n```",
  "1555": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Transaction {\n    int id;\n    std::string type; // \"deposit\" or \"withdrawal\"\n    double amount;\n};\n\ndouble getBalance(const std::vector<Transaction>& transactions) {\n    double balance = 0.0;\n    for (const auto& transaction : transactions) {\n        if (transaction.type == \"deposit\") {\n            balance += transaction.amount;\n        } else if (transaction.type == \"withdrawal\") {\n            balance -= transaction.amount;\n        }\n    }\n    return balance;\n}\n\nint main() {\n    // Test case 1\n    std::vector<Transaction> testTransactions1 = {{1, \"deposit\", 100.0}, {2, \"withdrawal\", 20.0}, {3, \"deposit\", 50.0}};\n    double result1 = getBalance(testTransactions1);\n    if (std::abs(result1 - 130.0) > 0.01) {\n        std::cerr << \"Test case 1 failed.\" << std::endl;\n        return 1;\n    }\n\n    // Test case 2\n    std::vector<Transaction> testTransactions2 = {{4, \"deposit\", 50.0}, {5, \"withdrawal\", 30.0}, {6, \"deposit\", 20.0}};\n    double result2 = getBalance(testTransactions2);\n    if (std::abs(result2 - 40.0) > 0.01) {\n        std::cerr << \"Test case 2 failed.\" << std::endl;\n        return 1;\n    }\n\n    // Test case 3\n    std::vector<Transaction> testTransactions3 = {{7, \"withdrawal\", 10.0}, {8, \"deposit\", 100.0}};\n    double result3 = getBalance(testTransactions3);\n    if (std::abs(result3 - 90.0) > 0.01) {\n        std::cerr << \"Test case 3 failed.\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed.\" << std::endl;\n    return 0;\n}",
  "1556": "```\n#include <iostream>\n#include <string>\n\nstd::string thousandSeparator(std::string num) {\n    if (num.length() <= 3) return num;\n    std::string res = \"\";\n    for (int i = 0; i < num.length(); i++) {\n        res += num[i];\n        if ((i + 1) % 3 == 0 && i != num.length() - 1) {\n            res += \",\";\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << thousandSeparator(\"1000\") << std::endl; // Output: \"1,000\"\n    std::cout << thousandSeparator(\"12345\") << std::endl; // Output: \"12,345\"\n    std::cout << thousandSeparator(\"9876543210\") << std::endl; // Output: \"9,876,543,210\"\n    return 0;\n}\n```",
  "1558": "```\n#include <iostream>\n#include <vector>\n\nint minOperations(std::vector<int>& nums) {\n    int res = 0;\n    for (int x : nums) {\n        while ((1 << (x & -x)) > 0) {\n            ++res;\n            x &= x - 1;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> test1({10,11});\n    std::cout << \"Test case 1: \" << minOperations(test1) << std::endl;\n\n    std::vector<int> test2({3,5,4,2,7,9,6,7,1,10});\n    std::cout << \"Test case 2: \" << minOperations(test2) << std::endl;\n\n    std::vector<int> test3({8,6,8,5,3,8,1,4,7,3,5,1,1});\n    std::cout << \"Test case 3: \" << minOperations(test3) << std::endl;\n    \n    return 0;\n}",
  "1557": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minReaches(vector<vector<int>>& edges) {\n        int n = edges.size() + 1;\n        vector<int> reaches(n, 0);\n        \n        for (int i = 0; i < edges.size(); ++i) {\n            int u = edges[i][0];\n            int v = edges[i][1];\n            reaches[v] = min(reaches[u], 1);\n        }\n        \n        int res = 0;\n        for (int i = 1; i <= n; ++i) {\n            res = max(res, reaches[i]);\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> edges1 = {{0, 1}, {1, 2}, {2, 3}};\n    cout << \"Test case 1: \" << solution.minReaches(edges1) << endl; // Expected output: 4\n\n    // Test case 2\n    vector<vector<int>> edges2 = {{0, 1}, {1, 2}, {2, 3}, {3, 1}};\n    cout << \"Test case 2: \" << solution.minReaches(edges2) << endl; // Expected output: 4\n\n    // Test case 3\n    vector<vector<int>> edges3 = {{0, 1}, {1, 2}};\n    cout << \"Test case 3: \" << solution.minReaches(edges3) << endl; // Expected output: 3\n\n    return 0;\n}\n```",
  "1560": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string mostVisited(int n, vector<int> p) {\n        int res = -1;\n        for (int i = 0; i < p.size(); i++) {\n            if (p[i] > p[i+1]) {\n                res = p[i];\n                break;\n            }\n        }\n        return to_string(res);\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test case 1\n    int n1 = 4;\n    vector<int> p1 = {0,3,1};\n    cout << \"Test case 1: \" << s.mostVisited(n1, p1) << endl;\n\n    // Test case 2\n    int n2 = 7;\n    vector<int> p2 = {1,2,4,7};\n    cout << \"Test case 2: \" << s.mostVisited(n2, p2) << endl;\n\n    // Test case 3\n    int n3 = 8;\n    vector<int> p3 = {0,11,5,6};\n    cout << \"Test case 3: \" << s.mostVisited(n3, p3) << endl;\n\n    return 0;\n}\n```",
  "1559": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool hasCycle(vector<vector<int>>& grid) {\n        int rows = grid.size();\n        if (rows == 0) return false;\n        int cols = grid[0].size();\n\n        vector<pair<int, int>> dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1) {\n                    vector<bool> visited(rows * cols);\n                    if (hasCycleDFS(grid, i, j, visited)) return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    bool hasCycleDFS(vector<vector<int>>& grid, int x, int y, vector<bool>& visited) {\n        int rows = grid.size();\n        int cols = grid[0].size();\n\n        if (x < 0 || x >= rows || y < 0 || y >= cols) return false;\n\n        if (!visited[x * cols + y]) {\n            visited[x * cols + y] = true;\n            for (pair<int, int> dir : {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {\n                int newX = x + dir.first;\n                int newY = y + dir.second;\n\n                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols) {\n                    if (grid[newX][newY] == 1) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> grid1 = {{0,0,0},{1,1,1},{0,1,1}};\n    cout << (solution.hasCycle(grid1) ? \"True\" : \"False\") << endl;  // Output: True\n\n    // Test Case 2\n    vector<vector<int>> grid2 = {{0,0,0},{1,0,1},{0,0,1}};\n    cout << (solution.hasCycle(grid2) ? \"True\" : \"False\") << endl;  // Output: False\n\n    // Test Case 3\n    vector<vector<int>> grid3 = {{0,0,0},{1,1,0},{1,1,1}};\n    cout << (solution.hasCycle(grid3) ? \"True\" : \"False\") << endl;  // Output: True\n\n    return 0;\n}\n```",
  "1561": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxCoins(std::vector<int>& piles) {\n    std::sort(piles.begin(), piles.end());\n    int total = 0;\n    for (int i = 0; i < piles.size(); i++) {\n        if (i % 2 == 1) {\n            if (i != piles.size() - 1) {\n                total += piles[i];\n            }\n        } else {\n            total += piles[i] + piles[i + 1];\n        }\n    }\n    return total;\n}\n\nint main() {\n    std::vector<int> piles1 = {2,4,3};\n    std::cout << \"Test case 1: \" << maxCoins(piles1) << std::endl;\n\n    std::vector<int> piles2 = {5,4,6,9};\n    std::cout << \"Test case 2: \" << maxCoins(piles2) << std::endl;\n\n    std::vector<int> piles3 = {10,8,7,1};\n    std::cout << \"Test case 3: \" << maxCoins(piles3) << std::endl;\n    \n    return 0;\n}\n```",
  "1562": "```\n#include <iostream>\n#include <vector>\n\nint findLatest(int* arr, int m) {\n    int n = sizeof(arr) / sizeof(arr[0]);\n    std::vector<int> group;\n    for (int i = 0; i < n; i++) {\n        if (group.empty() || arr[i] != group.back()) {\n            group.push_back(arr[i]);\n        } else {\n            while (!group.empty() && group.back() == arr[i]) {\n                group.pop_back();\n            }\n        }\n        if (group.size() == m) {\n            return i + 1;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    int* arr = new int[8] {3,5,1,2,3,4,5,6};\n    std::cout << \"Test case 1: The latest group of size 3 is at index \" << findLatest(arr, 3) << std::endl;\n\n    arr = new int[9] {1,2,2,3,3,3,4,5,5};\n    std::cout << \"Test case 2: The latest group of size 4 is at index \" << findLatest(arr, 4) << std::endl;\n\n    arr = new int[10] {1,1,1,2,2,2,2,3,3,3};\n    std::cout << \"Test case 3: The latest group of size 3 is at index \" << findLatest(arr, 3) << std::endl;\n    \n    delete[] arr;\n    return 0;\n}",
  "1563": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int stoneGameV(vector<int>& al) {\n        int n = al.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        \n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i == j) continue;\n                \n                int sum = 0;\n                for (int k = i; k <= j; ++k)\n                    sum += al[k];\n                \n                dp[i][j] = max(sum - dp[0][i-1], sum - dp[0][j+1]);\n            }\n        }\n        \n        return dp[0][n-1];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> al1 = {5, 4, 6, 7};\n    cout << \"Test case 1: \" << solution.stoneGameV(al1) << endl;\n\n    // Test case 2\n    vector<int> al2 = {10, 3, 15, 8, 4};\n    cout << \"Test case 2: \" << solution.stoneGameV(al2) << endl;\n\n    // Test case 3\n    vector<int> al3 = {1, 1, 2, 2};\n    cout << \"Test case 3: \" << solution.stoneGameV(al3) << endl;\n\n    return 0;\n}\n```",
  "1564": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nbool canArrange(std::vector<int>& arr) {\n    int n = arr.size();\n    int oddCount = 0, evenCount = 0;\n    for (int x : arr) {\n        if (x % 2 == 1)\n            oddCount++;\n        else\n            evenCount++;\n    }\n    if ((oddCount > n / 2 || evenCount > n / 2) && (n & 1))\n        return false;\n    if ((oddCount > n / 2 || evenCount > n / 2) && !(n & 1))\n        return false;\n    return true;\n}\n\nint main() {\n    std::vector<int> arr1 = {9, 15, 13};\n    std::cout << canArrange(arr1) << std::endl; // Output: 0\n\n    std::vector<int> arr2 = {3, 6, 5, 4, 8};\n    std::cout << canArrange(arr2) << std::endl; // Output: 1\n\n    std::vector<int> arr3 = {1, 2, 3, 4, 5};\n    std::cout << canArrange(arr3) << std::endl; // Output: 1\n\n    return 0;\n}",
  "1565": "```\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countOrders(vector<string>& orders) {\n        map<string, int> orderCount;\n        map<string, int> customerCount;\n        \n        for (string order : orders) {\n            string customer = order.substr(0, order.find(\" \"));\n            if (!orderCount.count(customer)) {\n                orderCount[customer] = 1;\n                customerCount[customer] = 1;\n            } else {\n                orderCount[customer]++;\n                customerCount[customer]++;\n            }\n        }\n        \n        int uniqueOrders = 0;\n        for (auto it = orderCount.begin(); it != orderCount.end(); ++it) {\n            if (it->second == 1) {\n                uniqueOrders++;\n            }\n        }\n        \n        return uniqueOrders;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<string> orders1 = {\"John 10-20\", \"Jane 10-30\", \"John 10-40\"};\n    cout << solution.countOrders(orders1) << endl; // Expected: 1\n\n    vector<string> orders2 = {\"Alice 5-15\", \"Bob 3-10\", \"Alice 5-25\"};\n    cout << solution.countOrders(orders2) << endl; // Expected: 1\n\n    vector<string> orders3 = {\"Charlie 20-30\", \"Charlie 20-40\", \"Dave 15-25\", \"Eve 15-35\"};\n    cout << solution.countOrders(orders3) << endl; // Expected: 2\n\n    return 0;\n}\n```",
  "1567": "```\n#include <iostream>\n#include <vector>\n\nint maxAlternatingSum(std::vector<int>& nums) {\n    int sumEven = 0;\n    int sumOdd = 0;\n\n    for (int i = 0; i < nums.size(); i++) {\n        if (i % 2 == 0) {\n            sumEven += nums[i];\n            sumOdd += nums[i] > 0 ? -nums[i] : nums[i];\n        } else {\n            sumOdd += nums[i];\n            sumEven += nums[i] > 0 ? -nums[i] : nums[i];\n        }\n    }\n\n    return std::max(sumEven, sumOdd);\n}\n\nint main() {\n    int test1 = maxAlternatingSum({2,4,-3});\n    int test2 = maxAlternatingSum({1,-2,3,10,-10,5});\n    int test3 = maxAlternatingSum({-1,4,-3,2});\n\n    std::cout << \"Test 1: \" << test1 << std::endl;\n    std::cout << \"Test 2: \" << test2 << std::endl;\n    std::cout << \"Test 3: \" << test3 << std::endl;\n\n    return 0;\n}\n```",
  "1566": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    bool containsPattern(const std::vector<int>& arr, int m, int k) {\n        for (int i = 0; i <= arr.size() - m * k; i++) {\n            bool isMatch = true;\n            for (int j = 0; j < m; j++) {\n                if (arr[i + j] != arr[i + j % m]) {\n                    isMatch = false;\n                    break;\n                }\n            }\n            if (isMatch) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> arr1 = {1, 2, 2, 3, 4};\n    int m1 = 2;\n    int k1 = 2;\n    if (solution.containsPattern(arr1, m1, k1)) {\n        std::cout << \"Test case 1: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Fail\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> arr2 = {1, 2, 3, 4};\n    int m2 = 1;\n    int k2 = 3;\n    if (solution.containsPattern(arr2, m2, k2)) {\n        std::cout << \"Test case 2: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Fail\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> arr3 = {1, 2, 1, 2, 1, 3};\n    int m3 = 2;\n    int k3 = 2;\n    if (solution.containsPattern(arr3, m3, k3)) {\n        std::cout << \"Test case 3: Pass\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Fail\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1569": "```\n#include <iostream>\n#include <vector>\n\nint numWays(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> left(n), right(n);\n    for (int i = 0; i < n; ++i) {\n        if (i % 2 == 0) {\n            left[i] = nums[i];\n        } else {\n            right[i / 2] = nums[i];\n        }\n    }\n    int ans = 1;\n    for (int i = 0; i < n / 2; ++i) {\n        if (left[i] > left[i + 1]) {\n            return 0;\n        }\n    }\n    for (int i = 0; i < (n - 1) / 2; ++i) {\n        if (right[i] <= right[i + 1]) {\n            ans *= (i + 1);\n        } else {\n            return 0;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::vector<int> nums1 = {2, 1, 3};\n    std::cout << numWays(nums1) << std::endl; // Output: 2\n\n    std::vector<int> nums2 = {5, 5, 4];\n    std::cout << numWays(nums2) << std::endl; // Output: 6\n\n    std::vector<int> nums3 = {3, 1};\n    std::cout << numWays(nums3) << std::endl; // Output: 0\n}\n```",
  "1568": "```\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDays(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> days(m, vector<int>(n));\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    queue<pair<int, int>> q;\n                    days[i][j] = 1;\n                    \n                    q.push({i, j});\n                    \n                    while (!q.empty()) {\n                        auto [x, y] = q.front();\n                        q.pop();\n                        \n                        if (x > 0 && grid[x-1][y] == 1) {\n                            q.push({x-1, y});\n                            days[x-1][y] = days[x][y] + 1;\n                        }\n                        if (x < m - 1 && grid[x+1][y] == 1) {\n                            q.push({x+1, y});\n                            days[x+1][y] = days[x][y] + 1;\n                        }\n                        if (y > 0 && grid[x][y-1] == 1) {\n                            q.push({x, y-1});\n                            days[x][y-1] = days[x][y] + 1;\n                        }\n                        if (y < n - 1 && grid[x][y+1] == 1) {\n                            q.push({x, y+1});\n                            days[x][y+1] = days[x][y] + 1;\n                        }\n                    }\n                }\n            }\n        }\n        \n        int maxDay = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1 && days[i][j] > maxDay) {\n                    maxDay = days[i][j];\n                }\n            }\n        }\n        \n        return maxDay;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> grid1 = {{0,1},{1,0}};\n    cout << \"Test case 1: \" << solution.minDays(grid1) << endl;\n\n    // Test case 2\n    vector<vector<int>> grid2 = {{0,0,0},{0,1,0},{0,0,0}};\n    cout << \"Test case 2: \" << solution.minDays(grid2) << endl;\n\n    // Test case 3\n    vector<vector<int>> grid3 = {{1,1,1,0},{1,0,1,1},{1,0,0,1},{1,0,0,1}};\n    cout << \"Test case 3: \" << solution.minDays(grid3) << endl;\n\n    return 0;\n}\n```",
  "1570": "```\n#include <iostream>\n#include <vector>\n\nclass Vector {\npublic:\n    int start;\n    int end;\n    std::vector<int> values;\n\n    Vector(int s, int e) : start(s), end(e) {}\n};\n\nint dotProduct(std::vector<Vector>& vec1, std::vector<Vector>& vec2) {\n    int result = 0;\n    for (const auto& v : vec1) {\n        for (int i = v.start; i < v.end; ++i) {\n            if (i >= 0 && i < vec2.size()) {\n                result += vec1[i] * vec2[i];\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::vector<Vector> vec1 = {{1, 4, {1, 2, -3}}, {4, 5, {0, 5, 0}}};\n    std::vector<Vector> vec2 = {{1, 4, {0, 7, -3}}, {4, 5, {-3, 9, 6}}};\n    \n    int expected = 23;\n    if (dotProduct(vec1, vec2) != expected) {\n        std::cout << \"Test case failed. Expected: \" << expected << \", got: \" << dotProduct(vec1, vec2) << std::endl;\n    } else {\n        std::cout << \"Test case passed.\" << std::endl;\n    }\n\n    vec1.clear(); vec1 = {{0, 1, {7, -3}}, {1, 2, {0, 5}}};\n    vec2.clear(); vec2 = {{0, 2, {7, -2, 5}}, {1, 2, {0, 4, 1}}};\n\n    expected = 12;\n    if (dotProduct(vec1, vec2) != expected) {\n        std::cout << \"Test case failed. Expected: \" << expected << \", got: \" << dotProduct(vec1, vec2) << std::endl;\n    } else {\n        std::cout << \"Test case passed.\" << std::endl;\n    }\n\n    vec1.clear(); vec1 = {{1, 3, {-5, -2, 3}}, {0, 3, {2, 7, 4}}};\n    vec2.clear(); vec2 = {{1, 3, {1, -1, 2}}, {0, 3, {1, 5, 6}}};\n\n    expected = 21;\n    if (dotProduct(vec1, vec2) != expected) {\n        std::cout << \"Test case failed. Expected: \" << expected << \", got: \" << dotProduct(vec1, vec2) << std::endl;\n    } else {\n        std::cout << \"Test case passed.\" << std::endl;\n    }\n\n    return 0;\n}",
  "1571": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int maxInventory(int n, std::vector<std::vector<int>>& records) {\n        int total = 0;\n        for (int i = 0; i < n; ++i) {\n            total += records[i][1] - records[i][0];\n        }\n        return total;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> records1 = {{10, 20}, {30, 40}};\n    int result1 = solution.maxInventory(2, records1);\n    if (result1 == 0) {\n        std::cout << \"Test case 1: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Failed\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::vector<int>> records2 = {{5, 10}, {15, 20}};\n    int result2 = solution.maxInventory(2, records2);\n    if (result2 == 10) {\n        std::cout << \"Test case 2: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Failed\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::vector<int>> records3 = {{1, 5}, {10, 15}};\n    int result3 = solution.maxInventory(2, records3);\n    if (result3 == 0) {\n        std::cout << \"Test case 3: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Failed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1573": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numWays(string s) {\n        int res = 0;\n        for (int i = 1; i <= s.length(); i++) {\n            if ((s.length() % i) == 0 && isOneTwo(s, i)) {\n                res++;\n            }\n        }\n        return res;\n    }\n\n    bool isOneTwo(string s, int len) {\n        for (int i = 0; i < len - 1; i++) {\n            if ((s[i] == '0' || s[i] == '4') && (s[i + 1] != '1' && s[i + 1] != '2')) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n    \n    string s1 = \"011010\";\n    cout << \"Test case 1: \" << solution.numWays(s1) << endl; // Output: 3\n\n    string s2 = \"10101\";\n    cout << \"Test case 2: \" << solution.numWays(s2) << endl; // Output: 4\n\n    string s3 = \"0110\";\n    cout << \"Test case 3: \" << solution.numWays(s3) << endl; // Output: 2\n\n    return 0;\n}\n```",
  "1572": "```\n#include <iostream>\n#include <vector>\n\nint diagonalSum(std::vector<std::vector<int>>& mat) {\n    int sum = 0;\n    int n = mat.size();\n    for (int i = 0; i < n; i++) {\n        sum += mat[i][i];\n        if (i != n - 1) {\n            sum += mat[i][n - i - 1];\n        }\n    }\n    if (n % 2 == 1) {\n        sum -= mat[n / 2][n / 2];\n    }\n    return sum;\n}\n\nint main() {\n    std::vector<std::vector<int>> mat1 = {{1, 2, 3}, {4, 5, 6}};\n    std::cout << \"Test case 1: \" << diagonalSum(mat1) << std::endl;\n\n    std::vector<std::vector<int>> mat2 = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n    std::cout << \"Test case 2: \" << diagonalSum(mat2) << std::endl;\n\n    std::vector<std::vector<int>> mat3 = {{1, 2, 3, 4}, {5, 6, 7, 8}};\n    std::cout << \"Test case 3: \" << diagonalSum(mat3) << std::endl;\n\n    return 0;\n}\n```",
  "1574": "```\n#include <iostream>\n#include <vector>\n\nint minSubArrayLen(const std::vector<int>& arr) {\n    int n = arr.size();\n    int left = 0, right = 1;\n    while (right < n && arr[right] >= arr[left]) {\n        if (arr[right] > arr[left]) return right - left + 1;\n        right++;\n    }\n    return -1;\n}\n\nint main() {\n    std::vector<int> testArr1 = {2,3,9,2,7};\n    std::cout << \"Test case 1: \" << minSubArrayLen(testArr1) << std::endl;\n\n    std::vector<int> testArr2 = {4,3,1,2};\n    std::cout << \"Test case 2: \" << minSubArrayLen(testArr2) << std::endl;\n\n    std::vector<int> testArr3 = {1,2,3};\n    std::cout << \"Test case 3: \" << minSubArrayLen(testArr3) << std::endl;\n\n    return 0;\n}\n```",
  "1575": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int countRoutes(vector<int>& dist, int M) {\n        int MOD = 1000000007;\n        vector<vector<int>> dp(dist.size(), vector<int>(M + 1, 0));\n        for (int i = 0; i < dist.size(); i++) {\n            if (dist[i] <= M) {\n                dp[i][0] = 1;\n            }\n        }\n        for (int j = 1; j <= M; j++) {\n            for (int i = 0; i < dist.size(); i++) {\n                int val = min(j, dist[i]);\n                if (val > 0) {\n                    dp[i][j] = (dp[i][j] + dp[(i - 1 + dist.size()) % dist.size()][j - val]) % MOD;\n                }\n            }\n        }\n        int res = 0;\n        for (int j = 0; j <= M; j++) {\n            res = (res + dp[dist.size() - 1][j]) % MOD;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> dist1 = {2, 3, 4};\n    int M1 = 5;\n    cout << \"Test case 1: \" << solution.countRoutes(dist1, M1) << endl;  // Expected output: 6\n\n    // Test case 2\n    vector<int> dist2 = {1, 2, 3};\n    int M2 = 4;\n    cout << \"Test case 2: \" << solution.countRoutes(dist2, M2) << endl;  // Expected output: 9\n\n    // Test case 3\n    vector<int> dist3 = {10, 20};\n    int M3 = 30;\n    cout << \"Test case 3: \" << solution.countRoutes(dist3, M3) << endl;  // Expected output: 32\n\n    return 0;\n}\n```",
  "1576": "```\n#include <iostream>\n#include <string>\n\nstd::string modifyString(std::string s) {\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '?') {\n            for (char c = 'a'; c <= 'z'; c++) {\n                if (!contains(s, c)) {\n                    s.replace(i, 1, String(1, c));\n                    break;\n                }\n            }\n        }\n    }\n    return s;\n}\n\nbool contains(const std::string& str, char ch) {\n    for (char c : str) {\n        if (c == ch) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::cout << modifyString(\"hello?\") << std::endl; // \"holle\"\n    std::cout << modifyString(\"?zzz\") << std::endl; // \"abcz\"\n    std::cout << modifyString(\"abc?d?e?f\") << std::endl; // \"abcef\"\n    return 0;\n}",
  "1577": "```\n#include <iostream>\n#include <vector>\n\nint countWays(std::vector<int>& nums) {\n    int res = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        for (int j = i + 1; j < nums.size(); ++j) {\n            if ((nums[i] * nums[j]) == (nums[i + 1] * nums[i + 2])) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {10,4,-8,7};\n    int result1 = countWays(test1);\n    if(result1 == 1) std::cout << \"Test case 1 passed\" << std::endl;\n    else std::cout << \"Test case 1 failed\" << std::endl;\n\n    std::vector<int> test2 = {1,1};\n    int result2 = countWays(test2);\n    if(result2 == 0) std::cout << \"Test case 2 passed\" << std::endl;\n    else std::cout << \"Test case 2 failed\" << std::endl;\n\n    std::vector<int> test3 = {7,6,8};\n    int result3 = countWays(test3);\n    if(result3 == 1) std::cout << \"Test case 3 passed\" << std::endl;\n    else std::cout << \"Test case 3 failed\" << std::endl;\n\n    return 0;\n}\n```",
  "1578": "```\n#include <iostream>\n#include <vector>\n\nint minCost(std::vector<std::string>& colors) {\n    int n = colors.size();\n    std::vector<int> colorCount(3, 0);\n    \n    for (const auto& color : colors) {\n        colorCount[color[0] - 'A']++;\n    }\n    \n    if (n % 3 == 1) {\n        return n * (n + 1) / 2 - min({colorCount[0], colorCount[1]});\n    } else if (n % 3 == 2) {\n        return n * (n + 1) / 2 - min({colorCount[1], colorCount[2]});\n    } else {\n        return 0;\n    }\n}\n\nint main() {\n    std::vector<std::string> colors1 = {\"A\", \"A\", \"B\", \"C\"};\n    int result1 = minCost(colors1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<std::string> colors2 = {\"A\", \"B\", \"C\", \"A\", \"C\", \"A\"};\n    int result2 = minCost(colors2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<std::string> colors3 = {\"A\"};\n    int result3 = minCost(colors3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}",
  "1580": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxBoxes(int boxes[100], int n) {\n        sort(boxes, boxes+n);\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if ((n - i) >= boxes[i]) {\n                res++;\n                i++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution sol;\n    \n    // Test case 1\n    int test1[] = {2,6,5,10};\n    cout << \"Test 1: \" << sol.maxBoxes(test1, sizeof(test1)/sizeof(test1[0])) << endl;\n\n    // Test case 2\n    int test2[] = {1,3,4,5};\n    cout << \"Test 2: \" << sol.maxBoxes(test2, sizeof(test2)/sizeof(test2[0])) << endl;\n\n    // Test case 3\n    int test3[] = {10,10,10,10};\n    cout << \"Test 3: \" << sol.maxBoxes(test3, sizeof(test3)/sizeof(test3[0])) << endl;\n    \n    return 0;\n}\n```",
  "1579": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxErosions(int n, vector<vector<int>>& edges) {\n        vector<int> parent(n);\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n        \n        sort(edges.begin(), edges.end());\n        \n        int res = 0;\n        for (auto edge : edges) {\n            int u = edge[1], v = edge[2];\n            if (parent[u] != parent[v]) {\n                parent[v] = parent[u];\n                res++;\n            }\n        }\n        \n        return n - 1 - res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int n1 = 5;\n    vector<vector<int>> edges1 = {{0,1},{1,2},{2,3},{4,3}};\n    cout << \"Test Case 1: \" << solution.maxErosions(n1, edges1) << endl;\n\n    // Test Case 2\n    int n2 = 6;\n    vector<vector<int>> edges2 = {{0,1},{1,2},{2,3},{3,4},{4,5}};\n    cout << \"Test Case 2: \" << solution.maxErosions(n2, edges2) << endl;\n\n    // Test Case 3\n    int n3 = 8;\n    vector<vector<int>> edges3 = {{0,1},{1,2},{2,3},{4,5},{5,6},{7,6}};\n    cout << \"Test Case 3: \" << solution.maxErosions(n3, edges3) << endl;\n\n    return 0;\n}\n```",
  "1581": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int get_customer_id(std::vector<std::vector<int>>& customer_info) {\n        int result = -1;\n        for (const auto& info : customer_info) {\n            if (info[2] == 0) {\n                result = info[0];\n                break;\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::vector<int>> test_case1{{1, \"John\", 0}, {2, \"Alice\", 1}};\n    int expected_result1 = 1;\n    if (solution.get_customer_id(test_case1) != expected_result1) {\n        std::cout << \"Test Case 1 failed.\" << std::endl;\n        return 1;\n    }\n\n    // Test Case 2\n    std::vector<std::vector<int>> test_case2{{3, \"Bob\", 0}, {4, \"Eve\", 1}};\n    int expected_result2 = 3;\n    if (solution.get_customer_id(test_case2) != expected_result2) {\n        std::cout << \"Test Case 2 failed.\" << std::endl;\n        return 1;\n    }\n\n    // Test Case 3\n    std::vector<std::vector<int>> test_case3{{5, \"Mike\", 0}, {6, \"Sarah\", 0}};\n    int expected_result3 = 5;\n    if (solution.get_customer_id(test_case3) != expected_result3) {\n        std::cout << \"Test Case 3 failed.\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}\n```",
  "1582": "```\n#include <iostream>\n#include <vector>\n\nint specialPositionsInBinaryMatrix(std::vector<std::vector<int>>& binaryMatrix) {\n    int m = binaryMatrix.size();\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < binaryMatrix[i].size(); ++j) {\n            if (binaryMatrix[i][j] == 1 && (i == 0 || j == 0 || i == m - 1 || j == binaryMatrix[i].size() - 1)) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix1 = {{0, 1}, {1, 0}};\n    std::cout << specialPositionsInBinaryMatrix(matrix1) << std::endl;\n\n    std::vector<std::vector<int>> matrix2 = {{0, 0, 0}, {0, 1, 1}};\n    std::cout << specialPositionsInBinaryMatrix(matrix2) << std::endl;\n\n    std::vector<std::vector<int>> matrix3 = {{1, 0}, {0, 1}};\n    std::cout << specialPositionsInBinaryMatrix(matrix3) << std::endl;\n}",
  "1583": "```\n#include <iostream>\n#include <vector>\n\nint unhappyFriends(int n, std::vector<std::string>& friends) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        bool unhappy = false;\n        for (int j = 0; j < n; j++) {\n            if (i != j && friends[i][friends[i].size() - 1] == friends[j][j]) {\n                unhappy = true;\n                break;\n            }\n        }\n        if (unhappy) count++;\n    }\n    return count;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::string> friends1 = {\"John,Jackie,Jilly\", \"Jackie,Jeffrey,Judy\", \"Jilly,Jimmy,Joy\"};\n    int result1 = unhappyFriends(3, friends1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<std::string> friends2 = {\"Alice,Bob,Charlie\", \"Bob,Alice,Eve\", \"Charlie,Eve,Frank\"};\n    int result2 = unhappyFriends(3, friends2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<std::string> friends3 = {\"A,B,C\", \"B,A,D\", \"C,E,F\"};\n    int result3 = unhappyFriends(3, friends3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1585": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool canBeTransformed(string s) {\n    vector<char> chars(26, 0);\n    int last = -1;\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            if (chars[s[i] - 'a'] > 0) {\n                return false;\n            }\n            chars[s[i] - 'a']++;\n            last = i;\n        } else {\n            int pos = s[i] - 'a';\n            for (int j = 0; j <= last; j++) {\n                if (s[j] == 'a' + pos) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    cout << boolalpha;\n    cout << canBeTransformed(\"abba\") << endl;  // Expected output: true\n    cout << canBeTransformed(\"aba\") << endl;   // Expected output: false\n    cout << canBeTransformed(\"caaaabbbcc\") << endl;  // Expected output: true\n    return 0;\n}\n```",
  "1584": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCostToConnectPoints(vector<vector<int>>& points) {\n        int n = points.size();\n        vector<pair<int, int>> edges;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                int cost = (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) + \n                           (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]);\n                edges.emplace_back(cost, i, j);\n            }\n        }\n        sort(edges.begin(), edges.end());\n        \n        int res = 0;\n        vector<int> parent(n);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n        for (auto& edge : edges) {\n            if (find(parent, edge.second) != find(parent, edge.third)) {\n                res += edge.first;\n                parent[find(parent, edge.third)] = edge.second;\n            }\n        }\n        return res;\n    }\n\nprivate:\n    int find(vector<int>& parent, int x) {\n        return parent[x] == x ? x : (parent[x] = find(parent, parent[x]));\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<vector<int>> points1 = {{0,0},{2,2}};\n    cout << \"Test Case 1: \" << solution.minCostToConnectPoints(points1) << endl;\n    \n    // Test Case 2\n    vector<vector<int>> points2 = {{3,1},{1,1},{2,1}};\n    cout << \"Test Case 2: \" << solution.minCostToConnectPoints(points2) << endl;\n    \n    // Test Case 3\n    vector<vector<int>> points3 = {{0,0},{1,0},{2,0},{3,0},{4,0},{5,0}};\n    cout << \"Test Case 3: \" << solution.minCostToConnectPoints(points3) << endl;\n    \n    return 0;\n}\n```",
  "1586": "```\n#include <iostream>\n#include <stack>\n#include <queue>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass BSTIterator {\npublic:\n    BSTIterator(TreeNode* root) : cursor(root) {}\n\n    int next() {\n        while (cursor) {\n            result.push(cursor->val);\n            cursor = cursor->left;\n        }\n        return result.top();\n    }\n\n    bool hasNext() { return !result.empty(); }\n\nprivate:\n    std::stack<int> result;\n    TreeNode* cursor;\n};\n\nint main() {\n    TreeNode *root1 = new TreeNode(5);\n    root1->right = new TreeNode(6);\n    root1->left = new TreeNode(3);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(4);\n    root1->right->left = new TreeNode(7);\n    root1->right->right = new TreeNode(8);\n\n    BSTIterator iter1(root1);\n    while (iter1.hasNext()) {\n        std::cout << \"Next: \" << iter1.next() << std::endl;\n    }\n\n    TreeNode *root2 = new TreeNode(10);\n    root2->left = new TreeNode(5);\n    root2->right = new TreeNode(15);\n    root2->left->left = new TreeNode(3);\n    root2->left->right = new TreeNode(7);\n\n    BSTIterator iter2(root2);\n    while (iter2.hasNext()) {\n        std::cout << \"Next: \" << iter2.next() << std::endl;\n    }\n\n    TreeNode *root3 = new TreeNode(25);\n    root3->left = new TreeNode(15);\n    root3->right = new TreeNode(30);\n\n    BSTIterator iter3(root3);\n    while (iter3.hasNext()) {\n        std::cout << \"Next: \" << iter3.next() << std::endl;\n    }\n\n    return 0;\n}",
  "1587": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nclass BankAccount {\npublic:\n    int id;\n    std::string name;\n};\n\nbool compare(BankAccount a, BankAccount b) {\n    return a.id < b.id;\n}\n\nvoid printTable(const std::vector<BankAccount>& accounts) {\n    std::cout << \"ID\\tName\\n\";\n    for (const auto& account : accounts) {\n        std::cout << account.id << \"\\t\" << account.name << \"\\n\";\n    }\n}\n\nint main() {\n    std::vector<BankAccount> accounts;\n\n    // Test Case 1\n    BankAccount a;\n    a.id = 101; a.name = \"John\"; accounts.push_back(a);\n    BankAccount b;\n    b.id = 102; b.name = \"Mary\"; accounts.push_back(b);\n\n    std::cout << \"Test Case 1:\\n\";\n    std::sort(accounts.begin(), accounts.end(), compare);\n    printTable(accounts);\n    std::cout << \"\\n\";\n\n    // Test Case 2\n    a.id = 103; a.name = \"Jane\"; accounts.clear();\n    a.id = 104; a.name = \"Jim\"; accounts.push_back(a);\n    b.id = 105; b.name = \"Julie\"; accounts.push_back(b);\n\n    std::cout << \"Test Case 2:\\n\";\n    std::sort(accounts.begin(), accounts.end(), compare);\n    printTable(accounts);\n    std::cout << \"\\n\";\n\n    // Test Case 3\n    a.id = 106; a.name = \"Jessica\"; accounts.clear();\n    b.id = 107; b.name = \"Jeremy\"; accounts.push_back(b);\n\n    std::cout << \"Test Case 3:\\n\";\n    printTable(accounts);\n    std::cout << \"\\n\";\n\n    return 0;\n}\n```",
  "1588": "```\n#include <iostream>\n#include <vector>\n\nint sumOddLengthSubarrays(std::vector<int>& arr) {\n    int n = arr.size();\n    int totalSum = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j <= i + n; ++j) {\n            if ((j - i) % 2 != 0) {\n                totalSum += std::accumulate(arr.begin() + i, arr.begin() + j, 0);\n            }\n        }\n    }\n    return totalSum;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 4, 2, 5};\n    std::cout << \"Test case 1: \" << sumOddLengthSubarrays(test1) << std::endl;\n\n    std::vector<int> test2 = {1, 14, 10, 7, 6};\n    std::cout << \"Test case 2: \" << sumOddLengthSubarrays(test2) << std::endl;\n\n    std::vector<int> test3 = {10, 11, 12};\n    std::cout << \"Test case 3: \" << sumOddLengthSubarrays(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1589": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxSumRangeQuery(int rows, int cols, std::vector<int>& sums, std::vector<int>& indices) {\n    std::vector<int> count(rows, 0);\n    for (int i = 0; i < cols; i++) {\n        count[indices[i]]++;\n    }\n    for (int i = 0; i < rows; i++) {\n        if (count[i] > 0) {\n            sums[i] += count[i];\n        }\n    }\n    std::sort(sums.begin(), sums.end());\n    std::vector<int> res(rows, 1);\n    for (int i = cols - 1; i >= 0; i--) {\n        if (res[indices[i]] > 0) {\n            res[indices[i]]++;\n        } else {\n            res[indices[i]] = sums.back();\n            sums.pop_back();\n        }\n    }\n    int resVal = 0;\n    for (int i = 0; i < rows; i++) {\n        resVal += sums[i] * res[i];\n    }\n    return resVal;\n}\n\nint main() {\n    // Test case 1\n    int rows1 = 3, cols1 = 1;\n    std::vector<int> sums1 = {4,9,6};\n    std::vector<int> indices1 = {1,2,0};\n    std::cout << \"Test case 1: \" << maxSumRangeQuery(rows1, cols1, sums1, indices1) << std::endl;\n\n    // Test case 2\n    int rows2 = 4, cols2 = 3;\n    std::vector<int> sums2 = {7,91,90,100};\n    std::vector<int> indices2 = {0,1,1};\n    std::cout << \"Test case 2: \" << maxSumRangeQuery(rows2, cols2, sums2, indices2) << std::endl;\n\n    // Test case 3\n    int rows3 = 5, cols3 = 4;\n    std::vector<int> sums3 = {3,1,6,5,4};\n    std::vector<int> indices3 = {0,1,9,3,2};\n    std::cout << \"Test case 3: \" << maxSumRangeQuery(rows3, cols3, sums3, indices3) << std::endl;\n\n    return 0;\n}\n```",
  "1590": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    bool canMakeDivisible(std::vector<int>& nums, int target) {\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        if (sum % target != 0) return false;\n        \n        int prefixSum = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            prefixSum += nums[i];\n            if (prefixSum % target == 0) {\n                continue;\n            }\n            while (i + 1 < nums.size() && prefixSum + nums[i + 1] <= sum - (sum % target)) {\n                prefixSum += nums[++i];\n            }\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<int> nums1 = {3,5,7,11};\n    int p1 = 10;\n    std::cout << (solution.canMakeDivisible(nums1, p1) ? \"true\" : \"false\") << std::endl; // true\n\n    std::vector<int> nums2 = {9,12};\n    int p2 = 5;\n    std::cout << (solution.canMakeDivisible(nums2, p2) ? \"true\" : \"false\") << std::endl; // false\n\n    std::vector<int> nums3 = {1000000007};\n    int p3 = 7;\n    std::cout << (solution.canMakeDivisible(nums3, p3) ? \"true\" : \"false\") << std::endl; // true\n\n    return 0;\n}\n```",
  "1591": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int strangePrinter(string s) {\n        int n = s.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\n        \n        for (int i = 0; i <= n; i++) {\n            dp[i][i] = 1;\n        }\n        \n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                \n                if (s[i] == s[j]) {\n                    dp[i][j] = 1 + dp[i + 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        \n        return dp[0][n - 1];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test case 1: \" << solution.strangePrinter(\"aba\") << endl; // Output: 2\n    cout << \"Test case 2: \" << solution.strangePrinter(\"abcd\") << endl; // Output: 4\n    cout << \"Test case 3: \" << solution.strangePrinter(\"aabbcc\") << endl; // Output: 6\n    \n    return 0;\n}\n```",
  "1593": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint maxUniqueSubstrings(string s) {\n    unordered_map<string, int> map;\n    vector<int> res;\n    for (int i = 1; i <= s.length(); i++) {\n        string t = s.substr(0, i);\n        if (!map[t]) {\n            map[t] = 1;\n            res.push_back(i);\n        }\n    }\n    return res.size();\n}\n\nint main() {\n    cout << maxUniqueSubstrings(\"abaccc\") << endl; // Output: 4\n    cout << maxUniqueSubstrings(\"abcabcabc\") << endl; // Output: 3\n    cout << maxUniqueSubstrings(\"abcd\") << endl; // Output: 4\n    return 0;\n}\n```",
  "1592": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstd::string reorderSpaces(std::string text) {\n    int count = 0;\n    bool isWordFound = false;\n\n    for (char c : text) {\n        if (c == ' ') {\n            if (!isWordFound) {\n                count++;\n                isWordFound = true;\n            }\n        } else {\n            isWordFound = true;\n        }\n    }\n\n    std::string result;\n    int spaceCount = 0;\n\n    for (char c : text) {\n        if (c == ' ') {\n            spaceCount++;\n        } else {\n            if (!isWordFound) {\n                result += c;\n            } else {\n                if (spaceCount > 1) {\n                    while (spaceCount-- > 1) {\n                        result += ' ';\n                    }\n                    result += c;\n                } else if (spaceCount == 1) {\n                    result += ' ';\n                    result += c;\n                } else {\n                    result += c;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::cout << reorderSpaces(\"words   space\") << std::endl;  // Output: \"words space\"\n    std::cout << reorderSpaces(\"only   consider   space\") << std::endl;  // Output: \"only   consider space\"\n    std::cout << reorderSpaces(\"a   b\") << std::endl;  // Output: \"a   b\"\n\n    return 0;\n}",
  "1595": "```\n#include <iostream>\nusing namespace std;\n\nlong long minCostToConnectPoints(vector<vector<int>>& points) {\n    int n = points.size();\n    vector<long long> dp(n, (1LL << 61) - 1);\n    vector<bool> visited(n, false);\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            if (!visited[j]) {\n                long long dist = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]);\n                dp[j] = min(dp[j], dp[i] + dist);\n            }\n        }\n    }\n\n    return *min_element(dp.begin(), dp.end());\n}\n\nint main() {\n    // Test Case 1\n    vector<vector<int>> points1 = {{0, 0}, {2, 2}};\n    cout << \"Test Case 1: \" << minCostToConnectPoints(points1) << endl;\n\n    // Test Case 2\n    vector<vector<int>> points2 = {{3, 12}, {-2, -20}, {4, 0}};\n    cout << \"Test Case 2: \" << minCostToConnectPoints(points2) << endl;\n\n    // Test Case 3\n    vector<vector<int>> points3 = {{1, 1}, {2, 2}};\n    cout << \"Test Case 3: \" << minCostToConnectPoints(points3) << endl;\n    return 0;\n}\n```",
  "1594": "```\n#include <iostream>\n#include <vector>\n\nint maxProduct(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n\n    for (int i = 1; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] > 0)\n                grid[i][j] *= grid[i - 1][j];\n            else\n                grid[i][j] = 0;\n        }\n    }\n\n    int max_product = Integer.MIN_VALUE;\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] > max_product)\n                max_product = grid[i][j];\n        }\n    }\n\n    return max_product;\n}\n\nint main() {\n    int[][] grid1 = {{-1,-2,3},{4,5,6},{10,20,50}};\n    std::cout << \"Maximum Product for Grid 1: \" << maxProduct(grid1) << std::endl;\n\n    int[][] grid2 = {{0,1,3},{8,9,10},{12,13,15}};\n    std::cout << \"Maximum Product for Grid 2: \" << maxProduct(grid2) << std::endl;\n\n    int[][] grid3 = {{-4,-5,10},{20,30,40},{50,60,70}};\n    std::cout << \"Maximum Product for Grid 3: \" << maxProduct(grid3) << std::endl;\n}\n```",
  "1597": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nstruct TreeNode {\n    char val;\n    TreeNode* left;\n    TreeNode* right;\n};\n\nTreeNode* constructFromInfix(const std::string& infix) {\n    // implementation of the problem\n}\n\nint main() {\n    {\n        TreeNode* root = constructFromInfix(\"A*B+C\");\n        std::cout << \"Test case 1: \";\n        printTree(root);\n        std::cout << \"\\n\";\n    }\n\n    {\n        TreeNode* root = constructFromInfix(\"(A+B)*C\");\n        std::cout << \"Test case 2: \";\n        printTree(root);\n        std::cout << \"\\n\";\n    }\n\n    {\n        TreeNode* root = constructFromInfix(\"A+(B*C)\");\n        std::cout << \"Test case 3: \";\n        printTree(root);\n        std::cout << \"\\n\";\n    }\n}\n\nvoid printTree(TreeNode* node) {\n    if (!node) return;\n    printTree(node->left);\n    std::cout << node->val << \" \";\n    printTree(node->right);\n}\n```",
  "1596": "```\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct Order {\n    string customer;\n    vector<string> products;\n};\n\nclass Solution {\npublic:\n    map<string, vector<string>> mostFrequentProducts(vector<Order> orders) {\n        map<string, map<string, int>> customerProductCount;\n        \n        for (const auto& order : orders) {\n            for (const auto& product : order.products) {\n                customerProductCount[order.customer][product] = customerProductCount.count(order.customer) > 0 \n                    ? customerProductCount[order.customer][product] + 1 \n                    : 1;\n            }\n        }\n\n        map<string, vector<string>> mostFrequentProducts;\n        for (const auto& customerProductCountMap : customerProductCount) {\n            int maxCount = 0;\n            string mostFrequentProduct;\n            for (const auto& productCount : customerProductCountMap.second) {\n                if (productCount.second > maxCount) {\n                    maxCount = productCount.second;\n                    mostFrequentProduct = productCount.first;\n                }\n            }\n            mostFrequentProducts[customerProductCountMap.first].push_back(mostFrequentProduct);\n        }\n\n        return mostFrequentProducts;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<Order> orders1 = {{\"john\", {\"apple\", \"banana\"}}, {\"john\", {\"apple\"}}, {\"mike\", {\"orange\"}}};\n    map<string, vector<string>> result1 = solution.mostFrequentProducts(orders1);\n    if (result1 == ({[\"john\", {\"apple\"}], [\"mike\", {\"orange\"}]})) {\n        cout << \"Test case 1 passed.\" << endl;\n    } else {\n        cout << \"Test case 1 failed.\" << endl;\n    }\n\n    // Test case 2\n    vector<Order> orders2 = {{\"amy\", {\"banana\", \"apple\"}}, {\"amy\", {\"banana\"}}, {\"john\", {\"apple\"}}};\n    map<string, vector<string>> result2 = solution.mostFrequentProducts(orders2);\n    if (result2 == ({[\"amy\", {\"banana\"}], [\"john\", {\"apple\"}]})) {\n        cout << \"Test case 2 passed.\" << endl;\n    } else {\n        cout << \"Test case 2 failed.\" << endl;\n    }\n\n    // Test case 3\n    vector<Order> orders3 = {{\"mike\", {\"orange\"}}, {\"amy\", {\"banana\", \"apple\"}}, {\"john\", {\"apple\", \"banana\"}}};\n    map<string, vector<string>> result3 = solution.mostFrequentProducts(orders3);\n    if (result3 == ({[\"mike\", {\"orange\"}], [\"john\", {\"banana\"}]})) {\n        cout << \"Test case 3 passed.\" << endl;\n    } else {\n        cout << \"Test case 3 failed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1598": "```\n#include <iostream>\n#include <vector>\n#include <stack>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMalwareSpread(vector<vector<int>>& M) {\n        int n = M.size();\n        vector<bool> visited(n, false);\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                stack<int> s;\n                dfs(M, i, visited, s);\n            }\n        }\n        \n        vector<int> res;\n        int maxDis = -1;\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                int dis = 0;\n                stack<int> s;\n                dfs(M, i, visited, s);\n                while (!s.empty()) {\n                    int node = s.top();\n                    s.pop();\n                    if (node != -1) {\n                        dis++;\n                    }\n                }\n                if (dis > maxDis) {\n                    res.clear();\n                    res.push_back(i);\n                    maxDis = dis;\n                } else if (dis == maxDis) {\n                    res.push_back(i);\n                }\n            }\n        }\n        \n        return res.empty() ? -1 : res[0];\n    }\n\nprivate:\n    void dfs(vector<vector<int>>& M, int node, vector<bool>& visited, stack<int>& s) {\n        visited[node] = true;\n        for (int i = 0; i < M.size(); i++) {\n            if (M[node][i]) {\n                if (!visited[i]) {\n                    s.push(i);\n                    dfs(M, i, visited, s);\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> M1 = {{0,1},{1,2},{2,0}};\n    cout << \"Test case 1: \" << solution.minMalwareSpread(M1) << endl;\n    \n    // Test case 2\n    vector<vector<int>> M2 = {{0,1},{1,2},{2,3},{3,4},{4,0}};\n    cout << \"Test case 2: \" << solution.minMalwareSpread(M2) << endl;\n    \n    // Test case 3\n    vector<vector<int>> M3 = {{1,2},{2,3},{3,1},{1,3}};\n    cout << \"Test case 3: \" << solution.minMalwareSpread(M3) << endl;\n    \n    return 0;\n}\n```",
  "1599": "```\n#include <iostream>\n#include <vector>\n\nint maxProfit(std::vector<int>& costs) {\n    int n = costs.size();\n    std::vector<int> dp(n);\n    dp[0] = costs[0];\n    for (int i = 1; i < n; i++) {\n        dp[i] = std::max(dp[i-1], costs[i]);\n    }\n    int max_profit = 0;\n    for (int i = 1; i < n; i++) {\n        max_profit = std::max(max_profit, dp[i] - dp[i-1]);\n    }\n    return max_profit;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> costs1 = {10, 7, 5, 8, 11};\n    int result1 = maxProfit(costs1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<int> costs2 = {3, 10, 15, 20, 6, 4};\n    int result2 = maxProfit(costs2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<int> costs3 = {5, 5, 5, 10};\n    int result3 = maxProfit(costs3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1600": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass ThroneInheritance {\npublic:\n    ThroneInheritance(string kingName) : king(kingName), children(map<string, vector<string>>()) {}\n\n    void birth(string parentName, string childName) {\n        children[parentName].push_back(childName);\n    }\n\n    string successor() {\n        return next;\n    }\n\nprivate:\n    map<string, vector<string>> children;\n    string king;\n    string next = king;\n};\n\nint main() {\n    ThroneInheritance throne(\"David\");\n    throne.birth(\"David\", \"Hannah\");\n    throne.birth(\"David\", \"Emma\");\n    throne.birth(\"Hannah\", \"Liam\");\n    throne.birth(\"Hannah\", \"Noah\");\n    cout << throne.successor() << endl;  // Output: David\n\n    ThroneInheritance throne2(\"Alice\");\n    throne2.birth(\"Alice\", \"Bob\");\n    throne2.birth(\"Alice\", \"Charlie\");\n    cout << throne2.successor() << endl;  // Output: Alice\n\n    ThroneInheritance throne3(\"Michael\");\n    throne3.birth(\"Michael\", \"Samantha\");\n    throne3.birth(\"Samantha\", \"John\");\n    throne3.birth(\"Samantha\", \"Emily\");\n    cout << throne3.successor() << endl;  // Output: Michael\n    return 0;\n}\n```",
  "1601": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\n        sort(boxTypes.begin(), boxTypes.end(), [](const vector<int>& a, const vector<int>& b){\n            return (b[1] - a[1]) * 1000 + a[0] > (b[1] - a[1]) * 1000 + b[0];\n        });\n        \n        int res = 0;\n        for(int i=0; i<boxTypes.size();i++){\n            while(truckSize>=boxTypes[i][0]){\n                truckSize -= boxTypes[i][0];\n                res += boxTypes[i][1];\n            }\n            if(truckSize==0) break;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test Case 1\n    vector<vector<int>> boxTypes1 = {{1,3},{2,2},{3,1}};\n    int truckSize1 = 4;\n    cout << \"Test Case 1: \" << s.maximumUnits(boxTypes1, truckSize1) << endl; // Output: 8\n\n    // Test Case 2\n    vector<vector<int>> boxTypes2 = {{5,10},{2,5},{4,7},{3,9}};\n    int truckSize2 = 10;\n    cout << \"Test Case 2: \" << s.maximumUnits(boxTypes2, truckSize2) << endl; // Output: 41\n\n    // Test Case 3\n    vector<vector<int>> boxTypes3 = {{1,5},{2,4},{3,7},{4,6}};\n    int truckSize3 = 10;\n    cout << \"Test Case 3: \" << s.maximumUnits(boxTypes3, truckSize3) << endl; // Output: 34\n\n    return 0;\n}\n```",
  "1602": "```\n#include <iostream>\n#include <queue>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* rightSideView(TreeNode* root) {\n        if (!root) return NULL;\n\n        std::vector<TreeNode*> vec;\n        std::queue<TreeNode*> q;\n\n        q.push(root);\n\n        while (!q.empty()) {\n            int levelSize = q.size();\n            for (int i = 0; i < levelSize; ++i) {\n                TreeNode* node = q.front();\n                q.pop();\n\n                if (i == levelSize - 1) vec.push_back(node);\n                \n                if (node->right) q.push(node->right);\n                if (node->left) q.push(node->left);\n            }\n        }\n\n        return vec.back();\n    }\n};\n\nint main() {\n    Solution s;\n\n    TreeNode* root = new TreeNode(1);\n    root->right = new TreeNode(2);\n    root->right->right = new TreeNode(5);\n    root->right->left = new TreeNode(3);\n    root->right->left->left = new TreeNode(4);\n\n    std::cout << s.rightSideView(root)->val << std::endl; // Output: 5\n\n    root = nullptr;\n\n    root = new TreeNode(1);\n    root->right = new TreeNode(2);\n\n    std::cout << s.rightSideView(root)->val << std::endl; // Output: 2\n\n    root = nullptr;\n\n    root = new TreeNode(1);\n    root->left = new TreeNode(2);\n\n    std::cout << s.rightSideView(root)->val << std::endl; // Output: 2\n\n    return 0;\n}\n```",
  "1603": "```\n#include <iostream>\n#include <unordered_map>\n\nusing namespace std;\n\nclass ParkingSystem {\npublic:\n    ParkingSystem() {\n        small = 0;\n        medium = 0;\n        large = 0;\n    }\n    \n    bool addCar(int carType) {\n        if (carType == 1 && small < 3) {\n            small++;\n            return true;\n        } else if (carType == 2 && (medium < 3 && small >= 1)) {\n            medium++;\n            small--;\n            return true;\n        } else if (carType == 3 && (large < 3 && medium >= 1 && small >= 1)) {\n            large++;\n            medium--;\n            small--;\n            return true;\n        }\n        \n        return false;\n    }\n};\n\nint main() {\n    ParkingSystem ps = ParkingSystem();\n    \n    cout << boolalpha;\n    cout << \"Test case 1: \" << (ps.addCar(1) ? \"Pass\" : \"Fail\") << endl;\n    for (int i = 0; i < 2; i++) {\n        if (!ps.addCar(2)) {\n            break;\n        }\n    }\n    cout << \"Test case 2: \" << (ps.addCar(2) ? \"Fail\" : \"Pass\") << endl;\n    \n    ps = ParkingSystem();\n    for (int i = 0; i < 3; i++) {\n        if (!ps.addCar(i+1)) {\n            break;\n        }\n    }\n    cout << \"Test case 3: \" << (ps.addCar(4) ? \"Fail\" : \"Pass\") << endl;\n    \n    return 0;\n}\n```",
  "1604": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nclass Solution {\npublic:\n    int alertNames(std::vector<std::string>& keyName, std::vector<int>& loginTime) {\n        std::unordered_map<std::string, std::vector<int>> timeMap;\n        for (int i = 0; i < keyName.size(); i++) {\n            if (timeMap.find(keyName[i]) == timeMap.end()) {\n                timeMap[keyName[i]] = {};\n            }\n            timeMap[keyName[i]].push_back(loginTime[i]);\n        }\n        \n        int count = 0;\n        for (auto& p : timeMap) {\n            std::sort(p.second.begin(), p.second.end());\n            for (int i = 0; i < p.second.size() - 2; i++) {\n                if (p.second[i + 3] - p.second[i] <= 3600) {\n                    count++;\n                    break;\n                }\n            }\n        }\n        \n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::string> keyName1 = {\"john\",\"johnny\",\"john\"};\n    std::vector<int> loginTime1 = {12345,23456,55555};\n    int result1 = solution.alertNames(keyName1, loginTime1);\n    if (result1 == 2) {\n        std::cout << \"Test Case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1 failed.\" << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<std::string> keyName2 = {\"aa\",\"aaa\",\"aaaa\",\"aaaaa\"};\n    std::vector<int> loginTime2 = {1,2,3,4};\n    int result2 = solution.alertNames(keyName2, loginTime2);\n    if (result2 == 0) {\n        std::cout << \"Test Case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2 failed.\" << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<std::string> keyName3 = {\"lemon\",\"lemon\",\"orange\"};\n    std::vector<int> loginTime3 = {1000,2008,2506};\n    int result3 = solution.alertNames(keyName3, loginTime3);\n    if (result3 == 1) {\n        std::cout << \"Test Case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3 failed.\" << std::endl;\n    }\n\n    return 0;\n}",
  "1605": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool isValidMatrix(vector<vector<int>>& matrix) {\n    int n = matrix.size();\n    vector<int> rowSums(n, 0);\n    vector<int> colSums(n, 0);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            rowSums[i] += matrix[i][j];\n            colSums[j] += matrix[i][j];\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        int targetRowSum = rowSums[i];\n        int remainingValue = rowSums[0];\n\n        if (targetRowSum != remainingValue) continue;\n\n        for (int j = 1; j < n; j++) {\n            remainingValue -= rowSums[j];\n            if (remainingValue > 0 && targetRowSum - remainingValue > colSums[j]) return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    vector<vector<int>> matrix1 {{4,2},{3,6}};\n    cout << \"Test case 1: \" << (isValidMatrix(matrix1) ? \"Valid\" : \"Invalid\") << endl;\n\n    vector<vector<int>> matrix2 {{10,15,20},{5,5,5},{1,5,8}};\n    cout << \"Test case 2: \" << (isValidMatrix(matrix2) ? \"Valid\" : \"Invalid\") << endl;\n\n    vector<vector<int>> matrix3 {{1,0},{0,1}};\n    cout << \"Test case 3: \" << (isValidMatrix(matrix3) ? \"Valid\" : \"Invalid\") << endl;\n\n    return 0;\n}\n```",
  "1607": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSellersWithNoSales(vector<vector<string>>& customers) {\n        unordered_map<string, bool> sellerSales;\n        for (const auto& customer : customers) {\n            if (!sellerSales.count(customer[0])) {\n                sellerSales[customer[0]] = false;\n            }\n        }\n        int count = 0;\n        for (const auto& p : sellerSales) {\n            if (!p.second) {\n                count++;\n            }\n        }\n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> customers1 = {{\"John\", \"Car\"}, {\"Jane\", \"Bike\"}};\n    cout << \"Test case 1: \" << solution.numSellersWithNoSales(customers1) << endl; \n\n    // Test case 2\n    vector<vector<string>> customers2 = {{\"Alice\", \"Car\"}, {\"Bob\", \"Bike\"}, {\"Charlie\", \"None\"}};\n    cout << \"Test case 2: \" << solution.numSellersWithNoSales(customers2) << endl;\n\n    // Test case 3\n    vector<vector<string>> customers3 = {{\"David\", \"Bike\"}, {\"Eve\", \"Car\"}, {\"Frank\", \"None\"}};\n    cout << \"Test case 3: \" << solution.numSellersWithNoSales(customers3) << endl;\n    \n    return 0;\n}\n```",
  "1606": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> highFive(int n, vector<vector<int>>& logs) {\n        unordered_map<int, int> map;\n        priority_queue<pair<int, int>> pq;\n        \n        for (const auto& log : logs) {\n            if (log[1] == 1) {\n                map[log[0]] = log[2];\n                pq.push({log[2], log[0]});\n            } else if (!pq.empty()) {\n                while (pq.size() > 1 && pq.top().first < log[2]) {\n                    pq.pop();\n                }\n            }\n        }\n        \n        vector<vector<int>> result;\n        while (!pq.empty()) {\n            int userId = pq.top().second;\n            int sum = 0;\n            for (int i = 0; i < n && !pq.empty(); i++) {\n                if (pq.top().second == userId) {\n                    sum += pq.top().first;\n                    pq.pop();\n                } else {\n                    break;\n                }\n            }\n            result.push_back({userId, sum});\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> logs1 = {{5, 1}, {4, 2}};\n    vector<vector<int>> logs2 = {{2, 100}, {3, 100}, {5, 45}, {5, 45}, {5, 45}, {5, 45}};\n    vector<vector<int>> logs3 = {{1, 5}, {4, 44}, {1, 15}, {4, 10}};\n\n    for (const auto& log : logs1) {\n        cout << \"Server \" << log[0] << \" handled \" << log[1] << \" requests.\" << endl;\n    }\n    \n    vector<vector<int>> result1 = solution.highFive(2, logs1);\n    for (const auto& res : result1) {\n        cout << \"Server \" << res[0] << \" handled the most number of requests: \" << res[1] << \".\" << endl;\n    }\n\n    cout << endl;\n\n    for (const auto& log : logs2) {\n        cout << \"Server \" << log[0] << \" handled \" << log[1] << \" requests.\" << endl;\n    }\n    \n    vector<vector<int>> result2 = solution.highFive(5, logs2);\n    for (const auto& res : result2) {\n        cout << \"Server \" << res[0] << \" handled the most number of requests: \" << res[1] << \".\" << endl;\n    }\n\n    cout << endl;\n\n    for (const auto& log : logs3) {\n        cout << \"Server \" << log[0] << \" handled \" << log[1] << \" requests.\" << endl;\n    }\n    \n    vector<vector<int>> result3 = solution.highFive(4, logs3);\n    for (const auto& res : result3) {\n        cout << \"Server \" << res[0] << \" handled the most number of requests: \" << res[1] << \".\" << endl;\n    }\n\n    return 0;\n}",
  "1608": "```\n#include <iostream>\n#include <vector>\n\nint specialArray(std::vector<int>& nums) {\n    int max = *std::max_element(nums.begin(), nums.end());\n    for (int i = 1; i <= max; i++) {\n        if ((i == *std::count_if(nums.begin(), nums.end(), [i](int x) { return x >= i; }))) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    std::vector<int> test1 = {2, 3, 4};\n    std::cout << \"Test case 1: \" << specialArray(test1) << std::endl;\n\n    std::vector<int> test2 = {3, 5, 20, 2, 3, 16, 7};\n    std::cout << \"Test case 2: \" << specialArray(test2) << std::endl;\n\n    std::vector<int> test3 = {1, 2, 2, 3, 5};\n    std::cout << \"Test case 3: \" << specialArray(test3) << std::endl;\n}\n```",
  "1609": "```\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode *left, TreeNode *right)\n        : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    bool isEvenOddTree(TreeNode* root) {\n        if (!root)\n            return true;\n\n        queue<TreeNode*> q;\n        q.push(root);\n\n        int level = 0;\n\n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n\n                if ((level % 2 == 0 && node->val % 2 != 0) || \n                    (level % 2 != 0 && node->val % 2 == 0))\n                    return false;\n\n                if (node->left)\n                    q.push(node->left);\n                if (node->right)\n                    q.push(node->right);\n\n            }\n            level++;\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(4);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(4);\n    cout << \"Test case 1: \" << (solution.isEvenOddTree(root1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(6);\n    root2->left->left = new TreeNode(4);\n    cout << \"Test case 2: \" << (solution.isEvenOddTree(root2) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(10);\n    root3->right = new TreeNode(4);\n    cout << \"Test case 3: \" << (solution.isEvenOddTree(root3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1610": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint visiblePoints(std::vector<std::vector<int>>& arrays) {\n    int maxVisible = 0;\n    for (const auto& array : arrays) {\n        std::sort(array.begin(), array.end());\n        int prev = -1;\n        int visible = 0;\n        for (const auto& point : array) {\n            if (point > prev) {\n                visible++;\n                prev = point;\n            }\n        }\n        maxVisible = std::max(maxVisible, visible);\n    }\n    return maxVisible;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> arrays1 = {{2, 3, 5}, {0, 4, 7}};\n    std::cout << \"Test Case 1: \" << visiblePoints(arrays1) << std::endl;\n\n    // Test case 2\n    std::vector<std::vector<int>> arrays2 = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};\n    std::cout << \"Test Case 2: \" << visiblePoints(arrays2) << std::endl;\n\n    // Test case 3\n    std::vector<std::vector<int>> arrays3 = {{1, 4, 5}, {6, 7, 8}};\n    std::cout << \"Test Case 3: \" << visiblePoints(arrays3) << std::endl;\n}\n```",
  "1611": "```\n#include <iostream>\n#include <vector>\n\nint minBitFlips(std::vector<int>& arr) {\n    int res = 0;\n    for (int num : arr) {\n        while (num > 0) {\n            if ((num & 1)) res++;\n            num >>= 1;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << minBitFlips({14, 0}) << std::endl; // Output: 4\n    std::cout << minBitFlips({5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}) << std::endl; // Output: 20\n    std::cout << minBitFlips({0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14}) << std::endl; // Output: 32\n    return 0;\n}\n```",
  "1613": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> findMissingIds(std::vector<std::vector<int>>& ids) {\n        if (ids.empty()) return {};\n        \n        std::sort(ids.begin(), ids.end());\n        \n        std::set<int> seen;\n        for (const auto& id : ids) {\n            seen.insert(id[0]);\n            seen.insert(id[1] + 1); // one more than the last id\n        }\n        \n        std::vector<int> missingIds;\n        for (int i = 1; ; ++i) {\n            if (!seen.count(i)) {\n                missingIds.push_back(i);\n            } else if (i >= *seen.rbegin()) {\n                break;\n            }\n        }\n        \n        return missingIds;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<std::vector<int>> ids1 = {{3,5},{4,7}};\n    std::cout << \"Test Case 1: \";\n    for (const auto& id : solution.findMissingIds(ids1)) {\n        std::cout << id << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> ids2 = {{1,3},{4,6}};\n    std::cout << \"Test Case 2: \";\n    for (const auto& id : solution.findMissingIds(ids2)) {\n        std::cout << id << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> ids3 = {{1,5},{6,8}};\n    std::cout << \"Test Case 3: \";\n    for (const auto& id : solution.findMissingIds(ids3)) {\n        std::cout << id << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1612": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    char val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(char x) : val(x), left(NULL), right(NULL) {}\n};\n\nbool isEquivalent(TreeNode* p, TreeNode* q) {\n    if (p == NULL && q == NULL) return true;\n    if (p == NULL || q == NULL) return false;\n    if (p->val != q->val) return false;\n\n    return isEquivalent(p->left, q->left) && isEquivalent(p->right, q->right);\n}\n\nbool checkEqual(TreeNode* p, TreeNode* q) {\n    if (isEquivalent(p, q)) return true;\n    \n    string expression1 = \"\";\n    string expression2 = \"\";\n\n    queue<TreeNode*> q1;\n    queue<TreeNode*> q2;\n\n    q1.push(p);\n    q2.push(q);\n\n    while (!q1.empty() || !q2.empty()) {\n        if (q1.empty()) break;\n        TreeNode* node1 = q1.front();\n        q1.pop();\n\n        if (q2.empty()) break;\n        TreeNode* node2 = q2.front();\n        q2.pop();\n\n        expression1 += (node1->val == '+') ? \" + 0\" : to_string(node1->val);\n        expression2 += (node2->val == '+') ? \" + 0\" : to_string(node2->val);\n\n        if (node1->left) {\n            q1.push(node1->left);\n            q2.push(node2->left);\n        }\n\n        if (node1->right) {\n            q1.push(node1->right);\n            q2.push(node2->right);\n        }\n    }\n\n    return expression1 == expression2;\n}\n\nint main() {\n    TreeNode* p = new TreeNode('+');\n    p->left = new TreeNode('3');\n    p->right = new TreeNode('-');\n    p->right->left = new TreeNode('4');\n    p->right->right = new TreeNode('2');\n\n    TreeNode* q = new TreeNode('+');\n    q->left = new TreeNode('3');\n    q->right = new TreeNode('-');\n    q->right->left = new TreeNode('2');\n    q->right->right = new TreeNode('4');\n\n    cout << (checkEqual(p, q) ? \"True\" : \"False\") << endl;\n\n    p = NULL;\n    q = NULL;\n\n    p = new TreeNode('*');\n    p->left = new TreeNode('-');\n    p->left->left = new TreeNode('2');\n    p->left->right = new TreeNode('3');\n    p->right = new TreeNode('+');\n    p->right->left = new TreeNode('4');\n    p->right->right = new TreeNode('5');\n\n    q = new TreeNode('*');\n    q->left = new TreeNode('-');\n    q->left->left = new TreeNode('5');\n    q->left->right = new TreeNode('2');\n    q->right = new TreeNode('+');\n    q->right->left = new TreeNode('4');\n    q->right->right = new TreeNode('3');\n\n    cout << (checkEqual(p, q) ? \"True\" : \"False\") << endl;\n\n    p = NULL;\n    q = NULL;\n\n    p = new TreeNode('=');\n    p->left = new TreeNode('0');\n    p->right = new TreeNode('+');\n    p->right->left = new TreeNode('-');\n    p->right->left->left = new TreeNode('3');\n    p->right->left->right = new TreeNode('2');\n\n    q = new TreeNode('=');\n    q->left = new TreeNode('0');\n    q->right = new TreeNode('+');\n    q->right->left = new TreeNode('-');\n    q->right->left->left = new TreeNode('3');\n    q->right->left->right = new TreeNode('2');\n\n    cout << (checkEqual(p, q) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}",
  "1614": "```\n#include <iostream>\n#include <stack>\n#include <string>\n\nint maxDepth(std::string s) {\n    int depth = 0;\n    for (char c : s) {\n        if (c == '(') {\n            depth++;\n        } else if (c == ')') {\n            depth--;\n        }\n    }\n    return depth;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << maxDepth(\"(()())\") << std::endl; // Expected output: 2\n    std::cout << \"Test Case 2: \" << maxDepth(\"((()))\") << std::endl; // Expected output: 3\n    std::cout << \"Test Case 3: \" << maxDepth(\"(a(b(c(d)e)f(g))h(i(j)))k\") << std::endl; // Expected output: 6\n\n    return 0;\n}\n```",
  "1616": "```\n#include <iostream>\n#include <string>\n\nbool canBePalindrome(std::string s1, std::string s2) {\n    int i = 0, j = s1.length() - 1;\n    while (i <= j) {\n        if (s1[i] != s2[j]) break;\n        i++;\n        j--;\n    }\n    return i > j;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << (canBePalindrome(\"abpcbe\", \"bapcu\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test Case 2: \" << (canBePalindrome(\"a\", \"b\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test Case 3: \" << (canBePalindrome(\"\", \"\") ? \"Pass\" : \"Fail\") << std::endl;\n    return 0;\n}\n```",
  "1615": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxRank(int n, vector<vector<int>>& roads) {\n        vector<vector<pair<int, int>>> graph(n);\n        for (auto road : roads) {\n            graph[road[0]].push_back({road[1], 1});\n            graph[road[1]].push_back({road[0], 1});\n        }\n        \n        int rank = 0;\n        for (int i = 0; i < n; i++) {\n            for (auto neighbor : graph[i]) {\n                if (!neighbor.second) {\n                    neighbor.second = true;\n                    rank++;\n                }\n            }\n        }\n        return rank;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n1 = 5;\n    vector<vector<int>> roads1 = {{0,1},{1,2},{2,3},{3,4}};\n    cout << \"Test case 1: \" << solution.maxRank(n1, roads1) << endl;\n\n    // Test case 2\n    int n2 = 8;\n    vector<vector<int>> roads2 = {{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7}};\n    cout << \"Test case 2: \" << solution.maxRank(n2, roads2) << endl;\n\n    // Test case 3\n    int n3 = 15;\n    vector<vector<int>> roads3 = {{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{9,10},{10,11},{11,12},{12,13},{13,14}};\n    cout << \"Test case 3: \" << solution.maxRank(n3, roads3) << endl;\n\n    return 0;\n}\n```",
  "1617": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxDistance(int n, vector<vector<int>>& edges) {\n        vector<vector<int>> g(n);\n        for (vector<int> edge : edges) {\n            g[edge[0]].push_back(edge[1]);\n            g[edge[1]].push_back(edge[0]);\n        }\n        \n        vector<int> dp(n, 0), mx(1 << 20, 0);\n        function<void(int, int)> dfs = [&](int node, int parent) {\n            if (dp[node]) return;\n            dp[node] = 1;\n            for (int neighbor : g[node]) {\n                if (neighbor == parent) continue;\n                dfs(neighbor, node);\n                mx[dp[node] | dp[neighbor]] = max(mx[dp[node] | dp[neighbor]], dp[node] + dp[neighbor]);\n            }\n        };\n        \n        int ans = 0;\n        for (int i = 1; i < n; i++) {\n            if (!dp[i]) continue;\n            dfs(i, -1);\n            ans += mx[i];\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution s;\n    vector<vector<int>> edges1 {{1,2},{2,3}};\n    cout << s.maxDistance(4, edges1) << endl; // Output: 2\n\n    vector<vector<int>> edges2 {{0,1},{1,2},{2,3},{3,4},{4,5}};\n    cout << s.maxDistance(6, edges2) << endl; // Output: 5\n\n    vector<vector<int>> edges3 {{0,1},{0,2},{1,2}};\n    cout << s.maxDistance(3, edges3) << endl; // Output: 3\n    return 0;\n}\n```",
  "1618": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint maxFont(vector<int>& sentence, vector<vector<int>>& screen) {\n    int left = 0;\n    int right = 10000;\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n        bool canFit = true;\n        for (int i = 0; i < sentence.size(); i++) {\n            if (screen[i].size() * mid > sentence[i]) {\n                canFit = false;\n                break;\n            }\n        }\n        if (!canFit) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    return left;\n}\n\nint main() {\n    vector<int> sentence = {4, 10};\n    vector<vector<int>> screen = {{12}, {5, 5}};\n    cout << \"Test case 1: \" << maxFont(sentence, screen) << endl;\n\n    sentence = {9, 3, 6};\n    screen = {{15}, {7, 2}};\n    cout << \"Test case 2: \" << maxFont(sentence, screen) << endl;\n\n    sentence = {23, 12};\n    screen = {{14}, {8, 6}};\n    cout << \"Test case 3: \" << maxFont(sentence, screen) << endl;\n    \n    return 0;\n}\n```",
  "1619": "```\n#include <iostream>\n#include <vector>\n\ndouble average(std::vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) {\n        sum += num;\n    }\n    return static_cast<double>(sum) / nums.size();\n}\n\nint main() {\n    std::cout << \"Test Case 1: \";\n    std::vector<int> test1 = {2, 5};\n    double result1 = average(test1);\n    if (std::abs(result1 - 3.5) < 0.001) {\n        std::cout << \"Pass\" << std::endl;\n    } else {\n        std::cout << \"Fail\" << std::endl;\n    }\n\n    std::cout << \"Test Case 2: \";\n    std::vector<int> test2 = {0, 4};\n    double result2 = average(test2);\n    if (std::abs(result2 - 2) < 0.001) {\n        std::cout << \"Pass\" << std::endl;\n    } else {\n        std::cout << \"Fail\" << std::endl;\n    }\n\n    std::cout << \"Test Case 3: \";\n    std::vector<int> test3 = {1, 12};\n    double result3 = average(test3);\n    if (std::abs(result3 - 6.5) < 0.001) {\n        std::cout << \"Pass\" << std::endl;\n    } else {\n        std::cout << \"Fail\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1621": "```\n#include <iostream>\n#include <vector>\n\nint totalSegments(int n, int k) {\n    if (n <= 2 * k) return 1;\n    std::vector<int> dp(n + 1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = dp[i - 1];\n        for (int j = 1; j <= k && j <= i; j++) {\n            dp[i] += dp[i - j];\n        }\n    }\n    return dp[n];\n}\n\nint main() {\n    std::cout << totalSegments(4, 2) << std::endl;\n    std::cout << totalSegments(6, 3) << std::endl;\n    std::cout << totalSegments(10, 5) << std::endl;\n    return 0;\n}\n```",
  "1620": "```\n#include <iostream>\n#include <vector>\n\nint maxQuality(int rows, int cols, std::vector<std::vector<int>>& quality) {\n    int maxQuality = -1;\n    for (int r = 0; r < rows; r++) {\n        for (int c = 0; c < cols; c++) {\n            int total = 0;\n            for (int i = -1; i <= 1; i++) {\n                for (int j = -1; j <= 1; j++) {\n                    if ((i == 0 && j == 0) || r + i < 0 || c + j < 0 || r + i >= rows || c + j >= cols)\n                        continue;\n                    total += quality[r + i][c + j];\n                }\n            }\n            maxQuality = std::max(maxQuality, total);\n        }\n    }\n    return maxQuality;\n}\n\nint main() {\n    // Test case 1\n    int rows1 = 3;\n    int cols1 = 2;\n    std::vector<std::vector<int>> quality1 = {{73, 82}, {77, 71}, {78, 70}};\n    int expected1 = 111;\n    if (maxQuality(rows1, cols1, quality1) != expected1) {\n        return 1; // fail\n    }\n\n    // Test case 2\n    int rows2 = 3;\n    int cols2 = 4;\n    std::vector<std::vector<int>> quality2 = {{70, 96, 98, 95}, {65, 82, 74, 72}, {68, 97, 84, 67}};\n    int expected2 = 206;\n    if (maxQuality(rows2, cols2, quality2) != expected2) {\n        return 1; // fail\n    }\n\n    // Test case 3\n    int rows3 = 5;\n    int cols3 = 1;\n    std::vector<std::vector<int>> quality3 = {{73}, {68}, {72}, {65}, {69}};\n    int expected3 = 104;\n    if (maxQuality(rows3, cols3, quality3) != expected3) {\n        return 1; // fail\n    }\n\n    std::cout << \"All test cases passed!\" << std::endl;\n    return 0;\n}\n```",
  "1622": "```\n#include <iostream>\n#include <vector>\n\nclass FancySequence {\npublic:\n    int getFancySum(int m, std::vector<int>& arr) {\n        int n = arr.size();\n        std::vector<std::vector<long long>> dp(n + 1, std::vector<long long>(m + 1));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= m; j++) {\n                if (j == 0) {\n                    dp[i][j] = arr[i];\n                } else {\n                    dp[i][j] = (dp[i - 1][j - 1] + arr[i]) % (int)1e9;\n                }\n            }\n        }\n        int fancySum = 0;\n        for (int i = 0; i < n; i++) {\n            fancySum += dp[i][m];\n        }\n        return fancySum;\n    }\n};\n\nint main() {\n    FancySequence fs;\n\n    // Test case 1\n    std::vector<int> arr1 = {4, 3, 2, 1};\n    int m1 = 3;\n    int result1 = fs.getFancySum(m1, arr1);\n    std::cout << \"Test case 1: Expected 10, got \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<int> arr2 = {1};\n    int m2 = 0;\n    int result2 = fs.getFancySum(m2, arr2);\n    std::cout << \"Test case 2: Expected 1, got \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<int> arr3 = {10, 20};\n    int m3 = 5;\n    int result3 = fs.getFancySum(m3, arr3);\n    std::cout << \"Test case 3: Expected 50, got \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1623": "```\n#include <iostream>\n#include <vector>\n\nbool countryIsValid(const std::vector<std::vector<int>>& borders) {\n    for (int i = 0; i < borders.size(); i++) {\n        for (int j = 0; j < borders[i].size(); j++) {\n            if (borders[i][j] >= i + 1 && borders[i][j] <= borders.size() && std::count(borders.begin(), borders.end(), borders[i][j]) > 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::vector<int>> borders1 = {{0, 1}, {2, 3}};\n    if (!countryIsValid(borders1)) {\n        std::cout << \"Test Case 1 failed.\" << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<std::vector<int>> borders2 = {{0, 1}, {1, 2}, {2, 3}};\n    if (!countryIsValid(borders2)) {\n        std::cout << \"Test Case 2 failed.\" << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<std::vector<int>> borders3 = {{0, 1}, {1, 2}, {2, 0}};\n    if (!countryIsValid(borders3)) {\n        std::cout << \"Test Case 3 failed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1624": "```\n#include <iostream>\n#include <string>\n\nint largestSubStringBetweenTwoEqualCharacters(const std::string& s) {\n    int res = 0;\n    for (int i = 0; i < s.size(); i++) {\n        char c = s[i];\n        int j = i + 1;\n        while (j < s.size() && s[j] != c) {\n            j++;\n        }\n        if (j - i > res) {\n            res = j - i;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << largestSubStringBetweenTwoEqualCharacters(\"aaabaab!\") << std::endl;\n    std::cout << largestSubSubstringBetweenTwoEqualCharacters(\"abcba\") << std::endl;\n    std::cout << largestSubStringBetweenTwoEqualCharacters(\"adcbcbbba\") << std::endl;\n    return 0;\n}",
  "1625": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string findSmallestString(std::vector<std::string>& s) {\n    int n = s.size();\n    std::vector<char> res(n);\n    for (int i = 0; i < n; ++i) {\n        if (s[i].size() > 0) {\n            char c = s[i][0];\n            res[i] = c;\n            for (int j = 1; j < s[i].size(); ++j) {\n                if (c < s[i][j]) {\n                    res[i] = s[i][j];\n                    break;\n                }\n            }\n        }\n    }\n    std::string ans;\n    for (char c : res) {\n        ans += c;\n    }\n    return ans;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::string> input1 = {\"ca\",\"cb\"};\n    std::cout << \"Test Case 1: \" << findSmallestString(input1) << std::endl;\n\n    // Test Case 2\n    std::vector<std::string> input2 = {\"aaa\",\"aa\",\"a\"};\n    std::cout << \"Test Case 2: \" << findSmallestString(input2) << std::endl;\n\n    // Test Case 3\n    std::vector<std::string> input3 = {\"vxyd\",\"vixy\",\"xxz\",\"zyt\"};\n    std::cout << \"Test Case 3: \" << findSmallestString(input3) << std::endl;\n    return 0;\n}\n```",
  "1626": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint bestTeamScore(std::vector<std::vector<int>>& scores) {\n    int n = scores.size();\n    std::vector<int> dp(n, 0);\n    for (int i = 0; i < n; i++) {\n        int score = scores[i][0];\n        bool flag = true;\n        for (int j = 1; j < scores[i].size(); j++) {\n            if (scores[i][j] > dp[i-1]) {\n                score += scores[i][j];\n                flag = false;\n            }\n        }\n        dp[i] = flag ? score : dp[i-1];\n    }\n    int ans = dp[0];\n    for (int i = 1; i < n; i++) {\n        if (dp[i] > dp[i-1]) {\n            ans = dp[i];\n        } else {\n            ans = std::max(ans, dp[i]);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int T = 3;\n    for (int t = 0; t < T; t++) {\n        if (t == 0) {\n            std::vector<std::vector<int>> scores = {{1, 3}, {2, 5}, {5, 10}, {6, 13}, {7, 15}};\n            int res = bestTeamScore(scores);\n            std::cout << \"Test case \" << t + 1 << \": Expected: 16, Got: \" << res << std::endl;\n        } else if (t == 1) {\n            std::vector<std::vector<int>> scores = {{12,5}, {10,6}, {4,4}};\n            int res = bestTeamScore(scores);\n            std::cout << \"Test case \" << t + 1 << \": Expected: 16, Got: \" << res << std::endl;\n        } else {\n            std::vector<std::vector<int>> scores = {{3,15},{10,5},{11,9}};\n            int res = bestTeamScore(scores);\n            std::cout << \"Test case \" << t + 1 << \": Expected: 20, Got: \" << res << std::endl;\n        }\n    }\n}\n```",
  "1627": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    bool isGraphConnected(std::vector<std::vector<int>>& edges, int threshold) {\n        int n = edges.size();\n        std::vector<int> parent(n);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n\n        for (const auto& edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n\n            if (u > threshold || v > threshold) continue;\n\n            if (find(parent, u) != find(parent, v)) {\n                unionSet(parent, u, v);\n            }\n        }\n\n        return parent.size() == 1;\n    }\n\nprivate:\n    int find(std::vector<int>& parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSet(std::vector<int>& parent, int x, int y) {\n        parent[find(parent, x)] = find(parent, y);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::vector<int>> edges1 = {{0, 1}, {1, 2}, {3, 4}};\n    int threshold1 = 2;\n    if (solution.isGraphConnected(edges1, threshold1)) {\n        std::cout << \"Test Case 1: Graph is connected.\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1: Graph is not connected.\" << std::endl;\n    }\n\n    // Test Case 2\n    std::vector<std::vector<int>> edges2 = {{0, 1}, {1, 2}};\n    int threshold2 = 3;\n    if (solution.isGraphConnected(edges2, threshold2)) {\n        std::cout << \"Test Case 2: Graph is connected.\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2: Graph is not connected.\" << std::endl;\n    }\n\n    // Test Case 3\n    std::vector<std::vector<int>> edges3 = {{0, 1}, {1, 2}, {2, 3}};\n    int threshold3 = 4;\n    if (solution.isGraphConnected(edges3, threshold3)) {\n        std::cout << \"Test Case 3: Graph is connected.\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3: Graph is not connected.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1629": "```\n#include <iostream>\n#include <string>\n\nint slowestKey(std::vector<std::pair<char, int>>& keysPressed) {\n    int maxTime = 0;\n    char result = ' ';\n\n    for (auto& key : keysPressed) {\n        if (key.second > maxTime) {\n            maxTime = key.second;\n            result = key.first;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<std::pair<char, int>> testCases[] = {\n        {{a, 1}, {b, 12}, {c, 23}, {d, 123}, {e, 1456}},\n        {{w, 8}, {w, 3}, e, 2}, {{o, 5}, i, 10}, {p, 7}, {p, 1}},\n        {{a, 1}, {a, 12}, {b, 23}, {c, 1234}},\n    };\n\n    for (int i = 0; i < sizeof(testCases) / sizeof(testCases[0]); ++i) {\n        std::cout << \"Test Case \" << i + 1 << \": \";\n        std::cout << slowestKey(testCases[i]) << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1628": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass ExpressionTree {\npublic:\n    TreeNode* evalRPN(vector<string>& tokens) {\n        if (tokens.empty()) return NULL;\n\n        TreeNode* root = new TreeNode(stoi(tokens[0]));\n        for (int i = 1; i < tokens.size(); i++) {\n            string op = tokens[i];\n            int val2 = stoi(tokens[i + 1]);\n            int val1 = root->val;\n            delete root;\n            root = new TreeNode(getOpValue(op, val1, val2));\n            i++;\n        }\n        return root;\n    }\n\n    int getOpValue(string op, int a, int b) {\n        if (op == \"+\") return a + b;\n        else if (op == \"-\") return a - b;\n        else if (op == \"*\") return a * b;\n        else if (op == \"/\") return a / b;\n        return 0; // error\n    }\n};\n\nint main() {\n    vector<string> tokens1 = {\"2\",\"1\",\"+\",\"3\"};\n    ExpressionTree tree1;\n    TreeNode* root1 = tree1.evalRPN(tokens1);\n    cout << \"Test Case 1: \" << root1->val << endl;\n\n    vector<string> tokens2 = {\"4\",\"13\",\"5\",\"/\",\"+\"];\n    ExpressionTree tree2;\n    TreeNode* root2 = tree2.evalRPN(tokens2);\n    cout << \"Test Case 2: \" << root2->val << endl;\n\n    vector<string> tokens3 = {\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\" ,\"//\" ,\"*\",\"1\",\"-\",\"+\"};\n    ExpressionTree tree3;\n    TreeNode* root3 = tree3.evalRPN(tokens3);\n    cout << \"Test Case 3: \" << root3->val << endl;\n\n    return 0;\n}\n```",
  "1630": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> getArithmeticSubarrays(int numSize, vector<int>& nums, vector<int>& queries) {\n        // your solution here\n    }\n};\n\nint main() {\n    Solution sol;\n    \n    int numSize = 5;\n    vector<int> nums = {12, 2, 6, 4, 3};\n    vector<int> queries = {0, 1};\n    \n    cout << \"Test Case 1: \";\n    vector<vector<int>> res1 = sol.getArithmeticSubarrays(numSize, nums, queries);\n    for (auto &vec : res1) {\n        for (int num : vec) {\n            cout << num << \" \";\n        }\n    }\n    cout << endl;\n    \n    numSize = 2;\n    nums = {4};\n    queries = {0};\n    \n    cout << \"Test Case 2: \";\n    vector<vector<int>> res2 = sol.getArithmeticSubarrays(numSize, nums, queries);\n    for (auto &vec : res2) {\n        for (int num : vec) {\n            cout << num << \" \";\n        }\n    }\n    cout << endl;\n    \n    numSize = 9;\n    nums = {1, 2, -3, 4, 5, 6, 7, 8, 9};\n    queries = {0, 1, 8};\n    \n    cout << \"Test Case 3: \";\n    vector<vector<int>> res3 = sol.getArithmeticSubarrays(numSize, nums, queries);\n    for (auto &vec : res3) {\n        for (int num : vec) {\n            cout << num << \" \";\n        }\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1631": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minEffort(vector<vector<int>>& hills) {\n        int m = hills.size();\n        if(m == 0) return 0;\n        int n = hills[0].size();\n        \n        vector<vector<int>> visited(m, vector<int>(n));\n        \n        int ans = INT_MAX;\n        for(int i=0; i<m; i++) {\n            for(int j=0; j<n; j++) {\n                if(i==0 || j==0 || i==m-1 || j==n-1) continue;\n                \n                visited[i][j] = hills[i][j];\n                int curAns = 0;\n                bool canVisit = true;\n                \n                for(int x=-1; x<=1; x++) {\n                    for(int y=-1; y<=1; y++) {\n                        if(x==0 && y==0) continue;\n                        int nx = i + x;\n                        int ny = j + y;\n                        \n                        if(nx>=0 && nx<m && ny>=0 && ny<n) {\n                            if(visited[nx][ny] > hills[i][j]) {\n                                visited[nx][ny] = hills[i][j];\n                                curAns++;\n                            }\n                            else canVisit = false;\n                        }\n                    }\n                }\n                \n                if(canVisit) ans = min(ans, curAns);\n            }\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    Solution s;\n\n    // Test Case 1:\n    vector<vector<int>> hills1 = {{0,0,1},{0,1,2},{1,3,4}};\n    cout << \"Test Case 1: \" << s.minEffort(hills1) << endl; \n\n    // Test Case 2:\n    vector<vector<int>> hills2 = {{1,2,5},{4,8,10}};\n    cout << \"Test Case 2: \" << s.minEffort(hills2) << endl; \n\n    // Test Case 3:\n    vector<vector<int>> hills3 = {{5,6,7,8,9},{1,2,4,9,11},{2,3,9,10,12}};\n    cout << \"Test Case 3: \" << s.minEffort(hills3) << endl; \n\n    return 0;\n}\n```",
  "1633": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint numOfUsersAttended(int loginTime, int endTime) {\n    if (loginTime > endTime) {\n        return 0;\n    }\n    return endTime - loginTime + 1;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << numOfUsersAttended(4, 7) << std::endl; // Expected output: 4\n    std::cout << \"Test Case 2: \" << numOfUsersAttended(10, 14) << std::endl; // Expected output: 5\n    std::cout << \"Test Case 3: \" << numOfUsersAttended(7, 6) << std::endl; // Expected output: 0\n\n    return 0;\n}\n```",
  "1632": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> rankTransform(vector<vector<char>>& grid) {\n        int m = grid.size();\n        if (m == 0) return {};\n\n        int n = grid[0].size();\n        vector<vector<int>> res(m, vector<int>(n));\n        vector<pair<int, int>> cells;\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 'O') cells.emplace_back(i, j);\n            }\n        }\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] != 'O' && grid[i][j] != 'X') continue;\n                int val = (grid[i][j] == 'O' ? 1 : -1);\n                for (auto p : cells) {\n                    if (i == p.first && j == p.second) res[i][j] += val;\n                }\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<char>> grid1 = {{'0', '0', '1'}, {'1', '1', '0'}, {'0', '2', '0'}};\n    vector<vector<int>> expected1 = {{0, 0, 1}, {1, 1, 0}, {0, 2, 0}};\n    auto result1 = solution.rankTransform(grid1);\n    for (int i = 0; i < grid1.size(); ++i) {\n        for (int j = 0; j < grid1[0].size(); ++j) {\n            cout << result1[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<char>> grid2 = {{'0', '1'}, {'1', '0'}};\n    vector<vector<int>> expected2 = {{1, -1}, {-1, 1}};\n    auto result2 = solution.rankTransform(grid2);\n    for (int i = 0; i < grid2.size(); ++i) {\n        for (int j = 0; j < grid2[0].size(); ++j) {\n            cout << result2[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<char>> grid3 = {{'O', 'O', '1'}, {'O', 'O', '0'}, {'0', '1', '0'}};\n    vector<vector<int>> expected3 = {{1, 1, -1}, {1, 1, 0}, {0, -1, 0}};\n    auto result3 = solution.rankTransform(grid3);\n    for (int i = 0; i < grid3.size(); ++i) {\n        for (int j = 0; j < grid3[0].size(); ++j) {\n            cout << result3[i][j] << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}",
  "1635": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numMusicPlaylists(int n, int start1, int skip1, int start2, int skip2) {\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (i >= start1 && i % (skip1 + 1) != start1 % (skip1 + 1)) {\n                res += min(i - start1 + 1, skip1 + 1);\n            }\n            if (i >= start2 && i % (skip2 + 1) != start2 % (skip2 + 1)) {\n                res += min(i - start2 + 1, skip2 + 1);\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.numMusicPlaylists(5, 3, 1, 4, 2) << endl; // expected output: 8\n    cout << \"Test case 2: \" << solution.numMusicPlaylists(10, 2, 0, 6, 1) << endl; // expected output: 26\n    cout << \"Test case 3: \" << solution.numMusicPlaylists(7, 1, 0, 5, 2) << endl; // expected output: 14\n\n    return 0;\n}\n```",
  "1634": "```\n#include <iostream>\nusing namespace std;\n\nstruct PolyNode {\n    int coeff;\n    int power;\n    PolyNode* next;\n};\n\nPolyNode* addPolyLists(PolyNode* p1, PolyNode* p2) {\n    if (p1 == nullptr && p2 == nullptr) return nullptr;\n    if (p1 == nullptr) return p2;\n    if (p2 == nullptr) return p1;\n\n    PolyNode* head = nullptr;\n    int carry = 0;\n\n    while (p1 != nullptr || p2 != nullptr || carry > 0) {\n        int sum = carry;\n        if (p1 != nullptr) sum += p1->coeff;\n        if (p2 != nullptr) sum += p2->coeff;\n\n        PolyNode* newNode = new PolyNode();\n        newNode->coeff = sum % 10;\n        newNode->power = p1 ? p1->power : p2->power;\n        carry = sum / 10;\n\n        if (head == nullptr) head = newNode;\n        else {\n            PolyNode* temp = head;\n            while (temp->next != nullptr) temp = temp->next;\n            temp->next = newNode;\n        }\n\n        if (p1 != nullptr) p1 = p1->next;\n        if (p2 != nullptr) p2 = p2->next;\n    }\n\n    return head;\n}\n\nvoid printPoly(PolyNode* p) {\n    while (p != nullptr) {\n        cout << p->coeff << \"x^\" << p->power << (p->next ? \" + \" : \"\\n\");\n        p = p->next;\n    }\n}\n\nint main() {\n    // Test Case 1\n    PolyNode* p1 = new PolyNode();\n    p1->coeff = 2;\n    p1->power = 3;\n\n    PolyNode* p2 = new PolyNode();\n    p2->coeff = 5;\n    p2->power = 4;\n\n    PolyNode* result = addPolyLists(p1, p2);\n    cout << \"Test Case 1: \";\n    printPoly(result);\n\n    // Test Case 2\n    p1 = nullptr;\n    p2 = new PolyNode();\n    p2->coeff = 7;\n    p2->power = 5;\n\n    result = addPolyLists(p1, p2);\n    cout << \"\\nTest Case 2: \";\n    printPoly(result);\n\n    // Test Case 3\n    p1 = new PolyNode();\n    p1->coeff = 9;\n    p1->power = 4;\n\n    p2 = new PolyNode();\n    p2->coeff = 5;\n    p2->power = 3;\n\n    result = addPolyLists(p1, p2);\n    cout << \"\\nTest Case 3: \";\n    printPoly(result);\n\n    return 0;\n}\n```",
  "1636": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> frequencySort(vector<int>& nums) {\n        unordered_map<int, int> count;\n        for (int num : nums) {\n            count[num]++;\n        }\n        \n        priority_queue<pair<int, int>> pq;\n        for (auto& pair : count) {\n            pq.push({pair.second, pair.first});\n        }\n        \n        vector<int> result;\n        while (!pq.empty()) {\n            int freq = pq.top().first;\n            int num = pq.top().second;\n            for (int i = 0; i < freq; i++) {\n                result.push_back(num);\n            }\n            pq.pop();\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {2,3,1,3,3};\n    vector<int> expected1 = {3, 1, 2};\n    if (solution.frequencySort(nums1) != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n        return -1;\n    }\n    cout << \"Test case 1 passed.\" << endl;\n\n    // Test case 2\n    vector<int> nums2 = {0,1};\n    vector<int> expected2 = {0, 1};\n    if (solution.frequencySort(nums2) != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n        return -1;\n    }\n    cout << \"Test case 2 passed.\" << endl;\n\n    // Test case 3\n    vector<int> nums3 = {4,2,7,2};\n    vector<int> expected3 = [2, 7, 4];\n    if (solution.frequencySort(nums3) != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n        return -1;\n    }\n    cout << \"Test case 3 passed.\" << endl;\n\n    cout << \"All test cases passed.\" << endl;\n    return 0;\n}\n```",
  "1638": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint countSubstrings(vector<string>& words) {\n    int res = 0;\n    for (int i = 0; i < words.size(); i++) {\n        for (int j = i + 1; j <= words.size(); j++) {\n            string s1 = words[i];\n            string s2 = (j == words.size()) ? \"\" : words[j];\n            int diffCount = 0;\n            for (int k = 0; k < min(s1.length(), s2.length()); k++) {\n                if (s1[k] != s2[k]) {\n                    diffCount++;\n                }\n            }\n            res += (diffCount == 1);\n        }\n    }\n    return res;\n}\n\nint main() {\n    vector<string> words = {\"abc\",\"bcd\",\"ace!!\"};\n    cout << \"Test Case 1: \" << countSubstrings(words) << endl;\n\n    words = {\"abcd\",\"acd!!\"};\n    cout << \"Test Case 2: \" << countSubstrings(words) << endl;\n\n    words = {\"ab\", \"a\", \"ba\" };\n    cout << \"Test Case 3: \" << countSubstrings(words) << endl;\n    \n    return 0;\n}\n```",
  "1637": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxArea(std::vector<std::vector<int>>& points) {\n    if (points.empty()) return 0;\n    \n    int minx = *min_element(points.begin(), points.end(), \n        [](const auto& a, const auto& b){return a[0] < b[0];})[0];\n    int maxx = *max_element(points.begin(), points.end(), \n        [](const auto& a, const auto& b){return a[0] > b[0];})[0];\n    \n    std::vector<int> heights;\n    for (int x : {minx, maxx}) {\n        int max_height = 0;\n        for (const auto& point : points) {\n            if (point[0] == x) {\n                max_height = std::max(max_height, point[1]);\n            }\n        }\n        heights.push_back(max_height);\n    }\n    \n    int res = 0;\n    int left = 0, right = heights.size() - 1;\n    while (left < right) {\n        if (heights[left] < heights[right]) {\n            res = std::max(res, heights[right] * (right - left));\n            left++;\n        } else {\n            res = std::max(res, heights[left] * (right - left));\n            right--;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> points1 = {{8,7},{9,9},{6,4},{6,8},{3,10}};\n    std::cout << \"Test case 1: \" << maxArea(points1) << std::endl;\n    \n    // Test case 2\n    std::vector<std::vector<int>> points2 = {{0,9},{2,5},{3,12},{5,15},{7,13},{8,17}};\n    std::cout << \"Test case 2: \" << maxArea(points2) << std::endl;\n    \n    // Test case 3\n    std::vector<std::vector<int>> points3 = {{0,1},{9,0}};\n    std::cout << \"Test case 3: \" << maxArea(points3) << std::endl;\n\n    return 0;\n}\n```",
  "1639": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint numWays(std::vector<std::string>& words, std::string target) {\n    int res = 0;\n    for (const auto& word : words) {\n        if (word.size() == target.size()) {\n            int diffCount = 0;\n            for (int i = 0; i < target.size(); ++i) {\n                if (target[i] != word[i]) {\n                    ++diffCount;\n                }\n            }\n            res += (1 << diffCount) - 1;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<std::string> words = {\"ab\", \"ba\", \"c\"};\n    std::cout << numWays(words, \"abc\") << std::endl;  // Expected: 2\n    words = {\"a\", \"b\", \"c\", \"d\"};\n    std::cout << numWays(words, \"ad\") << std::endl;   // Expected: 1\n    words = {\"aa\", \"bb\", \"ba\", \"ab\", \"aac\", \"cba\"};\n    std::cout << numWays(words, \"aab\") << std::endl;   // Expected: 4\n    return 0;\n}\n```",
  "1640": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canBeOrdered(vector<string>& targetArray) {\n        unordered_map<string, int> freq;\n        for (string s : targetArray) {\n            freq[s]++;\n        }\n        for (int i = 0; i < targetArray.size(); i++) {\n            if (targetArray[i].size() > i + 1 || targetArray[i].substr(0, i + 1) != to_string(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<string> targetArray1 = {\"65\", \"25\", \"975\", \"775\", \"19\"};\n    cout << (solution.canBeOrdered(targetArray1) ? \"True\" : \"False\") << endl;\n\n    // Test Case 2\n    vector<string> targetArray2 = {\"123\", \"456\", \"789\"};\n    cout << (solution.canBeOrdered(targetArray2) ? \"True\" : \"False\") << endl;\n\n    // Test Case 3\n    vector<string> targetArray3 = {\"50\", \"10\", \"90\", \"40\", \"30\", \"20\", \"100\"};\n    cout << (solution.canBeOrdered(targetArray3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1641": "```\n#include <iostream>\n#include <vector>\n\nint countVowelStrings(int n) {\n    if (n == 0) return 1;\n    int res = 0;\n    for (int i = 4; i >= 1; --i) {\n        res += (n >= i) ? pow(5, i - 1) : 0;\n    }\n    return res;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << countVowelStrings(1) << std::endl;\n    std::cout << \"Test case 2: \" << countVowelStrings(2) << std::endl;\n    std::cout << \"Test case 3: \" << countVowelStrings(5) << std::endl;\n}\n```",
  "1642": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxBuilding(int n, vector<int>& r) {\n        vector<int> heights(n, 0);\n        for (int i = 0; i < r.size(); i++) {\n            heights[r[i]] = 1;\n        }\n        \n        priority_queue<int> pq;\n        for (int i = 1; i <= n; i++) {\n            if (heights[i] == 1) {\n                pq.push(i);\n            } else {\n                int lastRampIndex = -1;\n                while (!pq.empty()) {\n                    lastRampIndex = pq.top();\n                    pq.pop();\n                }\n                int lastHeight = heights[lastRampIndex];\n                for (int j = lastRampIndex + 1; j <= i; j++) {\n                    if (j == n) {\n                        return i;\n                    } else if (heights[j] != 0) {\n                        break;\n                    } else {\n                        heights[j] = lastHeight + 1;\n                        pq.push(j);\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.maxBuilding(4, vector<int>{2,3}) << endl; // Output: 2\n    cout << solution.maxBuilding(7, vector<int>{2,5,4,6}) << endl; // Output: 5\n    cout << solution.maxBuilding(14, vector<int>{10,11}) << endl; // Output: 13\n\n    return 0;\n}\n```",
  "1643": "```\n#include <iostream>\n#include <vector>\n\nint findKthSmallest(const std::vector<std::vector<int>>& piles) {\n    int n = piles.size();\n    if (n == 0) return -1;\n\n    // Create a vector to store the number of stones for each pile\n    std::vector<int> nums;\n    for (const auto& pile : piles) {\n        nums.push_back(pile[0]);\n    }\n\n    // Sort the piles by the number of stones in descending order\n    std::sort(nums.begin(), nums.end(), [](int a, int b) { return a > b; });\n\n    int k = 1;\n    while (k <= n) {\n        if (nums[k - 1] != nums[0]) break;\n        --nums[0];\n        for (int i = 1; i < k; ++i) {\n            if (nums[i] > 0) {\n                --nums[i];\n                break;\n            }\n            nums[i - 1]--;\n        }\n        nums.pop_back();\n        --k;\n    }\n\n    return nums.size() + 1;\n}\n\nint main() {\n    std::vector<std::vector<int>> piles1 = {{10,5,3},{1,6,8},{2}};\n    int result1 = findKthSmallest(piles1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<std::vector<int>> piles2 = {{60,50,30},{10,20,40}};\n    int result2 = findKthSmallest(piles2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<std::vector<int>> piles3 = {};\n    int result3 = findKthSmallest(piles3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n}\n```",
  "1645": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int getHint(string secret, string guess) {\n        int bulls = 0, cows = 0;\n        \n        unordered_map<char, int> sc, gc;\n        \n        for (int i = 0; i < secret.length(); ++i) {\n            if (secret[i] == guess[i]) {\n                bulls++;\n            } else {\n                sc[secret[i]]++, gc[guess[i]]++;\n            }\n        }\n        \n        for (auto &p : gc) {\n            cows += min(sc.count(p.first), p.second);\n        }\n        \n        return to_string(bulls).append(to_string(cows)).append(\"a\");\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << solution.getHint(\"1123\", \"0111\") << endl;  // Output: 2a\n    cout << solution.getHint(\"1807\", \"7810\") << endl;  // Output: 1a\n    cout << solution.getHint(\"3118\", \"2817\") << endl;  // Output: 1a\n    \n    return 0;\n}\n```",
  "1644": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == nullptr || root == p || root == q)\n            return root;\n\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        if (left != nullptr)\n            return left;\n\n        return lowestCommonAncestor(root->right, p, q);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(5);\n    root1->right = new TreeNode(1);\n    root1->left->left = new TreeNode(6);\n    root1->left->right = new TreeNode(2);\n    root1->right->left = new TreeNode(0);\n    root1->right->right = new TreeNode(8);\n    \n    TreeNode* p1 = root1->left;\n    TreeNode* q1 = root1->left->right;\n\n    TreeNode* res1 = solution.lowestCommonAncestor(root1, p1, q1);\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(4);\n    root2->left = new TreeNode(2);\n    root2->right = new TreeNode(5);\n    \n    TreeNode* p2 = root2;\n    TreeNode* q2 = root2->right;\n\n    TreeNode* res2 = solution.lowestCommonAncestor(root2, p2, q2);\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    \n    TreeNode* p3 = root3;\n    TreeNode* q3 = root3->left;\n\n    TreeNode* res3 = solution.lowestCommonAncestor(root3, p3, q3);\n\n    if (res1 != nullptr) std::cout << \"Test case 1: The lowest common ancestor is \" << res1->val << std::endl;\n    else std::cout << \"Test case 1: No common ancestor found.\" << std::endl;\n\n    if (res2 != nullptr) std::cout << \"Test case 2: The lowest common ancestor is \" << res2->val << std::endl;\n    else std::cout << \"Test case 2: No common ancestor found.\" << std::endl;\n\n    if (res3 != nullptr) std::cout << \"Test case 3: The lowest common ancestor is \" << res3->val << std::endl;\n    else std::cout << \"Test case 3: No common ancestor found.\" << std::endl;\n\n    return 0;\n}",
  "1646": "```\n#include <iostream>\n#include <vector>\n\nint maximum69Integer(int num) {\n    int max = -1;\n    while (num > 0) {\n        int digit = num % 10;\n        if (digit == 6) {\n            return num + 9;\n        }\n        num /= 10;\n    }\n    return max;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << maximum69Integer(8) << \"\\n\";\n    std::cout << \"Test case 2: \" << maximum69Integer(0) << \"\\n\";\n    std::cout << \"Test case 3: \" << maximum69Integer(1000000) << \"\\n\";\n    \n    return 0;\n}\n```",
  "1647": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDeletions(string s) {\n        vector<int> freq(26, 0);\n        for (char c : s) {\n            freq[c - 'a']++;\n        }\n        \n        int deletions = 0;\n        bool unique = false;\n        for (int i = 0; i < 26; i++) {\n            if (freq[i] > 1) {\n                deletions += freq[i] - 1;\n                unique = true;\n            } else if (unique) {\n                return -1;\n            }\n        }\n        \n        return deletions;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.minDeletions(\"aab\") << endl; // Output: 2\n    cout << \"Test Case 2: \" << solution.minDeletions(\"azbazb\") << endl; // Output: 4\n    cout << \"Test Case 3: \" << solution.minDeletions(\"abcdefghijklmnopqrstuvwxyz\") << endl; // Output: 25\n\n    return 0;\n}\n```",
  "1648": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxProfitAssignment(std::vector<int>& assignmentFee, std::vector<int>& newBalls) {\n    int n = assignmentFee.size();\n    std::vector<std::pair<int, int>> balls;\n    for (int i = 0; i < n; ++i) {\n        balls.emplace_back(i + 1, assignmentFee[i]);\n    }\n\n    std::sort(balls.begin(), balls.end());\n\n    int res = 0, prev = 0;\n    for (auto it = newBalls.begin(); it != newBalls.end(); ++it) {\n        while (!balls.empty() && balls.back().second <= *it) {\n            prev = balls.back().first;\n            balls.pop_back();\n        }\n        if (!balls.empty()) {\n            res += prev - balls.front().first + *it - prev;\n        } else {\n            res += *it;\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<int> assignmentFee1 = {10, 20};\n    std::vector<int> newBalls1 = {30, 60};\n    std::cout << \"Case 1: \" << maxProfitAssignment(assignmentFee1, newBalls1) << std::endl;\n\n    std::vector<int> assignmentFee2 = {100, 200, 300, 400, 500};\n    std::vector<int> newBalls2 = {600, 700, 800, 900, 1000};\n    std::cout << \"Case 2: \" << maxProfitAssignment(assignmentFee2, newBalls2) << std::endl;\n\n    std::vector<int> assignmentFee3 = {10, 20, 30, 40, 50, 60, 70, 80, 90, 100};\n    std::vector<int> newBalls3 = {110, 120, 130, 140, 150, 160, 170, 180, 190, 200};\n    std::cout << \"Case 3: \" << maxProfitAssignment(assignmentFee3, newBalls3) << std::endl;\n\n    return 0;\n}\n```",
  "1649": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> result(n);\n        \n        for (int i = 0; i < n; i++) {\n            result[i] = nums[i] * nums[i];\n        }\n        \n        sort(result.begin(), result.end());\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> test1 = {-4, -3, -2, -1, 0, 1, 2, 3, 4};\n    vector<int> expected1 = {0, 1, 4};\n    vector<int> result1 = solution.sortedSquares(test1);\n    for (int i = 0; i < result1.size(); i++) {\n        cout << result1[i] << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<int> test2 = {-7, -3, 2, 3, 6, 8, 10};\n    vector<int> expected2 = {4, 9, 49};\n    vector<int> result2 = solution.sortedSquares(test2);\n    for (int i = 0; i < result2.size(); i++) {\n        cout << result2[i] << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<int> test3 = {1};\n    vector<int> expected3 = {1};\n    vector<int> result3 = solution.sortedSquares(test3);\n    for (int i = 0; i < result3.size(); i++) {\n        cout << result3[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1650": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (!root || root == p || root == q)\n            return root;\n\n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\n\n        if (left && right)\n            return root;\n        else\n            return left ? left : right;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(3);\n    root1->left = new TreeNode(5);\n    root1->right = new TreeNode(1);\n    root1->left->left = new TreeNode(6);\n    root1->left->right = new TreeNode(2);\n    root1->right->left = new TreeNode(0);\n    root1->right->right = new TreeNode(8);\n\n    std::cout << \"Lowest Common Ancestor for test case 1: \";\n    if (solution.lowestCommonAncestor(root1, root1->left->left, root1->left->right))\n        std::cout << solution.lowestCommonAncestor(root1, root1->left->left, root1->left->right)->val;\n    else\n        std::cout << \"NULL\";\n    std::cout << std::endl;\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(4);\n    root2->left = new TreeNode(7);\n    root2->right = new TreeNode(5);\n\n    std::cout << \"Lowest Common Ancestor for test case 2: \";\n    if (solution.lowestCommonAncestor(root2, root2->left, root2->right))\n        std::cout << solution.lowestCommonAncestor(root2, root2->left, root2->right)->val;\n    else\n        std::cout << \"NULL\";\n    std::cout << std::endl;\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(4);\n\n    std::cout << \"Lowest Common Ancestor for test case 3: \";\n    if (solution.lowestCommonAncestor(root3, root3->left, root3->right))\n        std::cout << solution.lowestCommonAncestor(root3, root3->left, root3->right)->val;\n    else\n        std::cout << \"NULL\";\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1651": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findSQLStrings(vector<vector<string>>& sales) {\n        // Your implementation here\n        vector<int> result;\n        for (int i = 0; i < sales.size(); i++) {\n            int total = 0;\n            string prevCity = \"\";\n            bool hasPrevCity = false;\n            for (const auto& sale : sales[i]) {\n                if (sale != \"city\") {\n                    total += stoi(sale);\n                } else {\n                    hasPrevCity = true;\n                }\n                if (hasPrevCity) {\n                    result.push_back(total);\n                    total = 0;\n                    hasPrevCity = false;\n                }\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> sales1 = {{\"2020-01-01\", \"New York\", \"100\"}, {\"2020-01-02\", \"Chicago\", \"50\"}, {\"2020-01-03\", \"city\"}, {\"2020-01-04\", \"Boston\", \"200\"}, {\"2020-01-05\", \"city\"}};\n    vector<int> result1 = solution.findSQLStrings(sales1);\n    for (const auto& num : result1) {\n        cout << num << endl;\n    }\n\n    // Test case 2\n    vector<vector<string>> sales2 = {{\"2019-12-01\", \"Los Angeles\", \"150\"}, {\"2019-12-02\", \"city\", \"200\"}, {\"2019-12-03\", \"San Francisco\", \"300\"}};\n    vector<int> result2 = solution.findSQLStrings(sales2);\n    for (const auto& num : result2) {\n        cout << num << endl;\n    }\n\n    // Test case 3\n    vector<vector<string>> sales3 = {{\"2021-01-01\", \"New York\", \"100\"}, {\"2021-01-02\", \"city\", \"50\"}, {\"2021-01-03\", \"Boston\", \"200\"}};\n    vector<int> result3 = solution.findSQLStrings(sales3);\n    for (const auto& num : result3) {\n        cout << num << endl;\n    }\n\n    return 0;\n}\n```",
  "1652": "```\n#include <iostream>\n#include <vector>\n\nint maxEqualFreq(std::vector<int>& bags) {\n    int n = bags.size();\n    std::vector<int> bagCount(1001, 0);\n    for (int i : bags) bagCount[i]++;\n    \n    for (int i = 1; i <= 1000; i++) {\n        if (bagCount[i] > 0) {\n            int maxFreq = -1;\n            int eqIndex = -1;\n            for (int j = i; j <= 1000 && bagCount[j] > 0; j++) {\n                if (bagCount[j] == bagCount[i]) {\n                    maxFreq = Math.max(maxFreq, j);\n                    eqIndex = j;\n                }\n                bagCount[j]--;\n            }\n            if (maxFreq != -1) {\n                return eqIndex;\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    std::vector<int> bags1({5,10,25});\n    std::cout << maxEqualFreq(bags1) << std::endl;\n\n    std::vector<int> bags2({1,2,3,4,5,6});\n    std::cout << maxEqualFreq(bags2) << std::endl;\n\n    std::vector<int> bags3({20,10,30});\n    std::cout << maxEqualFreq(bags3) << std::endl;\n    return 0;\n}\n```",
  "1653": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minDeletions(string s) {\n        vector<int> left(256, 0);\n        vector<int> right(256, 0);\n        for (char c : s) {\n            left[c]++;\n        }\n        int deletions = 0;\n        int maxDiff = 0;\n        for (int i = 0; i < 256; i++) {\n            if (left[i] > right[i]) {\n                deletions += left[i] - right[i];\n                maxDiff = max(maxDiff, left[i] - right[i]);\n            } else if (right[i] > left[i]) {\n                deletions -= right[i] - left[i];\n            }\n            right[i]++;\n        }\n        return deletions;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s1 = \"aabbbccc\";\n    int result1 = solution.minDeletions(s1);\n    cout << \"Test case 1: \" << result1 << endl;\n\n    // Test case 2\n    string s2 = \"aabbcc\";\n    int result2 = solution.minDeletions(s2);\n    cout << \"Test case 2: \" << result2 << endl;\n\n    // Test case 3\n    string s3 = \"aaaaaa\";\n    int result3 = solution.minDeletions(s3);\n    cout << \"Test case 3: \" << result3 << endl;\n\n    return 0;\n}\n```",
  "1655": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> distributeRepeats(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> res;\n        for (int i = 0; i < n; i++) {\n            bool found = false;\n            for (auto& v : res) {\n                if ((v[0] & 1) == (nums[i] & 1)) {\n                    v.push_back(nums[i]);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                res.push_back({nums[i]});\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution sol;\n    \n    vector<int> nums1 = {4, 3, 5, 8, 3, 12, 4};\n    vector<vector<int>> res1 = sol.distributeRepeats(nums1);\n    for (auto& v : res1) {\n        for (int i : v) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    nums1 = {3, 3, 2};\n    vector<vector<int>> res2 = sol.distributeRepeats(nums1);\n    for (auto& v : res2) {\n        for (int i : v) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    nums1 = {5, 4, 3};\n    vector<vector<int>> res3 = sol.distributeRepeats(nums1);\n    for (auto& v : res3) {\n        for (int i : v) {\n            cout << i << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1654": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minJumps(vector<vector<int>>& grid) {\n        int m = grid.size();\n        if (m == 0) return 0;\n        int n = grid[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n));\n        \n        queue<pair<int, int>> q;\n        q.push({0, 0});\n        visited[0][0] = true;\n        int step = 0;\n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                pair<int, int> p = q.front(); q.pop();\n                if (p.first == m - 1 && p.second == n - 1) return step;\n                \n                vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n                for (auto dir : dirs) {\n                    int x = p.first + dir.first;\n                    int y = p.second + dir.second;\n                    if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y] && grid[x][y] == 0) {\n                        q.push({x, y});\n                        visited[x][y] = true;\n                    }\n                }\n            }\n            step++;\n        }\n        \n        return -1; // not reachable\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1:\n    vector<vector<int>> grid1{{0,1,2,3},{4,5,6,7}};\n    cout << \"Test case 1: \" << solution.minJumps(grid1) << endl; // Output: 4\n\n    // Test case 2:\n    vector<vector<int>> grid2{{0,1},{2,3}};\n    cout << \"Test case 2: \" << solution.minJumps(grid2) << endl; // Output: -1 (not reachable)\n\n    // Test case 3:\n    vector<vector<int>> grid3{{0,1,2},{0,1,0}};\n    cout << \"Test case 3: \" << solution.minJumps(grid3) << endl; // Output: 4\n\n    return 0;\n}\n```",
  "1657": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool closeStrings(string word1, string word2) {\n        vector<int> count1(26), count2(26);\n        \n        for (char c : word1) {\n            ++count1[tolower(c) - 'a'];\n        }\n        \n        for (char c : word2) {\n            ++count2[tolower(c) - 'a'];\n        }\n        \n        return equal(count1.begin(), count1.end(), count2.begin());\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << boolalpha << solution.closeStrings(\"abc\", \"bca\") << endl;  // Expected: true\n    cout << boolalpha << solution.closeStrings(\"abc\", \"def\") << endl;  // Expected: false\n    cout << boolalpha << solution.closeStrings(\"xxyyzz\", \"xxyyz\") << endl;  // Expected: false\n    \n    return 0;\n}\n```",
  "1656": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nclass OrderedStream {\npublic:\n    int slowStart() {\n        return -1;\n    }\n\n    void insert(int idKey, string value) {\n        if (idKey > nums.size()) {\n            while (idKey > nums.size())\n                nums.push_back(0);\n        }\n        nums[idKey - 1] = value + \"\";\n    }\n\n    string get(int idKey) {\n        return (idKey <= nums.size() && nums[idKey - 1].find(' ') == std::string::npos)\n               ? nums[idKey - 1]\n               : \"-1\";\n    }\n\nprivate:\n    vector<string> nums;\n};\n\nint main() {\n    OrderedStream os;\n\n    cout << os.get(5) << endl; // Return \"AAAA\".id = 5\n    cout << os.get(1) << endl; // Return \"-1\"\n    cout << os.get(10) << endl; // Return \"iiiiihhhhhh\"\n\n    return 0;\n}\n```",
  "1658": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minOperations(int n) {\n        if (n == 0) return 0;\n        int res = 0, x = 1;\n        while (x <= n) {\n            res += (n + x - 1) / x;\n            x++;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test Case 1: For input 5, output is \" << solution.minOperations(5) << endl; // Expected Output: 5\n    cout << \"Test Case 2: For input 10, output is \" << solution.minOperations(10) << endl; // Expected Output: 12\n    cout << \"Test Case 3: For input 20, output is \" << solution.minOperations(20) << endl; // Expected Output: 30\n    return 0;\n}\n```",
  "1659": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint gridHappiness(vector<vector<int>>& grid) {\n    int n = grid.size();\n    vector<vector<int>> dp(n, vector<int>(1 << n));\n    for (int i = 0; i < n; i++) {\n        for (int mask = 0; mask < (1 << n); mask++) {\n            if ((mask & (1 << i)) && (i > 0)) {\n                dp[i][mask] += grid[0][i - 1];\n            }\n            if ((mask >> i) & 1) {\n                dp[i][mask] += grid[i][0];\n            }\n        }\n    }\n\n    int maxHappiness = 0;\n    for (int mask = 0; mask < (1 << n); mask++) {\n        int happiness = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (((mask >> i) & 1) && ((mask >> (i + 1)) & 1)) {\n                happiness += grid[i][i + 1];\n            }\n        }\n        maxHappiness = max(maxHappiness, happiness);\n    }\n\n    return maxHappiness;\n}\n\nint main() {\n    vector<vector<int>> grid1 = {{5}, {10}};\n    cout << \"Grid 1: \" << gridHappiness(grid1) << endl;\n\n    vector<vector<int>> grid2 = {{3, -1}, {-1, 0}};\n    cout << \"Grid 2: \" << gridHappiness(grid2) << endl;\n\n    vector<vector<int>> grid3 = {{5, 2, 6}, {7, 4, 10}, {9, 8, 1}};\n    cout << \"Grid 3: \" << gridHappiness(grid3) << endl;\n    \n    return 0;\n}\n```",
  "1661": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\ndouble averageTime(std::vector<std::vector<int>>& processes) {\n    int total = 0;\n    for (const auto& process : processes) {\n        total += process[1];\n    }\n    return static_cast<double>(total) / processes.size();\n}\n\nint main() {\n    std::vector<std::vector<int>> processes1 = {{10, 20}, {30, 40}};\n    double result1 = averageTime(processes1);\n    std::cout << \"Average time for process 1: \" << result1 << std::endl;\n\n    std::vector<std::vector<int>> processes2 = {{100, 200}, {300, 400}, {500, 600}};\n    double result2 = averageTime(processes2);\n    std::cout << \"Average time for process 2: \" << result2 << std::endl;\n\n    std::vector<std::vector<int>> processes3 = {{10, 20}, {30, 40}, {50, 60}, {70, 80}};\n    double result3 = averageTime(processes3);\n    std::cout << \"Average time for process 3: \" << result3 << std::endl;\n\n    return 0;\n}",
  "1660": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    void correctBST(TreeNode* root, long sum = 0, long expectedSum = 0) {\n        if (root == NULL)\n            return;\n\n        expectedSum += root->val;\n\n        if (root->left != NULL && root->left->val > root->val)\n            return;\n        if (root->right != NULL && root->right->val <= root->val)\n            return;\n\n        correctBST(root->left, sum + root->val, expectedSum);\n        correctBST(root->right, sum - root->val, expectedSum);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1:\n    TreeNode* t1 = new TreeNode(5);\n    t1->left = new TreeNode(2);\n    t1->right = new TreeNode(8);\n    t1->left->left = new TreeNode(1);\n    t1->left->right = new TreeNode(3);\n    solution.correctBST(t1);\n\n    // Test Case 2:\n    TreeNode* t2 = new TreeNode(5);\n    t2->left = new TreeNode(2);\n    t2->right = new TreeNode(8);\n    t2->left->left = new TreeNode(1);\n    t2->left->right = new TreeNode(3);\n    t2->right->right = new TreeNode(9);\n    solution.correctBST(t2);\n\n    // Test Case 3:\n    TreeNode* t3 = new TreeNode(5);\n    t3->left = new TreeNode(2);\n    t3->right = new TreeNode(8);\n    t3->left->left = new TreeNode(1);\n    t3->left->right = new TreeNode(4);\n    solution.correctBST(t3);\n\n    return 0;\n}\n```",
  "1663": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nint getSmallestString(int n, int k) {\n    std::string res = \"\";\n    for (int i = 1; i <= n; ++i) {\n        if (k >= i) {\n            res += 'a';\n            k -= i;\n        } else {\n            res += 'z' - (k + 1);\n            break;\n        }\n    }\n    while (k > 0 && res.size() < n) {\n        res.push_back('a');\n        --k;\n    }\n    for (; k > 25; ) {\n        res.push_back('z');\n        k -= 26;\n    }\n    res.resize(n, 'a');\n    return (res + std::string(k, 'a')).size();\n}\n\nint main() {\n    int n1 = 3, k1 = 27;\n    int n2 = 5, k2 = 6;\n    int n3 = 23, k3 = 46;\n\n    std::cout << getSmallestString(n1, k1) << std::endl; // Output: 6\n    std::cout << getSmallestString(n2, k2) << std::endl; // Output: 5\n    std::cout << getSmallestString(n3, k3) << std::endl; // Output: 14\n\n    return 0;\n}\n```",
  "1662": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool arrayStringsAreEqual(std::vector<std::string>& word1, std::vector<std::string>& word2) {\n    for(int i = 0; i < word1.size(); i++) {\n        if(word1[i].size() + (i > 0 ? word1[i-1].size() : 0) != word2[i].size()) {\n            return false;\n        }\n        if(word1[i] != word2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<std::string> word1 = {\"a\", \"c\"};\n    std::vector<std::string> word2 = {\"a\", \"c\"};\n    std::cout << (arrayStringsAreEqual(word1, word2) ? \"True\" : \"False\") << std::endl;\n\n    word1 = {};\n    word2 = {\"ab\"};\n    std::cout << (arrayStringsAreEqual(word1, word2) ? \"True\" : \"False\") << std::endl;\n\n    word1 = {\"a\", \"cb\"};\n    word2 = {\"ab\", \"c\"};\n    std::cout << (arrayStringsAreEqual(word1, word2) ? \"True\" : \"False\") << std::endl;\n    \n    return 0;\n}\n```",
  "1664": "```\n#include <iostream>\n#include <vector>\n\nint numFairArrays(int n) {\n    int sum = (n * (n + 1)) / 2;\n    long long oddSum = 0, evenSum = 0;\n    for (int i = 1; i <= n; ++i) {\n        if ((sum - i) % 2 == 0) {\n            evenSum += i;\n        } else {\n            oddSum += i;\n        }\n    }\n    return (evenSum > oddSum) ? (n - evenSum + oddSum) : (n - oddSum + evenSum);\n}\n\nint main() {\n    int n1 = 4;\n    int result1 = numFairArrays(n1);\n    std::cout << \"Ways to make a fair array for \" << n1 << \": \" << result1 << std::endl;\n\n    int n2 = 7;\n    int result2 = numFairArrays(n2);\n    std::cout << \"Ways to make a fair array for \" << n2 << \": \" << result2 << std::endl;\n\n    int n3 = 10;\n    int result3 = numFairArrays(n3);\n    std::cout << \"Ways to make a fair array for \" << n3 << \": \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1665": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint minInitialEnergy(int n, std::vector<int>& tasks) {\n    int res = 0;\n    for (int i = 0; i < n - 1; i++) {\n        res += std::max(tasks[i], tasks[i + 1]);\n    }\n    return res;\n}\n\nint main() {\n    // Test case 1\n    int n1 = 2;\n    std::vector<int> tasks1 = {1, 3};\n    if (minInitialEnergy(n1, tasks1) == 4) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed.\" << std::endl;\n    }\n\n    // Test case 2\n    int n2 = 3;\n    std::vector<int> tasks2 = {5, 9, 4};\n    if (minInitialEnergy(n2, tasks2) == 10) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed.\" << std::endl;\n    }\n\n    // Test case 3\n    int n3 = 1;\n    std::vector<int> tasks3 = {1};\n    if (minInitialEnergy(n3, tasks3) == 1) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1666": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* subtreeWithAllOccurrencesOfX(TreeNode* root, int X) {\n        if (!root) return NULL;\n        if (root->val == X) return new TreeNode(0);\n        root->left = subtreeWithAllOccurrencesOfX(root->left, X);\n        root->right = subtreeWithAllOccurrencesOfX(root->right, X);\n        return root;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(4);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(7);\n    root1->left->left = new TreeNode(1);\n    root1->left->right = new TreeNode(3);\n    solution.subtreeWithAllOccurrencesOfX(root1, 2);\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(7);\n    solution.subtreeWithAllOccurrencesOfX(root2, 3);\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    solution.subtreeWithAllOccurrencesOfX(root3, 0);\n\n    return 0;\n}\n```",
  "1667": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> fixNames(vector<vector<string>>& names) {\n        vector<string> result;\n        for (auto& row : names) {\n            string name = \"\";\n            bool prevUpper = false;\n            for (auto& c : row[0]) {\n                if (isupper(c)) {\n                    if (!prevUpper) {\n                        name += \"_\";\n                        prevUpper = true;\n                    }\n                } else {\n                    prevUpper = false;\n                }\n                name += tolower(c);\n            }\n            result.push_back(name);\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<string>> names1 = {{\"Thomas\",\"Tommy\"}, {\"Jane\",\"Jana\"}};\n    cout << \"Test case 1: \";\n    for (auto& name : solution.fixNames(names1)) {\n        cout << name << \" \";\n    }\n    cout << endl;\n    \n    vector<vector<string>> names2 = {{\"Micheal\",\"Mike\", \"mike\"}, {\"Alexandra\",\"Alex\", \"aLex\"}};\n    cout << \"Test case 2: \";\n    for (auto& name : solution.fixNames(names2)) {\n        cout << name << \" \";\n    }\n    cout << endl;\n\n    vector<vector<string>> names3 = {{\"John\",\"JohN\"}, {\"Emma\",\"eMmA\", \"emMa\"}};\n    cout << \"Test case 3: \";\n    for (auto& name : solution.fixNames(names3)) {\n        cout << name << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1668": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint maxRepeatingSubstring(std::string s) {\n    int n = s.size();\n    std::vector<int> dp(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= i; j++) {\n            if (s.substr(j - 1, i - j + 1) == s.substr(0, i - j + 1)) {\n                dp[i] = std::max(dp[i], dp[j - 1] + 1);\n            }\n        }\n    }\n    return dp[n];\n}\n\nint main() {\n    // Test case 1\n    std::string s1 = \"ababc\";\n    int result1 = maxRepeatingSubstring(s1);\n    std::cout << \"Test case 1: Expected 2, got \" << result1 << std::endl;\n\n    // Test case 2\n    std::string s2 = \"abcdabcd\";\n    int result2 = maxRepeatingSubstring(s2);\n    std::cout << \"Test case 2: Expected 4, got \" << result2 << std::endl;\n\n    // Test case 3\n    std::string s3 = \"aaabbbccc\";\n    int result3 = maxRepeatingSubstring(s3);\n    std::cout << \"Test case 3: Expected 3, got \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1669": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* mergeInBetween(ListNode* l1, ListNode* l2, int r) {\n        // Your code here\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    ListNode* node1 = new ListNode(0);\n    ListNode* node2 = new ListNode(3);\n    ListNode* node3 = new ListNode(5);\n\n    node1->next = node2;\n    node2->next = node3;\n\n    ListNode* l1 = node1;\n    ListNode* l2 = new ListNode(1);\n    ListNode* l3 = new ListNode(2);\n    l2->next = l3;\n    int r = 3;\n    \n    solution.mergeInBetween(l1, l2, r);\n\n    // Test case 2\n    node1 = new ListNode(0);\n    node2 = new ListNode(5);\n    node3 = new ListNode(7);\n\n    node1->next = node2;\n    node2->next = node3;\n\n    l1 = node1;\n    l2 = new ListNode(1);\n    l3 = new ListNode(4);\n    l2->next = l3;\n    r = 5;\n    \n    solution.mergeInBetween(l1, l2, r);\n\n    // Test case 3\n    node1 = new ListNode(0);\n    node2 = new ListNode(10);\n    node3 = new ListNode(20);\n\n    node1->next = node2;\n    node2->next = node3;\n\n    l1 = node1;\n    l2 = new ListNode(5);\n    l3 = new ListNode(15);\n    l2->next = l3;\n    r = 10;\n    \n    solution.mergeInBetween(l1, l2, r);\n\n    return 0;\n}\n```",
  "1671": "```\n#include <iostream>\n#include <vector>\n\nint minDeletions(std::vector<int>& arr) {\n    int n = arr.size();\n    std::vector<int> left(n), right(n);\n    \n    int top = 0;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] > arr[top]) {\n            left[i] = top++;\n        } else {\n            left[i] = left[i - 1];\n        }\n    }\n    \n    top = 0;\n    for (int i = n - 2; i >= 0; --i) {\n        if (arr[i] > arr[top]) {\n            right[i] = top++;\n        } else {\n            right[i] = right[i + 1];\n        }\n    }\n    \n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        res += std::min(left[i], right[i]);\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> arr1({2,3,5});\n    std::cout << \"Test case 1: \" << minDeletions(arr1) << std::endl;\n\n    std::vector<int> arr2({3,5,4,2});\n    std::cout << \"Test case 2: \" << minDeletions(arr2) << std::endl;\n\n    std::vector<int> arr3({1,2,3,5,6,7});\n    std::cout << \"Test case 3: \" << minDeletions(arr3) << std::endl;\n    \n    return 0;\n}\n```",
  "1670": "```\n#include <iostream>\n#include <string>\n#include \"MyQueue.h\"\n\nint main() {\n    MyQueue myQueue = MyQueue();\n\n    // Test Case 1: Push and Pop\n    std::cout << \"Test Case 1: \";\n    myQueue.push(1);\n    myQueue.push(2);\n    if (myQueue.pop() != 1) {\n        std::cout << \"Failed\" << std::endl;\n    } else {\n        std::cout << \"Passed\" << std::endl;\n    }\n\n    // Test Case 2: Push and Peek\n    std::cout << \"Test Case 2: \";\n    myQueue.push(3);\n    myQueue.push(4);\n    if (myQueue.peekFront() != 3) {\n        std::cout << \"Failed\" << std::endl;\n    } else if (myQueue.peekBack() != 4) {\n        std::cout << \"Failed\" << std::endl;\n    } else {\n        std::cout << \"Passed\" << std::endl;\n    }\n\n    // Test Case 3: Push, Peek Front, and Pop\n    std::cout << \"Test Case 3: \";\n    myQueue.push(5);\n    if (myQueue.peekFront() != 5) {\n        std::cout << \"Failed\" << std::endl;\n    } else {\n        myQueue.pop();\n        if (myQueue.peekFront() != 4) {\n            std::cout << \"Failed\" << std::endl;\n        } else {\n            std::cout << \"Passed\" << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "1672": "```\n#include <iostream>\n#include <vector>\n\nint maximumWealth(std::vector<std::vector<int>>& accounts) {\n    int maxWealth = 0;\n    for (const auto& account : accounts) {\n        int wealth = 0;\n        for (int amount : account) {\n            wealth += amount;\n        }\n        if (wealth > maxWealth) {\n            maxWealth = wealth;\n        }\n    }\n    return maxWealth;\n}\n\nint main() {\n    std::vector<std::vector<int>> accounts1 = {{1, 2, 3}, {3, 2, 1}};\n    std::cout << \"Test case 1: \" << maximumWealth(accounts1) << std::endl;\n\n    std::vector<std::vector<int>> accounts2 = {{1, 5}, {7, 3}, {3, 2}, {9, 8}, {5, 4}};\n    std::cout << \"Test case 2: \" << maximumWealth(accounts2) << std::endl;\n\n    std::vector<std::vector<int>> accounts3 = {{1, 1}, {0, 2}, {3, 2}, {1, 6}};\n    std::cout << \"Test case 3: \" << maximumWealth(accounts3) << std::endl;\n    \n    return 0;\n}\n```",
  "1673": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> mostCompetitive(vector<int>& nums) {\n        stack<int> st;\n        for (int num : nums) {\n            while (!st.empty() && st.top() > num) {\n                st.pop();\n            }\n            st.push(num);\n        }\n        vector<int> res;\n        while (!st.empty()) {\n            res.push_back(st.top());\n            st.pop();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n\n    // Test case 1\n    vector<int> nums1 = {4,2,3,1};\n    vector<int> expected1 = {1,2,3,4};\n    if (solution.mostCompetitive(nums1) != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n    } else {\n        cout << \"Test case 1 passed.\" << endl;\n    }\n\n    // Test case 2\n    vector<int> nums2 = {9,8,7,6};\n    vector<int> expected2 = {6,7,8,9};\n    if (solution.mostCompetitive(nums2) != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n    } else {\n        cout << \"Test case 2 passed.\" << endl;\n    }\n\n    // Test case 3\n    vector<int> nums3 = {5,4,3,2};\n    vector<int> expected3 = {};\n    if (solution.mostCompetitive(nums3) != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n    } else {\n        cout << \"Test case 3 passed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1674": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMoves(int target[], int n) {\n        vector<int> prefixSum(n + 1, 0);\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + target[i];\n        }\n        \n        int totalMoves = 0;\n        for (int i = 0; i < n; i++) {\n            if (target[i] == 1) {\n                totalMoves += n - i - 1 - (prefixSum[n] - (prefixSum[i] + 1));\n            } else {\n                totalMoves += i;\n            }\n        }\n        \n        return totalMoves;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    int target1[] = {0, 1};\n    cout << \"Test case 1: \" << solution.minMoves(target1, sizeof(target1) / sizeof(target1[0])) << endl;\n\n    int target2[] = {0, 0, 1, 1};\n    cout << \"Test case 2: \" << solution.minMoves(target2, sizeof(target2) / sizeof(target2[0])) << endl;\n\n    int target3[] = {1, 1, 1, 0};\n    cout << \"Test case 3: \" << solution.minMoves(target3, sizeof(target3) / sizeof(target3[0])) << endl;\n    \n    return 0;\n}\n```",
  "1675": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumDeviation(vector<int>& arr) {\n        priority_queue<int> pq;\n        for (int x : arr) {\n            pq.push(x);\n        }\n        \n        int res = INT_MAX, minVal = pq.top();\n        while (minVal < pq.top()) {\n            minVal = pq.top();\n            pq.pop();\n            pq.push(minVal * 2);\n        }\n        \n        res = min(res, minVal);\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Test case 1\n    vector<int> arr1 = {4, 1, 5, 20, 10};\n    cout << \"Minimize deviation for array [\" << endl;\n    for (int x : arr1) {\n        cout << x << \", \";\n    }\n    cout << \"] is: \" << sol.minimumDeviation(arr1) << endl;\n\n    // Test case 2\n    vector<int> arr2 = {2, 3, 1, 5};\n    cout << \"Minimize deviation for array [\" << endl;\n    for (int x : arr2) {\n        cout << x << \", \";\n    }\n    cout << \"] is: \" << sol.minimumDeviation(arr2) << endl;\n\n    // Test case 3\n    vector<int> arr3 = {1, 2};\n    cout << \"Minimize deviation for array [\" << endl;\n    for (int x : arr3) {\n        cout << x << \", \";\n    }\n    cout << \"] is: \" << sol.minimumDeviation(arr3) << endl;\n\n    return 0;\n}\n```",
  "1677": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double highFive(int[][] grades) {\n        int n = grades.size();\n        vector<int> total;\n        \n        for (int i = 0; i < n; ++i) {\n            int sum = 0;\n            for (int j = 0; j < 5; ++j) {\n                sum += grades[i][j];\n            }\n            if (sum > 0) {\n                total.push_back(sum / 5);\n            } else {\n                total.push_back(0.0);\n            }\n        }\n        \n        double average = 0.0;\n        for (int i = 0; i < n; ++i) {\n            average += total[i];\n        }\n        return average / n;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int[][] grades1 = {{1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};\n    cout << \"Test case 1: \" << solution.highFive(grades1) << endl;\n    \n    // Test case 2\n    int[][] grades2 = {{1, 1, 1, 1, 1}, {2, 2, 2, 2, 2}};\n    cout << \"Test case 2: \" << solution.highFive(grades2) << endl;\n    \n    // Test case 3\n    int[][] grades3 = {{1, 5}, {2, 4}, {3, 3}, {4, 2}, {5, 1}};\n    cout << \"Test case 3: \" << solution.highFive(grades3) << endl;\n\n    return 0;\n}\n```",
  "1676": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* getLCA(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (root == NULL || root == p || root == q)\n            return root;\n\n        TreeNode* left = getLCA(root->left, p, q);\n        TreeNode* right = getLCA(root->right, p, q);\n\n        if (left && right)\n            return root;\n        else\n            return left ? left : right;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    TreeNode *root1 = new TreeNode(3);\n    root1->left = new TreeNode(5);\n    root1->right = new TreeNode(1);\n    root1->left->left = new TreeNode(6);\n    root1->left->right = new TreeNode(2);\n    root1->right->left = new TreeNode(0);\n    root1->right->right = new TreeNode(8);\n    root1->left->left->left = new TreeNode(7);\n    root1->left->left->right = new TreeNode(4);\n\n    TreeNode *p1 = root1->left->left;\n    TreeNode *q1 = root1->left->right;\n\n    TreeNode* result1 = solution.getLCA(root1, p1, q1);\n    cout << \"Test case 1: LCA of (\" << p1->val << \", \" << q1->val << \") is \" << result1->val << endl;\n\n    // Test case 2:\n    root1 = new TreeNode(4);\n    root1->left = new TreeNode(7);\n    root1->right = new TreeNode(3);\n    root1->left->left = new TreeNode(2);\n    root1->left->right = new TreeNode(6);\n    root1->right->left = new TreeNode(5);\n    root1->right->right = new TreeNode(8);\n\n    p1 = root1->left;\n    q1 = root1->right;\n\n    TreeNode* result2 = solution.getLCA(root1, p1, q1);\n    cout << \"Test case 2: LCA of (\" << p1->val << \", \" << q1->val << \") is \" << result2->val << endl;\n\n    // Test case 3:\n    root1 = new TreeNode(5);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(4);\n\n    p1 = root1;\n    q1 = root1->right;\n\n    TreeNode* result3 = solution.getLCA(root1, p1, q1);\n    cout << \"Test case 3: LCA of (\" << p1->val << \", \" << q1->val << \") is \" << result3->val << endl;\n}\n```",
  "1678": "```\n#include <iostream>\n#include <string>\n\nstd::string interpret(std::string command) {\n    std::string result = \"\";\n    for (int i = 0; i < command.size(); i++) {\n        if (command[i] == 'G') {\n            if (i + 1 >= command.size() || command[i+1] != 'o') continue;\n            i++;\n            if (i + 1 >= command.size() || command[i+1] != 'a') continue;\n            i++;\n            result += \"G\";\n        } else if (command[i] == '![j]') {\n            if (i + 5 > command.size()) break;\n            char c = command[i+4];\n            switch(c) {\n                case 'o':\n                    result += \"o\";\n                    break;\n                case 'a':\n                    result += \"a\";\n                    break;\n            }\n        } else {\n            result += command[i];\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << interpret(\"G\") << std::endl; // Output: G\n    std::cout << interpret(\"G!o\") << std::endl; // Output: Go\n    std::cout << interpret(\"G!a\")) << std::endl; // Output: Ga\n    \n    return 0;\n}\n```",
  "1679": "```\n#include <iostream>\n#include <vector>\n\nint maxKSumPairs(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end());\n    int left = 0;\n    int right = nums.size() - k;\n    int res = 0;\n    \n    for (int i = 0; i <= right; i++) {\n        while (i + k <= right && nums[i] + nums[i+k] > nums[right]) {\n            right--;\n        }\n        res += right - i + 1;\n    }\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {1,2,3,4,5};\n    int k1 = 2;\n    std::cout << \"Test case 1: \" << maxKSumPairs(nums1, k1) << std::endl;\n\n    std::vector<int> nums2 = {-1,-1,-1,-1,-4};\n    int k2 = 3;\n    std::cout << \"Test case 2: \" << maxKSumPairs(nums2, k2) << std::endl;\n\n    std::vector<int> nums3 = {1,2,3};\n    int k3 = 5;\n    std::cout << \"Test case 3: \" << maxKSumPairs(nums3, k3) << std::endl;\n    \n    return 0;\n}\n```",
  "1680": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    string concatBits(int n) {\n        string res = \"\";\n        for (int i = 0; i <= n; ++i) {\n            res += bitSet(i);\n        }\n        return res;\n    }\n\n    string bitSet(int n) {\n        string s = \"\";\n        while (n > 0) {\n            s = (n & 1) ? \"1\" + s : \"0\" + s;\n            n >>= 1;\n        }\n        return s;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << solution.concatBits(3) << endl; // Output: \"11001100110100\"\n    cout << solution.concatBits(9) << endl; // Output: \"10011000110011100110\"\n    cout << solution.concatBits(5) << endl; // Output: \"111010110\"\n\n    return 0;\n}\n```",
  "1681": "```\n#include <iostream>\n#include <vector>\n\nint findMinIncompatibility(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(1 << 18));\n    \n    for (int i = 0; i < n; i++) {\n        int curr = nums[i];\n        for (int mask = 1; mask < (1 << 18); mask <<= 1) {\n            if (((mask >> (curr & 31)) & 1) == 0) {\n                dp[i][mask] = std::max(dp[i][mask], dp[(i - 1 + n) % n][mask ^ ((1 << curr) | (1 << (curr - 1)))] + abs(curr - nums[(i - 1 + n) % n]));\n            }\n        }\n    }\n    \n    int res = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        res = std::min(res, dp[i][(1 << 18) - 1]);\n    }\n    \n    return res;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> nums1 = {2, 5, 3};\n    int result1 = findMinIncompatibility(nums1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {2, 4, 6, 8};\n    int result2 = findMinIncompatibility(nums2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {1, 3, 5, 7};\n    int result3 = findMinIncompatibility(nums3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1682": "```\n#include <iostream>\n#include <vector>\n\nint longestPalindromicSubsequenceII(std::string s) {\n    int n = s.length();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <= i; j++) {\n            if (i == j) {\n                dp[i][j] = 1;\n            } else if (s[i] == s[j]) {\n                dp[i][j] = dp[i - 1][j - 1] + 2;\n            } else {\n                dp[i][j] = std::max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[n - 1][n - 1];\n}\n\nint main() {\n    std::cout << longestPalindromicSubsequenceII(\"babad\") << std::endl;\n    std::cout << longestPalindromicSubsequenceII(\"cbbd\") << std::endl;\n    std::cout << longestPalindromicSubsequenceII(\"a\") << std::endl;\n    return 0;\n}\n```",
  "1683": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int numInvalidEmails(std::vector<std::string> emails) {\n        int count = 0;\n        for (const auto& email : emails) {\n            if (!email.empty() && !email.back() == '>') {\n                count++;\n            }\n        }\n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::string> test1 = {\"test@email.com\", \"test2<@gmail.com\"};\n    int result1 = solution.numInvalidEmails(test1);\n    if (result1 == 1) {\n        std::cout << \"Test case 1: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Failed\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::string> test2 = {\"test3@google.com\", \"test4<@gmail.co\"};\n    int result2 = solution.numInvalidEmails(test2);\n    if (result2 == 1) {\n        std::cout << \"Test case 2: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Failed\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::string> test3 = {\"test5@gmail.com\", \"test6<@gmail.com\"};\n    int result3 = solution.numInvalidEmails(test3);\n    if (result3 == 0) {\n        std::cout << \"Test case 3: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Failed\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1684": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nint countConsistentStrings(std::vector<std::string>& arr, int low, int high) {\n    std::unordered_map<char, bool> consistent;\n\n    for (char c = low; c <= high; c++) {\n        consistent[c] = true;\n    }\n\n    int count = 0;\n    for (const auto& str : arr) {\n        bool isConsistent = true;\n        for (char c : str) {\n            if (!consistent[c]) {\n                isConsistent = false;\n                break;\n            }\n        }\n        if (isConsistent) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    std::vector<std::string> arr1 = {\"abc\", \"bcd\", \"xyz\"};\n    std::cout << \"Test case 1: \" << countConsistentStrings(arr1, 'a', 'd') << std::endl;\n\n    std::vector<std::string> arr2 = {\"aaa\", \"aa\", \"a\"};\n    std::cout << \"Test case 2: \" << countConsistentStrings(arr2, 'a', 'z') << std::endl;\n\n    std::vector<std::string> arr3 = {\"cool\", \"lock\", \"cook\"};\n    std::cout << \"Test case 3: \" << countConsistentStrings(arr3, 'a', 'z') << std::endl;\n\n    return 0;\n}\n```",
  "1685": "```\n#include <iostream>\n#include <vector>\n\nint absoluteSum(int left, int right) {\n    return (right - left);\n}\n\nint sumOfAbsoluteDifferences(std::vector<int>& nums) {\n    long long total = 0;\n    for (int i = 1; i < nums.size(); i++) {\n        total += (long long)absoluteSum(nums[i-1], nums[i]);\n    }\n    return total;\n}\n\nint main() {\n    std::vector<int> test1 = {2, 3, -4};\n    std::cout << \"Test case 1: \" << sumOfAbsoluteDifferences(test1) << std::endl;\n\n    std::vector<int> test2 = {-1, 0, 1, 3, 10};\n    std::cout << \"Test case 2: \" << sumOfAbsoluteDifferences(test2) << std::endl;\n\n    std::vector<int> test3 = {1};\n    std::cout << \"Test case 3: \" << sumOfAbsoluteDifferences(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1686": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int stoneGameVI(vector<int>& Alice, vector<int>& Bob) {\n        // Combine both arrays into one\n        vector<vector<int>> stones;\n        for (int i = 0; i < Alice.size(); i++) {\n            stones.push_back({Alice[i], 1});\n        }\n        for (int i = 0; i < Bob.size(); i++) {\n            stones.push_back({Bob[i], -1});\n        }\n\n        // Sort the array based on the value\n        sort(stones.begin(), stones.end());\n\n        int sumA = 0, sumB = 0;\n        for (int i = 0; i < stones.size(); i++) {\n            if (i % 2 == 0) {\n                sumA += stones[i][0];\n            } else {\n                sumB += stones[i][0];\n            }\n        }\n\n        return max(sumA, sumB);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> Alice1 = {5,3};\n    vector<int> Bob1 = {2,10};\n    cout << \"Test case 1: \" << solution.stoneGameVI(Alice1, Bob1) << endl;\n\n    // Test case 2\n    vector<int> Alice2 = {3,9};\n    vector<int> Bob2 = {6,6};\n    cout << \"Test case 2: \" << solution.stoneGameVI(Alice2, Bob2) << endl;\n\n    // Test case 3\n    vector<int> Alice3 = {1,2,3};\n    vector<int> Bob3 = {10,20,30};\n    cout << \"Test case 3: \" << solution.stoneGameVI(Alice3, Bob3) << endl;\n    \n    return 0;\n}\n```",
  "1687": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint boxShipping(std::vector<int>& boxes) {\n    int n = boxes.size();\n    if (n == 0) return 0;\n\n    std::vector<int> left(n), right(n);\n    for (int i = 0; i < n; i++) {\n        left[i] = (i > 0 ? left[i-1] : 0) + boxes[i];\n        right[n-i-1] = (n - i > 1 ? right[n-i] : 0) + boxes[n-i-1];\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        ans = std::max(ans, left[i] * right[n-i-1]);\n    }\n    return ans;\n}\n\nint main() {\n    {\n        std::vector<int> boxes = {1, 3, 2, 5};\n        int result = boxShipping(boxes);\n        if (result == 30) {\n            std::cout << \"Test case 1 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 1 failed. Expected: 30, Got: \" << result << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> boxes = {5};\n        int result = boxShipping(boxes);\n        if (result == 25) {\n            std::cout << \"Test case 2 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 2 failed. Expected: 25, Got: \" << result << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> boxes = {};\n        int result = boxShipping(boxes);\n        if (result == 0) {\n            std::cout << \"Test case 3 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 3 failed. Expected: 0, Got: \" << result << std::endl;\n        }\n    }\n\n    return 0;\n}\n```",
  "1688": "```\n#include <iostream>\n#include <vector>\n\nint calculateMatches(int n) {\n    return (n * (n - 1)) / 2;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << calculateMatches(10) << std::endl; // expected output: 45\n    std::cout << \"Test Case 2: \" << calculateMatches(5) << std::endl; // expected output: 4\n    std::cout << \"Test Case 3: \" << calculateMatches(20) << std::endl; // expected output: 190\n\n    return 0;\n}\n```",
  "1689": "```\n#include <iostream>\n#include <string>\n\nint minPartitions(std::string nums) {\n    int partitions = 0;\n    for (char c : nums) {\n        if (c == '1') {\n            ++partitions;\n        }\n    }\n    return partitions + 1;\n}\n\nint main() {\n    std::cout << minPartitions(\"032305\") << std::endl;  // Expected output: 2\n    std::cout << minPartitions(\"11001001\") << std::endl;  // Expected output: 4\n    std::cout << minPartitions(\"1111\") << std::endl;  // Expected output: 2\n\n    return 0;\n}\n```",
  "1690": "```\n#include <iostream>\nusing namespace std;\n\nint stoneGameVII(vector<int>& p) {\n    int n = p.size();\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = p[i];\n    }\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i <= n - len; i++) {\n            int j = i + len - 1;\n            dp[i][j] = max(p[i] + min(dp[i+1][j-1], dp[i+2][j]) if i+2<=j else 0, p[j] + min(dp[i][j-2], dp[i][j-1]) if j-2>=i else 0);\n        }\n    }\n\n    return dp[0][n - 1];\n}\n\nint main() {\n    vector<int> p1 = {5};\n    cout << \"Test case 1: \" << stoneGameVII(p1) << endl;\n    vector<int> p2 = {6,4,7};\n    cout << \"Test case 2: \" << stoneGameVII(p2) << endl;\n    vector<int> p3 = {5,8,9,10};\n    cout << \"Test case 3: \" << stoneGameVII(p3) << endl;\n}\n```",
  "1691": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint heightOverall(vector<vector<int>>& cuboids) {\n    int n = cuboids.size();\n    if (n == 0) return 0;\n    \n    vector<int> heights(n, 0);\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j >= 0; --j) {\n            if (cuboids[j][1] >= cuboids[i][1]) break;\n            heights[j] = max(heights[j], heights[i] + cuboids[j][2]);\n        }\n    }\n    \n    return *max_element(heights.begin(), heights.end());\n}\n\nint main() {\n    vector<vector<int>> cuboids1 = {{50, 60, 100}, {40, 50, 150}};\n    cout << heightOverall(cuboids1) << endl; // Output: 250\n\n    vector<vector<int>> cuboids2 = {{10, 12, 20}, {15, 17, 30}, {25, 27, 40]};\n    cout << heightOverall(cuboids2) << endl; // Output: 140\n\n    vector<vector<int>> cuboids3 = {{1, 5, 6}, {3, 4, 7}};\n    cout << heightOverall(cuboids3) << endl; // Output: 12\n    return 0;\n}\n```",
  "1692": "```\n#include <iostream>\n#include <vector>\n\nint countWays(int n, int m) {\n    if (n < m) return 0;\n    std::vector<std::vector<int>> dp(n+1, std::vector<int>(m+1));\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            if (!i && !j) continue;\n            if (!i) {\n                if (!j) dp[i][j] = 1;\n                else dp[i][j] = dp[i][j-1];\n            } else if (!j) {\n                dp[i][j] = dp[i-1][j];\n            } else {\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\n            }\n        }\n    }\n    return dp[n][m];\n}\n\nint main() {\n    int n1 = 3;\n    int m1 = 5;\n    std::cout << \"Test case 1: \" << countWays(n1, m1) << std::endl;\n\n    int n2 = 4;\n    int m2 = 4;\n    std::cout << \"Test case 2: \" << countWays(n2, m2) << std::endl;\n\n    int n3 = 6;\n    int m3 = 5;\n    std::cout << \"Test case 3: \" << countWays(n3, m3) << std::endl;\n\n    return 0;\n}",
  "1693": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int dailyLeadsAndPartners(int leadCount, std::vector<std::string>& partners) {\n        if (leadCount == 0) return 0;\n        int result = 1;\n        for (int i = 0; i < partners.size(); ++i) {\n            result += (partners[i].size() + 1) * leadCount;\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << \"Test Case 1: \" << solution.dailyLeadsAndPartners(2, {\"abc\", \"def\"}) << std::endl; // Expected output: 18\n    std::cout << \"Test Case 2: \" << solution.dailyLeadsAndPartners(1, {\"ghi\", \"jkl\", \"mno\"}) << std::endl; // Expected output: 15\n    std::cout << \"Test Case 3: \" << solution.dailyLeadsAndPartners(0, {}) << std::endl; // Expected output: 0\n\n    return 0;\n}\n```",
  "1694": "```\n#include <iostream>\n#include <string>\n\nstd::string reorderSpaces(std::string s) {\n    int spaceCount = 0;\n    int wordCount = 0;\n\n    for (char c : s) {\n        if (c == ' ') {\n            spaceCount++;\n        } else if (c != ' ') {\n            wordCount++;\n        }\n    }\n\n    std::string result = \"\";\n    bool firstWord = true;\n\n    for (char c : s) {\n        if (c == ' ') {\n            if (!firstWord) {\n                result += \" \";\n            }\n            firstWord = false;\n        } else {\n            result += c;\n        }\n    }\n\n    while (spaceCount > 0 && wordCount < 2) {\n        spaceCount--;\n        result += \" \";\n    }\n\n    return result;\n}\n\nint main() {\n    std::cout << reorderSpaces(\"123 456\") << std::endl; // Output: 123 456\n    std::cout << reorderSpaces(\"00-000-0000\") << std::endl; // Output: 00 000 0000\n    std::cout << reorderSpaces(\"a 1337   b9285 c62\") << std::endl; // Output: a 1337  b9285 c62\n\n    return 0;\n}",
  "1695": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint maximumErasureValue(std::vector<std::string>& words) {\n    int maxVal = 0;\n    for (const auto& word : words) {\n        int val = 0;\n        for (char c : word) {\n            if (isupper(c)) {\n                val++;\n            }\n        }\n        maxVal = std::max(maxVal, val);\n    }\n    return maxVal;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::string> test1 = {\"abc\", \"ABC\", \"abC\"};\n    int result1 = maximumErasureValue(test1);\n    if (result1 == 3) {\n        std::cout << \"Test case 1 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 3, Got: \" << result1 << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::string> test2 = {\"you\", \"are\", \"fine\"};\n    int result2 = maximumErasureValue(test2);\n    if (result2 == 0) {\n        std::cout << \"Test case 2 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 0, Got: \" << result2 << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::string> test3 = {\"Hello\", \"World\", \"HELLO\", \"WORLD\"};\n    int result3 = maximumErasureValue(test3);\n    if (result3 == 4) {\n        std::cout << \"Test case 3 passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 4, Got: \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1696": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxResult(vector<int>& nums) {\n        vector<int> dp(nums.size(), 0);\n        dp[0] = nums[0];\n        \n        for(int i=1; i<nums.size(); i++) {\n            dp[i] = nums[i] + (i > 0 ? max(dp[i-1], nums[i-1]) : 0);\n        }\n        \n        return dp.back();\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<int> test1 = {4,2,7,6,3};\n    cout << \"Test case 1: \" << solution.maxResult(test1) << endl; // Expected output: 12\n    \n    vector<int> test2 = {1,-1,-2,4,-7,5,-15};\n    cout << \"Test case 2: \" << solution.maxResult(test2) << endl; // Expected output: 5\n    \n    vector<int> test3 = {-5};\n    cout << \"Test case 3: \" << solution.maxResult(test3) << endl; // Expected output: -5\n    \n    return 0;\n}\n```",
  "1698": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass TrieNode {\npublic:\n    std::vector<TrieNode*> children;\n    bool isEndOfWord;\n\n    TrieNode() : isEndOfWord(false) {}\n};\n\nclass Trie {\npublic:\n    TrieNode* root;\n\n    Trie() : root(new TrieNode()) {}\n\n    void insert(const std::string& word) {\n        TrieNode* current = root;\n        for (char c : word) {\n            bool found = false;\n            for (TrieNode*& child : current->children) {\n                if (child != nullptr && child->isEndOfWord == (c == '1')) {\n                    current = child;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                TrieNode* newNode = new TrieNode();\n                current->children.push_back(newNode);\n                current = newNode;\n            }\n        }\n    }\n\n    int countDistinctSubstrings(const std::string& s) {\n        root = new TrieNode();\n        for (int i = 0; i < s.size(); ++i) {\n            insert(s.substr(i));\n        }\n        int count = 0;\n        for (int i = 0; i < s.size(); ++i) {\n            for (int j = i; j <= s.size(); ++j) {\n                if (!root->children[j - i].isEndOfWord) {\n                    break;\n                }\n                count++;\n            }\n        }\n        return count;\n    }\n};\n\nint main() {\n    Trie trie;\n    std::cout << trie.countDistinctSubstrings(\"abc\") << std::endl;  // Output: 3\n    std::cout << trie.countDistinctSubstrings(\"aaa\") << std::endl;  // Output: 2\n    std::cout << trie.countDistinctSubstrings(\"aabaa\") << std::endl;  // Output: 4\n\n    return 0;\n}\n```",
  "1697": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPathExist(vector<vector<int>>& grid) {\n        int m = grid.size();\n        if (m == 0) return false;\n        int n = grid[0].size();\n        vector<bool> visited(m, false);\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    dfs(grid, visited, i, j);\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    void dfs(vector<vector<int>>& grid, vector<bool>& visited, int i, int j) {\n        int m = grid.size();\n        int n = grid[0].size();\n\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j]) return;\n\n        visited[i][j] = true;\n        \n        for (int k = -1; k <= 1; ++k) {\n            for (int l = -1; l <= 1; ++l) {\n                int new_i = i + k;\n                int new_j = j + l;\n\n                if (new_i >= 0 && new_i < m && new_j >= 0 && new_j < n && grid[new_i][new_j] == 1) {\n                    dfs(grid, visited, new_i, new_j);\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> test1 = {{0,1},{1,0}};\n    cout << \"Test case 1: \" << (solution.isPathExist(test1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    vector<vector<int>> test2 = {{0,1,0},{0,0,0},{0,1,1}};\n    cout << \"Test case 2: \" << (solution.isPathExist(test2) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    vector<vector<int>> test3 = {{0,1,0},{0,1,1},{1,1,1}};\n    cout << \"Test case 3: \" << (solution.isPathExist(test3) ? \"True\" : \"False\") << endl;\n    \n    return 0;\n}\n```",
  "1700": "```\n#include <iostream>\n#include <vector>\n\nint studentsUnableToEat(int students[], int n) {\n    std::stack<int> lunchStudents;\n    for (int i = 0; i < n; ++i) {\n        if (!lunchStudents.empty() && students[i] == lunchStudents.top()) {\n            lunchStudents.pop();\n        } else {\n            lunchStudents.push(students[i]);\n        }\n    }\n    return lunchStudents.size();\n}\n\nint main() {\n    int testCases[] = {1, 2, 3, 5};\n    int n = sizeof(testCases) / sizeof(testCases[0]);\n\n    std::cout << \"Test Case 1: \" << studentsUnableToEat(testCases, n) << std::endl;\n    n = 7;\n    testCases = new int[n];\n    for (int i = 0; i < n; ++i) {\n        testCases[i] = i % 3 + 1;\n    }\n    std::cout << \"Test Case 2: \" << studentsUnableToEat(testCases, n) << std::endl;\n\n    delete[] testCases;\n    n = 5;\n    testCases = new int[n];\n    for (int i = 0; i < n; ++i) {\n        testCases[i] = i % 3 + 1;\n    }\n    std::cout << \"Test Case 3: \" << studentsUnableToEat(testCases, n) << std::endl;\n\n    delete[] testCases;\n\n    return 0;\n}\n```",
  "1699": "```\n#include <iostream>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\nclass CallLog {\npublic:\n    map<string, vector<pair<string, int>>> log;\n    \n    void processCall(string caller, string callee) {\n        log[caller].push_back({callee, 1});\n        log[callee].push_back({caller, 0});\n    }\n    \n    int numCallsBetween(string caller, string callee) {\n        if (log.find(caller) == log.end() || log.find(callee) == log.end())\n            return 0;\n        \n        vector<pair<string, int>> callerLog = log[caller];\n        vector<pair<string, int>> calleeLog = log[callee];\n        \n        int calls = 0;\n        for (int i = 0; i < callerLog.size(); i++) {\n            if (callerLog[i].first == callee) {\n                for (int j = 0; j < calleeLog.size(); j++) {\n                    if (calleeLog[j].first == caller)\n                        calls++;\n                }\n            }\n        }\n        \n        return calls;\n    }\n};\n\nint main() {\n    CallLog callLog;\n    \n    // Test case 1\n    callLog.processCall(\"A\", \"B\");\n    cout << callLog.numCallsBetween(\"A\", \"B\") << endl;  // Output: 1\n    \n    // Test case 2\n    callLog.processCall(\"C\", \"D\"); \n    callLog.processCall(\"C\", \"E\");\n    callLog.processCall(\"F\", \"G\");\n    \n    cout << callLog.numCallsBetween(\"C\", \"D\") << endl;  // Output: 1\n    cout << callLog.numCallsBetween(\"C\", \"E\") << endl;  // Output: 1\n    cout << callLog.numCallsBetween(\"F\", \"G\") << endl;  // Output: 0\n    \n    return 0;\n}\n```",
  "1702": "```\n#include <iostream>\n#include <string>\n\nint maximumBinaryString(std::string binary) {\n    int maxCount = 0;\n    char prevBit = ' ';\n    for (char bit : binary) {\n        if (bit == '1') {\n            if (prevBit == '0') {\n                maxCount++;\n            }\n        } else {\n            prevBit = '0';\n        }\n    }\n    return maxCount;\n}\n\nint main() {\n    std::cout << maximumBinaryString(\"10000111001111\") << std::endl; // Expected output: 3\n    std::cout << maximumBinaryString(\"111000\") << std::endl; // Expected output: 2\n    std::cout << maximumBinaryString(\"10101010\") << std::endl; // Expected output: 5\n    return 0;\n}",
  "1701": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    double averageWaitingTime(std::vector<int>& tickets) {\n        int totalWait = 0;\n        for (int i = 1; i < tickets.size(); i++) {\n            totalWait += tickets[i] - tickets[i-1];\n        }\n        return (double)totalWait / (tickets.size() - 1);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> tickets1 = {10, 2, 6, 4, 15};\n    double result1 = solution.averageWaitingTime(tickets1);\n    if (std::abs(result1 - 7.33333333333) < 0.000001)\n        std::cout << \"Test case 1: Pass\" << std::endl;\n    else\n        std::cout << \"Test case 1: Fail\" << std::endl;\n\n    // Test case 2\n    std::vector<int> tickets2 = {5, 3, 4};\n    double result2 = solution.averageWaitingTime(tickets2);\n    if (std::abs(result2 - 2.0) < 0.000001)\n        std::cout << \"Test case 2: Pass\" << std::endl;\n    else\n        std::cout << \"Test case 2: Fail\" << std::endl;\n\n    // Test case 3\n    std::vector<int> tickets3 = {1, 2};\n    double result3 = solution.averageWaitingTime(tickets3);\n    if (std::abs(result3 - 1.0) < 0.000001)\n        std::cout << \"Test case 3: Pass\" << std::endl;\n    else\n        std::cout << \"Test case 3: Fail\" << std::endl;\n\n    return 0;\n}\n```",
  "1704": "```\n#include <iostream>\n#include <string>\n\nbool halvesAreAlike(std::string s) {\n    int n = s.length();\n    int mid = n / 2;\n    \n    std::string firstHalf = s.substr(0, mid);\n    std::string secondHalf = s.substr(mid, n - mid);\n    \n    bool firstHalfIsVowel = false;\n    for (char c : firstHalf) {\n        if (\"aeiouAEIOU\".find(c) != std::string::npos) {\n            firstHalfIsVowel = true;\n            break;\n        }\n    }\n    \n    bool secondHalfIsVowel = false;\n    for (char c : secondHalf) {\n        if (\"aeiouAEIOU\".find(c) != std::string::npos) {\n            secondHalfIsVowel = true;\n            break;\n        }\n    }\n    \n    return firstHalfIsVowel && secondHalfIsVowel;\n}\n\nint main() {\n    std::cout << std::boolalpha << halvesAreAlike(\"book\") << std::endl; // false\n    std::cout << std::boolalpha << halvesAreAlike(\"aa\") << std::endl; // true\n    std::cout << std::boolalpha << halvesAreAlike(\"abec\") << std::endl; // false\n\n    return 0;\n}\n```",
  "1703": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minKBitFlips(vector<int>& nums) {\n        int ans = 0, lastflip = -1;\n        for (int i = 0; i < nums.size(); ++i) {\n            if ((i & 1 && nums[i] == 0) || (~i & 1 && nums[i] == 1)) {\n                if (lastflip + 1 != i) {\n                    ans++;\n                    lastflip = i;\n                    for (int j = min(lastflip + 1, int(nums.size() - 1)); j >= 0; --j)\n                        nums[j] ^= 1;\n                }\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution s;\n    vector<int> test1 = {1,1};\n    cout << \"Test Case 1: Expected 2, Actual \" << s.minKBitFlips(test1) << endl;\n\n    vector<int> test2 = {0,1};\n    cout << \"Test Case 2: Expected 3, Actual \" << s.minKBitFlips(test2) << endl;\n\n    vector<int> test3 = {0,1,0};\n    cout << \"Test Case 3: Expected 3, Actual \" << s.minKBitFlips(test3) << endl;\n}\n```",
  "1705": "```\n#include <iostream>\n#include <vector>\n#include <priority_queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int eatenApples(vector<int>& apples, vector<int>& days) {\n        priority_queue<pair<int, int>> pq;\n        for (int i = 0; i < apples.size(); ++i) {\n            pq.push({-apples[i], days[i]});\n        }\n        \n        int res = 0;\n        while (!pq.empty()) {\n            pair<int, int> cur = pq.top();\n            pq.pop();\n            \n            if (cur.second > 1) {\n                --cur.second;\n                pq.push({-cur.first, cur.second});\n            } else if (cur.second == 1) {\n                --cur.second;\n                res += min(cur.first, -cur.first);\n                pq.pop();\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> apples1 = {1,2};\n    vector<int> days1 = {3,2};\n    cout << \"Case 1: \" << solution.eatenApples(apples1, days1) << endl; // Output: 5\n\n    vector<int> apples2 = {5};\n    vector<int> days2 = [1];\n    cout << \"Case 2: \" << solution.eatenApples(apples2, days2) << endl; // Output: 5\n\n    vector<int> apples3 = [3, 0, 0, 2];\n    vector<int> days3 = [3, 0, 1, 2];\n    cout << \"Case 3: \" << solution.eatenApples(apples3, days3) << endl; // Output: 9\n\n    return 0;\n}",
  "1706": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> findBall(std::vector<std::vector<int>>& game) {\n    std::vector<int> result;\n    for (int i = 0; i < game.size(); i++) {\n        int x = i, y = 0;\n        while (y >= 0 && y < game[0].size()) {\n            if (game[x][y] == -1) {\n                if (y == game[0].size() - 1 || game[x][y + 1] == 1) {\n                    result.push_back(1);\n                    break;\n                } else {\n                    x--;\n                    y -= 2;\n                }\n            } else {\n                if (y == game[0].size() - 1 || game[x][y + 1] == -1) {\n                    result.push_back(-1);\n                    break;\n                } else {\n                    x++;\n                    y += 2;\n                }\n            }\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::vector<std::vector<int>> game1 = {{-1,-1,-1,-1,-1},{-1,1,0,1,-1},{-1,0,0,0,-1},{-1,0,0,2,1}};\n    std::cout << \"Test Case 1: \";\n    for (int i : findBall(game1)) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> game2 = {{-1,-1},{1,1}};\n    std::cout << \"Test Case 2: \";\n    for (int i : findBall(game2)) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<std::vector<int>> game3 = {{-1,0,-1},{1,2,1},{-1,0,1}};\n    std::cout << \"Test Case 3: \";\n    for (int i : findBall(game3)) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n    return 0;\n}",
  "1708": "```\n#include <iostream>\n#include <vector>\n\nint maxSubArrayLen(std::vector<int>& nums, int k) {\n    int res = 0;\n    for (int i = 0; i <= nums.size() - k; i++) {\n        int sum = 0;\n        for (int j = i; j < i + k; j++) {\n            sum += nums[j];\n        }\n        if (sum > res) {\n            res = sum;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {4,2,3};\n    std::cout << \"Test 1: \" << maxSubArrayLen(test1, 3) << std::endl;\n\n    std::vector<int> test2 = {1,4,4};\n    std::cout << \"Test 2: \" << maxSubArrayLen(test2, 3) << std::endl;\n\n    std::vector<int> test3 = {5,-3,5,1,3,5,6,7,-3};\n    std::cout << \"Test 3: \" << maxSubArrayLen(test3, 4) << std::endl;\n    \n    return 0;\n}\n```",
  "1707": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass TrieNode {\npublic:\n    int val;\n    TrieNode* left = nullptr;\n    TrieNode* right = nullptr;\n\n    TrieNode(int v) : val(v), left(nullptr), right(nullptr) {}\n};\n\nclass Trie {\npublic:\n    TrieNode* root = nullptr;\n\n    void insert(vector<int>& nums) {\n        root = new TrieNode(0);\n        for (int num : nums) {\n            TrieNode* cur = root;\n            for (int i = 31; i >= 0; --i) {\n                int bit = ((num >> i) & 1);\n                if (!cur->val) {\n                    cur->left = new TrieNode(0);\n                } else {\n                    cur->right = new TrieNode(0);\n                }\n                cur = (bit ? cur->left : cur->right);\n            }\n        }\n    }\n\n    int getMax(vector<int>& nums, int num) {\n        TrieNode* cur = root;\n        int res = 0;\n        for (int i = 31; i >= 0; --i) {\n            int bit = ((num >> i) & 1);\n            if (!cur->val) {\n                res |= (bit << i);\n                cur = cur->left;\n            } else {\n                res |= (1 - bit) << i;\n                cur = cur->right;\n            }\n        }\n        return res;\n    }\n\n};\n\nint findMaximumXOR(vector<int>& nums) {\n    Trie trie;\n    trie.insert(nums);\n    int max_xor = 0;\n    for (int num : nums) {\n        max_xor = max(max_xor, getMax(nums, num));\n    }\n    return max_xor;\n}\n\nint main() {\n    vector<int> nums1 = {14,7,1,0};\n    cout << \"Test Case 1: \" << findMaximumXOR(nums1) << endl;\n\n    vector<int> nums2 = {14,7,11,4};\n    cout << \"Test Case 2: \" << findMaximumXOR(nums2) << endl;\n\n    vector<int> nums3 = {5,6,7,8,9};\n    cout << \"Test Case 3: \" << findMaximumXOR(nums3) << endl;\n\n    return 0;\n}\n\n```",
  "1709": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int largestTimeFromDigits(vector<int>& A) {\n        int maxTime = -1;\n        for (int i = 0; i <= 9; i++) {\n            for (int j = 0; j <= 9; j++) {\n                for (int k = 0; k <= 9; k++) {\n                    for (int l = 0; l <= 9; l++) {\n                        int hours = i * 100 + j * 10 + k;\n                        int minutes = l * 10;\n                        if (hours < 24 && minutes < 60) {\n                            maxTime = max(maxTime, hours * 60 + minutes);\n                        }\n                    }\n                }\n            }\n        }\n        return maxTime;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> A1 = {2,0,0,0};\n    cout << \"Test case 1: \" << solution.largestTimeFromDigits(A1) << endl; \n\n    vector<int> A2 = {1,9,6,9,9,4};\n    cout << \"Test case 2: \" << solution.largestTimeFromDigits(A2) << endl;\n\n    vector<int> A3 = {6,6,6,6};\n    cout << \"Test case 3: \" << solution.largestTimeFromDigits(A3) << endl;\n\n    return 0;\n}\n```",
  "1710": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maximumUnits(std::vector<std::vector<int>>& boxTypes) {\n    std::sort(boxTypes.begin(), boxTypes.end(), [](const auto& a, const auto& b) {\n        return (a[1] > b[1]) || ((a[1] == b[1]) && (a[0] < b[0]));\n    });\n    \n    int totalUnits = 0;\n    for (const auto& boxType : boxTypes) {\n        totalUnits += boxType[0];\n    }\n    \n    return totalUnits;\n}\n\nint main() {\n    std::vector<std::vector<int>> test1 = {{1,3},{2,2},{3,1}};\n    int result1 = maximumUnits(test1);\n    std::cout << \"Test 1: \" << result1 << std::endl;\n\n    std::vector<std::vector<int>> test2 = {{5,10},{2,5},{4,7},{3,9}};\n    int result2 = maximumUnits(test2);\n    std::cout << \"Test 2: \" << result2 << std::endl;\n\n    std::vector<std::vector<int>> test3 = {{1,1},{2,5},{5,10}};\n    int result3 = maximumUnits(test3);\n    std::cout << \"Test 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1712": "```\n#include <iostream>\n#include <vector>\n\nint threeEqualParts(std::vector<int>& nums) {\n    int total = 0;\n    for (int num : nums) {\n        total += num;\n    }\n    \n    if (total % 3 != 0) return 0;\n\n    int target = total / 3;\n    int left = -1, right = nums.size();\n    for (int i = 0; i < nums.size(); ++i) {\n        int sum = 0;\n        for (int j = i; j < nums.size() && sum <= target; ++j) {\n            sum += nums[j];\n            if (sum == target) {\n                left = i;\n                right = j;\n                break;\n            }\n        }\n    }\n\n    return left + 1;\n}\n\nint main() {\n    std::vector<int> test1({3, 3, 6});\n    std::cout << threeEqualParts(test1) << std::endl; // Expected: 1\n\n    std::vector<int> test2({0, 2, 1 - 3, 4});\n    std::cout << threeEqualParts(test2) << std::endl; // Expected: 3\n\n    std::vector<int> test3({1, -1, 1, 1});\n    std::cout << threeEqualParts(test3) << std::endl; // Expected: 2\n    return 0;\n}\n```",
  "1711": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countGood Meals(vector<vector<string>>& recipes) {\n        unordered_map<string, unordered_set<string>> ingToRecipe;\n        for (const auto& recipe : recipes) {\n            for (const string& ingredient : recipe) {\n                ingToRecipe[ingredient].insert(recipe[0]);\n            }\n        }\n\n        int goodMeals = 0;\n        for (const auto& recipe : recipes) {\n            bool isGoodMeal = true;\n            for (const string& ingredient : recipe) {\n                if (ingToRecipe[ingredient].size() > 1) {\n                    isGoodMeal = false;\n                    break;\n                }\n            }\n            goodMeals += isGoodMeal ? 1 : 0;\n        }\n\n        return goodMeals;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> recipes1{{\"chicken\", \"rice\", \"beans\"}, {\"beef\", \"chicken\", \"carrots\"}};\n    cout << \"Test case 1: \" << solution.countGoodMeals(recipes1) << endl; // Expected output: 0\n\n    // Test case 2\n    vector<vector<string>> recipes2{{\"apple\", \"banana\", \"orange\"}, {\"grapes\", \"strawberries\", \"pineapple\"}};\n    cout << \"Test case 2: \" << solution.countGoodMeals(recipes2) << endl; // Expected output: 0\n\n    // Test case 3\n    vector<vector<string>> recipes3{{\"egg\", \"cheese\", \"bread\"}, {\"steak\", \"mashed potatoes\", \"green beans\"}};\n    cout << \"Test case 3: \" << solution.countGoodMeals(recipes3) << endl; // Expected output: 1\n\n    return 0;\n}\n```",
  "1713": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint minOperations(std::vector<int>& target, std::vector<std::vector<int>>& arr) {\n    int res = 0;\n    for (const auto& a : arr) {\n        size_t idx = 0;\n        while (idx < a.size()) {\n            if (std::binary_search(target.begin(), target.end(), a[idx])) {\n                target.erase(std::remove(target.begin(), target.end(), a[idx]), target.end());\n                res++;\n            } else {\n                break;\n            }\n            idx++;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> target = {5};\n    std::vector<std::vector<int>> arr = {{1, 7, 2}, {3, 8, 5}, {4, 20}};\n    \n    std::cout << \"Test Case 1: \" << minOperations(target, arr) << std::endl;\n    \n    target = {10};\n    arr = {{5, 1, 3}, {7, 6, 8}, {9, 8, 5}};\n    \n    std::cout << \"Test Case 2: \" << minOperations(target, arr) << std::endl;\n    \n    target = {13};\n    arr = {{12, 16, 14}, {15, 10, 11}, {12, 13, 17}};\n    \n    std::cout << \"Test Case 3: \" << minOperations(target, arr) << std::endl;\n    \n    return 0;\n}\n```",
  "1714": "```\n#include <iostream>\n#include <vector>\n\nint specialArray(std::vector<int>& nums) {\n    int max = *std::max_element(nums.begin(), nums.end());\n    for (int i = 1; i <= max; i++) {\n        int count = 0;\n        for (int num : nums) {\n            if (num >= i && num % i == 0) {\n                count++;\n            }\n        }\n        if (count == i) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    std::vector<int> test1 = {3, 5};\n    std::cout << \"Test 1: \" << specialArray(test1) << std::endl;\n\n    std::vector<int> test2 = {12};\n    std::cout << \"Test 2: \" << specialArray(test2) << std::endl;\n\n    std::vector<int> test3 = {4, 6, 5, 5, 3, 3};\n    std::cout << \"Test 3: \" << specialArray(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1716": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int maxCoins(std::vector<int>& piles) {\n        int n = piles.size();\n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 1) {\n                total += piles[i];\n            } else {\n                total += piles[i] * 2;\n            }\n        }\n        return total;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::vector<int> piles1 = {2,4,5};\n    std::cout << \"Test Case 1: \" << solution.maxCoins(piles1) << std::endl;\n\n    std::vector<int> piles2 = {1,4,6,8,10};\n    std::cout << \"Test Case 2: \" << solution.maxCoins(piles2) << std::endl;\n\n    std::vector<int> piles3 = {20};\n    std::cout << \"Test Case 3: \" << solution.maxCoins(piles3) << std::endl;\n\n    return 0;\n}\n```",
  "1715": "```\n#include <iostream>\n#include <vector>\n\nint countApplesAndOranges(int s, int m, int appleCount, std::vector<int> appleLocations) {\n    int oranges = 0;\n    for (int i : appleLocations) {\n        if (i >= s && i <= s + m) {\n            appleCount--;\n        }\n    }\n\n    return appleCount;\n}\n\nint main() {\n    // Test case 1\n    int s1 = 7, m1 = 11, c1 = 5;\n    std::vector<int> a1 = {2, 12};\n    int res1 = countApplesAndOranges(s1, m1, c1, a1);\n    if (res1 == 1) {\n        std::cout << \"Test case 1: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Failed. Expected 1, got \" << res1 << std::endl;\n    }\n\n    // Test case 2\n    int s2 = 7, m2 = 5, c2 = 3;\n    std::vector<int> a2 = {4, 8};\n    int res2 = countApplesAndOranges(s2, m2, c2, a2);\n    if (res2 == 0) {\n        std::cout << \"Test case 2: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Failed. Expected 0, got \" << res2 << std::endl;\n    }\n\n    // Test case 3\n    int s3 = 8, m3 = 9, c3 = 10;\n    std::vector<int> a3 = {1, 5};\n    int res3 = countApplesAndOranges(s3, m3, c3, a3);\n    if (res3 == 0) {\n        std::cout << \"Test case 3: Passed\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Failed. Expected 0, got \" << res3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1717": "```\n#include <iostream>\n#include <string>\n\nint maximumScore(std::string s) {\n    int score = 0;\n    int maxLen = 0;\n    for (char c : s) {\n        if (c == '1') {\n            maxLen++;\n        } else if (maxLen > 0) {\n            score += maxLen;\n            maxLen = 0;\n        }\n    }\n    return score + std::max(maxLen, 0);\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << maximumScore(\"011235\") << std::endl; // Expected output: 6\n    std::cout << \"Test case 2: \" << maximumScore(\"000111\") << std::endl; // Expected output: 4\n    std::cout << \"Test case 3: \" << maximumScore(\"1100\") << std::endl; // Expected output: 1\n\n    return 0;\n}",
  "1718": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string largestNumber(vector<int>& nums) {\n        vector<string> strNums;\n        for (int num : nums) {\n            strNums.push_back(to_string(num));\n        }\n        sort(strNums.begin(), strNums.end(), [](string a, string b) {\n            return a + b > b + a;\n        });\n        string result = \"\";\n        for (string s : strNums) {\n            result += s;\n        }\n        while (result.size() > 1 && result[0] == '0') {\n            result.erase(0, 1);\n        }\n        return result.size() == 0 ? \"0\" : result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<int> test1 = {3, 4, 9};\n    cout << solution.largestNumber(test1) << endl; // Output: 3949\n\n    vector<int> test2 = {0, 2, 3, 5);\n    cout << solution.largestNumber(test2) << endl; // Output: 5420\n\n    vector<int> test3 = {2, 3, 4, 5, 6, 7);\n    cout << solution.largestNumber(test3) << endl; // Output: 76354\n\n    return 0;\n}\n```",
  "1719": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numWays(int n) {\n        if (n == 1) return 1;\n        long long res = 0, a = 2, b = 4;\n        for (int i = 3; i <= n; ++i) {\n            res += a;\n            long long t = a + 3 * b;\n            a = b;\n            b = t;\n        }\n        return (int)res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n1 = 2;\n    cout << \"Number of ways for \" << n1 << \": \" << solution.numWays(n1) << endl;\n\n    // Test case 2\n    int n2 = 3;\n    cout << \"Number of ways for \" << n2 << \": \" << solution.numWays(n2) << endl;\n\n    // Test case 3\n    int n3 = 5;\n    cout << \"Number of ways for \" << n3 << \": \" << solution.numWays(n3) << endl;\n\n    return 0;\n}\n```",
  "1720": "```\n#include <iostream>\n#include <vector>\n\nint findFirstUnique(vector<int>& nums) {\n    int res = -1;\n    for (int i = 0; i < 32; i++) {\n        int count = 0, val = 1 << i;\n        for (int j = 0; j < nums.size(); j++) {\n            if ((nums[j] & val) == 0) count++;\n            else count--;\n        }\n        if (count == 0) res |= val;\n    }\n    return res;\n}\n\nint main() {\n    vector<int> test1 = {5, 7, 3, 5};\n    cout << \"Test 1: \" << findFirstUnique(test1) << endl;\n\n    vector<int> test2 = {6, 2, 7, 3};\n    cout << \"Test 2: \" << findFirstUnique(test2) << endl;\n\n    vector<int> test3 = {1, 2, 3, 4};\n    cout << \"Test 3: \" << findFirstUnique(test3) << endl;\n    \n    return 0;\n}\n```",
  "1722": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSwap(vector<int>& nums) {\n        int n = nums.size();\n        vector<pair<int, int>> edges;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((nums[i] ^ nums[j]) & 1) {\n                    edges.push_back({i, j});\n                }\n            }\n        }\n\n        int res = 0;\n        sort(edges.begin(), edges.end());\n        vector<int> parent(n);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        for (auto &edge : edges) {\n            int u = edge.first, v = edge.second;\n            if (parent[u] != parent[v]) {\n                parent[u] = parent[v];\n                res++;\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {0,1};\n    cout << \"Test case 1: \" << solution.minSwap(nums1) << endl; // Output: 2\n\n    // Test case 2\n    vector<int> nums2 = {3,5,4,7,9};\n    cout << \"Test case 2: \" << solution.minSwap(nums2) << endl; // Output: 5\n\n    // Test case 3\n    vector<int> nums3 = {1,2,0,3,5};\n    cout << \"Test case 3: \" << solution.minSwap(nums3) << endl; // Output: 4\n\n    return 0;\n}\n```",
  "1721": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nclass Solution {\npublic:\n    ListNode* swapNodes(ListNode* head, int k) {\n        if (!head || !head->next) return head;\n        \n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        ListNode* prev = dummy;\n        for (int i = 1; i < k && prev->next; ++i) {\n            prev = prev->next;\n        }\n        \n        if (!prev->next) return head; // no swap needed\n        \n        ListNode* first = prev;\n        for (int i = 1; i < k && first->next; ++i) {\n            first = first->next;\n        }\n        \n        ListNode* second = first->next;\n        while (second->next) {\n            second = second->next;\n        }\n        \n        // swap\n        ListNode* temp = first->next;\n        first->next = second->next;\n        second->next = temp;\n        \n        return dummy->next; // return the new head\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1:\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(4);\n\n    ListNode* result1 = solution.swapNodes(head1, 2);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test Case 2:\n    head1 = new ListNode(0);\n    head1->next = new ListNode(1);\n    head1->next->next = new ListNode(2);\n\n    result1 = solution.swapNodes(head1, 1);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test Case 3:\n    head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n\n    result1 = solution.swapNodes(head1, 1);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1723": "```\n#include <iostream>\n#include <vector>\n\nint minTime(int n, std::vector<std::vector<int>>& tasks) {\n    int time[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) time[i][j] = tasks[i][1];\n            else time[i][j] = INT_MAX;\n        }\n    }\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if (i == j) continue;\n\n            time[i][j] = std::min(time[i][j], time[i][i] + tasks[i][1] + time[i+1][j]);\n        }\n    }\n\n    return time[0][n-1];\n}\n\nint main() {\n    int n1 = 3;\n    std::vector<std::vector<int>> tasks1 = {{0, 3}, {1, 2}};\n    std::cout << \"Test Case 1: \" << minTime(n1, tasks1) << std::endl;\n\n    int n2 = 4;\n    std::vector<std::vector<int>> tasks2 = {{0, 3}, {1, 2}, {2, 4}, {3, 1}};\n    std::cout << \"Test Case 2: \" << minTime(n2, tasks2) << std::endl;\n\n    int n3 = 5;\n    std::vector<std::vector<int>> tasks3 = {{0, 5}, {1, 6}, {2, 3}, {3, 4}};\n    std::cout << \"Test Case 3: \" << minTime(n3, tasks3) << std::endl;\n\n    return 0;\n}\n```",
  "1725": "```\n#include <iostream>\n#include <vector>\n\nint countGoodRectangles(std::vector<std::vector<int>>& rectangles) {\n    int maxSide = 0;\n    int count = 0;\n\n    for (const auto& rect : rectangles) {\n        int side = *std::minmax_element(rect.begin(), rect.end())->first;\n        if (side > maxSide) {\n            maxSide = side;\n            count = 1;\n        } else if (side == maxSide) {\n            count++;\n        }\n    }\n\n    return count;\n}\n\nint main() {\n    std::vector<std::vector<int>> rectangles1{{5,3},{15,2}};\n    std::cout << \"Test case 1: \" << countGoodRectangles(rectangles1) << std::endl;\n\n    std::vector<std::vector<int>> rectangles2{{1,1},{2,2},{3,3},{4,4}};\n    std::cout << \"Test case 2: \" << countGoodRectangles(rectangles2) << std::endl;\n\n    std::vector<std::vector<int>> rectangles3{{10,8},{5,7},{9,8}};\n    std::cout << \"Test case 3: \" << countGoodRectangles(rectangles3) << std::endl;\n\n    return 0;\n}\n```",
  "1724": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isExist(vector<vector<int>>& graph, int n, int m, vector<vector<int>> &edges) {\n        int parent[501][501];\n        for (int i = 0; i < 501; i++) {\n            for (int j = 0; j < 501; j++) {\n                if (i == j)\n                    parent[i][j] = i;\n                else\n                    parent[i][j] = -1;\n            }\n        }\n\n        for (auto &edge : edges) {\n            int u = edge[0], v = edge[1];\n            if (parent[u][v] == -1 && edge[2] <= m) {\n                parent[v][u] = u;\n                parent[u][v] = u;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int root = i;\n            while (root != parent[root][i]) {\n                root = parent[root][i];\n            }\n            edges[i].back() = root;\n        }\n\n        for (auto &edge : edges) {\n            if (parent[edge[0]][edge[1]] == -1)\n                return false;\n        }\n\n        for (int i = 0; i < n; i++) {\n            int root = edges[i].back();\n            for (int j = 0; j < n; j++) {\n                if (edges[j].back() != root) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> graph1 = {{1,2,3},{1,3,5}};\n    int n1 = 3, m1 = 6;\n    vector<vector<int>> edges1 = {{0,1,4},{1,2,5},{0,2,1}};\n    cout << (solution.isExist(graph1, n1, m1, edges1) ? \"True\" : \"False\") << endl;\n\n    // Test Case 2\n    vector<vector<int>> graph2 = {};\n    int n2 = 0, m2 = 0;\n    vector<vector<int>> edges2 = {{}};\n    cout << (solution.isExist(graph2, n2, m2, edges2) ? \"True\" : \"False\") << endl;\n\n    // Test Case 3\n    vector<vector<int>> graph3 = {{1,2,5},{1,3,6},{2,3,7},{0,1,8}};\n    int n3 = 4, m3 = 9;\n    vector<vector<int>> edges3 = {{0,1,8},{1,2,5},{2,3,7},{0,3,6}};\n    cout << (solution.isExist(graph3, n3, m3, edges3) ? \"True\" : \"False\") << endl;\n\n    return 0;\n}\n```",
  "1726": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint numIdenticalPairs(std::vector<int>& nums) {\n    std::unordered_map<int, int> count;\n    int pairs = 0;\n\n    for (int num : nums) {\n        if (count.find(num) != count.end()) {\n            count[num]++;\n        } else {\n            count[num] = 1;\n        }\n    }\n\n    for (auto& pair : count) {\n        int val = pair.second;\n        pairs += val * (val - 1) / 2;\n    }\n\n    return pairs;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 1, 1, 1};\n    std::cout << \"Test case 1: \" << numIdenticalPairs(nums1) << std::endl;\n\n    std::vector<int> nums2 = {1, 2, 3, 4};\n    std::cout << \"Test case 2: \" << numIdenticalPairs(nums2) << std::endl;\n\n    std::vector<int> nums3 = {1, 1, 1, 2, 1, 1};\n    std::cout << \"Test case 3: \" << numIdenticalPairs(nums3) << std::endl;\n\n    return 0;\n}\n```",
  "1727": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint maxUncrossedLines(vector<int>& A, vector<int>& B) {\n    int m = A.size(), n = B.size();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (A[i - 1] == B[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n    \n    return dp[m][n];\n}\n\nint main() {\n    vector<int> A1 = {1,3};\n    vector<int> B1 = {2,5};\n    cout << \"Test case 1: \" << maxUncrossedLines(A1, B1) << endl;\n\n    vector<int> A2 = {1,4,8,10};\n    vector<int> B2 = {2,5,9,12};\n    cout << \"Test case 2: \" << maxUncrossedLines(A2, B2) << endl;\n\n    vector<int> A3 = {0,1,3,7,8};\n    vector<int> B3 = {0,1,4,7,8};\n    cout << \"Test case 3: \" << maxUncrossedLines(A3, B3) << endl;\n    \n    return 0;\n}\n```",
  "1728": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint totalWays(int n) {\n    vector<vector<int>> dp(n + 1, vector<int>(n + 1));\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j] + dp[i][j - 1]) % 1000000007;\n            }\n        }\n    }\n    return dp[n][n];\n}\n\nint main() {\n    cout << totalWays(2) << endl; // Test case 1\n    cout << totalWays(3) << endl; // Test case 2\n    cout << totalWays(4) << endl; // Test case 3\n\n    return 0;\n}\n```",
  "1729": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint countFollowers(const std::vector<std::pair<std::string, std::vector<std::string>>>& users) {\n    int totalFollowers = 0;\n    for (const auto& user : users) {\n        totalFollowers += user.second.size();\n    }\n    return totalFollowers;\n}\n\nint main() {\n    std::vector<std::pair<std::string, std::vector<std::string>>> users;\n\n    // Test Case 1\n    users = {{\"Alice\", {\"Bob\", \"Charlie\"}}, {\"Bob\", {\"Alice\"}}, {\"Charlie\", {}}};\n    int followersCount1 = countFollowers(users);\n    if (followersCount1 != 2) {\n        std::cerr << \"Test Case 1 failed. Expected 2, got \" << followersCount1 << \".\" << std::endl;\n        return 1;\n    }\n\n    // Test Case 2\n    users = {{\"John\", {\"Jane\"}}, {\"Jane\", {\"John\"}}};\n    int followersCount2 = countFollowers(users);\n    if (followersCount2 != 2) {\n        std::cerr << \"Test Case 2 failed. Expected 2, got \" << followersCount2 << \".\" << std::endl;\n        return 1;\n    }\n\n    // Test Case 3\n    users = {{\"Tom\", {\"Sara\", \"Mark\"}}, {\"Sara\", {}}, {\"Mark\", {\"Tom\"}}};\n    int followersCount3 = countFollowers(users);\n    if (followersCount3 != 2) {\n        std::cerr << \"Test Case 3 failed. Expected 2, got \" << followersCount3 << \".\" << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All test cases passed.\" << std::endl;\n    return 0;\n}\n```",
  "1730": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int shortestToTarget(vector<string>& target, string s) {\n        int n = target.size();\n        vector<int> res(n);\n        for (int i = 0; i < n; ++i) {\n            if (target[i] == s[0]) {\n                res[i] = 0;\n            } else if (s.find(target[i].c_str()) != string::npos) {\n                res[i] = min(abs(i), n - abs(i));\n            }\n        }\n\n        int minStep = INT_MAX;\n        for (int i = 0; i < n; ++i) {\n            if (target[i] == s[0]) {\n                return res[i];\n            }\n            minStep = min(minStep, res[i]);\n        }\n\n        return minStep;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> target1 = {\"hello\",\"i\",\"am\",\"sunny\",\"world\"};\n    string s1 = \"sunny\";\n    cout << \"Test case 1: \" << solution.shortestToTarget(target1, s1) << endl;\n    \n    // Test case 2\n    vector<string> target2 = {\"leet\",\"code\"};\n    string s2 = \"leet\";\n    cout << \"Test case 2: \" << solution.shortestToTarget(target2, s2) << endl;\n    \n    // Test case 3\n    vector<string> target3 = {\"apple\",\"banana\"};\n    string s3 = \"banana\";\n    cout << \"Test case 3: \" << solution.shortestToTarget(target3, s3) << endl;\n\n    return 0;\n}\n```",
  "1731": "```\n#include <unordered_map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> getReportedCount(vector<vector<int>>& reports) {\n        unordered_map<int, int> count;\n        for (const auto& report : reports) {\n            ++count[report[1]];\n        }\n        return vector<vector<int>>(count.begin(), count.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> reports1 = {{1,2},{2,3},{3,2},{4,5},{5,6}};\n    for (const auto& row : solution.getReportedCount(reports1)) {\n        cout << \"{\";\n        for (int i = 0; i < row.size(); ++i) {\n            cout << row[i];\n            if (i < row.size() - 1) {\n                cout << \",\";\n            }\n        }\n        cout << \"}\" << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> reports2 = {{1,2},{2,3},{4,5}};\n    for (const auto& row : solution.getReportedCount(reports2)) {\n        cout << \"{\";\n        for (int i = 0; i < row.size(); ++i) {\n            cout << row[i];\n            if (i < row.size() - 1) {\n                cout << \",\";\n            }\n        }\n        cout << \"}\" << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> reports3 = {};\n    for (const auto& row : solution.getReportedCount(reports3)) {\n        cout << \"{\";\n        for (int i = 0; i < row.size(); ++i) {\n            cout << row[i];\n            if (i < row.size() - 1) {\n                cout << \",\";\n            }\n        }\n        cout << \"}\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1732": "```\n#include <iostream>\n#include <vector>\n\nint highestAltitude(std::vector<std::vector<int>>& altitude) {\n    int max = 0;\n    for (int i = 0; i < altitude.size(); i++) {\n        int current = 0;\n        for (int j = 0; j < altitude[i].size(); j++) {\n            if (j == 0) {\n                current = altitude[i][j];\n            } else {\n                current += altitude[i][j] - altitude[i][j-1];\n            }\n            max = std::max(max, current);\n        }\n    }\n    return max;\n}\n\nint main() {\n    std::vector<std::vector<int>> altitude1 = {{1,2,3},{4,5,6}};\n    int result1 = highestAltitude(altitude1);\n    std::cout << \"Test case 1: Expected output 10, got \" << result1 << std::endl;\n\n    std::vector<std::vector<int>> altitude2 = {{2,1,1},{1,4,5},{5,3,1}};\n    int result2 = highestAltitude(altitude2);\n    std::cout << \"Test case 2: Expected output 7, got \" << result2 << std::endl;\n\n    std::vector<std::vector<int>> altitude3 = {{0,5},{4,-10}};\n    int result3 = highestAltitude(altitude3);\n    std::cout << \"Test case 3: Expected output 1, got \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1733": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minTeachTime(vector<vector<int>>& seats) {\n        vector<int> times;\n        for (const auto& row : seats) {\n            sort(row.begin(), row.end());\n            times.push_back(row[0] + (row.back() - row[0]) / (row.size() - 1));\n        }\n        return *min_element(times.begin(), times.end());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> seats1 = {{5,3,7},{10,9,6}};\n    cout << \"Test Case 1: \" << solution.minTeachTime(seats1) << endl;\n    \n    vector<vector<int>> seats2 = {{15,14,8,13},{12,11,9,10}};\n    cout << \"Test Case 2: \" << solution.minTeachTime(seats2) << endl;\n\n    vector<vector<int>> seats3 = {{5}};\n    cout << \"Test Case 3: \" << solution.minTeachTime(seats3) << endl;\n    \n    return 0;\n}\n```",
  "1734": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> decode(vector<int>& encoded, int first) {\n        vector<int> permutation(encoded.size(), 0);\n        permutation[0] = first;\n        for (int i = 1; i < encoded.size(); ++i) {\n            permutation[i] = permutation[i - 1] ^ encoded[i - 1];\n        }\n        return permutation;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> encoded1 = {4,2,3};\n    int first1 = 1;\n    vector<int> result1 = solution.decode(encoded1, first1);\n    for (int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<int> encoded2 = {6,5,4,6};\n    int first2 = 5;\n    vector<int> result2 = solution.decode(encoded2, first2);\n    for (int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<int> encoded3 = {1,4,7};\n    int first3 = 0;\n    vector<int> result3 = solution.decode(encoded3, first3);\n    for (int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1735": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSteps(int steps) {\n        if (steps == 0)\n            return 1;\n        \n        int res = 0, i = 0;\n        while ((long long)i * 2 <= steps) {\n            res += (steps - i * 2 + 1);\n            i++;\n        }\n        \n        for (;i < steps; i++) {\n            res += 1;\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n    \n    cout << \"Test case 1: \" << solution.numSteps(3) << endl;\n    cout << \"Test case 2: \" << solution.numSteps(4) << endl;\n    cout << \"Test case 3: \" << solution.numSteps(10) << endl;\n    \n    return 0;\n}\n```",
  "1736": "```\n#include <iostream>\n#include <string>\n\nint findLatestTime(const std::string& s) {\n    int n = s.size();\n    int res = 0;\n    for (int i = 1; i < n - 1; i++) {\n        if (s[i] == '?') {\n            int left = std::stoi(s.substr(0, i));\n            int right = std::stoi(s.substr(i + 1));\n            res = std::max(res, std::min(left, 23) * 60 + std::min(right, 59));\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << findLatestTime(\"11:00\") << std::endl; // Expected output: 660\n    std::cout << findLatestTime(\"??:34\") << std::endl; // Expected output: 634\n    std::cout << findLatestTime(\"18:59\") << std::endl; // Expected output: 5959\n    return 0;\n}\n```",
  "1737": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSteps(string s) {\n        int res = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == 'o') res += 2;\n            else res++;\n        }\n        return res / 2;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test Case 1: \";\n    string s1 = \"leetcode\";\n    int result1 = solution.minSteps(s1);\n    cout << result1 << endl;\n\n    cout << \"Test Case 2: \";\n    string s2 = \"loveleetcode\";\n    int result2 = solution.minSteps(s2);\n    cout << result2 << endl;\n\n    cout << \"Test Case 3: \";\n    string s3 = \"llooooveleetttcode\";\n    int result3 = solution.minSteps(s3);\n    cout << result3 << endl;\n    \n    return 0;\n}\n```",
  "1738": "```\n#include <iostream>\n#include <vector>\n\nint findKthLargest(std::vector<std::vector<int>>& grid, int k) {\n    std::vector<int> nums;\n    for (const auto& row : grid) {\n        for (const auto& num : row) {\n            nums.push_back(num);\n        }\n    }\n    \n    std::sort(nums.begin(), nums.end());\n    return nums[nums.size() - k];\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> grid1 = {{5, 2}, {1, 9}};\n    int k1 = 2;\n    std::cout << \"Test case 1: \" << findKthLargest(grid1, k1) << std::endl;\n\n    // Test case 2\n    std::vector<std::vector<int>> grid2 = {{12, 5, 6}, {7, 1, 15}, {13, 2, 3}};\n    int k2 = 2;\n    std::cout << \"Test case 2: \" << findKthLargest(grid2, k2) << std::endl;\n\n    // Test case 3\n    std::vector<std::vector<int>> grid3 = {{1, 4}, {9, 7}};\n    int k3 = 1;\n    std::cout << \"Test case 3: \" << findKthLargest(grid3, k3) << std::endl;\n\n    return 0;\n}\n```",
  "1739": "```\n#include <iostream>\n#include <vector>\n\nbool canPlace(int height, int width, int length) {\n    // Your solution here...\n}\n\nint main() {\n    std::cout << \"Test case 1: \";\n    if (canPlace(10, 2, 5)) std::cout << \"True\" << std::endl;\n    else std::cout << \"False\" << std::endl;\n\n    std::cout << \"Test case 2: \";\n    if (canPlace(12, 3, 4)) std::cout << \"True\" << std::endl;\n    else std::cout << \"False\" << std::endl;\n\n    std::cout << \"Test case 3: \";\n    if (canPlace(6, 1, 5)) std::cout << \"True\" << std::endl;\n    else std::cout << \"False\" << std::endl;\n    \n    return 0;\n}\n```",
  "1741": "```\n#include <iostream>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    map<string, int> getTotalTime(map<pair<string, string>, int>& logs) {\n        map<string, int> totalTime;\n        \n        for (const auto& log : logs) {\n            string emp = log.first.first;\n            int time = log.second;\n            \n            if (totalTime.find(emp) != totalTime.end()) {\n                totalTime[emp] += time;\n            } else {\n                totalTime[emp] = time;\n            }\n        }\n        \n        return totalTime;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    map<pair<string, string>, int> logs1 = {make_pair(pair<string, string>(\"John\", \"login\"), 10), \n                                             make_pair(pair<string, string>(\"John\", \"logout\"), 5),\n                                             make_pair(pair<string, string>(\"Alice\", \"login\"), 20)};\n    auto totalTime1 = solution.getTotalTime(logs1);\n    for (const auto& pair : totalTime1) {\n        cout << \"Employee: \" << pair.first << \", Total Time: \" << pair.second << endl;\n    }\n\n    // Test case 2\n    map<pair<string, string>, int> logs2 = {make_pair(pair<string, string>(\"Bob\", \"login\"), 5), \n                                             make_pair(pair<string, string>(\"Bob\", \"logout\"), 3),\n                                             make_pair(pair<string, string>(\"John\", \"login\"), 10)};\n    auto totalTime2 = solution.getTotalTime(logs2);\n    for (const auto& pair : totalTime2) {\n        cout << \"Employee: \" << pair.first << \", Total Time: \" << pair.second << endl;\n    }\n\n    // Test case 3\n    map<pair<string, string>, int> logs3 = {make_pair(pair<string, string>(\"Alice\", \"login\"), 20), \n                                             make_pair(pair<string, string>(\"John\", \"logout\"), 5)};\n    auto totalTime3 = solution.getTotalTime(logs3);\n    for (const auto& pair : totalTime3) {\n        cout << \"Employee: \" << pair.first << \", Total Time: \" << pair.second << endl;\n    }\n\n    return 0;\n}\n```",
  "1740": "```\n#include <iostream>\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int findClosestLeaf(TreeNode* root) {\n        unordered_map<TreeNode*, bool> visited;\n        queue<TreeNode*> q;\n        \n        if(root) {\n            q.push(root);\n            visited[root] = true;\n        }\n        \n        int closest = INT_MAX, dist = 0;\n        while(!q.empty()) {\n            TreeNode *node = q.front();\n            q.pop();\n            \n            if(node->val == 1) {\n                return dist;\n            }\n            \n            if(node->left && !visited[node->left]) {\n                visited[node->left] = true;\n                q.push(node->left);\n            }\n            \n            if(node->right && !visited[node->right]) {\n                visited[node->right] = true;\n                q.push(node->right);\n            }\n            \n            dist++;\n        }\n        \n        return -1;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    TreeNode* root1 = new TreeNode(1);\n    TreeNode* n2 = new TreeNode(3);\n    TreeNode* n4 = new TreeNode(2);\n    TreeNode* n5 = new TreeNode(1);\n\n    root1->left = n2;\n    root1->right = n4;\n    n4->left = n5;\n\n    cout << sol.findClosestLeaf(root1) << endl; // Output: 3\n\n    TreeNode* root2 = new TreeNode(1);\n    TreeNode* n3 = new TreeNode(2);\n\n    root2->left = n3;\n\n    cout << sol.findClosestLeaf(root2) << endl; // Output: 2\n\n    TreeNode* root3 = new TreeNode(1);\n    TreeNode* n6 = new TreeNode(2);\n    TreeNode* n7 = new TreeNode(4);\n    TreeNode* n8 = new TreeNode(5);\n\n    root3->left = n6;\n    root3->right = n7;\n    n7->left = n8;\n\n    cout << sol.findClosestLeaf(root3) << endl; // Output: 2\n\n    return 0;\n}\n```",
  "1742": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxBalls(int num1, int num2, int num3) {\n        return (num1 + num2 + num3 - 1);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test Case 1: \" << solution.maxBalls(1, 1, 2) << endl; // Expected output: 4\n    cout << \"Test Case 2: \" << solution.maxBalls(5, 3, 6) << endl; // Expected output: 12\n    cout << \"Test Case 3: \" << solution.maxBalls(10, 8, 7) << endl; // Expected output: 24\n\n    return 0;\n}\n```",
  "1744": "```\n#include <iostream>\n#include <vector>\n\nint totalFruit(std::vector<int>& fruits) {\n    int maxCount = 0;\n    int currentCount = 0;\n    char previousType = '\\0';\n    \n    for (int fruit : fruits) {\n        if (fruit == previousType)\n            currentCount++;\n        else {\n            maxCount = std::max(maxCount, currentCount);\n            currentCount = 1;\n            previousType = fruit;\n        }\n    }\n    \n    return std::max(maxCount, currentCount);\n}\n\nint main() {\n    // Test case 1:\n    std::vector<int> fruits1 = {1, 2, 3, 2, 2};\n    std::cout << \"Test case 1: \" << totalFruit(fruits1) << std::endl;\n\n    // Test case 2:\n    std::vector<int> fruits2 = {0, 1, 2, 3, 4, 5};\n    std::cout << \"Test case 2: \" << totalFruit(fruits2) << std::endl;\n\n    // Test case 3:\n    std::vector<int> fruits3 = {1, 2, 3, 4, 5, 5};\n    std::cout << \"Test case 3: \" << totalFruit(fruits3) << std::endl;\n    \n    return 0;\n}\n```",
  "1743": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nvector<int> restoreArray(vector<vector<int>>& adjacentPairs) {\n    unordered_map<int, int> map;\n    for (int i = 0; i < adjacentPairs.size(); i++) {\n        map[adjacentPairs[i][0]] = adjacentPairs[i][1];\n        map[adjacentPairs[i][1]] = adjacentPairs[i][0];\n    }\n    \n    vector<int> result(3);\n    for (auto it = map.begin(); it != map.end() - 2; it++) {\n        if (it->second == 0) {\n            result[0] = it->first;\n        } else if (it->second == 1) {\n            result[1] = it->first;\n        }\n    }\n    \n    result[2] = map.begin()->first;\n    return result;\n}\n\nint main() {\n    vector<vector<int>> adjacentPairs1 = {{2,1},{4,3}};\n    vector<int> expected1 = {1,2,4};\n    if (restoreArray(adjacentPairs1) != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n    } else {\n        cout << \"Test case 1 passed.\" << endl;\n    }\n\n    vector<vector<int>> adjacentPairs2 = {{3,8},{4,6},{5,7}};\n    vector<int> expected2 = {3,4,5};\n    if (restoreArray(adjacentPairs2) != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n    } else {\n        cout << \"Test case 2 passed.\" << endl;\n    }\n\n    vector<vector<int>> adjacentPairs3 = {{1000000000,1000000010},{1000000001,1000000024}};\n    vector<int> expected3 = {1000000000,1000000001,1000000010};\n    if (restoreArray(adjacentPairs3) != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n    } else {\n        cout << \"Test case 3 passed.\" << endl;\n    }\n\n    return 0;\n}",
  "1745": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool checkPartition(string s) {\n        int n = s.size();\n        for (int i = 0; i <= n; i++) {\n            string t = s.substr(0, i);\n            if (!isPalindrome(t)) return false;\n        }\n        return true;\n    }\n\n    bool isPalindrome(string s) {\n        int left = 0, right = s.size() - 1;\n        while (left < right) {\n            if (s[left] != s[right]) return false;\n            left++;\n            right--;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string test1 = \"aab\";\n    cout << \"Test case 1: \" << (solution.checkPartition(test1) ? \"True\" : \"False\") << endl;\n\n    // Test case 2\n    string test2 = \"a\";\n    cout << \"Test case 2: \" << (solution.checkPartition(test2) ? \"True\" : \"False\") << endl;\n\n    // Test case 3\n    string test3 = \"abc\";\n    cout << \"Test case 3: \" << (solution.checkPartition(test3) ? \"True\" : \"False\") << endl;\n    \n    return 0;\n}\n```",
  "1746": "```\n#include <iostream>\n#include <vector>\n\nint maxSumAfterOneOperation(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n == 1) return nums[0];\n    \n    std::vector<int> dp(n, nums[0]);\n    int sum = nums[0];\n\n    for (int i = 1; i < n; i++) {\n        if (i % 2 == 0) sum += nums[i];\n        else sum -= nums[i];\n        \n        if (sum < 0) sum = 0;\n        dp[i] = std::max(dp[i-1], sum);\n    }\n    \n    return *std::max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    // Test Case 1:\n    std::vector<int> nums1 = {-5, -3, -2, 7, 1};\n    int result1 = maxSumAfterOneOperation(nums1);\n    std::cout << \"Test Case 1: Expected 9, Got \" << result1 << std::endl;\n\n    // Test Case 2:\n    std::vector<int> nums2 = [3, 5, -6, 2, -7];\n    int result2 = maxSumAfterOneOperation(nums2);\n    std::cout << \"Test Case 2: Expected 15, Got \" << result2 << std::endl;\n\n    // Test Case 3:\n    std::vector<int> nums3 = {-1, -2, -3};\n    int result3 = maxSumAfterOneOperation(nums3);\n    std::cout << \"Test Case 3: Expected -1, Got \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1747": "```\n#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numBanned(int n, vector<string>& banneds) {\n        set<string> bannedSet(banneds.begin(), banneds.end());\n        return count_if(banneds.begin(), banneds.end(), [bannedSet](const string& s) {\n            return !bannedSet.count(s);\n        });\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<string> banned1 = {\"abc\", \"def\"};\n    cout << \"Test case 1: \" << solution.numBanned(2, banned1) << endl; // Expected output: 0\n    \n    // Test case 2\n    vector<string> banned2 = {\"leetcode\",\"love\",\"like\",\"lovely\",\"lollipop\",\"lot\",\"loop\"};\n    cout << \"Test case 2: \" << solution.numBanned(7, banned2) << endl; // Expected output: 4\n    \n    // Test case 3\n    vector<string> banned3 = {\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"};\n    cout << \"Test case 3: \" << solution.numBanned(15, banned3) << endl; // Expected output: 0\n    \n    return 0;\n}\n```",
  "1748": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint sumOfUnique(const std::vector<int>& nums) {\n    std::unordered_map<int, int> count;\n    for (const auto& num : nums) {\n        count[num]++;\n    }\n    int sum = 0;\n    for (const auto& pair : count) {\n        if (pair.second == 1) {\n            sum += pair.first;\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << sumOfUnique({1,2,3}) << std::endl; // Expected output: 6\n    std::cout << sumOfUnique({1,1,1,2,2,3,3}) << std::endl; // Expected output: 6\n    std::cout << sumOfUnique({1,5,5,11,13,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32}) << std::endl; // Expected output: 120\n    return 0;\n}",
  "1750": "```\n#include <iostream>\n#include <string>\n\nint minimumLengthAfterDeletions(std::string s) {\n    int i = 0, j = s.length() - 1;\n    \n    while (i < j) {\n        if (s[i] == s[j]) {\n            do {\n                i++;\n            } while (i < j && s[i] == s[i-1]);\n            \n            do {\n                j--;\n            } while (j > i && s[j] == s[j+1]);\n        } else {\n            break;\n        }\n    }\n    \n    return j - i + 1;\n}\n\nint main() {\n    std::cout << minimumLengthAfterDeletions(\"aaa\") << std::endl; // Output: 0\n    std::cout << minimumLengthAfterDeletions(\"elevenplusone\") << std::endl; // Output: 6\n    std::cout << minimumLengthAfterDeletions(\"yazxz\") << std::endl; // Output: 2\n    \n    return 0;\n}",
  "1749": "```\n#include <iostream>\n#include <vector>\n\nint maxAbsoluteSum(std::vector<int>& nums) {\n    int maxCur = 0, minCur = 0;\n    int maxSoFar = 0, minSoFar = 0;\n\n    for (int num : nums) {\n        if (num > 0) {\n            maxCur += num; \n            minCur = 0;\n        } else if (num < 0) {\n            minCur += num; \n            maxCur = 0;\n        } else {\n            if (maxCur > 0) {\n                maxSoFar = std::max(maxSoFar, maxCur);\n                maxCur = 0;\n            }\n            if (minCur < 0) {\n                minSoFar = std::min(minSoFar, minCur);\n                minCur = 0;\n            }\n        }\n\n        int temp = std::max(maxCur, minCur) + num;\n        maxCur = std::max(temp, num);\n        minCur = std::min(temp, num);\n\n        if (maxCur > maxSoFar)\n            maxSoFar = maxCur;\n        if (minCur < minSoFar)\n            minSoFar = minCur;\n    }\n\n    return maxSoFar - minSoFar;\n}\n\nint main() {\n    std::vector<int> nums1 = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n    int result1 = maxAbsoluteSum(nums1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> nums2 = {1, -3, 2};\n    int result2 = maxAbsoluteSum(nums2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> nums3 = [5];\n    int result3 = maxAbsoluteSum(nums3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}",
  "1751": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxEvents(std::vector<int>& events) {\n    std::sort(events.begin(), events.end());\n    int ans = 0, prevEnd = -1;\n    for (int event : events) {\n        if (event > prevEnd) {\n            prevEnd = event + 1; // or event\n            ++ans;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::vector<int> tests[] = {\n        {1,4,2,5,3,7}, \n        {2,3,1,6,5}, \n        {1,3,2}\n    };\n    \n    for (const auto& test : tests) {\n        std::cout << \"Test case: \";\n        for (int event : test) {\n            std::cout << event << ' ';\n        }\n        std::cout << '\\n';\n        \n        int result = maxEvents(test);\n        std::cout << \"Maximum Number of Events That Can Be Attended II: \" << result << '\\n';\n        std::cout << '\\n';\n    }\n    \n    return 0;\n}\n```",
  "1752": "```\n#include <iostream>\n#include <vector>\n\nbool checkArraySortedAndRotated(std::vector<int>& nums) {\n    int n = nums.size();\n    for (int i = 0; i < n - 1; ++i) {\n        if (nums[i] > nums[i + 1]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::vector<int> test1 = {3,4,5,1,2};\n    std::cout << \"Test case 1: \" << (checkArraySortedAndRotated(test1) ? \"Pass\" : \"Fail\") << std::endl;\n\n    std::vector<int> test2 = {1};\n    std::cout << \"Test case 2: \" << (checkArraySortedAndRotated(test2) ? \"Pass\" : \"Fail\") << std::endl;\n\n    std::vector<int> test3 = {1,2,3,4,5};\n    std::cout << \"Test case 3: \" << (checkArraySortedAndRotated(test3) ? \"Pass\" : \"Fail\") << std::endl;\n    \n    return 0;\n}\n```",
  "1753": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxScore(int stones[], int k) {\n        priority_queue<int> pq;\n        for (int stone : stones) {\n            pq.push(-stone);\n        }\n        int score = 0, removed = 0;\n        while (!pq.empty() && removed < k) {\n            if (-pq.top() > 0) {\n                score += -pq.top();\n                pq.pop();\n            } else {\n                removed++;\n                for (int i = 1; i <= k; i++) {\n                    if (pq.size() >= i) {\n                        pq.pop();\n                        i--;\n                    }\n                }\n            }\n        }\n        return score;\n    }\n};\n\nint main() {\n    Solution solution;\n    int stones1[] = {5,4,10};\n    cout << \"Test case 1: \" << solution.maxScore(stones1, 4) << endl;\n\n    int stones2[] = {7,2,4,8,9};\n    cout << \"Test case 2: \" << solution.maxScore(stones2, 3) << endl;\n\n    int stones3[] = {10,6,8,5};\n    cout << \"Test case 3: \" << solution.maxScore(stones3, 4) << endl;\n    \n    return 0;\n}\n```",
  "1754": "```\n#include <iostream>\n#include <string>\n\nstd::string largestMerge(std::string word1, std::string word2) {\n    int i = 0, j = 0;\n    std::string merged = \"\";\n    \n    while (i < word1.size() && j < word2.size()) {\n        if (word1[i] >= word2[j]) {\n            merged += word1[i];\n            i++;\n        } else {\n            merged += word2[j];\n            j++;\n        }\n    }\n    \n    merged += word1.substr(i) + word2.substr(j);\n    \n    return merged;\n}\n\nint main() {\n    std::cout << largestMerge(\"abc\", \"def\") << \"\\n\";  // Output: abedf\n    std::cout << largestMerge(\"adc\", \"yazz\") << \"\\n\";  // Output: adyczyz\n    std::cout << largestMerge(\"da\", \"b\") << \"\\n\";  // Output: dab\n    \n    return 0;\n}\n```",
  "1755": "```\n#include <iostream>\n#include <vector>\n\nint closestSubsequenceSum(std::vector<int>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(10001));\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= 10000; j++) {\n            if (j < nums[i - 1]) {\n                dp[i][j] = dp[i - 1][j];\n            } else {\n                dp[i][j] = std::max(dp[i - 1][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1]);\n            }\n        }\n    }\n    \n    int res = 0;\n    for (int i = 1; i <= n; i++) {\n        res = std::max(res, dp[i][res]);\n    }\n    \n    return res;\n}\n\nint main() {\n    // Test case 1:\n    std::vector<int> nums1 = {-2, 1, -3, 4};\n    int result1 = closestSubsequenceSum(nums1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    // Test case 2:\n    std::vector<int> nums2 = {0, 0, 0, 0, 0};\n    int result2 = closestSubsequenceSum(nums2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    // Test case 3:\n    std::vector<int> nums3 = {-1, -2, -3, -4, -5};\n    int result3 = closestSubsequenceSum(nums3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1757": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int productExceptElement(vector<int>& nums) {\n        vector<int> res(nums.size(), 1);\n        long left = 1, right = 1;\n        \n        for(int i = 0; i < nums.size(); i++) {\n            res[i] *= left;\n            left *= nums[i];\n        }\n        \n        for(int i = nums.size() - 1; i >= 0; i--) {\n            res[i] *= right;\n            right *= nums[i];\n        }\n        \n        return accumulate(res.begin(), res.end(), 0);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<int> test1 = {1,2,3,4};\n    cout << \"Test case 1: \" << solution.productExceptElement(test1) << endl;\n    \n    vector<int> test2 = {1,2,3,-5};\n    cout << \"Test case 2: \" << solution.productExceptElement(test2) << endl;\n    \n    vector<int> test3 = [4, -3, 9, 3, 2];\n    cout << \"Test case 3: \" << solution.productExceptElement(test3) << endl;\n    \n    return 0;\n}\n```",
  "1756": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass MostRecentQueue {\npublic:\n    MostRecentQueue() {}\n\n    void push(int item) {\n        if (queue_.empty()) {\n            queue_.push_back(item);\n            recentItems_[item] = 1;\n        } else {\n            while (!queue_.empty() && queue_.back() != item) {\n                int backItem = queue_.back();\n                queue_.pop_back();\n                recentItems_[backItem]--;\n                if (recentItems_[backItem] == 0) {\n                    recentItems_.erase(backItem);\n                }\n            }\n            queue_.push_back(item);\n            recentItems_[item]++;\n        }\n    }\n\n    int pop() {\n        if (queue_.empty()) return -1;\n        int front = queue_.front();\n        queue_.pop_front();\n        recentItems_[front]--;\n        if (recentItems_[front] == 0) {\n            recentItems_.erase(front);\n        }\n        return front;\n    }\n\nprivate:\n    vector<int> queue_;\n    unordered_map<int, int> recentItems_;\n};\n\nint main() {\n    MostRecentQueue queue;\n\n    // Test case 1\n    cout << \"Test case 1: \";\n    queue.push(1);\n    queue.push(2);\n    cout << queue.pop() << endl;  // prints 1\n    queue.push(3);\n    cout << queue.pop() << endl;  // prints 2\n    queue.push(1);\n    cout << queue.pop() << endl;  // prints 3\n    cout << queue.pop() << endl;  // prints 1\n\n    // Test case 2\n    cout << \"Test case 2: \";\n    for (int i = 5; i > 0; --i) {\n        queue.push(i);\n    }\n    while (!queue.empty()) {\n        cout << queue.pop() << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    cout << \"Test case 3: \";\n    for (int i = 1; i <= 5; ++i) {\n        queue.push(i);\n    }\n    while (!queue.empty()) {\n        cout << queue.pop() << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
  "1758": "```\n#include <iostream>\n#include <string>\n\nint minChanges(std::string s) {\n    int changes = 0;\n    bool previous = (s[0] == '1');\n    \n    for(int i = 1; i < s.length(); i++) {\n        if ((previous && s[i] == '1') || (!previous && s[i] == '0')) {\n            changes++;\n        }\n        previous = !previous;\n    }\n    \n    return changes;\n}\n\nint main() {\n    std::cout << minChanges(\"0102\") << std::endl; // Test case 1\n    std::cout << minChanges(\"10101010\") << std::endl; // Test case 2\n    std::cout << minChanges(\"1110\") << std::endl; // Test case 3\n    \n    return 0;\n}\n```",
  "1759": "```\n#include <iostream>\n#include <string>\n\nint countHomogenousSubstrings(const std::string& s) {\n    int res = 0;\n    for (int i = 0; i < s.size() - 1; ++i) {\n        if (s[i] == s[i + 1]) {\n            int left = i, right = i + 2;\n            while (right <= s.size() && s[left] == s[right]) {\n                ++res;\n                ++left;\n                ++right;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << countHomogenousSubstrings(\"abbACBccc\") << std::endl;  // Output: 9\n    std::cout << countHomogenousSubstrings(\"xyxyx\") << std::endl;       // Output: 4\n    std::cout << countHomogenousSubstrings(\"aaa\") << std::endl;         // Output: 3\n    return 0;\n}\n```",
  "1760": "```\n#include <iostream>\n#include <vector>\n\nint minimumSize(std::vector<int>& rolls) {\n    int low = 1;\n    int high = *std::max_element(rolls.begin(), rolls.end());\n    while (low <= high) {\n        int mid = low + (high - low) / 2;\n        bool canBeDivided = true;\n        for (int roll : rolls) {\n            if (roll % mid != 0) {\n                canBeDivided = false;\n                break;\n            }\n        }\n        if (!canBeDivided) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return low;\n}\n\nint main() {\n    std::vector<int> rolls1 = {2, 7, 5};\n    std::cout << \"Minimum size for \" << rolls1.size() << \" balls: \" << minimumSize(rolls1) << std::endl;\n\n    std::vector<int> rolls2 = {10};\n    std::cout << \"Minimum size for \" << rolls2.size() << \" ball: \" << minimumSize(rolls2) << std::endl;\n\n    std::vector<int> rolls3 = {4, 12, 8};\n    std::cout << \"Minimum size for \" << rolls3.size() << \" balls: \" << minimumSize(rolls3) << std::endl;\n    \n    return 0;\n}\n```",
  "1761": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge {\n    int u;\n    int v;\n};\n\nclass Solution {\npublic:\n    int minTrival(int n, vector<vector<int>>& edges) {\n        vector<vector<Edge>> graph(n);\n        for (const auto& edge : edges) {\n            graph[edge[0]].emplace_back(Edge{edge[0], edge[1]});\n            graph[edge[1]].emplace_back(Edge{edge[1], edge[0]});\n        }\n        \n        int result = n;\n        for (int i = 0; i < n; ++i) {\n            if (graph[i].size() < 2) continue;\n            queue<pair<int, int>> q;\n            vector<bool> visited(n);\n            for (const auto& edge : graph[i]) {\n                q.push({edge.v, i});\n                visited[edge.v] = true;\n            }\n            \n            while (!q.empty()) {\n                int curNode = q.front().first;\n                int prevNode = q.front().second;\n                q.pop();\n                \n                if (graph[curNode].size() < 2) continue;\n                for (const auto& edge : graph[curNode]) {\n                    if (!visited[edge.v] && edge.v != prevNode) {\n                        q.push({edge.v, curNode});\n                        visited[edge.v] = true;\n                    }\n                }\n            }\n            \n            int curNode = i;\n            while (true) {\n                curNode = -1;\n                for (const auto& edge : graph[i]) {\n                    if (!visited[edge.v]) {\n                        curNode = edge.v;\n                        break;\n                    }\n                }\n                if (curNode == -1) break;\n                visited[curNode] = true;\n                i = curNode;\n            }\n            \n            result = min(result, n - count(visited.begin(), visited.end(), true));\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << solution.minTrival(6, {{1, 2}, {1, 3}, {2, 4}}) << endl; // 2\n    cout << solution.minTrival(5, {{1, 2}, {2, 3}, {3, 4}, {4, 5}}) << endl; // 3\n    cout << solution.minTrival(8, {{1, 2}, {2, 3}, {4, 5}, {6, 7}, {7, 8}}) << endl; // 4\n    return 0;\n}\n```",
  "1762": "```\n#include <iostream>\n#include <vector>\n#include <stack>\n\nint calculate Buildings(const std::vector<int>& heights) {\n    int ans = 0;\n    int lastSeenIndex = -1;\n\n    std::stack<int> stack;\n    for (int i = heights.size() - 1; i >= 0; --i) {\n        while (!stack.empty() && stack.top() <= heights[i]) {\n            stack.pop();\n        }\n        if (!stack.empty()) {\n            lastSeenIndex = stack.top();\n        } else {\n            lastSeenIndex = -1;\n        }\n\n        ans += (heights[i] > lastSeenIndex ? 1 : 0);\n\n        stack.push(heights[i]);\n    }\n\n    return ans;\n}\n\nint main() {\n    std::vector<int> heights1 = {4, 2, 3, 1, 3};\n    std::cout << \"Test case 1: \" << calculateBuildings(heights1) << std::endl;\n\n    std::vector<int> heights2 = {6, 8, 12, 7, 3};\n    std::cout << \"Test case 2: \" << calculateBuildings(heights2) << std::endl;\n\n    std::vector<int> heights3 = {1, 2, 3, 5, 4};\n    std::cout << \"Test case 3: \" << calculateBuildings(heights3) << std::endl;\n\n    return 0;\n}\n```",
  "1763": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestNiceSubstring(string s) {\n        int n = s.length();\n        for (int i = 0; i <= n - 7; i++) {\n            for (int j = i + 1; j <= n - 7; j++) {\n                string sub = s.substr(i, j - i + 1);\n                if (isNice(sub)) {\n                    return sub;\n                }\n            }\n        }\n        return \"\";\n    }\n\n    bool isNice(string str) {\n        for (int i = 0; i < str.length(); i++) {\n            int c = tolower((int)str[i]);\n            bool hasLowercase = (c >= 97 && c <= 122);\n            bool hasUppercase = (c >= 65 && c <= 90);\n            if ((hasLowercase && !hasUppercase) || (!hasLowercase && hasUppercase)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s = \"Ybbtyz\";\n    cout << \"Longest nice substring for '\" << s << \"' is: \" << solution.longestNiceSubstring(s) << endl;\n\n    // Test case 2\n    s = \"KnitGood\";\n    cout << \"Longest nice substring for '\" << s << \"' is: \" << solution.longestNiceSubstring(s) << endl;\n\n    // Test case 3\n    s = \"Nope\";\n    cout << \"Longest nice substring for '\" << s << \"' is: \" << solution.longestNiceSubstring(s) << endl;\n\n    return 0;\n}\n```",
  "1764": "```\n#include <iostream>\n#include <vector>\n\nbool canBeEqual(std::vector<int>& target) {\n    int n = target.size();\n    int zeroCount = 0, oneCount = 0;\n    for (int i : target) {\n        if (i == 0) zeroCount++;\n        else oneCount++;\n    }\n    return zeroCount > n / 2 || oneCount > n / 2;\n}\n\nint main() {\n    std::vector<int> target1 = {10, 2, -2, -20, 10};\n    bool result1 = canBeEqual(target1);\n    if (result1) {\n        std::cout << \"Target array can be equal by concatenating subarrays of another array.\" << std::endl;\n    } else {\n        std::cout << \"Target array cannot be equal by concatenating subarrays of another array.\" << std::endl;\n    }\n\n    std::vector<int> target2 = {1, 1};\n    bool result2 = canBeEqual(target2);\n    if (result2) {\n        std::cout << \"Target array can be equal by concatenating subarrays of another array.\" << std::endl;\n    } else {\n        std::cout << \"Target array cannot be equal by concatenating subarrays of another array.\" << std::endl;\n    }\n\n    std::vector<int> target3 = {0, 1};\n    bool result3 = canBeEqual(target3);\n    if (result3) {\n        std::cout << \"Target array can be equal by concatenating subarrays of another array.\" << std::endl;\n    } else {\n        std::cout << \"Target array cannot be equal by concatenating subarrays of another array.\" << std::endl;\n    }\n\n    return 0;\n}",
  "1766": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n};\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if (!root || root == p || root == q) return root;\n        \n        TreeNode* left = lowestCommonAncestor(root->left, p, q);\n        TreeNode* right = lowestCommonAncestor(root->right, p, q);\n        \n        if (left && right) return root;\n        return left ? left : right;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    TreeNode* root1 = new TreeNode(6);\n    root1->left = new TreeNode(2);\n    root1->right = new TreeNode(8);\n    root1->left->left = new TreeNode(0);\n    root1->left->right = new TreeNode(4);\n    root1->right->left = new TreeNode(7);\n    root1->right->right = new TreeNode(9);\n    \n    TreeNode* p1 = root1->left->left;\n    TreeNode* q1 = root1->left->right;\n\n    cout << \"Test case 1: \";\n    TreeNode* res1 = solution.lowestCommonAncestor(root1, p1, q1);\n    if (res1) {\n        cout << res1->val << endl;\n    } else {\n        cout << \"None\" << endl;\n    }\n\n    // Test case 2\n    TreeNode* root2 = new TreeNode(3);\n    root2->left = new TreeNode(5);\n    root2->right = new TreeNode(1);\n\n    TreeNode* p2 = root2->left;\n    TreeNode* q2 = root2;\n\n    cout << \"Test case 2: \";\n    TreeNode* res2 = solution.lowestCommonAncestor(root2, p2, q2);\n    if (res2) {\n        cout << res2->val << endl;\n    } else {\n        cout << \"None\" << endl;\n    }\n\n    // Test case 3\n    TreeNode* root3 = new TreeNode(1);\n    root3->left = new TreeNode(2);\n    root3->right = new TreeNode(3);\n\n    TreeNode* p3 = root3->left;\n    TreeNode* q3 = root3;\n\n    cout << \"Test case 3: \";\n    TreeNode* res3 = solution.lowestCommonAncestor(root3, p3, q3);\n    if (res3) {\n        cout << res3->val << endl;\n    } else {\n        cout << \"None\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1765": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> highestPeak(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        vector<vector<int>> result(m, vector<int>(n, 0));\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    if (i == 0) {\n                        result[i][j] = 1;\n                    } else {\n                        int min_height = INT_MAX;\n                        for (int k = 0; k < j; k++) {\n                            min_height = min(min_height, result[i-1][k]);\n                        }\n                        result[i][j] = min_height + 1;\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> grid1 = {{0,1},{0,0}};\n    vector<vector<int>> result1 = solution.highestPeak(grid1);\n    for (auto &row : result1) {\n        for (auto &height : row) {\n            cout << height << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<vector<int>> grid2 = {{0,0,1},{0,0,0}};\n    vector<vector<int>> result2 = solution.highestPeak(grid2);\n    for (auto &row : result2) {\n        for (auto &height : row) {\n            cout << height << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<vector<int>> grid3 = {{0,1,1},{0,0,1}};\n    vector<vector<int>> result3 = solution.highestPeak(grid3);\n    for (auto &row : result3) {\n        for (auto &height : row) {\n            cout << height << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1767": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findUnfinishedTasks(vector<vector<int>>& tasks) {\n        unordered_map<int, int> taskDuration;\n        for (const auto& task : tasks) {\n            taskDuration[task[1]] = 0;\n            for (int i = 2; i < task.size(); ++i) {\n                if (!task[i].compare(0, task[i].size(), \"Start\") || !task[i].compare(0, task[i].size(), \"Finish\")) {\n                    taskDuration[task[i - 1]]++;\n                }\n            }\n        }\n\n        vector<string> unfinishedTasks;\n        for (const auto& pair : taskDuration) {\n            if (pair.second == 0) {\n                unfinishedTasks.push_back(to_string(pair.first));\n            }\n        }\n\n        return unfinishedTasks;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> tasks1 = {{1, 3}, {2, 5}, {7, 9}};\n    cout << \"Test case 1: \";\n    for (const auto& task : solution.findUnfinishedTasks(tasks1)) {\n        cout << task << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<vector<int>> tasks2 = {{3, 4}, {5, 6}, {10, 12}};\n    cout << \"Test case 2: \";\n    for (const auto& task : solution.findUnfinishedTasks(tasks2)) {\n        cout << task << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<vector<int>> tasks3 = {{1, 5}, {4, 8}};\n    cout << \"Test case 3: \";\n    for (const auto& task : solution.findUnfinishedTasks(tasks3)) {\n        cout << task << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1768": "```\n#include <iostream>\n#include <string>\n\nstd::string mergeAlternates(std::string word1, std::string word2) {\n    std::string result;\n    int i = 0, j = 0;\n\n    while (i < word1.size() && j < word2.size()) {\n        result += word1[i++];\n        if (j + 1 < word2.size())\n            result += word2[j++];\n\n        if (i < word1.size() && j < word2.size()) {\n            i++;\n            j++;\n        }\n    }\n\n    while (i < word1.size())\n        result += word1[i++];\n    while (j < word2.size())\n        result += word2[j++];\n\n    return result;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \";\n    std::string s1 = \"abc\", s2 = \"pqr\";\n    std::cout << mergeAlternates(s1, s2) << std::endl;\n\n    std::cout << \"Test Case 2: \";\n    s1 = \"abcd\"; s2 = \"pq\";\n    std::cout << mergeAlternates(s1, s2) << std::endl;\n\n    std::cout << \"Test Case 3: \";\n    s1 = \"ab\"; s2 = \"pqr\";\n    std::cout << mergeAlternates(s1, s2) << std::endl;\n\n    return 0;\n}\n```",
  "1769": "```\n#include <iostream>\n#include <vector>\n\nint minOperations(std::vector<int>& boxes) {\n    int res = 0;\n    for (int i = 1; i < boxes.size() - 1; ++i) {\n        if (boxes[i] != boxes[0]) {\n            if (boxes[i] > boxes[0])\n                res += i;\n            else\n                res += boxes.size() - i - 1;\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> box1 = {2, 1, 3};\n    int result1 = minOperations(box1);\n    std::cout << \"box1: \" << result1 << std::endl;\n\n    std::vector<int> box2 = {5, 4, 2, 3};\n    int result2 = minOperations(box2);\n    std::cout << \"box2: \" << result2 << std::endl;\n\n    std::vector<int> box3 = {1, 1, 1};\n    int result3 = minOperations(box3);\n    std::cout << \"box3: \" << result3 << std::endl;\n}\n```",
  "1770": "```\n#include <iostream>\n#include <vector>\n\nint maxScore(vector<int>& cardPoints, int k) {\n    int n = cardPoints.size();\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1));\n    \n    for (int i = 0; i <= n; i++) {\n        if (i == 0) {\n            for (int j = 0; j <= k; j++) {\n                dp[i][j] = cardPoints[j];\n            }\n        } else {\n            for (int j = 0; j <= min(i, k); j++) {\n                if (j == 0) {\n                    dp[i][j] = dp[i - 1][k];\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], cardPoints[i - 1] + dp[i - 2][j - 1]);\n                }\n            }\n        }\n    }\n    \n    return dp[n][k];\n}\n\nint main() {\n    vector<int> cardPoints1 = {2, 0, 3, 5, 4};\n    cout << \"Test Case 1: \" << maxScore(cardPoints1, 6) << endl;  // Expected output: 19\n\n    vector<int> cardPoints2 = {9, 7, 7, 6, 7, 1, 3, 5};\n    cout << \"Test Case 2: \" << maxScore(cardPoints2, 2) << endl;  // Expected output: 28\n\n    vector<int> cardPoints3 = {1, 1};\n    cout << \"Test Case 3: \" << maxScore(cardPoints3, 1) << endl;  // Expected output: 4\n    \n    return 0;\n}\n```",
  "1771": "```\n#include <iostream>\n#include <vector>\n\nint maxPalindrome(int n) {\n    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(n + 1));\n    int ans = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        for (int j = i; j <= n; j++) {\n            if (i == j) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = (i == j - 1 || s[i-1] == s[j]) ? dp[i-1][j-1] + 2 : 0;\n            }\n            \n            ans = std::max(ans, dp[i][j]);\n        }\n    }\n    \n    return ans;\n}\n\nint main() {\n    int n;\n    std::cout << \"Enter the value of n: \";\n    std::cin >> n;\n\n    std::string s;\n    std::cout << \"Enter the string: \";\n    std::cin >> s;\n\n    int result = maxPalindrome(n);\n    std::cout << \"Maximum length of palindrome is: \" << result << std::endl;\n\n    // Test case 1\n    n = 7;\n    s = \"babad\";\n    result = maxPalindrome(n);\n    std::cout << \"Maximum length of palindrome for 'babad' is: \" << result << std::endl;\n\n    // Test case 2\n    n = 3;\n    s = \"cbbd\";\n    result = maxPalindrome(n);\n    std::cout << \"Maximum length of palindrome for 'cbbd' is: \" << result << std::endl;\n\n    // Test case 3\n    n = 2;\n    s = \"a\";\n    result = maxPalindrome(n);\n    std::cout << \"Maximum length of palindrome for 'a' is: \" << result << std::endl;\n    \n    return 0;\n}\n```",
  "1772": "```\n#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> sortFeatures(vector<string>& features, vector<int>& prices) {\n        unordered_map<string, int> featurePrices;\n        for (int i = 0; i < features.size(); i++) {\n            featurePrices[features[i]] = prices[i];\n        }\n        \n        vector<string> result;\n        while (!featurePrices.empty()) {\n            string mostPopularFeature = \"\";\n            int maxPrice = 0;\n            for (auto it = featurePrices.begin(); it != featurePrices.end(); it++) {\n                if (it->second > maxPrice) {\n                    mostPopularFeature = it->first;\n                    maxPrice = it->second;\n                }\n            }\n            \n            result.push_back(mostPopularFeature);\n            featurePrices.erase(mostPopularFeature);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> features1 = {\"apple\", \"banana\", \"cherry\"};\n    vector<int> prices1 = {5, 3, 2};\n    vector<string> expected1 = {\"banana\", \"apple\", \"cherry\"};\n    vector<string> result1 = solution.sortFeatures(features1, prices1);\n    if (result1 != expected1) {\n        cout << \"Test case 1 failed\" << endl;\n    } else {\n        cout << \"Test case 1 passed\" << endl;\n    }\n\n    // Test case 2\n    vector<string> features2 = {\"peach\", \"grape\", \"kiwi\"};\n    vector<int> prices2 = {10, 8, 4};\n    vector<string> expected2 = {\"peach\", \"grape\", \"kiwi\"};\n    vector<string> result2 = solution.sortFeatures(features2, prices2);\n    if (result2 != expected2) {\n        cout << \"Test case 2 failed\" << endl;\n    } else {\n        cout << \"Test case 2 passed\" << endl;\n    }\n\n    // Test case 3\n    vector<string> features3 = {\"apple\", \"banana\"};\n    vector<int> prices3 = {5, 3};\n    vector<string> expected3 = {\"banana\", \"apple\"};\n    vector<string> result3 = solution.sortFeatures(features3, prices3);\n    if (result3 != expected3) {\n        cout << \"Test case 3 failed\" << endl;\n    } else {\n        cout << \"Test case 3 passed\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1773": "```\n#include <iostream>\n#include <vector>\n\nint countMatches(std::vector<std::vector<std::string>>& items, char conditionKey, char value) {\n    int count = 0;\n    for (const auto& item : items) {\n        if ((item[0][conditionKey] == value)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::vector<std::vector<std::string>> items = {{\"shirt\", \"blue\"}, {\"dress\", \"black\"}, {\"socks\", \"blue\"}};\n    char conditionKey = 'c';\n    char value = 'b';\n    \n    int result1 = countMatches(items, conditionKey, value);\n    std::cout << \"Test Case 1: \" << result1 << std::endl;\n\n    items = {{\"shirt\", \"white\"}, {\"dress\", \"black\"}, {\"socks\", \"red\"}};\n    conditionKey = 'c';\n    value = 'w';\n\n    int result2 = countMatches(items, conditionKey, value);\n    std::cout << \"Test Case 2: \" << result2 << std::endl;\n\n    items = {{\"shirt\", \"blue\"}, {\"dress\", \"black\"}, {\"socks\", \"blue\"}};\n    conditionKey = 'a';\n    value = 'b';\n\n    int result3 = countMatches(items, conditionKey, value);\n    std::cout << \"Test Case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1774": "```\n#include <iostream>\n#include <vector>\n\nint minCost(std::vector<int>& cost) {\n    int n = cost.size();\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n));\n    \n    for (int i = 0; i < n; i++) {\n        dp[i][i] = cost[i];\n    }\n    \n    for (int length = 2; length <= n; length++) {\n        for (int left = 0; length + left - 1 < n; left++) {\n            int right = left + length - 1;\n            \n            if (length == 2) {\n                dp[left][right] = std::min(cost[left] + cost[right], cost[left+1] + cost[right-1]);\n            } else {\n                dp[left][right] = std::numeric_limits<int>::max();\n                \n                for (int i = left; i <= right; i++) {\n                    int prevMin = (i == left) ? 0 : dp[left][i - 1];\n                    int nextMin = (i == right) ? 0 : dp[i + 1][right];\n                    int currCost = cost[i];\n                    \n                    if (prevMin + nextMin + currCost < dp[left][right]) {\n                        dp[left][right] = prevMin + nextMin + currCost;\n                    }\n                }\n            }\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> cost1({10,6,8,5});\n    std::cout << \"Minimum cost for test case 1: \" << minCost(cost1) << std::endl;\n    \n    // Test case 2\n    std::vector<int> cost2({3,1,4});\n    std::cout << \"Minimum cost for test case 2: \" << minCost(cost2) << std::endl;\n    \n    // Test case 3\n    std::vector<int> cost3({7,5,6,8,3,2,1});\n    std::cout << \"Minimum cost for test case 3: \" << minCost(cost3) << std::endl;\n    \n    return 0;\n}\n```",
  "1775": "```\n#include <iostream>\n#include <vector>\n\nint minOperations(std::vector<int>& nums) {\n    int n = nums.size();\n    int sum = 0;\n    for (int num : nums) {\n        sum += num;\n    }\n    \n    if (sum % 2 != 0) {\n        return -1;\n    }\n    \n    int target = sum / 2;\n    int operations = 0;\n    std::vector<int> count(10001, 0);\n    \n    for (int i : nums) {\n        count[i]++;\n    }\n    \n    for (int i = 1; i <= target; i++) {\n        if ((i % 2 == 0 && count[i] > 0) || (i % 2 != 0 && count[10000 - i] > 0)) {\n            operations += min(count[i], count[10000 - i]);\n            for (int j = i; j <= target; j++) {\n                if (j % 2 == 0 && j < 10001 && count[j] > 0) {\n                    operations++;\n                    count[j]--;\n                } else if (j % 2 != 0 && 10000 - j < 10001 && count[10000 - j] > 0) {\n                    operations++;\n                    count[10000 - j]--;\n                }\n            }\n        } else {\n            for (int i = target; i >= 1; i--) {\n                if ((i % 2 == 0 && count[i] > 0) || (i % 2 != 0 && count[10000 - i] > 0)) {\n                    operations += min(count[i], count[10000 - i]);\n                    for (int j = i; j >= 1; j--) {\n                        if (j % 2 == 0 && j < 10001 && count[j] > 0) {\n                            operations++;\n                            count[j]--;\n                        } else if (j % 2 != 0 && 10000 - j < 10001 && count[10000 - j] > 0) {\n                            operations++;\n                            count[10000 - j]--;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    \n    return operations;\n}\n\nint main() {\n    std::vector<int> test1 = {10,2,5};\n    std::cout << \"Test case 1: \" << minOperations(test1) << std::endl;\n\n    std::vector<int> test2 = {3,1,7,3};\n    std::cout << \"Test case 2: \" << minOperations(test2) << std::endl;\n\n    std::vector<int> test3 = {4,9,8};\n    std::cout << \"Test case 3: \" << minOperations(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1776": "```\n#include <iostream>\n#include <vector>\n\nint distanceTravelled(int dist, int hours) {\n    return dist / hours;\n}\n\nint maxStopTime(int pos, int speed, int totalTravelled) {\n    if (totalTravelled == 0) {\n        return -1;\n    }\n    return (pos + totalTravelled - 1) / speed;\n}\n\nint totalFuelForTrip(int target, vector<vector<int>>& trucks) {\n    int totalFuel = 0;\n    for (const auto& truck : trucks) {\n        int fuelPerHour = truck[0];\n        int hours = truck[1];\n        int travelled = min(target, hours * fuelPerHour);\n        totalFuel += travelled * fuelPerHour + max(0, target - travelled) * (fuelPerHour / distanceTravelled(fuelPerHour, hours));\n    }\n    return totalFuel;\n}\n\nint main() {\n    vector<vector<int>> trucks1 = {{10, 3}, {6, 4}};\n    cout << \"Test Case 1: \" << totalFuelForTrip(60, trucks1) << endl;\n\n    vector<vector<int>> trucks2 = {{5, 4}, {20, 2}};\n    cout << \"Test Case 2: \" << totalFuelForTrip(90, trucks2) << endl;\n\n    vector<vector<int>> trucks3 = {{30, 3}, {30, 1}};\n    cout << \"Test Case 3: \" << totalFuelForTrip(120, trucks3) << endl;\n    \n    return 0;\n}\n```",
  "1777": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct Store {\n    string name;\n    double price;\n};\n\nclass Solution {\npublic:\n    vector<vector<string>> productPrice(vector<string> prices) {\n        vector<vector<string>> result;\n        for (int i = 0; i < prices.size(); i += 2) {\n            vector<string> storePrices;\n            storePrices.push_back(prices[i]);\n            storePrices.push_back(to_string(stod(prices[i + 1]) * stod(prices[i])));\n            result.push_back(storePrices);\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<string> prices1 = {\"store1\",\"2.0\"};\n    vector<vector<string>> result1 = solution.productPrice(prices1);\n    for (auto &row : result1) {\n        for (const string &cell : row) {\n            cout << cell << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    vector<string> prices2 = {\"store2\",\"3.5\", \"store3\",\"4.0\"};\n    vector<vector<string>> result2 = solution.productPrice(prices2);\n    for (auto &row : result2) {\n        for (const string &cell : row) {\n            cout << cell << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    vector<string> prices3 = {\"store4\",\"1.0\", \"store5\",\"2.5\", \"store6\",\"3.5\"};\n    vector<vector<string>> result3 = solution.productPrice(prices3);\n    for (auto &row : result3) {\n        for (const string &cell : row) {\n            cout << cell << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1778": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint shortestPath(vector<vector<int>>& hidden) {\n    int m = hidden.size(), n = hidden[0].size();\n    vector<vector<bool>> visited(m, vector<bool>(n));\n    \n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (!visited[i][j]) {\n                int dist = bfs(hidden, visited, i, j);\n                if (dist == -1) return -1;\n                maxDist = max(maxDist, dist);\n            }\n        }\n    }\n    \n    return maxDist;\n}\n\nint bfs(vector<vector<int>>& hidden, vector<vector<bool>>& visited, int x, int y) {\n    int m = hidden.size(), n = hidden[0].size();\n    queue<pair<int, int>> q;\n    q.push({x, y});\n    visited[x][y] = true;\n    \n    int dist = 0;\n    while (!q.empty()) {\n        int size = q.size();\n        for (int i = 0; i < size; i++) {\n            pair<int, int> p = q.front(); q.pop();\n            if (hidden[p.first][p.second] == 1) return -1;\n            if (visited[m-1][n-1]) return dist + 1;\n            \n            for (int dx : {-1, 0, 1}) {\n                for (int dy : {-1, 0, 1}) {\n                    int nx = p.first + dx, ny = p.second + dy;\n                    if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny]) {\n                        q.push({nx, ny});\n                        visited[nx][ny] = true;\n                    }\n                }\n            }\n        }\n        dist++;\n    }\n    \n    return -1;\n}\n\nint main() {\n    vector<vector<int>> hidden1={{0,1,0},{1,1,1},{0,0,0}};\n    cout << \"Test Case 1: Expected output is 2. The actual output is: \" << shortestPath(hidden1) << endl;\n\n    vector<vector<int>> hidden2={{0,0,0},{1,1,0},{1,1,1}};\n    cout << \"Test Case 2: Expected output is -1. The actual output is: \" << shortestPath(hidden2) << endl;\n\n    vector<vector<int>> hidden3={{0,0,0,0,0},{0,1,0,1,0},{0,0,0,1,0},{0,1,0,1,0},{0,0,0,0,0}};\n    cout << \"Test Case 3: Expected output is -1. The actual output is: \" << shortestPath(hidden3) << endl;\n\n    return 0;\n}\n```",
  "1780": "```\n#include <iostream>\nusing namespace std;\n\nbool checkSumOfPowersThree(int num) {\n    for (int i = 0; ; i++) {\n        int sum = 0;\n        for (int j = 0; ; j++) {\n            if ((1 << j) > num) break;\n            sum += pow(3, i + j);\n        }\n        if (sum == num) return true;\n    }\n}\n\nint main() {\n    cout << boolalpha;\n    cout << \"Test case 1: \" << checkSumOfPowersThree(12) << endl; // Expected: true\n    cout << \"Test case 2: \" << checkSumOfPowersThree(45) << endl; // Expected: false\n    cout << \"Test case 3: \" << checkSumOfPowersThree(81) << endl; // Expected: true\n    return 0;\n}\n```",
  "1779": "```\n#include <iostream>\n#include <vector>\n\nint nearestValidPoint(std::vector<std::vector<int>>& points) {\n    int minDistance = INT_MAX;\n    int resultX = -1, resultY = -1;\n\n    for (int i = 0; i < points.size(); ++i) {\n        if (points[i][0] == 0 || points[i][1] == 0 || points[i][0] >= 1000 || points[i][1] >= 1000) {\n            int dx = std::abs(points[i][0]);\n            int dy = std::abs(points[i][1]);\n\n            if (dx + dy < minDistance) {\n                minDistance = dx + dy;\n                resultX = points[i][0];\n                resultY = points[i][1];\n            }\n        }\n    }\n\n    return resultX == -1 ? -1 : (resultY == -1 ? 0 : 1);\n}\n\nint main() {\n    std::vector<std::vector<int>> points1 {{3,1},{5,-1},{4,0}};\n    int x1 = nearestValidPoint(points1);\n    if (x1 != -1) {\n        std::cout << \"For points1, the point with same coordinate as point (\" << 3 << \",\" << 1 << \") is (\" << x1 << \",\" << (x1 == 3 ? 1 : 0) << \").\" << std::endl;\n    } else {\n        std::cout << \"No valid points found in points1.\" << std::endl;\n    }\n\n    std::vector<std::vector<int>> points2 {{1,4},{4,-3},{5,6}};\n    int x2 = nearestValidPoint(points2);\n    if (x2 != -1) {\n        std::cout << \"For points2, the point with same coordinate as point (\" << 1 << \",\" << 4 << \") is (\" << x2 << \",\" << (x2 == 1 ? 4 : 0) << \").\" << std::endl;\n    } else {\n        std::cout << \"No valid points found in points2.\" << std::endl;\n    }\n\n    std::vector<std::vector<int>> points3 {{5,4},{9,6}};\n    int x3 = nearestValidPoint(points3);\n    if (x3 != -1) {\n        std::cout << \"For points3, the point with same coordinate as point (\" << 5 << \",\" << 4 << \") is (\" << x3 << \",\" << (x3 == 5 ? 4 : 0) << \").\" << std::endl;\n    } else {\n        std::cout << \"No valid points found in points3.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1781": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int beautySum(string str) {\n        int res = 0;\n        for (int i = 0; i < str.length(); i++) {\n            int minChar = 'z', maxChar = 'a';\n            for (int j = i; j < str.length(); j++) {\n                minChar = min(minChar, str[j]);\n                maxChar = max(maxChar, str[j]);\n                res += maxChar - minChar;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution s;\n    cout << \"Test Case 1: \" << s.beautySum(\"aabba\") << endl; // Expected output: 10\n    cout << \"Test Case 2: \" << s.beautySum(\"leetcode\") << endl; // Expected output: 36\n    cout << \"Test Case 3: \" << s.beautySum(\"aabbccc\") << endl; // Expected output: 23\n    return 0;\n}\n```",
  "1782": "```\n#include <iostream>\n#include <vector>\n\nint findPairs(std::vector<int>& nums1, std::vector<int>& nums2) {\n    int i = 0, j = 0;\n    int count = 0;\n    \n    while (i < nums1.size() && j < nums2.size()) {\n        if (nums1[i] == nums2[j]) {\n            count++;\n            i++;\n            j++;\n        } else if (nums1[i] < nums2[j]) {\n            i++;\n        } else {\n            j++;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 3, 4};\n    std::vector<int> nums2 = {5, 6, 7, 8};\n    int result1 = findPairs(nums1, nums2);\n    std::cout << \"Test case 1: Number of pairs is \" << result1 << std::endl;\n\n    nums1.clear();\n    nums1 = {0, 3, 4, 9};\n    nums2.clear();\n    nums2 = {1, 2, 8, 10};\n    int result2 = findPairs(nums1, nums2);\n    std::cout << \"Test case 2: Number of pairs is \" << result2 << std::endl;\n\n    nums1.clear();\n    nums1 = {0, 5, 7};\n    nums2.clear();\n    nums2 = {1, 3, 10};\n    int result3 = findPairs(nums1, nums2);\n    std::cout << \"Test case 3: Number of pairs is \" << result3 << std::endl;\n\n    return 0;\n}",
  "1783": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    int numberOfWays(std::vector<std::string> &result) {\n        int ans = 0;\n        for (int i = 0; i < result.size(); i++) {\n            if (i % 4 == 0 || i % 4 == 1) {\n                ans += std::count(result[i].begin(), result[i].end(), 'F');\n            } else if (i % 4 == 2) {\n                ans += std::count(result[i].begin(), result[i].end(), 'W');\n            } else if (i % 4 == 3) {\n                ans += std::count(result[i].begin(), result[i].end(), 'U');\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::string> result1 = {\"F\",\"W\"};\n    int output1 = solution.numberOfWays(result1);\n    if (output1 == 2) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected 2, got \" << output1 << \".\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::string> result2 = {\"F\",\"W\",\"U\"};\n    int output2 = solution.numberOfWays(result2);\n    if (output2 == 3) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected 3, got \" << output2 << \".\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::string> result3 = {\"F\",\"W\",\"U\",\"F\"};\n    int output3 = solution.numberOfWays(result3);\n    if (output3 == 4) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected 4, got \" << output3 << \".\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1784": "```\n#include <iostream>\n#include <string>\n\nbool hasAtMostOneSegmentOfOnes(std::string binaryString) {\n    int onesCount = 0;\n    for (char c : binaryString) {\n        if (c == '1') {\n            onesCount++;\n            if (onesCount > 1) return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << hasAtMostOneSegmentOfOnes(\"100\") << \"\\n\"; // Expected: true\n    std::cout << hasAtMostOneSegmentOfOnes(\"10101\") << \"\\n\"; // Expected: false\n    std::cout << hasAtMostOneSegmentOfOnes(\"1111\") << \"\\n\"; // Expected: false\n    return 0;\n}\n```",
  "1785": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint minElements(std::vector<int>& arr, int sum) {\n    std::sort(arr.begin(), arr.end());\n    int res = 0;\n    int i = 0, j = arr.size() - 1;\n    \n    while (i <= j && sum > 0) {\n        if (arr[i] + arr[j] <= sum) {\n            sum -= arr[i] + arr[j];\n            res += 2;\n            i++;\n            j--;\n        } else {\n            sum -= arr[j];\n            res++;\n            j--;\n        }\n    }\n    \n    while (i <= j && sum > 0) {\n        if (sum >= arr[i]) {\n            sum -= arr[i];\n            res++;\n            i++;\n        } else {\n            break;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> arr1 = {1, 2, 3, 4};\n    int res1 = minElements(arr1, 6);\n    std::cout << \"Test case 1: \" << res1 << \"\\n\";\n    \n    std::vector<int> arr2 = {5, 10, 20};\n    int res2 = minElements(arr2, 15);\n    std::cout << \"Test case 2: \" << res2 << \"\\n\";\n    \n    std::vector<int> arr3 = {1, 4, 7, 8};\n    int res3 = minElements(arr3, 12);\n    std::cout << \"Test case 3: \" << res3 << \"\\n\";\n    \n    return 0;\n}\n```",
  "1786": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPaths(int n, vector<vector<int>>& roads) {\n        vector<vector<pair<int, int>>> graph(n);\n        for (int i = 0; i < roads.size(); i++) {\n            graph[roads[i][0]].push_back({roads[i][1], 1});\n            graph[roads[i][1]].push_back({roads[i][0], 1});\n        }\n        \n        vector<int> in_degree(n, 0);\n        for (int i = 0; i < n; i++) {\n            for (auto& edge : graph[i]) {\n                in_degree[edge.first]++;\n            }\n        }\n        \n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (in_degree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        int res = 0, count = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            res += in_degree[node];\n            for (auto& edge : graph[node]) {\n                in_degree[edge.first]--;\n                if (in_degree[edge.first] == 0) {\n                    q.push(edge.first);\n                }\n            }\n        }\n        \n        return min(res, n - 1);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    int n = 7;\n    vector<vector<int>> roads = {{0, 1}, {1, 2}, {2, 3}, {4, 5}};\n    cout << \"Test Case 1: \" << solution.countPaths(n, roads) << endl; // Expected Output: 4\n    \n    // Test Case 2\n    n = 7;\n    roads = {{0, 1}, {1, 2}, {3, 2}, {5, 4}};\n    cout << \"Test Case 2: \" << solution.countPaths(n, roads) << endl; // Expected Output: 3\n    \n    // Test Case 3\n    n = 8;\n    roads = {{0, 1}, {1, 2}, {2, 3}, {4, 5}, {6, 7}};\n    cout << \"Test Case 3: \" << solution.countPaths(n, roads) << endl; // Expected Output: 7\n    \n    return 0;\n}\n```",
  "1787": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool movesToEqual(vector<int>& nums) {\n        int xorAll = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            int xorLeft = 0;\n            for (int j = 0; j <= i; j++) {\n                xorLeft ^= nums[j];\n            }\n            int xorRight = 0;\n            for (int k = i + 1; k < nums.size(); k++) {\n                xorRight ^= nums[k];\n            }\n            if (xorAll != 0) {\n                return false;\n            }\n            xorAll = xorLeft ^ xorRight;\n        }\n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<int> test1 = {0,1};\n    cout << \"Test case 1: \" << (solution.movesToEqual(test1) ? \"True\" : \"False\") << endl;\n\n    vector<int> test2 = {0,1,0};\n    cout << \"Test case 2: \" << (solution.movesToEqual(test2) ? \"True\" : \"False\") << endl;\n\n    vector<int> test3 = {0};\n    cout << \"Test case 3: \" << (solution.movesToEqual(test3) ? \"True\" : \"False\") << endl;\n    \n    return 0;\n}\n```",
  "1788": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumBeauty(vector<vector<int>>& flowers) {\n        int n = flowers.size();\n        vector<vector<int>> dp(n, vector<int>(n));\n        for (int i = 0; i < n; ++i) {\n            for (int j = i; j < n; ++j) {\n                if (i == 0) {\n                    dp[i][j] = flowers[i][1];\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], flowers[i][2] + (j > i ? dp[i - 1][j - 1] : 0));\n                }\n            }\n        }\n        return dp.back().back();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1:\n    vector<vector<int>> test1 = {{1,2,3},{4,5,6}};\n    cout << \"Test case 1: \" << solution.maximumBeauty(test1) << endl;  // Expected output: 6\n\n    // Test case 2:\n    vector<vector<int>> test2 = {{1,2,3},{4,5,6},{7,8,9}};\n    cout << \"Test case 2: \" << solution.maximumBeauty(test2) << endl;  // Expected output: 9\n\n    // Test case 3:\n    vector<vector<int>> test3 = {{1,2,3},{4,5,10},{11,12,13},{14,15,16}};\n    cout << \"Test case 3: \" << solution.maximumBeauty(test3) << endl;  // Expected output: 16\n\n    return 0;\n}\n```",
  "1789": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nclass Employee {\npublic:\n    int id;\n    std::string name;\n    int departmentId;\n};\n\nstd::vector<Employee> getDepartmentForEachEmployee(std::vector<Employee> employees) {\n    unordered_map<int, vector<int>> employeeDepartments;\n\n    for (const auto& employee : employees) {\n        employeeDepartments[employee.id].push_back(employee.departmentId);\n    }\n\n    std::vector<std::pair<int, int>> result;\n    for (auto it = employeeDepartments.begin(); it != employeeDepartments.end(); ++it) {\n        if (it->second.size() == 1) {\n            result.push_back({it->first, it->second[0]});\n        }\n    }\n\n    return employees;\n}\n\nint main() {\n    vector<Employee> employees = {{1, \"John\", 2}, {2, \"Jane\", 3}, {3, \"Joe\", 4}, {4, \"Jen\", 2}};\n    vector<Employee> result = getDepartmentForEachEmployee(employees);\n\n    for (const auto& employee : result) {\n        cout << \"Employee ID: \" << employee.id << \", Department ID: \" << employee.departmentId << endl;\n    }\n\n    return 0;\n}\n\n```",
  "1790": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nbool areAlmostEqual(string s1, string s2) {\n    if (s1.size() != s2.size()) return false;\n    \n    unordered_map<char, int> countMap1, countMap2;\n    for (int i = 0; i < s1.size(); i++) {\n        countMap1[s1[i]]++;\n        countMap2[s2[i]]++;\n    }\n    \n    for (auto& pair : countMap1) {\n        if (pair.second != pair.second - 1) return false;\n    }\n    \n    for (auto& pair : countMap2) {\n        if (pair.second != pair.second + 1) return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    cout << boolalpha;\n    cout << areAlmostEqual(\"bank\", \"kanb\") << endl; // Expected: true\n    cout << areAlmostEqual(\"teacher\", \"cheater\") << endl; // Expected: true\n    cout << areAlmostEqual(\"hello\", \"world\") << endl; // Expected: false\n}\n```",
  "1791": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findCenter(vector<vector<int>>& edges) {\n        unordered_map<int, int> degree;\n        for (const auto& edge : edges) {\n            degree[edge[0]]++;\n            degree[edge[1]]++;\n        }\n        for (const auto& pair : degree) {\n            if (pair.second == 4) return pair.first;\n        }\n        return -1; // Should not happen\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> edges1 = {{0, 1}, {2, 3}};\n    cout << \"Test case 1: \" << solution.findCenter(edges1) << endl;\n    \n    vector<vector<int>> edges2 = {{0, 1}, {1, 2}, {2, 0}, {2, 4}, {4, 5}};\n    cout << \"Test case 2: \" << solution.findCenter(edges2) << endl;\n\n    vector<vector<int>> edges3 = {{1, 2}, {2, 3}, {4, 5}, {5, 6}};\n    cout << \"Test case 3: \" << solution.findCenter(edges3) << endl;\n    \n    return 0;\n}\n```",
  "1793": "```\n#include <iostream>\n#include <vector>\n\nint maxGoodSubarray(std::vector<int>& nums) {\n    int left = 0;\n    int right = 0;\n    int maxScore = 0;\n    while (right < nums.size()) {\n        if (nums[right] >= nums[left]) {\n            right++;\n        } else {\n            left++;\n        }\n        if (right - left > 1) {\n            maxScore = std::max(maxScore, right - left);\n        }\n    }\n    return maxScore;\n}\n\nint main() {\n    int testCases = 3;\n    for (int i = 0; i < testCases; i++) {\n        std::vector<int> nums;\n        if (i == 0) {\n            nums = {2,1,5,3,4};\n        } else if (i == 1) {\n            nums = {1,6,1};\n        } else if (i == 2) {\n            nums = {2,1,17,5,18,11,15};\n        }\n        int result = maxGoodSubarray(nums);\n        std::cout << \"Test Case \" << i << \": \" << result << std::endl;\n    }\n    return 0;\n}\n```",
  "1792": "```\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    double maxAverageRatio(vector<vector<int>>& passingGrade, vector<vector<int>>& totalTest) {\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n        for (int i = 0; i < passingGrade.size(); ++i) {\n            int ratio = (passingGrade[i][1] * 100 + totalTest[i][1]) / (totalTest[i][1]);\n            pq.push({ratio, i});\n        }\n        double ans = 0;\n        while (!pq.empty()) {\n            auto [ratio, idx] = pq.top();\n            pq.pop();\n            passingGrade[idx][1]++;\n            int newRatio = (passingGrade[idx][1] * 100 + totalTest[idx][1]) / (totalTest[idx][1]);\n            pq.push({newRatio, idx});\n            ans += (double)newRatio;\n        }\n        return ans / passingGrade.size();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<int>> passingGrade1 = {{100, 500}, {200, 300}};\n    vector<vector<int>> totalTest1 = {{750, 375}, {2500, 1250}};\n    cout << \"Test Case 1: \" << solution.maxAverageRatio(passingGrade1, totalTest1) << endl;\n\n    // Test Case 2\n    vector<vector<int>> passingGrade2 = {{1000, 5000}, {2000, 3000}};\n    vector<vector<int>> totalTest2 = {{7500, 3750}, {25000, 12500}};\n    cout << \"Test Case 2: \" << solution.maxAverageRatio(passingGrade2, totalTest2) << endl;\n\n    // Test Case 3\n    vector<vector<int>> passingGrade3 = {{1, 1}, {10, 5}};\n    vector<vector<int>> totalTest3 = {{6, 3}, {15, 7}};\n    cout << \"Test Case 3: \" << solution.maxAverageRatio(passingGrade3, totalTest3) << endl;\n\n    return 0;\n}\n```",
  "1794": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int equalSubstring(string s, string t, int minLen) {\n        int n = s.size();\n        vector<int> seen(256, -1);\n        int res = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (s[i] == t[i]) continue;\n            \n            int j = i + minLen - 1;\n            while (j >= 0 && s[j] != t[j]) j--;\n            \n            int len = i - j;\n            if (len > res) res = len;\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << solution.equalSubstring(\"abac\", \"cabca\", 3) << endl; // Expected: 1\n    cout << solution.equalSubstring(\"abcd\", \"badc\", 2) << endl; // Expected: 4\n    cout << solution.equalSubstring(\"a\", \"a\", 5) << endl; // Expected: 5\n    \n    return 0;\n}\n```",
  "1796": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nint atMostNGoceros(std::string s) {\n    std::unordered_map<char, int> freq;\n    for (char c : s) {\n        if (isdigit(c)) {\n            freq[c]++;\n        }\n    }\n\n    int max = 0, secondMax = -1;\n    for (auto it = freq.begin(); it != freq.end(); ++it) {\n        if (it->second > max) {\n            secondMax = max;\n            max = it->second;\n        } else if (it->second == max && it->first < '9' + '0') {\n            secondMax = it->second;\n        }\n    }\n\n    return secondMax;\n}\n\nint main() {\n    std::cout << atMostNGoceros(\"leet2code\") << std::endl; // Output: 2\n    std::cout << atMostNGoceros(\"a1b2\") << std::endl; // Output: 2\n    std::cout << atMostNGoceros(\"0123456789\") << std::endl; // Output: 8\n\n    return 0;\n}\n```",
  "1795": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Solution {\npublic:\n    std::vector<std::string> rearrangeProducts(std::vector<std::pair<int, int>>& products) {\n        std::sort(products.begin(), products.end(), [](const auto& a, const auto& b) {\n            return (a.first * b.second - b.first * a.second);\n        });\n        std::vector<std::string> result;\n        for (const auto& product : products) {\n            result.push_back(std::to_string(product.first) + \" x \" + std::to_string(product.second));\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::pair<int, int>> products1 = {{1, 2}, {3, 4}};\n    for (const auto& product : solution.rearrangeProducts(products1)) {\n        std::cout << product << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test Case 2\n    std::vector<std::pair<int, int>> products2 = {{5, 6}, {7, 8}};\n    for (const auto& product : solution.rearrangeProducts(products2)) {\n        std::cout << product << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test Case 3\n    std::vector<std::pair<int, int>> products3 = {{1, 4}, {2, 5}, {3, 6}};\n    for (const auto& product : solution.rearrangeProducts(products3)) {\n        std::cout << product << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```",
  "1798": "```\n#include <iostream>\n#include <vector>\n\nint maxConsecutive(const std::vector<int>& nums) {\n    if (nums.empty()) return 0;\n    \n    int maxCount = 1, currCount = 1, prevVal = nums[0];\n    \n    for (int i = 1; i < nums.size(); ++i) {\n        if (nums[i] == prevVal + 1) {\n            currCount++;\n        } else {\n            maxCount = std::max(maxCount, currCount);\n            currCount = 1;\n        }\n        prevVal = nums[i];\n    }\n    \n    return std::max(maxCount, currCount);\n}\n\nint main() {\n    int result = maxConsecutive({2, 2, 3, 4, 5});\n    if (result == 5) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 5, Got: \" << result << std::endl;\n    }\n    \n    result = maxConsecutive({1, 2, 3});\n    if (result == 3) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 3, Got: \" << result << std::endl;\n    }\n    \n    result = maxConsecutive({0, 1, 2, 4});\n    if (result == 3) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 3, Got: \" << result << std::endl;\n    }\n    \n    return 0;\n}\n```",
  "1797": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass AuthenticationManager {\npublic:\n    AuthenticationManager(int timeToLive) : timeToLive(timeToLive), head(nullptr), tail(nullptr) {}\n\n    void generateToken(int userId, int currentTime) {\n        Node* newNode = new Node(userId, currentTime);\n        if (head == nullptr) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            tail->next = newNode;\n            newNode->prev = tail;\n            tail = newNode;\n        }\n    }\n\n    string getTimestamp(int userId) {\n        Node* node = head;\n        while (node != nullptr) {\n            if (node->userId == userId) {\n                int timeElapsed = currentTime() - node->currentTime;\n                if (timeElapsed <= timeToLive) {\n                    return to_string(node->currentTime);\n                } else {\n                    removeNode(node);\n                }\n            }\n            node = node->next;\n        }\n        return \"\";\n    }\n\nprivate:\n    struct Node {\n        int userId;\n        int currentTime;\n        Node* next;\n        Node* prev;\n        Node(int userId, int currentTime) : userId(userId), currentTime(currentTime), next(nullptr), prev(nullptr) {}\n    };\n\n    int timeToLive;\n    Node* head;\n    Node* tail;\n\n    void removeNode(Node* node) {\n        if (node->prev != nullptr) {\n            node->prev->next = node->next;\n        } else {\n            head = node->next;\n        }\n        if (node->next != nullptr) {\n            node->next->prev = node->prev;\n        } else {\n            tail = node->prev;\n        }\n        delete node;\n    }\n\n    int currentTime() {\n        // This is a placeholder for the current time, you should implement it based on your system clock\n        return 1643723400; \n    }\n};\n\nint main() {\n    AuthenticationManager manager(60); // Create an authentication manager with a timeToLive of 1 minute\n\n    // Test case 1: Generate token and get timestamp within the timeToLive\n    int userId = 1;\n    int currentTime = 1643723400; // Current time in seconds\n    manager.generateToken(userId, currentTime);\n    cout << \"Test case 1: Expected \" << to_string(currentTime) << \", got \" << manager.getTimestamp(userId) << endl;\n\n    // Test case 2: Generate token and get timestamp after the timeToLive has passed\n    int userId2 = 2;\n    int currentTime2 = 1643724000; // Current time in seconds, 1 minute later than previous test\n    manager.generateToken(userId2, currentTime2);\n    cout << \"Test case 2: Expected \"\", got \" << manager.getTimestamp(userId2) << endl;\n\n    // Test case 3: Generate token and get timestamp within the timeToLive after some time has passed\n    int userId3 = 3;\n    int currentTime3 = 1643724200; // Current time in seconds, 20 seconds later than previous test\n    manager.generateToken(userId3, currentTime3);\n    cout << \"Test case 3: Expected \" << to_string(currentTime2) << \", got \" << manager.getTimestamp(userId3) << endl;\n\n    return 0;\n}\n```",
  "1799": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxSumRangeQuery(int* distances, int n, int* preference) {\n        vector<int> dist, pref;\n        for (int i = 0; i < n; i++) {\n            dist.push_back(distances[i]);\n            pref.push_back(preference[i]);\n        }\n        sort(dist.begin(), dist.end());\n        sort(pref.begin(), pref.end(), [](int a, int b) {return a > b;});\n        \n        long long sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += dist[i] * pref[i];\n        }\n        return (int)(sum % 1000000007);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int distances1[] = {2,5,4};\n    int preference1[] = {3,4,5};\n    cout << \"Test case 1: \" << solution.maxSumRangeQuery(distances1, 3, preference1) << endl;\n    \n    // Test case 2\n    int distances2[] = {7,8,9};\n    int preference2[] = {6,5,4};\n    cout << \"Test case 2: \" << solution.maxSumRangeQuery(distances2, 3, preference2) << endl;\n\n    // Test case 3\n    int distances3[] = {1,3,4};\n    int preference3[] = {3,2,3};\n    cout << \"Test case 3: \" << solution.maxSumRangeQuery(distances3, 3, preference3) << endl;\n    \n    return 0;\n}\n```",
  "1800": "```\n#include <iostream>\n#include <vector>\n\nint maxAscSubArraySum(std::vector<int>& nums) {\n    int maxSum = 0;\n    int currSum = 0;\n\n    for (int i = 0; i < nums.size(); i++) {\n        if (i == 0 || nums[i] >= nums[i - 1]) {\n            currSum += nums[i];\n        } else {\n            maxSum = std::max(maxSum, currSum);\n            currSum = nums[i];\n        }\n    }\n\n    return std::max(maxSum, currSum);\n}\n\nint main() {\n    std::vector<int> test1 = {10, 9, 2, 5, 3, 7, 101};\n    int result1 = maxAscSubArraySum(test1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<int> test2 = {0, 1, 1, 0, 1, 0, 1};\n    int result2 = maxAscSubArraySum(test2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<int> test3 = {-7, 1, 5, 3, 4, 2, 3};\n    int result3 = maxAscSubArraySum(test3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}",
  "1801": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nclass Solution {\npublic:\n    int getOrders(std::vector<int>& orders) {\n        std::priority_queue<int> pq;\n        for (int order : orders) {\n            pq.push(order);\n        }\n        \n        int count = 0;\n        while (!pq.empty()) {\n            int maxOrder = pq.top();\n            pq.pop();\n            while (!pq.empty() && pq.top() == maxOrder) {\n                pq.pop();\n            }\n            count += maxOrder;\n        }\n        \n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    std::vector<int> orders1 = {10, 6, 1000};\n    std::cout << \"Test Case 1: \" << solution.getOrders(orders1) << std::endl;\n\n    std::vector<int> orders2 = {3, 7, 5, 2, 4, 1, 5, 2};\n    std::cout << \"Test Case 2: \" << solution.getOrders(orders2) << std::endl;\n\n    std::vector<int> orders3 = {};\n    std::cout << \"Test Case 3: \" << solution.getOrders(orders3) << std::endl;\n    \n    return 0;\n}\n```",
  "1802": "```\n#include <iostream>\n#include <vector>\n\nint maxValueAtIndex(std::vector<int>& nums, int index) {\n    int low = 0, high = (1 << 20);\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (index >= (nums.size() - 1) * mid) {\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return nums[index];\n}\n\nint main() {\n    std::vector<int> nums1 = {3, 3, 5, 8};\n    int index1 = 2;\n    std::cout << \"Test case 1: \" << maxValueAtIndex(nums1, index1) << std::endl;\n\n    std::vector<int> nums2 = {10, 9, 8, 7};\n    int index2 = 3;\n    std::cout << \"Test case 2: \" << maxValueAtIndex(nums2, index2) << std::endl;\n\n    std::vector<int> nums3 = {1, 2, 3, 4};\n    int index3 = 0;\n    std::cout << \"Test case 3: \" << maxValueAtIndex(nums3, index3) << std::endl;\n\n    return 0;\n}\n```",
  "1803": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPairs(vector<int>& nums, int low, int high) {\n        int n = nums.size();\n        vector<int> count(32, 0);\n        for (int i = 0; i < n; i++) {\n            for (int j = 30; j >= 0; j--) {\n                if (((nums[i] >> j) & 1) == 0)\n                    count[j]++;\n                else\n                    count[j]--;\n            }\n        }\n        int res = 0;\n        for (int i = 0; i <= 30; i++) {\n            int val = (count[i] * (n - count[i])) + (count[i] * (count[i] - 1)) / 2;\n            if ((i >= low && i <= high) || (32 - i - 1 >= low && 32 - i - 1 <= high))\n                res += val;\n            else\n                res -= val;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> nums = {2,4};\n    int low = 3, high = 5;\n    cout << \"Test case 1: \" << solution.countPairs(nums, low, high) << endl;\n\n    nums = {8,10,8};\n    low = 0; high = 9;\n    cout << \"Test case 2: \" << solution.countPairs(nums, low, high) << endl;\n\n    nums = {14,7,5};\n    low = 6; high = 7;\n    cout << \"Test case 3: \" << solution.countPairs(nums, low, high) << endl;\n\n    return 0;\n}\n```",
  "1804": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass TrieNode {\npublic:\n    char val;\n    bool isEndOfWord;\n    map<char, TrieNode*> children;\n\n    TrieNode(char c) : val(c), isEndOfWord(false) {}\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\npublic:\n    Trie() : root(new TrieNode('\\0')) {}\n\n    void insert(string word) {\n        TrieNode* node = root;\n        for (char c : word) {\n            if (!node->children.count(c)) {\n                node->children[c] = new TrieNode(c);\n            }\n            node = node->children[c];\n        }\n        node->isEndOfWord = true;\n    }\n\n    bool startsWith(string prefix) {\n        TrieNode* node = root;\n        for (char c : prefix) {\n            if (!node->children.count(c)) return false;\n            node = node->children[c];\n        }\n        return true;\n    }\n};\n\nint main() {\n    Trie trie;\n    trie.insert(\"apple\");\n    cout << trie.startsWith(\"app\") << endl; // true\n    trie.insert(\"app\");\n    cout << trie.startsWith(\"app\") << endl; // true\n\n    trie.insert(\"apples\");\n    cout << trie.startsWith(\"ap\") << endl; // true\n    cout << trie.startsWith(\"appl\") << endl; // true\n    cout << trie.startsWith(\"apple\") << endl; // true\n\n    trie.insert(\"banana\");\n    cout << trie.startsWith(\"bana\") << endl; // true\n    return 0;\n}\n```",
  "1805": "```\n#include <iostream>\n#include <string>\n#include <unordered_map>\n\nusing namespace std;\n\nint countDifferentIntegers(string s) {\n    unordered_map<char, int> map;\n    int res = 0;\n    \n    for (char c : s) {\n        if (!map.count(c)) {\n            map[c] = 1;\n            res++;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    cout << countDifferentIntegers(\"a100\") << endl; // expected output: 2\n    cout << countDifferentIntegers(\"levego0\") << endl; // expected output: 3\n    cout << countDifferentIntegers(\"123456\") << endl; // expected output: 6\n    \n    return 0;\n}\n```",
  "1806": "```\n#include <iostream>\n#include <vector>\n\nint reorganizationSteps(std::vector<int>& arr) {\n    int steps = 0;\n    for (int i = 1; i <= arr.size(); ++i) {\n        if (arr[i - 1] != i) {\n            ++steps;\n            std::swap(arr[i - 1], arr[arr[i - 1] - 1]);\n        }\n    }\n    return steps / 2;\n}\n\nint main() {\n    std::vector<int> arr1 = {1, 2};\n    std::cout << \"Test case 1: \" << reorganizationSteps(arr1) << std::endl;\n\n    std::vector<int> arr2 = {1, 3, 5};\n    std::cout << \"Test case 2: \" << reorganizationSteps(arr2) << std::endl;\n\n    std::vector<int> arr3 = {4, 2, 3, 5, 6};\n    std::cout << \"Test case 3: \" << reorganizationSteps(arr3) << std::endl;\n    \n    return 0;\n}",
  "1807": "```\n#include <iostream>\n#include <string>\n#include <stack>\n#include <vector>\n\nbool areBracketPairsValid(std::string s) {\n    std::stack<char> stack;\n    for (char c : s) {\n        if (c == '(') {\n            stack.push(')');\n        } else if (!stack.empty() && stack.top() == ')') {\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n\nint main() {\n    std::vector<std::string> testCases = {\"((()))\", \"(()())(())\", \"(())\"};\n    for (const auto& testCase : testCases) {\n        if (areBracketPairsValid(testCase)) {\n            std::cout << \"Test case: \" << testCase << \" is valid.\\n\";\n        } else {\n            std::cout << \"Test case: \" << testCase << \" is not valid.\\n\";\n        }\n    }\n    return 0;\n}\n```",
  "1808": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumNiceDivisors(int n) {\n        if (n == 0)\n            return 1;\n        \n        vector<int> dp(n + 1, 0);\n        dp[2] = 1;\n        for (int i = 3; i <= n; i++) {\n            if ((i & 1) != 0)\n                dp[i] = max(dp[i / 2], 1);\n            else\n                dp[i] = max((dp[i / 2] + 1), 1);\n        }\n        \n        return dp[n];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << \"Test Case 1: \" << solution.maximumNiceDivisors(7) << endl; // Expected output: 4\n    cout << \"Test Case 2: \" << solution.maximumNiceDivisors(10) << endl; // Expected output: 6\n    cout << \"Test Case 3: \" << solution.maximumNiceDivisors(12) << endl; // Expected output: 8\n    \n    return 0;\n}\n```",
  "1809": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int getWatchedVideos(std::vector<std::vector<int>>& watchedVideoIds) {\n        int maxDuration = 0;\n        for (auto& video : watchedVideoIds) {\n            maxDuration = std::max(maxDuration, video.size());\n        }\n        \n        return maxDuration;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> watchedVideoIds1 = {{1, 2, 3}, {4, 5, 6}};\n    int result1 = solution.getWatchedVideos(watchedVideoIds1);\n    if (result1 == 3) {\n        std::cout << \"Test case 1 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed: expected 3, got \" << result1 << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::vector<int>> watchedVideoIds2 = {{7, 8}, {9, 10, 11}};\n    int result2 = solution.getWatchedVideos(watchedVideoIds2);\n    if (result2 == 3) {\n        std::cout << \"Test case 2 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed: expected 3, got \" << result2 << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::vector<int>> watchedVideoIds3 = {{12}};\n    int result3 = solution.getWatchedVideos(watchedVideoIds3);\n    if (result3 == 1) {\n        std::cout << \"Test case 3 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed: expected 1, got \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1810": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minPathCost(vector<vector<int>>& hiddenGrid, vector<vector<int>>& obstacles) {\n        int m = hiddenGrid.size(), n = hiddenGrid[0].size();\n        vector<vector<int>> cost(m, vector<int>(n));\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!obstacles[i][j]) {\n                    if (i > 0 && !obstacles[i-1][j])\n                        cost[i][j] += cost[i-1][j];\n                    if (j > 0 && !obstacles[i][j-1])\n                        cost[i][j] += cost[i][j-1];\n                }\n            }\n        }\n        \n        return *min_element(cost[m-1].begin(), cost[m-1].end());\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> hiddenGrid1 = {{0,0,0},{4,2,0},{0,5,0}};\n    vector<vector<int>> obstacles1 = {{false,false,false},{true,false,true},{false,false,false}};\n    cout << \"Test case 1: \" << solution.minPathCost(hiddenGrid1, obstacles1) << endl;\n    \n    // Test case 2\n    vector<vector<int>> hiddenGrid2 = {{0,3,0},{5,4,0},{0,2,0}};\n    vector<vector<int>> obstacles2 = {{false,false,true},{true,false,false},{false,false,false}};\n    cout << \"Test case 2: \" << solution.minPathCost(hiddenGrid2, obstacles2) << endl;\n    \n    // Test case 3\n    vector<vector<int>> hiddenGrid3 = {{0,0,0,8,0},{0,5,0,3,0},{0,2,0,1,0},{7,0,6,4,0}};\n    vector<vector<int>> obstacles3 = {{false,false,false,false,false},{true,false,false,false,true},{false,false,false,false,false},{false,false,false,false,false}};\n    cout << \"Test case 3: \" << solution.minPathCost(hiddenGrid3, obstacles3) << endl;\n    \n    return 0;\n}\n```",
  "1811": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> findInterviewCandidates(vector<vector<string>>& questions) {\n        map<string, set<string>> candidates;\n        \n        for (const auto& question : questions) {\n            string interviewer = question[0];\n            string candidate = question[1];\n            \n            if (!candidates.count(interviewer)) {\n                candidates[interviewer] = set<string>();\n            }\n            candidates[interviewer].insert(candidate);\n        }\n        \n        vector<vector<string>> result;\n        for (const auto& pair : candidates) {\n            vector<string> interviewers;\n            interviewers.push_back(pair.first);\n            \n            for (const auto& candidate : pair.second) {\n                interviewers.push_back(candidate);\n            }\n            \n            result.push_back(interviewers);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> questions1 = {{\"Kho\", \"Alice\"}, {\"Kho\", \"Bob\"}, {\"Kho\", \"Charlie\"}};\n    vector<vector<string>> expected1 = {{\"Kho\", \"Alice\", \"Bob\", \"Charlie\"}};\n    vector<vector<string>> result1 = solution.findInterviewCandidates(questions1);\n    if (result1 == expected1) {\n        cout << \"Test case 1 passed.\" << endl;\n    } else {\n        cout << \"Test case 1 failed.\" << endl;\n    }\n\n    // Test case 2\n    vector<vector<string>> questions2 = {{\"John\", \"Emma\"}, {\"Jane\", \"Olivia\"}};\n    vector<vector<string>> expected2 = {{\"John\", \"Emma\"}, {\"Jane\", \"Olivia\"}};\n    vector<vector<string>> result2 = solution.findInterviewCandidates(questions2);\n    if (result1 == expected2) {\n        cout << \"Test case 2 passed.\" << endl;\n    } else {\n        cout << \"Test case 2 failed.\" << endl;\n    }\n\n    // Test case 3\n    vector<vector<string>> questions3 = {{\"Alice\", \"Bob\"}, {\"Bob\", \"Charlie\"}, {\"Charlie\", \"David\"}};\n    vector<vector<string>> expected3 = {{\"Alice\", \"Bob\", \"Charlie\", \"David\"}};\n    vector<vector<string>> result3 = solution.findInterviewCandidates(questions3);\n    if (result3 == expected3) {\n        cout << \"Test case 3 passed.\" << endl;\n    } else {\n        cout << \"Test case 3 failed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1812": "```\n#include <iostream>\n\nchar squareColor(int n) {\n    return (n % 2 == 0) ? 'B' : 'W';\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << squareColor(4) << std::endl; // Expecting 'B'\n    std::cout << \"Test Case 2: \" << squareColor(5) << std::endl; // Expecting 'W'\n    std::cout << \"Test Case 3: \" << squareColor(8) << std::endl; // Expecting 'B'\n\n    return 0;\n}\n```",
  "1814": "```\n#include <iostream>\n#include <vector>\n\nint atMostNGather(int n) {\n    return (n * (n + 1)) / 2;\n}\n\nint countNicePairs(std::vector<int>& nums) {\n    int res = 0, mod = 1000000007;\n    std::unordered_map<int, int> mp;\n\n    for (int num : nums) {\n        int niceNum = abs(num - (num / 10 * 10));\n        res = (res + mp[niceNum]) % mod;\n        mp[niceNum]++;\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<int> test1 = {2,4,6};\n    std::cout << \"Test case 1: \" << countNicePairs(test1) << std::endl;\n\n    std::vector<int> test2 = {4,3,5,7};\n    std::cout << \"Test case 2: \" << countNicePairs(test2) << std::endl;\n\n    std::vector<int> test3 = {1,1,2};\n    std::cout << \"Test case 3: \" << countNicePairs(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1813": "```\n#include <iostream>\n#include <vector>\n\nbool arrayStringsAreEqual(std::vector<std::string>& word1, std::vector<std::string>& word2) {\n    int i = 0, j = 0;\n    \n    while (i < word1.size() && j < word2.size()) {\n        if (word1[i] + word1[i+1] != word2[j] + word2[j+1])\n            return false;\n        i += 2; \n        j += 2;\n    }\n    \n    return (i == word1.size() && j == word2.size());\n}\n\nint main() {\n    std::vector<std::string> word1 = {\"abc\", \"pqr\", \"lwn\"};\n    std::vector<std::string> word2 = {\"abe\", \"pqry\", \"lwng\"};\n    \n    if (arrayStringsAreEqual(word1, word2)) \n        std::cout << \"Test case 1: Passed\\n\";\n    else\n        std::cout << \"Test case 1: Failed\\n\";\n    \n    word1.clear(); word2.clear();\n    word1.push_back(\"a\"); word1.push_back(\"b\"); word1.push_back(\"c\");\n    word2.push_back(\"a\"); word2.push_back(\"x\"); word2.push_back(\"y\");\n\n    if (arrayStringsAreEqual(word1, word2)) \n        std::cout << \"Test case 2: Passed\\n\";\n    else\n        std::cout << \"Test case 2: Failed\\n\";\n\n    word1.clear(); word2.clear();\n    word1.push_back(\"x\"); word1.push_back(\"a\");\n    word2.push_back(\"x\"); word2.push_back(\"a\");\n\n    if (arrayStringsAreEqual(word1, word2)) \n        std::cout << \"Test case 3: Passed\\n\";\n    else\n        std::cout << \"Test case 3: Failed\\n\";\n\n    return 0;\n}\n```",
  "1816": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nstd::vector<std::string> truncateSentence(std::vector<std::string>& sentence) {\n    std::vector<std::string> result;\n    for (const auto& word : sentence) {\n        int pos = 0;\n        while ((pos = word.find(' ')) != -1) {\n            if (++pos >= word.size()) break;\n            result.push_back(word.substr(0, pos));\n            word.erase(0, pos);\n        }\n        result.push_back(word);\n    }\n    return result;\n}\n\nint main() {\n    std::vector<std::string> sentence1 = {\"Hello   a\",\"alittle   extra\",\"space   on   each   side\"};\n    auto result1 = truncateSentence(sentence1);\n    for (const auto& word : result1) {\n        std::cout << word << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<std::string> sentence2 = {\"What     is      going\",\"on       with     you\"};\n    auto result2 = truncateSentence(sentence2);\n    for (const auto& word : result2) {\n        std::cout << word << \" \";\n    }\n    std::cout << \"\\n\";\n\n    std::vector<std::string> sentence3 = {\"Single   space\",\"between   words\"};\n    auto result3 = truncateSentence(sentence3);\n    for (const auto& word : result3) {\n        std::cout << word << \" \";\n    }\n    std::cout << \"\\n\";\n    return 0;\n}\n```",
  "1815": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxGroups(vector<int>& donuts) {\n        int n = donuts.size();\n        vector<vector<int>> dp(n + 1, vector<int>(1 << 20));\n        for (int i = 0; i <= n; ++i) {\n            dp[i][0] = 1;\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (1 << 20); ++j) {\n                if ((j & (1 << donuts[i])) == 0 || dp[i][j] == 0) continue;\n                for (int k = i + 1; k <= n; ++k) {\n                    int newBitmask = j | (1 << donuts[k]);\n                    dp[k][newBitmask] = max(dp[k][newBitmask], dp[i][j] + 1);\n                }\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i <= n; ++i) {\n            ans = max(ans, dp[i][(1 << donuts[i]) - 1]);\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> donuts1 = {2, 3};\n    cout << \"Test case 1: \" << solution.maxGroups(donuts1) << endl;\n\n    vector<int> donuts2 = {10, 6, 7, 8, 5};\n    cout << \"Test case 2: \" << solution.maxGroups(donuts2) << endl;\n\n    vector<int> donuts3 = {18, 15, 12, 9, 6, 3};\n    cout << \"Test case 3: \" << solution.maxGroups(donuts3) << endl;\n    \n    return 0;\n}\n```",
  "1818": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint minAbsoluteSumDiff(std::vector<int>& nums1, std::vector<int>& nums2) {\n    int n = nums1.size();\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end());\n\n    long long res = LLONG_MAX;\n    for (int i = 0; i < n; ++i) {\n        if (nums1[i] != nums2[i]) {\n            long long leftSum = i * 2 + std::abs(nums2[i] - nums1[i]);\n            long long rightSum = (n - i - 1) * 2 + std::abs(nums2[i] - (nums1[n-1] - nums1[i]));\n            res = std::min(res, leftSum + rightSum);\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> nums1_1 = {1, 3, 5};\n    std::vector<int> nums2_1 = {2, 4, 6};\n    int result_1 = minAbsoluteSumDiff(nums1_1, nums2_1);\n    std::cout << \"Test Case 1: \" << result_1 << std::endl;\n\n    std::vector<int> nums1_2 = {0, 10, 20, 40, 50};\n    std::vector<int> nums2_2 = {5, 5, 7, 38, 45};\n    int result_2 = minAbsoluteSumDiff(nums1_2, nums2_2);\n    std::cout << \"Test Case 2: \" << result_2 << std::endl;\n\n    std::vector<int> nums1_3 = {13, 26, 30, 31};\n    std::vector<int> nums2_3 = {8, 9, 20, 23};\n    int result_3 = minAbsoluteSumDiff(nums1_3, nums2_3);\n    std::cout << \"Test Case 3: \" << result_3 << std::endl;\n\n    return 0;\n}\n```",
  "1817": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findActiveMinutes(vector<vector<int>>& logs) {\n        unordered_map<int, int> active_minutes;\n        for (const auto& log : logs) {\n            int userId = log[0];\n            int minute = log[1];\n            if (!active_minutes.count(userId)) {\n                active_minutes[userId] = 0;\n            }\n            active_minutes[userId] = max(active_minutes[userId], minute);\n        }\n        vector<int> result;\n        for (const auto& pair : active_minutes) {\n            result.push_back(pair.second);\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> logs1 = {{0,0},{0,5},{0,10},{1,2},{1,6},{1,8}};\n    vector<int> expected1 = {3};\n    if (solution.findActiveMinutes(logs1) != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n        return -1;\n    }\n\n    // Test case 2\n    vector<vector<int>> logs2 = {{0,10},{1,5},{0,20}};\n    vector<int> expected2 = {2};\n    if (solution.findActiveMinutes(logs2) != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n        return -1;\n    }\n\n    // Test case 3\n    vector<vector<int>> logs3 = {{0,10},{1,5},{1,15}};\n    vector<int> expected3 = {2};\n    if (solution.findActiveMinutes(logs3) != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n        return -1;\n    }\n\n    cout << \"All test cases passed.\" << endl;\n    return 0;\n}\n```",
  "1819": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numFactoredBinaryTrees(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        vector<vector<pair<int, int>>> dp = {{{0, -1}}};\n        int res = 0;\n        for (int i : arr) {\n            int j = upper_bound(dp.back().back().first + 1, dp.back().end(), i) - dp.back().begin();\n            if (j < dp.size()) {\n                for (auto& it : dp[j]) {\n                    if (it.second == -1 && i % it.first == 0) {\n                        res += it.second;\n                        break;\n                    } else if (i / it.first * it.second == i) {\n                        res++;\n                        break;\n                    }\n                }\n            }\n            for (int k = dp.size(); k <= i; k++) {\n                dp.emplace_back();\n                for (auto& p : dp[k - 1]) {\n                    for (int j = 0; j < arr.size() && arr[j] % p.first == 0; j++) {\n                        if (arr[j] / p.first > p.second) {\n                            vector<pair<int, int>> &newP = dp.back();\n                            newP.push_back({p.first * arr[j], p.second});\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test Case 1: \";\n    vector<int> test1 = {2,4,16};\n    cout << solution.numFactoredBinaryTrees(test1) << endl;\n\n    cout << \"Test Case 2: \";\n    vector<int> test2 = {1000,50,30};\n    cout << solution.numFactoredBinaryTrees(test2) << endl;\n\n    cout << \"Test Case 3: \";\n    vector<int> test3 = {1,2,3,4,5,6,7,8,9,10};\n    cout << solution.numFactoredBinaryTrees(test3) << endl;\n    \n    return 0;\n}\n```",
  "1820": "```\n#include <iostream>\n#include <vector>\n\nint maximumAcceptedInvitations(std::vector<std::vector<int>>& times) {\n    int n = times.size();\n    std::vector<int> dp(n, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (times[i][j] != -1 && dp[j] + times[i][j] > dp[i]) {\n                dp[i] = dp[j] + times[i][j];\n            }\n        }\n    }\n    \n    int maxAccepted = 0;\n    for (int i = 0; i < n; ++i) {\n        maxAccepted = std::max(maxAccepted, dp[i]);\n    }\n    \n    return maxAccepted;\n}\n\nint main() {\n    // Test case 1\n    std::vector<std::vector<int>> times1 = {{1,4},{2,3},{5,4},{5,2}};\n    std::cout << \"Test case 1: \" << maximumAcceptedInvitations(times1) << std::endl;\n    \n    // Test case 2\n    std::vector<std::vector<int>> times2 = {{1,4},{2,3},{3,2},{4,5},{5,3},{6,7}};\n    std::cout << \"Test case 2: \" << maximumAcceptedInvitations(times2) << std::endl;\n    \n    // Test case 3\n    std::vector<std::vector<int>> times3 = {{1,2},{2,3},{3,4},{4,5},{5,6}};\n    std::cout << \"Test case 3: \" << maximumAcceptedInvitations(times3) << std::endl;\n    \n    return 0;\n}\n```",
  "1822": "```\n#include <iostream>\n#include <vector>\n\nint arraySign(std::vector<int>& nums) {\n    int sign = 1;\n    for (int num : nums) {\n        if (num > 0)\n            continue;\n        if (num < 0)\n            return 0;\n        else\n            sign = -sign;\n    }\n    return sign;\n}\n\nint main() {\n    std::vector<int> test1 = {-1,-2,-3,-4};\n    std::cout << \"Test Case 1: \" << arraySign(test1) << std::endl;\n\n    std::vector<int> test2 = {1,5,0,5};\n    std::cout << \"Test Case 2: \" << arraySign(test2) << std::endl;\n\n    std::vector<int> test3 = {-1,1,-12};\n    std::cout << \"Test Case 3: \" << arraySign(test3) << std::endl;\n\n    return 0;\n}",
  "1821": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findCustomers(vector<vector<string>> accounts) {\n        vector<string> result;\n        for (const auto& account : accounts) {\n            if (stod(account[3]) > 0.0) {\n                result.push_back(account[1]);\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> accounts1 = {{\"John\", \"123\", \"USD\", \"100.00\"}, {\"Jane\", \"456\", \"EUR\", \"-50.00\"}};\n    cout << \"[\";\n    for (const auto& customer : solution.findCustomers(accounts1)) {\n        cout << \"\\\"\" << customer << \"\\\"\";\n    }\n    cout << \"]\";\n\n    // Test case 2\n    vector<vector<string>> accounts2 = {{\"Alice\", \"789\", \"USD\", \"-20.00\"}, {\"Bob\", \"321\", \"EUR\", \"30.00\"}};\n    cout << endl;\n    cout << \"[\";\n    for (const auto& customer : solution.findCustomers(accounts2)) {\n        cout << \"\\\"\" << customer << \"\\\"\";\n    }\n    cout << \"]\";\n\n    // Test case 3\n    vector<vector<string>> accounts3 = {{\"Charlie\", \"901\", \"USD\", \"100.00\"}, {\"David\", \"902\", \"EUR\", \"-50.00\"}};\n    cout << endl;\n    cout << \"[\";\n    for (const auto& customer : solution.findCustomers(accounts3)) {\n        cout << \"\\\"\" << customer << \"\\\"\";\n    }\n    cout << \"]\";\n\n    return 0;\n}\n```",
  "1823": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findTheWinner(vector<int>& arr, int k) {\n        int n = arr.size();\n        vector<int> queue;\n        \n        for(int i = 0; i < n; i++) {\n            queue.push_back(arr[i]);\n        }\n        \n        while(queue.size() > 1) {\n            for(int i = 0; i < k - 1; i++) {\n                queue.push_back(queue.front());\n                queue.erase(queue.begin());\n            }\n            queue.erase(queue.begin());\n        }\n        \n        return queue[0];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> arr1 = {2, 1, 3, 5};\n    int k1 = 2;\n    cout << \"Test case 1: Winner is \" << solution.findTheWinner(arr1, k1) << endl;\n\n    // Test case 2\n    vector<int> arr2 = {2, 4, 6, 8};\n    int k2 = 3;\n    cout << \"Test case 2: Winner is \" << solution.findTheWinner(arr2, k2) << endl;\n\n    // Test case 3\n    vector<int> arr3 = {1, 2, 3, 4, 5};\n    int k3 = 10;\n    cout << \"Test case 3: Winner is \" << solution.findTheWinner(arr3, k3) << endl;\n\n    return 0;\n}\n```",
  "1824": "```\n#include <iostream>\n#include <vector>\n\nint minSidewayJumps(int n, std::vector<int>& obstacles) {\n    int jumps = 0;\n    for (int i = 0; i < obstacles.size(); i++) {\n        while (obstacles[i] <= jumps * 2 + 1) {\n            jumps++;\n        }\n        jumps++;\n    }\n    return jumps;\n}\n\nint main() {\n    std::vector<int> obs1 = {4,2,7,6,9,14,3};\n    std::cout << \"Test Case 1: \" << minSidewayJumps(10, obs1) << std::endl;\n\n    std::vector<int> obs2 = {8,3,16,6,12};\n    std::cout << \"Test Case 2: \" << minSidewayJumps(25, obs2) << std::endl;\n\n    std::vector<int> obs3 = {};\n    std::cout << \"Test Case 3: \" << minSidewayJumps(5, obs3) << std::endl;\n    \n    return 0;\n}\n```",
  "1825": "```\n#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass MKAverage {\npublic:\n    MKAverage(int m, int n) : m(m), n(n) {}\n\n    void addElement(int num) {\n        if (q.size() == m) q.pop();\n        q.push(num);\n    }\n\n    double getMKAverage() {\n        if (q.size() != m) return -1.0;\n        long sum = 0, kth = 0;\n        for (int i = 0; i < m; ++i) {\n            if (i == k-1) kth += q.front();\n            else sum += q.front();\n            q.pop();\n        }\n        return (double)(sum + kth) / k;\n    }\n\nprivate:\n    int m, n;\n    priority_queue<int> q;\n};\n\nint main() {\n    MKAverage mk = new MKAverage(3, 2);\n    mk.addElement(1);\n    mk.addElement(4);\n    mk.addElement(5);\n    double res = mk.getMKAverage();\n    cout << \"The average is: \" << res << endl;\n\n    mk.addElement(7);\n    mk.addElement(8);\n    double res2 = mk.getMKAverage();\n    cout << \"The average is: \" << res2 << endl;\n\n    mk.addElement(9);\n    double res3 = mk.getMKAverage();\n    cout << \"The average is: \" << res3 << endl;\n}\n```",
  "1826": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> findErrorNums(std::vector<int>& nums) {\n    std::vector<int> result;\n    for (int i = 0; i < nums.size(); ++i) {\n        int pos = abs(nums[i]) - 1;\n        if (nums[pos] > 0) {\n            nums[pos] *= -1;\n        } else {\n            result.push_back(abs(nums[i]));\n        }\n    }\n    for (int i = 0; i < nums.size(); ++i) {\n        if (nums[i] > 0) {\n            return {i + 1, abs(nums[i])};\n        }\n    }\n    return {};\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {1, 2, 3, 4, 5, 6};\n    auto result1 = findErrorNums(test1);\n    if (result1[0] == 2 && result1[1] == 5) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed.\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> test2 = {3, 2};\n    auto result2 = findErrorNums(test2);\n    if (result2[0] == 2 && result2[1] == 3) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed.\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> test3 = [5, 7, 8, 9, 10];\n    auto result3 = findErrorNums(test3);\n    if (result3[0] == 5 && result3[1] == 8) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed.\" << std::endl;\n    }\n\n    return 0;\n}",
  "1827": "```\n#include <iostream>\n#include <vector>\n\nint minOperations(std::vector<int>& arr) {\n    int operations = 0;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] <= arr[i - 1]) {\n            int diff = arr[i - 1] - arr[i] + 1;\n            operations += diff;\n            arr[i] += diff;\n        }\n    }\n    return operations;\n}\n\nint main() {\n    std::vector<int> test1({1, 3, 5, 4});\n    std::cout << \"Test Case 1: \" << minOperations(test1) << std::endl;\n\n    std::vector<int> test2({2, 2, 2, 2});\n    std::cout << \"Test Case 2: \" << minOperations(test2) << std::endl;\n\n    std::vector<int> test3({5, 4, 3, 2, 1});\n    std::cout << \"Test Case 3: \" << minOperations(test3) << std::endl;\n\n    return 0;\n}\n```",
  "1828": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int countPoints(std::vector<std::vector<int>>& points, std::vector<std::vector<int>>& queries) {\n        int res = 0;\n        for (const auto& query : queries) {\n            for (const auto& point : points) {\n                int dx = query[0] - point[0];\n                int dy = query[1] - point[1];\n                if (dx * dx + dy * dy <= query[2] * query[2]) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> points1 = {{0, 0}, {2, 0}, {3, 1}};\n    std::vector<std::vector<int>> queries1 = {{1, 0, 2}, {2, 1, 3}, {3, 4, 5}};\n    int res1 = solution.countPoints(points1, queries1);\n    if (res1 != 3) {\n        std::cout << \"Test case 1 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::vector<int>> points2 = {{1, 4}, {3, 6}};\n    std::vector<std::vector<int>> queries2 = {{1, 4, 5}, {3, 6, 8}};\n    int res2 = solution.countPoints(points2, queries2);\n    if (res2 != 0) {\n        std::cout << \"Test case 2 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::vector<int>> points3 = {{1, 4}, {0, 5}};\n    std::vector<std::vector<int>> queries3 = {{1, 2, 10}, {0, 5, 7}};\n    int res3 = solution.countPoints(points3, queries3);\n    if (res3 != 2) {\n        std::cout << \"Test case 3 failed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1829": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> maxResult(vector<vector<int>>& ans, int n) {\n        vector<int> res(n);\n        for (int i = 0; i < n; i++) {\n            int mx = 0;\n            for (int j = i; j >= 0; j--) {\n                if (ans[j][1] > mx && ans[j][0] <= i) {\n                    mx = ans[j][1];\n                }\n            }\n            res[i] = mx;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> ans1 = {{8,9},{2,10},{5,9}};\n    vector<int> result1 = solution.maxResult(ans1, 5);\n    for (auto i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> ans2 = {{0,1},{1,1},{3,6},{4,7},{8,9}};\n    vector<int> result2 = solution.maxResult(ans2, 10);\n    for (auto i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> ans3 = {{0,5},{1,3},{6,9}};\n    vector<int> result3 = solution.maxResult(ans3, 10);\n    for (auto i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1830": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minNumberOperations(string s) {\n        int res = 0;\n        for (int i = 0; i < s.length(); i++) {\n            res += abs((s[i] - 'a') - (i % 26));\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.minNumberOperations(\"cba\") << endl; // expected output: 4\n    cout << \"Test case 2: \" << solution.minNumberOperations(\"bab\") << endl; // expected output: 0\n    cout << \"Test case 3: \" << solution.minNumberOperations(\"rywz\") << endl; // expected output: 8\n\n    return 0;\n}\n```",
  "1832": "```\n#include <iostream>\n#include <set>\nusing namespace std;\n\nbool checkIfPangram(string sentence) {\n    set<char> charSet;\n    \n    for (char c : sentence) {\n        if (isalpha(c)) {\n            charSet.insert(tolower(c));\n        }\n    }\n\n    return charSet.size() == 26;\n}\n\nint main() {\n    cout << boolalpha;\n    cout << checkIfPangram(\"The quick brown fox jumps over the lazy dog\") << endl; // Expected: true\n    cout << checkIfPangram(\"Hello world, this is a test.\") << endl; // Expected: false\n    cout << checkIfPangram(\"Pack my box with five dozen liquor jugs\") << endl; // Expected: true\n    return 0;\n}\n```",
  "1831": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> maxTransaction(vector<vector<string>>& transactions) {\n        map<string, int> dayTransactions;\n        \n        for (const auto& transaction : transactions) {\n            string date = transaction[0];\n            int amount = stoi(transaction[1]);\n            \n            dayTransactions[date] += amount;\n        }\n        \n        vector<int> result;\n        for (const auto& pair : dayTransactions) {\n            result.push_back(pair.second);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> transactions1 = {{\"2020-01-01\", \"100\"}, {\"2020-01-02\", \"-50\"}};\n    vector<int> expected1 = {150};\n    assert(solution.maxTransaction(transactions1) == expected1);\n\n    // Test Case 2\n    vector<vector<string>> transactions2 = {{\"2020-01-03\", \"200\"}, {\"2020-01-04\", \"-100\"}, {\"2020-01-05\", \"50\"}};\n    vector<int> expected2 = {150};\n    assert(solution.maxTransaction(transactions2) == expected2);\n\n    // Test Case 3\n    vector<vector<string>> transactions3 = {{\"2021-02-15\", \"300\"}, {\"2021-02-16\", \"-200\"}, {\"2021-02-17\", \"100\"}};\n    vector<int> expected3 = {200};\n    assert(solution.maxTransaction(transactions3) == expected3);\n\n    return 0;\n}\n```",
  "1833": "```\n#include <iostream>\n#include <vector>\n\nint maxIceCream(std::vector<int>& costs) {\n    std::sort(costs.begin(), costs.end());\n    \n    int total = 0, remainingCoins = 500;\n    for (int cost : costs) {\n        if (cost <= remainingCoins) {\n            total++;\n            remainingCoins -= cost;\n        } else {\n            break;\n        }\n    }\n    \n    return total;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 3, 2, 5};\n    std::cout << \"Test Case 1: \" << maxIceCream(test1) << std::endl;\n\n    std::vector<int> test2 = {4, 7, 6, 8};\n    std::cout << \"Test Case 2: \" << maxIceCream(test2) << std::endl;\n\n    std::vector<int> test3 = {1, 3, 2, 4, 5, 7};\n    std::cout << \"Test Case 3: \" << maxIceCream(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1834": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int busiestServer(int k, vector<vector<int>>& arrival, vector<vector<int>>& load) {\n        priority_queue<pair<int, int>> pq;\n        for (int i = 0; i < k; ++i) {\n            pq.push({arrival[i][0], i});\n        }\n        \n        vector<int> res(k, 0);\n        while (!pq.empty()) {\n            pair<int, int> curr = pq.top();\n            pq.pop();\n            \n            int start = curr.second;\n            for (int i = 1; i < k; ++i) {\n                if (arrival[i][0] >= curr.first && arrival[i][0] <= curr.second + load[start][1]) {\n                    pq.push({curr.second + load[start][1], i});\n                    res[start]++;\n                    break;\n                }\n            }\n        }\n        \n        int maxBusy = 0;\n        for (int i = 0; i < k; ++i) {\n            if (res[i] > maxBusy)\n                maxBusy = res[i];\n        }\n        \n        return maxBusy;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int k1 = 2;\n    vector<vector<int>> arrival1 = {{0, 10}, {5, 15}};\n    vector<vector<int>> load1 = {{6, 1}, [7, 12]};\n    cout << \"Test case 1: \" << solution.busiestServer(k1, arrival1, load1) << endl;\n\n    // Test case 2\n    int k2 = 3;\n    vector<vector<int>> arrival2 = {{0, 5}, {4, 9}, [7, 14]};\n    vector<vector<int>> load2 = [[1, 10], [2, 6], [3, 8]];\n    cout << \"Test case 2: \" << solution.busiestServer(k2, arrival2, load2) << endl;\n\n    // Test case 3\n    int k3 = 4;\n    vector<vector<int>> arrival3 = {{0, 10}, {1, 20}, [2, 30], [5, 45]};\n    vector<vector<int>> load3 = [[7, 6], [8, 11], [9, 15], [10, 21]];\n    cout << \"Test case 3: \" << solution.busiestServer(k3, arrival3, load3) << endl;\n\n    return 0;\n}",
  "1835": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findXORSum(vector<int>& nums) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                res ^= nums[i] ^ nums[j];\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> test1 = {1,3};\n    cout << \"Test Case 1: \" << solution.findXORSum(test1) << endl; // Output: 5\n\n    // Test case 2\n    vector<int> test2 = {0,1,2,10};\n    cout << \"Test Case 2: \" << solution.findXORSum(test2) << endl; // Output: 11\n\n    // Test case 3\n    vector<int> test3 = {4, 5, 6, 7};\n    cout << \"Test Case 3: \" << solution.findXORSum(test3) << endl; // Output: 0\n\n    return 0;\n}\n```",
  "1837": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int sumOfDigits(int n, int k) {\n        string s = to_string(n);\n        int res = 0;\n        for (char c : s) {\n            res += (c - '0') * k + (c - '1');\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    std::cout << solution.sumOfDigits(10, 2) << std::endl; // 7\n    std::cout << solution.sumOfDigits(25, 3) << std::endl; // 13\n    std::cout << solution.sumOfDigits(12, 4) << std::endl; // 8\n    return 0;\n}\n```",
  "1836": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for singly-linked list.\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode() : val(0), next(nullptr) {}\n    ListNode(int x) : val(x), next(nullptr) {}\n    ListNode(int x, ListNode *y) : val(x), next(y) {}\n};\n\nListNode* removeDuplicates(ListNode* head) {\n    if (!head)\n        return nullptr;\n\n    set<int> seen;\n    ListNode* curr = head;\n    while (curr) {\n        if (seen.find(curr->val) != seen.end())\n            curr = curr->next;\n        else\n            seen.insert(curr->val);\n        curr = curr->next;\n    }\n\n    return head;\n}\n\nint main() {\n    // Test Case 1:\n    ListNode* head1 = new ListNode(1);\n    head1->next = new ListNode(2);\n    head1->next->next = new ListNode(3);\n    head1->next->next->next = new ListNode(2);\n    head1->next->next->next->next = new ListNode(4);\n\n    ListNode* result1 = removeDuplicates(head1);\n    while (result1) {\n        cout << result1->val << \" \";\n        result1 = result1->next;\n    }\n    cout << endl;\n\n    // Test Case 2:\n    head1 = nullptr;\n\n    ListNode* result2 = removeDuplicates(head1);\n    while (result2) {\n        cout << result2->val << \" \";\n        result2 = result2->next;\n    }\n    cout << endl;\n\n    // Test Case 3:\n    head1 = new ListNode(1);\n\n    ListNode* result3 = removeDuplicates(head1);\n    while (result3) {\n        cout << result3->val << \" \";\n        result3 = result3->next;\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1838": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maxFrequency(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end());\n    int maxFreq = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        int left = i;\n        int right = nums.size() - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] <= k) {\n                left = mid + 1;\n                maxFreq = std::max(maxFreq, static_cast<int>(nums.end() - std::lower_bound(nums.begin(), nums.end(), k)));\n            } else {\n                right = mid - 1;\n            }\n        }\n    }\n    return maxFreq;\n}\n\nint main() {\n    std::vector<int> nums1 = {2, 11, 11, 2};\n    int k1 = 3;\n    std::cout << \"Test case 1: \" << maxFrequency(nums1, k1) << std::endl;\n\n    std::vector<int> nums2 = {10, 6, 5, 8, 20};\n    int k2 = 15;\n    std::cout << \"Test case 2: \" << maxFrequency(nums2, k2) << std::endl;\n\n    std::vector<int> nums3 = {4, 7, 9, 10, 16};\n    int k3 = 5;\n    std::cout << \"Test case 3: \" << maxFrequency(nums3, k3) << std::endl;\n\n    return 0;\n}",
  "1839": "```\n#include <iostream>\n#include <string>\n\nint longestVowelSubseq(std::string s) {\n    int n = s.length();\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n            int j = i + 1;\n            while (j < n && (s[j] != 'a' && s[j] != 'e' && s[j] != 'i' && s[j] != 'o' && s[j] != 'u')) {\n                ++j;\n            }\n            if (j - i > res) {\n                res = j - i;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << longestVowelSubseq(\"aaoobmmpp\") << std::endl;  // Expected output: 2\n    std::cout << longestVowelSubseq(\"yvvhbk\") << std::endl;      // Expected output: 1\n    std::cout << longestVowelSubseq(\"leothceoa\") << std::endl;    // Expected output: 5\n    return 0;\n}",
  "1840": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint maximumBuildingHeight(std::vector<int>& cost) {\n    int n = cost.size();\n    std::vector<int> dp(n);\n    dp[0] = cost[0];\n    for (int i = 1; i < n; ++i) {\n        dp[i] = std::max(dp[i - 1], cost[i]);\n    }\n    int maxHeight = 0;\n    for (int i = 1; i < n; ++i) {\n        maxHeight = std::max(maxHeight, cost[i]);\n    }\n    return maxHeight;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> cost1 = {14, 7, 15};\n    int result1 = maximumBuildingHeight(cost1);\n    std::cout << \"Test case 1: The maximum building height is \" << result1 << \".\" << std::endl;\n\n    // Test case 2\n    std::vector<int> cost2 = {10, 6, 8, 5};\n    int result2 = maximumBuildingHeight(cost2);\n    std::cout << \"Test case 2: The maximum building height is \" << result2 << \".\" << std::endl;\n\n    // Test case 3\n    std::vector<int> cost3 = {1, 1000000, 1};\n    int result3 = maximumBuildingHeight(cost3);\n    std::cout << \"Test case 3: The maximum building height is \" << result3 << \".\" << std::endl;\n\n    return 0;\n}\n```",
  "1841": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> leagueStatistics(vector<vector<string>>& statistics) {\n        unordered_map<string, int> teamScores;\n        for (const auto& stat : statistics) {\n            teamScores[stat[0]] += stoi(stat[1]);\n        }\n        \n        vector<vector<string>> result;\n        for (const auto& pair : teamScores) {\n            vector<string> row = {pair.first, to_string(pair.second)};\n            result.push_back(row);\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> statistics1 = {{\"A\", \"5\"}, {\"B\", \"3\"}, {\"C\", \"2\"}};\n    vector<vector<string>> expected1 = {{\"A\", \"5\"}, {\"B\", \"3\"}, {\"C\", \"2\"}};\n    assert(solution.leagueStatistics(statistics1) == expected1);\n\n    // Test Case 2\n    vector<vector<string>> statistics2 = {{\"D\", \"10\"}, {\"E\", \"8\"}, {\"F\", \"6\"}, {\"G\", \"4\"}};\n    vector<vector<string>> expected2 = {{\"D\", \"10\"}, {\"E\", \"8\"}, {\"F\", \"6\"}, {\"G\", \"4\"}};\n    assert(solution.leagueStatistics(statistics2) == expected2);\n\n    // Test Case 3\n    vector<vector<string>> statistics3 = {{\"H\", \"1\"}, {\"I\", \"2\"}, {\"J\", \"3\"}, {\"K\", \"4\"}, {\"L\", \"5\"}};\n    vector<vector<string>> expected3 = {{\"H\", \"1\"}, {\"I\", \"2\"}, {\"J\", \"3\"}, {\"K\", \"4\"}, {\"L\", \"5\"}};\n    assert(solution.leagueStatistics(statistics3) == expected3);\n\n    cout << \"All test cases passed.\" << endl;\n    return 0;\n}\n```",
  "1842": "```\n#include <iostream>\n#include <string>\n\nbool isPalindrome(const std::string& s) {\n    int left = 0, right = s.size() - 1;\n    while (left < right) {\n        if (s[left] != s[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\n\nstd::string nextPalindrome(const std::string& s) {\n    for (int i = s.size() - 2; i >= 0; --i) {\n        if (s[i] < s[i + 1]) break;\n        for (int j = s.size() - 1; j > i; --j) {\n            if (s[j] > s[i]) {\n                char c = s[j];\n                std::string next = s.substr(0, i + 1);\n                next += c;\n                for (char& cc : s.substr(i + 1)) {\n                    if (cc < c) return next + cc;\n                }\n                return next + c;\n            }\n        }\n    }\n    return s;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << nextPalindrome(\"1221\") << std::endl;\n    std::cout << \"Test case 2: \" << nextPalindrome(\"12321\") << std::endl;\n    std::cout << \"Test case 3: \" << nextPalindrome(\"1234567\") << std::endl;\n    return 0;\n}\n```",
  "1843": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> findAccountsWithBalance(vector<vector<string>>& accounts) {\n        vector<string> result;\n        for (auto& account : accounts) {\n            if (stoi(account[0]) > 500 && account.size() > 1) {\n                string res = account[0] + \" \" + account[1];\n                result.push_back(res);\n            }\n        }\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<string>> accounts1 = {{\"john\", \"12345\", \"215\"}};\n    vector<string> expected1 = {\"john 215\"};\n    assert(solution.findAccountsWithBalance(accounts1).size() == 1 && solution.findAccountsWithBalance(accounts1)[0] == \"john 215\");\n\n    vector<vector<string>> accounts2 = {{\"james\", \"12345\", \"215\"}};\n    vector<string> expected2 = {};\n    assert(solution.findAccountsWithBalance(accounts2).size() == 0);\n\n    vector<vector<string>> accounts3 = {{\"jane\", \"12345\", \"600\"}, {\"john\", \"12345\", \"500\"}};\n    vector<string> expected3 = {\"jane 600\"};\n    assert(solution.findAccountsWithBalance(accounts3).size() == 1 && solution.findAccountsWithBalance(accounts3)[0] == \"jane 600\");\n\n    return 0;\n}",
  "1844": "```\n#include <iostream>\n#include <string>\n\nstd::string replaceDigits(std::string s) {\n    std::string result = \"\";\n    for (char c : s) {\n        if (c >= '0' && c <= '9') {\n            result += '#';\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << replaceDigits(\"a23b\") << std::endl;\n    std::cout << \"Test case 2: \" << replaceDigits(\"ab#cd\") << std::endl;\n    std::cout << \"Test case 3: \" << replaceDigits(\"1234\") << std::endl;\n    return 0;\n}\n```",
  "1846": "```\n#include <iostream>\n#include <vector>\n\nint maxResult(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> dp(n);\n    \n    dp[0] = nums[0];\n    for (int i = 1; i < n; ++i) {\n        dp[i] = nums[i];\n        if (i > 0) {\n            dp[i] = std::max(dp[i], dp[i - 1] + nums[i]);\n        }\n    }\n    \n    return *std::max_element(dp.begin(), dp.end());\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {9, 3, 7};\n    int result1 = maxResult(test1);\n    if (result1 == 20) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 20, Actual: \" << result1 << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> test2 = {2, 7, 11};\n    int result2 = maxResult(test2);\n    if (result2 == 11) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 11, Actual: \" << result2 << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> test3 = {100, -20, 10};\n    int result3 = maxResult(test3);\n    if (result3 == 190) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 190, Actual: \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1845": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass SeatReservationManager {\npublic:\n    SeatReservationManager(int n) : seats(n), priorityQueue() {}\n\n    void reserve(string passenger, int start, int end) {\n        for (int i = start; i <= end; i++) {\n            if (!seats[i]) {\n                seats[i] = true;\n                priorityQueue.push({passenger, i});\n                return;\n            }\n        }\n    }\n\n    string unreserve(int seatNumber) {\n        SeatPair pair = priorityQueue.top();\n        priorityQueue.pop();\n        pair.seatNumber = -1;\n        return pair.passenger;\n    }\n\nprivate:\n    vector<bool> seats;\n    priority_queue<pair<string, int>, vector<pair<string, int>>, greater<pair<string, int>>> priorityQueue;\n\n};\n\nint main() {\n    SeatReservationManager manager(5);\n\n    cout << \"Test case 1: \" << manager.unreserve(-1) << endl; // Expected output: \"No one\"\n    cout << \"Test case 2: \";\n    manager.reserve(\"Alice\", 0, 3);\n    cout << manager.unreserve(0) << endl; // Expected output: \"Alice\"\n    cout << manager.unreserve(1) << endl; // Expected output: \"Alice\"\n    cout << manager.unreserve(-1) << endl; // Expected output: \"No one\"\n\n    cout << \"Test case 3: \";\n    manager.reserve(\"Bob\", 0, 2);\n    cout << manager.unreserve(0) << endl; // Expected output: \"Bob\"\n    cout << manager.unreserve(-1) << endl; // Expected output: \"No one\"\n    cout << manager.unreserve(1) << endl; // Expected output: \"Bob\"\n    cout << manager.unreserve(2) << endl; // Expected output: \"Bob\"\n\n    return 0;\n}\n```",
  "1848": "```\n#include <iostream>\n#include <vector>\n\nint minDistance(std::vector<int>& nums, int target) {\n    int n = nums.size();\n    int res = n;\n    for (int i = 0; i < n; ++i) {\n        if (nums[i] == target) {\n            int l = i - 1, r = i + 1;\n            while (l >= 0 && nums[l] != target) --l;\n            while (r < n && nums[r] != target) ++r;\n            res = std::min({res, i - l, r - i});\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 3, 4, 5, 6, 7};\n    int target1 = 5;\n    std::cout << \"Test case 1: \" << minDistance(nums1, target1) << std::endl;\n\n    std::vector<int> nums2 = {1};\n    int target2 = 1;\n    std::cout << \"Test case 2: \" << minDistance(nums2, target2) << std::endl;\n\n    std::vector<int> nums3 = {1, 2, 4, 4, 5, 6, 7, 8};\n    int target3 = 4;\n    std::cout << \"Test case 3: \" << minDistance(nums3, target3) << std::endl;\n\n    return 0;\n}\n```",
  "1847": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint closestRoom(std::vector<std::string>& rooms) {\n    std::sort(rooms.begin(), rooms.end());\n    int res = -1;\n    for (int i = 0; i < rooms.size(); ++i) {\n        if (rooms[i].find('x') == std::string::npos) {\n            if (res == -1 || std::stoi(rooms[i].substr(1, rooms[i].size() - 2)) < abs(std::stoi(rooms[res].substr(1, rooms[res].size() - 2))) - 3) {\n                res = i;\n            }\n        } else break;\n    }\n    return res;\n}\n\nint main() {\n    std::vector<std::string> rooms1 = {\"A001\", \"A003\", \"B002\", \"B005\", \"C004\"};\n    std::cout << closestRoom(rooms1) << std::endl;\n\n    std::vector<std::string> rooms2 = {\"100\", \"101\", \"102\", \"103\", \"104\", \"105\", \"106\", \"107\", \"108\", \"109\", \"110\", \"111\", \"113\", \"114\", \"115\"};\n    std::cout << closestRoom(rooms2) << std::endl;\n\n    std::vector<std::string> rooms3 = {\"A000\", \"B000\", \"C000\", \"D000\", \"E000\", \"F000\", \"G000\", \"H000\", \"I000\", \"J000\"};\n    std::cout << closestRoom(rooms3) << std::endl;\n\n    return 0;\n}",
  "1850": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minMovesToSort(int kthSmallest, vector<string>& nums) {\n        int moves = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] == to_string(kthSmallest)) {\n                while (i > 0 && to_string(kthSmallest) > nums[i - 1]) {\n                    swap(nums[i], nums[i - 1]);\n                    moves++;\n                }\n                return moves;\n            }\n        }\n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    vector<string> test1 = {\"105\", \"20\", \"7\", \"3\", \"19\"};\n    cout << solution.minMovesToSort(5, test1) << endl;  // Output: 2\n\n    // Test Case 2\n    vector<string> test2 = {\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"};\n    cout << solution.minMovesToSort(3, test2) << endl;  // Output: 0\n\n    // Test Case 3\n    vector<string> test3 = {\"105\", \"20\", \"7\", \"19\", \"3\"};\n    cout << solution.minMovesToSort(5, test3) << endl;  // Output: 1\n    \n    return 0;\n}\n```",
  "1849": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> splitString(string s) {\n        if (s.empty()) return {};\n\n        vector<string> result;\n        int start = 0, end = 0;\n        while (end < s.length()) {\n            if ((end + 1 == s.length() || s[end + 1] - '0' < s[end] - '0')) {\n                end++;\n            } else {\n                result.push_back(s.substr(start, end - start + 1));\n                start = end + 1;\n                end++;\n            }\n        }\n        result.push_back(s.substr(start));\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string s1 = \"1234\";\n    vector<string> result1 = solution.splitString(s1);\n    cout << \"[\\\"\" << result1[0] << \"\\\", \\\"\" << result1[1] << \"\\\"]\" << endl;\n    \n    // Test case 2\n    string s2 = \"345678\";\n    vector<string> result2 = solution.splitString(s2);\n    cout << \"[\\\"\" << result2[0] << \"\\\", \\\"\" << result2[1] << \"\\\", \\\"3\\\", \\\"2\\\", \\\"1\\\"]\" << endl;\n    \n    // Test case 3\n    string s3 = \"121313\";\n    vector<string> result3 = solution.splitString(s3);\n    cout << \"[\\\"1\\\", \\\"12\\\"]\" << endl;\n\n    return 0;\n}\n```",
  "1851": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> minInterval(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        vector<pair<int, int>> all(n * 2);\n        \n        for (int i = 0; i < n; ++i) {\n            all[2 * i] = {intervals[i][0], -1};\n            all[2 * i + 1] = {intervals[i][1], 1};\n        }\n        \n        sort(all.begin(), all.end());\n        \n        int minIntervalSize = INT_MAX;\n        int currentIntervalSize = 0;\n        for (const auto& event : all) {\n            if (event.second == -1) {\n                currentIntervalSize = event.first;\n            } else {\n                minIntervalSize = min(minIntervalSize, event.first - currentIntervalSize);\n                currentIntervalSize = 0;\n            }\n        }\n        \n        return {minIntervalSize};\n    }\n};\n\nint main() {\n    vector<vector<int>> intervals1 = {{10,15},{11,13},{12,14}};\n    cout << \"Expected: [3] Actual: \" << (new Solution())->minInterval(intervals1)[0] << endl;\n\n    vector<vector<int>> intervals2 = {{1,4},{4,5}};\n    cout << \"Expected: [3] Actual: \" << (new Solution())->minInterval(intervals2)[0] << endl;\n\n    vector<vector<int>> intervals3 = {{1,3}};\n    cout << \"Expected: [1] Actual: \" << (new Solution())->minInterval(intervals3)[0] << endl;\n    \n    return 0;\n}\n```",
  "1852": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> distinctNumbers(vector<string>& log) {\n        unordered_map<string, int> mp;\n        int res[1001] = {0};\n        for (int i = 0; i < log.size(); i++) {\n            string str = log[i].substr(5, log[i].size() - 5);\n            if (mp.find(str) == mp.end()) {\n                mp[str] = i;\n            }\n            res[min(i + 1, mp[str] + 1)]++;\n        }\n        int n = log.size();\n        vector<int> ans;\n        for (int i = 0; i <= n; i++) {\n            while (i > 0 && res[i - 1] == res[i]) {\n                i--;\n            }\n            ans.push_back(i);\n        }\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<string> log1 = {\"a1\",\"b2\",\"c3\",\"a1\",\"c3\"};\n    vector<int> expected1 = {3};\n    if (solution.distinctNumbers(log1) != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n    } else {\n        cout << \"Test case 1 passed.\" << endl;\n    }\n\n    vector<string> log2 = {\"2021:01:02 001:01:58\",\"2021:01:02 000:00:03\",\"2021:01:02 000:00:05\"};\n    vector<int> expected2 = {2};\n    if (solution.distinctNumbers(log2) != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n    } else {\n        cout << \"Test case 2 passed.\" << endl;\n    }\n\n    vector<string> log3 = {\"a1\",\"b1\"};\n    vector<int> expected3 = {2};\n    if (solution.distinctNumbers(log3) != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n    } else {\n        cout << \"Test case 3 passed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1853": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    string convertDate(string s) {\n        if (s.length() == 10) {\n            return s.replace(4, 2, \"-\").replace(7, 3, \"-\");\n        } else {\n            return s;\n        }\n    }\n};\n\nint main() {\n    Solution sol = Solution();\n    \n    // Test case 1\n    string s1 = \"2020-01-01\";\n    cout << \"Test case 1: Expected output - \" << s1 << endl;\n    cout << \"Actual output - \" << sol.convertDate(s1) << endl;\n\n    // Test case 2\n    string s2 = \"20220102\";\n    cout << \"Test case 2: Expected output - \" << \"2020-01-02\" << endl;\n    cout << \"Actual output - \" << sol.convertDate(s2) << endl;\n\n    // Test case 3\n    string s3 = \"12345678901234\";\n    cout << \"Test case 3: Expected output - \" << s3 << endl;\n    cout << \"Actual output - \" << sol.convertDate(s3) << endl;\n    \n    return 0;\n}\n```",
  "1854": "```\n#include <iostream>\n#include <vector>\n\nint maxPopulation(std::vector<std::vector<int>>& input) {\n    int n = input.size();\n    std::vector<int> population(n);\n    for (int i = 0; i < n; i++) {\n        population[i] = input[i][1];\n    }\n    \n    int maxYear = 0;\n    int maxPop = 0;\n    for (int i = 0; i < n - 1; i++) {\n        int popThisYear = population[i];\n        population[i] += population[n - 1 - i];\n        \n        if (popThisYear > maxPop) {\n            maxPop = popThisYear;\n            maxYear = i;\n        }\n    }\n    \n    return maxYear;\n}\n\nint main() {\n    std::vector<std::vector<int>> input1 = {{1950, 9800000}, {1951, 10000000}};\n    std::cout << \"Test case 1: \" << maxPopulation(input1) << std::endl;\n\n    std::vector<std::vector<int>> input2 = {{1990, 11000000}, {1991, 12000000}, {1992, 13000000}};\n    std::cout << \"Test case 2: \" << maxPopulation(input2) << std::endl;\n\n    std::vector<std::vector<int>> input3 = {{2000, 1000000}, {2001, 1010000}, {2002, 1020000}, {2003, 1030000}};\n    std::cout << \"Test case 3: \" << maxPopulation(input3) << std::endl;\n\n    return 0;\n}\n```",
  "1855": "```\n#include <iostream>\n#include <vector>\n\nint maxDistance(std::vector<int>& nums) {\n    int ans = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n        int target = nums[i];\n        auto leftIt = std::lower_bound(nums.begin(), nums.end(), target);\n        if (leftIt != nums.end() && *leftIt == target) {\n            int right = std::distance(leftIt, nums.end());\n            ans = std::max(ans, right - i);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    std::vector<int> test1 = {3, 4, 1, 2};\n    std::cout << \"Test case 1: \" << maxDistance(test1) << std::endl;\n\n    std::vector<int> test2 = {5, 7, 8, 9, 10, 20, 25, 30];\n    std::cout << \"Test case 2: \" << maxDistance(test2) << std::endl;\n\n    std::vector<int> test3 = {1, 2, 3, 4, 5};\n    std::cout << \"Test case 3: \" << maxDistance(test3) << std::endl;\n    \n    return 0;\n}\n```",
  "1856": "```\n#include <iostream>\n#include <vector>\n\nint maxSumMinProduct(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> leftMin(n, 1), rightMax(n, 1);\n    std::stack<int> s;\n    \n    for (int i = 0; i < n; ++i) {\n        while (!s.empty() && nums[s.top()] > nums[i]) {\n            rightMax[s.top()] = i;\n            s.pop();\n        }\n        s.push(i);\n    }\n    \n    for (int i = n - 1; i >= 0; --i) {\n        while (!s.empty() && nums[s.top()] > nums[i]) {\n            leftMin[s.top()] = i + 1;\n            s.pop();\n        }\n        s.push(i);\n    }\n    \n    int ans = 0;\n    for (int i = 0; i < n; ++i) {\n        ans = std::max(ans, nums[i] * (leftMin[i] - 1) * (rightMax[i] - 1));\n    }\n    return ans;\n}\n\nint main() {\n    std::vector<int> nums1 = {6,9,7,5,12};\n    std::cout << \"Maximum Subarray Min-Product for \" << nums1 << \": \" << maxSumMinProduct(nums1) << std::endl;\n\n    std::vector<int> nums2 = {1,0,-1,0,3};\n    std::cout << \"Maximum Subarray Min-Product for \" << nums2 << \": \" << maxSumMinProduct(nums2) << std::endl;\n\n    std::vector<int> nums3 = {2,3,4,5,6};\n    std::cout << \"Maximum Subarray Min-Product for \" << nums3 << \": \" << maxSumMinProduct(nums3) << std::endl;\n    \n    return 0;\n}\n```",
  "1857": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint largestColorValue(vector<vector<int>>& graph) {\n    unordered_map<int, int> colorCount;\n    vector<int> colors(graph.size(), -1);\n    \n    for (int i = 0; i < graph.size(); i++) {\n        if (colors[i] == -1) {\n            dfs(i, graph, colors, colorCount);\n        }\n    }\n    \n    return *max_element(colorCount.begin(), colorCount.end());\n}\n\nvoid dfs(int node, vector<vector<int>>& graph, vector<int>& colors, unordered_map<int, int>& colorCount) {\n    if (colors[node] != -1) {\n        return;\n    }\n    \n    for (int neighbor : graph[node]) {\n        if (colors[neighbor] == -1) {\n            dfs(neighbor, graph, colors, colorCount);\n            colors[neighbor] = node;\n            colorCount[node]++;\n        } else {\n            colors[neighbor] = node;\n        }\n    }\n}\n\nint main() {\n    vector<vector<int>> graph1 = {{1,2},{2,3},{4,5}};\n    cout << \"Largest Color Value for graph 1: \" << largestColorValue(graph1) << endl;\n\n    vector<vector<int>> graph2 = {{1,4},{7,8},{9,6},{10,2},{5,3}};\n    cout << \"Largest Color Value for graph 2: \" << largestColorValue(graph2) << endl;\n\n    vector<vector<int>> graph3 = {{0,1},{1,2},{2,0},{1,3},{3,4}};\n    cout << \"Largest Color Value for graph 3: \" << largestColorValue(graph3) << endl;\n    \n    return 0;\n}\n```",
  "1859": "```\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nbool compare(const std::string& s1, const std::string& s2) {\n    int i = 0;\n    while (i < s1.length() && i < s2.length()) {\n        if (s1[i] < s2[i]) return true;\n        if (s1[i] > s2[i]) return false;\n        i++;\n    }\n    return s1.length() <= s2.length();\n}\n\nint main() {\n    std::vector<std::string> sentences = {\"hello\", \"world\", \"abc\"};\n    std::sort(sentences.begin(), sentences.end(), compare);\n    \n    for (const auto& sentence : sentences) {\n        std::cout << sentence << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1858": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstruct TrieNode {\n    bool isWord;\n    unordered_map<char, TrieNode*> children;\n};\n\nclass WordFilter {\npublic:\n    TrieNode* root = new TrieNode();\n    vector<string> longestWords;\n\n    void addWord(string word) {\n        TrieNode* current = root;\n        for (char c : word) {\n            if (!current->children.count(c)) {\n                current->children[c] = new TrieNode();\n            }\n            current = current->children[c];\n        }\n        current->isWord = true;\n    }\n\n    int findLongest() {\n        int maxLength = 0;\n        queue<TrieNode*> q;\n        q.push(root);\n        while (!q.empty()) {\n            TrieNode* node = q.front();\n            q.pop();\n            for (auto& child : node->children) {\n                q.push(child.second);\n                if (child.second->isWord) {\n                    maxLength = max(maxLength, child.first - 'a' + 1);\n                }\n            }\n        }\n        return maxLength;\n    }\n\n};\n\nint main() {\n    WordFilter wf;\n    wf.addWord(\"apple\");\n    wf.addWord(\"apnea\");\n    wf.addWord(\"app\");\n\n    cout << wf.findLongest() << endl; // Expected output: 5\n\n    wf = WordFilter();\n    wf.addWord(\"abce\");\n    wf.addWord(\"aabce\");\n    wf.addWord(\"aaba\");\n    wf.addWord(\"a\");\n\n    cout << wf.findLongest() << endl; // Expected output: 4\n\n    wf = WordFilter();\n    wf.addWord(\"abc\");\n\n    cout << wf.findLongest() << endl; // Expected output: 3\n    return 0;\n}\n```",
  "1860": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int slowestKey(vector<int>& releaseTimes, char keys[]) {\n        int maxTime = 0;\n        char key = ' ';\n        \n        for (int i = 0; i < releaseTimes.size(); i++) {\n            if (releaseTimes[i] + i > maxTime) {\n                maxTime = releaseTimes[i] + i;\n                key = keys[i];\n            }\n        }\n        \n        return key;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> releaseTimes1 = {9, 29};\n    char keys1[] = {'4', '2'};\n    cout << \"Test Case 1: \" << solution.slowestKey(releaseTimes1, keys1) << endl;\n\n    // Test Case 2\n    vector<int> releaseTimes2 = {10, 20, 30};\n    char keys2[] = {'a', 'b', 'c'};\n    cout << \"Test Case 2: \" << solution.slowestKey(releaseTimes2, keys2) << endl;\n\n    // Test Case 3\n    vector<int> releaseTimes3 = {1, 12, 18};\n    char keys3[] = {'a', 'h', 'i'};\n    cout << \"Test Case 3: \" << solution.slowestKey(releaseTimes3, keys3) << endl;\n\n    return 0;\n}\n```",
  "1861": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int>> rotateBox(std::vector<std::vector<int>>& box) {\n    int n = box.size();\n    std::vector<std::vector<int>> rotatedBox(n, std::vector<int>(n));\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            rotatedBox[j][n - i - 1] = box[i][j];\n        }\n    }\n\n    return rotatedBox;\n}\n\nint main() {\n    std::vector<std::vector<int>> box1 {{1,2},{3,4}};\n    std::cout << \"Input Box: \";\n    for (const auto& row : box1) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> rotatedBox1 = rotateBox(box1);\n    std::cout << \"Rotated Box: \";\n    for (const auto& row : rotatedBox1) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> box2 {{5,6},{7,8}};\n    std::cout << \"Input Box: \";\n    for (const auto& row : box2) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> rotatedBox2 = rotateBox(box2);\n    std::cout << \"Rotated Box: \";\n    for (const auto& row : rotatedBox2) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> box3 {{1,2,3},{4,5,6},{7,8,9}};\n    std::cout << \"Input Box: \";\n    for (const auto& row : box3) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    std::vector<std::vector<int>> rotatedBox3 = rotateBox(box3);\n    std::cout << \"Rotated Box: \";\n    for (const auto& row : rotatedBox3) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "1862": "```\n#include <iostream>\n#include <vector>\n\nint totalFruit(std::vector<int>& fruits) {\n    int n = fruits.size();\n    if (n == 0) return 0;\n\n    std::unordered_map<int, int> fruitCount;\n    int start = 0, maxLen = 0;\n\n    for (int end = 0; end < n; ++end) {\n        fruitCount[fruits[end]]++;\n\n        while (fruitCount.size() > 2) {\n            fruitCount[fruits[start]]--;\n            if (fruitCount[fruits[start]] == 0)\n                fruitCount.erase(fruits[start]);\n            start++;\n        }\n\n        maxLen = std::max(maxLen, end - start + 1);\n    }\n\n    return maxLen;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<int> fruits1 = {1, 2, 3, 3, 2};\n    std::cout << \"Test Case 1: \" << totalFruit(fruits1) << std::endl;\n\n    // Test Case 2\n    std::vector<int> fruits2 = {0, 1, 2, 2};\n    std::cout << \"Test Case 2: \" << totalFruit(fruits2) << std::endl;\n\n    // Test Case 3\n    std::vector<int> fruits3 = {};\n    std::cout << \"Test Case 3: \" << totalFruit(fruits3) << std::endl;\n\n    return 0;\n}\n```",
  "1863": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int subsetXORSum(vector<int>& nums) {\n        int total = 0;\n        for (int num : nums) {\n            total ^= num;\n        }\n        int n = 1 << nums.size();\n        for (int i = 1; i < n; i++) {\n            int temp = total;\n            for (int j = 0; j < nums.size(); j++) {\n                if ((i & (1 << j))) {\n                    temp ^= nums[j];\n                }\n            }\n            total ^= temp;\n        }\n        return total;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {5,1,4};\n    cout << \"Test case 1: \" << solution.subsetXORSum(nums1) << endl;\n\n    // Test case 2\n    vector<int> nums2 = {7,8};\n    cout << \"Test case 2: \" << solution.subsetXORSum(nums2) << endl;\n\n    // Test case 3\n    vector<int> nums3 = {2,5,1};\n    cout << \"Test case 3: \" << solution.subsetXORSum(nums3) << endl;\n\n    return 0;\n}\n```",
  "1864": "```\n#include <iostream>\n#include <string>\n\nint minSwaps(std::string s) {\n    int n = s.size();\n    int swaps = 0;\n    for (int i = 1; i < n; i++) {\n        if ((s[i] == '1' && s[i - 1] == '1') || (s[i] == '0' && s[i - 1] == '0')) {\n            std::swap(s[i], s[i - 1]);\n            swaps++;\n        }\n    }\n    return swaps;\n}\n\nint main() {\n    int testCases = 3;\n    for (int i = 0; i < testCases; i++) {\n        if (i == 0) {\n            std::cout << \"Test Case: \" << minSwaps(\"111000\") << \"\\n\";\n        } else if (i == 1) {\n            std::cout << \"Test Case: \" << minSwaps(\"101010\") << \"\\n\";\n        } else if (i == 2) {\n            std::cout << \"Test Case: \" << minSwaps(\"11011111\") << \"\\n\";\n        }\n    }\n    return 0;\n}\n```",
  "1866": "```\n#include <iostream>\n#include <vector>\n\nint numWays(int n, int k) {\n    std::vector<int> dp(n + 1);\n    dp[0] = 1;\n    for (int i = 1; i <= k; i++) {\n        for (int j = i; j <= n; j++) {\n            dp[j] += dp[j - i];\n        }\n    }\n    int result = 0;\n    for (int i = k; i <= n; i++) {\n        result += dp[i];\n    }\n    return result;\n}\n\nint main() {\n    std::cout << numWays(3, 2) << std::endl;  // Expected output: 6\n    std::cout << numWays(4, 1) << std::endl;  // Expected output: 10\n    std::cout << numWays(5, 3) << std::endl;  // Expected output: 22\n    return 0;\n}\n```",
  "1865": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nvoid findPairs(std::vector<int>& nums, int targetSum, std::vector<std::pair<int, int>>& result) {\n    std::unordered_map<int, int> numIndex;\n    for (int i = 0; i < nums.size(); i++) {\n        int complement = targetSum - nums[i];\n        if (numIndex.find(complement) != numIndex.end()) {\n            result.push_back({complement, nums[i]});\n        }\n        numIndex[nums[i]] = i;\n    }\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 2, 3, 4, 5};\n    int targetSum1 = 7;\n    std::vector<std::pair<int, int>> result1;\n    findPairs(nums1, targetSum1, result1);\n\n    for (const auto& pair : result1) {\n        std::cout << \"Pair: (\" << pair.first << \", \" << pair.second << \")\" << std::endl;\n    }\n\n    std::vector<int> nums2 = {100, 4, 200, 3, 5, 300};\n    int targetSum2 = 999;\n    std::vector<std::pair<int, int>> result2;\n    findPairs(nums2, targetSum2, result2);\n\n    for (const auto& pair : result2) {\n        std::cout << \"Pair: (\" << pair.first << \", \" << pair.second << \")\" << std::endl;\n    }\n\n    std::vector<int> nums3 = {1, 4};\n    int targetSum3 = 5;\n    std::vector<std::pair<int, int>> result3;\n    findPairs(nums3, targetSum3, result3);\n\n    for (const auto& pair : result3) {\n        std::cout << \"Pair: (\" << pair.first << \", \" << pair.second << \")\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1867": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> highFive(int n, vector<vector<int>>& logs) {\n        unordered_map<int, pair<int, int>> studentData;\n        \n        for (const auto& log : logs) {\n            if (log[0] == 1) { // record a submission\n                studentData[log[1]].first++;\n                studentData[log[1]].second += log[2];\n            } else { // update high five scores\n                int id = log[1], score = log[2];\n                if (studentData.find(id) != studentData.end()) {\n                    studentData[id].second /= studentData[id].first;\n                    studentData[id].first = 0;\n                }\n                if (studentData.find(id) == studentData.end() || studentData[id].second < score) {\n                    studentData[id] = {1, score};\n                }\n            }\n        }\n        \n        vector<string> result;\n        for (const auto& pair : studentData) {\n            int id = pair.first, average = pair.second.second / pair.second.first;\n            if (average > 0) {\n                result.push_back(to_string(id) + \" \" + to_string(average));\n            }\n        }\n        \n        sort(result.begin(), result.end());\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n = 3;\n    vector<vector<int>> logs1 = {{1,2,100},{4,2,500},{2,1,300}};\n    vector<string> expected1 = {\"1 250\",\"2 0\"};\n    assert(solution.highFive(n, logs1) == expected1);\n\n    // Test case 2\n    int n2 = 4;\n    vector<vector<int>> logs2 = {{1,5,400},{4,5,500},{3,1,80},{5,5,550},{1,5,150}};\n    vector<string> expected2 = {\"1 250\",\"4 500\"};\n    assert(solution.highFive(n2, logs2) == expected2);\n\n    // Test case 3\n    int n3 = 6;\n    vector<vector<int>> logs3 = {{7,0,600},{9,6,400},{1,8,200},{2,0,100},{4,4,300},{8,1,250},{5,3,380}};\n    vector<string> expected3 = {\"1 200\",\"4 300\"};\n    assert(solution.highFive(n3, logs3) == expected3);\n\n    cout << \"All test cases passed.\" << endl;\n    return 0;\n}\n```",
  "1868": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findErrorNums(vector<vector<int>>& nums) {\n        int n = nums.size();\n        vector<int> res(2);\n        for (int i = 0; i < n; i++) {\n            int j = nums[i][1] - 1;\n            while (j > 0 && nums[j-1][1] >= j + 1) {\n                j--;\n            }\n            if (j == i) {\n                res[0] = i + 1;\n                res[1] = nums[i][0];\n                break;\n            } else if (j < i) {\n                res[0] = j + 1;\n                res[1] = nums[i][0];\n                break;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> input1 = {{1,3},{2,1},{3,3}};\n    vector<int> result1 = solution.findErrorNums(input1);\n    cout << \"Test Case 1: \";\n    for (int i : result1) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> input2 = {{1,1},{2,2}};\n    vector<int> result2 = solution.findErrorNums(input2);\n    cout << \"Test Case 2: \";\n    for (int i : result2) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    vector<vector<int>> input3 = {{1,5},{2,4},{3,3}};\n    vector<int> result3 = solution.findErrorNums(input3);\n    cout << \"Test Case 3: \";\n    for (int i : result3) {\n        cout << i << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1869": "```\n#include <iostream>\n#include <string>\n\nbool checkOnesZeros(std::string s) {\n    int ones = 0;\n    int zeros = 0;\n\n    for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '1') {\n            ones++;\n        } else {\n            zeros++;\n        }\n    }\n\n    return ones > zeros;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << checkOnesZeros(\"110\") << std::endl; // true\n    std::cout << checkOnesZeros(\"1001\") << std::endl; // false\n    std::cout << checkOnesZeros(\"11111\") << std::endl; // true\n    return 0;\n}",
  "1870": "```\n#include <iostream>\n#include <vector>\n\nint minEatingSpeed(std::vector<int>& hours, int m) {\n    if (hours.empty()) return 0;\n\n    int left = 1, right = m;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        long long needTime = 0;\n        for (int hour : hours) {\n            needTime += (hour + (mid - 1)) / mid;\n        }\n        if (needTime > m) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n\n    return left;\n}\n\nint main() {\n    std::vector<int> hours1 = {2,3,4};\n    int result1 = minEatingSpeed(hours1, 6);\n    std::cout << \"Test Case 1: \" << result1 << std::endl;\n\n    std::vector<int> hours2 = {4,5};\n    int result2 = minEatingSpeed(hours2, 15);\n    std::cout << \"Test Case 2: \" << result2 << std::endl;\n\n    std::vector<int> hours3 = {1,1,1};\n    int result3 = minEatingSpeed(hours3, 2);\n    std::cout << \"Test Case 3: \" << result3 << std::endl;\n    \n    return 0;\n}\n```",
  "1871": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxResult(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> dp(n, 0);\n        dp[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            dp[i] = max(dp[i - 1], nums[i]);\n            if (i >= max(0, i - nums[i])) {\n                dp[i] += nums[i];\n            }\n        }\n        return dp.back();\n    }\n};\n\nint main() {\n    Solution solution;\n    vector<int> test1 = {10,3,2};\n    cout << \"Test 1: \" << solution.maxResult(test1) << endl; // Output: 12\n\n    vector<int> test2 = {5,14,1,13,2,11,3,15,4,2,10};\n    cout << \"Test 2: \" << solution.maxResult(test2) << endl; // Output: 26\n\n    vector<int> test3 = {100,-23,-6,50,39,-3,75,-10];\n    cout << \"Test 3: \" << solution.maxResult(test3) << endl; // Output: 146\n    return 0;\n}\n```",
  "1872": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint stoneGameVIII(vector<int>& p1, vector<int>& p2) {\n    int n = p1.size();\n    vector<vector<int>> dp(n, vector<int>(n));\n    \n    for (int i = 0; i < n; i++) {\n        dp[i][i] = max(p1[i], p2[i]);\n    }\n    \n    for (int len = 3; len <= n; len++) {\n        for (int i = 0; i + len - 1 < n; i++) {\n            int j = i + len - 1;\n            dp[i][j] = max(p1[i] - p2[j], min(dp[i + 1][j - 1], dp[i][j - 1]) + (p1[i] > p2[j] ? p1[i] : p2[j]));\n        }\n    }\n    \n    return dp[0][n - 1];\n}\n\nint main() {\n    vector<int> p1 = {6,5,4,3};\n    int res1 = stoneGameVIII(p1, vector<int>());\n    cout << \"Test case 1: \" << res1 << endl;\n\n    vector<int> p2 = {10};\n    int res2 = stoneGameVIII(p2, vector<int>());\n    cout << \"Test case 2: \" << res2 << endl;\n\n    vector<int> p3 = {1,3,10,6,1,2,15,1};\n    int res3 = stoneGameVIII(p3, vector<int>());\n    cout << \"Test case 3: \" << res3 << endl;\n    \n    return 0;\n}\n```",
  "1873": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int specialBonus(std::vector<int>& bonuses) {\n        int total = 0;\n        for (int bonus : bonuses) {\n            total += bonus;\n        }\n        return total / bonuses.size();\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<int> bonuses1 = {10, 20, 30};\n    int result1 = solution.specialBonus(bonuses1);\n    if (result1 == 20) {\n        std::cout << \"Test case 1: PASS\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: FAIL\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> bonuses2 = {100, 200};\n    int result2 = solution.specialBonus(bonuses2);\n    if (result2 == 150) {\n        std::cout << \"Test case 2: PASS\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: FAIL\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> bonuses3 = {};\n    int result3 = solution.specialBonus(bonuses3);\n    if (result3 == 0) {\n        std::cout << \"Test case 3: PASS\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: FAIL\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1874": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint minProductSum(std::vector<int>& nums1, std::vector<int>& nums2) {\n    int m = nums1.size(), n = nums2.size();\n    std::sort(nums1.begin(), nums1.end());\n    std::sort(nums2.begin(), nums2.end(), std::greater<int>());\n    \n    int productSum = 0;\n    for (int i = 0; i < std::min(m, n); ++i) {\n        productSum += nums1[i] * nums2[i];\n    }\n    \n    return productSum;\n}\n\nint main() {\n    {\n        std::vector<int> nums1 = {4, 8};\n        std::vector<int> nums2 = [3, 6];\n        int result = minProductSum(nums1, nums2);\n        if (result == 37) {\n            std::cout << \"Test case 1 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 1 failed. Expected 37 but got \" << result << \".\" << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> nums1 = {2, 3};\n        std::vector<int> nums2 = [4, 5];\n        int result = minProductSum(nums1, nums2);\n        if (result == 28) {\n            std::cout << \"Test case 2 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 2 failed. Expected 28 but got \" << result << \".\" << std::endl;\n        }\n    }\n\n    {\n        std::vector<int> nums1 = [5, 6];\n        std::vector<int> nums2 = {7};\n        int result = minProductSum(nums1, nums2);\n        if (result == 35) {\n            std::cout << \"Test case 3 passed.\" << std::endl;\n        } else {\n            std::cout << \"Test case 3 failed. Expected 35 but got \" << result << \".\" << std::endl;\n        }\n    }\n\n    return 0;\n}",
  "1875": "```\n#include <iostream>\n#include <vector>\n#include <map>\n\nstruct Employee {\n    int id;\n    int salary;\n};\n\nvoid groupEmployeesBySalary(std::vector<Employee>& employees, std::map<int, std::vector<int>>& salaryToIds) {\n    for (Employee& employee : employees) {\n        if (!salaryToIds.count(employee.salary)) {\n            salaryToIds[employee.salary] = {};\n        }\n        salaryToIds[employee.salary].push_back(employee.id);\n    }\n}\n\nint main() {\n    std::vector<Employee> employees = {{1, 200}, {2, 300}, {3, 400}, {4, 500}, {5, 600}};\n    std::map<int, std::vector<int>> salaryToIds;\n\n    groupEmployeesBySalary(employees, salaryToIds);\n\n    for (const auto& pair : salaryToIds) {\n        std::cout << \"Salary: \" << pair.first << \", Employees: \";\n        for (int id : pair.second) {\n            std::cout << id << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    // Test case 2\n    employees = {{1, 200}, {2, 300}, {3, 400}, {4, 200}};\n    salaryToIds.clear();\n    groupEmployeesBySalary(employees, salaryToIds);\n\n    for (const auto& pair : salaryToIds) {\n        std::cout << \"Salary: \" << pair.first << \", Employees: \";\n        for (int id : pair.second) {\n            std::cout << id << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    // Test case 3\n    employees = {{1, 200}, {2, 300}, {3, 400}, {4, 500}};\n    salaryToIds.clear();\n    groupEmployeesBySalary(employees, salaryToIds);\n\n    for (const auto& pair : salaryToIds) {\n        std::cout << \"Salary: \" << pair.first << \", Employees: \";\n        for (int id : pair.second) {\n            std::cout << id << \" \";\n        }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1876": "```\n#include <iostream>\n#include <vector>\n\nint numDistinct(int A[], int N) {\n    int ans = 0;\n    for (int i = 0; i <= N - 3; i++) {\n        vector<char> temp(3);\n        for (int j = 0; j < 3; j++) {\n            temp[j] = 'a' + A[i + j];\n        }\n        sort(temp.begin(), temp.end());\n        if (find(temp.begin(), temp.end(), 'x') == temp.end()) {\n            ans++;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int A[] = {2, 4, 6};\n    std::cout << \"Test case 1: \" << numDistinct(A, sizeof(A)/sizeof(A[0])) << std::endl;\n\n    int B[] = {3, 5};\n    std::cout << \"Test case 2: \" << numDistinct(B, sizeof(B)/sizeof(B[0])) << std::endl;\n\n    int C[] = {1, 1, 2, 2};\n    std::cout << \"Test case 3: \" << numDistinct(C, sizeof(C)/sizeof(C[0])) << std::endl;\n}\n```",
  "1877": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minPairSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int left = 0, right = nums.size() - 1;\n        int maxSum = 0;\n        while (left < right) {\n            maxSum = max(maxSum, nums[left] + nums[right]);\n            if (nums[left] == nums[left + 1]) {\n                left++;\n            } else if (nums[right] == nums[right - 1]) {\n                right--;\n            } else {\n                left++, right--;\n            }\n        }\n        return maxSum;\n    }\n};\n\nint main() {\n    Solution solution = Solution();\n    \n    // Test case 1\n    vector<int> nums1 = {3,2,5,0,2,2};\n    cout << \"Test case 1: \" << solution.minPairSum(nums1) << endl;\n\n    // Test case 2\n    vector<int> nums2 = {1,4,3,2};\n    cout << \"Test case 2: \" << solution.minPairSum(nums2) << endl;\n\n    // Test case 3\n    vector<int> nums3 = {10,12};\n    cout << \"Test case 3: \" << solution.minPairSum(nums3) << endl;\n    \n    return 0;\n}\n```",
  "1878": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Rhombus {\n    int sum;\n    int x, y;\n};\n\npriority_queue<Rhombus*, vector<Rhombus*>, greater<Rhombus*>> pq;\n\nint getBiggestSums(vector<vector<int>>& grid) {\n    int m = grid.size();\n    if (m == 0) return 0;\n\n    priority_queue<Rhombus*> pq;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j <= i; j++) {\n            Rhombus* rhombus = new Rhombus();\n            rhombus->sum = grid[i][j] + (i > 0 ? grid[i-1][j] : 0) + (j > 0 ? grid[i][j-1] : 0);\n            rhombus->x = i;\n            rhombus->y = j;\n            pq.push(rhombus);\n        }\n    }\n\n    int biggestSum = 0;\n    for (int i = 0; i < 3; i++) {\n        Rhombus* rhombus = pq.top();\n        pq.pop();\n        biggestSum += rhombus->sum;\n    }\n\n    return biggestSum;\n}\n\nint main() {\n    vector<vector<int>> grid1 = {{3,5},{6,7}};\n    cout << getBiggestSums(grid1) << endl;  // Output: 20\n\n    vector<vector<int>> grid2 = {{1,2,3},{4,5,6},{10,14,17},{8,11,16}};\n    cout << getBiggestSums(grid2) << endl;  // Output: 27\n\n    vector<vector<int>> grid3 = {{0,1,2,3,4,5},{1,3,4,9,12,15},{2,7,10,14,17,18},{6,8,11,13,16,19}};\n    cout << getBiggestSums(grid3) << endl;  // Output: 39\n\n    return 0;\n}\n```",
  "1879": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int findMinXOR(vector<int>& nums) {\n        int res = INT_MAX;\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                res = min(res, nums[i] ^ nums[j]);\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<int> test1 = {2,4};\n    cout << \"Test Case 1: The minimum XOR sum is \" << solution.findMinXOR(test1) << endl;\n\n    // Test case 2\n    vector<int> test2 = {10,40};\n    cout << \"Test Case 2: The minimum XOR sum is \" << solution.findMinXOR(test2) << endl;\n\n    // Test case 3\n    vector<int> test3 = {4,8,2};\n    cout << \"Test Case 3: The minimum XOR sum is \" << solution.findMinXOR(test3) << endl;\n    \n    return 0;\n}",
  "1880": "```\n#include <iostream>\n#include <string>\n\nbool sumOfTwoWords(std::string w1, std::string w2) {\n    int n = w1.size() + w2.size();\n    for (int i = 0; i <= n - w1.size(); i++) {\n        if (w1 == w2.substr(i, w1.size())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << (sumOfTwoWords(\"aaa\", \"aa\") ? \"Pass\" : \"Fail\") << std::endl;\n    std::cout << \"Test case 2: \" << (sumOfTwoWords(\"abca\", \"abc\")) << std::endl;\n    std::cout << \"Test case 3: \" << (sumOfTwoWords(\"applepenapple\", \"pineapple\")) << std::endl;\n    return 0;\n}\n```",
  "1881": "```\n#include <iostream>\n#include <string>\n\nint maxValueAfterInsertions(std::string word1, std::string word2) {\n    int maxLen = std::max(word1.length(), word2.length());\n    int res = 0;\n    for (int i = 0; i <= maxLen; i++) {\n        if ((i < word1.length() && (word1[i] > '9' || word1[i] == '1')) ||\n            (i < word2.length() && (word2[i] > '9' || word2[i] == '1'))) {\n            res = 0;\n            break;\n        }\n        if (i < word1.length()) {\n            if (word1[i] != word2[i]) {\n                res = 0;\n                break;\n            }\n        } else if (i < word2.length()) {\n            if (word2[i] > '9' || word2[i] == '1') {\n                res++;\n            }\n        } else {\n            if (word1[i - 1] != '1' && word1[i - 1] > '9') {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::cout << maxValueAfterInsertions(\"1119\", \"911\") << std::endl; // output: 3\n    std::cout << maxValueAfterInsertions(\"4825\", \"724\") << std::endl; // output: 4\n    std::cout << maxValueAfterInsertions(\"1111\", \"\") << std::endl; // output: 4\n    return 0;\n}\n```",
  "1882": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int assignTasks(vector<int>& tasks, vector<vector<int>>& workers) {\n        priority_queue<pair<int, int>> pq;\n        for (int i = 0; i < tasks.size(); i++) {\n            pq.push({tasks[i], i});\n        }\n        \n        vector<int> ans(tasks.size(), -1);\n        int idx = 0;\n        while (!pq.empty()) {\n            auto [task, taskIdx] = pq.top();\n            pq.pop();\n            if (idx >= workers[0].size() && idx < workers[0].size() + workers[1].size()) {\n                idx++;\n            } else {\n                ans[taskIdx] = task;\n                idx++;\n            }\n        }\n        \n        return max(0, accumulate(ans.begin(), ans.end(), 0) - tasks.size());\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> tasks1({2,4,6,8});\n    vector<vector<int>> workers1 {{1,3},{2,5},{7,9}};\n    cout << \"Test Case 1: \" << solution.assignTasks(tasks1, workers1) << endl;\n\n    // Test Case 2\n    vector<int> tasks2({16,18,5});\n    vector<vector<int>> workers2 {{1,1,4,8},{10,11,12,19}};\n    cout << \"Test Case 2: \" << solution.assignTasks(tasks2, workers2) << endl;\n\n    // Test Case 3\n    vector<int> tasks3({20,19,18,17};\n    vector<vector<int>> workers3 {{1,2},{4,5,6},{7,8}};\n    cout << \"Test Case 3: \" << solution.assignTasks(tasks3, workers3) << endl;\n\n    return 0;\n}\n```",
  "1883": "```\n#include <iostream>\n#include <vector>\n\nint minSkips(std::vector<int>& dist, int hour) {\n    int n = dist.size();\n    std::vector<int> dp(n + 1, INT_MAX);\n    dp[0] = 0;\n    \n    for (int i = 1; i <= n; ++i) {\n        if (dp[i - 1] != INT_MAX) {\n            int need = dist[i - 1];\n            int skips = 0;\n            while (hour < need) {\n                hour++;\n                skips++;\n            }\n            dp[i] = std::min(dp[i], dp[i - 1] + skips);\n        }\n    }\n    \n    return dp[n] == INT_MAX ? -1 : dp[n];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> dist1 = {10, 2, 7};\n    int hour1 = 9;\n    std::cout << \"Test case 1: \" << minSkips(dist1, hour1) << std::endl;\n\n    // Test case 2\n    std::vector<int> dist2 = {3, 5, 4};\n    int hour2 = 6;\n    std::cout << \"Test case 2: \" << minSkips(dist2, hour2) << std::endl;\n\n    // Test case 3\n    std::vector<int> dist3 = {};\n    int hour3 = 0;\n    std::cout << \"Test case 3: \" << minSkips(dist3, hour3) << std::endl;\n\n    return 0;\n}\n```",
  "1884": "```\n#include <iostream>\nusing namespace std;\n\nint superEggDrop(int n, int k) {\n    if(n == 1 || k == 1)\n        return k;\n    int dp[n+1][k+1];\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= k; j++) {\n            dp[i][j] = i + j - 1;\n            if(j > 1)\n                dp[i][j] = min(dp[i][j], 1 + max(min(i-1, j-1), superEggDrop(i-1, j-1)));\n        }\n    }\n    return dp[n][k];\n}\n\nint main() {\n    cout << \"Test Case 1: \" << superEggDrop(2, 3) << endl;\n    cout << \"Test Case 2: \" << superEggDrop(5, 3) << endl;\n    cout << \"Test Case 3: \" << superEggDrop(1, 10) << endl;\n    return 0;\n}\n```",
  "1885": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countPairs(vector<int>& arr1, vector<int>& arr2) {\n        int res = 0;\n        sort(arr1.begin(), arr1.end());\n        sort(arr2.begin(), arr2.end());\n        \n        int i = 0, j = 0;\n        while (i < arr1.size() && j < arr2.size()) {\n            if (arr1[i] <= arr2[j]) {\n                res += j - i;\n                i++;\n            } else {\n                j++;\n            }\n        }\n        \n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<int> arr1 = {1, 3, 5};\n    vector<int> arr2 = {6, 7, 9};\n    cout << \"Test Case 1: \" << solution.countPairs(arr1, arr2) << endl; \n\n    // Test Case 2\n    arr1.clear();\n    arr1.push_back(1);\n    arr2.clear();\n    arr2.push_back(3);\n    cout << \"Test Case 2: \" << solution.countPairs(arr1, arr2) << endl; \n\n    // Test Case 3\n    arr1.clear();\n    arr1.push_back(-1);\n    arr1.push_back(0);\n    arr1.push_back(1);\n    arr2.clear();\n    arr2.push_back(0);\n    arr2.push_back(1);\n    cout << \"Test Case 3: \" << solution.countPairs(arr1, arr2) << endl; \n\n    return 0;\n}\n```",
  "1886": "```\n#include <iostream>\n#include <vector>\n\nbool findRotation(std::vector<std::vector<int>>& mat) {\n    int m = mat.size();\n    if (m == 0) return true;\n    int n = mat[0].size();\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (mat[i][j] != mat[m - 1 - j][i]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    std::vector<std::vector<int>> mat1{{0,1},{2,3}};\n    std::cout << findRotation(mat1) << std::endl; // Should print: 1\n\n    std::vector<std::vector<int>> mat2{{1,2,3},{4,5,6},{7,8,9}};\n    std::cout << findRotation(mat2) << std::endl; // Should print: 0\n\n    std::vector<std::vector<int>> mat3{{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}};\n    std::cout << findRotation(mat3) << std::endl; // Should print: 0\n\n    return 0;\n}\n```",
  "1887": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint totalSteps(std::vector<int>& arr) {\n    int res = 0;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] != arr[0]) {\n            res += abs(arr[i] - arr[0]);\n            arr[i] = arr[0];\n        }\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> arr1 = {9};\n    std::cout << \"Test case 1: \" << totalSteps(arr1) << std::endl;\n\n    std::vector<int> arr2 = {5,10,15};\n    std::cout << \"Test case 2: \" << totalSteps(arr2) << std::endl;\n\n    std::vector<int> arr3 = {2,10,6};\n    std::cout << \"Test case 3: \" << totalSteps(arr3) << std::endl;\n    \n    return 0;\n}\n```",
  "1888": "```\n#include <iostream>\n#include <vector>\n\nint minFlips(std::string s) {\n    int n = s.size();\n    std::vector<int> res(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        if ((s[i - 1] == '0' && i % 2 != 0) || (s[i - 1] == '1' && i % 2 == 0)) {\n            res[i] = res[i - 1] + 1;\n        } else {\n            res[i] = res[i - 1];\n        }\n    }\n    return res[n];\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << minFlips(\"001110\") << std::endl; // Output: 3\n    std::cout << \"Test Case 2: \" << minFlips(\"010101\") << std::endl; // Output: 0\n    std::cout << \"Test Case 3: \" << minFlips(\"111000\") << std::endl; // Output: 6\n\n    return 0;\n}\n```",
  "1889": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minWastedSpace(vector<vector<int>>& packages) {\n        if (packages.empty()) return 0;\n        \n        int n = packages.size();\n        vector<int> dp(n + 1);\n        for (int i = 0; i < n; ++i) {\n            int curWaste = 0;\n            for (int j = 0; j <= i; ++j) {\n                if (curWaste + packages[i][0] - packages[j][0] > dp[j]) {\n                    dp[i] = max(dp[i], dp[j] + packages[i][1] - packages[i][0]);\n                    curWaste = 0;\n                } else {\n                    curWaste += packages[i][0] - packages[j][0];\n                }\n            }\n        }\n        \n        int res = dp[n - 1];\n        for (int i = 0; i < n; ++i) {\n            if (res + packages[n - 1][1] - packages[i][1] > dp[i]) {\n                return res;\n            }\n        }\n        \n        return min(res, packages[0][1]);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> packages1 = {{5,10},{2,5},{4,7},{3,9}};\n    cout << \"Test case 1: \" << solution.minWastedSpace(packages1) << endl;  // Output: 10\n\n    // Test case 2\n    vector<vector<int>> packages2 = {{2,4},{3,5},{1,2}};\n    cout << \"Test case 2: \" << solution.minWastedSpace(packages2) << endl;  // Output: 3\n\n    // Test case 3\n    vector<vector<int>> packages3 = {{10,20}};\n    cout << \"Test case 3: \" << solution.minWastedSpace(packages3) << endl;  // Output: 0\n\n    return 0;\n}\n```",
  "1890": "```\n#include <iostream>\n#include <string>\n#include <vector>\n\nclass Solution {\npublic:\n    std::string findLatest(int n, const std::vector<int>& logs) {\n        int lastLogin = -1;\n        std::vector<std::pair<int, int>> logMap;\n        for (int i = 0; i < logs.size(); ++i) {\n            if (logs[i] == 1) {\n                if (!logMap.empty()) {\n                    --logMap.back().second;\n                    if (logMap.back().second == 0) {\n                        logMap.pop_back();\n                    }\n                } else {\n                    lastLogin = i;\n                }\n            } else {\n                int userId = logs[i] - 2;\n                for (auto& pair : logMap) {\n                    if (pair.first == userId) {\n                        ++pair.second;\n                        return std::to_string(i);\n                    }\n                }\n                logMap.emplace_back(userId, 1);\n            }\n        }\n        return std::to_string(lastLogin);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    int n = 5;\n    std::vector<int> logs = {4,3,2,2,1};\n    std::cout << \"Latest login for \" << n << \" users: \" << solution.findLatest(n, logs) << std::endl;\n\n    // Test Case 2\n    n = 1;\n    logs = {1};\n    std::cout << \"Latest login for \" << n << \" user: \" << solution.findLatest(n, logs) << std::endl;\n\n    // Test Case 3\n    n = 2;\n    logs = {0,1};\n    std::cout << \"Latest login for \" << n << \" users: \" << solution.findLatest(n, logs) << std::endl;\n\n    return 0;\n}\n```",
  "1891": "```\n#include <iostream>\n#include <vector>\n\nint cutRibbons(int len, std::vector<int>& cuts) {\n    int res = INT_MAX;\n    for (int i = 0; i <= len; ++i) {\n        int left = len - i;\n        bool canCut = true;\n        for (int j : cuts) {\n            if (j > left) {\n                canCut = false;\n                break;\n            }\n            left -= j;\n        }\n        if (canCut && left == 0) {\n            res = std::min(res, i);\n        }\n    }\n    return res;\n}\n\nint main() {\n    int len1 = 9; // Test case 1\n    std::vector<int> cuts1 = {3, 3};\n    std::cout << \"Test Case 1: \" << cutRibbons(len1, cuts1) << std::endl;\n\n    int len2 = 50000000; // Test case 2\n    std::vector<int> cuts2 = {1, 4, 15};\n    std::cout << \"Test Case 2: \" << cutRibbons(len2, cuts2) << std::endl;\n\n    int len3 = 14; // Test case 3\n    std::vector<int> cuts3 = {5, 6, 7};\n    std::cout << \"Test Case 3: \" << cutRibbons(len3, cuts3) << std::endl;\n    \n    return 0;\n}\n```",
  "1893": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isCovered(vector<vector<int>>& ranges) {\n        int maxVal = 0;\n        for (const auto &range : ranges) {\n            maxVal = max(maxVal, range[1]);\n        }\n        \n        vector<bool> covered(maxVal + 1, false);\n        for (const auto &range : ranges) {\n            for (int i = range[0]; i <= range[1]; ++i) {\n                covered[i] = true;\n            }\n        }\n        \n        for (int i = 0; i <= maxVal; ++i) {\n            if (!covered[i]) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    vector<vector<int>> ranges1 = {{1,10},{4,5}};\n    cout << (solution.isCovered(ranges1) ? \"True\" : \"False\") << endl;  // Expected output: True\n    \n    // Test case 2\n    vector<vector<int>> ranges2 = {{1,3},{6,7}};\n    cout << (solution.isCovered(ranges2) ? \"True\" : \"False\") << endl;  // Expected output: False\n    \n    // Test case 3\n    vector<vector<int>> ranges3 = {{1,13},{10,15},{18,19},{20,23}};\n    cout << (solution.isCovered(ranges3) ? \"True\" : \"False\") << endl;  // Expected output: True\n    \n    return 0;\n}\n```",
  "1892": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> recommend(vector<vector<string>>& watchedHistory, int user) {\n        unordered_map<string, int> movieIdToScore;\n        for (const auto& row : watchedHistory) {\n            if (row[0] == to_string(user)) {\n                movieIdToScore[row[1]] = stoi(row[2]);\n            }\n        }\n\n        vector<vector<int>> recommendations;\n        for (int i = 1; i <= 5; i++) {\n            int maxScore = 0;\n            string recommendedMovie;\n            for (const auto& pair : movieIdToScore) {\n                if (pair.second > maxScore && !count(recommendations.begin(), recommendations.end(), pair.first)) {\n                    maxScore = pair.second;\n                    recommendedMovie = pair.first;\n                }\n            }\n            recommendations.push_back({user, stoi(recommendedMovie)});\n        }\n\n        return recommendations;\n    }\n};\n\nint main() {\n    vector<vector<string>> watchedHistory1 = {{\"0\", \"5\", \"3\"}, {\"0\", \"2\", \"4\"}};\n    Solution solution;\n    auto result1 = solution.recommend(watchedHistory1, 0);\n    cout << \"Test case 1: \";\n    for (const auto& row : result1) {\n        cout << \"(\" << row[0] << \", \" << row[1] << \") \";\n    }\n    cout << endl;\n\n    vector<vector<string>> watchedHistory2 = {{\"1\", \"5\", \"4\"}, {\"1\", \"3\", \"2\"}};\n    auto result2 = solution.recommend(watchedHistory2, 1);\n    cout << \"Test case 2: \";\n    for (const auto& row : result2) {\n        cout << \"(\" << row[0] << \", \" << row[1] << \") \";\n    }\n    cout << endl;\n\n    vector<vector<string>> watchedHistory3 = {{\"0\", \"5\", \"3\"}, {\"0\", \"4\", \"2\"}};\n    auto result3 = solution.recommend(watchedHistory3, 0);\n    cout << \"Test case 3: \";\n    for (const auto& row : result3) {\n        cout << \"(\" << row[0] << \", \" << row[1] << \") \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1894": "```\n#include <iostream>\n#include <vector>\n\nint minTime(int n, int firstStudent, int* watchType) {\n    int res = 0;\n    for (int i = 1; i <= n; i++) {\n        if (watchType[i] == 1) {\n            res += i - firstStudent + 1;\n        } else {\n            if (i > firstStudent) {\n                res += i - firstStudent;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    // Test case 1\n    int n1 = 4;\n    int firstStudent1 = 2;\n    int watchType1[] = {1, 0, 1, 0};\n    std::cout << \"Test Case 1: \" << minTime(n1, firstStudent1, watchType1) << std::endl;\n\n    // Test case 2\n    int n2 = 3;\n    int firstStudent2 = 1;\n    int watchType2[] = {0, 1, 0};\n    std::cout << \"Test Case 2: \" << minTime(n2, firstStudent2, watchType2) << std::endl;\n\n    // Test case 3\n    int n3 = 5;\n    int firstStudent3 = 3;\n    int watchType3[] = {1, 0, 0, 1, 0};\n    std::cout << \"Test Case 3: \" << minTime(n3, firstStudent3, watchType3) << std::endl;\n\n    return 0;\n}\n```",
  "1895": "```\n#include <iostream>\n#include <vector>\n\nint maxSize(std::vector<std::vector<int>>& grid) {\n    int n = grid.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n                int left = j, right = j, top = i, bottom = i;\n                while (left > 0 && grid[top][left - 1] == 1)\n                    --left;\n                while (right < n - 1 && grid[top][right + 1] == 1)\n                    ++right;\n                while (top > 0 && grid[top - 1][j] == 1)\n                    --top;\n                while (bottom < n - 1 && grid[bottom + 1][j] == 1)\n                    ++bottom;\n                int magic = (i - top + 1) * (j - left + 1);\n                if (magic > right - left + 1)\n                    return n;\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    std::vector<std::vector<int>> grid1 {{0,1},{1,1}};\n    std::cout << \"Test case 1: \" << maxSize(grid1) << std::endl;\n\n    std::vector<std::vector<int>> grid2 {{0,0,0},\n                                          {1,1,0},\n                                          {0,1,0}};\n    std::cout << \"Test case 2: \" << maxSize(grid2) << std::endl;\n\n    std::vector<std::vector<int>> grid3 {{1,1,1,1},\n                                          {1,0,0,1},\n                                          {1,0,1,1},\n                                          {1,1,1,1}};\n    std::cout << \"Test case 3: \" << maxSize(grid3) << std::endl;\n\n    return 0;\n}\n```",
  "1896": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nint minFlips(string expr) {\n    int n = expr.size();\n    vector<int> dp(n + 1, 0);\n    \n    for (int i = 1; i <= n; ++i) {\n        if (expr[i - 1] == 'X') {\n            dp[i] = max(dp[i - 1] + 2, dp[i - 1]);\n        } else {\n            dp[i] = dp[i - 1];\n        }\n    }\n    \n    int res = dp[n];\n    \n    for (int i = n; i > 0 && expr[i - 1] != 'X'; --i) {\n        if (expr[i - 1] == expr[n]) {\n            res = min(res, dp[i - 1]);\n        } else {\n            res = min(res, dp[i - 1] + 2);\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    cout << minFlips(\"XOR\") << endl; // Output: 0\n    cout << minFlips(\"FXORFX\") << endl; // Output: 3\n    cout << minFlips(\"XXOR\") << endl; // Output: 1\n    \n    return 0;\n}\n```",
  "1897": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nint numMovesToAppearEqual(std::vector<std::string>& words) {\n    int n = words.size();\n    if (n == 0) return 0;\n    std::unordered_map<char, int> count;\n    for (const auto& word : words) {\n        for (char c : word) {\n            count[c]++;\n        }\n    }\n    int moves = 0;\n    for (int i = 1; i < n; i++) {\n        std::unordered_map<char, int> diff;\n        for (char c : words[i]) {\n            diff[c] = diff.count(c)?diff[c]-1:0;\n        }\n        for (const auto& p : count) {\n            if (p.second > 0 && diff.find(p.first) == diff.end()) {\n                moves += p.second;\n                break;\n            } else if (p.second < 0 && diff.find(p.first) != diff.end() && --diff[p.first] == 0) {\n                p.second = 0;\n            }\n        }\n    }\n    return moves;\n}\n\nint main() {\n    std::vector<std::string> words1 = {\"abcdef\", \"abcdfc\", \"abcdcf\"};\n    std::cout << numMovesToAppearEqual(words1) << std::endl;\n\n    std::vector<std::string> words2 = {\"cool\",\"lock\",\"cook\"};\n    std::cout << numMovesToAppearEqual(words2) << std::endl;\n\n    std::vector<std::string> words3 = {\"elcuor\",\"culer\",\"cuperc\"};\n    std::cout << numMovesToAppearEqual(words3) << std::endl;\n\n    return 0;\n}",
  "1898": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint maximumRemovableCharacters(std::string s) {\n    int n = s.length();\n    std::vector<int> left(n), right(n);\n    \n    for (int i = 0; i < n; ++i) {\n        left[i] = (s[i] == 'a') ? 1 : 0;\n    }\n    \n    for (int i = n - 1; i >= 0; --i) {\n        right[i] = (s[i] == 'b') ? 1 : 0;\n    }\n    \n    int res = 0, l = 0, r = 0;\n    while (l < n && r < n) {\n        if (left[l] && right[r]) {\n            ++res;\n            ++l; ++r;\n        } else if (left[l]) {\n            ++l;\n        } else if (right[r]) {\n            ++r;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::cout << maximumRemovableCharacters(\"aab\") << std::endl; // 2\n    std::cout << maximumRemovableCharacters(\"aaabb\") << std::endl; // 4\n    std::cout << maximumRemovableCharacters(\"baab\") << std::endl; // 3\n    return 0;\n}\n```",
  "1899": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<int>> mergeTriplets(vector<vector<int>>& triplets, vector<int>& targets) {\n        sort(triplets.begin(), triplets.end());\n        sort(targets.begin(), targets.end());\n\n        int i = 0;\n        int j = 0;\n        vector<vector<int>> result;\n\n        while (i < triplets.size() && j < targets.size()) {\n            if (triplets[i][0] <= targets[j]) {\n                if (triplets[i][1] >= targets[j] && triplets[i][2] >= targets[j]) {\n                    result.push_back({triplets[i][0], triplets[i][1], targets[j]});\n                    i++;\n                    j++;\n                } else if (triplets[i][1] <= targets[j]) {\n                    i++;\n                } else {\n                    j++;\n                }\n            } else {\n                i++;\n            }\n        }\n\n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> triplets1 = {{1,4},{2,5},{7,10}};\n    vector<int> targets1 = {5};\n    vector<vector<int>> result1 = solution.mergeTriplets(triplets1, targets1);\n    cout << \"Test case 1: \";\n    for (int i = 0; i < result1.size(); i++) {\n        cout << \"[\" << result1[i][0] << \", \" << result1[i][1] << \", \" << result1[i][2] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> triplets2 = {{1,2},{4,5},{7,8}};\n    vector<int> targets2 = {3};\n    vector<vector<int>> result2 = solution.mergeTriplets(triplets2, targets2);\n    cout << \"Test case 2: \";\n    for (int i = 0; i < result2.size(); i++) {\n        cout << \"[\" << result2[i][0] << \", \" << result2[i][1] << \", \" << result2[i][2] << \"] \";\n    }\n    cout << endl;\n\n    vector<vector<int>> triplets3 = {{1,5},{2,6},{7,11}};\n    vector<int> targets3 = {8};\n    vector<vector<int>> result3 = solution.mergeTriplets(triplets3, targets3);\n    cout << \"Test case 3: \";\n    for (int i = 0; i < result3.size(); i++) {\n        cout << \"[\" << result3[i][0] << \", \" << result3[i][1] << \", \" << result3[i][2] << \"] \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1900": "```\n#include <iostream>\n#include <vector>\n\nint earliestAndLatest(int n, std::vector<std::vector<int>>& rounds) {\n    int m = rounds.size();\n    int ans[2] = {-1, -1};\n    for (int i = 0; i < m; i++) {\n        int p = rounds[i][0], q = rounds[i][1];\n        if (ans[0] == -1 || p < ans[0]) {\n            ans[0] = p;\n        }\n        if (ans[1] == -1 || q > ans[1]) {\n            ans[1] = q;\n        }\n    }\n    return ans[0] + 1, ans[1] + 1;  // Add 1 because the first round is numbered as 1.\n}\n\nint main() {\n    std::vector<std::vector<int>> rounds1 = {{4,8},{10,14},{19,20}};\n    int earliest1, latest1;\n    earliestAndLatest(6, rounds1);\n    std::tie(earliest1, latest1) = earliestAndLatest(6, rounds1);\n    if (earliest1 == 2 && latest1 == 3)\n        std::cout << \"Test case 1 passed.\\n\";\n    else\n        std::cout << \"Test case 1 failed.\\n\";\n\n    std::vector<std::vector<int>> rounds2 = {{2,11},{14,22},{20,24}};\n    int earliest2, latest2;\n    std::tie(earliest2, latest2) = earliestAndLatest(5, rounds2);\n    if (earliest2 == 1 && latest2 == 3)\n        std::cout << \"Test case 2 passed.\\n\";\n    else\n        std::cout << \"Test case 2 failed.\\n\";\n\n    std::vector<std::vector<int>> rounds3 = {{1,5},{4,8}};\n    int earliest3, latest3;\n    std::tie(earliest3, latest3) = earliestAndLatest(7, rounds3);\n    if (earliest3 == 1 && latest3 == 2)\n        std::cout << \"Test case 3 passed.\\n\";\n    else\n        std::cout << \"Test case 3 failed.\\n\";\n\n    return 0;\n}\n```",
  "1901": "```\n#include <iostream>\n#include <vector>\n\nint findPeakElement(std::vector<std::vector<int>>& matrix) {\n    int m = matrix.size();\n    if (m == 0) return -1;\n    int n = matrix[0].size();\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if ((i == 0 || matrix[i][j] >= matrix[i-1][j]) &&\n                (i == m - 1 || matrix[i][j] >= matrix[i+1][j]) &&\n                (j == 0 || matrix[i][j] >= matrix[i][j-1]) &&\n                (j == n - 1 || matrix[i][j] >= matrix[i][j+1]))\n                return i * n + j;\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    std::vector<std::vector<int>> matrix1 = {{1,2,3},{4,5,6},{7,8,9}};\n    std::cout << \"Test case 1: \" << findPeakElement(matrix1) << std::endl;\n\n    std::vector<std::vector<int>> matrix2 = {{1,2},{3,4}};\n    std::cout << \"Test case 2: \" << findPeakElement(matrix2) << std::endl;\n\n    std::vector<std::vector<int>> matrix3 = {{0,0,1},{0,0,1}};\n    std::cout << \"Test case 3: \" << findPeakElement(matrix3) << std::endl;\n\n    return 0;\n}",
  "1903": "```\n#include <iostream>\n#include <string>\n\nint largestNumber(std::string num) {\n    std::string result = \"\";\n    for (char c : num) {\n        if (c >= '0' && c <= '9') {\n            int n = c - '0';\n            while ((n * 10 + (c + 1) - '0') % 2 == 0 && c + 1 < '9' && c + 1 <= num.back()) {\n                c++;\n            }\n        }\n        result += c;\n    }\n    return std::stoi(result);\n}\n\nint main() {\n    std::cout << largestNumber(\"52\") << std::endl; // Output: 5\n    std::cout << largestNumber(\"0a\") << std::endl; // Output: 0\n    std::cout << largestNumber(\"12345\") << std::endl; // Output: 54321\n\n    return 0;\n}\n```",
  "1902": "```\n#include <iostream>\n#include <vector>\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == NULL) return 0;\n        int left = maxDepth(root->left);\n        int right = maxDepth(root->right);\n        return (left > right) ? left + 1 : right + 1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    TreeNode* root1 = new TreeNode(2);\n    root1->left = new TreeNode(1);\n    root1->right = new TreeNode(3);\n    std::cout << \"Test Case 1: Depth of BST is \" << solution.maxDepth(root1) << std::endl;\n\n    // Test Case 2\n    TreeNode* root2 = new TreeNode(5);\n    root2->left = new TreeNode(3);\n    root2->right = new TreeNode(6);\n    root2->left->left = new TreeNode(2);\n    root2->left->right = new TreeNode(4);\n    std::cout << \"Test Case 2: Depth of BST is \" << solution.maxDepth(root2) << std::endl;\n\n    // Test Case 3\n    TreeNode* root3 = NULL;\n    std::cout << \"Test Case 3: Depth of BST is \" << solution.maxDepth(root3) << std::endl;\n\n    return 0;\n}\n```",
  "1904": "```\n#include <iostream>\nusing namespace std;\n\nclass Solution {\npublic:\n    int numberOfRounds(string logistics) {\n        int totalMinutes = 0;\n        for (int i = 0; i < logistics.size(); i++) {\n            if (logistics[i] == '1') {\n                totalMinutes += 15 + (i - 2);\n            }\n        }\n        return min(24, totalMinutes / 15) * 15;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test Case 1: \" << solution.numberOfRounds(\"00110100\") << endl; // expected output: 6\n    cout << \"Test Case 2: \" << solution.numberOfRounds(\"1111\") << endl; // expected output: 12\n    cout << \"Test Case 3: \" << solution.numberOfRounds(\"0000\") << endl; // expected output: 0\n\n    return 0;\n}\n```",
  "1906": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<int> getMinDifference(std::vector<std::vector<int>>& arr) {\n        int n = arr.size();\n        std::sort(arr.begin(), arr.end());\n        \n        std::vector<int> res;\n        for (int i = 0; i < n - 1; ++i) {\n            res.push_back(arr[i + 1][0] - arr[i][1]);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::vector<int>> testArr1 = {{5, 15}, {10, 20}};\n    std::vector<int> result1 = solution.getMinDifference(testArr1);\n    if (result1[0] == 2) {\n        std::cout << \"Test case 1 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed: expected 2, got \" << result1[0] << std::endl;\n    }\n\n    // Test case 2\n    std::vector<std::vector<int>> testArr2 = {{1, 3}, {2, 4}, {5, 7}};\n    std::vector<int> result2 = solution.getMinDifference(testArr2);\n    if (result2[0] == 1) {\n        std::cout << \"Test case 2 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed: expected 1, got \" << result2[0] << std::endl;\n    }\n\n    // Test case 3\n    std::vector<std::vector<int>> testArr3 = {{4, 10}, {12, 15}};\n    std::vector<int> result3 = solution.getMinDifference(testArr3);\n    if (result3[0] == 5) {\n        std::cout << \"Test case 3 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed: expected 5, got \" << result3[0] << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1905": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\n        if (grid1.empty() || grid2.empty()) return 0;\n        \n        int m = grid1.size(), n = grid1[0].size();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid1[i][j] == 1 && grid2[i][j] == 1) {\n                    dfs(grid1, grid2, i, j);\n                }\n            }\n        }\n        \n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid1[i][j] == 1 && grid2[i][j] == 1) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \nprivate:\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j) {\n        if (i < 0 || i >= grid1.size() || j < 0 || j >= grid1[0].size() || grid1[i][j] != 1 || grid2[i][j] == 0) return;\n        \n        grid1[i][j] = -1; // mark as visited\n        if (grid2[i][j] == 1) {\n            dfs(grid1, grid2, i + 1, j);\n            dfs(grid1, grid2, i - 1, j);\n            dfs(grid1, grid2, i, j + 1);\n            dfs(grid1, grid2, i, j - 1);\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<vector<int>> grid11 = {{1,1},{1,1}};\n    vector<vector<int>> grid21 = {{1,1},{1,0}};\n    cout << solution.countSubIslands(grid11, grid21) << endl; // 2\n    \n    vector<vector<int>> grid12 = {{1,0},{0,1}};\n    vector<vector]int> grid22 = {{1,0},{0,0}};\n    cout << solution.countSubIslands(grid12, grid22) << endl; // 0\n    \n    vector<vector<int>> grid13 = {{1,1,1},{1,1,0},{1,1,1}};\n    vector<vector<int>> grid23 = {{1,0,1},{0,1,1},{1,0,1}};\n    cout << solution.countSubIslands(grid13, grid23) << endl; // 3\n    \n    return 0;\n}",
  "1908": "```\n#include <iostream>\n#include <vector>\n\nint calculateNimGame(int n) {\n    int res = 0;\n    for (int i = 1; i <= n; ++i) {\n        res ^= 1 << i;\n    }\n    return res;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << calculateNimGame(3) << std::endl;\n    std::cout << \"Test Case 2: \" << calculateNimGame(5) << std::endl;\n    std::cout << \"Test Case 3: \" << calculateNimGame(8) << std::endl;\n    \n    return 0;\n}\n```",
  "1907": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countGoodTriplets(vector<int>& arr, int low, int high) {\n        int res = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr[i] >= low && arr[i] <= high) {\n                for (int j = i + 1; j < arr.size(); j++) {\n                    if (arr[j] > arr[i]) {\n                        for (int k = j + 1; k < arr.size(); k++) {\n                            if (arr[k] > arr[j]) {\n                                res++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> arr1 = {5,7,9};\n    int low1 = 5, high1 = 15;\n    cout << \"Test case 1: \" << solution.countGoodTriplets(arr1, low1, high1) << endl;\n\n    // Test case 2\n    vector<int> arr2 = {4,6,5,8,7};\n    int low2 = 0, high2 = 10;\n    cout << \"Test case 2: \" << solution.countGoodTriplets(arr2, low2, high2) << endl;\n\n    // Test case 3\n    vector<int> arr3 = {1,2,3,4};\n    int low3 = 1, high3 = 3;\n    cout << \"Test case 3: \" << solution.countGoodTriplets(arr3, low3, high3) << endl;\n\n    return 0;\n}\n```",
  "1909": "```\n#include <iostream>\n#include <vector>\n\nbool canBeIncreasing(std::vector<int>& nums) {\n    for (int i = 0; i < nums.size() - 1; ++i) {\n        if (nums[i] >= nums[i + 1]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::vector<int> test1 = {1, 2, 3, 4, 5};\n    std::cout << \"Test case 1: \" << (canBeIncreasing(test1) ? \"Pass\" : \"Fail\") << std::endl;\n\n    std::vector<int> test2 = {1, 3, 5, 4, 2};\n    std::cout << \"Test case 2: \" << (canBeIncreasing(test2) ? \"Pass\" : \"Fail\") << std::endl;\n\n    std::vector<int> test3 = {9, 8, 7, 6, 5};\n    std::cout << \"Test case 3: \" << (canBeIncreasing(test3) ? \"Pass\" : \"Fail\") << std::endl;\n\n    return 0;\n}\n```",
  "1910": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Solution {\npublic:\n    std::string removeOccurrences(std::string s, std::string sub) {\n        int n = s.length(), m = sub.length();\n        for (int i = 0; i <= n - m; ++i) {\n            if (s.substr(i, m).equals(sub)) {\n                s = s.substring(0, i) + s.substring(i + m);\n                --i;\n                --n;\n            }\n        }\n        return s;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    std::cout << solution.removeOccurrences(\"bazaza\", \"aza\") << std::endl;  // Output: b\n    std::cout << solution.removeOccurrences(\"azxxzy\", \"axyz\") << std::endl;  // Output: z\n    std::cout << solution.removeOccurrences(\"bobobbobbbobo\", \"bobo\") << std::endl;  // Output: obob\n\n    return 0;\n}\n```",
  "1911": "```\n#include <iostream>\n#include <vector>\n\nint maxAlternatingSum(const std::vector<int>& arr) {\n    int evenSum = 0;\n    int oddSum = 0;\n\n    for (const auto& num : arr) {\n        if ((num % 2 == 0 && evenSum >= oddSum) || (num % 2 != 0 && oddSum > evenSum)) {\n            oddSum += num;\n        } else {\n            evenSum += num;\n        }\n    }\n\n    return std::max(evenSum, oddSum);\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> testArr1 = {4, 2, 3, 1, 2, 4};\n    int result1 = maxAlternatingSum(testArr1);\n    if (result1 == 9) {\n        std::cout << \"Test case 1 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 9, Actual: \" << result1 << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> testArr2 = {2, 4, 6};\n    int result2 = maxAlternatingSum(testArr2);\n    if (result2 == 12) {\n        std::cout << \"Test case 2 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 12, Actual: \" << result2 << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> testArr3 = {1, -2, 3, -4};\n    int result3 = maxAlternatingSum(testArr3);\n    if (result3 == 6) {\n        std::cout << \"Test case 3 passed.\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 6, Actual: \" << result3 << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1913": "```\n#include <iostream>\n#include <vector>\n\nint maxProduct(int[] nums) {\n    int max1 = -nums[0], max2 = -nums[0];\n    int min1 = nums[0], min2 = nums[0];\n\n    for (int i = 1; i < nums.length; i++) {\n        if (nums[i] > max1) {\n            max2 = max1;\n            max1 = nums[i];\n        } else if (nums[i] > max2) {\n            max2 = nums[i];\n        }\n\n        if (nums[i] < min1) {\n            min2 = min1;\n            min1 = nums[i];\n        } else if (nums[i] < min2) {\n            min2 = nums[i];\n        }\n    }\n\n    return (max1 - 1) * max1 - (min1 - 1) * min1;\n}\n\nint main() {\n    int[] test1 = {-3, 7, 18};\n    std::cout << \"Test case 1: \" << maxProduct(test1) << std::endl;\n\n    int[] test2 = [2, 3];\n    std::cout << \"Test case 2: \" << maxProduct(test2) << std::endl;\n\n    int[] test3 = {0, 10};\n    std::cout << \"Test case 3: \" << maxProduct(test3) << std::endl;\n    return 0;\n}\n```",
  "1912": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nclass MovieRental {\npublic:\n    MovieRental() {}\n\n    void rentMovie(int movieId, int days) {\n        if (movies_.count(movieId)) {\n            movies_[movieId]->add(days);\n        } else {\n            movies_[movieId] = new Movie(days);\n        }\n    }\n\n    double getFees(int movieId, int days) {\n        if (!movies_.count(movieId))\n            return 0.0;\n        return movies_[movieId]->getFees(days);\n    }\n\nprivate:\n    struct Movie {\n        int baseFee;\n        std::vector<int> fees;\n\n        Movie(int baseFee) : baseFee(baseFee) {}\n\n        void add(int days) {\n            double totalFees = baseFee * (1 + 0.02 * days);\n            fees.push_back(static_cast<int>(totalFees));\n        }\n\n        double getFees(int days) {\n            if (days <= fees[0])\n                return fees[0];\n            int idx = std::lower_bound(fees.begin(), fees.end(), days) - fees.begin();\n            return fees[idx-1] + (days - fees[idx-1]) * (fees[idx] - fees[idx-1]) / (fees[idx] - fees[idx-2]);\n        }\n    };\n\n    std::unordered_map<int, Movie*> movies_;\n};\n\nint main() {\n    MovieRental rental;\n\n    // Test case 1\n    rental.rentMovie(1, 3);\n    std::cout << \"Test case 1: Fees for movie 1 rented for 3 days = \" << rental.getFees(1, 3) << std::endl;\n    rental.rentMovie(2, 2);\n    std::cout << \"Test case 1: Fees for movie 2 rented for 2 days = \" << rental.getFees(2, 2) << std::endl;\n\n    // Test case 2\n    rental.rentMovie(3, 5);\n    std::cout << \"Test case 2: Fees for movie 3 rented for 5 days = \" << rental.getFees(3, 5) << std::endl;\n    rental.rentMovie(1, 4);\n    std::cout << \"Test case 2: Fees for movie 1 rented for 4 days = \" << rental.getFees(1, 4) << std::endl;\n\n    // Test case 3\n    rental.rentMovie(2, 6);\n    std::cout << \"Test case 3: Fees for movie 2 rented for 6 days = \" << rental.getFees(2, 6) << std::endl;\n    rental.rentMovie(3, 4);\n    std::cout << \"Test case 3: Fees for movie 3 rented for 4 days = \" << rental.getFees(3, 4) << std::endl;\n\n    return 0;\n}",
  "1915": "```\n#include <iostream>\n#include <vector>\n\nint numWonderfulSubstrings(std::string s) {\n    int n = s.length();\n    int res = 0;\n    for (int i = 1; i < n; i++) {\n        int left = 0, right = 0;\n        for (int j = 0; j < i; j++) {\n            if ((s[j] - 'a' & 1) == (s[i] - 'a') % 2)\n                left++;\n            else\n                right++;\n        }\n        res += (i + 1);\n    }\n    return res;\n}\n\nint main() {\n    std::cout << numWonderfulSubstrings(\"abaaba\") << \"\\n\";\n    std::cout << numWonderfulSubstrings(\"yzzzzyxz\") << \"\\n\";\n    std::cout << numWonderfulSubstrings(\"aabbccdd\") << \"\\n\";\n}\n```",
  "1914": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    std::vector<std::vector<int>> rotateGrid(std::vector<std::vector<int>>& grid, int k) {\n        if (grid.empty() || grid[0].empty()) return grid;\n        \n        int rows = grid.size();\n        int cols = grid[0].size();\n        int totalCells = rows * cols;\n        k %= 4; // only need to consider [0, 3]\n        \n        std::vector<std::vector<int>> newGrid(rows, std::vector<int>(cols));\n        for (int i = 0; i < totalCells; i++) {\n            int row = i % rows;\n            int col = (i / rows + k) % cols;\n            newGrid[row][col] = grid[rows - 1 - (i % rows)][(i / rows + k) % cols];\n        }\n        \n        return newGrid;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    std::vector<std::vector<int>> grid1 = {{1, 2}, {3, 4}};\n    int k1 = 1;\n    for (const auto& row : solution.rotateGrid(grid1, k1)) {\n        for (int num : row) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    // Test Case 2\n    std::vector<std::vector<int>> grid2 = {{5, 6}, {7, 8}};\n    int k2 = 3;\n    for (const auto& row : solution.rotateGrid(grid2, k2)) {\n        for (int num : row) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    // Test Case 3\n    std::vector<std::vector<int>> grid3 = {{9, 10}, {11, 12}};\n    int k3 = 2;\n    for (const auto& row : solution.rotateGrid(grid3, k3)) {\n        for (int num : row) {\n            std::cout << num << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "1916": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countWays(int n) {\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));\n        for (int i = 0; i <= n; i++) {\n            if (i == 0)\n                dp[i][0] = 1;\n            else\n                dp[i][0] = 1;\n            for (int j = 1; j <= i; j++)\n                if (j % 2 != 0)\n                    dp[i][j] = dp[i - 1][j - 1];\n                else\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];\n        }\n        return dp[n][n / 2];\n    }\n};\n\nint main() {\n    Solution solution;\n    cout << \"Test case 1: n = 3, expected result is 3. Result is \" << solution.countWays(3) << endl;\n    cout << \"Test case 2: n = 4, expected result is 7. Result is \" << solution.countWays(4) << endl;\n    cout << \"Test case 3: n = 5, expected result is 15. Result is \" << solution.countWays(5) << endl;\n    return 0;\n}",
  "1918": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int kthSmallest(vector<int>& nums, int k) {\n        int n = nums.size();\n        int left = *min_element(nums.begin(), nums.end());\n        int right = *max_element(nums.begin(), nums.end());\n\n        while (right - left > 0) {\n            int mid = left + (right - left) / 2;\n            long count = 0;\n            for (int i = 0; i < n; ++i) {\n                count += (nums[i] <= mid ? 1 : 0);\n            }\n\n            if (count >= k) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return left;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> nums1 = {2, 1, 3};\n    int k1 = 3;\n    cout << \"Kth smallest subarray sum for test case 1: \" << solution.kthSmallest(nums1, k1) << endl;\n\n    // Test case 2\n    vector<int> nums2 = {9, 6, 4, 15};\n    int k2 = 1;\n    cout << \"Kth smallest subarray sum for test case 2: \" << solution.kthSmallest(nums2, k2) << endl;\n\n    // Test case 3\n    vector<int> nums3 = {1, 2, 3, 4};\n    int k3 = 5;\n    cout << \"Kth smallest subarray sum for test case 3: \" << solution.kthSmallest(nums3, k3) << endl;\n\n    return 0;\n}\n```",
  "1917": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> friendsRecommendations(int n, vector<string> person1, vector<string> person2) {\n        unordered_map<string, vector<string>> graph;\n        \n        for (int i = 0; i < person1.size(); i++) {\n            string p1 = person1[i];\n            for (int j = 0; j < person2.size(); j++) {\n                string p2 = person2[j];\n                if (p1 != p2) {\n                    graph[p1].push_back(p2);\n                    graph[p2].push_back(p1);\n                }\n            }\n        }\n        \n        vector<vector<string>> recommendations;\n        for (const auto& pair : graph) {\n            vector<string> friends = pair.second;\n            sort(friends.begin(), friends.end());\n            recommendations.push_back({pair.first, friends});\n        }\n        \n        return recommendations;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n = 4;\n    vector<string> person1 = {\"Alice\", \"Bob\", \"Charlie\"};\n    vector<string> person2 = {\"Bob\", \"Charlie\", \"David\"};\n    vector<vector<string>> expected = {{\"Alice\", {\"Bob\"}}, {\"Bob\", {\"Alice\", \"Charlie\", \"David\"}}, {\"Charlie\", {\"Alice\", \"Bob\", \"David\"}}, {\"David\", {}}};\n    auto actual = solution.friendsRecommendations(n, person1, person2);\n    for (int i = 0; i < n; i++) {\n        cout << \"Person: \" << i+1 << endl;\n        for (const auto& friend : actual[i]) {\n            cout << friend << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 2\n    n = 3;\n    person1 = {\"John\", \"Alice\"};\n    person2 = {\"Alice\", \"Bob\"};\n    expected = {{\"John\", {}}, {\"Alice\", {\"Bob\"}}, {\"Bob\", {\"Alice\"}}};\n    actual = solution.friendsRecommendations(n, person1, person2);\n    for (int i = 0; i < n; i++) {\n        cout << \"Person: \" << i+1 << endl;\n        for (const auto& friend : actual[i]) {\n            cout << friend << \" \";\n        }\n        cout << endl;\n    }\n\n    // Test case 3\n    n = 5;\n    person1 = {\"Eve\", \"John\", \"Alice\", \"Bob\"};\n    person2 = {\"John\", \"Alice\", \"Bob\", \"David\", \"Eve\"};\n    expected = {{\"Alice\", {\"Bob\"}}, {\"Bob\", {\"Alice\", \"David\", \"Eve\"}}, {\"Charlie\", {}}, {\"David\", {\"Alice\", \"Bob\", \"Eve\"}}, {\"Eve\", {\"Alice\", \"Bob\"}}};\n    actual = solution.friendsRecommendations(n, person1, person2);\n    for (int i = 0; i < n; i++) {\n        cout << \"Person: \" << i+1 << endl;\n        for (const auto& friend : actual[i]) {\n            cout << friend << \" \";\n        }\n        cout << endl;\n    }\n\n    return 0;\n}\n```",
  "1920": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> arrayRankTransform(std::vector<int>& arr) {\n    std::sort(arr.begin(), arr.end());\n    for (int i = 0; i < arr.size(); i++) {\n        int val = arr[i];\n        for (int j = 0; j < i; j++) {\n            if (arr[j] > val) {\n                arr[i] = i + 1;\n                break;\n            }\n        }\n    }\n    return arr;\n}\n\nint main() {\n    std::vector<int> test1 = {40, 10, 20};\n    for (auto x : arrayRankTransform(test1)) {\n        std::cout << x << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> test2 = {100, 101, 102, 103};\n    for (auto x : arrayRankTransform(test2)) {\n        std::cout << x << \" \";\n    }\n    std::cout << std::endl;\n\n    std::vector<int> test3 = {1, 5, 4, 6, 7, 8, 3, 0};\n    for (auto x : arrayRankTransform(test3)) {\n        std::cout << x << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
  "1919": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findSimilarFriends(vector<vector<string>>& friendships) {\n        unordered_map<string, int> friendMap;\n        for (int i = 0; i < friendships.size(); i++) {\n            string person1 = friendships[i][0];\n            string person2 = friendships[i][1];\n            friendMap[person1]++;\n            if (friendMap.find(person2) != friendMap.end()) {\n                friendMap[person2]++;\n            } else {\n                friendMap[person2] = 1;\n            }\n        }\n        \n        vector<int> similarFriends;\n        for (auto& pair : friendMap) {\n            if (pair.second > 1) {\n                similarFriends.push_back(pair.first);\n            }\n        }\n        \n        return similarFriends;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> test1 = {{\"John\", \"Alice\"}, {\"Alice\", \"Bob\"}, {\"Bob\", \"John\"}};\n    vector<int> result1 = solution.findSimilarFriends(test1);\n    cout << \"Test case 1: \";\n    for (int friend : result1) {\n        cout << friend << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<vector<string>> test2 = {{\"Jane\", \"John\"}, {\"John\", \"Alice\"}, {\"Alice\", \"Bob\"}};\n    vector<int> result2 = solution.findSimilarFriends(test2);\n    cout << \"Test case 2: \";\n    for (int friend : result2) {\n        cout << friend << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<vector<string>> test3 = {{\"Tom\", \"Alice\"}, {\"Bob\", \"John\"}, {\"John\", \"Jane\"}};\n    vector<int> result3 = solution.findSimilarFriends(test3);\n    cout << \"Test case 3: \";\n    for (int friend : result3) {\n        cout << friend << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1922": "```\n#include <iostream>\n#include <vector>\n\nint countGoodNumbers(int n) {\n    if (n == 1) return 5;\n    if (n % 2 == 0)\n        return (countGoodNumbers(n / 2) * (n + 1)) * 9;\n    else\n        return (countGoodNumbers((n - 1) / 2) * (n + 1)) * 10;\n}\n\nint main() {\n    std::cout << \"Test Case 1: Count good numbers for n = 3: \" << countGoodNumbers(3) << std::endl; // Expected output: 450\n    std::cout << \"Test Case 2: Count good numbers for n = 4: \" << countGoodNumbers(4) << std::endl; // Expected output: 12150\n    std::cout << \"Test Case 3: Count good numbers for n = 5: \" << countGoodNumbers(5) << std::endl; // Expected output: 191950\n\n    return 0;\n}\n```",
  "1921": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumEggDrop(int k, int n) {\n        if (k == 1)\n            return n;\n        vector<vector<int>> dp(k + 1, vector<int>(n + 1));\n        \n        for (int i = 1; i <= k; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = i + max(0, dp[i - 1][j - 1]);\n                \n                if (j < n)\n                    dp[i][j] = min(dp[i][j], dp[i][j + 1] + 1);\n            }\n        }\n        \n        return dp[k][n];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    cout << solution.maximumEggDrop(1, 2) << endl; // Output: 2\n    cout << solution.maximumEggDrop(2, 6) << endl; // Output: 4\n    cout << solution.maximumEggDrop(3, 14) << endl; // Output: 7\n    \n    return 0;\n}\n```",
  "1923": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestCommonSubpath(vector<vector<string>>& paths) {\n        int n = paths.size();\n        vector<int> dp(n + 1, 0);\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j <= i; ++j) {\n                int len = 0;\n                while (len <= dp[j] && i >= 0 && paths[i][j + len].size() > dp[j]) {\n                    if (paths[0].substr(j, len).compare(paths[i].substr(j, len)) != 0) {\n                        break;\n                    }\n                    ++len;\n                }\n                dp[i + 1] = max(dp[i + 1], len);\n            }\n        }\n        string res = \"\";\n        for (int i = n - 1; i >= 0; --i) {\n            int j = 0;\n            while (j <= dp[i]) {\n                if (paths[0].substr(0, j).compare(paths[i].substr(0, j)) != 0) {\n                    break;\n                }\n                res = paths[i].substr(0, j) + \" \" + res;\n                ++j;\n            }\n        }\n        return res.substr(0, res.size() - 1);\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> paths1({{\"flights\", \"to\", \"Newark\"}, {\"to\", \"Los Angeles\"}, {\"from\", \"Chicago\"}});\n    cout << solution.longestCommonSubpath(paths1) << endl;  // Output: to\n\n    // Test case 2\n    vector<vector<string>> paths2({{\"apple\", \"banana\", \"cherry\"}, {\"apple\", \"date\", \"elderberry\"}, {\"fig\", \"grape\", \"honeydew\"}});\n    cout << solution.longestCommonSubpath(paths2) << endl;  // Output: apple\n\n    // Test case 3\n    vector<vector<string>> paths3({{\"hello\", \"world\", \"java\"}, {\"c++\", \"python\", \"R\"}, {\"swift\", \"kotlin\", \"ruby\"}});\n    cout << solution.longestCommonSubpath(paths3) << endl;  // Output: \n\n    return 0;\n}\n```",
  "1925": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countTriples(int n) {\n        int res = 0;\n        for (int i = 1; i * i <= n; i++) {\n            for (int j = i; j * j <= n; j++) {\n                int k = (n - i * i - j * j);\n                if (k >= 0 && k * k + i * i + j * j == n) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \";\n    int n1 = 10; \n    cout << solution.countTriples(n1) << endl;\n\n    cout << \"Test case 2: \";\n    int n2 = 5; \n    cout << solution.countTriples(n2) << endl;\n\n    cout << \"Test case 3: \";\n    int n3 = 2147483647;\n    cout << solution.countTriples(n3) << endl;\n\n    return 0;\n}\n```",
  "1924": "```\n#include <iostream>\n#include <vector>\n\nint maxPoints(std::vector<std::vector<int>>& points) {\n    int n = points.size();\n    if (n <= 2) return n;\n    int res = 0;\n    for (int i = 0; i < n; ++i) {\n        std::unordered_map<std::pair<int, int>, int> m;\n        int same = 1;\n        for (int j = i + 1; j < n; ++j) {\n            if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) {\n                ++same;\n                continue;\n            }\n            int dx = points[j][0] - points[i][0];\n            int dy = points[j][1] - points[i][1];\n            if (dx < 0) std::swap(dx, dy);\n            m[{dx, dy}] = (m.find({dx, dy}) == m.end()) ? 1 : m[{dx, dy}] + 1;\n        }\n        res = std::max(res, same);\n        for (auto& p : m) {\n            res = std::max(res, p.second + same);\n        }\n    }\n    return res;\n}\n\nint main() {\n    int testNum = 3;\n    // Test Case 1\n    std::vector<std::vector<int>> points1 = {{0,0},{2,0},{4,0},{0,1},{1,1},{2,1},{3,1},{0,2},{1,2},{2,2}};\n    std::cout << \"Test Case 1: \" << maxPoints(points1) << std::endl;\n\n    // Test Case 2\n    std::vector<std::vector<int>> points2 = {{1,1},{2,2},{3,3}};\n    std::cout << \"Test Case 2: \" << maxPoints(points2) << std::endl;\n\n    // Test Case 3\n    std::vector<std::vector<int>> points3 = {{0,0},{1,1},{2,2},{3,3}};\n    std::cout << \"Test Case 3: \" << maxPoints(points3) << std::endl;\n\n    return 0;\n}\n```",
  "1927": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int getSum(vector<string>& nums) {\n        int res = 0;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (i % 2 == 0) {\n                res += stol(nums[i]);\n            } else {\n                res -= stol(nums[i]);\n            }\n        }\n        return abs(res);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<string> test1 = {\"1\",\"-1\"};\n    cout << \"Test case 1: \" << solution.getSum(test1) << endl;\n\n    vector<string> test2 = {\"1\", \"-2\", \"3\", \"1\"};\n    cout << \"Test case 2: \" << solution.getSum(test2) << endl;\n    \n    vector<string> test3 = {\"5\", \"-6\", \"7\", \"-8\", \"9\", \"-10\", \"11\", \"-12\", \"13\", \"14\", \"15\"};\n    cout << \"Test case 3: \" << solution.getSum(test3) << endl;\n\n    return 0;\n}\n```",
  "1926": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> nearestExit(vector<vector<char>>& maze, vector<int>& entrance) {\n        int rows = maze.size();\n        int cols = maze[0].size();\n        queue<pair<int, int>> q;\n        bool visited[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                visited[i][j] = false;\n            }\n        }\n\n        q.push({entrance[0], entrance[1]});\n        int steps = 0;\n\n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                pair<int, int> cur = q.front(); q.pop();\n                if (cur.first == 0 || cur.first == rows - 1 || cur.second == 0 || cur.second == cols - 1) {\n                    // find the nearest exit\n                    if (cur.first > 0 && maze[cur.first - 1][cur.second] != ' ') return {cur.first, cur.second};\n                    if (cur.second > 0 && maze[cur.first][cur.second - 1] != ' ') return {cur.first, cur.second};\n                    if (cur.first < rows - 1 && maze[cur.first + 1][cur.second] != ' ') return {cur.first, cur.second};\n                    if (cur.second < cols - 1 && maze[cur.first][cur.second + 1] != ' ') return {cur.first, cur.second};\n\n                }\n                for (int j = -1; j <= 1; j++) {\n                    for (int k = -1; k <= 1; k++) {\n                        if (j == 0 && k == 0) continue;\n                        int x = cur.first + j;\n                        int y = cur.second + k;\n\n                        if (x >= 0 && x < rows && y >= 0 && y < cols && !visited[x][y] && maze[x][y] != '#') {\n                            q.push({x, y});\n                            visited[x][y] = true;\n                        }\n                    }\n                }\n            }\n            steps++;\n        }\n\n        return {};\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<char>> maze1 = {{'0', '1'}, {'#', '#'}};\n    vector<int> entrance1 = {0, 0};\n    cout << \"Test Case 1: \";\n    for (auto exit : solution.nearestExit(maze1, entrance1)) {\n        cout << exit << \" \";\n    }\n    cout << endl;\n\n    // Test Case 2\n    vector<vector<char>> maze2 = {{'0', '1'}, {'#', '0'}};\n    vector<int> entrance2 = {1, 0};\n    cout << \"Test Case 2: \";\n    for (auto exit : solution.nearestExit(maze2, entrance2)) {\n        cout << exit << \" \";\n    }\n    cout << endl;\n\n    // Test Case 3\n    vector<vector<char>> maze3 = {{'0', '1'}, {'#', '#'}, {'0', '#'}};\n    vector<int> entrance3 = {2, 0};\n    cout << \"Test Case 3: \";\n    for (auto exit : solution.nearestExit(maze3, entrance3)) {\n        cout << exit << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1928": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCost(int n, vector<vector<int>>& flights) {\n        const int INF = 1e9;\n        vector<vector<pair<int, int>>> graph(n);\n        for (const auto& flight : flights) {\n            graph[flight[0]].push_back({flight[1], flight[2]});\n            graph[flight[1]].push_back({flight[0], flight[2]});\n        }\n        \n        vector<int> dp(n, INF);\n        dp[0] = 0;\n        for (int i = 1; i < n; ++i) {\n            for (const auto& edge : graph[i]) {\n                int to = edge.first;\n                int cost = edge.second;\n                if (dp[to] > cost + dp[i]) {\n                    dp[to] = cost + dp[i];\n                }\n            }\n        }\n        \n        int res = INF;\n        for (int i = 1; i < n; ++i) {\n            if (dp[i] != INF) {\n                res = min(res, dp[i]);\n            }\n        }\n        return res == INF ? -1 : res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n1 = 3;\n    vector<vector<int>> flights1 = {{0, 1, 2}, {1, 2, 5}};\n    cout << \"Test case 1: \" << solution.minCost(n1, flights1) << endl;  // Expected output: 4\n\n    // Test case 2\n    int n2 = 3;\n    vector<vector<int>> flights2 = {{0, 1, 10}, {1, 2, 6}};\n    cout << \"Test case 2: \" << solution.minCost(n2, flights2) << endl;  // Expected output: -1\n\n    // Test case 3\n    int n3 = 4;\n    vector<vector<int>> flights3 = {{0, 1, 5}, {1, 2, 3}, {0, 3, 10}};\n    cout << \"Test case 3: \" << solution.minCost(n3, flights3) << endl;  // Expected output: 7\n\n    return 0;\n}\n```",
  "1929": "```\n#include <iostream>\n#include <vector>\n\nstd::vector<int> getConcatenation(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> res(n * 2);\n    for (int i = 0; i < n; i++) {\n        res[i] = nums[i];\n        res[n + i] = nums[i];\n    }\n    return res;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> nums1 = {1,2};\n    std::vector<int> result1 = getConcatenation(nums1);\n    for (int num : result1) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 2\n    std::vector<int> nums2 = {1,3,2};\n    std::vector<int> result2 = getConcatenation(nums2);\n    for (int num : result2) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // Test case 3\n    std::vector<int> nums3 = {1,0,1};\n    std::vector<int> result3 = getConcatenation(nums3);\n    for (int num : result3) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n    \n    return 0;\n}\n```",
  "1930": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint countSubstrings(string s) {\n    int n = s.length();\n    vector<vector<int>> dp(n, vector<int>(n));\n\n    for (int i = 0; i < n; i++) {\n        dp[i][i] = 1;\n    }\n\n    for (int len = 2; len <= n; len++) {\n        for (int i = 0; i < n - len + 1; i++) {\n            int j = i + len - 1;\n            if (s[i] == s[j]) {\n                dp[i][j] = dp[i + 1][j - 1] + 3;\n            } else {\n                dp[i][j] = 2 * dp[i + 1][j - 1];\n            }\n        }\n    }\n\n    return dp[0][n - 1];\n}\n\nint main() {\n    cout << \"Test case 1: \" << countSubstrings(\"aba\") << endl;\n    cout << \"Test case 2: \" << countSubstrings(\"bcbdefegfedcbab\") << endl;\n    cout << \"Test case 3: \" << countSubstrings(\"a\") << endl;\n\n    return 0;\n}\n```",
  "1931": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int paintGrid(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<vector<int>> dp(m, vector<int>(n));\n        \n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i == 0) {\n                    dp[i][j] = grid[i][j];\n                } else if (j == 0) {\n                    dp[i][j] = min(dp[i-1][j], grid[i][j]);\n                } else {\n                    dp[i][j] = min({dp[i-1][j], dp[i][j-1], grid[i][j]});\n                }\n            }\n        }\n        \n        return dp[m-1][n-1];\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1:\n    vector<vector<int>> grid1 = {{1,1},{2,2}};\n    cout << \"Test Case 1: \" << solution.paintGrid(grid1) << endl;\n\n    // Test Case 2:\n    vector<vector<int>> grid2 = {{1,0},{1,1}};\n    cout << \"Test Case 2: \" << solution.paintGrid(grid2) << endl;\n\n    // Test Case 3:\n    vector<vector<int>> grid3 = {{0,0,0},{1,1,1}};\n    cout << \"Test Case 3: \" << solution.paintGrid(grid3) << endl;\n\n    return 0;\n}\n```",
  "1932": "```\n#include <iostream>\nusing namespace std;\n\n// Definition for a binary tree node.\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if (t1 == NULL && t2 == NULL) return NULL;\n        if (t1 == NULL) return t2;\n        if (t2 == NULL) return t1;\n\n        t1->val += t2->val;\n        t1->left = mergeTrees(t1->left, t2->left);\n        t1->right = mergeTrees(t1->right, t2->right);\n\n        return t1;\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test case 1\n    TreeNode* root1 = new TreeNode(1);\n    root1->left = new TreeNode(3);\n    root1->right = new TreeNode(4);\n    root1->left->left = new TreeNode(5);\n\n    TreeNode* root2 = new TreeNode(2);\n    root2->left = new TreeNode(6);\n\n    TreeNode* result = solution.mergeTrees(root1, root2);\n\n    // Print the merged tree\n    printTree(result);\n\n    cout << endl;\n\n    // Test case 2\n    root1 = NULL;\n    root2 = new TreeNode(5);\n\n    result = solution.mergeTrees(root1, root2);\n\n    // Print the merged tree\n    printTree(result);\n\n    cout << endl;\n\n    // Test case 3\n    root1 = new TreeNode(4);\n    root1->left = new TreeNode(7);\n    root1->right = new TreeNode(8);\n\n    root2 = new TreeNode(5);\n    root2->left = new TreeNode(6);\n\n    result = solution.mergeTrees(root1, root2);\n\n    // Print the merged tree\n    printTree(result);\n}\n\n// Helper function to print a binary tree\nvoid printTree(TreeNode* node) {\n    if (node == NULL) return;\n    cout << node->val << \" \";\n    printTree(node->left);\n    printTree(node->right);\n}\n```",
  "1933": "```\n#include <iostream>\n#include <string>\n\nbool isDecomposable(std::string s) {\n    int n = s.length();\n    for (int i = 1; i <= n / 2; i++) {\n        if (n % i == 0 && std::all_of(s.begin(), s.end(), [i](char c){ return c - '0' == i; })) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    std::cout << isDecomposable(\"11112222\") << std::endl;  // Expected: True\n    std::cout << isDecomposable(\"123456\") << std::endl;     // Expected: False\n    std::cout << isDecomposable(\"33333\") << std::endl;      // Expected: True\n\n    return 0;\n}\n```",
  "1934": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double getConfirmationRate(vector<vector<string>>& accounts, vector<int>& ratio) {\n        int total = 0;\n        int confirmed = 0;\n        \n        for (int i = 0; i < accounts.size(); i++) {\n            if (!accounts[i].empty()) {\n                total++;\n                if (ratio[i] == 1) {\n                    confirmed++;\n                }\n            }\n        }\n        \n        return static_cast<double>(confirmed) / total;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> accounts1 = {{}, {\"name1\", \"email1\"}, {\"name2\", \"email2\"}};\n    vector<int> ratio1 = {0, 1, 1};\n    cout << \"Test Case 1: \" << solution.getConfirmationRate(accounts1, ratio1) << endl;\n\n    // Test Case 2\n    vector<vector<string>> accounts2 = {{}, {\"name3\", \"email3\"}};\n    vector<int> ratio2 = {0, 1};\n    cout << \"Test Case 2: \" << solution.getConfirmationRate(accounts2, ratio2) << endl;\n\n    // Test Case 3\n    vector<vector<string>> accounts3 = {{}, {\"name4\", \"email4\"}, {\"name5\", \"email5\"}};\n    vector<int> ratio3 = {1, 0, 1};\n    cout << \"Test Case 3: \" << solution.getConfirmationRate(accounts3, ratio3) << endl;\n\n    return 0;\n}\n```",
  "1935": "```\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxWords(string typed, string sentence) {\n        int n = sentence.size();\n        int m = typed.size();\n        int res = 0;\n        int j = 0;\n        for (int i = 0; i < m; i++) {\n            while (j < n && (typed[i] == ' ' || typed[i] != sentence[j])) {\n                j++;\n            }\n            if (j < n) {\n                res += 1;\n                j++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    string typed = \"Fu\";\n    string sentence = \"Hello Fusheng\";\n    cout << \"Test case 1: \" << solution.maxWords(typed, sentence) << endl;  // Output: 2\n\n    // Test case 2\n    typed = \"hello world\";\n    sentence = \"hello world hello\";\n    cout << \"Test case 2: \" << solution.maxWords(typed, sentence) << endl;  // Output: 1\n\n    // Test case 3\n    typed = \"\";\n    sentence = \"Hello World\";\n    cout << \"Test case 3: \" << solution.maxWords(typed, sentence) << endl;  // Output: 0\n\n    return 0;\n}\n```",
  "1936": "```\n#include <iostream>\n#include <vector>\n\nint minAdditions(int n) {\n    int res = 0;\n    while ((n & 1) == 0) {\n        n /= 2;\n        res++;\n    }\n    return res;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << minAdditions(5) << std::endl; // Expected output: 1\n    std::cout << \"Test Case 2: \" << minAdditions(8) << std::endl; // Expected output: 3\n    std::cout << \"Test Case 3: \" << minAdditions(10) << std::endl; // Expected output: 0\n\n    return 0;\n}\n```",
  "1937": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxPoints(vector<vector<int>>& points) {\n        int n = points.size();\n        if (n <= 2)\n            return n;\n        \n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            map<pair<int, int>, int> m;\n            int same = 1;\n            for (int j = i + 1; j < n; ++j) {\n                if (points[i][0] == points[j][0] && points[i][1] == points[j][1]) \n                    same++;\n                else {\n                    int dx = points[j][0] - points[i][0];\n                    int dy = points[j][1] - points[i][1];\n                    pair<int, int> p(dx, dy);\n                    m[p]++;\n                }\n            }\n            \n            int maxPoints = same;\n            for (auto it = m.begin(); it != m.end(); ++it) {\n                maxPoints = max(maxPoints, it->second + 1);\n            }\n            \n            ans = max(ans, min(2 * n - 3, maxPoints));\n        }\n        \n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> points1 = {{0,0},{2,0}};\n    cout << \"Test case 1: \" << solution.maxPoints(points1) << endl; \n\n    // Test case 2\n    vector<vector<int>> points2 = {{0,0},{2,0},{4,0},{6,0}};\n    cout << \"Test case 2: \" << solution.maxPoints(points2) << endl; \n\n    // Test case 3\n    vector<vector<int>> points3 = {{1,2},{2,3},{3,1},{4,5},{5,7}};\n    cout << \"Test case 3: \" << solution.maxPoints(points3) << endl;\n\n    return 0;\n}\n```",
  "1938": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int maxDiff(const std::vector<std::string>& parents) {\n        int n = parents.size();\n        std::vector<int> parentMap(n, -1);\n        for (int i = 0; i < n; ++i) {\n            if (parents[i].size() > 0 && parents[i][0] != '0') {\n                parentMap[std::stoi(parents[i].substr(0, 1))] = i;\n            }\n        }\n\n        int res = -1;\n        for (int i = 0; i < n; ++i) {\n            if (parentMap[i] == -1) continue;\n\n            int p = parentMap[i];\n            while (p != -1) {\n                res = std::max(res, (p << 6) ^ (parents[p].size() - 1));\n                p = parentMap[p];\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    std::vector<std::string> parents1 = {\"0\", \"10\", \"20\"};\n    int expected1 = 5;\n    int actual1 = solution.maxDiff(parents1);\n    if (actual1 == expected1) {\n        std::cout << \"Test case 1 passed.\\n\";\n    } else {\n        std::cout << \"Test case 1 failed: Expected \" << expected1 << \", got \" << actual1 << \".\\n\";\n    }\n\n    // Test case 2\n    std::vector<std::string> parents2 = {\"0\", \"10\", \"20\", \"30\", \"31\"};\n    int expected2 = 6;\n    int actual2 = solution.maxDiff(parents2);\n    if (actual2 == expected2) {\n        std::cout << \"Test case 2 passed.\\n\";\n    } else {\n        std::cout << \"Test case 2 failed: Expected \" << expected2 << \", got \" << actual2 << \".\\n\";\n    }\n\n    // Test case 3\n    std::vector<std::string> parents3 = {\"0\", \"10\"};\n    int expected3 = -1;\n    int actual3 = solution.maxDiff(parents3);\n    if (actual3 == expected3) {\n        std::cout << \"Test case 3 passed.\\n\";\n    } else {\n        std::cout << \"Test case 3 failed: Expected \" << expected3 << \", got \" << actual3 << \".\\n\";\n    }\n\n    return 0;\n}\n```",
  "1939": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nbool checkIfExist(std::vector<int>& arr) {\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] == 2 || arr[i] % 2 == 0 && std::find_if(arr.begin(), arr.end(), [&](int n) { return n == arr[i] / 2; }) != arr.end()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> testCase1 = {4, -3, 2};\n    if (checkIfExist(testCase1)) {\n        std::cout << \"Test case 1: Expected result is true\" << std::endl;\n    } else {\n        std::cout << \"Test case 1: Expected result is false\" << std::endl;\n    }\n\n    // Test case 2\n    std::vector<int> testCase2 = {10, 2};\n    if (checkIfExist(testCase2)) {\n        std::cout << \"Test case 2: Expected result is true\" << std::endl;\n    } else {\n        std::cout << \"Test case 2: Expected result is false\" << std::endl;\n    }\n\n    // Test case 3\n    std::vector<int> testCase3 = {4};\n    if (checkIfExist(testCase3)) {\n        std::cout << \"Test case 3: Expected result is true\" << std::endl;\n    } else {\n        std::cout << \"Test case 3: Expected result is false\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1940": "```\n#include <iostream>\n#include <vector>\n\nint findLCS(std::vector<int>& nums1, std::vector<int>& nums2) {\n    int m = nums1.size(), n = nums2.size();\n    int res = 0;\n    \n    for (int i = 0; i < m; i++) {\n        int j = 0, k = i;\n        while (k < m && j < n) {\n            if (nums1[k] == nums2[j]) {\n                res++;\n                k++;\n                j++;\n            } else if (nums1[k] < nums2[j]) {\n                k++;\n            } else {\n                j++;\n            }\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {1, 4, 6, 8, 12, 14};\n    std::vector<int> nums2 = {1, 2, 3, 4, 7, 8, 9};\n    std::cout << \"Test case 1: The longest common subsequence is \" << findLCS(nums1, nums2) << std::endl;\n\n    nums1 = {5, 6, 8, 12};\n    nums2 = {1, 2, 3, 4, 7, 8, 9};\n    std::cout << \"Test case 2: The longest common subsequence is \" << findLCS(nums1, nums2) << std::endl;\n\n    nums1 = {10, 12, 14};\n    nums2 = {5, 6, 8, 12};\n    std::cout << \"Test case 3: The longest common subsequence is \" << findLCS(nums1, nums2) << std::endl;\n    \n    return 0;\n}\n```",
  "1941": "```\n#include <iostream>\n#include <unordered_map>\n\nbool areOccurrencesEqual(std::string s) {\n    std::unordered_map<char, int> count;\n    for (char c : s) {\n        count[c]++;\n    }\n    return !std::any_of(count.begin(), count.end(), [&count](const auto& p) {\n        return p.second != 1;\n    });\n}\n\nint main() {\n    std::cout << areOccurrencesEqual(\"book\") << std::endl; // Expected output: true\n    std::cout << areOccurrencesEqual(\"text\") << std::endl; // Expected output: false\n    std::cout << areOccurrencesEqual(\"abcabcabc\") << std::endl; // Expected output: true\n\n    return 0;\n}\n```",
  "1942": "```\n#include <iostream>\n#include <vector>\n#include <queue>\n\nint numSmallestUnoccupiedChair(std::vector<std::string>& seats) {\n    std::priority_queue<int> queue;\n    for (int i = 0; i < seats.size(); i++) {\n        if (seats[i].find(\"Person\") != std::string::npos) {\n            int personIndex = stoi(seats[i].substr(7, seats[i].size() - 8));\n            queue.push(personIndex);\n        }\n    }\n\n    int res = 1;\n    while (!queue.empty()) {\n        if (res == queue.top()) {\n            return res;\n        }\n        res++;\n        queue.pop();\n    }\n    return -1;\n}\n\nint main() {\n    std::vector<std::string> seats1 = {\"Mrs. White\", \"Little Red Riding Hood\", \"Abracadabra!!\", \"Person 0\"};\n    int res1 = numSmallestUnoccupiedChair(seats1);\n    std::cout << \"Test Case 1: \" << res1 << std::endl;\n\n    std::vector<std::string> seats2 = {\"John Smith\", \"Mona Lisa\", \"Alice in Wonderland\", \"Person 1\"};\n    int res2 = numSmallestUnoccupiedChair(seats2);\n    std::cout << \"Test Case 2: \" << res2 << std::endl;\n\n    std::vector<std::string> seats3 = {\"Person 5\", \"Person 4\", \"Person 3\", \"Person 2\"};\n    int res3 = numSmallestUnoccupiedChair(seats3);\n    std::cout << \"Test Case 3: \" << res3 << std::endl;\n\n    return 0;\n}\n```",
  "1943": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> descriptivePainting(vector<vector<int>>& colors) {\n        int n = colors.size();\n        vector<string> result;\n        \n        for (int i = 0; i < n; i++) {\n            string temp;\n            for (int j = 0; j < colors[0].size(); j++) {\n                if (colors[i][j] == 1) {\n                    temp += \"W\";\n                } else {\n                    temp += \"B\";\n                }\n            }\n            result.push_back(temp);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<int>> colors1 = {{0, 1}, {1, 0}};\n    vector<string> expected1 = {\"WB\"};\n    if (solution.descriptivePainting(colors1) != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n        return 1;\n    }\n    \n    // Test case 2\n    vector<vector<int>> colors2 = {{0, 1}, {1, 1}};\n    vector<string> expected2 = {\"BW\"};\n    if (solution.descriptivePainting(colors2) != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n        return 1;\n    }\n    \n    // Test case 3\n    vector<vector<int>> colors3 = {{0, 0}, {1, 1}};\n    vector<string> expected3 = {\"BB\"};\n    if (solution.descriptivePainting(colors3) != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n        return 1;\n    }\n    \n    cout << \"All test cases passed.\" << endl;\n    return 0;\n}\n```",
  "1944": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int visiblePeople(vector<int>& heights) {\n        stack<int> s;\n        int res = 0, maxh = 0;\n        for (int i = 0; i < heights.size(); i++) {\n            while (!s.empty() && s.top() <= heights[i]) {\n                s.pop();\n            }\n            if (!s.empty()) maxh = s.top();\n            res += maxh > heights[i] ? 1 : 0;\n            s.push(heights[i]);\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution sol;\n\n    // Test case 1\n    vector<int> heights1 = {2,3,4,5};\n    cout << \"Test case 1: \" << sol.visiblePeople(heights1) << endl; \n\n    // Test case 2\n    vector<int> heights2 = {7,5,9,10,6};\n    cout << \"Test case 2: \" << sol.visiblePeople(heights2) << endl;\n\n    // Test case 3\n    vector<int> heights3 = {11,12,10,9,8};\n    cout << \"Test case 3: \" << sol.visiblePeople(heights3) << endl;\n    \n    return 0;\n}\n```",
  "1945": "```\n#include <iostream>\n#include <string>\n\nint sumOfDigits(std::string str) {\n    int sum = 0;\n    for (char c : str) {\n        if (c >= '0' && c <= '9') {\n            sum += (c - '0');\n        } else {\n            char temp[3];\n            temp[2] = '\\0';\n            sprintf(temp, \"%c\", c);\n            int val = std::stoi(temp);\n            sum += val;\n        }\n    }\n    return sum;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << sumOfDigits(\"letCodeHandle\") << \"\\n\";\n    std::cout << \"Test case 2: \" << sumOfDigits(\"something0Something\") << \"\\n\";\n    std::cout << \"Test case 3: \" << sumOfDigits(\"a1b2c3d4e5f6g7h8i9j10k11m13n15p17q19t21u23v25w27x29y31z33\") << \"\\n\";\n    return 0;\n}\n```",
  "1946": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nstd::string maximumNumber(std::vector<std::string>& digits) {\n    std::sort(digits.begin(), digits.end(), [](const auto& a, const auto& b) {\n        if (a.length() == 1 || b.length() == 1) return false;\n        if (a.back() > b.back()) return true;\n        if (a.back() < b.back()) return false;\n        return a.substr(0, a.size() - 1) > b.substr(0, b.size() - 1);\n    });\n    std::string result = \"\";\n    for (const auto& digit : digits) {\n        result += digit;\n    }\n    return result;\n}\n\nint main() {\n    {\n        std::vector<std::string> digits = {\"3\", \"6\", \"9\"};\n        std::cout << maximumNumber(digits) << std::endl;  // Output: 963\n    }\n\n    {\n        std::vector<std::string> digits = {\"1\", \"2\", \"34\"};\n        std::cout << maximumNumber(digits) << std::endl;  // Output: 4134\n    }\n\n    {\n        std::vector<std::string> digits = {\"10\", \"2\"};\n        std::cout << maximumNumber(digits) << std::endl;  // Output: 210\n    }\n}\n```",
  "1947": "```\n#include <iostream>\n#include <vector>\n\nint maxCompatibilitySum(std::vector<int>& answers) {\n    int n = answers.size();\n    int res = 0;\n    for (int i = 0; i < n; i++) {\n        int ones = 0, zeros = 0;\n        for (int j = 0; j < n; j++) {\n            if ((answers[i] & (1 << j)) && answers[j] & (1 << j))\n                ones++;\n            else if (!(answers[i] & (1 << j)) && !(answers[j] & (1 << j)))\n                zeros++;\n        }\n        res += ones * 2 + zeros;\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> answers1 = {2, 1, 3};\n    std::cout << \"Test case 1: \" << maxCompatibilitySum(answers1) << std::endl;\n\n    std::vector<int> answers2 = {5, 4, 6};\n    std::cout << \"Test case 2: \" << maxCompatibilitySum(answers2) << std::endl;\n\n    std::vector<int> answers3 = {1, 2, 3, 4};\n    std::cout << \"Test case 3: \" << maxCompatibilitySum(answers3) << std::endl;\n    \n    return 0;\n}\n```",
  "1948": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<string> deleteDuplicate(vector<vector<string>>& folders) {\n        unordered_map<string, int> folderMap;\n        vector<string> result;\n        \n        for (const auto& folder : folders) {\n            string path = \"\";\n            for (int i = 0; i < folder.size(); i++) {\n                if (folder[i].size() > 1 && folder[i][0] == '.') {\n                    path += folder[i];\n                } else {\n                    path = folderMap[path] ? \"\" : path + \"/\";\n                    path += folder[i];\n                    folderMap[path]++;\n                }\n            }\n            result.push_back(path);\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> folders1 = {{\"root/a\", \"root/c\", \"root\"};\n    vector<string> expected1 = {\"root\"};\n    if (solution.deleteDuplicate(folders1) != expected1) {\n        cout << \"Test case 1 failed.\" << endl;\n    }\n\n    // Test case 2\n    vector<vector<string>> folders2 = {{\"/a/b/c\", \"/a/b/c\"}, {\"/a/b/c\"}};\n    vector<string> expected2 = {\"/a/b/c\"};\n    if (solution.deleteDuplicate(folders2) != expected2) {\n        cout << \"Test case 2 failed.\" << endl;\n    }\n\n    // Test case 3\n    vector<vector<string>> folders3 = {{\"root/a\", \"root/x\", \"root\"}};\n    vector<string> expected3 = {\"root\"};\n    if (solution.deleteDuplicate(folders3) != expected3) {\n        cout << \"Test case 3 failed.\" << endl;\n    }\n\n    return 0;\n}\n```",
  "1949": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int strongFriendship(vector<vector<string>>& friendships) {\n        unordered_map<string, vector<string>> map;\n        for (const auto& pair : friendships) {\n            map[pair[0]].push_back(pair[1]);\n            map[pair[1]].push_back(pair[0]);\n        }\n        \n        int count = 0;\n        for (const auto& pair : map) {\n            if (pair.second.size() > 2)\n                count++;\n        }\n        return count;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test Case 1\n    vector<vector<string>> friendships1 = {{ \"John\", \"Alice\" }, { \"John\", \"Bob\" }, { \"Bob\", \"Alice\" }};\n    cout << \"Test Case 1: \" << solution.strongFriendship(friendships1) << endl;\n    \n    // Test Case 2\n    vector<vector<string>> friendships2 = {{ \"Eve\", \"Charlie\" }, { \"Eve\", \"Ashley\" }, { \"Ashley\", \"Charlie\" }};\n    cout << \"Test Case 2: \" << solution.strongFriendship(friendships2) << endl;\n\n    // Test Case 3\n    vector<vector<string>> friendships3 = {{ \"Alice\", \"Bob\" }, { \"Bob\", \"Eve\" }, { \"Eve\", \"Charlie\" }, { \"Charlie\", \"John\" }};\n    cout << \"Test Case 3: \" << solution.strongFriendship(friendships3) << endl;\n\n    return 0;\n}",
  "1950": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint maxOfMin(vector<int>& nums) {\n    int n = nums.size();\n    vector<int> minLeft(n, INT_MAX);\n    vector<int> minRight(n, INT_MAX);\n\n    for (int i = 0; i < n; i++) {\n        minLeft[i] = min(nums[i], minLeft[i-1]);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        minRight[i] = min(nums[i], minRight[i+1]);\n    }\n\n    int maxOfMin = INT_MIN;\n    for (int i = 0; i < n; i++) {\n        maxOfMin = max(maxOfMin, min(minLeft[i], minRight[i]));\n    }\n    return maxOfMin;\n}\n\nint main() {\n    vector<int> test1 = {34, 35, 29, 42, 5, 15};\n    cout << \"Test Case 1: Expected - 6, Actual - \" << maxOfMin(test1) << endl;\n\n    vector<int> test2 = {10, 20, 30, 40, 50};\n    cout << \"Test Case 2: Expected - 10, Actual - \" << maxOfMin(test2) << endl;\n\n    vector<int> test3 = {7, 14, 12, 13, 11};\n    cout << \"Test Case 3: Expected - 11, Actual - \" << maxOfMin(test3) << endl;\n}\n```",
  "1951": "```\n#include <vector>\n#include <unordered_map>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<vector<string>> publicFriends(vector<vector<string>>& mutualFriend) {\n        unordered_map<string, unordered_map<string, int>> graph;\n        for (int i = 0; i < mutualFriend.size(); i++) {\n            string person1 = mutualFriend[i][0];\n            string person2 = mutualFriend[i][1];\n            graph[person1][person2] = graph[person2][person1] = 1;\n        }\n        \n        vector<vector<string>> maxFriends;\n        int maxCount = 0;\n        for (auto p1 : graph) {\n            for (auto p2 : graph) {\n                if (p1.first != p2.first && p1.second.count(p2.first)) {\n                    int count = 0;\n                    for (auto p3 : graph) {\n                        if (p3.first != p1.first && p3.first != p2.first && p1.second.count(p3.first) && p2.second.count(p3.first))\n                            count++;\n                    }\n                    if (count > maxCount) {\n                        maxCount = count;\n                        maxFriends.clear();\n                        maxFriends.push_back({p1.first, p2.first});\n                    } else if (count == maxCount) {\n                        maxFriends.push_back({p1.first, p2.first});\n                    }\n                }\n            }\n        }\n        \n        return maxFriends;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<vector<string>> mutualFriend1 = {{ \"John\", \"Steve\" }, { \"John\", \"Tony\" }, { \"John\", \"George\" }, { \"Steve\", \"Tony\" }, { \"Steve\", \"George\" }, { \"Tony\", \"George\" }};\n    vector<vector<string>> result1 = solution.publicFriends(mutualFriend1);\n    for (auto pair : result1) {\n        cout << \"(\" << pair[0] << \", \" << pair[1] << \") \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<vector<string>> mutualFriend2 = {{ \"Alice\", \"Bob\" }, { \"Alice\", \"Charlie\" }, { \"Bob\", \"Charlie\" }};\n    vector<vector<string>> result2 = solution.publicFriends(mutualFriend2);\n    for (auto pair : result2) {\n        cout << \"(\" << pair[0] << \", \" << pair[1] << \") \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<vector<string>> mutualFriend3 = {{ \"X\", \"Y\" }, { \"Y\", \"Z\" }, { \"X\", \"Z\" }, { \"A\", \"B\" }, { \"C\", \"D\" }};\n    vector<vector<string>> result3 = solution.publicFriends(mutualFriend3);\n    for (auto pair : result3) {\n        cout << \"(\" << pair[0] << \", \" << pair[1] << \") \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1952": "```\n#include <iostream>\nusing namespace std;\n\nbool hasThreeDivisors(int n) {\n    int count = 0;\n    for (int i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            if (i * i != n && i != n / i)\n                count++;\n            else\n                count += 2;\n        }\n    }\n    return count >= 3;\n}\n\nint main() {\n    cout << boolalpha;\n    cout << \"Test case 1: \" << hasThreeDivisors(4) << endl; // True\n    cout << \"Test case 2: \" << hasThreeDivisors(25) << endl; // False\n    cout << \"Test case 3: \" << hasThreeDivisors(30) << endl; // True\n    return 0;\n}\n```",
  "1953": "```\n#include <iostream>\n#include <vector>\n\nint maxWeeks(std::vector<int>& days) {\n    int weeks = 0;\n    for (int i = 0; i < days.size(); i += 7) {\n        weeks++;\n    }\n    return weeks;\n}\n\nint main() {\n    std::vector<int> test1({5,2,8,8,3,4,6});\n    std::cout << \"Test case 1: \" << maxWeeks(test1) << std::endl;\n\n    std::vector<int> test2({2,10,3,7,15});\n    std::cout << \"Test case 2: \" << maxWeeks(test2) << std::endl;\n\n    std::vector<int> test3({1,4,6,8,7,5,16,15});\n    std::cout << \"Test case 3: \" << maxWeeks(test3) << std::endl;\n\n    return 0;\n}\n```",
  "1954": "```\n#include <iostream>\n#include <vector>\n\nint minEatingTime(std::vector<std::vector<int>>& grid) {\n    int m = grid.size();\n    if (m == 0) return 0;\n    int n = grid[0].size();\n\n    int res = 0;\n    for (int i = 0; i < m; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] > 0) {\n                int x1, y1, x2, y2;\n                if (i > 0 && grid[i - 1][j] > 0) {\n                    x1 = i - 1;\n                    y1 = j;\n                } else {\n                    x1 = i;\n                    y1 = j;\n                }\n                for (int k = i + 1; k < m; ++k) {\n                    if (grid[k][j] > 0) {\n                        x2 = k - 1;\n                        break;\n                    }\n                }\n\n                int l, r;\n                for (l = 0; l <= j; ++l) {\n                    if (grid[i][l] > 0) break;\n                }\n                for (; l <= n; ++l) {\n                    if (grid[i][l] == 0) break;\n                    r = l - 1;\n                }\n\n                int midX, midY;\n                for (int k = x1; k <= x2; ++k) {\n                    for (int m = l; m <= r; ++m) {\n                        grid[k][m] -= 1;\n                        if (grid[k][m] == 0) {\n                            int dX = m - y1;\n                            int dY = k - x1;\n                            res += abs(dX) + abs(dY);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return res;\n}\n\nint main() {\n    std::vector<std::vector<int>> grid1 = {{1,1},{1,0}};\n    std::cout << minEatingTime(grid1) << std::endl;\n\n    std::vector<std::vector<int>> grid2 = {{5,3,1},{4,2,2},{3,2,2}};\n    std::cout << minEatingTime(grid2) << std::endl;\n\n    std::vector<std::vector<int>> grid3 = {{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}};\n    std::cout << minEatingTime(grid3) << std::endl;\n}\n```",
  "1955": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int specialSubsequences(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> dp(n, vector<int>(2, 0));\n        \n        for (int i = 1; i < n; i++) {\n            if (nums[i] > nums[i - 1]) {\n                dp[i][0] = dp[i - 1][0];\n                dp[i][1] = max(dp[i - 1][0], dp[i - 1][1] + 1);\n            } else {\n                dp[i][0] = max(dp[i - 1][0] + 2, dp[i - 1][1]);\n                dp[i][1] = dp[i - 1][1];\n            }\n        }\n        \n        return dp[n - 1][1];\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    vector<int> nums1 = {12, 15, 26, 27, 29};\n    cout << \"Test case 1: \" << solution.specialSubsequences(nums1) << endl;  // Expected output: 6\n    \n    vector<int> nums2 = {4, 4, 7, 5, 6, 13};\n    cout << \"Test case 2: \" << solution.specialSubsequences(nums2) << endl;  // Expected output: 4\n    \n    vector<int> nums3 = {1, 2, 3, 4, 5};\n    cout << \"Test case 3: \" << solution.specialSubsequences(nums3) << endl;  // Expected output: 0\n    \n    return 0;\n}\n```",
  "1956": "```\n#include <iostream>\n#include <vector>\n\nint minTime(int n, int fn, std::vector<int>& virus) {\n    // your solution here\n}\n\nint main() {\n    // Test Case 1:\n    int n = 2;\n    int fn = 5;\n    std::vector<int> virus = {0, 4};\n    int result1 = minTime(n, fn, virus);\n    if (result1 == 8) {\n        std::cout << \"Test Case 1 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test Case 1 failed. Expected: 8, but got: \" << result1 << std::endl;\n    }\n\n    // Test Case 2:\n    n = 3;\n    fn = 6;\n    virus = {0, 2, 4};\n    int result2 = minTime(n, fn, virus);\n    if (result2 == 14) {\n        std::cout << \"Test Case 2 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test Case 2 failed. Expected: 14, but got: \" << result2 << std::endl;\n    }\n\n    // Test Case 3:\n    n = 5;\n    fn = 9;\n    virus = {0, 1, 2, 4, 6};\n    int result3 = minTime(n, fn, virus);\n    if (result3 == 23) {\n        std::cout << \"Test Case 3 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test Case 3 failed. Expected: 23, but got: \" << result3 << std::endl;\n    }\n\n    return 0;\n}",
  "1957": "```\n#include <iostream>\n#include <string>\n\nint totalFruit(std::string f) {\n    int maxLen = 0;\n    int currLen = 0;\n    char prevChar = '\\0';\n    for (char c : f) {\n        if (c == prevChar) {\n            currLen++;\n        } else {\n            prevChar = c;\n            currLen = 1;\n        }\n        maxLen = std::max(maxLen, currLen);\n    }\n    return maxLen;\n}\n\nint main() {\n    std::cout << \"Test Case 1: \" << totalFruit(\"applepenapple\") << std::endl; // Expected output: 3\n    std::cout << \"Test Case 2: \" << totalFruit(\"apple\") << std::endl; // Expected output: 1\n    std::cout << \"Test Case 3: \" << totalFruit(\"banana\") << std::endl; // Expected output: 1\n    return 0;\n}\n```",
  "1959": "```\n#include <iostream>\n#include <vector>\n\nint minCost(int arr[], int m, int n) {\n    std::vector<std::vector<int>> dp(m + 1, std::vector<int>(n + 1));\n\n    for (int i = 1; i <= m; i++) {\n        dp[i][0] = i * arr[0];\n    }\n\n    for (int j = 1; j <= n; j++) {\n        dp[0][j] = j * arr[1];\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i < j) {\n                dp[i][j] = std::min(std::min(dp[i][j - 1], dp[i + 1][j]), arr[0] * min(i, j));\n            } else {\n                dp[i][j] = std::min({dp[i][j - 1], dp[i + 1][j]});\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n\nint main() {\n    int arr[] = {3, 5};\n    int m = 4;\n    int n = 6;\n    \n    std::cout << \"Minimum total space wasted: \" << minCost(arr, m, n) << std::endl;\n\n    arr[0] = 2;\n    arr[1] = 3;\n    m = 5;\n    n = 8;\n    \n    std::cout << \"Minimum total space wasted: \" << minCost(arr, m, n) << std::endl;\n\n    arr[0] = 10;\n    arr[1] = 15;\n    m = 2;\n    n = 3;\n    \n    std::cout << \"Minimum total space wasted: \" << minCost(arr, m, n) << std::endl;\n\n    return 0;\n}",
  "1958": "```\n#include <iostream>\n#include <vector>\n\nbool checkMove(std::vector<std::vector<int>>& board, int xStart, int yStart, int xEnd, int yEnd) {\n    // Check if start and end positions are within the board\n    if (xStart < 0 || xStart >= board.size() || yStart < 0 || yStart >= board[0].size() ||\n        xEnd < 0 || xEnd >= board.size() || yEnd < 0 || yEnd >= board[0].size()) {\n        return false;\n    }\n\n    // Check if start position is empty\n    if (board[xStart][yStart] != 0) {\n        return false;\n    }\n\n    // Check if end position is not occupied by the same player or piece\n    if ((xEnd == xStart && yEnd == yStart) || board[xEnd][yEnd] == board[xStart][yStart]) {\n        return true;\n    }\n\n    return false;\n}\n\nint main() {\n    std::vector<std::vector<int>> board1 = {{0, 0, 0}, {0, 2, 0}, {0, 0, 0}};\n    std::cout << checkMove(board1, 0, 0, 0, 2) << std::endl; // Expected output: false\n\n    std::vector<std::vector<int>> board2 = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};\n    std::cout << checkMove(board2, 0, 0, 1, 1) << std::endl; // Expected output: true\n\n    std::vector<std::vector<int>> board3 = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};\n    std::cout << checkMove(board3, 0, 2, 2, 2) << std::endl; // Expected output: false\n\n    return 0;\n}\n```",
  "1961": "```\n#include <iostream>\n#include <vector>\n\nbool isPrefix(std::vector<std::string>& words, std::string word) {\n    for (int i = 0; i < words.size(); ++i) {\n        if (words[i].compare(0, word.length(), word) != 0)\n            return false;\n    }\n    return true;\n}\n\nint main() {\n    // Test Case 1\n    std::vector<std::string> words1 = {\"love\", \"like\", \"lovely\", \"lonely\"};\n    std::cout << (isPrefix(words1, \"lo\") ? \"True\" : \"False\") << std::endl;\n\n    // Test Case 2\n    std::vector<std::string> words2 = {\"hello\", \"hi\", \"hola\", \"goodbye\"};\n    std::cout << (isPrefix(words2, \"hi\") ? \"True\" : \"False\") << std::endl;\n\n    // Test Case 3\n    std::vector<std::string> words3 = {\"abc\", \"abcd\", \"abcde\", \"abcdef\"};\n    std::cout << (isPrefix(words3, \"abc\") ? \"True\" : \"False\") << std::endl;\n    \n    return 0;\n}\n```",
  "1960": "```\n#include <iostream>\n#include <string>\n\nint maxProduct(int len1, int len2) {\n    return len1 * len2;\n}\n\nint main() {\n    std::cout << \"Test case 1: \" << maxProduct(5, 7) << std::endl; // Expected output: 35\n    std::cout << \"Test case 2: \" << maxProduct(3, 4) << std::endl; // Expected output: 12\n    std::cout << \"Test case 3: \" << maxProduct(1, 2) << std::endl; // Expected output: 2\n\n    return 0;\n}\n```",
  "1963": "```\n#include <iostream>\n#include <string>\n\nint minSwaps(std::string s) {\n    int left = 0, right = s.length() - 1;\n    int swaps = 0;\n\n    while (left < right) {\n        if (s[left] == 'X' && s[right] == 'O') {\n            std::swap(s[left], s[right]);\n            swaps++;\n            left++;\n            right--;\n        } else if (s[left] == 'O') {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return swaps;\n}\n\nint main() {\n    // Test case 1\n    std::cout << minSwaps(\"OXOX\") << std::endl; // Expected output: 2\n\n    // Test case 2\n    std::cout << minSwaps(\"OOOXX\") << std::endl; // Expected output: 2\n\n    // Test case 3\n    std::cout << minSwaps(\"XOXOO\") << std::endl; // Expected output: 4\n\n    return 0;\n}\n```",
  "1962": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int min Stones(int piles[], int n) {\n        priority_queue<int> pq;\n        for (int i = 0; i < n; i++) {\n            pq.push(piles[i]);\n        }\n        int res = 0;\n        while (pq.size() > 1) {\n            res += pq.top();\n            pq.pop();\n            if (!pq.empty()) {\n                pq.push(pq.top() - 1);\n                pq.pop();\n            }\n        }\n        return res + pq.top();\n    }\n};\n\nint main() {\n    Solution solution;\n    int testCases[][] = {\n        {5,3,4,2},\n        {1,2,3,4,5},\n        {7,8}\n    };\n    for (auto testCase : testCases) {\n        cout << \"Test case: \";\n        for (int i = 0; i < sizeof(testCase)/sizeof(int); i++) {\n            cout << testCase[i] << \" \";\n        }\n        cout << endl;\n        cout << \"Result: \" << solution.minStones(testCase, sizeof(testCase)/sizeof(int)) << endl;\n    }\n    return 0;\n}\n```",
  "1964": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> longestObstacleCourse(vector<vector<int>>& obstacles) {\n        int n = obstacles.size();\n        vector<int> dp(n, 1);\n        vector<int> res(n, -1);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (obstacles[i][0] >= obstacles[j][1]) {\n                    dp[i] = max(dp[i], dp[j]);\n                    if (dp[i] > res[i]) {\n                        res[i] = i - dp[i] + 1;\n                    }\n                }\n            }\n        }\n\n        vector<int> ans(n, 0);\n        for (int i = n - 1; i >= 0; i--) {\n            if (res[i] != -1) {\n                int j = res[i];\n                while (j < n && obstacles[j][0] <= obstacles[i][1]) {\n                    ans[i] = max(ans[i], dp[j]);\n                    j++;\n                }\n            }\n        }\n\n        return ans;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    vector<vector<int>> obstacles1 = {{9,10},{8,10},{5,6},{4,7},{3,7}};\n    vector<int> res1 = solution.longestObstacleCourse(obstacles1);\n    for (auto x : res1) cout << x << \" \";\n    cout << endl;\n\n    vector<vector<int>> obstacles2 = {{2,8},{4,9},{5,11}};\n    vector<int> res2 = solution.longestObstacleCourse(obstacles2);\n    for (auto x : res2) cout << x << \" \";\n    cout << endl;\n\n    vector<vector<int>> obstacles3 = {};\n    vector<int> res3 = solution.longestObstacleCourse(obstacles3);\n    for (auto x : res3) cout << x << \" \";\n    cout << endl;\n    \n    return 0;\n}\n```",
  "1965": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Employee {\n    std::string id;\n    std::string name;\n    std::string email;\n};\n\nstd::vector<Employee> getEmployeesWithMissingInformation(std::vector<Employee> employees) {\n    std::vector<Employee> result;\n    for (const auto& employee : employees) {\n        if (employee.name.empty() || employee.email.empty()) {\n            result.push_back(employee);\n        }\n    }\n    return result;\n}\n\nint main() {\n    // Test case 1\n    std::vector<Employee> employees1 = {{ \"emp1\", \"\", \"emp1@example.com\" },\n                                          {\"emp2\", \"John Doe\", \"\"}};\n    std::vector<Employee> expected1 = {{ \"emp1\", \"\", \"emp1@example.com\" }};\n    auto result1 = getEmployeesWithMissingInformation(employees1);\n    if (result1 != expected1) {\n        std::cout << \"Test case 1 failed.\\n\";\n        return 1;\n    }\n    \n    // Test case 2\n    std::vector<Employee> employees2 = {{ \"\", \"Jane Smith\", \"jane@example.com\" },\n                                          {\"emp3\", \"Bob Johnson\", \"bob@example.com\"}};\n    std::vector<Employee> expected2 = {};\n    auto result2 = getEmployeesWithMissingInformation(employees2);\n    if (result2 != expected2) {\n        std::cout << \"Test case 2 failed.\\n\";\n        return 1;\n    }\n    \n    // Test case 3\n    std::vector<Employee> employees3 = {{ \"emp4\", \"\", \"\" },\n                                          {\"emp5\", \"Alice Brown\", \"alice@example.com\"}};\n    std::vector<Employee> expected3 = {{ \"emp4\", \"\", \"\" }, { \"emp5\", \"Alice Brown\", \"alice@example.com\" }};\n    auto result3 = getEmployeesWithMissingInformation(employees3);\n    if (result3 != expected3) {\n        std::cout << \"Test case 3 failed.\\n\";\n        return 1;\n    }\n    \n    std::cout << \"All test cases passed.\\n\";\n    return 0;\n}\n```",
  "1966": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint binarySearchableNumbers(std::vector<int>& nums) {\n    int count = 0;\n    for (int i = 0; i < nums.size(); i++) {\n        bool isBinarySearchable = true;\n        for (int j = 0; j < nums.size() && isBinarySearchable; j++) {\n            if (j != i && nums[j] >= nums[i]) {\n                isBinarySearchable = false;\n            }\n        }\n        count += isBinarySearchable;\n    }\n    return count;\n}\n\nint main() {\n    std::vector<int> test1 = {10, 2, 5, 3};\n    std::cout << \"Test Case 1: \" << binarySearchableNumbers(test1) << \"\\n\";\n\n    std::vector<int> test2 = {1, 3, 8, 4, 3};\n    std::cout << \"Test Case 2: \" << binarySearchableNumbers(test2) << \"\\n\";\n\n    std::vector<int> test3 = {};\n    std::cout << \"Test Case 3: \" << binarySearchableNumbers(test3) << \"\\n\";\n\n    return 0;\n}",
  "1967": "```\n#include <iostream>\n#include <vector>\n\nint countSubString(const std::string& word, const std::vector<std::string>& strings) {\n    int count = 0;\n    for (const auto& str : strings) {\n        if (word.find(str) != std::string::npos) {\n            count++;\n        }\n    }\n    return count;\n}\n\nint main() {\n    std::vector<std::string> strings1 = {\"abc\", \"bcd\", \"xyz\"};\n    int result1 = countSubString(\"abcdefxyz\", strings1);\n    if (result1 == 2) {\n        std::cout << \"Test case 1 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 1 failed!\" << std::endl;\n    }\n\n    std::vector<std::string> strings2 = {\"ab\", \"c\", \"def\"};\n    int result2 = countSubString(\"abcdef\", strings2);\n    if (result2 == 3) {\n        std::cout << \"Test case 2 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 2 failed!\" << std::endl;\n    }\n\n    std::vector<std::string> strings3 = {\"abc\", \"def\", \"ghi\"};\n    int result3 = countSubString(\"abcdefghi\", strings3);\n    if (result3 == 0) {\n        std::cout << \"Test case 3 passed!\" << std::endl;\n    } else {\n        std::cout << \"Test case 3 failed!\" << std::endl;\n    }\n\n    return 0;\n}\n```",
  "1968": "```\n#include <iostream>\n#include <vector>\n\nbool canBeEqual(const std::vector<int>& nums) {\n    int sum = 0;\n    for (int num : nums) {\n        sum += num;\n    }\n    if (sum % nums.size() != 0) return false;\n\n    int average = sum / nums.size();\n    for (int i = 1; i < nums.size(); i++) {\n        if ((nums[i] == average && (nums[i-1] != average || nums[i+1] != average)) ||\n            (nums[i] != average && (nums[i-1] == average || nums[i+1] == average))) return false;\n    }\n    return true;\n}\n\nint main() {\n    std::cout << canBeEqual({10,2,-10,-10,5,5}) << std::endl;  // Expected: true\n    std::cout << canBeEqual({-1,-1,1,1,-1,-6,-1,-1}) << std::endl;  // Expected: false\n    std::cout << canBeEqual({0,0,4,2,3}) << std::endl;  // Expected: true\n    return 0;\n}",
  "1969": "```\n#include <iostream>\n#include <vector>\n\nint minNonZeroProduct(const std::vector<int>& nums) {\n    int product = 1;\n    bool foundZeros = false;\n\n    for (int num : nums) {\n        if (num == 0) {\n            if (!foundZeros) {\n                foundZeros = true;\n            } else {\n                return 0;\n            }\n        } else {\n            product *= num;\n        }\n    }\n\n    return product;\n}\n\nint main() {\n    std::vector<int> nums1 = {3, 4, 5};\n    int result1 = minNonZeroProduct(nums1);\n    std::cout << \"Test Case 1: Product of non-zero elements in array {3, 4, 5} is \" << result1 << std::endl;\n\n    std::vector<int> nums2 = {0, 2, 3};\n    int result2 = minNonZeroProduct(nums2);\n    std::cout << \"Test Case 2: Product of non-zero elements in array {0, 2, 3} is \" << result2 << std::endl;\n\n    std::vector<int> nums3 = {1, 2, 3, 4};\n    int result3 = minNonZeroProduct(nums3);\n    std::cout << \"Test Case 3: Product of non-zero elements in array {1, 2, 3, 4} is \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1970": "```\n#include <iostream>\n#include <vector>\n\nclass Solution {\npublic:\n    int lastDay(int n) {\n        for (int i = n; i >= 1; --i) {\n            if ((i & (i << 1)) == 0) return i;\n        }\n        return -1;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    int n1 = 5;\n    std::cout << \"Test case 1: The last day where you can still cross is \" << solution.lastDay(n1) << std::endl;\n\n    // Test case 2\n    int n2 = 3;\n    std::cout << \"Test case 2: The last day where you can still cross is \" << solution.lastDay(n2) << std::endl;\n\n    // Test case 3\n    int n3 = 10;\n    std::cout << \"Test case 3: The last day where you can still cross is \" << solution.lastDay(n3) << std::endl;\n\n    return 0;\n}\n```",
  "1971": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool hasPath(int n, vector<vector<int>>& edges, int start, int target) {\n        vector<int> parent(n);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n        \n        function<int(int)> find = [&](int x) {\n            if (parent[x] != x)\n                parent[x] = find(parent[x]);\n            return parent[x];\n        };\n        \n        function<void(int, int)> unionTwo = [&](int x, int y) {\n            parent[find(x)] = find(y);\n        };\n        \n        for (const auto& edge : edges) {\n            unionTwo(edge[0], edge[1]);\n        }\n        \n        return find(start) == find(target);\n    }\n};\n\nint main() {\n    Solution solution;\n    \n    // Test Case 1\n    int n1 = 3;\n    vector<vector<int>> edges1 = {{0,1},{1,2},{2,0}};\n    int start1 = 0, target1 = 2;\n    cout << \"Test Case 1: \";\n    if (solution.hasPath(n1, edges1, start1, target1)) {\n        cout << \"True\" << endl;\n    } else {\n        cout << \"False\" << endl;\n    }\n    \n    // Test Case 2\n    int n2 = 6;\n    vector<vector<int>> edges2 = {{0,1},{1,2},{2,3},{3,4},{4,5}};\n    int start2 = 0, target2 = 5;\n    cout << \"Test Case 2: \";\n    if (solution.hasPath(n2, edges2, start2, target2)) {\n        cout << \"True\" << endl;\n    } else {\n        cout << \"False\" << endl;\n    }\n    \n    // Test Case 3\n    int n3 = 4;\n    vector<vector<int>> edges3 = {{0,1},{1,2},{2,3}};\n    int start3 = 0, target3 = 3;\n    cout << \"Test Case 3: \";\n    if (solution.hasPath(n3, edges3, start3, target3)) {\n        cout << \"True\" << endl;\n    } else {\n        cout << \"False\" << endl;\n    }\n    \n    return 0;\n}\n```",
  "1972": "```\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nclass CallLog {\npublic:\n    vector<string> getFirstAndLastCallOnSameDay(vector<vector<string>>& calls) {\n        unordered_map<int, pair<int, int>> callMap;\n        \n        for (const auto& call : calls) {\n            int id = stoi(call[0]);\n            string timestamp = call[1];\n            \n            if (!callMap.count(id)) {\n                callMap[id] = {stoi(timestamp), -1};\n            } else {\n                int prevTimestamp = callMap.at(id).first;\n                int lastCallTime = callMap.at(id).second;\n                \n                if (prevTimestamp < 0) {\n                    callMap.at(id) = {stoi(timestamp), stoi(timestamp)};\n                } else if (lastCallTime == prevTimestamp) {\n                    callMap.at(id).second = stoi(timestamp);\n                }\n            }\n        }\n        \n        vector<string> result;\n        for (const auto& pair : callMap) {\n            if (pair.second.second != -1) {\n                result.push_back(to_string(pair.first) + \" \" + to_string(pair.second.first) + \" \" + to_string(pair.second.second));\n            }\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    CallLog log;\n\n    vector<vector<string>> calls = {{\"2020-01-01 00:00:00\", \"10\"}, {\"2020-01-01 12:45:00\", \"10\"}, {\"2020-01-02 14:15:00\", \"11\"}};\n    cout << \"Case 1: \";\n    for (const auto& call : log.getFirstAndLastCallOnSameDay(calls)) {\n        cout << call << \" \";\n    }\n    cout << endl;\n\n    calls = {{\"2020-01-03 10:45:00\", \"12\"}, {\"2020-01-04 13:15:00\", \"12\"}};\n    cout << \"Case 2: \";\n    for (const auto& call : log.getFirstAndLastCallOnSameDay(calls)) {\n        cout << call << \" \";\n    }\n    cout << endl;\n\n    calls = {{\"2020-01-05 10:45:00\", \"13\"}, {\"2020-01-06 10:15:00\", \"14\"}};\n    cout << \"Case 3: \";\n    for (const auto& call : log.getFirstAndLastCallOnSameDay(calls)) {\n        cout << call << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1973": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct TreeNode {\n    int val;\n    TreeNode *left;\n    TreeNode *right;\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n};\n\nclass Solution {\npublic:\n    int countNodes(TreeNode* root, TreeNode* parent = NULL) {\n        if (root == NULL)\n            return 0;\n\n        int sumDescendants = 1; // Include current node\n\n        if (parent != NULL && parent->val > root->val) {\n            // Left child\n            sumDescendants += countNodes(root->right, root);\n        } else if (parent != NULL && parent->val < root->val) {\n            // Right child\n            sumDescendants += countNodes(root->left, root);\n        }\n\n        return sumDescendants;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    TreeNode* node1 = new TreeNode(1);\n    TreeNode* node2 = new TreeNode(2);\n    TreeNode* node3 = new TreeNode(3);\n    TreeNode* node4 = new TreeNode(4);\n    TreeNode* node5 = new TreeNode(5);\n\n    node1->left = node2;\n    node1->right = node3;\n    node2->left = node4;\n    node2->right = node5;\n\n    cout << \"Test Case 1: \" << solution.countNodes(node1) << endl; // Expected output: 4\n\n    TreeNode* node6 = new TreeNode(1);\n    TreeNode* node7 = new TreeNode(2);\n    TreeNode* node8 = new TreeNode(3);\n\n    node6->left = node7;\n    node6->right = node8;\n\n    cout << \"Test Case 2: \" << solution.countNodes(node6) << endl; // Expected output: 1\n\n    TreeNode* node9 = new TreeNode(5);\n    TreeNode* node10 = new TreeNode(3);\n    TreeNode* node11 = new TreeNode(7);\n\n    node9->left = node10;\n    node9->right = node11;\n\n    cout << \"Test Case 3: \" << solution.countNodes(node9) << endl; // Expected output: 1\n\n    return 0;\n}\n```",
  "1974": "```\n#include <iostream>\n#include <string>\n\nint minTimeToType(std::string word) {\n    int time = 0;\n    bool prevCaps = false;\n\n    for (char c : word) {\n        bool caps = isupper(c);\n\n        if (caps != prevCaps)\n            time += 1; // change capitalization\n\n        time += caps ? 2 : 1; // add typing time\n        prevCaps = caps;\n    }\n\n    return time;\n}\n\nint main() {\n    std::cout << minTimeToType(\"HelloWorld\") << \"\\n\"; // Output: 10\n    std::cout << minTimeToType(\"abcdefghijklmnopqrstuvwxyz\") << \"\\n\"; // Output: 26\n    std::cout << minTimeToType(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\") << \"\\n\"; // Output: 26\n\n    return 0;\n}\n```",
  "1975": "```\n#include <iostream>\n#include <vector>\n\nint maxMatrixSum(std::vector<std::vector<int>>& matrix) {\n    int n = matrix.size();\n    int m = matrix[0].size();\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (matrix[i][j] > 0) {\n                matrix[i][j] = -matrix[i][j];\n            }\n        }\n    }\n\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            sum += matrix[i][j];\n        }\n    }\n\n    if (sum < 0 && n > 1 && m > 1) {\n        return -abs(sum) + min({matrix[0][0], matrix[0][m-1], matrix[n-1][0], matrix[n-1][m-1]});\n    } else {\n        return sum;\n    }\n}\n\nint main() {\n    std::vector<std::vector<int>> test1 = {{1, -4, 3}, {2, 5, -2}};\n    int result1 = maxMatrixSum(test1);\n    std::cout << \"Test case 1: \" << result1 << std::endl;\n\n    std::vector<std::vector<int>> test2 = {{10,-3,-24},{-7,50,18}};\n\n    int result2 = maxMatrixSum(test2);\n    std::cout << \"Test case 2: \" << result2 << std::endl;\n\n    std::vector<std::vector<int>> test3 = {{1,-4,7},{13,0,-10}};\n\n    int result3 = maxMatrixSum(test3);\n    std::cout << \"Test case 3: \" << result3 << std::endl;\n\n    return 0;\n}\n```",
  "1976": "```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint numWays(int n, vector<vector<int>>& flights, int k) {\n    vector<int> dp(n + 1, 0);\n    for (int i = 1; i <= n; i++) {\n        for (auto& flight : flights) {\n            if (flight[0] == i) {\n                dp[i] += 1;\n                if (i < k && flight[2]) {\n                    dp[k]++;\n                }\n            } else if (flight[1] == i) {\n                dp[i] = 1;\n                if (i < k && flight[2]) {\n                    dp[k]++;\n                }\n            }\n        }\n    }\n    return dp.back();\n}\n\nint main() {\n    int n1 = 2, k1 = 2; \n    vector<vector<int>> flights1 = {{0, 1, 10}, {1, 2, 3}};\n    cout << numWays(n1, flights1, k1) << endl;\n    \n    int n2 = 3, k2 = 4; \n    vector<vector<int>> flights2 = {{0, 1, 100}, {1, 2, 10}, {2, 3, 6}};\n    cout << numWays(n2, flights2, k2) << endl;\n    \n    int n3 = 5, k3 = 4; \n    vector<vector<int>> flights3 = {{0, 1, 10}, {1, 2, 3}, {0, 2, 5}, {0, 3, 3}};\n    cout << numWays(n3, flights3, k3) << endl;\n    \n    return 0;\n}\n```",
  "1977": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int numSeparate(string s) {\n        int n = s.size();\n        vector<int> prefixSum(n + 1, 0);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                prefixSum[i + 1] = prefixSum[i] + 1;\n            } else {\n                prefixSum[i + 1] = prefixSum[i];\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') {\n                int left = prefixSum[i];\n                for (int j = i + 1; j <= n; j++) {\n                    if (s[j - 1] != '0') break;\n                    res += min(left, j - i);\n                    left--;\n                }\n            }\n        }\n\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << solution.numSeparate(\"001\") << endl; // Expected output: 3\n    cout << solution.numSeparate(\"0110\") << endl; // Expected output: 4\n    cout << solution.numSeparate(\"00011\") << endl; // Expected output: 6\n\n    return 0;\n}\n```",
  "1978": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nstruct Employee {\n    int id;\n    int mgrId;\n};\n\nstd::vector<Employee> employees = {{1, 2}, {2, 3}, {4, 5}, {5, 6}, {7, 1}};\n\nint main() {\n    std::sort(employees.begin(), employees.end(), \n              [](const Employee& a, const Employee& b) { return a.mgrId < b.mgrId; });\n    \n    int leftEmployees = 0;\n    for (int i = 0; i < employees.size(); ++i) {\n        if (i > 0 && employees[i].mgrId == employees[i - 1].id) {\n            continue;\n        }\n        \n        for (int j = i + 1; j < employees.size(); ++j) {\n            if (employees[j].id != employees[i].id && employees[j].mgrId == employees[i].id) {\n                leftEmployees++;\n                break;\n            }\n        }\n    }\n    \n    std::cout << \"Number of employees whose manager left the company: \" << leftEmployees << std::endl;\n    \n    return 0;\n}\n\n```",
  "1979": "```\n#include <iostream>\n#include <vector>\n\nint findGCD(std::vector<int>& nums) {\n    int res = nums[0];\n    for (int i = 1; i < nums.size(); ++i) {\n        res = __gcd(res, nums[i]);\n    }\n    return res;\n}\n\nint main() {\n    std::vector<int> nums1 = {2, 4, 6};\n    std::cout << \"GCD of \" << std::endl;\n    for (int num : nums1)\n        std::cout << num << \" \";\n    std::cout << \"is \" << findGCD(nums1) << \".\" << std::endl;\n\n    std::vector<int> nums2 = {2, 7};\n    std::cout << \"GCD of \" << std::endl;\n    for (int num : nums2)\n        std::cout << num << \" \";\n    std::cout << \"is \" << findGCD(nums2) << \".\" << std::endl;\n\n    std::vector<int> nums3 = {4, 18};\n    std::cout << \"GCD of \" << std::endl;\n    for (int num : nums3)\n        std::cout << num << \" \";\n    std::cout << \"is \" << findGCD(nums3) << \".\" << std::endl;\n\n    return 0;\n}\n```",
  "1980": "```\n#include <iostream>\n#include <vector>\n#include <string>\n\nint minFlips(std::vector<std::string>& strs) {\n    int n = strs.size();\n    int res = INT_MAX;\n    for (int i = 0; i < (1 << n); ++i) {\n        bool valid = true;\n        std::string str = \"\";\n        for (int j = 0; j < n; ++j) {\n            if (((i >> j) & 1) && (strs[j][0] == '0')) {\n                valid = false;\n                break;\n            }\n            if (!((i >> j) & 1) && (strs[j][0] == '1')) {\n                valid = false;\n                break;\n            }\n            str += strs[j][0];\n        }\n        if (valid) res = std::min(res, count(str));\n    }\n    return res;\n}\n\nint count(const std::string& s) {\n    int res = 0;\n    for (char c : s) res += c - '0';\n    return res;\n}\n\nint main() {\n    std::vector<std::string> strs1 = {\"01\",\"10\"};\n    std::cout << minFlips(strs1) << std::endl;\n\n    std::vector<std::string> strs2 = {\"00\",\"01\",\"11\"};\n    std::cout << minFlips(strs2) << std::endl;\n\n    std::vector<std::string> strs3 = {\"0000\",\"0110\",\"1111\"};\n    std::cout << minFlips(strs3) << std::endl;\n\n    return 0;\n}\n```",
  "1981": "```\n#include <iostream>\n#include <vector>\n\nint totalVariance(std::vector<int>& nums) {\n    int n = nums.size();\n    long long sum1 = 0, sum2 = 0;\n    \n    for (int num : nums) {\n        sum1 += num;\n        sum2 += num * num;\n    }\n    \n    double mean = 1.0 * sum1 / n;\n    double variance = 1.0 * (sum2 - sum1 * sum1 / n) / (n - 1);\n    return static_cast<int>(variance);\n}\n\nint minAbsoluteSumDiff(std::vector<int>& nums, int target) {\n    int n = nums.size();\n    std::vector<int> diff(n);\n    \n    for (int i = 0; i < n; ++i) {\n        diff[i] = abs(nums[i] - target);\n    }\n    \n    std::sort(diff.begin(), diff.end());\n    \n    int left = 0, right = n - 1;\n    int minDiff = diff[n-1];\n    \n    while (left <= right) {\n        if ((target - nums[left]) <= (nums[right] - target)) {\n            int newTarget = target - diff[left];\n            int newVariance = totalVariance(nums);\n            minDiff = std::min(minDiff, abs(newTarget - newVariance));\n            left++;\n        } else {\n            int newTarget = target + diff[right];\n            int newVariance = totalVariance(nums);\n            minDiff = std::min(minDiff, abs(newTarget - newVariance));\n            right--;\n        }\n    }\n    \n    return minDiff;\n}\n\nint main() {\n    std::vector<int> nums1 = {4, 5};\n    int target1 = 5;\n    std::cout << \"Test case 1: \" << minAbsoluteSumDiff(nums1, target1) << \"\\n\";\n    \n    std::vector<int> nums2 = {1, 3, 6};\n    int target2 = 3;\n    std::cout << \"Test case 2: \" << minAbsoluteSumDiff(nums2, target2) << \"\\n\";\n    \n    std::vector<int> nums3 = {9, 11, 13, 14};\n    int target3 = 10;\n    std::cout << \"Test case 3: \" << minAbsoluteSumDiff(nums3, target3) << \"\\n\";\n    \n    return 0;\n}",
  "1982": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> subsetSums(vector<int>& nums, int targetSum) {\n        sort(nums.begin(), nums.end());\n        vector<int> res;\n        helper(nums, 0, targetSum, res);\n        return res;\n    }\n    \nprivate:\n    void helper(vector<int>& nums, int start, int targetSum, vector<int>& res) {\n        if (targetSum < 0) {\n            return;\n        }\n        \n        if (targetSum == 0) {\n            res.push_back(0);\n            return;\n        }\n        \n        for (int i = start; i < nums.size(); i++) {\n            int val = nums[i];\n            helper(nums, i + 1, targetSum - val, res);\n            res.push_back(targetSum - val);\n        }\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> test1 = {5,7,6};\n    int targetSum1 = 15;\n    vector<int> result1 = solution.subsetSums(test1, targetSum1);\n    for (int sum : result1) {\n        cout << sum << \" \";\n    }\n    cout << endl;\n\n    // Test case 2\n    vector<int> test2 = {3,5};\n    int targetSum2 = 8;\n    vector<int> result2 = solution.subsetSums(test2, targetSum2);\n    for (int sum : result2) {\n        cout << sum << \" \";\n    }\n    cout << endl;\n\n    // Test case 3\n    vector<int> test3 = {1};\n    int targetSum3 = 0;\n    vector<int> result3 = solution.subsetSums(test3, targetSum3);\n    for (int sum : result3) {\n        cout << sum << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```",
  "1983": "```\n#include <iostream>\n#include <vector>\n\nint maxEqualRangeSum(std::vector<int>& nums) {\n    int n = nums.size();\n    std::vector<int> prefixSum(n + 1, 0);\n    for (int i = 0; i < n; ++i) {\n        prefixSum[i + 1] = prefixSum[i] + nums[i];\n    }\n\n    int maxWidth = 0;\n    int left = 0, right = 0;\n\n    for (int i = 0; i < n; ++i) {\n        for (int j = i; j < n; ++j) {\n            int sumLeft = prefixSum[i] - (i > 0 ? prefixSum[i - 1] : 0);\n            int sumRight = prefixSum[j + 1] - (j >= 0 ? prefixSum[j] : 0);\n\n            if (sumLeft == sumRight && j - i + 1 > maxWidth) {\n                maxWidth = j - i + 1;\n                left = i;\n                right = j;\n            }\n        }\n    }\n\n    return right - left + 1;\n}\n\nint main() {\n    std::vector<int> nums1 = {3, 2, 4, 5};\n    std::cout << \"Test case 1: \" << maxEqualRangeSum(nums1) << std::endl;\n\n    std::vector<int> nums2 = {-10, -8, -6, -4, -2, 0, 0, 0, 3};\n    std::cout << \"Test case 2: \" << maxEqualRangeSum(nums2) << std::endl;\n\n    std::vector<int> nums3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    std::cout << \"Test case 3: \" << maxEqualRangeSum(nums3) << std::endl;\n\n    return 0;\n}\n```",
  "1984": "```\n#include <iostream>\n#include <vector>\n\nint minimumDifference(std::vector<int>& nums, int k) {\n    if (k > nums.size()) return 0;\n    std::sort(nums.begin(), nums.end());\n    int minDiff = nums[k-1] - nums[0];\n    for(int i = k; i < nums.size(); i++) {\n        minDiff = std::min(minDiff, nums[i] - nums[i-k]);\n    }\n    return minDiff;\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {9,4,7,2,10};\n    int k1 = 3;\n    std::cout << \"Test Case 1: \" << minimumDifference(test1, k1) << std::endl;\n\n    // Test case 2\n    std::vector<int> test2 = {1,2,3,4,5,6,7,8};\n    int k2 = 2;\n    std::cout << \"Test Case 2: \" << minimumDifference(test2, k2) << std::endl;\n\n    // Test case 3\n    std::vector<int> test3 = {1,1,2,2,2,2};\n    int k3 = 4;\n    std::cout << \"Test Case 3: \" << minimumDifference(test3, k3) << std::endl;\n\n    return 0;\n}\n```",
  "1985": "```\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint findKthLargest(std::vector<int>& nums, int k) {\n    std::sort(nums.begin(), nums.end());\n    return nums[nums.size() - k];\n}\n\nint main() {\n    // Test case 1\n    std::vector<int> test1 = {3,2,1,5,6,4};\n    int result1 = findKthLargest(test1, 2);\n    if (result1 == 4) {\n        std::cout << \"Test case 1 passed.\\n\";\n    } else {\n        std::cout << \"Test case 1 failed. Expected: 4, Actual: \" << result1 << \"\\n\";\n    }\n\n    // Test case 2\n    std::vector<int> test2 = {3};\n    int result2 = findKthLargest(test2, 1);\n    if (result2 == 3) {\n        std::cout << \"Test case 2 passed.\\n\";\n    } else {\n        std::cout << \"Test case 2 failed. Expected: 3, Actual: \" << result2 << \"\\n\";\n    }\n\n    // Test case 3\n    std::vector<int> test3 = {1, 2, 3, 4};\n    int result3 = findKthLargest(test3, 3);\n    if (result3 == 3) {\n        std::cout << \"Test case 3 passed.\\n\";\n    } else {\n        std::cout << \"Test case 3 failed. Expected: 3, Actual: \" << result3 << \"\\n\";\n    }\n\n    return 0;\n}\n```",
  "1986": "```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minSessions(vector<int>& tasks, int sessionTime) {\n        int n = tasks.size();\n        vector<vector<int>> dp(n + 1, vector<int>(n / (sessionTime * 2) + 1, INT_MAX));\n        vector<bool> finished(n, false);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = min(i / (sessionTime * 2) + 1, n / (sessionTime * 2)); j >= 1; j--) {\n                int totalTasks = 0;\n                for (int k = i; k > 0 && totalTasks < sessionTime; k -= (k % sessionTime ? 1 : sessionTime)) {\n                    if (!finished[k - 1]) {\n                        totalTasks += tasks[k - 1];\n                    }\n                }\n                dp[i + 1][j] = min(dp[i + 1][j], totalTasks > 0);\n            }\n        }\n        \n        int res = INT_MAX;\n        for (int i = 0; i <= n / (sessionTime * 2); i++) {\n            res = min(res, dp[n][i]);\n        }\n        \n        return res == INT_MAX ? -1 : res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    // Test case 1\n    vector<int> tasks1 = {10, 20, 60};\n    int sessionTime1 = 60;\n    cout << \"Test case 1: \" << solution.minSessions(tasks1, sessionTime1) << endl;\n\n    // Test case 2\n    vector<int> tasks2 = {5, 15, 30, 60};\n    int sessionTime2 = 60;\n    cout << \"Test case 2: \" << solution.minSessions(tasks2, sessionTime2) << endl;\n\n    // Test case 3\n    vector<int> tasks3 = {10, 20, 10, 40};\n    int sessionTime3 = 30;\n    cout << \"Test case 3: \" << solution.minSessions(tasks3, sessionTime3) << endl;\n\n    return 0;\n}\n```",
  "1987": "```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int countGoodSubstrings(string s) {\n        int n = s.length();\n        int res = 0;\n        for (int i = 2; i <= n; ++i) {\n            string t = s.substr(i - 3, 3);\n            bool unique = true;\n            for (char c : t) {\n                if (count(t.begin(), t.end(), c) > 1) {\n                    unique = false;\n                    break;\n                }\n            }\n            res += unique;\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution solution;\n\n    cout << \"Test case 1: \" << solution.countGoodSubsequences(\"xyxz\") << endl; // Expected output: 3\n    cout << \"Test case 2: \" << solution.countGoodSubsequences(\"abcba\") << endl; // Expected output: 4\n    cout << \"Test case 3: \" << solution.countGoodSubsequences(\"aabracadabra\") << endl; // Expected output: 5\n\n    return 0;\n}\n```"
}