{
  "1": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] pairs = {{-1, 0}, {0, 1}, {-2, -1}};\n        for (int[] pair : pairs) {\n            System.out.println(\"Two Sum: \" + pair[0] + \" and \" + pair[1] + \" equals \" + twoSum(pair[0], pair[1]));\n        }\n    }\n\n    public static int twoSum(int x, int y) {\n        int sum = x + y;\n        return sum;\n    }\n}\n```",
  "2": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode l1 = new ListNode(2, new ListNode(4, new ListNode(3)));\n        ListNode l2 = new ListNode(5, new ListNode(6, new ListNode(4)));\n        System.out.println(\"Test case 1: \" + addTwoNumbers(l1, l2).toString());\n        \n        l1 = new ListNode(0);\n        l2 = new ListNode(0);\n        System.out.println(\"Test case 2: \" + addTwoNumbers(l1, l2).toString());\n        \n        l1 = new ListNode(9, new ListNode(9));\n        l2 = new ListNode(1);\n        System.out.println(\"Test case 3: \" + addTwoNumbers(l1, l2).toString());\n    }\n    \n    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        // Your code here\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n    ListNode(int x, ListNode y) { val = x; next = y; }\n\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        ListNode node = this;\n        while (node != null) {\n            sb.append(node.val);\n            node = node.next;\n        }\n        return sb.toString();\n    }\n}\n```",
  "3": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(lengthOfLongestSubstring(\"abcabcbb\")); // Output: 3\n        System.out.println(lengthOfLongestSubstring(\"bbbbb\")); // Output: 1\n        System.out.println(lengthOfLongestSubstring(\"abcdefg\")); // Output: 7\n    }\n\n    public static int lengthOfLongestSubstring(String s) {\n        if (s == null || s.isEmpty()) {\n            return 0;\n        }\n        \n        int start = 0, maxLen = 0, curIndex = 0;\n        Map<Character, Integer> charIndexMap = new HashMap<>();\n\n        while (curIndex < s.length()) {\n            if (!charIndexMap.containsKey(s.charAt(curIndex))) {\n                charIndexMap.put(s.charAt(curIndex), curIndex);\n                maxLen = Math.max(maxLen, curIndex - start + 1);\n                curIndex++;\n            } else {\n                start = charIndexMap.get(s.charAt(curIndex)) + 1;\n                charIndexMap.clear();\n                charIndexMap.put(s.charAt(curIndex), curIndex);\n                curIndex++;\n            }\n        }\n\n        return maxLen;\n    }\n}\n```",
  "5": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + longestPalindromicSubstring(\"babad\")); // Output: \"bab\"\n        System.out.println(\"Test case 2: \" + longestPalindromicSubstring(\"cbbd\")); // Output: \"bb\"\n        System.out.println(\"Test case 3: \" + longestPalindromicSubstring(\"a\")); // Output: \"a\"\n    }\n\n    public static String longestPalindromicSubstring(String s) {\n        if (s == null || s.length() < 1) {\n            return \"\";\n        }\n        \n        int start = 0, end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            // odd length palindrome\n            int left = i, right = i;\n            while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n                if (right - left > end - start) {\n                    start = left; \n                    end = right;\n                }\n                left--;\n                right++;\n            }\n\n            // even length palindrome\n            left = i; right = i+1;\n            while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n                if (right - left > end - start) {\n                    start = left; \n                    end = right;\n                }\n                left--;\n                right++;\n            }\n        }\n        \n        return s.substring(start, end+1);\n    }\n}",
  "4": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + findMedianSortedArrays(new int[]{1, 3}, new int[]{2})); // Expected output: 2\n        System.out.println(\"Test case 2: \" + findMedianSortedArrays(new int[]{0, 0}, new int[]{0, 0})); // Expected output: 0\n        System.out.println(\"Test case 3: \" + findMedianSortedArrays(new int[]{1, 2}, new int[]{3, 4})); // Expected output: 2.5\n    }\n\n    public static double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int x = nums1.length;\n        int y = nums2.length;\n\n        int low = 0;\n        int high = x;\n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (x + y + 1) / 2 - partitionX;\n            \n            int maxLeftX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n            int minRightX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n\n            int maxLeftY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n            int minRightY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n\n            if (maxLeftX <= minRightY && maxLeftY <= minRightX) {\n                if ((x + y) % 2 == 0) {\n                    return ((double) Math.max(maxLeftX, maxLeftY) + Math.min(minRightX, minRightY)) / 2;\n                } else {\n                    return (double) Math.max(maxLeftX, maxLeftY);\n                }\n            } \n            else if (maxLeftX > minRightY) {\n                high = partitionX - 1;\n            } \n            else {\n                low = partitionX + 1;\n            }\n        }\n\n        throw new RuntimeException(\"Should not reach here\");\n    }\n}\n```",
  "6": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(convert(\"PAYPALISHMING\", 4)); // Output: \"PAHNAPLSIIGYNM\"\n        System.out.println(convert(\"a\", 1)); // Output: \"a\"\n        System.out.println(convert(\"abcdefg\", 2)); // Output: \"acfegb\"\n    }\n\n    public static String convert(String s, int nRows) {\n        if (nRows == 1) return s;\n        StringBuilder[] rows = new StringBuilder[nRows];\n        for (int i = 0; i < nRows; i++) rows[i] = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            int index = c - 'A';\n            if ((index + 1) % nRows == 0) {\n                rows[0].append(c);\n            } else {\n                rows[(index + 1) / nRows].append(c);\n            }\n        }\n        StringBuilder result = new StringBuilder();\n        for (StringBuilder row : rows) {\n            result.append(row.toString());\n        }\n        return result.toString();\n    }\n}\n```",
  "7": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(reverse(123)); // expected output: 321\n        System.out.println(reverse(-123)); // expected output: -321\n        System.out.println(reverse(1000000003)); // expected output: 300000001\n    }\n\n    public static int reverse(int x) {\n        long res = 0;\n        while (x != 0) {\n            res = res * 10 + x % 10;\n            x /= 10;\n        }\n        if (res > Integer.MAX_VALUE || res < Integer.MIN_VALUE)\n            return 0;\n        return (int) res;\n    }\n}\n```",
  "9": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isPalindrome(121)); // Expected output: true\n        System.out.println(isPalindrome(-121)); // Expected output: false\n        System.out.println(isPalindrome(10)); // Expected output: false\n    }\n\n    public static boolean isPalindrome(int x) {\n        if (x < 0) return false;\n        int reverse = 0;\n        int original = x;\n        while (x != 0) {\n            int remainder = x % 10;\n            reverse = reverse * 10 + remainder;\n            x /= 10;\n        }\n        return original == reverse;\n    }\n}\n```",
  "8": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(myAtoi(\"123\") == 123);\n        System.out.println(myAtoi(\"   -42\") == -42);\n        System.out.println(myAtoi(\"     +1\") == 1);\n\n        // More test cases...\n    }\n\n    public static int myAtoi(String s) {\n        s = s.trim();\n        if (s.length() == 0) return 0;\n\n        boolean isNegative = false;\n        int start = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '-') {\n                isNegative = true;\n                start = i + 1;\n                break;\n            } else if (c == '+') {\n                start = i + 1;\n                break;\n            } else if (!Character.isDigit(c)) {\n                return 0;\n            }\n        }\n\n        int result = 0;\n        for (int i = start; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (!Character.isDigit(c)) {\n                return isNegative ? -result : result;\n            }\n            result = result * 10 + (c - '0');\n        }\n\n        return isNegative ? -result : result;\n    }\n}",
  "10": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canMatch(\"aa\", \"a\")); // false\n        System.out.println(canMatch(\"aa\", \"*\")); // true\n        System.out.println(canMatch(\"cb\", \"?c|c*\"));// true\n    }\n\n    public static boolean canMatch(String s, String p) {\n        if (p.isEmpty()) return s.isEmpty();\n        firstCharMatches(s.charAt(0), p.charAt(0)) && canMatch(s.substring(1), p.substring(1));\n        else if (p.length() > 1 && p.charAt(1) == '*') {\n            return canMatch(s, p.substring(2)) || (firstCharMatches(s.charAt(0), p.charAt(0)) && canMatch(s.substring(1), p));\n        } else return false;\n    }\n\n    public static boolean firstCharMatches(char sChar, char pChar) {\n        if (pChar == '.') return true;\n        return sChar == pChar;\n    }\n}\n```",
  "11": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = { {1,8,6}, {1,2,7,3,5,8}, {2,1,5,6,4} };\n        for (int i = 0; i < inputs.length; i++) {\n            System.out.println(\"Container with most water in \" + Arrays.toString(inputs[i]) + \": \" +\n                    maxArea(Arrays.stream(inputs[i]).mapToInt(Integer::intValue).toArray()));\n        }\n    }\n\n    public static int maxArea(int[] height) {\n        int left = 0, right = height.length - 1;\n        int max_area = 0;\n        while (left < right) {\n            int area = Math.min(height[left], height[right]) * (right - left);\n            if (area > max_area) {\n                max_area = area;\n            }\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return max_area;\n    }\n}\n```",
  "12": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(intToRoman(3)); // Sample Test Case 1: Output should be \"III\"\n        System.out.println(intToRoman(4)); // Sample Test Case 2: Output should be \"IV\"\n        System.out.println(intToRoman(9)); // Sample Test Case 3: Output should be \"IX\"\n    }\n\n    public static String intToRoman(int num) {\n        // Your code goes here\n        return \"\";\n    }\n}\n```",
  "13": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(intToRoman(3) + \" should be equal to III\");\n        System.out.println(intToRoman(4) + \" should be equal to IV\");\n        System.out.println(intToRoman(9) + \" should be equal to IX\");\n    }\n\n    public static String intToRoman(int num) {\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] romanLiterals = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n\n        StringBuilder result = new StringBuilder();\n\n        for (int i = 0; i < values.length; i++) {\n            while (num >= values[i]) {\n                num -= values[i];\n                result.append(romanLiterals[i]);\n            }\n        }\n\n        return result.toString();\n    }\n}",
  "14": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(longestCommonPrefix(new String[]{\"flower\",\"flow\",\"flight\"}));\n        System.out.println(longestCommonPrefix(new String[]{\"dog\",\"racecar\",\"car\"}));\n        System.out.println(longestCommonPrefix(new String[]{\"cool\",\"lock\",\"cook\"}));\n    }\n\n    public static String longestCommonPrefix(String[] strs) {\n        if (strs.length == 0) return \"\";\n        \n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < strs[0].length(); i++) {\n            char c = strs[0].charAt(i);\n            for (String str : strs) {\n                if (i >= str.length() || str.charAt(i) != c) {\n                    return prefix.toString();\n                }\n            }\n            prefix.append(c);\n        }\n        \n        return prefix.toString();\n    }\n}\n```",
  "15": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] testCases = {\n            {{-1, 0, 1, 2, -1, -4}, [-1, -1], []},\n            {{0, 0, 0}, [0], [0]},\n            {{0, 0, 0, 0}, [], []}\n        };\n\n        for (int[] testCase : testCases) {\n            int[] nums = testCase[0];\n            List<List<Integer>> expected = new ArrayList<>();\n            for (int i = 1; i < testCase.length; i++) {\n                expected.add((List<Integer>) Arrays.asList(testCase[i]));\n            }\n            threeSum(nums, expected);\n        }\n    }\n\n    public static void threeSum(int[] nums, List<List<Integer>> expected) {\n        Arrays.sort(nums);\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n            int left = i + 1, right = nums.length - 1;\n\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                if (sum < 0) {\n                    left++;\n                } else if (sum > 0) {\n                    right--;\n                } else {\n                    List<Integer> triplet = new ArrayList<>();\n                    triplet.add(nums[i]);\n                    triplet.add(nums[left]);\n                    triplet.add(nums[right]);\n                    expected.add(triplet);\n                    while (left < right && nums[left] == nums[left + 1]) left++;\n                    while (left < right && nums[right] == nums[right - 1]) right--;\n                    left++; right--;\n                }\n            }\n        }\n\n        System.out.println(expected);\n    }\n}",
  "16": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {{{-1, 2, 1, -4}, 1}, {{1, 0, -1, 0, -2, 2}, 3}, {{0, 0, 0}, 0}};\n        \n        for (int i = 0; i < arrays.length; i++) {\n            int[] nums = arrays[i][0];\n            int target = arrays[i][1];\n            \n            System.out.println(\"Array: \" + Arrays.toString(nums) + \", Target: \" + target);\n            System.out.println(\"Closest sum: \" + threeSumClosest(nums, target));\n            System.out.println();\n        }\n    }\n\n    public static int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        \n        int closest = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1, right = nums.length - 1;\n            \n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                \n                if (Math.abs(sum - target) < Math.abs(closest - target)) {\n                    closest = sum;\n                }\n                \n                if (sum < target) {\n                    left++;\n                } else if (sum > target) {\n                    right--;\n                } else {\n                    return target;\n                }\n            }\n        }\n        \n        return closest;\n    }\n}",
  "17": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Solution().letterCombinations(\"23\"));\n        System.out.println(new Solution().letterCombinations(\"234\"));\n        System.out.println(new Solution().letterCombinations(\"2\")); \n    }\n}\n```",
  "18": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums1 = {{1,0,-1,-6,-2,-4,-2,-3,-5},{-2,-1,-2,-4,0,1,6}};\n        int target1 = 0;\n        System.out.println(\"Test Case 1: \" + fourSum(nums1, target1));\n\n        int[][] nums2 = {{2,2}, {2,2}};\n        int target2 = 4;\n        System.out.println(\"Test Case 2: \" + fourSum(nums2, target2));\n\n        int[][] nums3 = {{-5,-5,-5,5},{-5,1,5,5}};\n        int target3 = -11;\n        System.out.println(\"Test Case 3: \" + fourSum(nums3, target3));\n    }\n\n    public static List<List<Integer>> fourSum(int[][] nums, int target) {\n        Arrays.sort(Arrays.stream(nums).flatMapToInt(IntStream::of).toArray());\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (i > 0 && nums[i][0] == nums[i - 1][0]) continue;\n            for (int j = i + 1; j < nums.length; j++) {\n                if (j > i + 1 && nums[j][0] == nums[j - 1][0]) continue;\n                int left = j + 1, right = nums.length - 1;\n                while (left < right) {\n                    int sum = nums[i][0] + nums[j][0] + nums[left][0] + nums[right][0];\n                    if (sum < target) {\n                        left++;\n                    } else if (sum > target) {\n                        right--;\n                    } else {\n                        result.add(Arrays.asList(nums[i][0], nums[j][0], nums[left][0], nums[right][0]));\n                        while (left < right && nums[left][0] == nums[left + 1][0]) left++;\n                        while (left < right && nums[right][0] == nums[right - 1][0]) right--;\n                        left++; right--;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
  "19": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test Case 1: Remove the first node from the end of the list\n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head.next.next.next.next = new ListNode(5);\n        removeNthFromEnd(head, 1);\n        System.out.println(\"Test Case 1: Removed the first node from the end of the list\");\n\n        // Test Case 2: Remove a node in the middle\n        head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        removeNthFromEnd(head, 2);\n        System.out.println(\"Test Case 2: Removed a node in the middle\");\n\n        // Test Case 3: Remove the last node from the list\n        head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        removeNthFromEnd(head, 2);\n        System.out.println(\"Test Case 3: Removed the last node from the list\");\n    }\n\n    public static void removeNthFromEnd(ListNode head, int n) {\n        // Your code here\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n```",
  "20": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(isValid(\"()\")); // True\n        System.out.println(isValid(\"()[]{}\")); // True\n        System.out.println(isValid(\"(]\")); // False\n    }\n\n    public static boolean isValid(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(' || c == '[' || c == '{') {\n                stack.push(c);\n            } else if (c == ')' || c == ']' || c == '}') {\n                if (stack.isEmpty()) return false;\n                char top = stack.pop();\n                if ((c == ')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top != '[')) return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```",
  "22": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n = 3;\n        System.out.println(generateParenthesis(n));\n        \n        n = 1;\n        System.out.println(generateParenthesis(n));\n\n        n = 4;\n        System.out.println(generateParenthesis(n));\n    }\n\n    public static List<String> generateParenthesis(int n) {\n        List<String> result = new ArrayList<>();\n        backtrack(result, \"\", 0, 0, n);\n        return result;\n    }\n\n    private static void backtrack(List<String> result, String current, int open, int close, int max) {\n        if (current.length() == max * 2) {\n            result.add(current);\n            return;\n        }\n        \n        if (open < max) {\n            backtrack(result, current + \"(\", open + 1, close, max);\n        }\n        \n        if (close < open) {\n            backtrack(result, current + \")\", open, close + 1, max);\n        }\n    }\n}\n```",
  "21": "```\npublic class Main {\n\n    public static ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) return l2;\n        if (l2 == null) return l1;\n\n        ListNode merged = null;\n        if (l1.val <= l2.val) {\n            merged = l1;\n            l1 = l1.next;\n        } else {\n            merged = l2;\n            l2 = l2.next;\n        }\n\n        ListNode current = merged;\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n\n        current.next = l1 != null ? l1 : l2;\n\n        return merged;\n    }\n\n    public static void main(String[] args) {\n        ListNode node5 = new ListNode(5);\n        ListNode node4 = new ListNode(4, node5);\n        ListNode node3 = new ListNode(3, node4);\n        ListNode node2 = new ListNode(2, node3);\n        ListNode node1 = new ListNode(1, node2);\n\n        ListNode node6 = new ListNode(6);\n        ListNode node5_1 = new ListNode(5, node6);\n        ListNode node4_1 = new ListNode(4, node5_1);\n        ListNode node3_1 = new ListNode(3, node4_1);\n\n        System.out.println(\"Test Case 1: \");\n        ListNode result1 = mergeTwoLists(node1, node3_1);\n        while (result1 != null) {\n            System.out.print(result1.val + \" \");\n            result1 = result1.next;\n        }\n        System.out.println();\n\n        ListNode node7 = new ListNode(7);\n        ListNode node6_1 = new ListNode(6, node7);\n\n        System.out.println(\"Test Case 2: \");\n        ListNode result2 = mergeTwoLists(node3_1, node6_1);\n        while (result2 != null) {\n            System.out.print(result2.val + \" \");\n            result2 = result2.next;\n        }\n        System.out.println();\n\n        ListNode node8 = new ListNode(8);\n        ListNode node7_1 = new ListNode(7, node8);\n\n        System.out.println(\"Test Case 3: \");\n        ListNode result3 = mergeTwoLists(node6_1, node7_1);\n        while (result3 != null) {\n            System.out.print(result3.val + \" \");\n            result3 = result3.next;\n        }\n        System.out.println();\n    }\n}\n```",
  "23": "```\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        Queue<ListNode> queue = new PriorityQueue<>((a, b) -> (a.val - b.val));\n        \n        for (ListNode node : lists) {\n            if (node != null) {\n                queue.offer(node);\n            }\n        }\n        \n        ListNode dummyHead = new ListNode(0);\n        ListNode p = dummyHead;\n        \n        while (!queue.isEmpty()) {\n            p.next = queue.poll();\n            p = p.next;\n            \n            if (p.next != null) {\n                queue.offer(p.next);\n            }\n        }\n        \n        return dummyHead.next;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        ListNode list1 = new ListNode(1, new ListNode(4, new ListNode(5)));\n        ListNode list2 = new ListNode(1, new ListNode(3, new ListNode(4)));\n        ListNode list3 = new ListNode(2, new ListNode(6));\n        ListNode[] lists1 = {list1, list2, list3};\n        ListNode result1 = solution.mergeKLists(lists1);\n        while (result1 != null) {\n            System.out.print(result1.val + \" \");\n            result1 = result1.next;\n        }\n        System.out.println();\n\n        // Test case 2\n        list1 = new ListNode(0, new ListNode(3));\n        list2 = new ListNode(4);\n        list3 = null;\n        ListNode[] lists2 = {list1, list2, list3};\n        ListNode result2 = solution.mergeKLists(lists2);\n        while (result2 != null) {\n            System.out.print(result2.val + \" \");\n            result2 = result2.next;\n        }\n        System.out.println();\n\n        // Test case 3\n        list1 = new ListNode(5);\n        list2 = new ListNode(1, new ListNode(3));\n        list3 = new ListNode(0, new ListNode(4));\n        ListNode[] lists3 = {list1, list2, list3};\n        ListNode result3 = solution.mergeKLists(lists3);\n        while (result3 != null) {\n            System.out.print(result3.val + \" \");\n            result3 = result3.next;\n        }\n        System.out.println();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int val) {\n        this.val = val;\n    }\n\n    public ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}",
  "24": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(3);\n        head1.next.next.next = new ListNode(4);\n\n        ListNode.printList(head1); // Output: 1 -> 2 -> 3 -> 4\n        Solution solution = new Solution();\n        solution.swapPairs(head1);\n        ListNode.printList(head1); // Expected output: 2 -> 1 -> 4 -> 3\n\n        ListNode head2 = new ListNode(0);\n        head2.next = new ListNode(1);\n        head2.next.next = new ListNode(2);\n\n        ListNode.printList(head2); // Output: 0 -> 1 -> 2\n        solution.swapPairs(head2);\n        ListNode.printList(head2); // Expected output: 1 -> 0 -> 2\n\n        ListNode head3 = new ListNode(1);\n        head3.next = new ListNode(2);\n\n        ListNode.printList(head3); // Output: 1 -> 2\n        solution.swapPairs(head3);\n        ListNode.printList(head3); // Expected output: 2 -> 1\n    }\n}\n```",
  "26": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] testCases = {\n            {1, 1, 2},\n            {0, 1, 1, 1, 2, 3},\n            {1}\n        };\n\n        for (int[] testCase : testCases) {\n            System.out.println(\"Input: \" + Arrays.toString(testCase));\n            int[] result = removeDuplicates(testCase);\n            System.out.println(\"Output: \" + Arrays.toString(result));\n            System.out.println();\n        }\n    }\n\n    public static int[] removeDuplicates(int[] nums) {\n        if (nums.length == 0) return nums;\n\n        int i = 0;\n        for (int j = 1; j < nums.length; j++) {\n            if (nums[j] != nums[i]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n\n        return Arrays.copyOfRange(nums, 0, i + 1);\n    }\n}",
  "25": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1, new ListNode(2, new ListNode(3, new ListNode(4, new ListNode(5)))));\n        Solution solution1 = new Solution();\n        head1 = solution1.reverseKGroup(head1, 2);\n        printList(head1);\n\n        ListNode head2 = new ListNode(1, new ListNode(2));\n        solution1 = new Solution();\n        head2 = solution1.reverseKGroup(head2, 2);\n        printList(head2);\n\n        ListNode head3 = null;\n        solution1 = new Solution();\n        head3 = solution1.reverseKGroup(head3, 1);\n        printList(head3);\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n}\n\nclass Solution {\n\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null || head.next == null || k == 1) {\n            return head;\n        }\n\n        ListNode newHead = null;\n        ListNode prevTail = null;\n\n        while (head != null) {\n            ListNode tail = head;\n            for (int i = 0; i < k && tail != null; i++) {\n                tail = tail.next;\n            }\n            if (tail == null) {\n                break;\n            }\n\n            ListNode newTail = reverse(head, tail);\n            if (newHead == null) {\n                newHead = newTail;\n            } else {\n                prevTail.next = newTail;\n            }\n            prevTail = head;\n            head = tail;\n        }\n\n        return newHead;\n    }\n\n    public ListNode reverse(ListNode head, ListNode tail) {\n        ListNode prev = null;\n        while (head != tail) {\n            ListNode nextNode = head.next;\n            head.next = prev;\n            prev = head;\n            head = nextNode;\n        }\n        return prev;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n\n    public ListNode(int val) {\n        this(val, null);\n    }\n}",
  "27": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] array1 = {0, 1, 2, 2, 3, 0, 4, 2};\n        System.out.println(\"Array 1: \" + removeElement(array1, 2));\n        \n        int[] array2 = {3, 2, 2, 3};\n        System.out.println(\"Array 2: \" + removeElement(array2, 3));\n\n        int[] array3 = {0, 1, 2};\n        System.out.println(\"Array 3: \" + removeElement(array3, 0));\n    }\n\n    public static int removeElement(int[] nums, int val) {\n        if (nums.length == 0) return 0;\n        \n        int i = 0;\n        for (int j = 0; j < nums.length; j++) {\n            if (nums[j] != val) {\n                nums[i] = nums[j];\n                i++;\n            }\n        }\n        return i;\n    }\n}",
  "28": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + strStr(\"hello\", \"ll\")); // Expected output: 2\n        System.out.println(\"Test Case 2: \" + strStr(\"aaa\", \"aa\")); // Expected output: 0\n        System.out.println(\"Test Case 3: \" + strStr(\"beerhunter\", \"hun\")); // Expected output: 7\n    }\n\n    public static int strStr(String haystack, String needle) {\n        if (needle.length() == 0) return 0;\n        for (int i = 0; i <= haystack.length() - needle.length(); i++) {\n            int j = 0;\n            while (j < needle.length()) {\n                if (haystack.charAt(i + j) != needle.charAt(j)) break;\n                j++;\n            }\n            if (j == needle.length()) return i;\n        }\n        return -1;\n    }\n}\n```",
  "29": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(divide(10, 3)); // expected output: 3\n        System.out.println(divide(-10, 3)); // expected output: -3\n        System.out.println(divide(Integer.MIN_VALUE, 1)); // expected output: Integer.MIN_VALUE\n    }\n\n    public static int divide(int dividend, int divisor) {\n        if ((dividend == Integer.MIN_VALUE && divisor == 1) || (divisor == 0)) {\n            throw new ArithmeticException(\"Division by zero is not allowed\");\n        }\n        int sign = (dividend < 0) ^ (divisor < 0) ? -1 : 1;\n        long ldividend = Math.abs((long) dividend);\n        long ldivisor = (long) divisor;\n        long result = 0;\n\n        while (ldivisor <= ldividend) {\n            long temp = ldivisor, multiples = 0;\n            while ((temp << 1) <= ldividend) {\n                temp <<= 1;\n                multiples <<= 1;\n            }\n            ldividend -= temp;\n            result += multiples;\n        }\n\n        return sign * (result);\n    }\n}\n```",
  "30": "```\npublic class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        // Your code here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(\"Test Case 1:\");\n        String s1 = \"barfoofoobar\";\n        String[] words1 = {\"foo\",\"bar\"};\n        List<Integer> result1 = solution.findSubstring(s1, words1);\n        for (int i : result1) {\n            System.out.println(i);\n        }\n        \n        System.out.println(\"\\nTest Case 2:\");\n        String s2 = \"wordgoodgoodgood\";\n        String[] words2 = {\"word\",\"good\",\"good\"};\n        List<Integer> result2 = solution.findSubstring(s2, words2);\n        for (int i : result2) {\n            System.out.println(i);\n        }\n        \n        System.out.println(\"\\nTest Case 3:\");\n        String s3 = \"aaabaaaaa\";\n        String[] words3 = {\"aa\",\"aaa\"};\n        List<Integer> result3 = solution.findSubstring(s3, words3);\n        for (int i : result3) {\n            System.out.println(i);\n        }\n    }\n}\n```",
  "31": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums = {{1, 2, 3}, {3, 2, 1, 4}, {1, 5, 3}};\n\n        for (int i = 0; i < nums.length; i++) {\n            nextPermutation(nums[i]);\n            System.out.println(Arrays.toString(nums[i]));\n        }\n    }\n\n    public static void nextPermutation(int[] nums) {\n        int n = nums.length;\n        int k = -1, t;\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > nums[i + 1]) {\n                k = i;\n                break;\n            }\n        }\n\n        if (k == n - 1) {\n            reverse(nums, 0, n - 1);\n            return;\n        }\n\n        for (int i = n - 1; i > k; i--) {\n            if (nums[k + 1] < nums[i]) {\n                t = nums[k + 1];\n                nums[k + 1] = nums[i];\n                nums[i] = t;\n                break;\n            }\n        }\n\n        reverse(nums, k + 1, n - 1);\n    }\n\n    public static void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int t = nums[start];\n            nums[start] = nums[end];\n            nums[end] = t;\n            start++;\n            end--;\n        }\n    }\n}",
  "32": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestValidParentheses(\"(()\")); // Output: 2\n        System.out.println(longestValidParentheses(\")()(\")); // Output: 4\n        System.out.println(longestValidParentheses(\"(()())\")); // Output: 4\n    }\n\n    public static int longestValidParentheses(String s) {\n        int max = 0;\n        int left = 0, right = 0;\n        int temp = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                left++;\n                right = 0;\n                temp = 0;\n            } else if (s.charAt(i) == ')') {\n                if (left > 0) {\n                    right++;\n                    if (right == left) {\n                        max = Math.max(max, left + right);\n                    }\n                } else {\n                    temp++;\n                }\n            }\n        }\n\n        return max;\n    }\n}\n```",
  "33": "```\npublic class Main {\n    public static void main(String[] args) {\n        int target = 8;\n        System.out.println(searchRange(new int[]{4,5,6,7,0,1,2}, target));\n        \n        target = 0;\n        System.out.println(searchRange(new int[]{4,5,6,7,0,1,2}, target));\n        \n        target = 3;\n        System.out.println(searchRange(new int[]{1}, target));\n    }\n\n    public static int[] searchRange(int[] nums, int target) {\n        int[] result = new int[]{-1, -1};\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n        \n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // Target found at the middle\n                if (mid == 0 || nums[mid - 1] < target) {\n                    result[0] = mid;\n                }\n                if (mid == nums.length - 1 || nums[mid + 1] > target) {\n                    result[1] = mid;\n                }\n                \n                return result;\n            } else if (nums[left] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return result;\n    }\n}\n```",
  "34": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \");\n        int[] nums = new int[]{5,7,7,8,8,10};\n        int target = 8;\n        int[] result = searchRange(nums, target);\n        for (int i : result) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Test Case 2: \");\n        nums = new int[]{5,7,7,8,9,10};\n        target = 8;\n        result = searchRange(nums, target);\n        for (int i : result) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Test Case 3: \");\n        nums = new int[]{2,2};\n        target = 2;\n        result = searchRange(nums, target);\n        for (int i : result) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n    }\n\n    public static int[] searchRange(int[] nums, int target) {\n        int left = binarySearch(nums, target, true);\n        int right = binarySearch(nums, target, false);\n\n        return new int[]{left, right};\n    }\n\n    public static int binarySearch(int[] nums, int target, boolean isLeft) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return isLeft ? findLeft(nums, target, mid) : findRight(nums, target, mid);\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return isLeft ? nums.length : -1;\n    }\n\n    public static int findLeft(int[] nums, int target, int start) {\n        while (start > 0 && nums[start - 1] == target) {\n            start--;\n        }\n        return start;\n    }\n\n    public static int findRight(int[] nums, int target, int end) {\n        while (end < nums.length - 1 && nums[end + 1] == target) {\n            end++;\n        }\n        return end;\n    }\n}",
  "35": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] nums = { {1, 3, 5}, {0} ,{2}};\n        \n        for(int i=0;i<nums.length;i++){\n            System.out.println(\"Index of \"+nums[i][0]+\" is \"+searchInsert(nums[i], nums[i][0]));\n        }\n    }\n\n    public static int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left;\n    }\n}\n```",
  "36": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(isValidSudoku(new char[][]{\n                {'5', '3'}, {'.', '.'}, {'.' , '.'}\n        })); // true\n        System.out.println(isValidSudoku(new char[][]{\n                {'8','3','. ','.7','.','.','.','.6','.'}\n        })); // true\n        System.out.println(isValidSudoku(new char[][]{\n                {'8', '3', '.', '.', '7', '.', '.', '6', '.'}\n        })); // false\n    }\n\n    public static boolean isValidSudoku(char[][] board) {\n        if (board == null || board.length != 9) {\n            return false;\n        }\n        for (int i = 0; i < 9; i++) {\n            boolean[] rowUsed = new boolean[9];\n            boolean[] columnUsed = new boolean[9];\n            for (int j = 0; j < 9; j++) {\n                if (board[i][j] == '.') continue;\n                int num = board[i][j] - '1';\n                if (rowUsed[num] || columnUsed[num]) return false;\n                rowUsed[num] = true;\n                columnUsed[num] = true;\n            }\n        }\n        for (int i = 0; i < 3; i++) {\n            boolean[] boxUsed = new boolean[9];\n            for (int j = 0; j < 3; j++) {\n                for (int k = 0; k < 3; k++) {\n                    if (board[i*3 + j][k*3] == '.') continue;\n                    int num = board[i*3 + j][k*3] - '1';\n                    if (boxUsed[num]) return false;\n                    boxUsed[num] = true;\n                }\n            }\n        }\n        return true;\n    }\n}\n```",
  "37": "```\npublic class Main {\n    public static void main(String[] args) {\n        solveSudoku(new int[][]{\n                {5,1,7,6,0,0,0,3,4},\n                {2,8,9,0,0,4,0,0,0},\n                {3,4,6,7,8,5,0,0,0},\n                {0,0,0,0,0,0,0,9,8},\n                {7,5,0,0,0,0,0,1,2},\n                {0,9,8,7,6,3,0,4,5},\n                {1,2,3,9,5,7,6,8,0},\n                {8,5,0,0,9,7,2,3,4},\n                {4,3,0,2,8,5,1,6,7}\n        });\n        \n        solveSudoku(new int[][]{\n                {0,0,0,0,0,0,0,0,0},\n                {0,0,0,0,0,0,0,0,0},\n                {0,0,0,0,0,0,0,0,0},\n                {3,1,2,4,5,6,7,8,9},\n                {9,8,7,6,5,4,3,2,1},\n                {1,2,3,4,5,6,7,8,9},\n                {7,6,5,4,3,2,1,0,0},\n                {0,0,0,0,0,0,0,0,0},\n                {0,0,0,0,0,0,0,0,0}\n        });\n        \n        solveSudoku(new int[][]{\n                {8,0,0,0,0,0,0,0,3},\n                {0,6,0,0,2,0,0,0,0},\n                {0,7,0,0,5,9,0,0,0},\n                {4,0,0,8,3,0,0,1,0},\n                {0,5,0,6,7,0,0,4,0},\n                {0,0,0,2,1,0,0,5,0},\n                {0,9,8,3,0,4,0,2,0},\n                {0,1,0,0,0,3,0,6,0},\n                {0,4,3,0,0,0,7,0,0}\n        });\n    }\n\n    public static void solveSudoku(int[][] board) {\n        // TO DO: implement Sudoku solver algorithm\n    }\n}",
  "38": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countAndSay(1).equals(\"1\")); // Test case 1\n        System.out.println(countAndSay(4).equals(\"12121\")); // Test case 2\n        System.out.println(countAndSay(6).equals(\"111221\")); // Test case 3\n    }\n\n    public static String countAndSay(int n) {\n        if (n == 1) return \"1\";\n        String prev = countAndSay(n - 1);\n        StringBuilder sb = new StringBuilder();\n        int count = 1;\n        for (int i = 1; i < prev.length(); i++) {\n            if (prev.charAt(i) == prev.charAt(i - 1)) {\n                count++;\n            } else {\n                sb.append(count).append(prev.charAt(i - 1));\n                count = 1;\n            }\n        }\n        sb.append(count).append(prev.charAt(prev.length() - 1));\n        return sb.toString();\n    }\n}\n```",
  "39": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] targetSum = {{2, 3, 6, 7}, {5, 10, 15, 20}};\n        for (int i = 0; i < targetSum.length; i++) {\n            System.out.println(\"Target sum: \" + Arrays.toString(targetSum[i]));\n            List<List<Integer>> result = combinationSum(new int[]{2, 3, 5}, targetSum[i]);\n            for (List<Integer> list : result) {\n                System.out.println(list);\n            }\n            System.out.println();\n        }\n    }\n\n    public static List<List<Integer>> combinationSum(int[] candidates, int[] targetSums) {\n        List<List<Integer>> results = new ArrayList<>();\n        Arrays.sort(candidates);\n        for (int[] targetSum : targetSums) {\n            results.add(combinationSumHelper(candidates, targetSum));\n        }\n        return results;\n    }\n\n    public static List<List<Integer>> combinationSumHelper(int[] candidates, int[] targetSum) {\n        List<List<Integer>> combinations = new ArrayList<>();\n        backtrack(combinations, new ArrayList<>(), 0, targetSum, candidates);\n        return combinations;\n    }\n\n    public static void backtrack(List<List<Integer>> combinations, List<Integer> tempList, int start, int[] nums, int[] targetSum) {\n        if (tempList.size() == targetSum.length) {\n            if (validate(tempList, targetSum)) {\n                combinations.add(new ArrayList<>(tempList));\n            }\n        } else {\n            for (int i = start; i < nums.length; i++) {\n                tempList.add(nums[i]);\n                backtrack(combinations, tempList, i + 1, nums, targetSum);\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n\n    public static boolean validate(List<Integer> tempList, int[] targetSum) {\n        int sum = 0;\n        for (int num : tempList) {\n            sum += num;\n        }\n        return sum == targetSum[0];\n    }\n}",
  "40": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] expect1 = {{1,2},{1,5},{5}};\n        System.out.println(Arrays.deepToString(combinationSum2(new int[]{10,9,8,7,6,5,4,3,2,1}, 15)));\n        \n        int[][] expect2 = {};\n        System.out.println(Arrays.deepToString(combinationSum2(new int[]{10,9,8,7,6,5,4,3,2,1}, 20)));\n        \n        int[][] expect3 = {{1,1,2}};\n        System.out.println(Arrays.deepToString(combinationSum2(new int[]{2,3,5}, 3)));\n    }\n\n    public static int[][] combinationSum2(int[] candidates, int target) {\n        if (candidates.length == 0) {\n            return new int[0][];\n        }\n        \n        Arrays.sort(candidates);\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(result, new ArrayList<>(), candidates, target, 0);\n        return result.toArray(new int[0][]);\n    }\n\n    private static void backtrack(List<List<Integer>> result, List<Integer> tempList, int[] nums, int remain, int start) {\n        if (remain < 0) {\n            return;\n        } else if (remain == 0) {\n            result.add(new ArrayList<>(tempList));\n        } else {\n            for (int i = start; i < nums.length; i++) {\n                if (i > start && nums[i] == nums[i - 1]) continue; // skip duplicates\n                if (nums[i] > remain) break;\n                tempList.add(nums[i]);\n                backtrack(result, tempList, nums, remain - nums[i], i + 1);\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n}\n```",
  "41": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1,2,0};\n        System.out.println(\"First missing positive: \" + firstMissingPositive(nums1));\n        \n        int[] nums2 = {3,4,-1,1};\n        System.out.println(\"First missing positive: \" + firstMissingPositive(nums2));\n        \n        int[] nums3 = {7,8,9,11,12};\n        System.out.println(\"First missing positive: \" + firstMissingPositive(nums3));\n    }\n\n    public static int firstMissingPositive(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            if (num > 0) {\n                set.add(num);\n            }\n        }\n        \n        int i = 1;\n        while (i <= set.size()) {\n            if (!set.contains(i)) {\n                return i;\n            }\n            i++;\n        }\n        \n        return i + 1;\n    }\n}\n```",
  "42": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = { {0,1,0,2,6,3,4,7,1,8,8}, {4,2,0,3,2,5}, {1,2,0,1} };\n        for (int i = 0; i < inputs.length; i++) {\n            System.out.println(\"Input: \" + java.util.Arrays.toString(inputs[i]) +\n                    \", Output: \" + trappingRainWater(inputs[i]));\n        }\n    }\n\n    public static int trappingRainWater(int[] height) {\n        if (height.length == 0) return 0;\n        int water = 0, left = 0, right = height.length - 1;\n        while (left <= right) {\n            int min = Math.min(height[left], height[right]);\n            water += min - height[Math.min(left, right)];\n            if (min == height[left]) left++;\n            else right--;\n        }\n        return water;\n    }\n}\n```",
  "43": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(multiply(\"2\", \"3\").equals(\"6\")); // Test case 1\n        System.out.println(multiply(\"0\", \"0\").equals(\"0\")); // Test case 2\n        System.out.println(multiply(\"100\", \"123\").equals(\"122400\")); // Test case 3\n    }\n\n    public static String multiply(String num1, String num2) {\n        int m = num1.length(), n = num2.length();\n        int[] pos = new int[m + n];\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0');\n                int p1 = i + j, p2 = i + j + 1;\n                int sum = mul + pos[p2];\n                pos[p2] = sum % 10;\n                pos[p1] += sum / 10;\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        for (int val : pos) {\n            if (!(sb.length() == 0 && val == 0)) {\n                sb.append(val);\n            }\n        }\n        return sb.length() == 0 ? \"0\" : sb.toString();\n    }\n}\n```",
  "44": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isMatch(\"a\", \"*\")); // false\n        System.out.println(isMatch(\"aa\", \"a*\")); // true\n        System.out.println(isMatch(\"aa\", \"a*a\")); // true\n    }\n\n    public static boolean isMatch(String s, String p) {\n        // code goes here\n    }\n}\n```",
  "45": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2,3,1,1,4};\n        System.out.println(\"Test case 1: \" + canJump(nums1));\n        \n        int[] nums2 = {3,2 - 1,1,1,1};\n        System.out.println(\"Test case 2: \" + canJump(nums2));\n        \n        int[] nums3 = {0,2,6,9,9,10,4,7,5,0,5};\n        System.out.println(\"Test case 3: \" + canJump(nums3));\n    }\n\n    public static boolean canJump(int[] nums) {\n        int maxReachablePosition = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (i > maxReachablePosition) return false;\n            maxReachablePosition = Math.max(maxReachablePosition, i + nums[i]);\n        }\n        return true;\n    }\n}",
  "46": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] expect1 = {{1, 2}, {1, 3}, {1, 4}, {2, 1}, {2, 3}, {2, 4}, {3, 1}, {3, 2}, {3, 4}, {4, 1}, {4, 2}, {4, 3}};\n        int[][] expect2 = {{0, 1, 2}, {0, 2, 1}, {1, 0, 2}, {1, 2, 0}, {2, 0, 1}, {2, 1, 0}};\n        int[][] expect3 = {};\n\n        backtrack(new int[]{1, 2, 3}, new boolean[3], expect1);\n        backtrack(new int[]{0, 1}, new boolean[2], expect2);\n        backtrack(new int[]{1}, new boolean[1], expect3);\n\n        System.out.println(\"Test cases passed.\");\n    }\n\n    public static void backtrack(int[] nums, boolean[] used, int[][] expect) {\n        for (int i = 0; i < nums.length; i++) {\n            if (!used[i]) {\n                // add permutation to result\n                List<int[]> res = new ArrayList<>();\n                backtrackHelp(nums, used, 0, new int[nums.length], res);\n                for (int[] p : res) {\n                    System.out.println(Arrays.toString(p));\n                }\n                System.out.println(\"Expected: \" + Arrays.deepToString(expect));\n                System.out.println();\n            }\n        }\n    }\n\n    public static void backtrackHelp(int[] nums, boolean[] used, int start, int[] permutation, List<int[]> res) {\n        if (start == nums.length) {\n            res.add((int[]) permutation.clone());\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                permutation[start] = nums[i];\n                backtrackHelp(nums, used, start + 1, permutation, res);\n                used[i] = false;\n            }\n        }\n    }\n}\n```",
  "47": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] expectedResults = { {{1,2}, {1,2}}, {{1,1}, {1,1}}, {{1,2,3}, {1,2,3, 1,3,2}}};\n        for (int i = 0; i < expectedResults.length; i++) {\n            int[] nums = expectedResults[i][0];\n            List<List<Integer>> result = permuteUnique(nums);\n            boolean match = true;\n            for (List<Integer> permutation : result) {\n                if (!matchPermutations(expectedResults[i][1], permutation)) {\n                    match = false;\n                    break;\n                }\n            }\n            System.out.println(\"Test case \" + i + \": \" + (match ? \"Passed\" : \"Failed\"));\n        }\n    }\n\n    public static List<List<Integer>> permuteUnique(int[] nums) {\n        // implement the solution here\n    }\n\n    private static boolean matchPermutations(List<Integer> expected, List<Integer> actual) {\n        if (expected.size() != actual.size()) {\n            return false;\n        }\n        for (int i = 0; i < expected.size(); i++) {\n            if (!expected.get(i).equals(actual.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "48": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {\n                {1, 2, 3},\n                {4, 5, 6},\n                {7, 8, 9}\n        };\n        rotate(matrix1);\n        printMatrix(matrix1);\n\n        int[][] matrix2 = {\n                {5, 0, 0, 0},\n                {0, 10, 11, 12},\n                {0, 13, 14, 15},\n                {0, 0, 16, 17}\n        };\n        rotate(matrix2);\n        printMatrix(matrix2);\n\n        int[][] matrix3 = {\n                {1},\n                {2},\n                {3},\n                {4}\n        };\n        rotate(matrix3);\n        printMatrix(matrix3);\n    }\n\n    public static void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for (int i = 0; i < n / 2; i++) {\n            for (int j = i; j < n - i - 1; j++) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[n - j - 1][i];\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n                matrix[j][n - i - 1] = temp;\n            }\n        }\n    }\n\n    public static void printMatrix(int[][] matrix) {\n        for (int[] row : matrix) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "49": "```\nimport java.util.*;\n\npublic class GroupAnagrams {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<>();\n        for (String str : strs) {\n            char[] chars = str.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            if (!map.containsKey(key)) {\n                map.put(key, new ArrayList<>());\n            }\n            map.get(key).add(str);\n        }\n        return new ArrayList<>(map.values());\n    }\n\n    public static void main(String[] args) {\n        GroupAnagrams ga = new GroupAnagrams();\n        System.out.println(ga.groupAnagrams(new String[]{\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"}));\n        System.out.println(ga.groupAnagrams(new String[]{\"\"}));\n        System.out.println(ga.groupAnagrams(new String[] {\"a\"})));\n    }\n}",
  "50": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + myPow(2.0, 3));\n        System.out.println(\"Test case 2: \" + myPow(-10.0, 2));\n        System.out.println(\"Test case 3: \" + myPow(5.5, -1));\n    }\n\n    public static double myPow(double x, int n) {\n        if (n == 0) return 1;\n        if (n < 0) return 1 / myPow(x, -n);\n        if ((n & 1) == 0) return myPow(x * x, n / 2);\n        return x * myPow(x, n - 1);\n    }\n}\n```",
  "51": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] result1 = solveNQueens(4);\n        for (int i = 0; i < result1.length; i++) {\n            for (int j = 0; j < result1[i].length; j++) {\n                System.out.print(result1[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        int[][] result2 = solveNQueens(3);\n        for (int i = 0; i < result2.length; i++) {\n            for (int j = 0; j < result2[i].length; j++) {\n                System.out.print(result2[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        int[][] result3 = solveNQueens(1);\n        for (int i = 0; i < result3.length; i++) {\n            for (int j = 0; j < result3[i].length; j++) {\n                System.out.print(result3[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static int[][] solveNQueens(int n) {\n        if (n == 0) return new int[0][];\n        int[][] board = new int[n][n];\n        placeQueen(0, board, new boolean[n]);\n        return board;\n    }\n\n    private static void placeQueen(int row, int[][] board, boolean[] occupied) {\n        for (int col = 0; col < board.length; col++) {\n            if (!occupied[col]) {\n                board[row][col] = 1;\n                occupied[col] = true;\n                if (row == board.length - 1) {\n                    printBoard(board);\n                    System.out.println();\n                } else placeQueen(row + 1, board, occupied);\n                board[row][col] = 0;\n                occupied[col] = false;\n            }\n        }\n    }\n\n    private static void printBoard(int[][] board) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[i].length; j++) {\n                if (board[i][j] == 1) System.out.print(\"Q \");\n                else System.out.print(\". \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "52": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] res1 = solveNQueens(4);\n        printBoard(res1);\n        \n        System.out.println();\n        \n        int[][] res2 = solveNQueens(1);\n        printBoard(res2);\n        \n        System.out.println();\n        \n        int[][] res3 = solveNQueens(8);\n        printBoard(res3);\n    }\n    \n    public static int[][] solveNQueens(int n) {\n        // write your solution here\n    }\n    \n    public static void printBoard(int[][] board) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[i].length; j++) {\n                System.out.print(\" \" + (board[i][j] == 1 ? \"Q\" : \".\"));\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "53": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        int[] nums1 = {-2, 1, -3, 4, -1, 2, 1, -5, 4};\n        System.out.println(\"Maximum Subarray: \" + maxSubArray(nums1));\n        \n        System.out.println(\"\\nTest Case 2:\");\n        int[] nums2 = [0];\n        System.out.println(\"Maximum Subarray: \" + maxSubArray(nums2));\n\n        System.out.println(\"\\nTest Case 3:\");\n        int[] nums3 = [-1, -2, 3, 4, -5];\n        System.out.println(\"Maximum Subarray: \" + maxSubArray(nums3));\n    }\n\n    public static int maxSubArray(int[] nums) {\n        if (nums.length == 0) return 0;\n        int maxSoFar = nums[0], maxEndingHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n        return maxSoFar;\n    }\n}",
  "54": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        printMatrix(matrix1);\n\n        int[][] matrix2 = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n        printMatrix(matrix2);\n\n        int[][] matrix3 = {{1}, {2}};\n        printMatrix(matrix3);\n    }\n\n    public static void printMatrix(int[][] matrix) {\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                System.out.print(matrix[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "55": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canJump(new int[]{2,3,1,1,4})); // true\n        System.out.println(canJump(new int[]{0,2,5})); // false\n        System.out.println(canJump(new int[]{0})); // true\n    }\n\n    public static boolean canJump(int[] nums) {\n        int maxReachableIndex = 0;\n        for (int i = 0; i <= maxReachableIndex; i++) {\n            if (i > maxReachableIndex) {\n                maxReachableIndex = i + nums[i];\n            }\n        }\n        return maxReachableIndex >= nums.length - 1;\n    }\n}",
  "56": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals1 = {{1,3},{2,6},{8,10},{15,18}};\n        System.out.println(\"Expected: [[1,6],[8,10],[15,18]]\");\n        printIntervals(merge(intervals1));\n        \n        int[][] intervals2 = {{1,4},{4,5}};\n        System.out.println(\"Expected: [[1,5]]\");\n        printIntervals(merge(intervals2));\n        \n        int[][] intervals3 = {{1,2},{2,3},{4,5}};\n        System.out.println(\"Expected: [[1,3],[4,5]]\");\n        printIntervals(merge(intervals3));\n    }\n\n    public static int[][] merge(int[][] intervals) {\n        if (intervals.length == 0) {\n            return new int[0][];\n        }\n        \n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        \n        List<int[]> merged = new ArrayList<>();\n        int[] currentInterval = intervals[0];\n        \n        for (int i = 1; i < intervals.length; i++) {\n            if (currentInterval[1] >= intervals[i][0]) {\n                currentInterval[1] = Math.max(currentInterval[1], intervals[i][1]);\n            } else {\n                merged.add(currentInterval);\n                currentInterval = intervals[i];\n            }\n        }\n        \n        merged.add(currentInterval);\n        \n        return merged.toArray(new int[0][]);\n    }\n\n    public static void printIntervals(int[][] intervals) {\n        for (int[] interval : intervals) {\n            System.out.println(\"[\" + interval[0] + \",\" + interval[1] + \"]\");\n        }\n    }\n}",
  "57": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals = {{1,2},{3,5},{6,7},{8,10},{12,16}};\n        System.out.println(Arrays.deepToString(insert(intervals, new int[]{2, 3})));\n        System.out.println(Arrays.deepToString(insert(intervals, new int[]{0, 4})));\n        System.out.println(Arrays.deepcopyToString(insert(intervals, new int[]{5,7})));\n    }\n\n    public static int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> merged = new ArrayList<>();\n        int i = 0;\n        for (int[] interval : intervals) {\n            if (interval[1] < newInterval[0]) {\n                merged.add(interval);\n            } else if (interval[0] > newInterval[1]) {\n                merged.add(newInterval);\n                return merge(merged.toArray(new int[][]{}), new int[][]{interval});\n            } else {\n                newInterval[0] = Math.min(interval[0], newInterval[0]);\n                newInterval[1] = Math.max(interval[1], newInterval[1]);\n            }\n        }\n        merged.add(newInterval);\n        return merge(merged.toArray(new int[][]{}), null);\n    }\n\n    public static int[][] merge(int[][] intervals, int[] newInterval) {\n        List<int[]> merged = new ArrayList<>();\n        for (int[] interval : intervals) {\n            if ((interval[1] < newInterval[0]) || (newInterval[1] < interval[0])) {\n                merged.add(interval);\n            } else {\n                newInterval[0] = Math.min(interval[0], newInterval[0]);\n                newInterval[1] = Math.max(interval[1], newInterval[1]);\n            }\n        }\n        if (newInterval != null) {\n            merged.add(newInterval);\n        }\n        return merged.toArray(new int[][]{});\n    }\n}\n```",
  "58": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(lengthOfLastWord(\"Hello World\")); // Expected output: 5\n        System.out.println(lengthOfLastWord(\"   fly me to the moon   \")); // Expected output: 4\n        System.out.println(lengthOfLastWord(\"aaa\"));\n    }\n\n    public static int lengthOfLastWord(String s) {\n        if (s == null || s.trim().equals(\"\")) {\n            return 0;\n        }\n        String[] words = s.split(\"\\\\s+\");\n        return words[words.length - 1].length();\n    }\n}",
  "60": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(nthSuperUglyNumber(12, new int[]{2, 7, 13, 19}));\n        System.out.println(nthSuperUglyNumber(1, new int[]{2, 3, 5})); \n        System.out.println(nthSuperUglyNumber(4, new int[]{1, 2, 3}));    \n    }\n\n    public static long nthSuperUglyNumber(int n, int[] primes) {\n        List<Long> ugly = new ArrayList<>();\n        ugly.add(1L);\n        for (int i = 1; i < n; i++) {\n            long next = -1;\n            for (int p : primes) {\n                while (ugly.get((ugly.size() - 1) * p % (i + 1)) * p <= next) {\n                    ugly.set(ugly.size() - 1, ugly.get(ugly.size() - 1) * p);\n                }\n            }\n        }\n        return ugly.get(n - 1);\n    }\n}\n```",
  "59": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        spiralOrder(matrix1);\n\n        int[][] matrix2 = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}, {13, 14, 15, 16}};\n        spiralOrder(matrix2);\n\n        int[][] matrix3 = {{1}};\n        spiralOrder(matrix3);\n    }\n\n    public static void spiralOrder(int[][] matrix) {\n        if (matrix == null || matrix.length == 0)\n            return;\n\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int[] result = new int[rows * cols];\n\n        int top = 0, bottom = rows - 1;\n        int left = 0, right = cols - 1;\n        int index = 0;\n\n        while (top <= bottom && left <= right) {\n            // Traverse from left to right\n            for (int i = left; i <= right; i++) {\n                result[index++] = matrix[top][i];\n            }\n            top++;\n\n            // Traverse from top to bottom\n            for (int i = top; i <= bottom; i++) {\n                result[index++] = matrix[i][right];\n            }\n            right--;\n\n            // Traverse from right to left\n            if (top <= bottom) {\n                for (int i = right; i >= left; i--) {\n                    result[index++] = matrix[bottom][i];\n                }\n                bottom--;\n            }\n\n            // Traverse from bottom to top\n            if (left <= right) {\n                for (int i = bottom; i >= top; i--) {\n                    result[index++] = matrix[i][left];\n                }\n                left++;\n            }\n        }\n\n        // Print the spiral order\n        for (int i = 0; i < rows * cols; i++) {\n            System.out.print(result[i] + \" \");\n        }\n        System.out.println();\n    }\n}",
  "61": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(3);\n        head1.next.next.next = new ListNode(4);\n        head1.next.next.next.next = new ListNode(5);\n\n        ListNode result1 = rotateRight(head1, 2);\n        printList(result1);\n\n        ListNode head2 = new ListNode(0);\n        head2.next = new ListNode(1);\n        head2.next.next = new ListNode(2);\n\n        ListNode result2 = rotateRight(head2, 4);\n        printList(result2);\n\n        ListNode head3 = null;\n\n        ListNode result3 = rotateRight(head3, 5);\n        printList(result3);\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n\n    public static ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        int length = 1;\n        ListNode tail = head;\n\n        while (tail.next != null) {\n            tail = tail.next;\n            length++;\n        }\n\n        ListNode newTail = head;\n        for (int i = 0; i < length - k % length - 1; i++) {\n            newTail = newTail.next;\n        }\n\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n\n        tail = newHead;\n        for (int i = 0; i < length - k % length - 1; i++) {\n            tail = tail.next;\n        }\n\n        head = tail.next;\n        tail.next = newHead;\n\n        return head;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int val) {\n        this.val = val;\n    }\n}",
  "62": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(uniquePaths(3, 7)); // Test case 1: Expected output - 28\n        System.out.println(uniquePaths(2, 3)); // Test case 2: Expected output - 3\n        System.out.println(uniquePaths(5, 20)); // Test case 3: Expected output - 651744\n    }\n\n    public static int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}",
  "64": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{1,3,1},{1,5,1},{4,2,1}};\n        System.out.println(minPathSum(grid1));\n        \n        int[][] grid2 = {{2, 1, 3}, {6, 5, 4}, {7, 8, 9}};\n        System.out.println(minPathSum(grid2));\n\n        int[][] grid3 = {{0, 0, 0},{0, 9, 0},{4,7,8}};\n        System.out.println(minPathSum(grid3));\n    }\n\n    public static int minPathSum(int[][] grid) {\n        int m = grid.length;\n        if (m == 0) return 0;\n\n        int n = grid[0].length;\n        for (int i = 1; i < m; i++) {\n            grid[i][0] += grid[i - 1][0];\n        }\n        for (int j = 1; j < n; j++) {\n            grid[0][j] += grid[0][j - 1];\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);\n            }\n        }\n\n        return grid[m - 1][n - 1];\n    }\n}\n```",
  "63": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,0,0},{0,1,0},{0,1,0}};\n        System.out.println(\"Test Case 1: \" + uniquePathsWithObstacles(grid1));\n\n        int[][] grid2 = {{0,0,0},{1,1,1},{0,0,0}};\n        System.out.println(\"Test Case 2: \" + uniquePathsWithObstacles(grid2));\n\n        int[][] grid3 = {{0,0,0,0},{0,1,1,0},{0,0,0,0},{0,0,0,0}};\n        System.out.println(\"Test Case 3: \" + uniquePathsWithObstacles(grid3));\n    }\n\n    public static int uniquePathsWithObstacles(int[][] grid) {\n        if (grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        int m = grid.length, n = grid[0].length;\n        int[] dp = new int[n];\n        for (int i = 1; i < n; i++) {\n            if (grid[0][i] == 1) {\n                break;\n            }\n            dp[i] = (i > 0 ? dp[i - 1] : 1);\n        }\n        for (int i = 1; i < m; i++) {\n            int[] ndp = new int[n];\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    ndp[j] = 0;\n                } else {\n                    ndp[j] = (j > 0 ? ndp[j - 1] : dp[0]) + (j < n - 1 && i > 0 ? ndp[j + 1] : 0);\n                }\n            }\n            dp = ndp;\n        }\n        return dp[n - 1];\n    }\n}\n```",
  "65": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isValid(\"0\")); // true\n        System.out.println(isValid(\"123.45\")); // true\n        System.out.println(isValid(\"123e+\")); // false\n    }\n\n    public static boolean isValid(String s) {\n        if (s.isEmpty()) return true;\n        \n        boolean hasPoint = false, hasE = false;\n        for (char c : s.toCharArray()) {\n            if (!Character.isDigit(c)) {\n                if (c == '.') hasPoint = true;\n                else if (c == 'e' || c == 'E') {\n                    if (hasPoint) return false; // can't have both '.' and 'e'\n                    hasE = true;\n                } else return false; // only allow '.', 'e', or digits\n            }\n        }\n        \n        return !s.isEmpty() && (!hasPoint || s.indexOf('.') == 0) && (hasE ? !hasPoint : true);\n    }\n}",
  "66": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2};\n        int[] result1 = plusOne(nums1);\n        System.out.println(\"Test case 1: \" + Arrays.toString(result1));\n\n        int[] nums2 = {1, 3, 4};\n        int[] result2 = plusOne(nums2);\n        System.out.println(\"Test case 2: \" + Arrays.toString(result2));\n\n        int[] nums3 = [9];\n        int[] result3 = plusOne(nums3);\n        System.out.println(\"Test case 3: \" + Arrays.toString(result3));\n    }\n\n    public static int[] plusOne(int[] digits) {\n        for (int i = digits.length - 1; i >= 0; i--) {\n            if (digits[i] < 9) {\n                return increaseDigit(digits, i);\n            }\n        }\n        return new int[] {1};\n    }\n\n    public static int[] increaseDigit(int[] digits, int index) {\n        digits[index]++;\n        for (int i = index + 1; i < digits.length; i++) {\n            if (digits[i] > 9) {\n                digits[i] = 0;\n                return new int[] {1}.concat(digits);\n            }\n        }\n        return digits;\n    }\n}\n```",
  "67": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(addBinary(\"11\", \"1\")); // Expected output: \"100\"\n        System.out.println(addBinary(\"1010\", \"1111\")); // Expected output: \"11001\"\n        System.out.println(addBinary(\"0\", \"0\")); // Expected output: \"0\"\n    }\n\n    public static String addBinary(String a, String b) {\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n        StringBuilder sb = new StringBuilder();\n        int carry = 0;\n\n        while (i >= 0 || j >= 0 || carry > 0) {\n            int sum = (i >= 0 ? a.charAt(i--) - '0' : 0) + \n                (j >= 0 ? b.charAt(j--) - '0' : 0) + carry;\n            sb.append((sum & 1) == 1 ? '1' : '0');\n            carry = sum >> 1;\n        }\n\n        return sb.reverse().toString();\n    }\n}\n```",
  "68": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        justification(\"This is an example sentence for justification.\");\n        justification(\"Hello world this is a test\");\n        justification(\"a b c d e f g h i j k l m n o p q r s t\");\n    }\n\n    public static void justification(String text) {\n        // Your logic to justify the text goes here\n    }\n}\n```",
  "69": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + sqrt(4));\n        System.out.println(\"Test case 2: \" + sqrt(8));\n        System.out.println(\"Test case 3: \" + sqrt(9));\n    }\n\n    public static int sqrt(int x) {\n        if (x < 0) {\n            return -1;\n        }\n        if (x == 0 || x == 1) {\n            return x;\n        }\n        int left = 1, right = x;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            long square = (long)mid * mid;\n            if (square == x) {\n                return mid;\n            } else if (square < x) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return right;\n    }\n}\n```",
  "70": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(climbStairs(2)); // Expected: 2\n        System.out.println(climbStairs(3)); // Expected: 3\n        System.out.println(climbStairs(4)); // Expected: 5\n    }\n\n    public static int climbStairs(int n) {\n        if (n == 1) return 1;\n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        dp[2] = 2;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}",
  "71": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(simplifyPath(\"/home//foo/\")); // Output: \"/home/foo\"\n        System.out.println(simplifyPath(\"/a/./b/../../c/\")); // Output: \"/c\"\n        System.out.println(simplifyPath(\"/../\")); // Output: \"/\"\n    }\n\n    public static String simplifyPath(String path) {\n        Stack<String> stack = new Stack<>();\n        for (String part : path.split(\"/\")) {\n            if (part.isEmpty() || part.equals(\".\")) {\n                continue;\n            } else if (part.equals(\"..\")) {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                }\n            } else {\n                stack.push(part);\n            }\n        }\n        StringBuilder simplified = new StringBuilder(\"/\");\n        for (String dir : stack) {\n            simplified.append(dir).append(\"/\");\n        }\n        return stack.isEmpty() ? \"/\" : simplified.toString().substring(0, simplified.length() - 1);\n    }\n}\n```",
  "72": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(editDistance(\"horse\", \"ros\")); // Test case 1\n        System.out.println(editDistance(\"intention\", \"execution\")); // Test case 2\n        System.out.println(editDistance(\"kitten\", \"sitting\")); // Test case 3\n    }\n\n    public static int editDistance(String word1, String word2) {\n        int m = word1.length();\n        int n = word2.length();\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 0; i <= m; i++) {\n            dp[i][0] = i;\n        }\n        for (int j = 0; j <= n; j++) {\n            dp[0][j] = j;\n        }\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                int cost = word1.charAt(i - 1) == word2.charAt(j - 1) ? 0 : 1;\n                dp[i][j] = Math.min(Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1), dp[i - 1][j - 1] + cost);\n            }\n        }\n\n        return dp[m][n];\n    }\n}\n```",
  "73": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {\n            {1,0,1},\n            [0,1,1],\n            {1,1,1}\n        };\n        setZeroes(matrix1);\n        printMatrix(matrix1);\n\n        int[][] matrix2 = {\n            {0,1,2,0},\n            {3,4,5,2},\n            {1,3,1,5}\n        };\n        setZeroes(matrix2);\n        printMatrix(matrix2);\n\n        int[][] matrix3 = {\n            {1,1,1,1},\n            [0,1,0,1],\n            {0,0,0,1},\n            [1,1,1,1]\n        };\n        setZeroes(matrix3);\n        printMatrix(matrix3);\n    }\n\n    public static void setZeroes(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n\n        boolean[] rowFlags = new boolean[m];\n        boolean[] colFlags = new boolean[n];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    rowFlags[i] = true;\n                    colFlags[j] = true;\n                }\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (rowFlags[i] || colFlags[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n\n    public static void printMatrix(int[][] matrix) {\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                System.out.print(matrix[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "74": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix = {{1, 4, 7, 11, 15},\n                           {2, 5, 8, 12, 19},\n                           {3, 6, 9, 16, 22},\n                           {10, 13, 14, 17, 24},\n                           {18, 21, 23, 26, 30}};\n        \n        System.out.println(searchMatrix(matrix, 5)); // Test case 1: found\n        System.out.println(searchMatrix(matrix, 20)); // Test case 2: not found\n        System.out.println(searchMatrix(matrix, 25)); // Test case 3: found\n    }\n\n    public static int searchMatrix(int[][] matrix, int target) {\n        if (matrix.length == 0 || matrix[0].length == 0) {\n            return -1;\n        }\n        \n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        \n        int low = 0;\n        int high = rows * cols - 1;\n        \n        while (low <= high) {\n            int mid = (low + high) / 2;\n            int midVal = matrix[mid / cols][mid % cols];\n            \n            if (midVal == target) {\n                return mid;\n            } else if (midVal < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        \n        return -1;\n    }\n}\n```",
  "75": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] testCases = {\n            {2,0,2},\n            {1,1,0},\n            {2,0}\n        };\n\n        for (int[] testCase : testCases) {\n            int[] colors = new int[testCase.length];\n            for (int i = 0; i < testCase.length; i++) {\n                colors[i] = testCase[i];\n            }\n            twoPointerSort(colors);\n            System.out.println(\"Test case: \" + Arrays.toString(testCase));\n            System.out.println(\"Sorted: \" + Arrays.toString(colors));\n            System.out.println();\n        }\n    }\n\n    public static void twoPointerSort(int[] nums) {\n        int low = 0;\n        int mid = 0;\n        int high = nums.length - 1;\n\n        while (mid <= high) {\n            if (nums[mid] == 0) {\n                swap(nums, low++, mid++);\n            } else if (nums[mid] == 2) {\n                swap(nums, mid, high--);\n            } else {\n                mid++;\n            }\n        }\n    }\n\n    public static void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```",
  "76": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minWindow(\"ADOBECODEBANC\", \"ABC\")); // Output: \"BANC\"\n        System.out.println(minWindow(\"a\", \"a\")); // Output: \"a\"\n        System.out.println(minWindow(\"\", \"a\")); // Output: \"\"\n    }\n\n    public static String minWindow(String s, String t) {\n        if (t.length() > s.length()) return \"\";\n        int left = 0;\n        int right = 0;\n        int formated = 0;\n        int minLen = Integer.MAX_VALUE;\n        String res = \"\";\n\n        while (right < s.length()) {\n            if (strContains(t.charAt(formated), s, right)) {\n                formated++;\n            }\n            while (formated == t.length()) {\n                if (right - left + 1 < minLen) {\n                    minLen = right - left + 1;\n                    res = s.substring(left, right + 1);\n                }\n                if (strContains(t.charAt(formated), s, left)) {\n                    formated--;\n                    left++;\n                } else {\n                    right++;\n                }\n            }\n            right++;\n        }\n\n        return res;\n    }\n\n    public static boolean strContains(char c, String s, int start) {\n        for (int i = start; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
  "77": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n = 4;\n        int k = 2;\n        List<List<Integer>> combinations = combine(n, k);\n        \n        System.out.println(\"Test case 1: n=3, k=2\");\n        printCombinations(combinations);\n        \n        n = 3;\n        k = 3;\n        combinations = combine(n, k);\n        \n        System.out.println(\"\\nTest case 2: n=3, k=3\");\n        printCombinations(combinations);\n        \n        n = 5;\n        k = 3;\n        combinations = combine(n, k);\n        \n        System.out.println(\"\\nTest case 3: n=5, k=3\");\n        printCombinations(combinations);\n    }\n\n    public static List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        combineHelper(result, new ArrayList<>(), 1, n, k);\n        return result;\n    }\n\n    private static void combineHelper(List<List<Integer>> result, List<Integer> tempList, int start, int end, int k) {\n        if (tempList.size() == k) {\n            result.add(new ArrayList<>(tempList));\n        } else if (start <= end) {\n            for (int i = start; i <= end; i++) {\n                tempList.add(i);\n                combineHelper(result, tempList, i + 1, end, k);\n                tempList.remove(tempList.size() - 1);\n            }\n        }\n    }\n\n    private static void printCombinations(List<List<Integer>> combinations) {\n        for (List<Integer> combination : combinations) {\n            System.out.println(combination);\n        }\n    }\n}",
  "78": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] expected = { {{}, {1}, {2}, {1, 2}},\n                {{}, {0}, {0, 1}, {0, 2}, {0, 1, 2},\n                        {1}, {1, 0}, {1, 2}, {1, 0, 2},\n                        {2}, {2, 0}, {2, 1}, {2, 0, 1}},\n                {{}, {0}, {1}, {0, 1}, {2}, {0, 2}, {1, 2},\n                        {0, 1, 2}, {0}, {0, 1}, {0, 1, 2},\n                        {0, 2}, {1}, {1, 2}, {0, 1, 2}}};\n\n        for (int i = 0; i < expected.length; i++) {\n            int[] nums = {0, 1, 2};\n            int[][] subsets = new Solution().subsets(nums);\n            System.out.println(\"Test Case \" + i);\n            for (int j = 0; j < subsets.length; j++) {\n                System.out.print(\"[\");\n                for (int k = 0; k < subsets[j].length; k++) {\n                    System.out.print(subsets[j][k]);\n                    if (k != subsets[j].length - 1) {\n                        System.out.print(\", \");\n                    }\n                }\n                System.out.println(\"]\");\n            }\n            System.out.println();\n        }\n    }\n}\n\n```",
  "80": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {\n            {1, 1, 2},\n            {0, 0, 1, 1, 1, 2, 3},\n            {1}\n        };\n        for (int i = 0; i < inputs.length; i++) {\n            int[] array = inputs[i];\n            int[] result = new int[removeDuplicates(array).length];\n            System.arraycopy(removeDuplicates(array), 0, result, 0, result.length);\n            System.out.println(\"Input: \" + Arrays.toString(array));\n            System.out.println(\"Output: \" + Arrays.toString(result));\n        }\n    }\n\n    public static int[] removeDuplicates(int[] nums) {\n        if (nums.length == 0) return nums;\n        int left = 1, right = 1;\n        while (right < nums.length) {\n            if (nums[right] != nums[right - 1]) {\n                nums[left++] = nums[right];\n            }\n            right++;\n        }\n        int[] result = new int[left];\n        System.arraycopy(nums, 0, result, 0, left);\n        return result;\n    }\n}",
  "79": "```\npublic class Main {\n    public static void main(String[] args) {\n        String[][] board1 = {{\"A\",\"B\",\"C\",\"E\"},\"D\",\"F\"};\n        boolean result1 = exist(board1, \"ABC\");\n        System.out.println(result1);  // Expected: true\n\n        String[][] board2 = {{\"SOLVEME\",\"POMME\",\"TIME\",\"SOLVE\"},{\"ORZ\",\"HIDE\",\"SPACER\",\"HIDDEN\"],[\"THIS\",\"IS\",\"CODING\",\"CHALLENGE\"]};\n        boolean result2 = exist(board2, \"SOLV\");\n        System.out.println(result2);  // Expected: true\n\n        String[][] board3 = {{\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"},\"H\",\"I\",\"J\",\"K\",\"L\",\"M\"};\n        boolean result3 = exist(board3, \"GDFEFG\");\n        System.out.println(result3);  // Expected: false\n    }\n\n    public static boolean exist(String[][] board, String word) {\n        if (board == null || board.length == 0 || word == null || word.length() == 0) {\n            return false;\n        }\n        int rows = board.length;\n        int cols = board[0].length;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (exist(board, i, j, word, 0)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static boolean exist(String[][] board, int row, int col, String word, int index) {\n        if (index == word.length()) {\n            return true;\n        }\n\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length) {\n            return false;\n        }\n\n        if (board[row].charAt(col) != word.charAt(index)) {\n            return false;\n        }\n\n        String temp = board[row].charAt(col) + \"\";\n        board[row] = board[row].replaceFirst(temp, \" \");\n\n        boolean result = exist(board, row - 1, col, word, index + 1)\n                || exist(board, row + 1, col, word, index + 1)\n                || exist(board, row, col - 1, word, index + 1)\n                || exist(board, row, col + 1, word, index + 1);\n\n        board[row] = board[row].replaceFirst(\" \", temp);\n        return result;\n    }\n}\n```",
  "81": "```\npublic class Main {\n    public static void main(String[] args) {\n        int target1 = 8;\n        System.out.println(\"Searching for \" + target1 + \": \" + searchRange(new int[]{1, 3}, target1));\n        \n        int target2 = 4;\n        System.out.println(\"Searching for \" + target2 + \": \" + searchRange(new int[]{1, 1}, target2));\n        \n        int target3 = 5;\n        System.out.println(\"Searching for \" + target3 + \": \" + searchRange(new int[]{1, 2}, target3));\n    }\n\n    public static int[] searchRange(int[] nums, int target) {\n        int[] result = new int[]{-1, -1};\n        int left = findFirst(nums, target);\n        if (left == -1) return result;\n        result[0] = left;\n\n        result[1] = findLast(nums, target);\n        return result;\n    }\n\n    public static int findFirst(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else if (nums[mid] > target) {\n                right = mid - 1;\n            } else {\n                return mid;\n            }\n        }\n        return -1;\n    }\n\n    public static int findLast(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] > target) {\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                return mid;\n            }\n        }\n        return -1;\n    }\n}",
  "82": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(2);\n        head1.next.next.next = new ListNode(3);\n\n        System.out.println(\"Before removing duplicates: \");\n        printList(head1);\n        \n        head1 = removeDuplicates(head1);\n        \n        System.out.println(\"\\nAfter removing duplicates: \");\n        printList(head1);\n\n        // Test case 2\n        ListNode head2 = new ListNode(0);\n        head2.next = new ListNode(1);\n        head2.next.next = new ListNode(3);\n\n        System.out.println(\"\\nBefore removing duplicates (Test case 2): \");\n        printList(head2);\n\n        head2 = removeDuplicates(head2);\n\n        System.out.println(\"\\nAfter removing duplicates (Test case 2): \");\n        printList(head2);\n\n        // Test case 3\n        ListNode head3 = new ListNode(1);\n        head3.next = new ListNode(1);\n        head3.next.next = new ListNode(1);\n        head3.next.next.next = new ListNode(2);\n        head3.next.next.next.next = new ListNode(3);\n\n        System.out.println(\"\\nBefore removing duplicates (Test case 3): \");\n        printList(head3);\n\n        head3 = removeDuplicates(head3);\n\n        System.out.println(\"\\nAfter removing duplicates (Test case 3): \");\n        printList(head3);\n    }\n\n    public static ListNode removeDuplicates(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode dummyHead = new ListNode(0);\n        dummyHead.next = head;\n        ListNode prev = dummyHead;\n        ListNode curr = head;\n\n        while (curr != null && curr.next != null) {\n            if (curr.val == curr.next.val) {\n                while (curr.next != null && curr.next.val == curr.val) {\n                    curr = curr.next;\n                }\n                prev.next = curr.next;\n            } else {\n                prev = prev.next;\n            }\n            curr = curr.next;\n        }\n\n        return dummyHead.next;\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n```",
  "83": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(1);\n        head1.next.next = new ListNode(2);\n\n        ListNode head2 = new ListNode(1);\n        head2.next = new ListNode(1);\n        head2.next.next = new ListNode(1);\n        head2.next.next.next = new ListNode(2);\n\n        ListNode head3 = new ListNode(1);\n        head3.next = new ListNode(2);\n\n        System.out.println(\"Test Case 1: \" + removeDuplicates(head1).toString());\n        System.out.println(\"Test Case 2: \" + removeDuplicates(head2).toString());\n        System.out.println(\"Test Case 3: \" + removeDuplicates(head3).toString());\n    }\n\n    public static ListNode removeDuplicates(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode current = head;\n        while (current.next != null) {\n            if (current.val != current.next.val) {\n                current = current.next;\n            } else {\n                current.next = current.next.next;\n            }\n        }\n\n        return head;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int val) {\n        this.val = val;\n        this.next = null;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        ListNode current = this;\n        while (current != null) {\n            sb.append(current.val).append(\" \");\n            current = current.next;\n        }\n        return sb.toString();\n    }\n}",
  "84": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] histogram1 = {{2}};\n        System.out.println(\"Histogram 1: \" + largestRectangleArea(histogram1));\n\n        int[][] histogram2 = {{1,2},{2,3},{2,4}};\n        System.out.println(\"Histogram 2: \" + largestRectangleArea(new int[][]{histogram2}));\n\n        int[][] histogram3 = {{6,7},{8,9},{5,6},{7,8}};\n        System.out.println(\"Histogram 3: \" + largestRectangleArea(new int[][]{histogram3}));\n    }\n\n    public static int largestRectangleArea(int[][] height) {\n        if (height == null || height.length == 0) {\n            return 0;\n        }\n        \n        int maxArea = 0;\n        for (int i = 0; i < height.length; i++) {\n            int[] h = height[i];\n            Stack<Integer> stack = new Stack<>();\n            \n            for (int j = 0; j <= h.length; j++) {\n                if (j == h.length || h[j] < h[j - 1]) {\n                    while (!stack.isEmpty()) {\n                        int topHeight = h[stack.pop()];\n                        int width = j - stack.size() - 1;\n                        \n                        maxArea = Math.max(maxArea, topHeight * width);\n                    }\n                } else if (j == 0 || h[j] >= h[j - 1]) {\n                    stack.push(j);\n                }\n            }\n        }\n        \n        return maxArea;\n    }\n}\n```",
  "85": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input1 = {{'0','0','1','0','0'},{'1','0','1','1','0'},{'1','1','1','1','1'},{'1','0','0','0','0'}};\n        System.out.println(\"Test case 1: \" + maximalRectangle(input1));\n\n        int[][] input2 = {{'0'}};\n        System.out.println(\"Test case 2: \" + maximalRectangle(input2));\n\n        int[][] input3 = {{'1'},{'1'}};\n        System.out.println(\"Test case 3: \" + maximalgroundColor(maximalRectangle(input3)));\n    }\n\n    public static int maximalRectangle(int[][] matrix) {\n        if(matrix.length == 0 || matrix[0].length == 0)\n            return 0;\n        \n        int maxArea = 0;\n        int[] height = new int[matrix[0].length];\n        \n        for(int i = 0; i < matrix.length; i++){\n            for(int j = 0; j < matrix[i].length; j++){\n                if(matrix[i][j] == '1')\n                    height[j]++;\n                else\n                    height[j] = 0;\n            }\n            \n            int left = 0, right = matrix[0].length-1, area = 0;\n            \n            while(left <= right){\n                area = height[left];\n                for(int k = left; k <= right; k++){\n                    if(height[k] < area)\n                        break;\n                    else\n                        area++;\n                }\n                \n                maxArea = Math.max(maxArea, area*(right-left+1));\n                \n                int minVal = height[right], leftBound = left;\n                for(int k = right; k >= left; k--){\n                    if(height[k] < minVal)\n                        minVal = height[k];\n                    else\n                        break;\n                }\n                area = (minVal - left) * 1;\n                for(int k = left; k <= minVal - 1; k++){\n                    if(height[k] < area)\n                        break;\n                    else\n                        area++;\n                }\n                \n                maxArea = Math.max(maxArea, area);\n                \n                left++;\n            }\n        }\n        \n        return maxArea;\n    }\n}",
  "86": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(4);\n        head1.next.next = new ListNode(3);\n        head1.next.next.next = new ListNode(2);\n        head1.next.next.next.next = new ListNode(5);\n\n        partition(head1, 3);\n\n        System.out.println(\"Test case 1: \");\n        printList(head1);\n\n        // Test case 2\n        ListNode head2 = new ListNode(4);\n        head2.next = new ListNode(2, new ListNode(2));\n        head2.next.next = new ListNode(5, new ListNode(3));\n\n        partition(head2, 2);\n\n        System.out.println(\"Test case 2: \");\n        printList(head2);\n\n        // Test case 3\n        ListNode head3 = new ListNode(1);\n        head3.next = new ListNode(4);\n\n        partition(head3, 5);\n\n        System.out.println(\"Test case 3: \");\n        printList(head3);\n    }\n\n    public static void partition(ListNode head, int x) {\n        if (head == null || head.next == null) return;\n\n        ListNode beforeStart = null;\n        ListNode afterStart = null;\n        ListNode afterEnd = null;\n\n        ListNode cur = head;\n        while (cur != null) {\n            if (cur.val < x) {\n                if (beforeStart == null) {\n                    beforeStart = cur;\n                    beforeStart.next = null;\n                } else {\n                    beforeStart.next = cur;\n                    beforeStart = beforeStart.next;\n                }\n            } else {\n                afterEnd = cur;\n                afterEnd.next = null;\n\n                if (afterStart == null) {\n                    afterStart = afterEnd;\n                } else {\n                    afterEnd.next = afterStart;\n                    afterStart = afterEnd;\n                }\n            }\n            cur = cur.next;\n        }\n\n        if (beforeStart == null) {\n            head = afterStart;\n        } else {\n            beforeStart.next = afterStart;\n            head = beforeStart;\n        }\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int val) {\n        this.val = val;\n    }\n\n    public ListNode(int val, ListNode next) {\n        this(val);\n        this.next = next;\n    }\n}\n```",
  "87": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(scrambleString(\"rgtae\", \"teaforart\")); // true\n        System.out.println(scrambleString(\"abcw\", \"bzaqac\")); // false\n        System.out.println(scrambleString(\"aebd\", \"baed\"));// true\n    }\n\n    public static boolean scrambleString(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int[][] dp = new int[s.length()][t.length()];\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = 0; j <= i; j++) {\n                if (s.charAt(i) == t.charAt(j)) {\n                    dp[i][j] = (i == 0)? 1 : dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (dp[i][s.length() - 1] != 1) return false;\n        }\n        return true;\n    }\n}",
  "88": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrays = {{1, 2, 3}, {2, 4, 6}};\n        mergeSortedArray(arrays);\n\n        arrays = new int[][]{{0, 1, 2, 5}, {3, 7, 10, 11}};\n        mergeSortedArray(arrays);\n\n        arrays = new int[][]{{1, 2, 3, 4, 6, 8}, {3, 5, 7}};\n        mergeSortedArray(arrays);\n    }\n\n    public static void mergeSortedArray(int[][] arrays) {\n        int[] result = new int[arrays.length];\n        int i = 0;\n        for (int[] array : arrays) {\n            System.arraycopy(array, 0, result, i, array.length);\n            i += array.length;\n        }\n        Arrays.sort(result);\n\n        for (int num : result) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n    }\n}\n```",
  "89": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(getGrayCode(2).toString()); // Output: [0, 1, 3, 2]\n        System.out.println(getGrayCode(3).toString()); // Output: [0, 1, 3, 2, 6, 7]\n        System.out.println(getGrayCode(4).toString()); // Output: [0, 1, 3, 2, 6, 7, 5, 4]\n    }\n\n    public static List<Integer> getGrayCode(int n) {\n        List<Integer> grayCodes = new ArrayList<>();\n        for (int i = 0; i < (1 << n); i++) {\n            int code = i ^ (i >> 1);\n            grayCodes.add(code);\n        }\n        return grayCodes;\n    }\n}\n```",
  "91": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numDecodings(\"12\")); // Test case 1\n        System.out.println(numDecodings(\"226\")); // Test case 2\n        System.out.println(numDecodings(\"0\")); // Test case 3\n    }\n\n    public static int numDecodings(String s) {\n        if (s.isEmpty()) return 0;\n        int[] dp = new int[s.length() + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= s.length(); i++) {\n            if (s.charAt(i - 1) != '0') {\n                dp[i] += dp[i - 1];\n            }\n            if (i >= 2 && Integer.parseInt(s.substring(i - 2, i)) <= 26) {\n                dp[i] += dp[i - 2];\n            }\n        }\n        return dp[s.length()];\n    }\n}\n```",
  "90": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] expected1 = {new int[]{}, new int[]{1}, new int[]{2}, new int[]{1, 2}, new int[]{1, 3}, new int[]{2, 3}, new int[]{1, 2, 3}};\n        subsets(new int[]{1, 2, 2}, expected1);\n        \n        int[][] expected2 = {new int[]{}};\n        subsets(new int[]{0}, expected2);\n\n        int[][] expected3 = {new int[]{}, new int[]{0}, new int[]{1}};\n        subsets(new int[]{0, 1, 0}, expected3);\n    }\n\n    public static void subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < (1 << nums.length); i++) {\n            List<Integer> subset = new ArrayList<>();\n            for (int j = 0; j < nums.length; j++) {\n                if (((i >> j) & 1) == 1) {\n                    subset.add(nums[j]);\n                }\n            }\n            res.add(new ArrayList<>(subset));\n        }\n        System.out.println(res);\n    }\n}",
  "93": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canPartition(\"25525511135\")); // expected: [\"255.255.11.135\", \"255.255.111.35\"]\n        System.out.println(canPartition(\"0100111\")); // expected: [\"0.10.11.1\", \"0.1.01.11\", \"00.10.11.1\", \"0001.0.11.1\", \"00010.1.1.1\"]\n        System.out.println(canPartition(\"123456789012\")); // expected: []\n    }\n}\n\nclass Solution {\n    public List<String> restoreIpAddresses(String s) {\n        List<String> res = new ArrayList<>();\n        backtrack(s, \"\", 0, res);\n        return res;\n    }\n\n    private void backtrack(String s, String path, int start, List<String> res) {\n        if (path.length() > 3 * (s.length() - start + 1)) return; // avoid the case where the number of segments is more than the remaining string\n        if (start == s.length()) {\n            if (path.length() == 4) res.add(\"inet.\" + path.substring(0, 4));\n            return;\n        }\n        for (int i = start; i <= Math.min(start + 2, s.length()); i++) {\n            String segment = s.substring(start, i);\n            if (isValid(segment)) {\n                backtrack(s, path + segment + \".\", start + i, res);\n            }\n        }\n    }\n\n    private boolean isValid(String s) {\n        if (s.isEmpty()) return true;\n        if (s.charAt(0) == '0') return s.equals(\"0\"); // leading zero is not allowed\n        int num = Integer.parseInt(s);\n        return num <= 255; // the number should be within the range of an IP address segment\n    }\n}\n```",
  "92": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(3);\n        head1.next.next.next = new ListNode(4);\n        head1.next.next.next.next = new ListNode(5);\n\n        System.out.println(\"Test case 1: Before\");\n        printList(head1);\n        head1 = reverseBetween(head1, 2, 4);\n        System.out.println(\"\\nTest case 1: After\");\n        printList(head1);\n\n        ListNode head2 = new ListNode(1);\n        head2.next = new ListNode(2);\n        head2.next.next = new ListNode(3);\n        head2.next.next.next = new ListNode(4);\n\n        System.out.println(\"Test case 2: Before\");\n        printList(head2);\n        head2 = reverseBetween(head2, 1, 3);\n        System.out.println(\"\\nTest case 2: After\");\n        printList(head2);\n\n        ListNode head3 = new ListNode(1);\n        head3.next = new ListNode(2);\n\n        System.out.println(\"Test case 3: Before\");\n        printList(head3);\n        head3 = reverseBetween(head3, 1, 2);\n        System.out.println(\"\\nTest case 3: After\");\n        printList(head3);\n    }\n\n    public static ListNode reverseBetween(ListNode head, int left, int right) {\n        if (head == null || left == right) {\n            return head;\n        }\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode pre = dummy;\n\n        for (int i = 1; i < left; i++) {\n            pre = pre.next;\n        }\n\n        ListNode start = pre.next;\n        ListNode end = start;\n        for (int i = left; i < right; i++) {\n            end = end.next;\n        }\n\n        ListNode next = end.next;\n        end.next = null;\n\n        pre.next = reverse(start);\n        start.next = next;\n\n        return dummy.next;\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int x) { val = x; }\n}\n```",
  "94": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Node root1 = new Node(1);\n        root1.right = new Node(2);\n        root1.left = new Node(0);\n\n        Node root2 = new Node(4);\n        root2.right = new Node(6);\n        root2.left = new Node(2);\n        root2.left.left = new Node(3);\n        root2.left.right = new Node(5);\n\n        Node root3 = null;\n\n        inorder(root1);\n        System.out.println();\n        inorder(root2);\n        System.out.println();\n        inorder(root3);\n    }\n\n    public static void inorder(Node root) {\n        if (root == null) return;\n        inorder(root.left);\n        System.out.print(root.val + \" \");\n        inorder(root.right);\n    }\n}\n\nclass Node {\n    int val;\n    Node left, right;\n\n    public Node(int val) {\n        this.val = val;\n    }\n}\n```",
  "95": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n = 3;\n        System.out.println(numUniqueBTs(n));\n        \n        n = 1;\n        System.out.println(numUniqueBTs(n));\n        \n        n = 2;\n        System.out.println(numUniqueBTs(n));\n    }\n\n    public static int numUniqueBTs(int n) {\n        if (n == 0) return 1;\n        int res = 0;\n        for (int i = 0; i <= n; i++) {\n            res += helper(i, n - 1);\n        }\n        return res;\n    }\n\n    public static long helper(int left, int right) {\n        if (left == 0 && right == 0) return 1;\n        if (left > right) return 0;\n        long res = 0;\n        for (int i = Math.min(left, right); i >= 1; i--) {\n            res += helper(i - 1, left - i);\n            res += helper(i - 1, right - i);\n        }\n        return res;\n    }\n}",
  "96": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n = 3;\n        System.out.println(numTrees(n));\n        \n        n = 2;\n        System.out.println(numTrees(n));\n\n        n = 4;\n        System.out.println(numTrees(n));\n    }\n\n    public static int numTrees(int n) {\n        int[] G = new int[n + 1];\n        G[0] = G[1] = 1;\n\n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j <= i; j++) {\n                G[i] += G[j - 1] * G[i - j];\n            }\n        }\n\n        return G[n];\n    }\n}\n```",
  "98": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(2);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(3);\n\n        System.out.println(\"Case 1: \" + isValidBST(root1)); // true\n\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(4);\n        root2.right = new TreeNode(7);\n\n        System.out.println(\"Case 2: \" + isValidBST(root2)); // false\n\n        TreeNode root3 = new TreeNode(10);\n        root3.left = new TreeNode(9);\n        root3.right = new TreeNode(11);\n\n        System.out.println(\"Case 3: \" + isValidBST(root3)); // true\n    }\n}\n```",
  "97": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isInterleave(\"aabcc\", \"dbbdc\", \"aadbbcbc\")); // true\n        System.out.println(isInterleaving(\"a\", \"b\", \"aa\")); // false\n        System.out.println(isInterleaving(\"\", \"\", \"\")); // true\n    }\n\n    public static boolean isInterleaving(String s1, String s2, String s3) {\n        if (s1.length() + s2.length() != s3.length()) return false;\n\n        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];\n        dp[0][0] = true;\n        for (int i = 1; i <= s1.length(); i++) {\n            dp[i][0] = dp[i - 1][0] && s1.charAt(i - 1) == s3.charAt(i - 1);\n        }\n        for (int j = 1; j <= s2.length(); j++) {\n            dp[0][j] = dp[0][j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n        }\n\n        for (int i = 1; i <= s1.length(); i++) {\n            for (int j = 1; j <= s2.length(); j++) {\n                dp[i][j] = (dp[i - 1][j] && s1.charAt(i - 1) == s3.charAt(i + j - 1)) ||\n                        (dp[i][j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1));\n            }\n        }\n\n        return dp[s1.length()][s2.length()];\n    }\n}",
  "100": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(sameTree(new TreeNode(1), new TreeNode(1))); // Expected: true\n        System.out.println(sameTree(new TreeNode(1), new TreeNode(2))); // Expected: false\n        System.out.println(sameTree(null, null)); // Expected: true\n    }\n\n    public static boolean sameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        if (p.val != q.val) {\n            return false;\n        }\n        return sameTree(p.left, q.left) && sameTree(p.right, q.right);\n    }\n\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "99": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(4);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(7);\n        root1.left.left = new TreeNode(1);\n        root1.left.right = new TreeNode(3);\n\n        recoverBinarySearchTree(root1);\n\n        System.out.println(\"Test case 1 passed\");\n\n        // Test case 2\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(7);\n        root2.left.left = new TreeNode(2);\n        root2.left.right = new TreeNode(4);\n\n        recoverBinarySearchTree(root2);\n\n        System.out.println(\"Test case 2 passed\");\n\n        // Test case 3\n        TreeNode root3 = null;\n\n        recoverBinarySearchTree(root3);\n\n        System.out.println(\"Test case 3 passed\");\n    }\n\n    public static void recoverBinarySearchTree(TreeNode root) {\n        if (root == null || root.left == null && root.right == null) return;\n        \n        TreeNode firstBadNode = null;\n        TreeNode secondBadNode = null;\n        \n        TreeNode curr = root;\n        Stack<TreeNode> stack = new Stack<>();\n        while (!stack.isEmpty() || curr != null) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            if (curr.val > 2 * firstBadNode == null ? Integer.MIN_VALUE : firstBadNode.val \n                    || curr.val < secondBadNode == null ? Integer.MAX_VALUE : secondBadNode.val) {\n                secondBadNode = firstBadNode;\n                firstBadNode = curr;\n            }\n            curr = curr.right;\n        }\n        \n        // Swap the two bad nodes\n        int temp = firstBadNode.val;\n        firstBadNode.val = secondBadNode.val;\n        secondBadNode.val = temp;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n}\n```",
  "101": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(2);\n        root1.left.left = new TreeNode(3);\n        root1.left.right = new TreeNode(4);\n        root1.right.left = new TreeNode(4);\n        root1.right.right = new TreeNode(3);\n\n        System.out.println(isSymmetric(root1));  // true\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n\n        System.out.println(isSymmetric(root2));  // false\n\n        TreeNode root3 = null;\n\n        System.out.println(isSymmetric(root3));  // true\n    }\n\n    public static boolean isSymmetric(TreeNode root) {\n        return isMirror(root, root);\n    }\n\n    public static boolean isMirror(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) return true;\n        if (t1 == null || t2 == null) return false;\n        return (t1.val == t2.val) &&\n                isMirror(t1.right, t2.left) &&\n                isMirror(t1.left, t2.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n```",
  "102": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List<Integer> levelList = new ArrayList<>();\n\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                levelList.add(node.val);\n\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n\n            result.add(0, new ArrayList<>(levelList));\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(9);\n        root1.right = new TreeNode(20);\n        root1.right.left = new TreeNode(15);\n        root1.right.right = new TreeNode(7);\n        System.out.println(solution.levelOrderBottom(root1));\n\n        // Test case 2\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n        System.out.println(solution.levelOrderBottom(root2));\n\n        // Test case 3\n        TreeNode root3 = null;\n        System.out.println(solution.levelOrderBottom(root3));\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "103": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(9);\n        root1.right = new TreeNode(20);\n        root1.right.left = new TreeNode(15);\n        root1.right.right = new TreeNode(7);\n\n        zigzagLevelOrder(root1);\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(4);\n        root2.right = new TreeNode(5);\n        root2.right.left = new TreeNode(6);\n\n        zigzagLevelOrder(root2);\n\n        TreeNode root3 = null;\n\n        zigzagLevelOrder(root3);\n    }\n\n    public static List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList<>();\n        }\n        List<List<Integer>> result = new ArrayList<>();\n        boolean isLeftToRight = true;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List<Integer> levelList = new ArrayList<>();\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                if (isLeftToRight) {\n                    levelList.add(node.val);\n                } else {\n                    levelList.add(0, node.val);\n                }\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            result.add(levelList);\n            isLeftToRight = !isLeftToRight;\n        }\n        return result;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "104": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(5);\n\n        System.out.println(\"Max depth of tree 1: \" + maxDepth(root1));\n\n        TreeNode root2 = new TreeNode(0);\n        root2.left = new TreeNode(-1);\n        root2.right = new TreeNode(null);\n\n        System.out.println(\"Max depth of tree 2: \" + maxDepth(root2));\n\n        TreeNode root3 = null;\n\n        System.out.println(\"Max depth of tree 3: \" + maxDepth(root3));\n    }\n\n    public static int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        else return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n}\n```",
  "105": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test case 1:\n        int[] preorder = {3,9,20,15,7};\n        int[] inorder = {9,15,7,20,3};\n        TreeNode root1 = new Solution().buildTree(preorder, inorder);\n        System.out.println(\"Test case 1: \");\n        printInOrder(root1);\n\n        // Test case 2:\n        preorder = new int[]{1,2};\n        inorder = new int[]{2,1};\n        TreeNode root2 = new Solution().buildTree(preorder, inorder);\n        System.out.println(\"\\nTest case 2: \");\n        printInOrder(root2);\n\n        // Test case 3:\n        preorder = new int[]{1,2,4,5,3,6,7};\n        inorder = new int[]{4,2,5,1,3,6,7};\n        TreeNode root3 = new Solution().buildTree(preorder, inorder);\n        System.out.println(\"\\nTest case 3: \");\n        printInOrder(root3);\n    }\n\n    public static void printInOrder(TreeNode node) {\n        if (node == null) return;\n        printInOrder(node.left);\n        System.out.print(node.val + \" \");\n        printInOrder(node.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n    TreeNode(int x, TreeNode y, TreeNode z) {\n        val = x; left = y; right = z;\n    }\n}\n```",
  "106": "```\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if (inorder == null || postorder == null) {\n            return null;\n        }\n        \n        TreeNode root = new TreeNode(postorder[postorder.length - 1]);\n        int index = find(inorder, postorder[postorder.length - 1]);\n        root.right = buildTree(new int[index], new int[index - 1]).right;\n        root.left = buildTree(Arrays.copyOfRange(inorder, index + 1, inorder.length), \n                Arrays.copyOfRange(postorder, 0, postorder.length - index - 1));\n        \n        return root;\n    }\n    \n    private int find(int[] inorder, int target) {\n        for (int i = 0; i < inorder.length; i++) {\n            if (inorder[i] == target) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] inorder1 = {9,3,15,20,7};\n        int[] postorder1 = {9,15,7,20,3};\n        TreeNode root1 = solution.buildTree(inorder1, postorder1);\n        // PreOrder traversal of constructed tree\n        printTree(root1);\n\n        \n        int[] inorder2 = {5,8,6,14,3};\n        int[] postorder2 = {3,14,6,8,5};\n        TreeNode root2 = solution.buildTree(inorder2, postorder2);\n        // PreOrder traversal of constructed tree\n        printTree(root2);\n\n        \n        int[] inorder3 = {};\n        int[] postorder3 = {};\n        TreeNode root3 = solution.buildTree(inorder3, postorder3);\n        // PreOrder traversal of constructed tree\n        printTree(root3);\n    }\n\n    public static void printTree(TreeNode node) {\n        if (node != null) {\n            System.out.print(node.val + \" \");\n            printTree(node.left);\n            printTree(node.right);\n        }\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "108": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {2,1};\n        TreeNode root1 = sortedArrayToBST(nums1);\n        System.out.println(\"Test case 1:\");\n        printTree(root1);\n\n        int[] nums2 = {-10,-3,0,5,9};\n        TreeNode root2 = sortedArrayToBST(nums2);\n        System.out.println(\"\\nTest case 2:\");\n        printTree(root2);\n\n        int[] nums3 = {1,3};\n        TreeNode root3 = sortedArrayToBST(nums3);\n        System.out.println(\"\\nTest case 3:\");\n        printTree(root3);\n    }\n\n    public static TreeNode sortedArrayToBST(int[] nums) {\n        if (nums == null || nums.length == 0) return null;\n\n        int start = 0, end = nums.length - 1;\n        return helper(nums, start, end);\n    }\n\n    public static TreeNode helper(int[] nums, int start, int end) {\n        if (start > end) return null;\n\n        int mid = (start + end) / 2;\n        TreeNode node = new TreeNode(nums[mid]);\n        node.left = helper(nums, start, mid - 1);\n        node.right = helper(nums, mid + 1, end);\n\n        return node;\n    }\n\n    public static void printTree(TreeNode root) {\n        if (root == null) return;\n\n        System.out.print(root.val + \" \");\n        printTree(root.left);\n        printTree(root.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n}\n```",
  "107": "```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // Test Case 1\n        TreeNode root = new TreeNode(3);\n        root.left = new TreeNode(9);\n        root.right = new TreeNode(20);\n        root.right.left = new TreeNode(15);\n        root.right.right = new TreeNode(7);\n\n        List<List<Integer>> result = levelOrderBottom(root);\n        System.out.println(result);\n\n        // Test Case 2\n        root = null;\n        result = levelOrderBottom(root);\n        System.out.println(result);\n\n        // Test Case 3\n        root = new TreeNode(1);\n        root.right = new TreeNode(2);\n\n        result = levelOrderBottom(root);\n        System.out.println(result);\n    }\n\n    public static List<List<Integer>> levelOrderBottom(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List<Integer> levelList = new ArrayList<>();\n\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                levelList.add(node.val);\n\n                if (node.left != null) queue.add(node.left);\n                if (node.right != null) queue.add(node.right);\n            }\n\n            result.add(0, new ArrayList<>(levelList));\n        }\n\n        return result;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) {\n        val = x;\n    }\n}\n```",
  "110": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(9);\n        root1.right = new TreeNode(20);\n        root1.right.left = new TreeNode(15);\n        root1.right.right = new TreeNode(7);\n\n        System.out.println(isBalanced(root1)); // Expected: true\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n        root2.left.left = new TreeNode(4);\n        root2.left.right = new TreeNode(5);\n\n        System.out.println(isBalanced(root2)); // Expected: false\n\n        TreeNode root3 = null;\n\n        System.out.println(isBalanced(root3)); // Expected: true\n    }\n\n    public static boolean isBalanced(TreeNode root) {\n        return check(root) != -1;\n    }\n\n    public static int check(TreeNode node) {\n        if (node == null)\n            return 0;\n\n        int left = check(node.left);\n        if (left == -1)\n            return -1;\n\n        int right = check(node.right);\n        if (right == -1)\n            return -1;\n\n        if Math.abs(left - right) > 1\n            return -1;\n\n        return Math.max(left, right) + 1;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n}\n```",
  "109": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head.next.next.next.next = new ListNode(5);\n\n        TreeNode root = sortedListToBST(head);\n\n        printTree(root);\n\n        System.out.println();\n\n        head = new ListNode(-10);\n        head.next = new ListNode(-3);\n        head.next.next = new ListNode(0);\n        head.next.next.next = new ListNode(2);\n        head.next.next.next.next = new ListNode(5);\n        head.next.next.next.next.next = new ListNode(7);\n\n        root = sortedListToBST(head);\n\n        printTree(root);\n\n        System.out.println();\n\n        head = new ListNode(1);\n        head.next = new ListNode(3);\n        head.next.next = new ListNode(4);\n        head.next.next.next = new ListNode(5);\n        head.next.next.next.next = new ListNode(6);\n\n        root = sortedListToBST(head);\n\n        printTree(root);\n    }\n\n    public static TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n\n        int len = 0;\n        ListNode temp = head;\n        while (temp != null) {\n            len++;\n            temp = temp.next;\n        }\n\n        return sortedListToBST(head, len);\n    }\n\n    public static TreeNode sortedListToBST(ListNode head, int n) {\n        if (n <= 0) return null;\n\n        int left = (n + 1) / 2;\n\n        ListNode mid = getMid(head, left);\n\n        TreeNode root = new TreeNode(mid.val);\n\n        root.left = sortedListToBST(head, left);\n        root.right = sortedListToBST(mid.next, n - left);\n\n        return root;\n    }\n\n    public static ListNode getMid(ListNode head, int len) {\n        for (int i = 0; i < len - 1; i++) {\n            head = head.next;\n        }\n        return head;\n    }\n\n    public static void printTree(TreeNode node) {\n        if (node == null) return;\n\n        System.out.println(node.val);\n\n        printTree(node.left);\n        printTree(node.right);\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n}\n```",
  "111": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(9);\n        root1.right = new TreeNode(20);\n        root1.right.left = new TreeNode(15);\n        root1.right.right = new TreeNode(7);\n\n        System.out.println(\"Test case 1: \" + minDepth(root1)); // Output: 2\n\n        TreeNode root2 = new TreeNode(1);\n        root2.right = new TreeNode(2);\n\n        System.out.println(\"Test case 2: \" + minDepth(root2)); // Output: 2\n\n        TreeNode root3 = new TreeNode(0);\n\n        System.out.println(\"Test case 3: \" + minDepth(root3)); // Output: 1\n    }\n\n    public static int minDepth(TreeNode root) {\n        if (root == null) return 0;\n\n        int leftDepth = root.left != null ? minDepth(root.left) : Integer.MAX_VALUE;\n        int rightDepth = root.right != null ? minDepth(root.right) : Integer.MAX_VALUE;\n\n        return Math.min(leftDepth, rightDepth) + 1;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}",
  "112": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(4);\n        root1.right = new TreeNode(8);\n        root1.left.left = new TreeNode(11);\n        root1.left.left.left = new TreeNode(7);\n        root1.left.left.right = new TreeNode(2);\n        System.out.println(\"Test case 1: \" + hasPathSum(root1, 22));\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        System.out.println(\"Test case 2: \" + hasPathSum(root2, 1));\n\n        TreeNode root3 = null;\n        System.out.println(\"Test case 3: \" + hasPathSum(root3, 0));\n    }\n\n    public static boolean hasPathSum(TreeNode root, int sum) {\n        if (root == null) {\n            return false;\n        }\n        if (root.val == sum && root.left == null && root.right == null) {\n            return true;\n        }\n        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "113": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(4);\n        root1.right = new TreeNode(8);\n        root1.left.left = new TreeNode(11);\n        root1.left.left.left = new TreeNode(7);\n        root1.left.left.right = new TreeNode(2);\n        root1.right.right = new TreeNode(4);\n        root1.right.left = new TreeNode(13);\n        root1.right.right.left = new TreeNode(5);\n        root1.right.right.right = new TreeNode(1);\n\n        System.out.println(pathSum(root1, 22)); // Expected: 3\n        System.out.println(pathSum(new TreeNode(1), 5)); // Expected: 1\n        System.out.println(pathSum(null, 100)); // Expected: 0\n    }\n\n    public static int pathSum(TreeNode root, int sum) {\n        if (root == null) return 0;\n\n        int paths = 0;\n        for (int val : dfs(root, sum)) {\n            paths += val;\n        }\n        return paths;\n    }\n\n    public static List<Integer> dfs(TreeNode node, int sum) {\n        List<Integer> result = new ArrayList<>();\n        if (node == null) return result;\n\n        if (node.val == sum) {\n            result.add(1);\n            sum -= node.val;\n        }\n\n        for (int val : dfs(node.left, sum)) {\n            result.add(val);\n        }\n        for (int val : dfs(node.right, sum)) {\n            result.add(val);\n        }\n\n        return result;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "114": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root1 = new Node(1);\n        root1.left = new Node(2);\n        root1.right = new Node(5);\n        root1.left.left = new Node(3);\n        root1.left.right = new Node(4);\n\n        flatten(root1);\n\n        System.out.println();\n\n        Node root2 = new Node(1);\n        root2.right = new Node(2);\n        root2.right.right = new Node(5);\n\n        flatten(root2);\n\n        System.out.println();\n\n        Node root3 = null;\n\n        flatten(root3);\n    }\n\n    public static void flatten(Node head) {\n        // Your code here\n    }\n}\n\nclass Node {\n    int val;\n    Node left, right;\n\n    Node(int x) {\n        val = x;\n    }\n}\n```",
  "115": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numDistinct(\"rabbbit\", \"rabbit\")); // prints 3\n        System.out.println(numDistinct(\"banana\", \"an\")); // prints 6\n        System.out.println(numDistinct(\"abc\", \"ab\")); // prints 2\n    }\n\n    public static int numDistinct(String s, String t) {\n        int m = s.length();\n        int n = t.length();\n        int[][] dp = new int[m + 1][n + 1];\n        \n        for (int i = 0; i <= m; i++) {\n            dp[i][0] = 1;\n        }\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n}",
  "116": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root = new Node(1);\n        root.left = new Node(2);\n        root.right = new Node(3);\n        root.left.left = new Node(4);\n        root.left.right = new Node(5);\n        root.right.left = new Node(6);\n        root.right.right = new Node(7);\n\n        connect(root);\n\n        printNodes(root);\n\n        Node root2 = new Node(1);\n        root2.right = new Node(2);\n        root2.left = new Node(3);\n\n        connect(root2);\n\n        printNodes(root2);\n\n        Node root3 = new Node(1);\n        root3.left = new Node(2);\n        root3.right = new Node(3);\n\n        connect(root3);\n\n        printNodes(root3);\n    }\n\n    public static void connect(Node root) {\n        if (root == null || root.left == null && root.right == null) {\n            return;\n        }\n\n        Node leftmost = root;\n        while (leftmost != null) {\n            Node current = leftmost;\n            while (current != null) {\n                current.left.next = current.right;\n                if (current.right.next != null) {\n                    current.right.next = current.left.next;\n                }\n                current = current.next;\n            }\n            leftmost = leftmost.left;\n        }\n    }\n\n    public static void printNodes(Node root) {\n        while (root != null) {\n            Node current = root;\n            while (current != null) {\n                System.out.print(current.val + \" \");\n                current = current.next;\n            }\n            System.out.println();\n            root = root.left;\n        }\n    }\n}\n\nclass Node {\n    int val;\n    Node left, right, next;\n\n    public Node(int val) {\n        this.val = val;\n    }\n}\n```",
  "118": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] result1 = generate(5);\n        for (int i = 0; i < result1.length; i++) {\n            for (int j = 0; j <= i; j++) {\n                System.out.print(result1[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        int[][] result2 = generate(3);\n        for (int i = 0; i < result2.length; i++) {\n            for (int j = 0; j <= i; j++) {\n                System.out.print(result2[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        int[][] result3 = generate(10);\n        for (int i = 0; i < result3.length; i++) {\n            for (int j = 0; j <= i; j++) {\n                System.out.print(result3[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static int[][] generate(int numRows) {\n        int[][] result = new int[numRows][];\n        for (int i = 0; i < numRows; i++) {\n            result[i] = new int[i + 1];\n            if (i == 0) {\n                result[i][0] = 1;\n            } else if (i == 1) {\n                result[i][0] = 1;\n                result[i][1] = 1;\n            } else {\n                for (int j = 0; j <= i; j++) {\n                    if (j == 0 || j == i) {\n                        result[i][j] = 1;\n                    } else {\n                        result[i][j] = result[i - 1][j - 1] + result[i - 1][j];\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}",
  "117": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Node node = new Node(1);\n        node.left = new Node(2);\n        node.right = new Node(3);\n        node.left.left = new Node(4);\n        node.left.right = new Node(5);\n        node.right.left = new Node(6);\n        node.right.right = new Node(7);\n\n        connect(node);\n\n        printNode(node);\n\n        System.out.println();\n\n        node = new Node(1);\n        node.right = new Node(2);\n\n        connect(node);\n\n        printNode(node);\n\n        System.out.println();\n\n        node = new Node(1);\n        node.left = new Node(2);\n        node.right = new Node(3);\n        node.left.left = new Node(4);\n        node.left.right = new Node(5);\n\n        connect(node);\n\n        printNode(node);\n    }\n\n    public static void connect(Node root) {\n        if (root == null || root.left == null && root.right == null) {\n            return;\n        }\n        Node current = root;\n        while (current != null) {\n            Node next = null;\n            while (current != null) {\n                if (current.left != null) {\n                    if (next == null) {\n                        next = current.left;\n                    } else {\n                        next.next = current.left;\n                        next = next.next;\n                    }\n                }\n                if (current.right != null) {\n                    if (next == null) {\n                        next = current.right;\n                    } else {\n                        next.next = current.right;\n                        next = next.next;\n                    }\n                }\n                current = current.next;\n            }\n            current = root.next;\n        }\n    }\n\n    public static void printNode(Node node) {\n        while (node != null) {\n            System.out.print(node.val + \" \");\n            node = node.next;\n        }\n        System.out.println();\n    }\n}\n\nclass Node {\n    int val;\n    Node left;\n    Node right;\n    Node next;\n\n    public Node(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n        this.next = null;\n    }\n}\n```",
  "119": "```\npublic class Main {\n    public static void main(String[] args) {\n        getRow(1).forEach(System.out::print);\n        System.out.println();\n        \n        getRow(3).forEach(System.out::print);\n        System.out.println();\n        \n        getRow(5).forEach(System.out::print);\n        System.out.println();\n    }\n    \n    public static List<Integer> getRow(int rowIndex) {\n        if (rowIndex == 0) {\n            return Arrays.asList(1);\n        }\n        \n        List<Integer> row = new ArrayList<>();\n        row.add(1);\n        \n        for (int i = 1; i < rowIndex; i++) {\n            List<Integer> prevRow = getRow(i);\n            row.clear();\n            row.add(1);\n            for (int j = 1; j <= i; j++) {\n                int val = prevRow.get(j - 1) + prevRow.get(j);\n                row.add(val);\n            }\n            row.add(1);\n        }\n        \n        row.add(1);\n        return row;\n    }\n}",
  "120": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input1 = {{2}, {3}, {4}};\n        System.out.println(\"Test case 1: \" + triangle(new int[][]{input1[0], input1[1], input1[2]}));\n        \n        int[][] input2 = {{5, 1, 5}, {1, 5, 1}, {5, 1, 5}};\n        System.out.println(\"Test case 2: \" + triangle(new int[][]{input2[0], input2[1], input2[2]}));\n        \n        int[][] input3 = {{-10, -20}, {-30, -40}};\n        System.out.println(\"Test case 3: \" + triangle(new int[][]{input3[0], input3[1]}));\n    }\n\n    public static int triangle(int[][] A) {\n        if (A.length == 0) return 0;\n        int[] dp = new int[A.length];\n        for (int i = 0; i < A.length; i++) {\n            int prev = 0;\n            for (int j = 0; j <= i; j++) {\n                dp[i] = Math.max(Math.max(dp[j], prev), A[i][j] + Math.min(prev, dp[j]));\n                prev = dp[j];\n            }\n        }\n        return dp[dp.length - 1];\n    }\n}\n```",
  "121": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] prices1 = {7,1,5,3,6,4};\n        System.out.println(\"Best time to buy and sell stock for \" + Arrays.toString(prices1) + \": \" + maxProfit(prices1));\n        \n        int[] prices2 = {1,2,3,4,5};\n        System.out.println(\"Best time to buy and sell stock for \" + Arrays.toString(prices2) + \": \" + maxProfit(prices2));\n\n        int[] prices3 = {7,6,5,4,3,2,1};\n        System.out.println(\"Best time to buy and sell stock for \" + Arrays.toString(prices3) + \": \" + maxProfit(prices3));\n    }\n\n    public static int maxProfit(int[] prices) {\n        if (prices.length < 2) {\n            return 0;\n        }\n        \n        int minPrice = prices[0];\n        int maxProfit = 0;\n\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] < minPrice) {\n                minPrice = prices[i];\n            } else if (prices[i] - minPrice > maxProfit) {\n                maxProfit = prices[i] - minPrice;\n            }\n        }\n\n        return maxProfit;\n    }\n}",
  "122": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] prices1 = {7, 1, 5, 3, 6, 4};\n        System.out.println(\"Best Time to Buy and Sell Stock II for \" + Arrays.toString(prices1) + \": \" + maxProfit(prices1));\n\n        int[] prices2 = {1, 2, 3, 4, 5};\n        System.out.println(\"Best Time to Buy and Sell Stock II for \" + Arrays.toString(prices2) + \": \" + maxProfit(prices2));\n\n        int[] prices3 = {7, 6, 5, 4, 3, 2, 1};\n        System.out.println(\"Best Time to Buy and Sell Stock II for \" + Arrays.toString(prices3) + \": \" + maxProfit(prices3));\n    }\n\n    public static int maxProfit(int[] prices) {\n        int maxSoFar = 0;\n        int currMaxDiff = 0;\n\n        for (int i = 1; i < prices.length; i++) {\n            int diff = prices[i] - prices[i - 1];\n            if (diff > 0) {\n                currMaxDiff = diff;\n            } else {\n                currMaxDiff = 0;\n            }\n            maxSoFar += Math.max(0, currMaxDiff);\n        }\n\n        return maxSoFar;\n    }\n}",
  "123": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxProfit(new int[]{3,2,6,5,0,3})); // Expected output: 7\n        System.out.println(maxProfit(new int[]{1,2,3,4,5})); // Expected output: 4\n        System.out.println(maxProfit(new int[]{1})); // Expected output: 0\n    }\n\n    public static int maxProfit(int[] prices) {\n        if (prices.length < 2) {\n            return 0;\n        }\n        int[] buy = new int[prices.length];\n        int[] sell = new int[prices.length];\n        buy[0] = -prices[0];\n        for (int i = 1; i < prices.length; i++) {\n            buy[i] = Math.max(buy[i-1], sell[i-1] - prices[i]);\n            sell[i] = Math.max(sell[i-1], buy[i-1] + prices[i]);\n        }\n        return sell[sell.length-1];\n    }\n}",
  "124": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maxPathSum(new TreeNode(1, new TreeNode(4), new TreeNode(5)), 0));\n        System.out.println(maxPathSum(new TreeNode(-10, null, new TreeNode(9)), -1));\n        System.out.println(maxPathSum(new TreeNode(2, new TreeNode(1), new TreeNode(3)), 6));\n    }\n\n    public static int maxPathSum(TreeNode root, int sum) {\n        if (root == null) return sum;\n        if (root.left == null && root.right == null) return sum + root.val;\n        sum = Math.max(sum, maxPathSum(root.left, sum));\n        sum = Math.max(sum, maxPathSum(root.right, sum));\n        return Math.max(sum, root.val + maxPathSum(root.left, root.val) + maxPathSum(root.right, root.val));\n    }\n\n    class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        public TreeNode(int x) {\n            val = x;\n        }\n\n        public TreeNode(int x, TreeNode left, TreeNode right) {\n            val = x;\n            this.left = left;\n            this.right = right;\n        }\n    }\n}",
  "125": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isValidPalindrome(\"A man, a plan, a canal: Panama\")); // true\n        System.out.println(isValidPalindrome(\"race car\")); // true\n        System.out.println(isValidPalindrome(\"Not a palindrome\")); // false\n    }\n\n    public static boolean isValidPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n\n        while (left < right) {\n            if (!Character.toLowerCase(s.charAt(left)).equals(Character.toLowerCase(s.charAt(right)))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n}\n```",
  "127": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new WordLadder().ladderLength(\"hit\", \"cog\", new HashSet<String>()));\n        System.out.println(new WordLadder().ladderLength(\"start\", \"group\", new HashSet<String>()));\n        System.out.println(new WordLadder().ladderLength(\"a\", \"c\", new HashSet<String>()));\n    }\n}\n\nclass WordLadder {\n    public int ladderLength(String start, String end, Set<String> dict) {\n        // your code here\n    }\n}\n```",
  "126": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        // implement your solution here\n    }\n\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        \n        List<String> wordList = Arrays.asList(\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\");\n        \n        System.out.println(s.findLadders(\"hit\",\"cog\",wordList));\n        \n        wordList = Arrays.asList(\"start\",\"puzzles\",\"limits\",\"abc\",\"xyz\");\n        System.out.println(s.findLadders(\"hits\",\"cog\",wordList));\n        \n        wordList = Arrays.asList(\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\");\n        System.out.println(s.findLadders(\"a\",\"zz\",wordList));\n    }\n}",
  "128": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = { {9, 1, 4, 7, 3}, {0, 3, 7, 2, 5, 8, 4, 6, 1}, {100, 4, 200, 1, 3, 2}};\n        for (int[] array : arrays) {\n            System.out.println(\"Longest Consecutive Sequence: \" + longestConsecutive(array));\n        }\n    }\n\n    public static int longestConsecutive(int[] nums) {\n        if (nums.length == 0) return 0;\n        \n        int longestStreak = 0;\n        HashSet<Integer> set = new HashSet<>();\n        for (int num : nums) set.add(num);\n        \n        for (int num : set) {\n            if (!set.contains(num - 1)) { // Start of a sequence\n                int currentNum = num;\n                int currentStreak = 1;\n                \n                while (set.contains(currentNum + 1)) {\n                    currentNum += 1;\n                    currentStreak += 1;\n                }\n                \n                longestStreak = Math.max(longestStreak, currentStreak);\n            }\n        }\n        \n        return longestStreak;\n    }\n}",
  "129": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(5);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(7);\n        root.left.left = new TreeNode(3);\n        root.right.left = new TreeNode(6);\n        root.right.right = new TreeNode(2);\n        root.left.left.left = new TreeNode(2);\n\n        System.out.println(\"Test Case 1: \" + sumRootToLeaf(root) + \"\\n\");\n        root = null;\n        System.out.println(\"Test Case 2: \" + sumRootToLeaf(root) + \"\\n\");\n\n        root = new TreeNode(4);\n        root.left = new TreeNode(7);\n        root.right = new TreeNode(5);\n        root.left.left = new TreeNode(1);\n        root.left.right = new TreeNode(0);\n\n        System.out.println(\"Test Case 3: \" + sumRootToLeaf(root) + \"\\n\");\n    }\n\n    public static int sumRootToLeaf(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private static int dfs(TreeNode node, int total) {\n        if (node == null) {\n            return 0;\n        }\n        total = total * 2 + node.val;\n        if (node.left == null && node.right == null) {\n            return total;\n        }\n        return dfs(node.left, total) + dfs(node.right, total);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "131": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(partition(\"aab\")); // Output: [[a, a], [aa, b]]\n        System.out.println(partition(\"abc\")); // Output: [[a, b, c]]\n        System.out.println(partition(\"a\")); // Output: [[a]]\n    }\n\n    public static List<List<String>> partition(String s) {\n        List<List<String>> res = new ArrayList<>();\n        backtrack(res, new ArrayList<>(), s);\n        return res;\n    }\n\n    private static void backtrack(List<List<String>> res, List<String> path, String s) {\n        if (s.isEmpty()) {\n            res.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = 1; i <= s.length(); i++) {\n            if (isPalindrome(s.substring(0, i))) {\n                path.add(s.substring(0, i));\n                backtrack(res, path, s.substring(i));\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n\n    private static boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n```",
  "130": "```\npublic class Main {\n    public static void main(String[] args) {\n        char[][] board1 = {{'X', 'X', 'X', 'X'}, {'X', 'O', 'O', 'X'}, {'X', 'X', 'O', 'X'}, {'X', 'O', 'X', 'X'}};\n        solve(board1);\n\n        char[][] board2 = {{'O', 'O', 'O'}, {'O', 'O', 'O'}, {'O', 'O', 'O'}};\n        solve(board2);\n\n        char[][] board3 = {{'X', 'O', 'O', 'X'}, {'X', 'O', 'O', 'O'}, {'X', 'O', 'O', 'O'}, {'X', 'O', 'O', 'X'}};\n        solve(board3);\n    }\n\n    public static void solve(char[][] board) {\n        if (board == null || board.length == 0) return;\n\n        for (int i = 0; i < board.length; i++) {\n            dfs(board, i, 0);\n            dfs(board, i, board[0].length - 1);\n        }\n\n        for (int j = 0; j < board[0].length; j++) {\n            dfs(board, 0, j);\n            dfs(board, board.length - 1, j);\n        }\n\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                } else if (board[i][j] == 'X') {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                System.out.print(board[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static void dfs(char[][] board, int x, int y) {\n        if (x < 0 || x >= board.length || y < 0 || y >= board[0].length || board[x][y] != 'O') return;\n\n        board[x][y] = '#';\n        dfs(board, x - 1, y);\n        dfs(board, x + 1, y);\n        dfs(board, x, y - 1);\n        dfs(board, x, y + 1);\n    }\n}\n```",
  "132": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numOfPalindromicSubstrings(\"aab\"));\n        System.out.println(numOfPalindromicSubstrings(\"babad\"));\n        System.out.println(numOfPalindromicSubstrings(\"cbbd\"));\n    }\n\n    public static int numOfPalindromicSubstrings(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String substr = s.substring(i, j);\n                if (isPalindrome(substr)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public static boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}",
  "134": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canCompleteCircuit(new int[]{1,2,3,4,5}, new int[]{3,4,-1,1,2}) == 3 ? \"Test 1 Passed\" : \"Test 1 Failed\");\n        System.out.println(canCompleteCircuit(new int[]{2,3,4}, new int[]{3,1,-2}) == 0 ? \"Test 2 Passed\" : \"Test 2 Failed\");\n        System.out.println(canCompleteCircuit(new int[]{5}, new int[]{-2}) == 0 ? \"Test 3 Passed\" : \"Test 3 Failed\");\n    }\n\n    public static int canCompleteCircuit(int[] gas, int[] cost) {\n        int n = gas.length;\n        int total_gas = 0;\n        int current_gas = 0;\n        int start = 0;\n\n        for (int i = 0; i < n; i++) {\n            total_gas += gas[i] - cost[i];\n            current_gas += gas[i] - cost[i];\n\n            if (current_gas < 0) {\n                start = i + 1;\n                current_gas = 0;\n            }\n        }\n\n        return total_gas >= 0 ? start : -1;\n    }\n}\n```",
  "133": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node node1 = new Node(1);\n        Node node2 = new Node(2);\n        Node node3 = new Node(3);\n\n        node1.neighbors.add(node2);\n        node1.neighbors.add(node3);\n\n        node2.neighbors.add(node1);\n        node2.neighbors.add(new Node(4));\n\n        node3.neighbors.add(node1);\n\n        CloneGraph cloneGraph = new CloneGraph();\n        Node copiedNode1 = cloneGraph.cloneGraph(node1);\n\n        testCloneGraph(copiedNode1, 1, new Node[]{new Node(1), new Node(2), new Node(3)});\n        \n        Node node4 = new Node(4);\n        node2.neighbors.add(node4);\n\n        Node copiedNode2 = cloneGraph.cloneGraph(node2);\n\n        testCloneGraph(copiedNode2, 2, new Node[]{new Node(2), new Node(1), new Node(4)});\n\n        node3.neighbors.clear();\n\n        Node copiedNode3 = cloneGraph.cloneGraph(node3);\n\n        testCloneGraph(copiedNode3, 3, new Node[0]);\n    }\n\n    private static void testCloneGraph(Node node, int expectedValue, Node[] expectedNeighbors) {\n        System.out.println(\"Test Case for Node \" + expectedValue);\n        System.out.println(\"Expected Neighbors: \");\n        for (Node neighbor : expectedNeighbors) {\n            System.out.print(neighbor.val + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Actual Neighbors: \");\n        for (Node neighbor : node.neighbors) {\n            System.out.print(neighbor.val + \" \");\n        }\n        System.out.println();\n    }\n}\n\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n\n    public Node(int val) {\n        this.val = val;\n        this.neighbors = new ArrayList<>();\n    }\n}\n\nclass CloneGraph {\n    public Node cloneGraph(Node node) {\n        if (node == null) {\n            return null;\n        }\n\n        Map<Integer, Node> map = new HashMap<>();\n\n        Node newNode = new Node(node.val);\n        map.put(newNode.val, newNode);\n\n        clone(node, map);\n\n        return newNode;\n    }\n\n    private void clone(Node node, Map<Integer, Node> map) {\n        if (node == null) {\n            return;\n        }\n\n        Node newNode = map.getOrDefault(node.val, new Node(node.val));\n\n        map.put(newNode.val, newNode);\n\n        for (Node neighbor : node.neighbors) {\n            clone(neighbor, map);\n            newNode.neighbors.add(map.getOrDefault(neighbor.val, new Node(neighbor.val)));\n        }\n    }\n}\n```",
  "135": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1:\");\n        int[] ratings1 = {2,3,5,3,2};\n        System.out.println(candy(ratings1)); // expected output: 9\n\n        System.out.println(\"\\nTest case 2:\");\n        int[] ratings2 = {4,2,1,3};\n        System.out.println(candy(ratings2)); // expected output: 7\n\n        System.out.println(\"\\nTest case 3:\");\n        int[] ratings3 = {1,3,2,5,3,2,3};\n        System.out.println(candy(ratings3)); // expected output: 15\n    }\n\n    public static int candy(int[] ratings) {\n        int n = ratings.length;\n        int[] candies = new int[n];\n        Arrays.fill(candies, 1);\n\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1;\n            }\n        }\n\n        for (int i = n - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                if (candies[i] <= candies[i + 1]) {\n                    candies[i] = candies[i + 1] + 1;\n                }\n            }\n        }\n\n        int sum = 0;\n        for (int candy : candies) {\n            sum += candy;\n        }\n        return sum;\n    }\n}",
  "136": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] arr1 = {2, 2, 1};\n        System.out.println(\"Output for array 1: \" + singleNumber(arr1));\n\n        int[] arr2 = {4, 2, 7, 1, 3, 7, 1};\n        System.out.println(\"Output for array 2: \" + singleNumber(arr2));\n\n        int[] arr3 = {1, 1, 2, 2};\n        System.out.println(\"Output for array 3: \" + singleNumber(arr3));\n    }\n\n    public static int singleNumber(int[] nums) {\n        int result = 0;\n        for (int num : nums) {\n            result ^= num;\n        }\n        return result;\n    }\n}\n```",
  "137": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2,7,11,8,5,3};\n        System.out.println(\"Single Number II for \" + Arrays.toString(nums1) + \": \" + singleNumberII(nums1));\n        \n        int[] nums2 = {1,2,3};\n        System.out.println(\"Single Number II for \" + Arrays.toString(nums2) + \": \" + singleNumberII(nums2));\n        \n        int[] nums3 = {5,2,-1,2};\n        System.out.println(\"Single Number II for \" + Arrays.toString(nums3) + \": \" + singleNumberII(nums3));\n    }\n\n    public static int singleNumberII(int[] nums) {\n        int xorAll = 0;\n        for (int num : nums) {\n            xorAll ^= num;\n        }\n        \n        // Find the rightmost set bit\n        int rightmostSetBit = xorAll & -xorAll;\n        \n        int num1 = 0, num2 = 0;\n        for (int num : nums) {\n            if ((num & rightmostSetBit) != 0) {\n                num1 ^= num;\n            } else {\n                num2 ^= num;\n            }\n        }\n        \n        return num1;\n    }\n}\n```",
  "138": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node node1 = new Node(7);\n        Node node2 = new Node(13);\n        Node node3 = new Node(8);\n        Node node4 = new Node(4);\n\n        node1.next = node2;\n        node2.next = node3;\n        node3.next = node4;\n\n        node1.random = node3;\n        node2.random = node4;\n        node3.random = node1;\n        node4.random = node2;\n\n        Node copiedHead = copyRandomList(node1);\n\n        testNode(copiedHead, 7);\n        testNode(copiedHead.next, 13);\n        testNode(copiedHead.next.next, 8);\n\n    }\n\n    public static class Node {\n        int val;\n        Node next;\n        Node random;\n\n        public Node(int val) {\n            this.val = val;\n            this.next = null;\n            this.random = null;\n        }\n    }\n\n    public static Node copyRandomList(Node head) {\n        // Create a new node for each original node and map them together\n        Map<Node, Node> map = new HashMap<>();\n        Node current = head;\n\n        while (current != null) {\n            if (!map.containsKey(current)) {\n                Node newNode = new Node(current.val);\n                map.put(current, newNode);\n                current = current.next;\n            } else {\n                current = current.next;\n            }\n        }\n\n        // Copy the random pointer for each node\n        for (Map.Entry<Node, Node> entry : map.entrySet()) {\n            Node originalNode = entry.getKey();\n            Node copiedNode = entry.getValue();\n\n            if (originalNode.random != null) {\n                copiedNode.random = map.get(originalNode.random);\n            }\n        }\n\n        // Set the next pointer for each node\n        current = head;\n\n        while (current != null) {\n            Node copiedCurrent = map.get(current);\n\n            if (current.next != null) {\n                copiedCurrent.next = map.get(current.next);\n            } else {\n                copiedCurrent.next = null;\n            }\n            current = current.next;\n        }\n\n        return map.get(head);\n    }\n\n    public static void testNode(Node node, int expectedVal) {\n        if (node == null || node.val != expectedVal) {\n            System.out.println(\"Test failed for node with value \" + expectedVal);\n        } else {\n            System.out.println(\"Test passed for node with value \" + expectedVal);\n        }\n    }\n}",
  "139": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(wordBreak(\"leetcode\", new String[]{\"leet\", \"code\"}));\n        System.out.println(wordBreak(\"catsandog\", new String[]{\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}));\n        System.out.println(wordBreak(\"applepenapple\", new String[]{\"apple\", \"pen\"}));\n    }\n\n    public static boolean wordBreak(String s, String[] wordDict) {\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        for (int i = 1; i <= s.length(); i++) {\n            for (String word : wordDict) {\n                if (i >= word.length() && s.substring(i - word.length(), i).equals(word)) {\n                    dp[i] = dp[i] || dp[i - word.length()];\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}",
  "140": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(wordBreak(\"leetcode\", new String[]{\"leet\", \"code\"}));\n        System.out.println(wordBreak(\"applepenapple\", new String[]{\"apple\", \"pen\"}));\n        System.out.println(wordBreak(\"catsandog\", new String[]{\"cats\", \"dog\", \"sand\", \"and\", \"cat\"}));\n    }\n\n    public static List<String> wordBreak(String s, List<String> wordDict) {\n        // your logic here\n    }\n}\n```",
  "141": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode list1 = new ListNode(3);\n        list1.next = new ListNode(2);\n        list1.next.next = new ListNode(0);\n        list1.next.next.next = list1;\n        System.out.println(hasCycle(list1));  // Expected output: true\n\n        ListNode list2 = new ListNode(1);\n        list2.next = new ListNode(2);\n        System.out.println(hasCycle(list2));  // Expected output: false\n\n        ListNode list3 = new ListNode(1);\n        list3.next = list3;\n        System.out.println(hasCycle(list3));  // Expected output: true\n    }\n\n    public static boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int x) { val = x; }\n}\n```",
  "142": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode node1 = new ListNode(3);\n        node1.next = new ListNode(2);\n        node1.next.next = new ListNode(0);\n        node1.next.next.next = node1;\n        System.out.println(\"Test case 1: \" + detectCycle(node1).val);\n\n        ListNode node2 = new ListNode(1);\n        node2.next = new ListNode(2);\n        node2.next.next = node2;\n        System.out.println(\"Test case 2: \" + detectCycle(node2).val);\n\n        ListNode node3 = new ListNode(1);\n        System.out.println(\"Test case 3: \" + detectCycle(node3));\n    }\n\n    public static ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n        if (fast == null || fast.next == null) return null;\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```",
  "143": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        // Test case 1:\n        ListNode head = new ListNode(4);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(1);\n        head.next.next.next = new ListNode(3);\n        reorderList(head);\n\n        // Test case 2:\n        head = new ListNode(1);\n        head.next = new ListNode(5);\n        head.next.next = new ListNode(9);\n        head.next.next.next = new ListNode(20);\n        reorderList(head);\n\n        // Test case 3:\n        head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head.next.next.next.next = new ListNode(5);\n        reorderList(head);\n    }\n}\n```",
  "144": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(4);\n        root1.left.left = new TreeNode(3);\n\n        preorderTraversal(root1);\n\n        System.out.println();\n\n        TreeNode root2 = new TreeNode(1);\n        root2.right = new TreeNode(2);\n\n        preorderTraversal(root2);\n\n        System.out.println();\n\n        TreeNode root3 = null;\n\n        preorderTraversal(root3);\n    }\n\n    public static void preorderTraversal(TreeNode root) {\n        if (root == null) return;\n        System.out.print(root.val + \" \");\n        preorderTraversal(root.left);\n        preorderTraversal(root.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "145": "```\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n        \n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode curr = root;\n        while (!stack.isEmpty() || curr != null) {\n            if (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            } else {\n                TreeNode temp = stack.peek();\n                if (temp.right != null && curr != temp.right) {\n                    curr = temp.right;\n                } else {\n                    result.add(stack.pop().val);\n                    curr = temp;\n                }\n            }\n        }\n        \n        return result;\n    }\n\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1:\n        TreeNode root1 = new TreeNode(1);\n        root1.right = new TreeNode(2);\n        root1.left = new TreeNode(3);\n        System.out.println(\"Postorder Traversal for test case 1: \" + solution.postorderTraversal(root1));\n        \n        // Test Case 2:\n        TreeNode root2 = new TreeNode(5);\n        root2.right = new TreeNode(6);\n        root2.left = new TreeNode(7);\n        root2.left.left = new TreeNode(8);\n        System.out.println(\"Postorder Traversal for test case 2: \" + solution.postorderTraversal(root2));\n        \n        // Test Case 3:\n        TreeNode root3 = null;\n        System.out.println(\"Postorder Traversal for test case 3: \" + solution.postorderTraversal(root3));\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}",
  "146": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        LRUCache cache = new LRUCache(2);\n\n        System.out.println(cache.get(1)); // returns 1\n        System.out.println(cache.put(1, 1));\n        System.out.println(cache.get(1)); // returns 1\n        System.out.println(cache.put(2, 2));\n        System.out.println(cache.get(1)); // returns 1\n        System.out.println(cache.get(3)); // returns -1 (not found)\n        System.out.println(cache.put(4, 4));\n        System.out.println(cache.get(2)); // returns 2\n        System.out.println(cache.get(1)); // returns 1\n        System.out.println(cache.get(3)); // returns -1 (not found)\n        System.out.println(cache.get(4)); // returns 4\n\n    }\n}\n\nclass LRUCache {\n    private int capacity;\n    private Node head, tail;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.head = new Node(0, 0);\n        this.tail = new Node(0, 0);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        Node node = nodes.getOrDefault(key, null);\n        if (node == null) return -1;\n\n        remove(node);\n\n        add(node);\n\n        return node.val;\n    }\n\n    public void put(int key, int value) {\n        Node node = nodes.getOrDefault(key, null);\n        if (node != null) {\n            node.val = value;\n            return;\n        }\n\n        node = new Node(key, value);\n        if (nodes.size() >= capacity) {\n            nodes.remove(head.prev.key);\n            remove(head.prev);\n        }\n\n        add(node);\n\n        nodes.put(key, node);\n    }\n\n    private static class Node {\n        int key;\n        int val;\n        Node prev, next;\n\n        Node(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    private HashMap<Integer, Node> nodes = new HashMap<>();\n}\n\n```",
  "147": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test case 1:\n        ListNode head = new ListNode(4);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(2);\n        head.next.next.next = new ListNode(3);\n        head.next.next.next.next = new ListNode(1);\n        insertionSortList(head);\n        System.out.println(\"Test case 1: \" + printList(head));\n\n        // Test case 2:\n        head = new ListNode(5);\n        head.next = new ListNode(4);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(2);\n        head.next.next.next.next = new ListNode(1);\n        insertionSortList(head);\n        System.out.println(\"Test case 2: \" + printList(head));\n\n        // Test case 3:\n        head = new ListNode(20);\n        head.next = new ListNode(18);\n        head.next.next = new ListNode(16);\n        head.next.next.next = new ListNode(15);\n        head.next.next.next.next = new ListNode(14);\n        head.next.next.next.next.next = new ListNode(12);\n        head.next.next.next.next.next.next = new ListNode(10);\n        insertionSortList(head);\n        System.out.println(\"Test case 3: \" + printList(head));\n    }\n\n    public static void insertionSortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return;\n        }\n        \n        ListNode current = head;\n        while (current != null && current.next != null) {\n            ListNode nextNode = current.next;\n            if (Integer.compare(current.val, nextNode.val) > 0) {\n                int val = current.val;\n                current.val = nextNode.val;\n                nextNode.val = val;\n                while (nextNode.next != null && Integer.compare(nextNode.val, nextNode.next.val) < 0) {\n                    ListNode temp = nextNode.next;\n                    nextNode.next = temp.next;\n                    temp.next = nextNode;\n                    nextNode = temp;\n                }\n            } else {\n                current = current.next;\n            }\n        }\n    }\n\n    public static String printList(ListNode head) {\n        StringBuilder sb = new StringBuilder();\n        while (head != null) {\n            sb.append(head.val).append(\" \");\n            head = head.next;\n        }\n        return sb.toString();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n```",
  "148": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(4);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(1);\n        new MergeSort().sort(head1);\n\n        System.out.println(\"Test case 1: \");\n        printList(head1);\n\n        ListNode head2 = new ListNode(-1);\n        head2.next = new ListNode(5);\n        head2.next.next = new ListNode(3);\n        head2.next.next.next = new ListNode(4);\n        new MergeSort().sort(head2);\n\n        System.out.println(\"Test case 2: \");\n        printList(head2);\n\n        ListNode head3 = new ListNode(20);\n        head3.next = new ListNode(1);\n        head3.next.next = new ListNode(15);\n        head3.next.next.next = new ListNode(10);\n        head3.next.next.next.next = new ListNode(5);\n        new MergeSort().sort(head3);\n\n        System.out.println(\"Test case 3: \");\n        printList(head3);\n    }\n\n    public static void printList(ListNode node) {\n        while (node != null) {\n            System.out.print(node.val + \" \");\n            node = node.next;\n        }\n        System.out.println();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n```",
  "149": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] points1 = {{1,1},{2,2},{3,3}};\n        System.out.println(\"Max Points on Line for Test Case 1: \" + maxPoints(points1));\n        \n        int[][] points2 = {{1,1},{5,5},{5,2},{4,4}};\n        System.out.println(\"Max Points on Line for Test Case 2: \" + maxPoints(points2));\n        \n        int[][] points3 = {{0,0},{3,9},{10,20}};\n        System.out.println(\"Max Points on Line for Test Case 3: \" + maxPoints(points3));\n    }\n\n    public static int maxPoints(int[][] points) {\n        // Your code here\n    }\n}\n```",
  "151": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reverseWords(\"Hello World\")); // Output: \"World Hello\"\n        System.out.println(reverseWords(\"a good   example   of   space   comments\")); // Output: \"comments space of example good a\"\n        System.out.println(reverseWords(\"abc def ghi jkl mno pqr\")); // Output: \"pqr mno jkl ghi def abc\"\n    }\n\n    public static String reverseWords(String s) {\n        String[] words = s.split(\"\\\\s+\");\n        StringBuilder reversed = new StringBuilder();\n        for (int i = words.length - 1; i >= 0; i--) {\n            if (!words[i].isEmpty()) {\n                reversed.append(words[i]).append(\" \");\n            }\n        }\n        return reversed.toString().trim();\n    }\n}",
  "150": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(evaluate(\"3+2*\") == 5 ? \"Test case 1 passed\" : \"Test case 1 failed\");\n        System.out.println(evaluate(\"23+4/2\") == 6 ? \"Test case 2 passed\" : \"Test case 2 failed\");\n        System.out.println(evaluate(\"100-200/20\") == -3 ? \"Test case 3 passed\" : \"Test case 3 failed\");\n    }\n\n    public static int evaluate(String s) {\n        Stack<Integer> stack = new Stack<>();\n        for (String numOrOp : s.split(\"\")) {\n            if (!isOperator(numOrOp)) {\n                int num = Integer.parseInt(numOrOp);\n                while (!stack.isEmpty() && isOperator(stack.peek())) {\n                    int op2 = stack.pop();\n                    int op1 = stack.pop();\n                    int result = applyOp(op2, op1, num);\n                    stack.push(result);\n                }\n                stack.push(num);\n            } else if (numOrOp.equals(\"(\")) {\n                stack.push(numOrOp);\n            } else if (numOrOp.equals(\")\")) {\n                while (!stack.isEmpty() && !stack.peek().equals(\"(\")) {\n                    stack.pop();\n                }\n                stack.pop();\n            } else {\n                while (!stack.isEmpty() && isOperator(stack.peek())) {\n                    int op2 = stack.pop();\n                    int op1 = stack.pop();\n                    int result = applyOp(op2, op1, Integer.parseInt(numOrOp));\n                    stack.push(result);\n                }\n                stack.push(Integer.parseInt(numOrOp));\n            }\n        }\n        return stack.isEmpty() ? 0 : stack.peek();\n    }\n\n    public static boolean isOperator(String s) {\n        return \"+-*/\".indexOf(s) != -1;\n    }\n\n    public static int applyOp(int op, int op1, int op2) {\n        if (op == '+') return op1 + op2;\n        else if (op == '-') return op1 - op2;\n        else if (op == '*') return op1 * op2;\n        else return op1 / op2;\n    }\n}\n```",
  "152": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] array1 = {-2,0,-1};\n        System.out.println(\"Maximum Product Subarray of \" + Arrays.toString(array1) + \" is \" + maxProduct(array1));\n        \n        int[] array2 = [2,3,-2,4];\n        System.out.println(\"Maximum Product Subarray of \" + Arrays.toString(array2) + \" is \" + maxProduct(array2));\n\n        int[] array3 = [-4,-3,-2];\n        System.out.println(\"Maximum Product Subarray of \" + Arrays.toString(array3) + \" is \" + maxProduct(array3));\n    }\n\n    public static int maxProduct(int[] nums) {\n        if (nums.length == 0) return 0;\n        \n        int maxSoFar = nums[0];\n        int minSoFar = nums[0];\n        int result = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] < 0) {\n                int temp = maxSoFar;\n                maxSoFar = minSoFar;\n                minSoFar = temp;\n            }\n            maxSoFar = Math.max(nums[i], maxSoFar * nums[i]);\n            minSoFar = Math.min(nums[i], minSoFar * nums[i]);\n            result = Math.max(result, maxSoFar);\n        }\n        \n        return result;\n    }\n}\n```",
  "153": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findMin(new int[]{3, 4, 5, 1, 2})); // Expected output: 1\n        System.out.println(findMin(new int[]{4, 5, 6, 7, 0, 1, 2})); // Expected output: 0\n        System.out.println(findMin(new int[]{10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9})); // Expected output: 0\n    }\n\n    public static int findMin(int[] nums) {\n        int start = 0;\n        int end = nums.length - 1;\n\n        while (start < end) {\n            int mid = start + (end - start) / 2;\n\n            if (nums[mid] > nums[end]) {\n                start = mid + 1;\n            } else {\n                end = mid;\n            }\n        }\n\n        return nums[start];\n    }\n}",
  "154": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + findMin(new int[]{1,3,5})); // Expected output: 1\n        System.out.println(\"Test Case 2: \" + findMin(new int[]{2,2,2,0,1})); // Expected output: 0\n        System.out.println(\"Test Case 3: \" + findMin(new int[]{3,4,-9,2,5,32,7,8,10,15,19,26,29,31,38,41,43,46,49,51})); // Expected output: -9\n    }\n\n    public static int findMin(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] > nums[right]) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return nums[left];\n    }\n}\n```",
  "155": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        MinStack minStack = new MinStack();\n        minStack.push(0);\n        minStack.push(1);\n        minStack.push(0);\n\n        System.out.println(minStack.getMin());  // prints: 0\n        minStack.pop();\n\n        System.out.println(minStack.getMin());  // prints: 0\n\n        minStack.push(2);\n\n        System.out.println(minStack.getMin());  // prints: 0\n\n        minStack.push(3);\n\n        System.out.println(minStack.getMin());  // prints: 0\n\n        minStack.pop();\n        minStack.pop();\n\n        System.out.println(minStack.getMin());  // prints: 1\n    }\n}\n\nclass MinStack {\n\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n        if (minStack.isEmpty() || x <= getMin()) {\n            minStack.push(x);\n        }\n    }\n\n    public void pop() {\n        int x = stack.pop();\n        if (x == getMin()) {\n            minStack.pop();\n        }\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n}\n```",
  "156": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node node1 = new Node(1);\n        node1.left = new Node(2);\n        node1.right = new Node(3);\n        node1.left.left = new Node(4);\n        node1.left.right = new Node(5);\n\n        Node result1 = upsideDown(node1);\n        printTree(result1);\n\n        System.out.println();\n\n        Node node2 = new Node(0);\n        node2.left = new Node(8);\n        node2.right = new Node(1);\n        node2.left.left = new Node(4);\n        node2.left.right = new Node(7);\n        node2.right.left = new Node(3);\n        node2.right.right = new Node(6);\n\n        Node result2 = upsideDown(node2);\n        printTree(result2);\n\n        System.out.println();\n\n        Node node3 = new Node(1);\n        node3.left = new Node(0);\n        node3.right = new Node(1);\n\n        Node result3 = upsideDown(node3);\n        printTree(result3);\n    }\n\n    public static Node upsideDown(Node node) {\n        if (node == null || node.left == null) {\n            return node;\n        }\n        Node newRoot = node.left;\n        node.left = upsideDown(newRoot.right);\n        newRoot.right = upsideDown(node.right);\n        newRoot.left = node;\n        return newRoot;\n    }\n\n    public static void printTree(Node node) {\n        if (node == null) {\n            return;\n        }\n        System.out.println(\"In-order traversal of the upside down binary tree: \");\n        printInOrder(node);\n        System.out.println();\n    }\n\n    public static void printInOrder(Node node) {\n        if (node == null) {\n            return;\n        }\n        printInOrder(node.left);\n        System.out.print(node.val + \" \");\n        printInOrder(node.right);\n    }\n}\n\nclass Node {\n    int val;\n    Node left;\n    Node right;\n\n    public Node(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n```",
  "157": "```\npublic class Main {\n    public static void main(String[] args) {\n        Read4ReadN read = new Read4ReadN();\n        System.out.println(read.read4(\"abcde\", 5)); // prints \"abcde\"\n        System.out.println(read.read4(\"abcde\", 7)); // prints \"abcde\"\n        System.out.println(read.read4(\"abcde\", 9)); // prints \"abcde\"\n    }\n}\n\nclass Read4ReadN {\n    public String read4(String s, int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i += 4) {\n            if (i + 4 > s.length()) {\n                break;\n            }\n            sb.append(s.substring(i, i + 4));\n        }\n        return sb.toString();\n    }\n}\n```",
  "158": "```\npublic class Main {\n    public static void main(String[] args) {\n        Read4 read4 = new Read4();\n        System.out.println(readNCharacters(read4, 7));\n        System.out.println(readNCharacters(read4, 10));\n        System.out.println(readNCharacters(read4, 15));\n    }\n\n    private static String readNCharacters(Read4 read4, int n) {\n        char[] buffer = new char[4];\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            int count = read4.read(buffer);\n            while (count > 0) {\n                for (char c : buffer) {\n                    if (i < n && count-- > 0) {\n                        sb.append(c);\n                        i++;\n                    } else break;\n                }\n                buffer = new char[4];\n                count = read4.read(buffer);\n            }\n        }\n        return sb.toString();\n    }\n}\n\nclass Read4 {\n    public int read(char[] buf) {\n        // your code here\n        return 3; // example implementation, replace with actual logic\n    }\n}\n```",
  "159": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestSubstring(\"eceba\")); // expected output: \"ece\"\n        System.out.println(longestSubstring(\"aa\")); // expected output: \"a\"\n        System.out.println(longestSubstring(\"babad\")); // expected output: \"bab\"\n    }\n\n    public static String longestSubstring(String s) {\n        int maxLen = 0;\n        String res = \"\";\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String substring = s.substring(i, j);\n                if (hasAtMostTwoDistinctChars(substring) && substring.length() > maxLen) {\n                    maxLen = substring.length();\n                    res = substring;\n                }\n            }\n        }\n        return res;\n    }\n\n    public static boolean hasAtMostTwoDistinctChars(String s) {\n        int[] count = new int[256];\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (++count[c] > 2)\n                return false;\n        }\n        return true;\n    }\n}",
  "160": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        ListNode list1 = new ListNode(4);\n        list1.next = new ListNode(1);\n        list1.next.next = new ListNode(8);\n\n        ListNode list2 = new ListNode(5);\n        list2.next = list1; // 5 -> 4 -> 1 -> 8\n\n        ListNode intersection = getIntersectionNode(list1, list2);\n        System.out.println(\"Intersection: \" + (intersection == null ? \"null\" : intersection.val));\n\n        list1 = new ListNode(2);\n        list1.next = new ListNode(6);\n        list1.next.next = new ListNode(4);\n\n        list2 = new ListNode(1);\n        list2.next = list1; // 1 -> 2 -> 6 -> 4\n\n        intersection = getIntersectionNode(list1, list2);\n        System.out.println(\"Intersection: \" + (intersection == null ? \"null\" : intersection.val));\n\n        list1 = new ListNode(3);\n        list1.next = new ListNode(7);\n\n        list2 = new ListNode(1);\n        list2.next = new ListNode(9);\n        list2.next.next = new ListNode(3); // 1 -> 9 -> 3\n        list2.next.next.next = list1; // 1 -> 9 -> 3 -> 3\n\n        intersection = getIntersectionNode(list1, list2);\n        System.out.println(\"Intersection: \" + (intersection == null ? \"null\" : intersection.val));\n    }\n\n    public static ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n\n        int lenA = 0;\n        int lenB = 0;\n\n        ListNode A = headA;\n        while (A != null) {\n            lenA++;\n            A = A.next;\n        }\n\n        ListNode B = headB;\n        while (B != null) {\n            lenB++;\n            B = B.next;\n        }\n\n        if (lenA > lenB) {\n            for (int i = 0; i < lenA - lenB; i++) {\n                headA = headA.next;\n            }\n        } else if (lenB > lenA) {\n            for (int i = 0; i < lenB - lenA; i++) {\n                headB = headB.next;\n            }\n        }\n\n        while (headA != null && headB != null) {\n            if (headA == headB) {\n                return headA;\n            }\n            headA = headA.next;\n            headB = headB.next;\n        }\n\n        return null;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int x) { val = x; }\n}\n```",
  "161": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"hello\", \"holle\")); // true\n        System.out.println(canBeEqual(\"pale\", \"plea\")); // true\n        System.out.println(canBeEqual(\"apple\", \"aple\")); // false\n    }\n\n    public static boolean canBeEqual(String word1, String word2) {\n        int m = word1.length();\n        int n = word2.length();\n\n        if (Math.abs(m - n) > 1) {\n            return false;\n        }\n\n        int i = 0, j = 0;\n        while (i < m && j < n) {\n            if (word1.charAt(i) != word2.charAt(j)) {\n                if (m == n) {\n                    return false;\n                }\n                if (m > n) {\n                    i++;\n                } else {\n                    j++;\n                }\n            } else {\n                i++;\n                j++;\n            }\n        }\n\n        return true;\n    }\n}\n```",
  "162": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {1,2,3,1};\n        System.out.println(\"Test case 1: \" + findPeakElement(arr1));\n        \n        int[] arr2 = {1,2,1,3,5,6,4};\n        System.out.println(\"Test case 2: \" + findPeakElement(arr2));\n        \n        int[] arr3 = {0,1,0};\n        System.out.println(\"Test case 3: \" + findPeakElement(arr3));\n    }\n\n    public static int findPeakElement(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] > nums[mid + 1]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return nums[left];\n    }\n}",
  "163": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] intervals = {{0,1},{2,5}};\n        System.out.println(\"Missing Ranges: \" + findMissingRanges(intervals));\n        \n        int[][] intervals2 = {{0,3},{4,5}};\n        System.out.println(\"Missing Ranges: \" + findMissingRanges(intervals2));\n        \n        int[][] intervals3 = {{1,2}};\n        System.out.println(\"Missing Ranges: \" + findMissingRanges(intervals3));\n    }\n\n    public static List<String> findMissingRanges(int[][] intervals) {\n        List<String> result = new ArrayList<>();\n        if (intervals.length == 0) {\n            result.add(\"[]\");\n            return result;\n        }\n        \n        for (int i = 0; i < intervals.length - 1; i++) {\n            int start = Math.max(0, intervals[i][1]);\n            while (start <= intervals[i + 1][0]) {\n                result.add(start + \"->\" + start);\n                start++;\n            }\n            if (start > intervals[i][1]) {\n                result.add(start + \"->\" + intervals[i + 1][0] - 1);\n            }\n        }\n        \n        return result;\n    }\n}",
  "164": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        int[] nums = {3, 7, 73};\n        System.out.println(\"Maximum Gap: \" + maxGap(nums));\n        \n        System.out.println(\"\\nTest Case 2:\");\n        int[] nums2 = {1, 15, 6, 2, 4, 8];\n        System.out.println(\"Maximum Gap: \" + maxGap(nums2));\n        \n        System.out.println(\"\\nTest Case 3:\");\n        int[] nums3 = {0};\n        System.out.println(\"Maximum Gap: \" + maxGap(nums3));\n    }\n\n    public static int maxGap(int[] nums) {\n        if (nums.length < 2) return 0;\n        int min = Arrays.stream(nums).min().getAsInt();\n        int max = Arrays.stream(nums).max().getAsInt();\n\n        int buckets[][] = new int[(max - min + 1)][];\n\n        for (int i = 0; i <= max - min; i++) {\n            buckets[i] = new int[2];\n        }\n\n        for (int num : nums) {\n            int bucketIndex = num - min;\n            if (buckets[bucketIndex][0] == 0) {\n                buckets[bucketIndex][0] = num;\n                buckets[bucketIndex][1] = num;\n            } else {\n                buckets[bucketIndex][0] = Math.min(num, buckets[bucketIndex][0]);\n                buckets[bucketIndex][1] = Math.max(num, buckets[bucketIndex][1]);\n            }\n        }\n\n        int maxGap = 0;\n        for (int i = 0; i < buckets.length; i++) {\n            if (buckets[i][0] != 0) {\n                maxGap = Math.max(maxGap, buckets[i][1] - buckets[i][0]);\n            }\n        }\n\n        return maxGap;\n    }\n}",
  "165": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(compareVersion(\"1.0.3\", \"1.0.2\")); // Expected: 1\n        System.out.println(compareVersion(\"1.1\", \"1.0\")); // Expected: 1\n        System.out.println(compareVersion(\"0.0.4\", \"0.0.5\")); // Expected: -1\n    }\n\n    public static int compareVersion(String version1, String version2) {\n        String[] v1 = version1.split(\"\\\\.\");\n        String[] v2 = version2.split(\"\\\\.\");\n\n        int len1 = v1.length;\n        int len2 = v2.length;\n\n        for (int i = 0; i < Math.max(len1, len2); i++) {\n            int val1 = i < len1 ? Integer.parseInt(v1[i]) : 0;\n            int val2 = i < len2 ? Integer.parseInt(v2[i]) : 0;\n\n            if (val1 > val2) return 1;\n            else if (val1 < val2) return -1;\n        }\n\n        return 0;\n    }\n}\n```",
  "166": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(fractionToDecimal(1, 2)); // expected output: \"0.5\"\n        System.out.println(fractionToDecimal(2, 1)); // expected output: \"2\"\n        System.out.println(fractionToDecimal(4, 333)); // expected output: \"0.(012)\"\n    }\n\n    public static String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) return \"0\";\n        StringBuilder res = new StringBuilder();\n        res.append(numerator/denominator);\n        long n = Math.abs((long)numerator);\n        long d = Math.abs((long)denominator);\n        long decimal = n % d;\n        while(decimal > 0) {\n            res.append(\".\");\n            int temp = (int)(decimal*d); // temp = decimal * denominator\n            int pre = temp/d; // get the integer part of temp/d\n            if(pre == 0) break;\n            res.append(pre);\n            decimal = temp % d; // update decimal\n        }\n        return res.toString();\n    }\n}\n```",
  "167": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] pairs = {{-1,0}, {0,1,3},{-1,-2,3,-5,-8,-10,-100,200}};\n        for (int[] pair : pairs) {\n            int[] result = twoSumII(pair[0], pair[1]);\n            System.out.println(\"Input: \" + pair[0] + \", \" + pair[1] + \". Output: \" + result[0] + \", \" + result[1]);\n        }\n    }\n\n    public static int[] twoSumII(int target, int array[]) {\n        int left = 0;\n        int right = array.length - 1;\n\n        while (left < right) {\n            int sum = array[left] + array[right];\n            if (sum == target) {\n                return new int[]{array[left], array[right]};\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return new int[]{-1, -1};\n    }\n}\n```",
  "168": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(columnTitle(\"A\")); // \"A\"\n        System.out.println(columnTitle(\"AB\")); // \"Z\"\n        System.out.println(columnTitle(\"AZ\")); // \"ZZ\"\n    }\n\n    public static String columnTitle(int n) {\n        StringBuilder sb = new StringBuilder();\n        while (n > 0) {\n            n--;\n            sb.insert(0, (char) ('A' + n % 26));\n            n /= 26;\n        }\n        return sb.toString();\n    }\n}\n```",
  "169": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1:\");\n        int[] nums1 = {2,2,1,1,1,2,2};\n        System.out.println(\"Majority element: \" + majorityElement(nums1));\n\n        System.out.println(\"\\nTest case 2:\");\n        int[] nums2 = {0,1};\n        System.out.println(\"Majority element: \" + majorityElement(nums2));\n\n        System.out.println(\"\\nTest case 3:\");\n        int[] nums3 = {1};\n        System.out.println(\"Majority element: \" + majorityElement(nums3));\n    }\n\n    public static int majorityElement(int[] nums) {\n        int candidate = nums[0];\n        int count = 1;\n        \n        for (int num : nums) {\n            if (num == candidate) {\n                count++;\n            } else {\n                count--;\n                if (count == 0) {\n                    candidate = num;\n                    count = 1;\n                }\n            }\n        }\n        \n        return candidate;\n    }\n}\n```",
  "170": "```\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    Map<Integer, Integer> numToIndexMap = new HashMap<>();\n\n    public int[] twoSum(int[] numbers, int target) {\n        for (int i = 0; i < numbers.length; i++) {\n            int complement = target - numbers[i];\n            if (numToIndexMap.containsKey(complement)) {\n                return new int[]{complement, numbers[i]};\n            }\n            numToIndexMap.put(numbers[i], i);\n        }\n        throw new RuntimeException(\"No two sum solution\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] inputs = {\n            {0, -1, 10, 12, -9},\n            {-1, 3, 4, 5, 8, 14, 28},\n            {2, 7, 11, 15}\n        };\n        int[] targets = {1, 17, 13};\n        \n        for (int i = 0; i < inputs.length; i++) {\n            int[] result = solution.twoSum(inputs[i], targets[i]);\n            System.out.println(\"Input: \" + Arrays.toString(inputs[i]) + \", Target: \" + targets[i] + \", Output: \" + Arrays.toString(result));\n        }\n    }\n}",
  "171": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(columnNumber(\"A\")); // expected: 1\n        System.out.println(columnNumber(\"AB\")); // expected: 28\n        System.out.println(columnNumber(\"ZY\")); // expected: 701\n    }\n\n    public static int columnNumber(String s) {\n        int result = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            char c = s.charAt(i);\n            result = result * 26 + (c - 'A' + 1);\n        }\n        return result;\n    }\n}",
  "172": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(trailingZeroes(4)); // expected output: 1\n        System.out.println(trailingZeroes(5)); // expected output: 1\n        System.out.println(trailingZeroes(100)); // expected output: 24\n    }\n\n    public static int trailingZeroes(int n) {\n        int count = 0;\n        for (int i = 5; n / i >= 1; i *= 5) {\n            count += n / i;\n        }\n        return count;\n    }\n}\n```",
  "173": "```\npublic class Main {\n    public static void main(String[] args) {\n        BSTIterator iterator = new BSTIterator(new TreeNode(2, new TreeNode(1), new TreeNode(3)));\n        System.out.println(iterator.next()); // prints 1\n        System.out.println(iterator.next()); // prints 2\n        System.out.println(iterator.hasNext()); // prints false\n\n        iterator = new BSTIterator(new TreeNode(5, new TreeNode(3), new TreeNode(7)));\n        System.out.println(iterator.next()); // prints 3\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next()); // prints 5 then 7\n        }\n\n        iterator = new BSTIterator(new TreeNode(2));\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next()); // prints 2\n        }\n    }\n}\n\nclass BSTIterator {\n    private Stack<TreeNode> stack;\n\n    public BSTIterator(TreeNode root) {\n        stack = new Stack<>();\n        pushLeft(root);\n    }\n\n    public int next() {\n        TreeNode node = stack.pop();\n        if (node.right != null) {\n            pushLeft(node.right);\n        }\n        return node.val;\n    }\n\n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n\n    private void pushLeft(TreeNode node) {\n        while (node != null) {\n            stack.push(node);\n            node = node.left;\n        }\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n\n    public TreeNode(int val) {\n        this(val, null, null);\n    }\n}",
  "174": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] dungeon = new int[][]{{-2,-3,3},{-5,-10,1},{10,30,-5}};\n        System.out.println(\"Expected: 7\");\n        System.out.println(\"Actual: \" + new Solution().maximumUnits(new int[][]{dungeon}, 100));\n        \n        int[][] dungeon2 = new int[][]{{0,0,0},{8,0,0},{0,9,10}};\n        System.out.println(\"Expected: 34\");\n        System.out.println(\"Actual: \" + new Solution().maximumUnits(new int[][]{dungeon2}, 100));\n        \n        int[][] dungeon3 = new int[][]{{0,0},{0,-1}};\n        System.out.println(\"Expected: 6\");\n        System.out.println(\"Actual: \" + new Solution().maximumUnits(new int[][]{dungeon3}, 5));\n    }\n}\n\nclass Solution {\n    public int maximumUnits(int[][] boxSize, int truckSize) {\n        Arrays.sort(boxSize, (a, b) -> b[1] - a[1]);\n        int res = 0;\n        for (int[] unit : boxSize) {\n            if (truckSize >= unit[1]) {\n                res += unit[1];\n                truckSize -= unit[1];\n            } else {\n                res += truckSize;\n                break;\n            }\n        }\n        return res;\n    }\n}\n```",
  "175": "```\nimport java.sql.Connection;\nimport-java.sql.DriverManager;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Statement;\n\npublic class Main {\n    public static void main(String[] args) throws SQLException {\n        // Test Case 1:\n        String table1 = \"Table1\";\n        String table2 = \"Table2\";\n        String query = \"SELECT * FROM Table1 UNION SELECT * FROM Table2\";\n        test(query, table1, table2);\n\n        // Test Case 2:\n        table1 = \"Person\";\n        table2 = \"Contact\";\n        query = \"SELECT * FROM Person UNION SELECT * FROM Contact\";\n        test(query, table1, table2);\n\n        // Test Case 3:\n        table1 = \"Employee\";\n        table2 = \"Manager\";\n        query = \"SELECT * FROM Employee UNION SELECT * FROM Manager\";\n        test(query, table1, table2);\n    }\n\n    public static void test(String query, String table1, String table2) throws SQLException {\n        // Establish database connection\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/your_database\", \"username\", \"password\");\n\n        // Execute the query\n        Statement stmt = conn.createStatement();\n        ResultSet rs = stmt.executeQuery(query);\n\n        while (rs.next()) {\n            System.out.println(rs.getString(1) + \", \" + rs.getString(2) + \", \" + rs.getString(3));\n        }\n\n        // Close database connection\n        rs.close();\n        stmt.close();\n        conn.close();\n    }\n}",
  "176": "```\npublic class Main {\n    public static void main(String[] args) {\n        EmployeeSalaries es1 = new EmployeeSalaries(new String[]{\"John\", \"Paul\", \"George\", \"Ringo\"}, new int[]{100, 200, 300, 400});\n        System.out.println(\"Second Highest Salary: \" + secondHighestSalary(es1));\n\n        EmployeeSalaries es2 = new EmployeeSalaries(new String[]{\"Alice\", \"Bob\", \"Charlie\", \"David\"}, new int[]{500, 400, 600, 700});\n        System.out.println(\"Second Highest Salary: \" + secondHighestSalary(es2));\n\n        EmployeeSalaries es3 = new EmployeeSalaries(new String[]{\"Eve\", \"Frank\", \"Gina\", \"Hank\"}, new int[]{1000, 900, 1100, 1200});\n        System.out.println(\"Second Highest Salary: \" + secondHighestSalary(es3));\n    }\n\n    public static Integer secondHighestSalary(EmployeeSalaries es) {\n        if (es.salaries.length < 2) return null;\n        int max = 0, secMax = 0;\n        for (int salary : es.salaries) {\n            if (salary > max) {\n                secMax = max;\n                max = salary;\n            } else if (salary != max && salary > secMax)\n                secMax = salary;\n        }\n        return secMax;\n    }\n}\n\nclass EmployeeSalaries {\n    String[] employees;\n    int[] salaries;\n\n    public EmployeeSalaries(String[] employees, int[] salaries) {\n        this.employees = employees;\n        this.salaries = salaries;\n    }\n}\n```",
  "177": "```\npublic class Solution {\n    public int nThHighestSalary(Solution schemas, String table, String column, int n) {\n        // your logic here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1:\n        Salary salary1 = new Salary(\"John\", 100000);\n        Salary salary2 = new Salary(\"Alice\", 80000);\n        Salary salary3 = new Salary(\"Bob\", 120000);\n\n        List<Salary> salaries = Arrays.asList(salary1, salary2, salary3);\n        \n        System.out.println(solution.nThHighestSalary(null, \"salaries\", \"salary\", 2)); // Expected: 100000\n\n        // Test Case 2:\n        Salary salary4 = new Salary(\"Eve\", 90000);\n        Salary salary5 = new Salary(\"Max\", 110000);\n        \n        salaries.add(salary4);\n        salaries.add(salary5);\n\n        System.out.println(solution.nThHighestSalary(null, \"salaries\", \"salary\", 3)); // Expected: 110000\n\n        // Test Case 3:\n        Salary salary6 = new Salary(\"Lily\", 70000);\n        \n        salaries.add(salary6);\n\n        System.out.println(solution.nThHighestSalary(null, \"salaries\", \"salary\", 1)); // Expected: 70000\n    }\n}\n\nclass Salary {\n    String employee;\n    int salary;\n\n    public Salary(String employee, int salary) {\n        this.employee = employee;\n        this.salary = salary;\n    }\n\n    public int getSalary() {\n        return salary;\n    }\n}\n```",
  "178": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] scores = {{5, 1, 9}, {6, 2, 4}, {8, 3, 7}};\n        System.out.println(Arrays.deepToString(rankScores(scores)));\n\n        scores = new int[][]{{1, 2}, {3, 4}};\n        System.out.println(Arrays.deepToString(rankScores(scores)));\n\n        scores = new int[][]{{5, 6, 9, 10}, {1, 2, 8, 11}};\n        System.out.println(Arrays.deepToString(rankScores(scores)));\n    }\n\n    public static int[][] rankScores(int[][] scores) {\n        Arrays.sort(scores, (a, b) -> a[0] - b[0]);\n        for (int i = 0; i < scores.length; i++) {\n            scores[i][1] = i + 1;\n        }\n        return scores;\n    }\n}",
  "179": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(compare(\"10\", \"2\")); // Expected: \"210\"\n        System.out.println(compare(\"3\", \"30\")); // Expected: \"330\"\n        System.out.println(compare(\"20\", \"1\")); // Expected: \"21\"\n    }\n\n    public static String compare(String a, String b) {\n        return compare(a + b, b + a).substring(0, 1 == a.length() ? a.length() : b.length());\n    }\n\n    public static String compare(String a, String b) {\n        Comparator<String> comparator = new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                return Long.compare(Long.parseLong(s1 + s2), Long.parseLong(s2 + s1));\n            }\n        };\n\n        List<String> strings = Arrays.asList(a, b);\n        Collections.sort(strings, comparator);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : strings) {\n            sb.append(str);\n        }\n\n        return sb.toString();\n    }\n}\n```",
  "180": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findConsecutiveNumbers(new int[][]{{1,2}, {2,3}}));\n        System.out.println(findConsecutiveNumbers(new int[][]{{-10,-9,0},{8,9}}));\n        System.out.println(findConsecutiveNumbers(new int[][]{}));\n    }\n\n    public static String findConsecutiveNumbers(int[][] sequences) {\n        List<List<Integer>> result = new ArrayList<>();\n        for (int[] sequence : sequences) {\n            if (sequence.length < 2) continue;\n            boolean isConsecutive = true;\n            List<Integer> currentSequence = new ArrayList<>();\n            int prevNum = sequence[0];\n            for (int num : sequence) {\n                if (num - prevNum != 1) {\n                    isConsecutive = false;\n                    break;\n                }\n                currentSequence.add(num);\n                prevNum = num;\n            }\n            if (isConsecutive) result.add(currentSequence);\n        }\n        return result.toString();\n    }\n}",
  "181": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] salary = {\n                {1,5,3},\n                {2,3,18},\n                {49,50,7},\n                {1}\n            };\n\n        System.out.println(employeesEarningMoreThanTheirManagers(salary));\n    }\n\n    public static List<Integer> employeesEarningMoreThanTheirManagers(int[][] salary) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < salary.length; i++) {\n            map.put(salary[i][0], salary[i][1]);\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getKey() != 0) {\n                int managerSalary = map.get(entry.getKey());\n                if (managerSalary < entry.getValue()) {\n                    res.add(entry.getValue());\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```",
  "182": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<String> findDuplicates(String[] emails) {\n        Map<String, Integer> map = new HashMap<>();\n        List<String> result = new ArrayList<>();\n\n        for (String email : emails) {\n            String[] parts = email.split(\"@\");\n            String domain = parts[1];\n            map.put(domain, map.getOrDefault(domain, 0) + 1);\n        }\n\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            if (entry.getValue() > 1) {\n                result.add(entry.getKey());\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        String[] emails1 = {\"john@example.com\", \"jane@example.com\", \"john@example.com\", \"abc@example.com\"};\n        List<String> duplicates1 = solution.findDuplicates(emails1);\n        System.out.println(\"Test case 1: \" + duplicates1);\n\n        // Test case 2\n        String[] emails2 = {\"a@example.com\", \"b@example.com\", \"c@example.com\", \"d@example.com\"};\n        List<String> duplicates2 = solution.findDuplicates(emails2);\n        System.out.println(\"Test case 2: \" + duplicates2);\n\n        // Test case 3\n        String[] emails3 = [\"conradresnick@gmail.com\", \"conradresnick@gmail.com\", \"conradresnick@gmail.com\", \"xyz@example.com\"];\n        List<String> duplicates3 = solution.findDuplicates(emails3);\n        System.out.println(\"Test case 3: \" + duplicates3);\n    }\n}",
  "183": "```\npublic class Main {\n    public static void main(String[] args) {\n        String[] accounts = {\"John23\", \"J0hn23\", \"j0hn23\"};\n        System.out.println(\"Customers who never order: \" + customersWhoNeverOrder(accounts));\n        \n        accounts = new String[]{\"Alice28\",\"Bob42\",\"Carl83\"};\n        System.out.println(\"\\nCustomers who never order: \" + customersWhoNeverOrder(accounts));\n\n        accounts = new String[]{\"Jane24\", \"Jim30\", \"J0hn25\"};\n        System.out.println(\"\\nCustomers who never order: \" + customersWhoNeverOrder(accounts));\n    }\n\n    public static List<String> customersWhoNeverOrder(String[] customerList) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String customer : customerList) {\n            if (!customer.matches(\"^[a-zA-Z]+$\")) {\n                continue;\n            }\n            int orderNumber = Integer.parseInt(customer.substring(customer.length() - 2));\n            if (!map.containsKey(customer)) {\n                map.put(customer, orderNumber);\n            } else {\n                map.put(customer, Math.max(map.get(customer), orderNumber));\n            }\n        }\n        List<String> result = new ArrayList<>();\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            if (entry.getValue() == 0) {\n                result.add(entry.getKey());\n            }\n        }\n        return result;\n    }\n}\n```",
  "184": "```\npublic class Main {\n    public static void main(String[] args) {\n        Employee[] employees = new Employee[] {\n            new Employee(1, \"John\", \"A\", 30000),\n            new Employee(2, \"Jane\", \"B\", 40000),\n            new Employee(3, \"Bob\", \"C\", 50000),\n            new Employee(4, \"Alice\", \"D\", 55000),\n            new Employee(5, \"Mike\", \"E\", 60000)\n        };\n\n        for (String department : getHighestSalaryDepartments(employees)) {\n            System.out.println(department);\n        }\n    }\n\n    public static String[] getHighestSalaryDepartments(Employee[] employees) {\n        Map<String, Integer> departmentSalaries = new HashMap<>();\n        for (Employee employee : employees) {\n            if (!departmentSalaries.containsKey(employee.department)) {\n                departmentSalaries.put(employee.department, employee.salary);\n            } else {\n                int currentSalary = departmentSalaries.get(employee.department);\n                if (employee.salary > currentSalary) {\n                    departmentSalaries.put(employee.department, employee.salary);\n                }\n            }\n        }\n\n        String[] result = new String[departmentSalaries.size()];\n        int i = 0;\n        for (Map.Entry<String, Integer> entry : departmentSalaries.entrySet()) {\n            result[i++] = \"Department: \" + entry.getKey() + \", Highest Salary: \" + entry.getValue();\n        }\n        return result;\n    }\n\n    static class Employee {\n        int id;\n        String name;\n        String department;\n        int salary;\n\n        public Employee(int id, String name, String department, int salary) {\n            this.id = id;\n            this.name = name;\n            this.department = department;\n            this.salary = salary;\n        }\n    }\n}",
  "186": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reverseWords(\"Hello world\")); // Expected output: \"world Hello\"\n        System.out.println(reverseWords(\"a b c d e f g h i j k\")); // Expected output: \"j k i h g f e d c b a\"\n        System.out.println(reverseWords(\"This is just a test\")); // Expected output: \"test a just is This\"\n    }\n\n    public static String reverseWords(String s) {\n        String[] words = s.split(\" \");\n        StringBuilder reversedS = new StringBuilder();\n        for (String word : words) {\n            char[] chars = word.toCharArray();\n            int left = 0;\n            int right = chars.length - 1;\n            while (left < right) {\n                char temp = chars[left];\n                chars[left] = chars[right];\n                chars[right] = temp;\n                left++;\n                right--;\n            }\n            reversedS.append(new String(chars)).append(\" \");\n        }\n        return reversedS.toString().trim();\n    }\n}\n```",
  "185": "```\npublic class Main {\n    public static void main(String[] args) {\n        test1();\n        test2();\n        test3();\n    }\n\n    private static void test1() {\n        Employee[] employees = new Employee[] {\n            new Employee(\"John\", \"A\", 1000),\n            new Employee(\"Mary\", \"A\", 2000),\n            new Employee(\"Jane\", \"B\", 3000),\n            new Employee(\"Tom\", \"C\", 4000)\n        };\n        List<Integer> result = getTopThreeSalaries(employees);\n        System.out.println(result); // expected output: [2000, 1000, 3000]\n    }\n\n    private static void test2() {\n        Employee[] employees = new Employee[] {\n            new Employee(\"Alice\", \"A\", 5000),\n            new Employee(\"Bob\", \"B\", 6000),\n            new Employee(\"Eve\", \"C\", 7000)\n        };\n        List<Integer> result = getTopThreeSalaries(employees);\n        System.out.println(result); // expected output: [7000, 6000, 5000]\n    }\n\n    private static void test3() {\n        Employee[] employees = new Employee[] {\n            new Employee(\"Mike\", \"A\", 8000),\n            new Employee(\"Sarah\", \"B\", 9000),\n            new Employee(\"John\", \"C\", 10000)\n        };\n        List<Integer> result = getTopThreeSalaries(employees);\n        System.out.println(result); // expected output: [10000, 9000, 8000]\n    }\n\n    public static List<Integer> getTopThreeSalaries(Employee[] employees) {\n        Map<String, List<Employee>> departmentToEmployees = new HashMap<>();\n        for (Employee employee : employees) {\n            departmentToEmployees.computeIfAbsent(employee.department, k -> new ArrayList<>()).add(employee);\n        }\n        List<List<Integer>> results = new ArrayList<>();\n        for (Map.Entry<String, List<Employee>> entry : departmentToEmployees.entrySet()) {\n            List<Integer> salaries = new ArrayList<>();\n            for (Employee employee : entry.getValue()) {\n                salaries.add(employee.salary);\n            }\n            Collections.sort(salaries);\n            results.add(salaries.subList(salaries.size() - 3, salaries.size()));\n        }\n        return results.stream().flatMap(Collection::stream).sorted(Comparator.reverseOrder()).limit(3).collect(Collectors.toList());\n    }\n\n    static class Employee {\n        String name;\n        String department;\n        int salary;\n\n        public Employee(String name, String department, int salary) {\n            this.name = name;\n            this.department = department;\n            this.salary = salary;\n        }\n    }\n}\n```",
  "187": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numRepeatedDnaSequences(\"AACCCAAA\")); // Output: [\"AAC\", \"ACA\"]\n        System.out.println(numRepeatedDnaSequences(\"AAAAACCCCC\")); // Output: [\"AAAA\", \"ACCCC\"]\n        System.out.println(numRepeatedDnaSequences(\"BBBBB\")); // Output: []\n    }\n\n    public static List<String> numRepeatedDnaSequences(String s) {\n        // Your code here\n    }\n}\n```",
  "188": "```\npublic class Main {\n    public static void main(String[] args) {\n        int result1 = maxProfit(new int[]{7,6,5,4,3,2,1}, 2);\n        System.out.println(\"Test case 1: \" + result1);\n\n        int result2 = maxProfit(new int[]{1,2,3,4,5}, 1);\n        System.out.println(\"Test case 2: \" + result2);\n\n        int result3 = maxProfit(new int[]{7,6,8,9,10}, 3);\n        System.out.println(\"Test case 3: \" + result3);\n    }\n\n    public static int maxProfit(int[] prices, int windowSize) {\n        if (prices.length < windowSize * 2) {\n            return 0;\n        }\n        \n        int maxProfit = 0;\n        for (int i = 0; i < prices.length - windowSize; i++) {\n            int minPrice = Integer.MAX_VALUE;\n            int maxDiff = 0;\n            \n            for (int j = 0; j < windowSize; j++) {\n                if (prices[i + j] < minPrice) {\n                    minPrice = prices[i + j];\n                } else if (prices[i + j] - minPrice > maxDiff) {\n                    maxDiff = prices[i + j] - minPrice;\n                }\n            }\n            \n            if (maxDiff > 0) {\n                maxProfit += maxDiff;\n            }\n        }\n        \n        return maxProfit;\n    }\n}",
  "189": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {1,2,3,4,5};\n        rotateArray(nums1, 2);\n        System.out.println(Arrays.toString(nums1));\n        \n        int[] nums2 = {1,2};\n        rotateArray(nums2, 4);\n        System.out.println(Arrays.toString(nums2));\n\n        int[] nums3 = {-1,-100,3,99];\n        rotateArray(nums3, 3);\n        System.out.println(Arrays.toString(nums3));\n    }\n\n    public static void rotateArray(int[] nums, int k) {\n        k = k % nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n\n    public static void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}",
  "190": "```\npublic class Solution {\n    public int reverseBits(int n) {\n        int result = 0;\n        for (int i = 0; i < 32; i++) {\n            result = ((result << 1) | (n & 1)) << (31 - i);\n            n >>>= 1;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(\"Test case 1: \" + solution.reverseBits(993996960415863027));\n        System.out.println(\"Test case 2: \" + solution.reverseBits(0));\n        System.out.println(\"Test case 3: \" + solution.reverseBits(1064418256));\n    }\n}",
  "191": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(hammingWeight(0b00000000) + \" - Expected: 0\");\n        System.out.println(hammingWeight(0b00000001) + \" - Expected: 1\");\n        System.out.println(hammingWeight(0b01110011) + \" - Expected: 4\");\n    }\n\n    public static int hammingWeight(int n) {\n        int count = 0;\n        while (n > 0) {\n            count += n & 1;\n            n >>= 1;\n        }\n        return count;\n    }\n}\n```",
  "192": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(wordFrequency(\"apple apple\", \"apple\")); // Expected: 2\n        System.out.println(wordFrequency(\"word word\", \"word\")); // Expected: 2\n        System.out.println(wordFrequency(\"hello world hello\", \"world\")); // Expected: 1\n    }\n\n    public static int wordFrequency(String text, String word) {\n        String[] words = text.split(\"\\\\s+\");\n        return Arrays.stream(words).filter(w -> w.equals(word)).count();\n    }\n}",
  "193": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isValidPhoneNumber(\"123-456-7890\")); // true\n        System.out.println(isValidPhoneNumber(\"(123)-456-7890\")); // false\n        System.out.println(isValidPhoneNumber(\"123.456.7890\")); // false\n    }\n\n    public static boolean isValidPhoneNumber(String phoneNumber) {\n        String regex = \"^\\\\(?([0-9]{3})\\\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$\";\n        return phoneNumber.matches(regex);\n    }\n}\n```",
  "195": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(tenthLine(\"Hello\\nWorld\", 1)); // Test case 1: First line is not the tenth line\n        System.out.println(tenthLine(\"hello\\\\nworld\\\\nthis\\\\nis\\\\nthe\\\\ntenth\\\\nline\", 10)); // Test case 2: Tenth line should be returned\n        System.out.println(tenthLine(\"\", 5)); // Test case 3: No tenth line in empty string\n    }\n\n    public static String tenthLine(String text, int n) {\n        if (text == null || text.isEmpty() || n < 1) {\n            return \"\";\n        }\n        \n        String[] lines = text.split(\"\\\\n\");\n        try {\n            return lines[n - 1];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            return \"\";\n        }\n    }\n}",
  "194": "```\npublic class Main {\n    public static void main(String[] args) {\n        String file1 = \"abc\\ncba\";\n        String expected1 = \"acb\\nbac\";\n        System.out.println(transposeFile(file1, \"output.txt\"));\n        \n        String file2 = \"a\\nb\\nc\";\n        String expected2 = \"a\\nb\\nc\";\n        System.out.println(transposeFile(file2, \"output.txt\"));\n        \n        String file3 = \"\";\n        String expected3 = \"\";\n        System.out.println(transposeLineByLine(\"input.txt\", \"output.txt\"));\n    }\n\n    public static void transposeLineByLine(String inputFile, String outputFile) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(inputFile));\n             PrintWriter writer = new PrintWriter(new FileWriter(outputFile))) {\n\n            String line;\n            while ((line = reader.readLine()) != null) {\n                StringBuilder sb = new StringBuilder();\n                for (String word : line.split(\"\\\\s+\")) {\n                    for (char c : word.toCharArray()) {\n                        sb.append(c);\n                    }\n                    sb.append(\" \");\n                }\n                writer.println(sb.toString().trim());\n            }\n\n        } catch (IOException e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n```",
  "196": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<String> deleteDuplicateEmails(List<String> emails) {\n        Set<String> uniqueEmails = new HashSet<>();\n        List<String> result = new ArrayList<>();\n\n        for (String email : emails) {\n            if (!uniqueEmails.contains(email)) {\n                uniqueEmails.add(email);\n                result.add(email);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> emails1 = Arrays.asList(\"mary@example.com\", \"john@example.com\", \"jane@example.com\", \"jane@example.com\");\n        System.out.println(solution.deleteDuplicateEmails(emails1));\n        \n        List<String> emails2 = Arrays.asList(\"mike@gmail.com\", \"sofia@gmail.com\", \"anna@gmail.com\", \"anna@gmail.com\", \"mike@gmail.com\");\n        System.out.println(solution.deleteDuplicateEmails(emails2));\n\n        List<String> emails3 = Arrays.asList(\"julia@leetcode.com\", \"julia@leetcode.com\");\n        System.out.println(solution.deleteDuplicateEmails(emails3));\n    }\n}",
  "197": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(risingTemperature(new int[][]{{73, 85}, {73, 89, 91}, {74, 85, 90}}));\n        System.out.println(risingTemperature(new int[][]{}));\n        System.out.println(risingTemperature(new int[][]{{30, 95}}));\n    }\n\n    public static double risingTemperature(int[][] temperatures) {\n        if (temperatures == null || temperatures.length == 0) {\n            return -1.0;\n        }\n        \n        double result = 0;\n        for (int i = 1; i < temperatures[0].length; i++) {\n            int previousTemp = temperatures[0][i - 1];\n            int currentTemp = temperatures[0][i];\n            if (currentTemp > previousTemp) {\n                result += currentTemp - previousTemp;\n            }\n        }\n        \n        return result / (temperatures[0].length - 1);\n    }\n}\n```",
  "198": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + rob(new int[]{2,7,9,3,5}) + \"\\n\");\n        System.out.println(\"Test Case 2: \" + rob(new int[]{1,2}) + \"\\n\");\n        System.out.println(\"Test Case 3: \" + rob(new int[]{0})) + \"\\n\";\n    }\n\n    public static int rob(int[] nums) {\n        if (nums.length == 0) return 0;\n        if (nums.length == 1) return nums[0];\n\n        int[] dp = new int[nums.length];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n\n        for (int i = 2; i < nums.length; i++) {\n            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\n        }\n\n        return dp[nums.length - 1];\n    }\n}",
  "199": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.right = new TreeNode(2);\n        root1.left = new TreeNode(4);\n        root1.left.right = new TreeNode(5);\n        root1.left.left = new TreeNode(3);\n\n        System.out.println(\"Test Case 1:\");\n        System.out.println(\"Result: \" + rightSideView(root1));\n        System.out.println();\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n\n        System.out.println(\"Test Case 2:\");\n        System.out.println(\"Result: \" + rightSideView(root2));\n        System.out.println();\n\n        TreeNode root3 = null;\n\n        System.out.println(\"Test Case 3:\");\n        System.out.println(\"Result: \" + rightSideView(root3));\n        System.out.println();\n    }\n\n    public static List<Integer> rightSideView(TreeNode root) {\n        // Your code here\n    }\n}\n```",
  "201": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(bitwiseAnd(5, 7)); // Output: 4\n        System.out.println(bitwiseAnd(0, 1)); // Output: 0\n        System.out.println(bitwiseAnd(16, 17)); // Output: 16\n    }\n\n    public static int bitwiseAnd(int m, int n) {\n        int result = m;\n        for (int i = m - 1; i >= 31; i--) {\n            if (((m >> i) & 1) == 0 || ((n >> i) & 1) == 0) {\n                continue;\n            }\n            while (((result >> i) & 1) == 0) {\n                result = (result & ~(1 << i)) | (m & ~(1 << i));\n            }\n        }\n        return result;\n    }\n}",
  "200": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{'0', '1', '0', '0', '0'},\n                         {'1', '1', '1', '0', '0'},\n                         {'0', '1', '0', '0', '0'},\n                         {'0', '0', '0', '1', '1'}};\n        System.out.println(\"Number of islands in grid 1: \" + numIslands(grid1));\n\n        int[][] grid2 = {{'1', '1', '0', '0', '0'},\n                         {'1', '1', '0', '0', '0'},\n                         {'0', '0', '1', '0', '0'}};\n        System.out.println(\"Number of islands in grid 2: \" + numIslands(grid2));\n\n        int[][] grid3 = {{'1', '1', '0', '1', '1'},\n                         {'0', '0', '1', '0', '0'},\n                         {'1', '0', '0', '0', '0'}};\n        System.out.println(\"Number of islands in grid 3: \" + numIslands(grid3));\n    }\n\n    public static int numIslands(int[][] grid) {\n        if (grid == null || grid.length == 0) return 0;\n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void dfs(int[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] != '1') return;\n        grid[i][j] = '2';\n        dfs(grid, i - 1, j);\n        dfs(grid, i + 1, j);\n        dfs(grid, i, j - 1);\n        dfs(grid, i, j + 1);\n    }\n}",
  "202": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isHappy(19)); // true\n        System.out.println(isHappy(2)); // false\n        System.out.println(isHappy(13)); // true\n    }\n\n    public static boolean isHappy(int n) {\n        Set<Integer> seen = new HashSet<>();\n        while (n != 1 && !seen.add(n)) {\n            n = getSumOfSquares(n);\n        }\n        return n == 1;\n    }\n\n    private static int getSumOfSquares(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            sum += digit * digit;\n            n /= 10;\n        }\n        return sum;\n    }\n}",
  "204": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countPrimes(10)); // Output: 4\n        System.out.println(countPrimes(50)); // Output: 15\n        System.out.println(countPrimes(1000000)); // Output: 78498\n    }\n\n    public static int countPrimes(int n) {\n        if (n <= 2) {\n            return n == 2 ? 1 : 0;\n        }\n        \n        boolean[] isPrime = new boolean[n];\n        for (int i = 2; i < n; i++) {\n            isPrime[i] = true;\n        }\n\n        for (int i = 2; Math.sqrt(i) <= n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n}",
  "203": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(3);\n        head1.next.next.next = new ListNode(4);\n        head1.next.next.next.next = new ListNode(5);\n\n        removeElements(head1, 3);\n\n        System.out.println(\"Test Case 1: \");\n\n        printList(head1);\n\n        //------------------------------------------------\n\n        ListNode head2 = new ListNode(1);\n        head2.next = new ListNode(2);\n        head2.next.next = new ListNode(3);\n\n        removeElements(head2, 2);\n\n        System.out.println(\"\\nTest Case 2: \");\n\n        printList(head2);\n\n        //------------------------------------------------\n\n        ListNode head3 = null;\n\n        removeElements(head3, 1);\n\n        System.out.println(\"\\nTest Case 3: \");\n    }\n\n    public static void removeElements(ListNode head, int val) {\n        if (head == null || head.val != val) {\n            printList(head);\n        } else {\n            head = head.next;\n            removeElements(head, val);\n        }\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n```",
  "205": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeIsomorphic(\"egg\", \"add\")); // true\n        System.out.println(canBeIsomorphic(\"foo\", \"bar\")); // false\n        System.out.println(canBeIsomorphic(\"paper\", \"title\")); // true\n    }\n\n    public static boolean canBeIsomorphic(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int[] mapS = new int[256], mapT = new int[256];\n        for (int i = 0; i < s.length(); i++) {\n            if (mapS[s.charAt(i)] != mapT[t.charAt(i)]) return false;\n            mapS[s.charAt(i)] = mapT[t.charAt(i)] = i + 1;\n        }\n        return true;\n    }\n}\n```",
  "206": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        // Test case 1:\n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head = reverseList(head);\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n\n        // Test case 2:\n        head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head = reverseList(head);\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n\n        // Test case 3:\n        head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head.next.next.next.next = new ListNode(5);\n        head = reverseList(head);\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n\n    public static ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int x) { val = x; }\n}\n```",
  "207": "```\nimport java.util.*;\n\nclass Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] pair : prerequisites) {\n            graph.get(pair[1]).add(pair[0]);\n        }\n        \n        boolean[] visited = new boolean[numCourses];\n        boolean[] recStack = new boolean[numCourses];\n        \n        for (int i = 0; i < numCourses; i++) {\n            if (!dfs(graph, visited, recStack, i)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n\n    private boolean dfs(List<List<Integer>> graph, boolean[] visited, boolean[] recStack, int node) {\n        if (recStack[node]) {\n            return false;\n        }\n        \n        if (visited[node]) {\n            return true;\n        }\n        \n        visited[node] = true;\n        recStack[node] = true;\n        \n        for (int neighbor : graph.get(node)) {\n            if (!dfs(graph, visited, recStack, neighbor)) {\n                return false;\n            }\n        }\n        \n        recStack[node] = false;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.canFinish(2, new int[][]{{1,0}})); // Expected: true\n        System.out.println(solution.canFinish(4, new int[][]{{1,0},{2,2},{3,1},{3,2}})); // Expected: false\n        System.out.println(solution.canFinish(3, new int[][]{})); // Expected: true\n    }\n}",
  "209": "```\npublic class Main {\n    public static void main(String[] args) {\n        int result1 = minSubArrayLen(new int[]{2, 3, 1, 2, 4, 3}, 7);\n        System.out.println(\"Test case 1: \" + result1);\n\n        int result2 = minSubArrayLen(new int[]{5, 6, 7, 8, 9, 10}, 100);\n        System.out.println(\"Test case 2: \" + result2);\n\n        int result3 = minSubArrayLen(new int[]{1}, 1);\n        System.out.println(\"Test case 3: \" + result3);\n    }\n\n    public static int minSubArrayLen(int[] nums, int target) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        int n = nums.length;\n        int res = n + 1;\n        int left = 0;\n        long sum = 0;\n\n        for (int right = 0; right < n; right++) {\n            sum += nums[right];\n            while (sum >= target) {\n                res = Math.min(res, right - left + 1);\n                sum -= nums[left++];\n            }\n        }\n        return res == n + 1 ? 0 : res;\n    }\n}\n```",
  "208": "```\npublic class Main {\n    public static void main(String[] args) {\n        Trie trie = new Trie();\n        System.out.println(trie.insert(\"apple\")); // true\n        System.out.println(trie.search(\"apple\")); // true\n        System.out.println(trie.startsWith(\"app\")); // true\n\n        trie = new Trie();\n        System.out.println(trie.insert(\"cat\")); // true\n        System.out.println(trie.search(\"cat\")); // true\n        System.out.println(trie.search(\"car\")); // false\n\n        trie = new Trie();\n        System.out.println(trie.insert(\"a\")); // true\n        System.out.println(trie.search(\"a\")); // true\n        System.out.println(trie.startsWith(\"aa\")); // true\n    }\n}\n\nclass TrieNode {\n    char val;\n    boolean isEndOfWord;\n    TrieNode[] children = new TrieNode[26];\n\n    public TrieNode() {}\n    public TrieNode(char ch) {\n        val = ch;\n        isEndOfWord = false;\n        for (int i = 0; i < 26; i++) children[i] = null;\n    }\n}\n\nclass Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public boolean insert(String word) {\n        TrieNode node = root;\n        for (char ch : word.toCharArray()) {\n            if (node.children[ch - 'a'] == null)\n                node.children[ch - 'a'] = new TrieNode(ch);\n            node = node.children[ch - 'a'];\n        }\n        node.isEndOfWord = true;\n        return true;\n    }\n\n    public boolean search(String word) {\n        TrieNode node = root;\n        for (char ch : word.toCharArray()) {\n            if (node.children[ch - 'a'] == null)\n                return false;\n            node = node.children[ch - 'a'];\n        }\n        return node.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        TrieNode node = root;\n        for (char ch : prefix.toCharArray()) {\n            if (node.children[ch - 'a'] == null)\n                return false;\n            node = node.children[ch - 'a'];\n        }\n        return true;\n    }\n}\n```",
  "210": "```\nimport java.util.*;\n\nclass Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        int[] inDegree = new int[numCourses];\n        List<int[]> edges = new ArrayList<>();\n        \n        for (int i = 0; i < prerequisites.length; i++) {\n            int a = prerequisites[i][0], b = prerequisites[i][1];\n            if (!edges.contains(new int[]{b, a})) edges.add(new int[]{b, a});\n            inDegree[a]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (inDegree[i] == 0) queue.offer(i);\n        }\n        \n        List<Integer> order = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            int course = queue.poll();\n            order.add(course);\n            \n            for (int[] edge : edges) {\n                if (edge[1] == course) {\n                    inDegree[edge[0]]--;\n                    if (inDegree[edge[0]] == 0) queue.offer(edge[0]);\n                }\n            }\n        }\n        \n        int[] result = new int[numCourses];\n        for (int i = order.size() - 1; i >= 0; i--) {\n            result[i] = order.get(i);\n        }\n        \n        if (order.size() == numCourses) return result;\n        else return new int[0];\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[][] prerequisites1 = {{1, 0}};\n        System.out.println(Arrays.toString(solution.findOrder(2, prerequisites1)));\n        \n        // Test case 2\n        int[][] prerequisites2 = {{1, 0}, {0, 2}};\n        System.out.println(Arrays.toString(solution.findOrder(3, prerequisites2)));\n        \n        // Test case 3\n        int[][] prerequisites3 = {};\n        System.out.println(Arrays.toString(solution.findOrder(1, prerequisites3)));\n    }\n}",
  "211": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TrieNode root = new TrieNode();\n\n        // Test case 1\n        WordDictionary dictionary = new WordDictionary(root);\n        dictionary.addWord(\"bad\");\n        dictionary.addWord(\"dad\");\n        dictionary.addWord(\"mad\");\n        System.out.println(dictionary.search(\"pad\")); // false\n        System.out.println(dictionary.search(\"bad\")); // true\n        System.out.println(dictionary.search(\"maid\")); // true\n\n        // Test case 2\n        root = new TrieNode();\n        dictionary = new WordDictionary(root);\n        dictionary.addWord(\"hello\");\n        dictionary.addWord(\"alooo\");\n        System.out.println(dictionary.search(\"alooo\")); // true\n        System.out.println(dictionary.search(\"hello\")); // true\n        System.out.println(dictionary.search(\"hell\")); // false\n\n        // Test case 3\n        root = new TrieNode();\n        dictionary = new WordDictionary(root);\n        dictionary.addWord(\"apple\");\n        dictionary.addWord(\"banana\");\n        System.out.println(dictionary.search(\"app\")); // false\n        System.out.println(dictionary.search(\"banana\")); // true\n        System.out.println(dictionary.search(\"banan\")); // false\n    }\n}\n\nclass TrieNode {\n    boolean isEndOfWord;\n    Map<Character, TrieNode> children = new HashMap<>();\n\n    public TrieNode() {\n        this.isEndOfWord = false;\n    }\n}\n\nclass WordDictionary {\n    private TrieNode root;\n\n    public WordDictionary(TrieNode root) {\n        this.root = root;\n    }\n\n    public void addWord(String word) {\n        TrieNode current = root;\n        for (char c : word.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                current.children.put(c, new TrieNode());\n            }\n            current = current.children.get(c);\n        }\n        current.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        return search(root, word, 0);\n    }\n\n    private boolean search(TrieNode node, String word, int index) {\n        if (index == word.length()) {\n            return node.isEndOfWord;\n        }\n        for (char c : word.toCharArray()) {\n            if (c == '.') {\n                for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {\n                    if (search(entry.getValue(), word, index + 1)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else if (!node.children.containsKey(c)) {\n                return false;\n            } else {\n                node = node.children.get(c);\n            }\n        }\n        return node.isEndOfWord;\n    }\n}\n```",
  "212": "```\npublic class Main {\n    public static void main(String[] args) {\n        char[][] board = {{'A','B','C','E'},\n                          {'S','F','C','S'},\n                          {'A','D','E','E'}};\n        String[] words = {\"ABCCED\",\"SEEQS\"};\n        \n        for (String word : words) {\n            System.out.println(findWords(board, word));\n        }\n    }\n\n    public static List<String> findWords(char[][] board, String word) {\n        // Code to solve the problem\n    }\n}\n```",
  "213": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \");\n        int[] nums = {2,7,9,3,5};\n        System.out.println(\"Expected Output: \" + rob(nums));\n        System.out.println();\n\n        System.out.println(\"Test Case 2: \");\n        int[] nums2 = {2};\n        System.out.println(\"Expected Output: \" + rob(nums2));\n        System.out.println();\n\n        System.out.println(\"Test Case 3: \");\n        int[] nums3 = {0};\n        System.out.println(\"Expected Output: \" + rob(nums3));\n    }\n\n    public static int rob(int[] nums) {\n        if (nums.length == 1) return nums[0];\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\n        \n        int[] dp = new int[nums.length+1];\n        dp[0] = 0;\n        dp[1] = Math.max(nums[0], nums[1]);\n\n        for (int i = 2; i < nums.length; i++) {\n            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i]);\n        }\n        \n        return dp[nums.length-1];\n    }\n}\n```",
  "215": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class KthLargestElement {\n    public static int findKthLargest(int[] nums, int k) {\n        Arrays.sort(nums);\n        PriorityQueue<Integer> queue = new PriorityQueue((a, b) -> b - a);\n        for (int num : nums) {\n            queue.offer(num);\n            if (queue.size() > k) {\n                queue.poll();\n            }\n        }\n        return queue.peek();\n    }\n\n    public static void main(String[] args) {\n        int[][] testCases = {{3, 2, 1, 5, 6, 4}, {0, -9, 10, 11, 7, 8, 15}, {-1, 10}};\n        for (int[] testCase : testCases) {\n            System.out.println(\"Kth Largest Element in array \" + Arrays.toString(testCase) + \": \" + findKthLargest(testCase, 2));\n        }\n    }\n}",
  "214": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(shortestPalindrome(\"a\", \"paymentplan\")); // expected: \"apaymenteypad\"\n        System.out.println(shortestPalindrome(\"ab\", \"hiqshijooupdsfhbsdouyhdbsouhdbsuoyhdbsu\")); // expected: \"ahihisudshsdsfsdhsouyoouysdusdhbousdhbousyuhsydhsuhbod\"\n        System.out.println(shortestPalindrome(\"abc\", \"\")); // expected: \"cbbaabc\"\n    }\n\n    public static String shortestPalindrome(String s, String w) {\n        int n = s.length();\n        int m = w.length();\n        StringBuilder sb = new StringBuilder();\n        \n        for (int i = 0; i < m; i++) {\n            sb.append(w.charAt(m - i - 1));\n        }\n        \n        while (!kmp(s, sb.toString())) {\n            sb.insert(0, 'a');\n        }\n        \n        return sb.toString() + s;\n    }\n\n    public static boolean kmp(String s, String w) {\n        int n = s.length();\n        int m = w.length();\n        int[] lps = new int[m];\n        int j = 0;\n\n        computeLPSArray(w, lps);\n\n        for (int i = 0; i < n; ) {\n            if (s.charAt(i) == w.charAt(j)) {\n                i++;\n                j++;\n            }\n\n            if (j == m) {\n                return true;\n            }\n\n            else if (i < n && s.charAt(i) != w.charAt(j)) {\n                if (j != 0) {\n                    j = lps[j - 1];\n                } else {\n                    i++;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    public static void computeLPSArray(String str, int[] lps) {\n        int length = 0;\n\n        for (int i = 1; i < str.length(); ) {\n            if (str.charAt(i) == str.charAt(length)) {\n                length++;\n                lps[i] = length;\n                i++;\n            } else {\n                if (length != 0) {\n                    length = lps[length - 1];\n                } else {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n    }\n}\n```",
  "217": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(containsDuplicate(new int[]{1, 2, 3, 1})); // Expected output: true\n        System.out.println(containsDuplicate(new int[]{1, 2, 3, 4})); // Expected output: false\n        System.out.println(containsDuplicate(new int[]{1, 1})); // Expected output: true\n    }\n\n    public static boolean containsDuplicate(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            if (!set.add(num)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "216": "```\npublic class Main {\n    public static void main(String[] args) {\n        int k1 = 9;\n        System.out.println(\"Expected: [[8,1],[7,2],[6,3],[5,4],[4,5],[3,6],[2,7],[1,8]]\");\n        List<List<Integer>> result1 = combinationSum3(k1, 18);\n        for (List<Integer> list : result1) {\n            System.out.println(list);\n        }\n\n        int k2 = 3;\n        System.out.println(\"Expected: [[1,2,3],[1,3,4],[2,3,5]]\");\n        List<List<Integer>> result2 = combinationSum3(k2, 9);\n        for (List<Integer> list : result2) {\n            System.out.println(list);\n        }\n\n        int k3 = 2;\n        System.out.println(\"Expected: [[1,1,1],[1,2]]\");\n        List<List<Integer>> result3 = combinationSum3(k3, 5);\n        for (List<Integer> list : result3) {\n            System.out.println(list);\n        }\n    }\n\n    public static List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> res = new ArrayList<>();\n        backtrack(res, new ArrayList<>(), k, n, 1);\n        return res;\n    }\n\n    private static void backtrack(List<List<Integer>> res, List<Integer> path, int k, int remain, int start) {\n        if (path.size() == k) {\n            if (remain == 0) {\n                res.add(new ArrayList<>(path));\n            }\n            return;\n        }\n        for (int i = start; i <= 9 && i <= remain; i++) {\n            path.add(i);\n            backtrack(res, path, k, remain - i, i + 1);\n            path.remove(path.size() - 1);\n        }\n    }\n}",
  "218": "```\nimport java.util.*;\n\nclass Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        List<int[]> points = new ArrayList<>();\n        for (int[] building : buildings) {\n            points.add(new int[]{building[0], -building[2]});\n            points.add(new int[]{building[1], building[2]});\n        }\n        Arrays.sort(points.toArray(), (a, b) -> a[0] - b[0]);\n        \n        List<List<Integer>> result = new ArrayList<>();\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        int maxHeight = 0;\n        for (int[] point : points) {\n            if (point[1] < 0) {\n                pq.add(-point[1]);\n                maxHeight = Collections.max(pq);\n            } else {\n                while (!pq.isEmpty() && pq.peek() > point[1]) {\n                    pq.poll();\n                }\n                maxHeight = pq.peek();\n                result.add(Arrays.asList(point[0], maxHeight));\n                while (!pq.isEmpty()) {\n                    if (point[1] < -pq.peek()) {\n                        break;\n                    }\n                    pq.poll();\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[][] buildings1 = {{0, 2, 9}, {4, 6, 0}};\n        System.out.println(solution.getSkyline(buildings1));\n        \n        // Test case 2\n        int[][] buildings2 = {{2, 8, 4}, {3, 9, 7}};\n        System.out.println(solution.getSkyline(buildings2));\n        \n        // Test case 3\n        int[][] buildings3 = {{0, 2, 1}, {2, 5, 7}, {5, 6, 5}};\n        System.out.println(solution.getSkyline(buildings3));\n    }\n}",
  "219": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(containsDuplicate(new int[]{1, 2, 3, 1})); // Expected: true\n        System.out.println(containsDuplicate(new int[]{1, 2, 3, 4})); // Expected: false\n        System.out.println(containsDuplicate(new int[]{1, 1, 1, 3})); // Expected: true\n    }\n\n    public static boolean containsDuplicate(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            if (!set.add(num)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "220": "```\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums1 = {{1,2,3,1}};\n        System.out.println(containsNearbyDuplicate(nums1));\n        \n        int[][] nums2 = {{4,7,10,14,20}};\n        System.out.println(containsNearbyDuplicate(nums2));\n        \n        int[][] nums3 = {{1,2}};\n        System.out.println(containsNearbyDuplicate(nums3));\n    }\n\n    public static boolean containsNearbyDuplicate(int[][] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            Arrays.sort(nums[i]);\n            for (int j = 0; j < nums[i].length - 1; j++) {\n                if (nums[i][j] == nums[i][j + 1]) {\n                    return true;\n                }\n                if (j > 0 && nums[i][j] == nums[i][j - 1]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
  "221": "```\npublic class Main {\n    public static void main(String[] args) {\n        char[][] matrix1 = {{'1', '0', '1', '0', '0'}, {'1', '0', '1', '1', '1'}, {'1', '1', '1', '1', '1'}, {'1', '0', '0', '1', '0}};\n        System.out.println(\"Maximal square size for matrix 1: \" + maximalSquare(matrix1));\n\n        char[][] matrix2 = {{'0', '1'}};\n        System.out.println(\"Maximal square size for matrix 2: \" + maximalSideLength(maximalSquare(matrix2)));\n\n        char[][] matrix3 = {{'1'}, {'0'}};\n        System.out.println(\"Maximal square size for matrix 3: \" + maximalSideLength(maximalSquare(matrix3)));\n    }\n\n    public static int maximalSquare(char[][] matrix) {\n        if (matrix.length == 0) return 0;\n        int maxSide = 0;\n        int[][] dp = new int[matrix.length][matrix[0].length];\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if ((i == 0) || (j == 0)) dp[i][j] = (matrix[i][j] - '0');\n                else if (matrix[i][j] - '0' == 1) {\n                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;\n                }\n                maxSide = Math.max(maxSide, dp[i][j]);\n            }\n        }\n        return maxSide * maxSide;\n    }\n\n    public static int maximalSideLength(int size) {\n        return (int) Math.sqrt(size);\n    }\n}",
  "222": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countNodes(new TreeNode(1, new TreeNode(2, null, new TreeNode(4)), new TreeNode(3, new TreeNode(5, null, new TreeNode(6)), null)))); // 6\n        System.out.println(countNodes(null)); // 0\n        System.out.println(countNodes(new TreeNode(1, null, new TreeNode(2))))); // 3\n    }\n\n    public static int countNodes(TreeNode root) {\n        if (root == null) return 0;\n        int leftHeight = 0;\n        TreeNode current = root;\n        while (current != null) {\n            leftHeight++;\n            current = current.left;\n        }\n        if (root.val == null) return (int)Math.pow(2, leftHeight + 1) - 1;\n        int rightHeight = 0;\n        current = root.right;\n        while (current != null) {\n            rightHeight++;\n            current = current.right;\n        }\n        if (rightHeight > 0) return (int)Math.pow(2, leftHeight + rightHeight) - 1;\n        return (int)Math.pow(2, leftHeight) - 1;\n    }\n\n    static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        public TreeNode(int val) {\n            this.val = val;\n        }\n\n        public TreeNode(int val, TreeNode left, TreeNode right) {\n            this(val);\n            this.left = left;\n            this.right = right;\n        }\n    }\n}",
  "223": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(calculateArea(4, 3)); // Test case 1: Expected output = 12\n        System.out.println(calculateArea(0, 100)); // Test case 2: Expected output = 0\n        System.out.println(calculateArea(-5, -8)); // Test case 3: Expected output = 40\n    }\n\n    public static int calculateArea(int length, int width) {\n        return Math.abs(length * width);\n    }\n}\n```",
  "224": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(new Calculator().calculate(\"0\")); // Output: 0\n        System.out.println(new Calculator().calculate(\"1 + 1\")); // Output: 2\n        System.out.println(new Calculator().calculate(\"3 + 4 * 2 - 1\")); // Output: 7\n    }\n}\n\nclass Calculator {\n    public int calculate(String s) {\n        return new Tokenizer(s).eval();\n    }\n\n    static class Tokenizer {\n        String[] tokens;\n        int pos;\n\n        Tokenizer(String s) {\n            tokens = s.split(\"\\\\+|\\\\-|\\\\*|/|(\\\\s+)\");\n            pos = 0;\n        }\n\n        int readNumber() {\n            StringBuilder sb = new StringBuilder();\n            while (pos < tokens.length && !isOperator(tokens[pos])) {\n                sb.append(tokens[pos]);\n                pos++;\n            }\n            return Integer.parseInt(sb.toString());\n        }\n\n        boolean isOperator(String token) {\n            return \"+-*/\".indexOf(token) != -1;\n        }\n\n        int eval() {\n            return expr();\n        }\n\n        int expr() {\n            if (pos >= tokens.length)\n                return 0;\n\n            int x = term();\n\n            while (true) {\n                if (isOperator(tokens[pos])) {\n                    pos++;\n                    x += term();\n                } else\n                    break;\n            }\n            return x;\n        }\n\n        int term() {\n            if (pos >= tokens.length)\n                return readNumber();\n            int x = readNumber();\n\n            while (true) {\n                if (\"*\".equals(tokens[pos]) || \"/\".equals(tokens[pos])) {\n                    pos++;\n                    x = x * readNumber() / readNumber();\n                } else\n                    break;\n            }\n            return x;\n        }\n    }\n}",
  "225": "```\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n    public static void main(String[] args) {\n        MyStack stack = new MyStack();\n        \n        System.out.println(\"Test Case 1:\");\n        pushAndPop(stack);\n        System.out.println();\n\n        System.out.println(\"Test Case 2:\");\n        stack = new MyStack();\n        for (int i = 0; i < 5; i++) {\n            stack.push(i);\n        }\n        while (!stack.isEmpty()) {\n            System.out.print(stack.pop() + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Test Case 3:\");\n        stack = new MyStack();\n        for (int i = 0; i < 2; i++) {\n            stack.push(i);\n        }\n        for (int i = 2; i < 4; i++) {\n            stack.push(i);\n        }\n        while (!stack.isEmpty()) {\n            System.out.print(stack.pop() + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void pushAndPop(MyStack stack) {\n        stack.push(1);\n        System.out.print(\"Pushed: 1, Expected Top: 1, Actual Top: \" + stack.peek() + \"\\n\");\n        stack.push(2);\n        System.out.print(\"Pushed: 2, Expected Top: 2, Actual Top: \" + stack.peek() + \"\\n\");\n        System.out.print(\"Popped: \" + stack.pop() + \", Expected Popped: 2, Actual Popped: \" + stack.pop() + \"\\n\");\n    }\n}\n\nclass MyStack {\n    Queue<Integer> queue1;\n    Queue<Integer> queue2;\n\n    public MyStack() {\n        queue1 = new LinkedList<>();\n        queue2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        while (!queue1.isEmpty()) {\n            queue2.add(queue1.poll());\n        }\n        queue1.add(x);\n        while (!queue2.isEmpty()) {\n            queue1.add(queue2.poll());\n        }\n    }\n\n    public int pop() {\n        return queue1.poll();\n    }\n\n    public int peek() {\n        return queue1.peek();\n    }\n\n    public boolean isEmpty() {\n        return queue1.isEmpty();\n    }\n}",
  "227": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(eval(\"14-3/2+(6+18)*23\", new Stack<String>()));\n        System.out.println(eval(\"1+(4+5+6)-3+7\", new Stack<String>()));\n        System.out.println(eval(\"(3)+(8-(10-1)+2)\", new Stack<String>()));\n    }\n\n    public static int eval(String s, Stack<String> operators) {\n        // Your code here\n    }\n}\n```",
  "226": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(4);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(7);\n        root1.left.left = new TreeNode(1);\n        root1.left.right = new TreeNode(3);\n        root1.right.left = new TreeNode(6);\n        root1.right.right = new TreeNode(9);\n\n        invertTree(root1);\n\n        System.out.println(\"Test Case 1: \");\n        printTree(root1);\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(0);\n        root2.right = new TreeNode(2);\n\n        invertTree(root2);\n\n        System.out.println(\"\\nTest Case 2: \");\n        printTree(root2);\n\n        TreeNode root3 = null;\n\n        invertTree(root3);\n\n        System.out.println(\"\\nTest Case 3: \");\n    }\n\n    public static void invertTree(TreeNode root) {\n        if (root == null) return;\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n        invertTree(root.left);\n        invertTree(root.right);\n    }\n\n    public static void printTree(TreeNode root) {\n        if (root == null) return;\n        System.out.println(root.val + \" \");\n        printTree(root.left);\n        printTree(root.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "229": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {{1, 2}, {0, 1}, {1}};\n        for (int i = 0; i < inputs.length; i++) {\n            System.out.println(\"Majority Element of \" + inputs[i][0] + \" and \" + inputs[i][1] + \": \" +\n                    majorityElement(inputs[i][0], inputs[i][1]));\n        }\n    }\n\n    public static int majorityElement(int n, int m) {\n        int[] counts = new int[2];\n        for (int i = 0; i < 2; i++) {\n            int count = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i == 0 && (m & (1 << j))) || (i == 1)) {\n                    count++;\n                }\n            }\n            counts[i] = count;\n        }\n\n        return Math.max(counts[0], counts[1]);\n    }\n}\n```",
  "228": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals1 = {{0,1},{2,3},{4,5},{7,8}};\n        System.out.println(Arrays.toString(summaryRanges(intervals1)));\n\n        int[][] intervals2 = {{0,1}};\n        System.out.println(Arrays.toString(summaryRanges(intervals2)));\n\n        int[][] intervals3 = {{0,2},{4,8}};\n        System.out.println(Arrays.toString(summaryRanges(intervals3)));\n    }\n\n    public static String[] summaryRanges(int[] nums) {\n        List<String> result = new ArrayList<>();\n        if (nums.length == 0) return result.toArray(new String[0]);\n\n        int start = nums[0];\n        int end = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == end + 1) {\n                end = nums[i];\n            } else {\n                result.add(start == end ? String.valueOf(end) : start + \"->\" + end);\n                start = nums[i];\n                end = nums[i];\n            }\n        }\n\n        result.add(start == end ? String.valueOf(end) : start + \"->\" + end);\n\n        return result.toArray(new String[0]);\n    }\n}",
  "231": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isPowerOfTwo(8)); // true\n        System.out.println(isPowerOfTwo(10)); // false\n        System.out.println(isPowerOfTwo(16)); // true\n    }\n\n    public static boolean isPowerOfTwo(int n) {\n        return (n > 0) && ((n & (n - 1)) == 0);\n    }\n}\n```",
  "230": "```\npublic class Main {\n    public static void main(String[] args) {\n        BinarySearchTree tree1 = new BinarySearchTree();\n        tree1.add(4);\n        tree1.add(2);\n        tree1.add(6);\n        tree1.add(1);\n        tree1.add(3);\n\n        System.out.println(\"Kth smallest element in BST: \" + kthSmallest(tree1.root, 3));\n\n        BinarySearchTree tree2 = new BinarySearchTree();\n        tree2.add(5);\n        tree2.add(3);\n        tree2.add(4);\n        tree2.add(2);\n        tree2.add(1);\n\n        System.out.println(\"Kth smallest element in BST: \" + kthSmallest(tree2.root, 4));\n\n        BinarySearchTree tree3 = new BinarySearchTree();\n        tree3.add(8);\n        tree3.add(5);\n        tree3.add(10);\n        tree3.add(2);\n        tree3.add(6);\n        tree3.add(1);\n\n        System.out.println(\"Kth smallest element in BST: \" + kthSmallest(tree3.root, 5));\n    }\n\n    public static int kthSmallest(Node root, int k) {\n        List<Integer> result = new ArrayList<>();\n        inorder(root, result);\n        return result.get(k - 1);\n    }\n\n    public static void inorder(Node node, List<Integer> result) {\n        if (node == null) {\n            return;\n        }\n        inorder(node.left, result);\n        result.add(node.val);\n        inorder(node.right, result);\n    }\n\n    static class Node {\n        int val;\n        Node left;\n        Node right;\n\n        public Node(int val) {\n            this.val = val;\n        }\n    }\n}\n```",
  "232": "```\npublic class Main {\n    public static void main(String[] args) {\n        MyQueue queue = new MyQueue();\n        \n        // Test case 1\n        System.out.println(\"Test case 1: \");\n        enqueue(queue, 1);\n        enqueue(queue, 2);\n        enqueue(queue, 3);\n        System.out.println(dequeue(queue));  // Should print 1\n        System.out.println(dequeue(queue));  // Should print 2\n        System.out.println(dequeue(queue));  // Should print 3\n        \n        // Test case 2\n        System.out.println(\"\\nTest case 2: \");\n        for (int i = 1; i <= 5; i++) {\n            enqueue(queue, i);\n        }\n        while (!isEmpty(queue)) {\n            System.out.print(dequeue(queue) + \" \");\n        }\n        \n        // Test case 3\n        System.out.println(\"\\nTest case 3: \");\n        for (int i = 1; i <= 10; i++) {\n            enqueue(queue, i);\n        }\n        while (!isEmpty(queue)) {\n            System.out.print(dequeue(queue) + \" \");\n        }\n    }\n\n    public static void enqueue(MyQueue queue, int item) {\n        queue.stack2.push(item);\n    }\n\n    public static int dequeue(MyQueue queue) {\n        if (isEmpty(queue)) {\n            return -1;\n        }\n        while (!queue.stack1.isEmpty()) {\n            queue.stack2.push(queue.stack1.pop());\n        }\n        return queue.stack1.pop();\n    }\n\n    public static boolean isEmpty(MyQueue queue) {\n        return queue.stack1.isEmpty() && queue.stack2.isEmpty();\n    }\n}\n```",
  "233": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfDigitOne(13)); // Expected output: 6\n        System.out.println(numberOfDigitOne(0)); // Expected output: 1\n        System.out.println(numberOfDigitOne(1000000003)); // Expected output: 1098765432\n    }\n\n    public static int numberOfDigitOne(int n) {\n        if (n < 1) return 0;\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            res += countOne(i);\n        }\n        return res;\n    }\n\n    public static int countOne(int n) {\n        int ones = 0, tens = 0, hundreds = 0;\n        if (n >= 100) {\n            hundreds = n / 100;\n            n %= 100;\n        }\n        if (n >= 10) {\n            tens = n / 10;\n            n %= 10;\n        }\n        ones = n;\n\n        int res = 0;\n        // Count the number of ones in hundreds\n        for (int i = 1; i <= hundreds; i++) res += Math.min(9, 100 - i * 100) + 1;\n\n        if (hundreds > 0) {\n            // Count the number of ones in tens\n            for (int i = 1; i <= tens; i++) res += Math.min(9, 10 - i) * 100 + 1;\n            // Count the number of ones in ones\n            res += Math.min(9, hundreds * 10 + tens) + 1;\n        } else {\n            // Count the number of ones in tens\n            for (int i = 0; i <= tens; i++) res += Math.min(9, 10 - i) + 1;\n            // Count the number of ones in ones\n            res += Math.min(tens, 9) + 1;\n        }\n\n        // Count the number of ones in last digit\n        if (ones > 0) {\n            for (int i = 0; i <= ones; i++) res++;\n        }\n        return res;\n    }\n}",
  "235": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test case 1\n        TreeNode root = new TreeNode(6);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(8);\n        root.left.left = new TreeNode(0);\n        root.left.right = new TreeNode(4);\n        root.right.left = new TreeNode(7);\n        root.right.right = new TreeNode(9);\n        System.out.println(\"Test case 1: \" + lowestCommonAncestor(root, new TreeNode(2), new TreeNode(8)).val);\n\n        // Test case 2\n        root = new TreeNode(4);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(7);\n        root.left.left = new TreeNode(1);\n        root.left.right = new TreeNode(3);\n        System.out.println(\"Test case 2: \" + lowestCommonAncestor(root, new TreeNode(2), new TreeNode(6)).val);\n\n        // Test case 3\n        root = new TreeNode(5);\n        System.out.println(\"Test case 3: \" + lowestCommonAncestor(root, null, new TreeNode(5)).val);\n    }\n\n    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root.val > Math.max(p.val, q.val)) {\n            return lowestCommonAncestor(root.left, p, q);\n        }\n        if (root.val < Math.min(p.val, q.val)) {\n            return lowestCommonAncestor(root.right, p, q);\n        }\n        return root;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "234": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1, new ListNode(2));\n        System.out.println(\"Is palindrome: \" + isPalindrome(head1));\n\n        ListNode head2 = new ListNode(1, new ListNode(2, new ListNode(2, new ListNode(1))));\n        System.out.println(\"Is palindrome: \" + isPalindrome(head2));\n\n        ListNode head3 = new ListNode();\n        System.out.println(\"Is palindrome: \" + isPalindrome(head3));\n    }\n\n    public static boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null) {\n            return true;\n        }\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        reverseList(head);\n        ListNode p1 = head, p2 = slow.next;\n        boolean result = true;\n        while (p2 != null) {\n            if (p1.val != p2.val) {\n                result = false;\n                break;\n            }\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        reverseList(slow);\n        return result;\n    }\n\n    public static ListNode reverseList(ListNode head) {\n        ListNode prev = null, curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int x) {\n        val = x;\n    }\n\n    public ListNode(int x, ListNode next) {\n        val = x;\n        this.next = next;\n    }\n}",
  "236": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(5);\n        root1.right = new TreeNode(1);\n        root1.left.left = new TreeNode(6);\n        root1.left.right = new TreeNode(2);\n        root1.right.left = new TreeNode(0);\n        root1.right.right = new TreeNode(8);\n        root1.left.right.left = new TreeNode(7);\n        root1.left.right.right = new TreeNode(4);\n\n        System.out.println(\"Test case 1: \");\n        System.out.println(\"Root is \" + findLCA(root1, root1.left.left, root1.left.right).val);\n\n        System.out.println(\"\\nTest case 2: \");\n        System.out.println(\"Root is \" + findLCA(root1, root1.right.left, root1.right.right).val);\n\n        System.out.println(\"\\nTest case 3: \");\n        System.out.println(\"Root is \" + findLCA(root1, root1.left, root1.right).val);\n    }\n\n    public static TreeNode findLCA(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root.val == p.val || root.val == q.val) return root;\n\n        TreeNode left = findLCA(root.left, p, q);\n        TreeNode right = findLCA(root.right, p, q);\n\n        if (left != null && right != null) return root;\n        if (left != null) return left;\n        return right;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) { \n        val = x; \n    }\n}\n```",
  "237": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(4);\n        head1.next = new ListNode(5);\n        head1.next.next = new ListNode(1);\n        head1.next.next.next = new ListNode(9);\n\n        deleteNode(head1, 5);\n\n        System.out.println(\"Test Case 1: \");\n        printList(head1);\n\n        ListNode head2 = new ListNode(6);\n        head2.next = new ListNode(7);\n        head2.next.next = new ListNode(8);\n        head2.next.next.next = new ListNode(9);\n        deleteNode(head2, 6);\n        System.out.println(\"Test Case 2: \");\n        printList(head2);\n\n        ListNode head3 = new ListNode(1);\n        head3.next = new ListNode(2);\n        head3.next.next = new ListNode(3);\n        head3.next.next.next = new ListNode(4);\n        deleteNode(head3, 2);\n        System.out.println(\"Test Case 3: \");\n        printList(head3);\n    }\n\n    public static void deleteNode(ListNode head, int val) {\n        if (head == null || head.val != val) return;\n\n        if (head.next == null) return; // only one node in the list\n        head.val = head.next.val;\n        head.next = head.next.next;\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n```",
  "238": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1, 2, 3, 4};\n        int[] result1 = productExceptSelf(nums1);\n        for (int i : result1) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        int[] nums2 = {-1, 0, 1, 10};\n        int[] result2 = productExceptSelf(nums2);\n        for (int i : result2) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        int[] nums3 = [5, 6];\n        int[] result3 = productExceptSelf(nums3);\n        for (int i : result3) {\n            System.out.print(i + \" \");\n        }\n    }\n\n    public static int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n\n        // Left to right\n        int leftProd = 1;\n        for (int i = 0; i < n; i++) {\n            res[i] = leftProd;\n            leftProd *= nums[i];\n        }\n\n        // Right to left\n        int rightProd = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            res[i] *= rightProd;\n            rightProd *= nums[i];\n        }\n        return res;\n    }\n}",
  "239": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        maxSlidingWindow(new int[]{1,3,-1}, 2); // Test case 1: [1,3] (window size 2)\n        maxSlidingWindow(new int[]{1,-1}, 1); // Test case 2: [1] (window size 1)\n        maxSlidingWindow(new int[]{9,8,7,6,5,4,3,2,1}, 3); // Test case 3: [9,8,7,6,5,4,3,2,1] (window size 3)\n    }\n\n    public static List<Integer> maxSlidingWindow(int[] nums, int k) {\n        if(nums.length < k || k <= 0) return new ArrayList<>();\n\n        List<Integer> result = new ArrayList<>();\n        Deque<Integer> queue = new ArrayDeque<>();\n\n        for(int i = 0; i < k; ++i) {\n            while(!queue.isEmpty() && nums[i] >= nums[queue.peek()]) {\n                queue.poll();\n            }\n            queue.offer(i);\n        }\n\n        result.add(nums[queue.peek()]);\n        \n        for(int i = k; i < nums.length; ++i) {\n            if(queue.peekFirst() == i - k) {\n                queue.pollFirst();\n            }\n\n            while(!queue.isEmpty() && nums[i] >= nums[queue.peek()]) {\n                queue.poll();\n            }\n            queue.offer(i);\n            \n            result.add(nums[queue.peek()]);\n        }\n\n        return result;\n    }\n}",
  "241": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numDecodings(\"226\")); // Expected output: 3\n        System.out.println(numDecodings(\"06\")); // Expected output: 2\n        System.out.println(numDecodings(\"0a2bc\"));// Expected output: 1\n    }\n}\n```",
  "240": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(searchMatrix(new int[][]{{1,4,7,11,15},{2,5,8,12,19},{3,6,9,16,22},{10,13,14,17,24},{15,18,21,23,26}}, 5));\n        System.out.println(searchMatrix(new int[][]{{1,4,7,11,15,20}} , 20));\n        System.out.println(searchTarget(new int[][]{{1,3,5,7,9,11,16,20,25,30},{2,4,6,8,10,12,14,17,21,26},{3,5,8,12,15,18,22,24,28,32}}, 12));\n    }\n\n    public static int searchMatrix(int[][] matrix, int target) {\n        if(matrix.length == 0 || matrix[0].length == 0)\n            return -1;\n        \n        int row = 0, col = matrix[0].length - 1;\n        \n        while(row < matrix.length && col >= 0){\n            if(matrix[row][col] == target)\n                return 1;\n            \n            else if(matrix[row][col] > target) \n                col--;\n            else\n                row++;\n        }\n        \n        return -1;\n    }\n}",
  "242": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isAnagram(\"anagram\", \"nagaram\")); // true\n        System.out.println(isAnagram(\"listen\", \"silent\")); // true\n        System.out.println(isAnagram(\"hello\", \"world\")); // false\n    }\n\n    public static boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) {\n            return false;\n        }\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n            count[t.charAt(i) - 'a']--;\n        }\n        for (int i : count) {\n            if (i != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "243": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(shortestWordDistance(new String[]{\"apple\", \"banana\", \"orange\"}, \"apple\", \"banana\") + \"\\n\");\n        System.out.println(shortestWordDistance(new String[]{\"a\", \"b\"], \"a\", \"b\") + \"\\n\");\n        System.out.println(shortestWordDistance(new String[]{\"apple\", \"banana\", \"apple\"}, \"banana\", \"apple\") + \"\\n\");\n    }\n\n    public static int shortestWordDistance(String[] words, String word1, String word2) {\n        int minDist = Integer.MAX_VALUE;\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].equals(word1)) {\n                for (int j = i + 1; j < words.length; j++) {\n                    if (words[j].equals(word2)) {\n                        minDist = Math.min(minDist, j - i);\n                        break;\n                    }\n                }\n            } else if (words[i].equals(word2)) {\n                for (int j = i - 1; j >= 0; j--) {\n                    if (words[j].equals(word1)) {\n                        minDist = Math.min(minDist, i - j);\n                        break;\n                    }\n                }\n            }\n        }\n        return minDist == Integer.MAX_VALUE ? 0 : minDist;\n    }\n}\n```",
  "244": "```\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public int shortestWordDistance(String[] words, String word1, String word2) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            map.put(words[i], i);\n        }\n        \n        int index1 = map.get(word1);\n        int index2 = map.get(word2);\n\n        if (word1.equals(word2)) {\n            return Math.abs(index1 - index2);\n        } else {\n            int distance1 = Math.abs(index1 - index2);\n            int distance2 = 0;\n            for (int i = 0; i < words.length; i++) {\n                if (words[i].equals(word1) || words[i].equals(word2)) {\n                    continue;\n                }\n                if (i < index1) {\n                    distance2 = Math.min(distance2, index1 - i);\n                } else {\n                    distance2 = Math.min(distance2, i - index2);\n                }\n            }\n            return Math.min(distance1, distance2);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words1 = {\"Practice\", \"Makes\", \"Perfect\", \"Coding\", \"Makes\"};\n        System.out.println(solution.shortestWordDistance(words1, \"Makes\", \"Coding\"));  // Output: 3\n\n        String[] words2 = {\"Assume\", \"virtual\", \"Director\", \"you\", \"are\", \"an\", \"actor\", \"and\", \"your\", \"life\", \"is\", \"a\", \"movie\"};\n        System.out.println(solution.shortestWordDistance(words2, \"movie\", \"actor\"));  // Output: 7\n\n        String[] words3 = {\"Hello\", \"World\", \"This\", \"Is\", \"A\", \"Test\", \"World\", \"Test\", \"Again\", \"Goodbye\"};\n        System.out.println(solution.shortestWordDistance(words3, \"World\", \"Goodbye\"));  // Output: 4\n    }\n}",
  "245": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] words = {{\"apple\", \"banana\", \"orange\"}, {\"apple\", \"pen\", \"banana\", \"pineapple\"}, {\"apple\"}};\n        System.out.println(shortestDistance(words, \"banana\")); // 1\n        System.out.println(shortestDistance(words, \"apple\")); // 0\n        System.out.println(shortestDistance(words, \"pineapple\")); // -1\n    }\n\n    public static int shortestDistance(int[][] words, String target) {\n        int minDist = Integer.MAX_VALUE;\n        for (int i = 0; i < words.length; i++) {\n            for (String word : words[i]) {\n                if (word.equals(target)) {\n                    for (int j = 0; j < words.length; j++) {\n                        if (i != j) {\n                            for (String w : words[j]) {\n                                if (w.equals(target)) {\n                                    minDist = Math.min(minDist, Math.abs(i - j));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return minDist == Integer.MAX_VALUE ? -1 : minDist;\n    }\n}\n```",
  "246": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isStrobogrammatic(0)); // true\n        System.out.println(isStrobogrammatic(12321)); // true\n        System.out.println(isStrobogrammatic(2469)); // false\n    }\n\n    public static boolean isStrobogrammatic(int num) {\n        Map<Character, Character> map = new HashMap<>();\n        map.put('0', '0');\n        map.put('1', '1');\n        map.put('6', '9');\n        map.put('9', '6');\n        map.put('8', '8');\n\n        while (num > 0) {\n            int digit = num % 10;\n            if (!map.containsKey(String.valueOf(digit)) && !String.valueOf(digit).equals(\"0\")) {\n                return false;\n            }\n            num /= 10;\n        }\n\n        return true;\n    }\n}",
  "247": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isStrobogrammatic(\"12321\")); // true\n        System.out.println(isStrobogrammatic(\"234\"));   // false\n        System.out.println(isStrobogrammatic(\"0\"));      // true\n    }\n\n    public static boolean isStrobogrammatic(String num) {\n        Map<Character, Character> mapping = new HashMap<>();\n        mapping.put('0', '0');\n        mapping.put('1', '1');\n        mapping.put('6', '9');\n        mapping.put('9', '6');\n\n        int left = 0;\n        int right = num.length() - 1;\n\n        while (left < right) {\n            if (!mapping.containsKey(num.charAt(left)) || !mapping.containsValue(num.charAt(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n}",
  "248": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isStrobogrammatic(\"9\")); // true\n        System.out.println(isStrobogrammatic(\"88190\")); // false\n        System.out.println(isStrobogrammatic(\"123021\")); // false\n    }\n\n    public static boolean isStrobogrammatic(String num) {\n        return isStrobogrammatic(num, 0, num.length() - 1);\n    }\n\n    private static boolean isStrobogrammatic(String num, int left, int right) {\n        if (left > right)\n            return true;\n        switch (num.charAt(left)) {\n            case '0':\n                return num.charAt(right) == '0' && isStrobogrammatic(num, left + 1, right - 1);\n            case '8':\n                return num.charAt(right) == '8' && isStrobogrammatic(num, left + 1, right - 1);\n            case '6':\n                return (num.charAt(right) == '9' || num.charAt(right) == '6') && isStrobogrammatic(num, left + 1, right - 1);\n            case '9':\n                return (num.charAt(right) == '6' || num.charAt(right) == '9') && isStrobogrammatic(num, left + 1, right - 1);\n            default:\n                return false;\n        }\n    }\n}\n```",
  "249": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        String[] strings1 = {\"abc\", \"bcd\", \"xyz\"};\n        List<List<String>> result1 = groupStrings(strings1);\n        for (List<String> list : result1) {\n            System.out.println(list);\n        }\n        System.out.println();\n\n        System.out.println(\"Test Case 2:\");\n        String[] strings2 = {\"a1b2\", \"3z4\", \"apq\"};\n        List<List<String>> result2 = groupStrings(strings2);\n        for (List<String> list : result2) {\n            System.out.println(list);\n        }\n        System.out.println();\n\n        System.out.println(\"Test Case 3:\");\n        String[] strings3 = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqr\", \"stu\", \"vwx\", \"yz\"];\n        List<List<String>> result3 = groupStrings(strings3);\n        for (List<String> list : result3) {\n            System.out.println(list);\n        }\n    }\n\n    public static List<List<String>> groupStrings(String[] strings) {\n        // your solution here\n    }\n}\n```",
  "250": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countUnivalues(new TreeNode(1), true));\n        System.out.println(countUnivalues(null, false));\n        System.out.println(countUnivalues(new TreeNode(0,null,null), false));\n    }\n\n    public static int countUnivalues(TreeNode root, boolean expected) {\n        int result = 0;\n        dfs(root, root.val, expected, result);\n        return result;\n    }\n\n    private static void dfs(TreeNode node, int val, boolean expected, int result) {\n        if (node == null) {\n            return;\n        }\n        if (node.val != val && !expected) {\n            result++;\n            return;\n        }\n        if (node.left != null && node.left.val != val && !expected) {\n            result++;\n        }\n        if (node.right != null && node.right.val != val && !expected) {\n            result++;\n        }\n        dfs(node.left, node.left == null ? 0 : node.left.val, node.val == node.left.val, result);\n        dfs(node.right, node.right == null ? 0 : node.right.val, node.val == node.right.val, result);\n    }\n\n    static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        public TreeNode(int val) {\n            this.val = val;\n        }\n    }\n}",
  "251": "```\npublic class Main {\n    public static void main(String[] args) {\n        Vector2D vec1 = new Vector2D(1, 2);\n        vec1.add(3).add(4);\n\n        System.out.println(\"Test Case 1: \");\n        Iterator<Vector2D> it1 = vec1.iterator();\n        while (it1.hasNext()) {\n            Vector2D v = it1.next();\n            System.out.print(\"(\" + v.x + \", \" + v.y + \") \");\n        }\n        System.out.println();\n\n        Vector2D vec2 = new Vector2D(5, 6);\n        vec2.add(7).add(8);\n\n        System.out.println(\"Test Case 2: \");\n        Iterator<Vector2D> it2 = vec2.iterator();\n        while (it2.hasNext()) {\n            Vector2D v = it2.next();\n            System.out.print(\"(\" + v.x + \", \" + v.y + \") \");\n        }\n        System.out.println();\n\n        Vector2D vec3 = new Vector2D(1, 2);\n        vec3.add(3).add(4).add(5);\n\n        System.out.println(\"Test Case 3: \");\n        Iterator<Vector2D> it3 = vec3.iterator();\n        while (it3.hasNext()) {\n            Vector2D v = it3.next();\n            System.out.print(\"(\" + v.x + \", \" + v.y + \") \");\n        }\n        System.out.println();\n    }\n}\n```",
  "252": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals1 = {{0,30},{5,10},{15,20}};\n        System.out.println(canAttendMeetings(intervals1)); // Expected output: false\n\n        int[][] intervals2 = {{7,10},{2,4}};\n        System.out.println(canAttendMeetings(intervals2)); // Expected output: true\n\n        int[][] intervals3 = {{0,29},{30,40},{57,60},{91,100}};\n        System.out.println(canAttendMeetings(intervals3)); // Expected output: false\n    }\n\n    public static boolean canAttendMeetings(int[][] intervals) {\n        if (intervals == null || intervals.length == 0) return true;\n\n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n\n        for (int i = 0; i < intervals.length - 1; i++) {\n            if (intervals[i][1] > intervals[i + 1][0]) return false;\n        }\n\n        return true;\n    }\n}\n```",
  "253": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] intervals = {{0,30},{5,10},{15,20}};\n        System.out.println(\"Expected: 2\");\n        System.out.println(\"Actual: \" + minMeetingRooms(intervals));\n        \n        int[][] intervals1 = {{7,10},{2,4}};\n        System.out.println(\"Expected: 1\");\n        System.out.println(\"Actual: \" + minMeetingRooms(intervals1));\n        \n        int[][] intervals2 = {{0,30},{5,15},{8,22},{16,25}};\n        System.out.println(\"Expected: 3\");\n        System.out.println(\"Actual: \" + minMeetingRooms(intervals2));\n    }\n\n    public static int minMeetingRooms(int[][] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        \n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> a - b);\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        \n        int rooms = 0;\n        for (int[] interval : intervals) {\n            if (!queue.isEmpty() && queue.peek() <= interval[0]) {\n                queue.poll();\n            }\n            queue.offer(interval[1]);\n            rooms = Math.max(rooms, queue.size());\n        }\n        \n        return rooms;\n    }\n}",
  "254": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int n1 = 12;\n        System.out.println(\"Test case 1: \" + getFactors(n1));\n        \n        int n2 = 7;\n        System.out.println(\"Test case 2: \" + getFactors(n2));\n\n        int n3 = 36;\n        System.out.println(\"Test case 3: \" + getFactors(n3));\n    }\n\n    public static List<List<Integer>> getFactors(int n) {\n        // Your code here\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                int start = i;\n                int end = n / i;\n                while (start <= end) {\n                    List<Integer> factors = new ArrayList<>();\n                    for (int j = start; j <= end; j++) {\n                        if (j * i > n) break;\n                        factors.add(j);\n                    }\n                    result.add(factors);\n                    start++;\n                }\n            }\n        }\n        return result;\n    }\n}\n```",
  "256": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] house1 = {{17,2,5},{14,7,11},{13,10,13}};\n        System.out.println(\"Test case 1: \" + minCostToPaintHouse(house1));\n        \n        int[][] house2 = {{0,0,0},{3,4,2},{2,6,3}};\n        System.out.println(\"Test case 2: \" + minCostToPaintHouse(house2));\n\n        int[][] house3 = {{36,76,84},{72,79,66},{94,85,81}};\n        System.out.println(\"Test case 3: \" + minCostToPaintHouse(house3));\n    }\n\n    public static int minCostToPaintHouse(int[][] houses) {\n        if (houses.length == 1) {\n            return Math.min(houses[0][0], houses[0][1]);\n        }\n        \n        for (int i = 2; i < houses.length; i++) {\n            houses[i][0] += Math.min(houses[i-1][1], houses[i-1][2]);\n            houses[i][1] += Math.min(houses[i-1][0], houses[i-1][2]);\n            houses[i][2] += Math.min(houses[i-1][0], houses[i-1][1]);\n        }\n        \n        return Math.min(houses[0][0], Math.min(houses[0][1], houses[0][2]));\n    }\n}",
  "255": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] preorder1 = {5, 2, 6, 1, 4};\n        System.out.println(solution.verifyPreorder(preorder1)); // Expected output: true\n\n        int[] preorder2 = {1, 4, 2, 6, 5, 3};\n        System.out.println(solution.verifyPreorder(preorder2)); // Expected output: false\n\n        int[] preorder3 = {1, 2, null, null, 3, 4, 5};\n        System.out.println(solution.verifyPreorder(preorder3)); // Expected output: true\n    }\n}\n\nclass Solution {\n    public boolean verifyPreorder(int[] preorder) {\n        return canMakeBST(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n\n    private boolean canMakeBST(int[] preorder, int minVal, int maxVal) {\n        for (int val : preorder) {\n            if (!isValid(val, minVal, maxVal)) {\n                return false;\n            }\n            if (val > maxVal) {\n                return false;\n            }\n            maxVal = val;\n            int leftIndex = findLeftIndex(preorder, 0, preorder.length - 1, maxVal);\n            if (leftIndex == -1) {\n                return true;\n            }\n            minVal = preorder[leftIndex];\n        }\n        return true;\n    }\n\n    private boolean isValid(int val, int minVal, int maxVal) {\n        return val > minVal && val < maxVal;\n    }\n\n    private int findLeftIndex(int[] preorder, int start, int end, int val) {\n        for (int i = start; i <= end; i++) {\n            if (preorder[i] >= val) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```",
  "258": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(addDigits(38)); // Expected output: 2\n        System.out.println(addDigits(9)); // Expected output: 9\n        System.out.println(addDigits(493782834)); // Expected output: 2\n    }\n\n    public static int addDigits(int num) {\n        while (num > 9) {\n            num = getSumOfDigits(num);\n        }\n        return num;\n    }\n\n    public static int getSumOfDigits(int n) {\n        int sum = 0;\n        while (n != 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n```",
  "257": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(5);\n\n        System.out.println(binaryTreePaths(root1));\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(2);\n        root2.left.left = new TreeNode(5);\n\n        System.out.println(binaryTreePaths(root2));\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n\n        System.out.println(binaryTreePaths(root3));\n    }\n\n    public static List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        if (root == null) return result;\n        \n        dfs(root, \"\", result);\n        \n        return result;\n    }\n    \n    private static void dfs(TreeNode node, String path, List<String> result) {\n        if (node.left == null && node.right == null) {\n            result.add(path + node.val);\n            return;\n        }\n        \n        if (node.left != null) dfs(node.left, path + node.val + \"->\", result);\n        if (node.right != null) dfs(node.right, path + node.val + \"->\", result);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "259": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums1 = {{1,2,3},{-1,-2,-3}};\n        for (int[] num : nums1) {\n            System.out.println(threeSumSmaller(num, 2));\n        }\n\n        int[][] nums2 = {{0,4,-3,2,1},{-1,2,1,4}};\n        for (int[] num : nums2) {\n            System.out.println(threeSumSmaller(num, 5));\n        }\n        \n        int[][] nums3 = {{0,-4,-2,2,-2,2}};\n        for (int[] num : nums3) {\n            System.out.println(threeSumSmaller(num, -1));\n        }\n    }\n\n    public static int threeSumSmaller(int[] nums, int target) {\n        int ans = 0;\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length; i++) {\n            int left = i + 1;\n            int right = nums.length - 1;\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n                if (sum < target) {\n                    ans += (right - left);\n                    left++;\n                    right--;\n                } else {\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n}",
  "260": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2,4,3,5,7,8,3};\n        System.out.println(\"Single number in array: \" + singleNumber(nums1));\n\n        int[] nums2 = {2,7,11,8,1,3};\n        System.out.println(\"Single number in array: \" + singleNumber(nums2));\n\n        int[] nums3 = {2,2,3,2};\n        System.out.println(\"Single number in array: \" + singleNumber(nums3));\n    }\n\n    public static int singleNumber(int[] nums) {\n        int ones = 0;\n        int twos = 0;\n\n        for (int num : nums) {\n            twos = twos ^ (twos & num);\n            ones = ones ^ num;\n        }\n\n        return (ones & ~(twos ^ ones)) | (~ones & ~twos & (ones ^ twos));\n    }\n}",
  "261": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] edges1 = {{0,1},{1,2},{2,3},{1,3}};\n        System.out.println(canBeValidTree(4, edges1));\n        \n        int[][] edges2 = {{0,1},{1,2},{2,3},{3,4},{3,5},{2,5}};\n        System.out.println(canBeValidTree(6, edges2));\n        \n        int[][] edges3 = {{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9},{9,10}};\n        System.out.println(canBeValidTree(11, edges3));\n    }\n\n    public static boolean canBeValidTree(int n, int[][] edges) {\n        if (edges.length < n - 1) return false;\n        \n        List<Integer>[] adj = new ArrayList[n];\n        for (int i = 0; i < n; i++) \n            adj[i] = new ArrayList();\n        \n        for (int[] edge : edges) {\n            int a = edge[0], b = edge[1];\n            if (a >= n || b >= n || a < 0 || b < 0) return false;\n            \n            adj[a].add(b);\n            adj[b].add(a);\n        }\n        \n        for (int i = 0; i < n; i++) \n            if (!dfs(adj, new boolean[n], i)) return false;\n        \n        return true;\n    }\n\n    public static boolean dfs(List<Integer>[] adj, boolean[] visited, int node) {\n        if (visited[node]) return true;\n        visited[node] = true;\n        \n        for (int neighbor : adj[node])\n            if (!dfs(adj, visited, neighbor)) return false;\n        \n        return true;\n    }\n}\n```",
  "262": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        System.out.println(solution.trips(new String[][]{{\"John\", \"New York\"}, {\"John\", \"New York\"}}, 2, 3));\n        \n        // Test case 2\n        System.out.println(solution.trips(new String[][]{{\"Jane\", \"NYC\"}, {\"Alice\", \"NYC\"}}, 1, 2));\n        \n        // Test case 3\n        System.out.println(solution.trips(new String[][]{}, 1, 1));\n    }\n}\n```",
  "263": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isUgly(6)); // true\n        System.out.println(isUgly(8)); // false\n        System.out.println(isUgly(14)); // false\n    }\n\n    public static boolean isUgly(int n) {\n        if (n <= 0) return false;\n        while (n % 2 == 0) n /= 2;\n        while (n % 3 == 0) n /= 3;\n        while (n % 5 == 0) n /= 5;\n        return n == 1;\n    }\n}\n```",
  "264": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(nthSuperUgly(1690)); // Output: 12\n        System.out.println(nthSuperUgly(1)); // Output: 1\n        System.out.println(nthSuperUgly(2)); // Output: 2\n    }\n\n    public static int nthSuperUgly(int n) {\n        int[] primes = {2, 3, 5};\n        List<Integer> ugly = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int min = Integer.MAX_VALUE;\n            for (int prime : primes) {\n                while (!ugly.isEmpty() && ugly.get(0) <= i / prime * prime) {\n                    ugly.remove(0);\n                }\n                if (i % prime == 0) {\n                    min = Math.min(min, prime);\n                } else {\n                    min = Math.min(min, i % prime);\n                }\n            }\n            ugly.add(min);\n        }\n        return ugly.get(n - 1);\n    }\n}\n```",
  "265": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] cost1 = {{14,2,15},{11,5,12},{4,3,9},{8,7,6},{8,6,7}};\n        System.out.println(\"Expected: 10, Actual: \" + houseRobbery(cost1));\n        \n        int[][] cost2 = {{1,2,3},{3,4,5}};\n        System.out.println(\"Expected: 6, Actual: \" + houseRobbery(cost2));\n        \n        int[][] cost3 = {{1,2}};\n        System.out.println(\"Expected: 2, Actual: \" + houseRobbery(cost3));\n    }\n\n    public static int houseRobbery(int[][] nums) {\n        if (nums.length == 0) return 0;\n        if (nums.length == 1) return Math.max(nums[0][0], 0);\n\n        int[] dp = new int[nums.length];\n        dp[0] = Math.max(nums[0][0], 0);\n        for (int i = 1; i < nums.length; i++) {\n            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i][0]);\n        }\n        return dp[nums.length - 1];\n    }\n}",
  "266": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canPermutePalindrome(\"carerac\")); // true\n        System.out.println(canPermutePalindrome(\"abc\")); // false\n        System.out.println(canPermutePalindrome(\"a\")); // true\n    }\n\n    public static boolean canPermutePalindrome(String s) {\n        int[] charCount = new int[256];\n        for (char c : s.toLowerCase().toCharArray()) {\n            charCount[c]++;\n        }\n        int oddCount = 0;\n        for (int count : charCount) {\n            if (count % 2 != 0) {\n                oddCount++;\n            }\n            if (oddCount > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "268": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {0, 1, 2, 4};\n        System.out.println(\"Missing number for array 1: \" + missingNumber(nums1));\n        \n        int[] nums2 = {0, 2, 3];\n        System.out.println(\"Missing number for array 2: \" + missingNumber(nums2));\n\n        int[] nums3 = {0, 1};\n        System.out.println(\"Missing number for array 3: \" + missingNumber(nums3));\n    }\n\n    public static int missingNumber(int[] nums) {\n        int n = nums.length;\n        int expectedSum = (n * (n + 1)) / 2;\n        int actualSum = 0;\n        for (int num : nums) {\n            actualSum += num;\n        }\n        return expectedSum - actualSum;\n    }\n}",
  "267": "```\nimport java.util.*;\n\nclass Solution {\n    public List<String> generatePalindromesfromKeys(String S) {\n        List<String> result = new ArrayList<>();\n        backtrack(S, \"\", new boolean[256], result);\n        return result;\n    }\n\n    private void backtrack(String s, String cur, boolean[] used, List<String> result) {\n        if (s.length() == 0 && cur.length() > 0) {\n            result.add(new StringBuilder(cur).reverse().toString());\n            return;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (!used[c]) {\n                used[c] = true;\n                backtrack(s.substring(0, i) + s.substring(i + 1), cur + c, used, result);\n                used[c] = false;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.generatePalindromesfromKeys(\"a\"));\n        System.out.println(solution.generatePalindromesfromKeys(\"aab\"));\n        System.out.println(solution.generatePalindromesfromKeys(\"abc\"));\n    }\n}",
  "269": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(findOrder(\"winked\", new String[]{\"winked\",\"wodon'tbelieve\",\"be\",\"have\",\"believe\",\"not\"}));\n        System.out.println(findOrder(\"kiqzpxoyv\", new String[]{\"k\",\"io\",\"qzp\",\"yv\"}));\n        System.out.println(findOrder(\"\", new String[]{}));\n    }\n\n    public static List<String> findOrder(String alienW\u00f6rterbuch, String[] words) {\n        // Your code here\n    }\n}\n```",
  "270": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(2);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(4);\n\n        System.out.println(\"Test case 1: \" + closestValue(root, 3.5)); // Output: 2\n        System.out.println(\"Test case 2: \" + closestValue(root, 0.5)); // Output: 1\n        System.out.println(\"Test case 3: \" + closestValue(root, 5.5)); // Output: 4\n\n    }\n\n    public static double closestValue(TreeNode root, double target) {\n        double minDiff = Double.MAX_VALUE;\n        double closestVal = 0;\n\n        while (root != null) {\n            int diffLeft = Math.abs(target - root.left.val);\n            int diffRight = Math.abs(target - root.right.val);\n\n            if (diffLeft < minDiff) {\n                minDiff = diffLeft;\n                closestVal = root.left.val;\n            }\n            if (diffRight < minDiff) {\n                minDiff = diffRight;\n                closestVal = root.right.val;\n            }\n\n            if (Math.abs(target - root.val) < minDiff) {\n                minDiff = Math.abs(target - root.val);\n                closestVal = root.val;\n            }\n\n            if (target > root.val) {\n                root = root.right;\n            } else if (target < root.val) {\n                root = root.left;\n            } else {\n                return (double) target;\n            }\n        }\n        return closestVal;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) { val = x; }\n}\n```",
  "271": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String encoded1 = solution.encode(\"Hello\");\n        System.out.println(\"Encoded: \" + encoded1);\n        System.out.println(\"Decoded: \" + solution.decode(encoded1));\n\n        String encoded2 = solution.encode(\"World\");\n        System.out.println(\"Encoded: \" + encoded2);\n        System.out.println(\"Decoded: \" + solution.decode(encoded2));\n\n        String encoded3 = solution.encode(\"Hello World\");\n        System.out.println(\"Encoded: \" + encoded3);\n        System.out.println(\"Decoded: \" + solution.decode(encoded3));\n    }\n}\n\nclass Solution {\n    public String encode(String s) {\n        // Your code here\n    }\n\n    public String decode(String s) {\n        // Your code here\n    }\n}\n```",
  "272": "```\nimport java.util.*;\n\npublic class Solution {\n    public int closestValue(TreeNode root, double target) {\n        int res = root.val;\n        while (root != null) {\n            if (Math.abs(root.val - target) < Math.abs(res - target)) {\n                res = root.val;\n            }\n            root = root.val < target ? root.right : root.left;\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1\n        TreeNode root1 = new TreeNode(2);\n        root1.right = new TreeNode(4);\n        root1.left = new TreeNode(3);\n        System.out.println(\"Test Case 1: \" + solution.closestValue(root1, 2.5));  // Output: 2\n\n        // Test Case 2\n        TreeNode root2 = new TreeNode(1);\n        root2.right = new TreeNode(3);\n        root2.left = new TreeNode(2);\n        System.out.println(\"Test Case 2: \" + solution.closestValue(root2, 2.11));  // Output: 2\n\n        // Test Case 3\n        TreeNode root3 = new TreeNode(4);\n        root3.right = new TreeNode(7);\n        root3.left = new TreeNode(2);\n        System.out.println(\"Test Case 3: \" + solution.closestValue(root3, 5.78));  // Output: 7\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "273": "```\npublic class Main {\n    public static void main(String[] args) {\n        int num1 = 123;\n        System.out.println(numberToWords(num1)); // Should print \"One Hundred Twenty Three\"\n\n        int num2 = 9;\n        System.out.println(numberToWords(num2)); // Should print \"Nine\"\n\n        int num3 = 0;\n        System.out.println(numberToWords(num3)); // Should print \"Zero\"\n    }\n\n    public static String numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n        String[] ones = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n        String[] teens = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n        String[] tens = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n\n        if (num < 10) return ones[num];\n        if (num < 20) return teens[num - 10];\n        if (num < 100) return tens[num / 10] + (\" \" + numberToWords(num % 10));\n\n        String[] hundreds = {\"\", \"One Hundred\", \"Two Hundred\", \"Three Hundred\", \"Four Hundred\", \"Five Hundred\", \"Six Hundred\", \"Seven Hundred\", \"Eight Hundred\", \"Nine Hundred\"};\n        if (num < 100) return hundreds[num / 100] + (\" Zero\");\n        return hundreds[num / 100] + (\" \" + numberToWords(num % 100));\n    }\n}\n```",
  "274": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] cite = {3, 0, 6, 1, 5};\n        System.out.println(hIndex(cite)); // Test case 1: Expected output is 3\n\n        cite = new int[]{1, 3, 12};\n        System.out.println(hIndex(cite)); // Test case 2: Expected output is 3\n\n        cite = new int[]{0, 1, 3, 5, 6};\n        System.out.println(hIndex(cite)); // Test case 3: Expected output is 3\n    }\n\n    public static int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        for (int i = 0; i < citations.length; i++) {\n            if (citations[i] < (1 + i)) return i;\n        }\n        return citations.length;\n    }\n}",
  "275": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] citations = new int[]{0, 1, 3, 6, 3};\n        System.out.println(hIndex(citations)); // Output: 3\n\n        citations = new int[]{4, 0, 6, 1, 5};\n        System.out.println(hIndex(citations)); // Output: 3\n\n        citations = new int[]{8, 2, 12, 3};\n        System.out.println(hIndex(citations)); // Output: 4\n    }\n\n    public static int hIndex(int[] citations) {\n        Arrays.sort(citations);\n        for (int i = citations.length - 1; i >= 0; i--) {\n            if (citations[i] < i + 1) {\n                return i;\n            }\n        }\n        return citations.length - 1;\n    }\n}\n```",
  "276": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minFlips(new int[]{0,0,0,1},2));\n        System.out.println(minFlips(new int[]{0,1,0},4));\n        System.out.println(minFlips(new int[]{1,0,0,1,0,1,0},5));\n    }\n\n    public static int minFlips(int[] fence, int n) {\n        int res = 0;\n        if(fence[0] == 0)\n            res++;\n        for(int i = 1; i < n-1; i++){\n            if((fence[i-1]^fence[i]) != 0){\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```",
  "278": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(firstBadVersion(2)); // 1\n        System.out.println(firstBadVersion(5)); // 4\n        System.out.println(firstBadVersion(10)); // 9\n    }\n\n    public static int firstBadVersion(int n) {\n        int start = 1;\n        int end = n;\n\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (isBadVersion(mid)) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n\n        return start;\n    }\n\n    // This method is not implemented in this problem\n    public static boolean isBadVersion(int version) {\n        return false; // Replace with your actual logic\n    }\n}\n```",
  "277": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n = 3;\n        boolean[][] known = {\n                {true, true, false},\n                {false, true, true},\n                {false, false, true}\n        };\n        \n        Celebrity celebrity = findCelebrity(n, known);\n        if (celebrity != -1) {\n            System.out.println(\"The celebrity is: \" + celebrity);\n        } else {\n            System.out.println(\"No celebrity found.\");\n        }\n    }\n\n    public static int findCelebrity(int n, boolean[][] known) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((i != j && !known[i][j])) {\n                    return -1;\n                }\n                if (i == j || (!known[j][i])) {\n                    continue;\n                }\n                known[i][j] = false;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((i != j && known[i][j])) {\n                    return -1;\n                }\n            }\n        }\n        return n - 1;\n    }\n}\n```",
  "279": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numSquares(12) == 3 ? \"Pass\" : \"Fail\");\n        System.out.println(numSquares(13) == 2 ? \"Pass\" : \"Fail\");\n        System.out.println(numSquares(1) == 1 ? \"Pass\" : \"Fail\");\n    }\n\n    public static int numSquares(int n) {\n        int[] dp = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            int minPath = Integer.MAX_VALUE;\n            for (int j = 1; j * j <= i; j++) {\n                if (i - j * j >= 0) {\n                    minPath = Math.min(minPath, dp[i - j * j] + 1);\n                }\n            }\n            dp[i] = minPath;\n        }\n        return dp[n];\n    }\n}\n```",
  "280": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] tests = {\n            {{1}, null},\n            {{3,4,2,7,6,5}, [2,7,4,3,1,6]},\n            {{1,5,1,9,8,3}, [1,9,3,5,8,2]}\n        };\n        \n        for (int i = 0; i < tests.length; i++) {\n            int[][] nums = tests[i][0];\n            if (nums != null) {\n                wiggleSort(nums);\n                System.out.println(Arrays.toString(nums));\n            }\n        }\n    }\n\n    public static void wiggleSort(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            if ((i % 2 == 0 && nums[i] <= nums[i - 1]) || \n                (i % 2 != 0 && nums[i] >= nums[i - 1])) {\n                int temp = nums[i];\n                nums[i] = nums[i - 1];\n                nums[i - 1] = temp;\n                i--;\n            }\n        }\n    }\n}",
  "282": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(addOperators(\"123\", 6)); // Expected: [1,2+3]\n        System.out.println(addOperators(\"45+2*\", \"7\")); // Expected: [4*5+2,45+2*7]\n        System.out.println(addOperators(\"0000\", 0)); // Expected: [0]\n    }\n\n    public static List<String> addOperators(String num, int target) {\n        // Your code here\n    }\n}\n```",
  "281": "```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ZigzagIterator {\n    private List<Integer> list1;\n    private List<Integer> list2;\n    private boolean flag;\n\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n        this.list1 = v1;\n        this.list2 = v2;\n        flag = true;\n    }\n\n    public int next() {\n        if (flag && !list1.isEmpty()) {\n            return list1.remove(0);\n        } else if (!flag && !list2.isEmpty()) {\n            return list2.remove(0);\n        }\n        if (list1.isEmpty()) {\n            while (!list2.isEmpty()) {\n                list1.add(list2.remove(0));\n            }\n            flag = false;\n        } else if (list2.isEmpty()) {\n            while (!list1.isEmpty()) {\n                list2.add(list1.remove(0));\n            }\n            flag = true;\n        }\n        return -1;\n    }\n\n    public boolean hasNext() {\n        return !list1.isEmpty() || !list2.isEmpty();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> v1 = new ArrayList<>();\n        List<Integer> v2 = new ArrayList<>();\n\n        v1.add(3);\n        v1.add(9);\n\n        v2.add(-10);\n        v2.add(-5);\n        v2.add(-3);\n\n        ZigzagIterator solution = new ZigzagIterator(v1, v2);\n\n        System.out.println(\"Test case 1: \" + solution.next()); // prints -3\n        System.out.println(\"Has next? \" + solution.hasNext()); // prints true\n\n        System.out.println(\"Test case 2: \" + solution.next()); // prints 9\n        System.out.println(\"Has next? \" + solution.hasNext()); // prints true\n\n        System.out.println(\"Test case 3: \" + solution.next()); // prints -5\n        System.out.println(\"Has next? \" + solution.hasNext()); // prints false\n    }\n}",
  "283": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] testCases = {\n            {{0,1,0,3,12}, [0,1,3,12]},\n            {{0,0,0,0,0}, [0]},\n            {{1,0,1,0,1}, [1,0,1,0,1]}\n        };\n\n        for (int[] testCase : testCases) {\n            int[] nums = testCase[0];\n            int[] expected = testCase[1];\n\n            moveZeroes(nums);\n\n            boolean pass = true;\n            for (int i = 0; i < nums.length; i++) {\n                if (nums[i] != expected[i]) {\n                    pass = false;\n                    break;\n                }\n            }\n\n            System.out.println(\"Test case passed: \" + pass);\n        }\n    }\n\n    public static void moveZeroes(int[] nums) {\n        int nonZeroIndex = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != 0) {\n                nums[nonZeroIndex++] = nums[i];\n            } else {\n                if (i < nonZeroIndex) {\n                    nums[i] = 0;\n                }\n            }\n        }\n\n        while (nonZeroIndex < nums.length) {\n            nums[nonZeroIndex++] = 0;\n        }\n    }\n}\n```",
  "284": "```\npublic class Main {\n    public static void main(String[] args) {\n        PeekingIterator iterator = new PeekingIterator(new int[]{1, 2, 3});\n        System.out.println(iterator.peek()); // prints 1\n        System.out.println(iterator.next()); // prints 1\n        System.out.println(iterator.hasNext()); // prints false\n\n        iterator = new PeekingIterator(new int[]{1, 2, 3, 4});\n        while (iterator.hasNext()) {\n            System.out.println(iterator.peek());\n            System.out.println(iterator.next());\n        }\n\n        iterator = new PeekingIterator(new int[]{1, 2, 3, 4, 5, 6});\n        for (int i = 0; i < 6; i++) {\n            System.out.println(iterator.next()); // prints 1 then 2 to 6\n        }\n    }\n}\n\nclass PeekingIterator implements Iterator<Integer> {\n    private final Iterator<Integer> iterator;\n    private Integer peeked;\n\n    public PeekingIterator(Iterator<Integer> iterator) {\n        this.iterator = iterator;\n    }\n\n    @Override\n    public boolean hasNext() {\n        if (peeked != null) {\n            return true;\n        }\n        if (!iterator.hasNext()) {\n            return false;\n        }\n        peeked = iterator.next();\n        return true;\n    }\n\n    @Override\n    public Integer next() {\n        if (peeked != null) {\n            Integer result = peeked;\n            peeked = null;\n            return result;\n        }\n        return iterator.next();\n    }\n\n    @Override\n    public Integer peek() {\n        if (!hasNext()) {\n            throw new NoSuchElementException();\n        }\n        return peeked;\n    }\n}\n\ninterface Iterator<T> {\n    boolean hasNext();\n\n    T next();\n}\n```",
  "285": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root = new Node(2);\n        root.left = new Node(1);\n        root.right = new Node(3);\n        \n        System.out.println(\"Test Case 1: \");\n        Node node = root.right;\n        System.out.println(\"Inorder Successor of \" + node.val + \": \" + findSuccessor(root, node).val);\n\n        root = new Node(5);\n        root.left = new Node(3);\n        root.right = new Node(6);\n        root.left.left = new Node(2);\n        root.left.right = new Node(4);\n        \n        System.out.println(\"\\nTest Case 2: \");\n        node = root.left.right;\n        System.out.println(\"Inorder Successor of \" + node.val + \": \" + findSuccessor(root, node).val);\n\n        root = new Node(5);\n        root.left = new Node(3);\n        root.right = new Node(6);\n        \n        System.out.println(\"\\nTest Case 3: \");\n        node = root;\n        System.out.println(\"Inorder Successor of \" + node.val + \": \" + findSuccessor(root, node).val);\n    }\n\n    public static Node findSuccessor(Node root, Node p) {\n        if (p.right != null) {\n            return min(p.right);\n        }\n        Node q = root;\n        while (q.left != null && q.left != p) {\n            q = q.left;\n        }\n        return q;\n    }\n\n    public static Node min(Node node) {\n        Node cur = node;\n        while (cur.left != null) {\n            cur = cur.left;\n        }\n        return cur;\n    }\n\n    class Node {\n        int val;\n        Node left, right;\n\n        Node(int item) {\n            val = item;\n        }\n    }\n}",
  "287": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1, 3, 4, 2, 1};\n        System.out.println(\"Test case 1: \" + findDuplicate(nums1));\n        \n        int[] nums2 = {1, 2, 3, 4};\n        System.out.println(\"Test case 2: \" + findDuplicate(nums2));\n\n        int[] nums3 = {1, 1, 1, 5, 6};\n        System.out.println(\"Test case 3: \" + findDuplicate(nums3));\n    }\n\n    public static int findDuplicate(int[] nums) {\n        int tortoise = nums[0];\n        int hare = nums[0];\n        \n        do {\n            tortoise = nums[tortoise];\n            hare = nums[nums[hare]];\n        } while (tortoise != hare);\n        \n        tortoise = nums[0];\n        while (tortoise != hare) {\n            tortoise = nums[tortoise];\n            hare = nums[hare];\n        }\n        \n        return hare;\n    }\n}\n```",
  "286": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] room = new int[][]{{0,0,1},{0,1,0},{0,2,0}};\n        wallsAndGates(room);\n        printRoom(room);\n\n        System.out.println();\n\n        room = new int[][]{{0,0,0},{0,1,0},{0,2,0}};\n        wallsAndGates(room);\n        printRoom(room);\n\n        System.out.println();\n\n        room = new int[][]{{0,0,0,0},{1,1,1,1},{2,2,2,2},{3,3,3,3}};\n        wallsAndGates(room);\n        printRoom(room);\n    }\n\n    public static void wallsAndGates(int[][] rooms) {\n        if (rooms == null || rooms.length == 0) return;\n        int rows = rooms.length;\n        int cols = rooms[0].length;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (rooms[i][j] == 1 || rooms[i][j] == 2) continue;\n                if (i == 0 || j == 0 || i == rows - 1 || j == cols - 1) rooms[i][j] = 0;\n                else {\n                    boolean[][] visited = new boolean[rows][cols];\n                    dfs(rooms, i, j, visited);\n                }\n            }\n        }\n    }\n\n    public static void dfs(int[][] rooms, int x, int y, boolean[][] visited) {\n        if (x < 0 || x >= rooms.length || y < 0 || y >= rooms[0].length || visited[x][y]) return;\n        visited[x][y] = true;\n        for (int[] direction : {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {\n            int newX = x + direction[0];\n            int newY = y + direction[1];\n            if (newX >= 0 && newX < rooms.length && newY >= 0 && newY < rooms[0].length\n                    && rooms[newX][newY] > 0) {\n                rooms[x][y] = 0;\n                dfs(rooms, newX, newY, visited);\n            }\n        }\n    }\n\n    public static void printRoom(int[][] room) {\n        for (int i = 0; i < room.length; i++) {\n            for (int j = 0; j < room[0].length; j++) {\n                System.out.print(room[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
  "288": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String[] words1 = {\"like\", \"unlike\"};\n        System.out.println(solution.wordAbbreviation(words1));\n        \n        String[] words2 = {\"dog\", \"cat\", \"apple\"};\n        System.out.println(solution.wordAbbreviation(words2));\n        \n        String[] words3 = {\"a\", \"b\", \"c\", \"d\"};\n        System.out.println(solution.wordAbbreviation(words3));\n    }\n}\n\nclass Solution {\n    public String[] wordAbbreviation(String[] words) {\n        // Your code here\n    }\n}\n```",
  "289": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] board1 = {{0,1,0},{1,1,1},{0,0,0}};\n        printBoard(board1);\n\n        int[][] board2 = {{0,1,0},{1,0,1},{0,1,0}};\n        printBoard(board2);\n\n        int[][] board3 = {{0,0,1},{0,0,1},{0,0,0}};\n        printBoard(board3);\n    }\n\n    public static void printBoard(int[][] board) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                System.out.print(board[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "290": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(wordPattern(\"abba\", \"dog cat cat dog\") == true ? \"Pass\" : \"Fail\");\n        System.out.println(wordPattern(\"abc\", \"b c a\") == false ? \"Pass\" : \"Fail\");\n        System.out.println(wordPattern(\"aaa\", \"cat dog cat\") == false ? \"Pass\" : \"Fail\");\n    }\n\n    public static boolean wordPattern(String pattern, String str) {\n        if (pattern.length() != str.length()) return false;\n        int[] charIndexMap = new int[256];\n        Map<Character, Integer> map = new HashMap<>();\n        \n        for (int i = 0; i < pattern.length(); i++) {\n            char ch = str.charAt(i);\n            if (!map.containsKey(ch)) {\n                for (int j = 0; j < 256; j++) {\n                    if (charIndexMap[j] == i) return false;\n                }\n                map.put(ch, pattern.length() - i - 1);\n                charIndexMap[str.charAt(i)] = i;\n            } else {\n                if (pattern.charAt(i) != (char)map.get(ch)) return false;\n            }\n        }\n        \n        return true;\n    }\n}\n```",
  "292": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] pile1 = {2, 1, 3};\n        System.out.println(canWin(pile1)); // Output: true\n\n        int[] pile2 = {1, 2};\n        System.out.println(canWin(pile2)); // Output: false\n\n        int[] pile3 = {0, 0};\n        System.out.println(canWin(pile3)); // Output: true\n    }\n\n    public static boolean canWin(int[] piles) {\n        for (int i = 0; i < piles.length; i++) {\n            if ((piles[i] & 1) == 1) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
  "291": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"abc\", \"xyz\"));\n        System.out.println(canBeEqual(\"foo\", \"bar\"));\n        System.out.println(canBeEqual(\"aa\", \"aaa\"));\n    }\n\n    public static boolean canBeEqual(String word1, String word2) {\n        if (word1.length() != word2.length()) return false;\n        Map<Character, Character> map = new HashMap<>();\n        for (int i = 0; i < word1.length(); i++) {\n            char c1 = word1.charAt(i);\n            char c2 = word2.charAt(i);\n            if (!map.containsKey(c1)) {\n                map.put(c1, c2);\n            } else if (map.get(c1) != c2) return false;\n        }\n        for (Map.Entry<Character, Character> entry : map.entrySet()) {\n            if (word1.chars().filter(ch -> ch == entry.getKey()).count() !=\n                    word2.chars().filter(ch -> ch == entry.getValue()).count())\n                return false;\n        }\n        return true;\n    }\n}\n```",
  "293": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(calculate(\"WPWP\")); // expected: 4\n        System.out.println(calculate(\"NN\")); // expected: 2\n        System.out.println(calculate(\"PP\")); // expected: 0\n    }\n\n    public static int calculate(String WF) {\n        int result = 0;\n        for (int i = 0; i < WF.length(); i++) {\n            if ((i % 2 == 0 && WF.charAt(i) == 'W') || (i % 2 != 0 && WF.charAt(i) == 'P')) {\n                result++;\n            }\n        }\n        return result;\n    }\n}",
  "294": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canWin(\"10100\")); // expected: true\n        System.out.println(canWin(\"11010\")); // expected: false\n        System.out.println(canWin(\"1000101\")); // expected: true\n    }\n\n    public static boolean canWin(String state) {\n        int n = state.length();\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = false;\n        for (int i = 1; i <= n; i++) {\n            if (state.charAt(i - 1) == '1') {\n                dp[i] = !dp[i - 1];\n            } else if (i >= 2) {\n                dp[i] = dp[i - 1] || !dp[i - 2];\n            }\n        }\n        return dp[n];\n    }\n}\n```",
  "295": "```\npublic class Main {\n    public static void main(String[] args) {\n        DisjointSet ds = new DisjointSet();\n        System.out.println(\"Test case 1: \" + findMedian(ds.insert(1), ds.insert(2)));\n        System.out.println(\"Test case 2: \" + findMedian(ds.insert(3), ds.insert(4)));\n        System.out.println(\"Test case 3: \" + findMedian(ds.insert(5), ds.insert(6)));\n    }\n\n    public static double findMedian(int[] nums) {\n        Arrays.sort(nums);\n        if (nums.length % 2 == 0) {\n            return (nums[nums.length / 2 - 1] + nums[nums.length / 2]) / 2.0;\n        } else {\n            return nums[nums.length / 2];\n        }\n    }\n}\n\nclass DisjointSet {\n    private Map<Integer, Integer> parent;\n\n    public DisjointSet() {\n        this.parent = new HashMap<>();\n    }\n\n    public int insert(int val) {\n        if (!parent.containsKey(val)) {\n            parent.put(val, val);\n        } else {\n            findAndUnion(val, parent.get(val));\n        }\n        return parent.get(val);\n    }\n\n    private void findAndUnion(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            parent.put(rootX, rootY);\n        }\n    }\n\n    private int find(int x) {\n        if (parent.get(x).equals(x)) {\n            return x;\n        } else {\n            parent.put(x, find(parent.get(x)));\n            return parent.get(x);\n        }\n    }\n}\n```",
  "296": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] meeting1 = {{0,2},{1,3},{1,4}};\n        System.out.println(\"Meeting 1: \" + minTimeToMeet(meeting1));\n        \n        int[][] meeting2 = {{0,5},{2,8}};\n        System.out.println(\"Meeting 2: \" + minTimeToMeet(meeting2));\n\n        int[][] meeting3 = {{1,4},{2,3}};\n        System.out.println(\"Meeting 3: \" + minTimeToMeet(meeting3));\n    }\n\n    public static int minTimeToMeet(int[][] meetings) {\n        if (meetings == null || meetings.length == 0) {\n            return 0;\n        }\n        \n        Arrays.sort(meetings, (a, b) -> a[1] - b[1]);\n        \n        int time = meetings[0][1];\n        for (int i = 1; i < meetings.length; i++) {\n            if (meetings[i][0] >= time) {\n                return time;\n            }\n            time = Math.max(time, meetings[i][1]);\n        }\n        \n        return -1;\n    }\n}\n```",
  "297": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        // Test case 1\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(5);\n\n        String serialized1 = serialize(root1);\n        System.out.println(serialized1);\n        TreeNode deserialized1 = deserialize(serialized1);\n        inOrder(deserialized1);\n\n        // Test case 2\n        TreeNode root2 = new TreeNode(3);\n        root2.left = new TreeNode(1);\n        root2.right = new TreeNode(4);\n        root2.left.left = new TreeNode(0);\n        root2.left.right = new TreeNode(2);\n\n        String serialized2 = serialize(root2);\n        System.out.println(serialized2);\n        TreeNode deserialized2 = deserialize(serialized2);\n        inOrder(deserialized2);\n\n        // Test case 3\n        TreeNode root3 = null;\n\n        String serialized3 = serialize(root3);\n        System.out.println(serialized3);\n        TreeNode deserialized3 = deserialize(serialized3);\n        inOrder(deserialized3);\n    }\n\n    public static String serialize(TreeNode root) {\n        if (root == null) {\n            return \"X,\"; // Represent null node as \"X,\"\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(root.val).append(\",\");\n\n        sb.append(serialize(root.left));\n        sb.append(serialize(root.right));\n\n        return sb.toString();\n    }\n\n    public static TreeNode deserialize(String data) {\n        if (data == null || data.length() == 0) {\n            return null;\n        }\n\n        String[] values = data.split(\",\");\n        return deserialize(values, 0);\n    }\n\n    private static TreeNode deserialize(String[] values, int index) {\n        if (values[index].equals(\"X\")) {\n            return null;\n        }\n\n        TreeNode root = new TreeNode(Integer.parseInt(values[index]));\n        index++;\n\n        root.left = deserialize(values, index);\n        index++;\n\n        root.right = deserialize(values, index);\n\n        return root;\n    }\n\n    public static void inOrder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n\n        inOrder(root.left);\n        System.out.print(root.val + \" \");\n        inOrder(root.right);\n    }\n}\n```",
  "298": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root = new Node(1);\n        root.left = new Node(0);\n        root.right = new Node(2);\n\n        System.out.println(\"Test Case 1: \");\n        System.out.println(\"Expected: 3, Actual: \" + longestConsecutive(root));\n\n        Node root2 = new Node(2);\n        root2.right = new Node(3);\n        root2.right.right = new Node(4);\n\n        System.out.println(\"\\nTest Case 2: \");\n        System.out.println(\"Expected: 3, Actual: \" + longestConsecutive(root2));\n\n        Node root3 = new Node(1);\n        root3.left = new Node(0);\n        root3.right = new Node(1);\n\n        System.out.println(\"\\nTest Case 3: \");\n        System.out.println(\"Expected: 2, Actual: \" + longestConsecutive(root3));\n    }\n\n    public static int longestConsecutive(Node root) {\n        if (root == null) return 0;\n\n        int maxSequence = 0;\n        for (Node node : traverse(root)) {\n            if (node.left == null && node.right == null) {\n                int currentSequence = dfs(node, 1);\n                maxSequence = Math.max(maxSequence, currentSequence);\n            }\n        }\n\n        return maxSequence;\n    }\n\n    private static List<Node> traverse(Node root) {\n        List<Node> nodes = new ArrayList<>();\n        if (root == null) return nodes;\n\n        nodes.add(root);\n\n        Node left = root.left;\n        while (left != null) {\n            nodes.add(left);\n            left = left.left;\n        }\n\n        Node right = root.right;\n        while (right != null) {\n            nodes.add(right);\n            right = right.right;\n        }\n\n        return nodes;\n    }\n\n    private static int dfs(Node node, int currentSequence) {\n        if (node == null) return 0;\n\n        if (Math.abs(node.val - (node.left.val + 1)) <= 1 && node.left != null) {\n            return currentSequence + dfs(node.left, currentSequence + 1);\n        }\n\n        if (Math.abs(node.val - (node.right.val - 1)) <= 1 && node.right != null) {\n            return currentSequence + dfs(node.right, currentSequence + 1);\n        }\n\n        return currentSequence;\n    }\n}\n\nclass Node {\n    int val;\n    Node left;\n    Node right;\n\n    public Node(int v) {\n        val = v;\n        left = null;\n        right = null;\n    }\n}\n```",
  "299": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(getHint(\"1807\", \"7810\")); // Expected: \"1A2\"\n        System.out.println(getHint(\"1123\", \"2211\")); // Expected: \"4A1\"\n        System.out.println(getHint(\"oldwars\", \"swardlo\")); // Expected: \"1A3N\"\n    }\n\n    public static String getHint(String secret, String guess) {\n        int a = 0;\n        int b = 0;\n\n        for (int i = 0; i < secret.length(); i++) {\n            if (secret.charAt(i) == guess.charAt(i)) {\n                a++;\n            } else if (guess.indexOf(guess.charAt(i)) != -1) {\n                b++;\n            }\n        }\n\n        return a + \"A\" + b + \"B\";\n    }\n}\n```",
  "300": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {10,9,2,5,3,7,101,18};\n        System.out.println(\"Longest Increasing Subsequence for \" + Arrays.toString(nums1) + \": \" + longestIncreasingSubsequence(nums1));\n        \n        int[] nums2 = {0,1,3,4,5,6};\n        System.out.println(\"Longest Increasing Subsequence for \" + Arrays.toString(nums2) + \": \" + longestIncreasingSubsequence(nums2));\n\n        int[] nums3 = [1, 2, 3, 4, 5];\n        System.out.println(\"Longest Increasing Subsequence for \" + Arrays.toString(nums3) + \": \" + longestIncreasingSubsequence(nums3));\n    }\n\n    public static int longestIncreasingSubsequence(int[] nums) {\n        if (nums.length == 0) return 0;\n\n        int[] dp = new int[nums.length];\n        Arrays.fill(dp, 1);\n\n        for (int i = 1; i < nums.length; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n\n        int maxLen = 0;\n        for (int len : dp) {\n            maxLen = Math.max(maxLen, len);\n        }\n\n        return maxLen;\n    }\n}\n```",
  "301": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removeInvalidParentheses(\"(()())(())\")); // expected output: \"((())())()\"\n        System.out.println(removeInvalidParentheses(\"(a(b(c))d)\")); // expected output: \"a(b(c)d)\"\n        System.out.println(removeInvalidParentheses(\"(()()\")); // expected output: \"()\"\n    }\n\n    public static List<String> removeInvalidParentheses(String s) {\n        // your solution here\n    }\n}\n```",
  "302": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] image1 = {{0,0,1},{1,1,1}};\n\n        System.out.println(\"Expected: \" + 4);\n        System.out.println(\"Actual: \" + new Solution().surfaceArea(image1));\n        System.out.println();\n\n        int[][] image2 = {{0,0,1,0},{0,1,1,0},{0,0,1,0}};\n\n        System.out.println(\"Expected: \" + 14);\n        System.out.println(\"Actual: \" + new Solution().surfaceArea(image2));\n        System.out.println();\n\n        int[][] image3 = {{1,0,1,1},{1,1,1,1},{1,0,0,0}};\n\n        System.out.println(\"Expected: \" + 16);\n        System.out.println(\"Actual: \" + new Solution().surfaceArea(image3));\n    }\n}\n\nclass Solution {\n    public int surfaceArea(int[][] image) {\n        // your logic here\n    }\n}\n```",
  "303": "```\npublic class Solution {\n    public int[] prefixSum(int[] nums) {\n        int n = nums.length;\n        int[] prefixSums = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSums[i + 1] = prefixSums[i] + nums[i];\n        }\n        return prefixSums;\n    }\n\n    public int segmentSum(int[] nums, int left, int right) {\n        int[] prefixSums = prefixSum(nums);\n        return prefixSums[right + 1] - prefixSums[left];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] test1 = {1, 3, 5};\n        System.out.println(\"Test case 1: \" + solution.segmentSum(test1, 0, 2)); // Output: 9\n\n        int[] test2 = {2, 3, -1};\n        System.out.println(\"Test case 2: \" + solution.segmentSum(test2, 0, 1)); // Output: 4\n\n        int[] test3 = {-2, 0, 3, -5, 2];\n        System.out.println(\"Test case 3: \" + solution.segmentSum(test3, 2, 4)); // Output: 6\n    }\n}",
  "304": "```\npublic class Solution {\n    public int[][] prefixSumMatrix(int[][] mat) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int[][] sumMat = new int[m + 1][n + 1];\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                sumMat[i][j] = mat[i - 1][j - 1] + sumMat[i - 1][j] + sumMat[i][j - 1] - sumMat[i - 1][j - 1];\n            }\n        }\n        \n        return sumMat;\n    }\n\n    public int sumRegion(int[][] mat, int row1, int col1, int row2, int col2) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int[][] sumMat = prefixSumMatrix(mat);\n        return sumMat[row2 + 1][col2 + 1] - (sumMat[row1][col2 + 1] + sumMat[row2 + 1][col1] - sumMat[row1][col1]);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] mat1 = {{3, 0, 1, 4}, {1, 5, 9, 2}};\n        System.out.println(\"Test case 1: \" + solution.sumRegion(mat1, 1, 1, 2, 2)); // Should return 8\n        \n        int[][] mat2 = {{1, 2}, {3, 4}};\n        System.out.println(\"Test case 2: \" + solution.sumRegion(mat2, 0, 0, 1, 1)); // Should return 5\n        \n        int[][] mat3 = {{10}};\n        System.out.println(\"Test case 3: \" + solution.sumRegion(mat3, 0, 0, 0, 0)); // Should return 10\n    }\n}",
  "305": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {\n            {\"0\", \"0\", \"1\", \"0\", \"0\"},\n            {\"0\", \"1\", \"0\", \"1\", \"0\"},\n            {\"0\", \"0\", \"1\", \"1\", \"1\"},\n            {\"0\", \"1\", \"0\", \"0\", \"1\"}\n        };\n        System.out.println(numberOfIslandsII(grid1)); // expected output: 3\n\n        int[][] grid2 = {\n            {\"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\"},\n            {\"0\", \"0\", \"1\", \"1\", \"1\", \"1\", \"0\"},\n            {\"0\", \"1\", \"1\", \"1\", \"1\", \"0\", \"0\"},\n            {\"0\", \"1\", \"0\", \"0\", \"0\", \"0\", \"0\"},\n            {\"0\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\"}\n        };\n        System.out.println(numberOfIslandsII(grid2)); // expected output: 1\n\n        int[][] grid3 = {\n            {\"0\", \"0\", \"0\", \"0\", \"0\"},\n            {\"0\", \"0\", \"0\", \"0\", \"0\"},\n            {\"0\", \"0\", \"0\", \"0\", \"0\"}\n        };\n        System.out.println(numberOfIslandsII(grid3)); // expected output: 0\n    }\n\n    public static int numberOfIslandsII(int[][] grid) {\n        if (grid == null || grid.length == 0) return 0;\n\n        int count = 0;\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j].equals(\"1\") && !visited[i][j]) {\n                    dfs(grid, visited, i, j);\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    private static void dfs(int[][] grid, boolean[][] visited, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || !grid[i][j].equals(\"1\") || visited[i][j]) return;\n\n        visited[i][j] = true;\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (int[] direction : directions) {\n            dfs(grid, visited, i + direction[0], j + direction[1]);\n        }\n    }\n}\n```",
  "306": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(additiveNumber(\"123\")); // Expected output: \"1+2+3\"\n        System.out.println(additiveNumber(\"25\")); // Expected output: \"\"\n        System.out.println(adductiveNumber(\"111221\")); // Expected output: \"1+12+22+2+11+2+1\"\n    }\n\n    public static String additiveNumber(String num) {\n        for (int i = 1; i <= num.length() / 2; i++) {\n            if (num.length() % (i + 1) != 0) continue;\n            String first = num.substring(0, i);\n            if (!isValid(first)) continue;\n            String second = num.substring(i, i + 1 + num.length() / (i + 1));\n            if (!second.startsWith(first) && !second.startsWith(\"0\")) continue;\n            if (addition(first, second).equals(num.substring(i + 1))) {\n                return first + \"+\" + second;\n            }\n        }\n        return \"\";\n    }\n\n    public static boolean isValid(String s) {\n        if (s.equals(\"0\")) return false;\n        for (char c : s.toCharArray()) {\n            if (!Character.isDigit(c)) return false;\n        }\n        return true;\n    }\n\n    public static String addition(String a, String b) {\n        int carry = 0;\n        StringBuilder sb = new StringBuilder();\n        int i = a.length() - 1;\n        int j = b.length() - 1;\n        while (i >= 0 || j >= 0 || carry > 0) {\n            int sum = carry;\n            if (i >= 0) sum += a.charAt(i--) - '0';\n            if (j >= 0) sum += b.charAt(j--) - '0';\n            sb.append((sum % 10));\n            carry = sum / 10;\n        }\n        return sb.reverse().toString();\n    }\n}\n```",
  "307": "```\npublic class Main {\n    public static void main(String[] args) {\n        NumArray numArray = new NumArray(new int[]{1, 3, 5});\n        System.out.println(numArray.sumRange(0, 1)); // prints 4\n        numArray.update(1, 2);\n        System.out.println(numArray.sumRange(0, 2)); // prints 6\n        numArray.update(0, -1);\n        System.out.println(numArray.sumRange(1, 3)); // prints 5\n    }\n}\n\nclass NumArray {\n    int[] tree;\n    public NumArray(int[] nums) {\n        if (nums.length == 0) return;\n        tree = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            update(i, nums[i]);\n        }\n    }\n\n    void update(int index, int val) {\n        for (int i = index + 1; i <= tree.length; i++) {\n            tree[i] += val;\n            if ((i & 1) == 0) {\n                tree[i / 2] += tree[i];\n                tree[i] = 0;\n            }\n        }\n    }\n\n    int sumRange(int left, int right) {\n        return query(right + 1) - query(left);\n    }\n\n    int query(int index) {\n        int sum = 0;\n        for (; index > 0; index /= 2) {\n            sum += tree[index];\n            if ((index & 1) == 1) index--;\n        }\n        return sum;\n    }\n}",
  "308": "```\npublic class Main {\n    public static void main(String[] args) {\n        NumMatrix numMatrix = new NumMatrix(new int[][]{{1,2,3},{4,5,6},{7,8,9}});\n        \n        System.out.println(numMatrix.sumRegion(0, 1, 1, 1)); // prints 5\n        System.out.println(numMatrix.update(1, 1, 10));\n        System.out.println(numMatrix.sumRegion(2, 1, 3, 2)); // prints 13\n\n        numMatrix = new NumMatrix(new int[][]{{1,4,5},{7,8,9},{6,7,8}});\n        System.out.println(numMatrix.update(0, 1, 1));\n        System.out.println(numMatrix.sumRegion(0, 0, 2, 3)); // prints 12\n    }\n}\n\nclass NumMatrix {\n    private int[][] matrix;\n    private Bit[] bit;\n\n    public NumMatrix(int[][] matrix) {\n        this.matrix = matrix;\n        this.bit = new Bit[matrix.length];\n        for (int i = 0; i < matrix.length; i++) {\n            bit[i] = new Bit(matrix[0].length);\n            for (int j = 0; j < matrix[0].length; j++) {\n                update(i, j, matrix[i][j]);\n            }\n        }\n    }\n\n    public void update(int row, int col, int val) {\n        for (; row < bit.length; row += row & -row) {\n            for (int i = 0, len = bit[0].length; i < len; i++) {\n                if (col >= i && i + len > col) {\n                    bit[row].update(i, col - i + 1, val);\n                }\n            }\n        }\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        return sum(row2, col2) - sum(row1 - 1, col2) - sum(row2, col1 - 1) + sum(row1 - 1, col1 - 1);\n    }\n\n    private int sum(int row, int col) {\n        int res = 0;\n        for (; row > 0; row -= row & -row) {\n            for (int i = 0, len = bit[0].length; i < len; i++) {\n                if (col >= i && i + len > col) {\n                    res += bit[row].getSum(i, col - i + 1);\n                }\n            }\n        }\n        return res;\n    }\n}\n\nclass Bit {\n    private int[] bit;\n\n    public Bit(int n) {\n        this.bit = new int[n + 1];\n    }\n\n    public void update(int x, int y, int val) {\n        for (int i = x; i <= x + y; i += i & -i) {\n            bit[i] += val;\n        }\n    }\n\n    public int getSum(int x, int y) {\n        int res = 0;\n        for (int i = x; i > 0; i -= i & -i) {\n            res += bit[i];\n            if (x + y >= i) {\n                res += bit[x + y];\n            }\n        }\n        return res;\n    }\n}\n```",
  "309": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] prices1 = {1,2,3,0,2};\n        System.out.println(\"Best Time to Buy and Sell Stock with Cooldown: \" + maxProfit(prices1));\n        \n        int[] prices2 = {1,2,4,2,5};\n        System.out.println(\"Best Time to Buy and Sell Stock with Cooldown: \" + maxProfit(prices2));\n\n        int[] prices3 = {7,6,8,9,11,12,13,15};\n        System.out.println(\"Best Time to Buy and Sell Stock with Cooldown: \" + maxProfit(prices3));\n    }\n\n    public static int maxProfit(int[] prices) {\n        if (prices.length < 2) return 0;\n\n        int[] buy = new int[prices.length];\n        int[] sell = new int[prices.length];\n\n        buy[0] = -prices[0];\n        for (int i = 1; i < prices.length; i++) {\n            buy[i] = Math.max(buy[i-1], sell[i-1] - prices[i]);\n            sell[i] = Math.max(sell[i-1], buy[i-1] + prices[i]);\n        }\n\n        return sell[sell.length-1];\n    }\n}\n```",
  "310": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph1 = {{1,0},{1,2},{3,2},{2,4}};\n        System.out.println(\"Test case 1: \" + findMinHeightTrees(6, graph1));\n        \n        int[][] graph2 = {{1,0},{2,0}};\n        System.out.println(\"Test case 2: \" + findMinHeightTrees(3, graph2));\n        \n        int[][] graph3 = {};\n        System.out.println(\"Test case 3: \" + findMinHeightTrees(4, graph3));\n    }\n\n    public static List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        if (n == 0) return new ArrayList<>();\n        if (n == 1) return Collections.singletonList(0);\n        \n        List<Integer>[] graph = new List[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int[] edge : edges) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        while (n > 2) {\n            int leaves = 0;\n            List<Integer> leavesList = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (graph[i].size() == 1) {\n                    leaves++;\n                    leavesList.add(i);\n                }\n            }\n            if (leaves == 1) {\n                result.addAll(leavesList);\n                break;\n            } else {\n                for (int leaf : leavesList) {\n                    graph[leaf] = new ArrayList<>();\n                }\n                n -= leaves;\n            }\n        }\n        \n        if (n > 1) {\n            result.add(0);\n            result.add(0);\n        } else {\n            result.addAll(new ArrayList<>(Arrays.asList(0, 1)));\n        }\n        return result;\n    }\n}\n```",
  "311": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] mat1 = {{0, 0, 0}, {0, 3, 2}, {1, 5, 0}};\n        int[][] mat2 = {{0, 0, 0}, {0, 3, 2}, {1, 5, 0}};\n        System.out.println(\"Matrix 1: \\n\" + Arrays.deepToString(mat1) + \"\\n\");\n        System.out.println(\"Matrix 2: \\n\" + Arrays.deepToString(mat2) + \"\\n\");\n        int[][] res1 = new Solution().multiply(new SparseArray(mat1), new SparseArray(mat2));\n        printResult(res1, \"Matrix 1 * Matrix 2: \\n\");\n\n        int[][] mat3 = {{0, 0, 0}, {0, 12, -3}, {10, 5, 0}};\n        int[][] mat4 = {{0, 0, 0}, {0, -3, 8}, {-4, -1, 0}};\n        res1 = new Solution().multiply(new SparseArray(mat3), new SparseArray(mat4));\n        printResult(res1, \"Matrix 3 * Matrix 4: \\n\");\n\n        int[][] mat5 = {{-6, -2, -5}, {3, -6, 8}, {0, -8, -9}};\n        int[][] mat6 = {{-8, -7, -5}, {-12, -10, -8}, {4, 5, 0}};\n        res1 = new Solution().multiply(new SparseArray(mat5), new SparseArray(mat6));\n        printResult(res1, \"Matrix 5 * Matrix 6: \\n\");\n    }\n\n    public static void printResult(int[][] result, String message) {\n        System.out.println(message);\n        for (int[] row : result) {\n            System.out.println(Arrays.toString(row));\n        }\n        System.out.println();\n    }\n}\n\nclass Solution {\n    public int[][] multiply(int[][] mat1, int[][] mat2) {\n        // your code here\n    }\n}\n\nclass SparseArray {\n    private int[][] array;\n    public SparseArray(int[][] array) {\n        this.array = array;\n    }\n\n    public int get(int i, int j) {\n        return array[i][j];\n    }\n}",
  "312": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] balloons1 = {{3,4}, {1,2}};\n        System.out.println(\"Burst Balloons for \" + Arrays.toString(balloons1) + \": \" + maxCoins(balloons1));\n\n        int[][] balloons2 = {{5,6},{7,8}};\n        System.out.println(\"Burst Balloons for \" + Arrays.toString(balloons2) + \": \" + maxCoins(balloons2));\n\n        int[][] balloons3 = {{9,10},{11,12},{13,14}};\n        System.out.println(\"Burst Balloons for \" + Arrays.toString(balloons3) + \": \" + maxCoins(balloons3));\n    }\n\n    public static int maxCoins(int[][] piles) {\n        // Your code here\n    }\n}\n```",
  "313": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n1 = 12;\n        System.out.println(\"n1: \" + nthSuperUglyNumber(n1, new int[]{2, 7, 13, 19}));\n        \n        int n2 = 10;\n        System.out.println(\"n2: \" + nthSuperUglyNumber(n2, new int[]{3, 5}));\n\n        int n3 = 11;\n        System.out.println(\"n3: \" + nthSuperUglyNumber(n3, new int[]{2, 7, 13, 19}));\n    }\n\n    public static int nthSuperUglyNumber(int n, int[] primes) {\n        if (n == 1) return 1;\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n        for (int i = 1; i < n; i++) {\n            ugly[i] = Integer.MAX_VALUE;\n            for (int prime : primes) {\n                while (ugly[i].divide(ugly[i], prime) <= ugly[i-1]) {\n                    ugly[i] = ugly[i].multiply(prime);\n                }\n            }\n        }\n        return ugly[n-1];\n    }\n\n    public static int divide(int a, int b) {\n        return a / b;\n    }\n\n    public static int multiply(int a, int b) {\n        return a * b;\n    }\n}",
  "314": "```\nimport java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Main {\n\n    public static List<List<Integer>> verticalOrder(TreeNode root) {\n        if (root == null) return new ArrayList<>();\n\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        Queue<TreeNode> q = new LinkedList<>();\n        Queue<Integer> colQ = new LinkedList<>();\n\n        q.offer(root);\n        colQ.offer(0);\n\n        while (!q.isEmpty()) {\n            TreeNode node = q.poll();\n            int col = colQ.poll();\n\n            if (node == null) continue;\n\n            map.computeIfAbsent(col, k -> new ArrayList<>()).add(node.val);\n\n            if (node.left != null) {\n                q.offer(node.left);\n                colQ.offer(col - 1);\n            }\n\n            if (node.right != null) {\n                q.offer(node.right);\n                colQ.offer(col + 1);\n            }\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        map.forEach((k, v) -> res.add(v));\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(9);\n        root1.right = new TreeNode(20);\n        root1.right.left = new TreeNode(15);\n        root1.right.right = new TreeNode(7);\n\n        System.out.println(verticalOrder(root1));\n\n        TreeNode root2 = new TreeNode(4);\n        root2.left = new TreeNode(5);\n        root2.right = new TreeNode(2);\n        root2.right.left = new TreeNode(3);\n        root2.right.right = new TreeNode(1);\n\n        System.out.println(verticalOrder(root2));\n\n        TreeNode root3 = null;\n\n        System.out.println(verticalOrder(root3));\n    }\n}",
  "315": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {5,2,6,1};\n        System.out.println(\"Count of smaller numbers after self for \" + Arrays.toString(arr1) + \": \" + new Solution().countOfSmallerNumbersThanTarget(arr1));\n        \n        int[] arr2 = {96, 57, 23, 100};\n        System.out.println(\"Count of smaller numbers after self for \" + Arrays.toString(arr2) + \": \" + new Solution().countOfSmallerNumbersThanTarget(arr2));\n        \n        int[] arr3 = {7, 7, 7, 12};\n        System.out.println(\"Count of smaller numbers after self for \" + Arrays.toString(arr3) + \": \" + new Solution().countOfSmallerNumbersThanTarget(arr3));\n    }\n}\n```",
  "316": "```\nimport java.util.Stack;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removeDuplicateLetters(\"bcab\")); // Output: \"abc\"\n        System.out.println(removeDuplicateLetters(\"aa\")); // Output: \"\"\n        System.out.println(removeDuplicateLetters(\"aaa\")); // Output: \"\"\n    }\n\n    public static String removeDuplicateLetters(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            while (!stack.isEmpty() && stack.peek() > c) {\n                stack.pop();\n            }\n            if (!stack.contains(c)) {\n                stack.push(c);\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        while (!stack.isEmpty()) {\n            sb.append(stack.pop());\n        }\n        return sb.reverse().toString();\n    }\n}\n```",
  "318": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxProduct(new String[]{\"a\", \"ab\", \"abc\"})); // Expected output: 9\n        System.out.println(maxProduct(new String[]{\"b\", \"c\", \"bc\"})); // Expected output: 6\n        System.out.println(maxProduct(new String[]{\"wont\", \"good\", \"walker\", \"walker\"})); // Expected output: 13\n    }\n\n    public static int maxProduct(String[] words) {\n        int maxProduct = 0;\n        for (int i = 0; i < words.length; i++) {\n            for (int j = i + 1; j < words.length; j++) {\n                int product = (words[i].length() * words[j].length());\n                if (product > maxProduct) {\n                    maxProduct = product;\n                }\n            }\n        }\n        return maxProduct;\n    }\n}\n```",
  "317": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{1,0,2,0,1},{0,0,0,0,0},{1,0,0,0,1},{1,1,1,1,1},{1,0,0,0,1}};\n        System.out.println(\"Test case 1: \" + shortestDistance(grid1));\n        \n        int[][] grid2 = {{0,4,4,3,0},{3,2,4,2,0},{0,0,2,0,0}};\n        System.out.println(\"Test case 2: \" + shortestDistance(grid2));\n        \n        int[][] grid3 = {{1,2,3},{0,0,0},{5,7,8}};\n        System.out.println(\"Test case 3: \" + shortestDistance(grid3));\n    }\n\n    public static int shortestDistance(int[][] grid) {\n        if (grid == null || grid.length == 0) return -1;\n        \n        int m = grid.length;\n        int n = grid[0].length;\n        \n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[m][n];\n        \n        int res = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    queue.add(new int[]{i, j});\n                    visited[i][j] = true;\n                    \n                    while (!queue.isEmpty()) {\n                        int[] pos = queue.poll();\n                        \n                        for (int dx = -1; dx <= 1; dx++) {\n                            for (int dy = -1; dy <= 1; dy++) {\n                                if (dx == 0 && dy == 0) continue;\n                                \n                                int x = pos[0] + dx;\n                                int y = pos[1] + dy;\n                                \n                                if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y] && grid[x][y] != 0) {\n                                    queue.add(new int[]{x, y});\n                                    visited[x][y] = true;\n                                    \n                                    res = Math.min(res, Math.abs(x - i) + Math.abs(y - j));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        return res == Integer.MAX_VALUE ? 0 : res;\n    }\n}\n```",
  "319": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + bulbSwitcher(3) + \"\\n\");\n        System.out.println(\"Test case 2: \" + bulbSwitcher(4) + \"\\n\");\n        System.out.println(\"Test case 3: \" + bulbSwitcher(5));\n    }\n\n    public static int bulbSwitcher(int n) {\n        return (int)Math.sqrt(n);\n    }\n}\n```",
  "320": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(abbreviate(\"word\")); // Output: [\"w1\", \"wo2\", \"wor3\", \"word4\"]\n        System.out.println(abbreviate(\"a23b6c\"));// Output: [\"a23b6c\"]\n        System.out.println(abbreviate(\"abc\")); // Output: [\"a1b2c\", \"a2b1c\", \"ab1c2\", \"ab2c1\", \"abc1\", \"abc2\"]\n    }\n    \n    public static List<String> abbreviate(String word) {\n        List<String> res = new ArrayList<>();\n        backtrack(res, \"\", 0, word);\n        return res;\n    }\n\n    private static void backtrack(List<String> res, String cur, int pos, String word) {\n        if (pos == word.length()) {\n            res.add(cur);\n            return;\n        }\n        for (int i = pos; i < word.length(); i++) {\n            String temp = cur + (word.charAt(i) == '0' ? \"\" : word.charAt(i)) + ((i != word.length() - 1) ? (Math.pow(2, i - pos + 1) + 1) : \"\");\n            backtrack(res, temp, i + 1, word);\n        }\n    }\n}\n```",
  "321": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maximumNumber(new int[]{3, 2}, new String[]{\"100\", \"23\"})); // Expected: \"230\"\n        System.out.println(maximumNumber(new int[]{0, 9}, new String[]{\"1\", \"2\"})); // Expected: \"921\"\n        System.out.println(maximumNumber(new int[]{4, 6}, new String[]{\"27\", \"39\"})); // Expected: \"76329\"\n    }\n\n    public static String maximumNumber(int[] secrecyLevel, String[] numbers) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < secrecyLevel.length; i++) {\n            if (secrecyLevel[i] == 0) {\n                result.append(numbers[i]);\n            } else {\n                result.append(String.valueOf(secrecyLevel[i]));\n            }\n        }\n        return result.toString();\n    }\n\n}\n```",
  "322": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(coinChange(new int[]{1,2,5}, 11)); // Expected: 3\n        System.out.println(coinChange(new int[]{2}, 3)); // Expected: -1\n        System.out.println(coinChange(new int[]{1}, 2)); // Expected: 2\n    }\n\n    public static int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        for (int i = 0; i <= amount; i++) {\n            for (int j = 0; j < coins.length; j++) {\n                if (i >= coins[j]) {\n                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}\n```",
  "323": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numComponents(new String[][]{{\"SCIENCE\", \"MATH\"}, {\"ART\", \"SCIENCE\"}}, new String[]{\"SCIENCE\"}));\n        System.out.println(numComponents(new String[][]{}, new String[]{}));\n        System.out.println(numComponents(new String[][]{{\"A\", \"B\"}, {\"B\", \"C\"}, {\"C\", \"A\"}, {\"A\", \"C\"}, {\"B\", \"D\"}, {\"C\", \"D\"}}, new String[]{\"C\", \"D\", \"A\", \"B\"}));\n    }\n\n    public static int numComponents(int[][] edges, String[] connection) {\n        List<Integer> graph = new ArrayList<>();\n        for (String con : connection) {\n            graph.add(Integer.parseInt(con.substring(1, con.length() - 1)));\n        }\n        UnionFind uf = new UnionFind(graph.size());\n        for (int i = 0; i < edges.length; i++) {\n            int v1 = Integer.parseInt(edges[i][0].substring(1, edges[i][0].length() - 1));\n            int v2 = Integer.parseInt(edges[i][1].substring(1, edges[i][1].length() - 1));\n            uf.union(v1 - 1, v2 - 1);\n        }\n        int count = 0;\n        for (int i = 0; i < graph.size(); i++) {\n            if (uf.root(i) == i) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n\nclass UnionFind {\n    private List<Integer> parent;\n\n    public UnionFind(int n) {\n        parent = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            parent.add(i);\n        }\n    }\n\n    public int root(int x) {\n        if (parent.get(x) != x) {\n            parent.set(x, root(parent.get(x)));\n        }\n        return parent.get(x);\n    }\n\n    public void union(int x, int y) {\n        int r1 = root(x);\n        int r2 = root(y);\n        if (r1 != r2) {\n            parent.set(r1, r2);\n        }\n    }\n}\n```",
  "324": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrays = { {{1,5,5},2,3},{{2,6,12},3},{{1,3,4,7},{2,4,5,8}}};\n        \n        for (int i = 0; i < arrays.length; i++) {\n            wiggleSort(arrays[i][1], arrays[i][2], arrays[i][0]);\n            System.out.println(Arrays.deepToString(arrays[i][0]));\n        }\n    }\n\n    public static void wiggleSort(int k, int n, int[] arr) {\n        int left = 0;\n        int right = n - 1;\n\n        while (left < right) {\n            for (int i = left; i <= right; i++) {\n                if ((i & 1) == 0) { // even index\n                    if (arr[i] > k) {\n                        swap(arr, left++, i);\n                    }\n                } else { // odd index\n                    if (arr[i] < k) {\n                        swap(arr, --right, i);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}",
  "325": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {{-1,-1,1,1,-2,1,-3}, {0,-1,5,-5,4,-4,3,2}, {1,-1,6,3,5,3,-2,2,7}};\n        int[] expectedResults = {3, 4, 9};\n        \n        for(int i=0; i<inputs.length; i++) {\n            int result = maxSubArraySumEqualK(inputs[i]);\n            if(result != expectedResults[i]) {\n                System.out.println(\"Test Case \" + (i+1) + \" failed\");\n                return;\n            }\n        }\n        \n        System.out.println(\"All test cases passed\");\n    }\n\n    public static int maxSubArraySumEqualK(int[] nums) {\n        // Your code here\n    }\n}",
  "326": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(powerOfThree(27)); // Test case 1: 27 is power of three\n        System.out.println(powerOfThree(0)); // Test case 2: 0 is not a power of three\n        System.out.println(powerOfThree(9)); // Test case 3: 9 is power of three\n    }\n\n    public static boolean powerOfThree(int n) {\n        if (n < 1) return false;\n        while (n % 3 == 0) n /= 3;\n        return n == 1;\n    }\n}\n```",
  "327": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(subarraySum(new int[]{]-10,0,5,[-20,-9,-5,7,13,15,20], 0));\n        System.out.println(subarraySum(new int[]{}-6,1,-3,2,-2,-2,0,1,5,8], 3));\n        System.out.println(subarraySum(new int[]{}-10,-12,-7,-20,-5,4,-10,-10,-5,15], 4));\n    }\n\n    public static int subarraySum(int[] nums, int k) {\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int sum = 0;\n            for (int j = i; j < nums.length; j++) {\n                sum += nums[j];\n                if (sum == k) count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "328": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1, new ListNode(2, new ListNode(3)));\n        ListNode result1 = oddEvenList(head1);\n        while (result1 != null) {\n            System.out.print(result1.val + \" \");\n            result1 = result1.next;\n        }\n        System.out.println();\n\n        ListNode head2 = new ListNode(0, new ListNode(1, new ListNode(2)));\n        ListNode result2 = oddEvenList(head2);\n        while (result2 != null) {\n            System.out.print(result2.val + \" \");\n            result2 = result2.next;\n        }\n        System.out.println();\n\n        ListNode head3 = new ListNode(1);\n        ListNode result3 = oddEvenList(head3);\n        while (result3 != null) {\n            System.out.print(result3.val + \" \");\n            result3 = result3.next;\n        }\n        System.out.println();\n    }\n\n    public static ListNode oddEvenList(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode odd = head;\n        ListNode even = head.next;\n        ListNode evenHead = even;\n\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n\n        odd.next = evenHead;\n        return head;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n\n    ListNode(int x, ListNode y) {\n        val = x;\n        next = y;\n    }\n}\n```",
  "330": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {0, 10, -5};\n        System.out.println(patchingArray(nums1)); // Expected output: [0, 9,-4]\n\n        int[] nums2 = {1, 2, -3, 4};\n        System.out.println(patchingArray(nums2)); // Expected output: [1, 2, -3, 4]\n\n        int[] nums3 = {5, -1, 6, 7};\n        System.out.println(patchingArray(nums3)); // Expected output: [5,9,6,7]\n    }\n\n    public static int patchingArray(int[] nums) {\n        Arrays.sort(nums);\n        int res = 0;\n        for (int i = 1; i < nums.length - 1; i++) {\n            if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) {\n                res += nums[i];\n            } else {\n                res += Math.max(nums[i], nums[i - 1]);\n                nums[i] = nums[i - 1];\n            }\n        }\n        return res;\n    }\n}",
  "329": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{9, 9, 9}, {1, 6, 10}, {4, 13, 3}};\n        System.out.println(\"Expected: 3, Actual: \" + longestIncreasingPath(matrix1));\n\n        int[][] matrix2 = {{17, 13, 11}, {18, 5, 12}, {4, 19, 1}};\n        System.out.println(\"Expected: 3, Actual: \" + longestIncreasingPath(matrix2));\n\n        int[][] matrix3 = {{5, 8, 9}, {6, 7, 10}, {3, 4, 14}};\n        System.out.println(\"Expected: 4, Actual: \" + longestIncreasingPath(matrix3));\n    }\n\n    public static int longestIncreasingPath(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) {\n            return 0;\n        }\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int maxPathLength = 0;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (matrix[i][j] > maxPathLength) {\n                    maxPathLength = dfs(matrix, i, j);\n                }\n            }\n        }\n\n        return maxPathLength;\n    }\n\n    public static int dfs(int[][] matrix, int row, int col) {\n        if (row < 0 || row >= matrix.length || col < 0 || col >= matrix[0].length) {\n            return 1;\n        }\n        if (matrix[row][col] <= 0) {\n            return 0;\n        }\n\n        int currVal = matrix[row][col];\n        matrix[row][col] = -1; // mark as visited\n        int maxPathLength = 0;\n\n        for (int i = -1; i <= 1; i++) {\n            for (int j = -1; j <= 1; j++) {\n                if ((i == 0 && j == 0) || Math.abs(i) != 1 || Math.abs(j) != 1) {\n                    continue;\n                }\n                int newRow = row + i;\n                int newCol = col + j;\n\n                if (newRow >= 0 && newRow < matrix.length && newCol >= 0 && newCol < matrix[0].length &&\n                        matrix[newRow][newCol] > currVal) {\n                    maxPathLength = Math.max(maxPathLength, dfs(matrix, newRow, newCol));\n                }\n            }\n        }\n\n        matrix[row][col] = currVal; // restore original value\n        return maxPathLength + 1;\n    }\n}\n```",
  "331": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canSerialization(\"9,3,4,#,#,1,#,#\")); // true\n        System.out.println(canSerialization(\"1,2,3,#,#,4,5\")) ; // false\n        System.out.println(canSerialization(\"\")) ; // true\n    }\n\n    public static boolean canSerialization(String s) {\n        int i = 0;\n        String[] preOrder = s.split(\",\");\n        Stack<String> stack = new Stack<>();\n        while (i < preOrder.length || !stack.isEmpty()) {\n            if (i < preOrder.length && preOrder[i].equals(\"#\")) {\n                stack.push(preOrder[i]);\n                i++;\n            } else if (!stack.isEmpty() && !preOrder[i].equals(stack.peek())) {\n                return false;\n            } else if (!stack.isEmpty()) {\n                stack.pop();\n            }\n            i++;\n        }\n        return true;\n    }\n}\n```",
  "332": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<String> findItinerary(String[][] tickets) {\n        Map<String, PriorityQueue<String>> graph = new HashMap<>();\n        for (String[] ticket : tickets) {\n            String from = ticket[0];\n            String to = ticket[1];\n            graph.computeIfAbsent(from, k -> new PriorityQueue<>()).offer(to);\n        }\n\n        List<String> itinerary = new ArrayList<>();\n        reconstructItinerary(graph, \"JFK\", itinerary);\n\n        Collections.reverse(itinerary);\n        return itinerary;\n    }\n\n    private void reconstructItinerary(Map<String, PriorityQueue<String>> graph, String currentCity, List<String> itinerary) {\n        while (!graph.get(currentCity).isEmpty()) {\n            currentCity = graph.get(currentCity).poll();\n            reconstructItinerary(graph, currentCity, itinerary);\n        }\n        itinerary.add(0, currentCity);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        String[][] tickets1 = {{\"MUC\", \"LHR\"}, {\"LHR\", \"SCH\"}, {\"SCH\", \"LUN\"}, {\"LUN\", \"MUC\"}};\n        List<String> itinerary1 = solution.findItinerary(tickets1);\n        System.out.println(itinerary1);\n\n        // Test case 2\n        String[][] tickets2 = {{\"JFK\", \"SFO\"}, {\"SFO\", \"ATL\"}, {\"ATL\", \"JFK\"}, {\"JFK\", \"SFO\"}};\n        List<String> itinerary2 = solution.findItinerary(tickets2);\n        System.out.println(itinerary2);\n\n        // Test case 3\n        String[][] tickets3 = {{\"A\", \"B\"}, {\"B\", \"C\"}, {\"C\", \"D\"}, {\"D\", \"E\"}, {\"E\", \"F\"}, {\"F\", \"G\"}, {\"G\", \"A\"}};\n        List<String> itinerary3 = solution.findItinerary(tickets3);\n        System.out.println(itinerary3);\n    }\n}",
  "333": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(4);\n        root1.left.left = new TreeNode(3);\n        root1.left.right = new TreeNode(null);\n\n        System.out.println(\"Test Case 1: \" + largestBST(root1));\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(4);\n        root2.right = new TreeNode(6);\n        root2.left.left = new TreeNode(0);\n        root2.left.right = new TreeNode(2);\n\n        System.out.println(\"Test Case 2: \" + largestBST(root2));\n\n        TreeNode root3 = new TreeNode(4);\n        root3.left = new TreeNode(1);\n        root3.right = new TreeNode(6);\n\n        System.out.println(\"Test Case 3: \" + largestBST(root3));\n    }\n\n    public static int largestBST(TreeNode root) {\n        // implement the solution here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n}\n```",
  "334": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {{1, 2, 3, 4, 5}, {5, 4, 3, 2, 1}, {1, 2, 3}};\n        \n        for (int[] input : inputs) {\n            System.out.println(\"Input: \" + Arrays.toString(input));\n            System.out.println(\"Output: \" + increasingTriplet(input));\n            System.out.println();\n        }\n    }\n\n    public static boolean increasingTriplet(int[] nums) {\n        int first = Integer.MIN_VALUE, second = Integer.MIN_VALUE;\n        \n        for (int num : nums) {\n            if (num > first) {\n                if (second == Integer.MIN_VALUE)\n                    second = num;\n                else if (num > second) \n                    return true;\n            } else if (first < num && num <= second) \n                first = num;\n            else\n                first = Integer.MIN_VALUE, second = Integer.MIN_VALUE;\n        }\n        \n        return false;\n    }\n}",
  "335": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canCross(new int[][]{{0,0},{4,8},{2,5},{9,10}}));\n        System.out.println(canCross(new int[][]{{1,1},{2,3},{6,6}}));\n        System.out.println(!canCross(new int[][]{{0,0},{1,1},{2,3},{3,5}}));\n    }\n\n    public static boolean canCross(int[][] points) {\n        Map<Integer, List<int[]>> map = new HashMap<>();\n        for (int i = 0; i < points.length - 1; i++) {\n            int x1 = points[i][0];\n            int y1 = points[i][1];\n            int x2 = points[i + 1][0];\n            int y2 = points[i + 1][1];\n            if (x2 <= x1) return false;\n            for (int j = Math.max(x1, 0); j <= Math.min(x2, points[points.length - 1][0]); j++) {\n                List<int[]> list = map.computeIfAbsent(j, k -> new ArrayList<>());\n                list.add(new int[]{x1, y1});\n                list.add(new int[]{x2, y2});\n            }\n        }\n\n        for (int i = 0; i < points[0][0]; i++) {\n            if (!map.containsKey(i)) return false;\n            List<int[]> values = map.get(i);\n            for (int j = 1; j < values.size(); j++) {\n                int[] point1 = values.get(j - 1);\n                int[] point2 = values.get(j);\n                if ((point1[0] > i && point2[0] > i) || (point1[0] < i && point2[0] < i)) continue;\n                if (Math.abs(point2[1] - point1[1]) != Math.abs(i - point1[0])) return false;\n            }\n        }\n\n        return true;\n    }\n}\n```",
  "336": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(palindromePairs(new String[]{\"a\", \"b\"}, \"aa\")); // Output: [[0, 1]]\n        System.out.println(palindromePairs(new String[]{\"ad\",\"bd\",\"ea\"}, \"ab\"));// Output: [[0, 2], [1, 0]]\n        System.out.println(palindromePairs(new String[]{\"xyx\",\"xyy\",\"xxq\",\"abc\"}, \"xyz\"));// Output: [[0, 1]]\n    }\n\n    public static List<List<Integer>> palindromePairs(String[] words) {\n        // Your code here\n    }\n}",
  "337": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode tree1 = new TreeNode(3);\n        tree1.left = new TreeNode(2);\n        tree1.right = new TreeNode(1);\n        tree1.left.left = new TreeNode(4);\n        tree1.left.right = new TreeNode(5);\n        tree1.right.right = new TreeNode(7);\n\n        System.out.println(\"Test case 1: \" + rob(tree1) + \"\\n\");\n\n        TreeNode tree2 = new TreeNode(3);\n        tree2.right = new TreeNode(2);\n        tree2.right.left = new TreeNode(4);\n\n        System.out.println(\"Test case 2: \" + rob(tree2) + \"\\n\");\n\n        TreeNode tree3 = null;\n\n        System.out.println(\"Test case 3: \" + rob(tree3) + \"\\n\");\n    }\n\n    public static int rob(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(robHelp(root, false), robHelp(root, true));\n    }\n\n    public static int robHelp(TreeNode node, boolean canRob) {\n        if (node == null) {\n            return 0;\n        }\n        if (canRob) {\n            int withoutNode = robHelp(node.right, false) + robHelp(node.left, false);\n            int withNode = node.val + robHelp(node.right, true) + robHelp(node.left, true);\n            return Math.max(withoutNode, withNode);\n        } else {\n            return node.val + robHelp(node.left, true) + robHelp(node.right, true);\n        }\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "338": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countBits(10)); // Expected output: [1, 0, 1, 1, 2, 1, 2]\n        System.out.println(countBits(20)); // Expected output: [1, 0, 1, 1, 2, 1, 2, 2, 3, 2]\n        System.out.println(countBits(5)); // Expected output: [1, 1, 1, 2]\n    }\n\n    public static int[] countBits(int n) {\n        int[] result = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            result[i] = countOnes(i);\n        }\n        return result;\n    }\n\n    public static int countOnes(int n) {\n        int count = 0;\n        while (n > 0) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n}\n```",
  "339": "```\npublic class Solution {\n    public int depthSum(List<NestedInteger> nestedList) {\n        return dfs(nestedList, 1);\n    }\n\n    private int dfs(List<NestedInteger> list, int depth) {\n        int sum = 0;\n        for (NestedInteger node : list) {\n            if (node.isInteger()) {\n                sum += node.getInteger() * depth;\n            } else {\n                sum += dfs(node.getList(), depth + 1);\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<NestedInteger> list1 = new ArrayList<>();\n        list1.add(new NestedInteger(5));\n        list1.add(new NestedInteger(list1));\n        System.out.println(\"Test case 1: \" + solution.depthSum(list1)); // Output: 15\n\n        List<NestedInteger> list2 = new ArrayList<>();\n        list2.add(new NestedInteger(1));\n        list2.add(new NestedInteger(3));\n        list2.add(new NestedInteger(5));\n        System.out.println(\"Test case 2: \" + solution.depthSum(list2)); // Output: 9\n\n        List<NestedInteger> list3 = new ArrayList<>();\n        list3.add(new NestedInteger(1));\n        list3.add(new NestedInteger(4));\n        list3.add(new NestedInteger(5));\n        list3.add(new NestedInteger(list3));\n        System.out.println(\"Test case 3: \" + solution.depthSum(list3)); // Output: 11\n    }\n}\n\nclass NestedInteger {\n    public boolean isInteger() { return false; }\n    public int getInteger() { return 0; }\n    public List<NestedInteger> getList() { return new ArrayList<>(); }\n}\n```",
  "340": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(longestSubstr(\"BACB\", 1)); // Expected: \"B\"\n        System.out.println(longestSubstr(\"AA\", 0)); // Expected: \"\"\n        System.out.println(longestSubstr(\"abcba\", 2)); // Expected: \"bcb\"\n    }\n\n    public static String longestSubstr(String s, int k) {\n        if (s == null || s.isEmpty()) return \"\";\n\n        Map<Character, Integer> charCount = new HashMap<>();\n        int start = 0;\n        int maxLength = 0;\n        String result = \"\";\n\n        for (int end = 0; end < s.length(); end++) {\n            charCount.put(s.charAt(end), charCount.getOrDefault(s.charAt(end), 0) + 1);\n\n            while (charCount.size() > k) {\n                charCount.put(s.charAt(start), charCount.get(s.charAt(start)) - 1);\n                if (charCount.get(s.charAt(start)) == 0) {\n                    charCount.remove(s.charAt(start));\n                }\n                start++;\n            }\n\n            if (end - start + 1 > maxLength) {\n                maxLength = end - start + 1;\n                result = s.substring(start, end + 1);\n            }\n        }\n\n        return result;\n    }\n}\n```",
  "342": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(powerOfFour(16)); // Expected: true\n        System.out.println(powerOfFour(5)); // Expected: false\n        System.out.println(powerOfFour(1024)); // Expected: true\n    }\n\n    public static boolean powerOfFour(int n) {\n        if (n <= 0) return false;\n        return (n & (n - 1)) == 0 && ((n + 1) % 3) != 0;\n    }\n}\n```",
  "341": "```\npublic class Main {\n    public static void main(String[] args) {\n        FlattenNestedListIterator iterator = new FlattenNestedListIterator(new NestedInteger(\"[1,null,2,[3,4]]\"));\n        \n        while (iterator.hasNext()) {\n            System.out.println(iterator.next().intValue());\n        }\n    }\n}\n\nclass FlattenNestedListIterator {\n    private NestedIterator iterator;\n\n    public FlattenNestedListIterator(NestedInteger nestedList) {\n        this.iterator = new NestedIterator(nestedList);\n    }\n\n    public int next() {\n        return iterator.next();\n    }\n\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n}\n\nclass NestedIterator implements Iterator<Integer> {\n    private Queue<NestedInteger> queue;\n\n    public NestedIterator(NestedInteger nestedList) {\n        queue = new LinkedList<>();\n        flatten(nestedList, queue);\n    }\n\n    @Override\n    public boolean hasNext() {\n        return !queue.isEmpty();\n    }\n\n    @Override\n    public Integer next() {\n        int val = queue.poll().getInteger();\n        while (!queue.isEmpty() && queue.peek().isNumeric()) {\n            NestedInteger node = queue.poll();\n            if (node.getNestedIntegers().size() > 0) {\n                queue.addAll(node.getNestedIntegers());\n            }\n        }\n        return val;\n    }\n\n    private void flatten(NestedInteger nestedList, Queue<NestedInteger> queue) {\n        if (nestedList.isNumeric()) {\n            queue.offer(nestedList);\n        } else {\n            for (NestedInteger node : nestedList.getNestedIntegers()) {\n                flatten(node, queue);\n            }\n        }\n    }\n}\n\nclass NestedInteger {\n    public final boolean isNumeric() {\n        return val != null;\n    }\n\n    public final int getInteger() {\n        return val;\n    }\n\n    public final List<NestedInteger> getNestedIntegers() {\n        return list;\n    }\n\n    private Integer val;\n\n    private List<NestedInteger> list;\n\n    public NestedInteger(String s) {\n        if (s.startsWith(\"[\") && s.endsWith(\"]\")) {\n            s = s.substring(1, s.length() - 1);\n        }\n        String[] parts = s.split(\",\");\n        this.val = null;\n        this.list = new ArrayList<>();\n        for (String part : parts) {\n            if (!part.isEmpty()) {\n                if (part.startsWith(\"null\")) {\n                    val = null;\n                } else {\n                    try {\n                        val = Integer.parseInt(part);\n                    } catch (NumberFormatException e) {\n                        NestedInteger node = new NestedInteger(part);\n                        list.add(node);\n                    }\n                }\n            }\n        }\n    }\n}\n```",
  "343": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(integerBreak(2)); // Output: 1\n        System.out.println(integerBreak(10)); // Output: 36\n        System.out.println(integerBreak(9)); // Output: 729\n    }\n\n    public static int integerBreak(int n) {\n        if (n == 2) return 1;\n        if (n == 3) return 2;\n        int res = 1;\n        while (n > 4) {\n            res *= 3;\n            n -= 3;\n        }\n        res *= n;\n        return res;\n    }\n}\n```",
  "344": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reverseString(\"hello\")); // expected output: \"olleh\"\n        System.out.println(reverseString(\"abcdefg\")); // expected output: \"gfedcba\"\n        System.out.println(reverseString(\"a\")); // expected output: \"a\"\n    }\n\n    public static String reverseString(String s) {\n        char[] arr = s.toCharArray();\n        int left = 0, right = arr.length - 1;\n        while (left < right) {\n            char temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n        return new String(arr);\n    }\n}",
  "345": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reverseVowels(\"hello\")); // \"holle\"\n        System.out.println(reverseVowels(\"leetcode\")); // \"leotcede\"\n        System.out.println(reverseVowels(\"aA\")); // \"aA\"\n    }\n\n    public static String reverseVowels(String s) {\n        char[] chars = s.toCharArray();\n        int left = 0, right = s.length() - 1;\n        while (left < right) {\n            if (!isVowel(chars[left])) {\n                left++;\n                continue;\n            }\n            if (!isVowel(chars[right])) {\n                right--;\n                continue;\n            }\n            swap(chars, left, right);\n            left++;\n            right--;\n        }\n        return new String(chars);\n    }\n\n    public static boolean isVowel(char c) {\n        c = Character.toLowerCase(c);\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n\n    public static void swap(char[] chars, int i, int j) {\n        char temp = chars[i];\n        chars[i] = chars[j];\n        chars[j] = temp;\n    }\n}",
  "346": "```\npublic class Main {\n    public static void main(String[] args) {\n        MovingAverage ma = new MovingAverage(3);\n        \n        System.out.println(ma.calculate(new int[]{1, 3, 2, 4, 5, 7, 2, 6})); // expected output: [0.50000, 1.33333, 1.66667]\n        System.out.println(ma.calculate(new int[]{-1, -2, 0, 3, 10})); // expected output: [-1.00000, 0.00000, 4.00000]\n        System.out.println(ma.calculate(new int[]{5, 10, 15})); // expected output: [5.00000, 7.50000, 11.66667]\n    }\n}\n\nclass MovingAverage {\n    private Queue<Integer> queue;\n    private double sum;\n    private int count;\n\n    public MovingAverage(int size) {\n        queue = new LinkedList<>();\n        this.sum = 0;\n        this.count = 0;\n    }\n\n    public double calculate(int[] nums) {\n        for (int num : nums) {\n            queue.offer(num);\n            if (queue.size() > count) {\n                sum -= queue.poll();\n            }\n            sum += num;\n            count++;\n            return sum / count;\n        }\n        return 0.0;\n    }\n}\n```",
  "347": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {{{1, 1}, 2}, {{1}, 1}, {{1, 1, 1}, 3}};\n        for (int i = 0; i < inputs.length; i++) {\n            int[] arr = inputs[i][0];\n            int k = inputs[i][1];\n            Arrays.stream(arr).boxed().collect(Collectors.frequencyMap())\n                    .entrySet()\n                    .stream()\n                    .sorted((a, b) -> b.getValue().compareTo(a.getValue()))\n                    .limit(k)\n                    .forEach(System.out::println);\n        }\n    }\n}\n```",
  "349": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays1 = {{1, 2}, {2, 3}};\n        int[][] arrays2 = {{2, 4}};\n        System.out.println(intersect(arrays1, arrays2));\n\n        int[][] arrays3 = {{1, 2, 3}, {}};\n        int[][] arrays4 = {};\n        System.out.println(intersect(arrays3, arrays4));\n\n        int[][] arrays5 = {{1, 2, 3, 4}, {7, 8}};\n        System.out.println(intersect(arrays5, null));\n    }\n\n    public static List<Integer> intersect(int[][] nums1, int[][] nums2) {\n        Set<Integer> set1 = new HashSet<>();\n        Set<Integer> set2 = new HashSet<>();\n\n        for (int[] array : nums1) {\n            for (int num : array) {\n                set1.add(num);\n            }\n        }\n\n        for (int[] array : nums2) {\n            for (int num : array) {\n                set2.add(num);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n\n        for (int num : set1) {\n            if (set2.contains(num)) {\n                result.add(num);\n            }\n        }\n\n        return result;\n    }\n}\n```",
  "348": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TicTacToe ttt = new TicTacToe(3);\n        System.out.println(ttt.move(0, 0)); // X\n        System.out.println(ttt.move(0, 1)); // O\n        System.out.println(ttt.move(2, 2)); // X\n\n        ttt = new TicTacToe(5);\n        for (int i = 0; i < 25; i++) {\n            if ((i + 1) % 3 == 0) {\n                System.out.print(\"X\");\n            } else {\n                System.out.print(ttt.move(i, i));\n            }\n        }\n\n        ttt = new TicTacToe(2);\n        for (int i = 0; i < 4; i++) {\n            if ((i + 1) % 2 == 0) {\n                System.out.print(\"O\");\n            } else {\n                System.out.print(ttt.move(i, i));\n            }\n        }\n    }\n}\n\nclass TicTacToe {\n\n    private int n;\n    private int[][] board;\n\n    public TicTacToe(int n) {\n        this.n = n;\n        board = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(board[i], 0);\n        }\n    }\n\n    public int move(int row, int col) {\n        if (row < 0 || row >= n || col < 0 || col >= n || board[row][col] != 0) {\n            return 0;\n        }\n        board[row][col] = (board[row][col] + 1) % 2;\n        for (int i = 0; i < n; i++) {\n            if (hasWon(row, i)) {\n                return row + 1;\n            }\n            if (hasWon(i, col)) {\n                return i + 1;\n            }\n        }\n        if (hasWon(row, col)) {\n            return row + 1;\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == 0) {\n                    return row * n + j + 1;\n                }\n            }\n        }\n        return 0;\n    }\n\n    private boolean hasWon(int row, int col) {\n        for (int i = 0; i < n; i++) {\n            if (board[row][i] != board[i][col]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "350": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays1 = {{1, 2}, {7, 8, 15}};\n        int[][] arrays2 = {{3}, {5, 6}, {17, 18, 19}};\n\n        int[][] arrays3 = {{-9, -6, -3, -1}, {-4, -2}};\n        int[][] arrays4 = {{-7, -3, -1, 0}, {}};\n\n        int[][] arrays5 = {{1, 2, 3}, {4, 5}};\n\n        System.out.println(\"Test case 1: \" + intersection(arrays1[0], arrays1[1]));\n        System.out.println(\"Test case 2: \" + intersection(arrays3[0], arrays3[1]));\n        System.out.println(\"Test case 3: \" + intersection(arrays5[0], arrays5[1]));\n    }\n\n    public static List<Integer> intersection(int[] nums1, int[] nums2) {\n        Set<Integer> set1 = new HashSet<>();\n        for (int num : nums1) {\n            set1.add(num);\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int num : nums2) {\n            if (set1.contains(num)) {\n                result.add(num);\n            }\n        }\n        \n        return result;\n    }\n}\n```",
  "351": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numberOfPatterns(\"123\")); // Expected: 6\n        System.out.println(numberOfPatterns(\"1\")); // Expected: 1\n        System.out.println(numberedOFPatterns(\"01\")); // Expected: 2\n    }\n\n    public static int numberOfPatterns(int n) {\n        boolean[][] dir = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        boolean[][] dp = new boolean[n + 1][10];\n        for (int i = 1; i <= 9; i++) {\n            dp[i][i] = true;\n        }\n        for (int len = 3; len <= n; len++) {\n            for (int i = 0, cur = 0; i < len; i++, cur++) {\n                if (!dp[len][cur]) continue;\n                boolean isOk = true;\n                int pre = cur;\n                for (int j = 1; j < len; j++) {\n                    int next = (pre + dir[0][j % 4].x * len + dir[0][j % 4].y) % 10;\n                    if (!dp[len][(next + i) % 10]) isOk = false;\n                    pre = next;\n                }\n                dp[len][cur] = isOk;\n            }\n        }\n        int res = 1;\n        for (int i = 0; i <= 9; i++) {\n            res += dp[n][i];\n        }\n        return res;\n    }\n}\n```",
  "352": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        SummaryRanges sr = new SummaryRanges();\n        sr.addNum(1);\n        sr.addNum(3);\n        System.out.println(sr.getIntervals());\n        \n        sr = new SummaryRanges();\n        sr.addNum(0);\n        sr.addNum(1);\n        sr.addNum(2);\n        sr.addNum(5);\n        sr.addNum(6);\n        System.out.println(sr.getIntervals());\n\n        sr = new SummaryRanges();\n        sr.addNum(44);\n        sr.addNum(22);\n        sr.add.out(33);\n        System.out.println(sr.getIntervals());\n    }\n}\n\nclass SummaryRanges {\n    TreeSet<Integer> set;\n    List<int[]> intervals;\n\n    public SummaryRanges() {\n        this.set = new TreeSet<>();\n        this.intervals = new ArrayList<>();\n    }\n\n    public void addNum(int val) {\n        if (!set.contains(val)) {\n            set.add(val);\n            for (int[] interval : intervals) {\n                if (interval[1] + 1 == val) {\n                    interval[1] = val;\n                    return;\n                }\n                if (val < interval[0]) {\n                    int[] newInterval = {val, val};\n                    intervals.add(newInterval);\n                    return;\n                }\n            }\n            int[] newInterval = {{val, val}};\n            intervals.add(newInterval);\n        }\n    }\n\n    public List<int[]> getIntervals() {\n        List<int[]> result = new ArrayList<>();\n        for (int[] interval : intervals) {\n            if (interval[0] == interval[1]) {\n                result.add(interval);\n            } else {\n                result.add(new int[]{interval[0], interval[1]});\n            }\n        }\n        return result;\n    }\n}\n```",
  "353": "```\nimport org.junit.jupiter.api.Test;\n\npublic class Solution {\n    public static void main(String[] args) {\n        SnakeGame snakeGame1 = new SnakeGame(3, [[0,1],[0,2],[1,2]]);\n        System.out.println(snakeGame1.start(1)); // 4\n        System.out.println(snakeGame1.start(2)); // 5\n        System.out.println(snakeGame1.start(4)); // -1\n\n        SnakeGame snakeGame2 = new SnakeGame(10, [[5,3],[4,2],[6,6],[5,6],[5,6]]);\n        System.out.println(snakeGame2.start(0)); // 7\n        System.out.println(snakeGame2.start(2)); // -1\n        System.out.println(snakeGame2.start(10)); // -1\n\n        SnakeGame snakeGame3 = new SnakeGame(11, [[4,5],[5,6],[3,2]]);\n        System.out.println(snakeGame3.start(0)); // 7\n        System.out.println(snakeGame3.start(5)); // -1\n        System.out.println(snakeGame3.start(10)); // -1\n    }\n}\n\nclass SnakeGame {\n    int[] snake;\n    Map<Integer, Integer> board;\n    int direction;\n\n    public SnakeGame(int n, int[][] k) {\n        this.board = new HashMap<>();\n        this.snake = new int[n];\n        for (int i = 0; i < n; i++) {\n            snake[i] = -1;\n        }\n        for (int[] pos : k) {\n            board.put(pos[0], pos[1]);\n        }\n    }\n\n    public int start(int x) {\n        if (!board.containsKey(x)) return -1;\n        if (snake[0] == -1) {\n            snake[0] = x;\n            direction = 1;\n            return 1;\n        } else {\n            int prevX = snake[0];\n            for (int i = 1; i < snake.length; i++) {\n                if (Math.abs(snake[i-1] - x) == 1 && Math.abs(prevX - snake[i-1]) == 1) return -1;\n                else if (Math.abs(snake[i-1] - x) > 0) prevX = snake[i-1];\n            }\n            for (int i = snake.length - 1; i > 0; i--) {\n                snake[i] = snake[i-1];\n            }\n            snake[0] = x;\n            return direction == 1 ? snake.length : -1;\n        }\n    }\n}\n\n```",
  "354": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] envelopes = {{5,8},{1,4},{3,9},{7,6},{2,3}};\n        System.out.println(\"Expected: 10\");\n        System.out.println(\"Actual: \" + maxEnvelopes(envelopes));\n        \n        int[][] envelopes2 = {{1,3},{3,5},{5,7}};\n        System.out.println(\"Expected: 3\");\n        System.out.println(\"Actual: \" + maxEnvelopes(envelopes2));\n\n        int[][] envelopes3 = {{4,4},{2,6},{8,10}};\n        System.out.println(\"Expected: 3\");\n        System.out.println(\"Actual: \" + maxEnvelopes(envelopes3));\n    }\n\n    public static int maxEnvelopes(int[][] envelopes) {\n        Arrays.sort(envelopes, (a, b) -> a[0] - b[0]);\n        int[] dp = new int[envelopes.length];\n        for (int i = 0; i < envelopes.length; i++) {\n            dp[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (envelopes[j][1] < envelopes[i][1] && envelopes[j][0] < envelopes[i][0]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        int max = 0;\n        for (int i = 0; i < dp.length; i++) {\n            max = Math.max(max, dp[i]);\n        }\n        return max;\n    }\n}",
  "355": "```\nimport java.util.*;\n\npublic class Twitter {\n    // your implementation here\n}\n\nclass User {\n    int id;\n    String name;\n    public User(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Twitter twitter = new Twitter();\n        \n        // Test case 1\n        User user1 = new User(1, \"Alice\");\n        User user2 = new User(2, \"Bob\");\n        twitter.postTweet(user1.id, \"Hello World!\");\n        System.out.println(\"Test case 1: Post a tweet by Alice.\");\n        System.out.println(\"Expected output: The tweet should be posted to Alice's timeline and all followers' timelines.\\n\");\n\n        // Test case 2\n        User user3 = new User(3, \"Charlie\");\n        twitter.follow(user1.id, user3.id);\n        twitter.postTweet(user2.id, \"Hello Again!\");\n        System.out.println(\"Test case 2: Post a tweet by Bob and Charlie follows Alice.\");\n        System.out.println(\"Expected output: The tweet should be posted to Bob's timeline and all followers' timelines including Alice.\\n\");\n\n        // Test case 3\n        User user4 = new User(4, \"David\");\n        twitter.follow(user2.id, user4.id);\n        twitter.postTweet(user1.id, \"Hello Again!\");\n        System.out.println(\"Test case 3: Post a tweet by Alice and Bob follows David.\");\n        System.out.println(\"Expected output: The tweet should be posted to Bob's timeline and all followers' timelines including Charlie.\\n\");\n    }\n}\n```",
  "356": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(lineReflection(new int[][]{{1,1},{-1,1},{1,-1},{-1,-1}}));\n        System.out.println(lineReflection(new int[][]{{1,2},{2,2},{4,7},{5,6},{3,0},{3,9}}));\n        System.out.println(lineReflection(new int[][]{{0,1},{4,2},{3,3},{5,5},{-1,-1},{1,6}}));\n\n    }\n\n    public static int lineReflection(int[][] positions) {\n        Map<Integer, Integer> xMap = new HashMap<>();\n        for (int[] position : positions) {\n            if (!xMap.containsKey(position[0])) {\n                xMap.put(position[0], position[1]);\n            } else if (position[1] != xMap.get(position[0])) {\n                return 0;\n            }\n        }\n        List<Integer> ys = new ArrayList<>(xMap.values());\n        int midX = median(ys);\n        for (int[] position : positions) {\n            if (position[0] < midX) {\n                if (ys.contains(-position[1])) {\n                    return 1;\n                }\n            } else {\n                if (ys.contains(position[1])) {\n                    return 2;\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static int median(List<Integer> list) {\n        int n = list.size();\n        Integer[] array = list.toArray(new Integer[0]);\n        Arrays.sort(array);\n        return n % 2 == 0 ? (array[n / 2 - 1] + array[n / 2]) / 2 : array[n / 2];\n    }\n}\n```",
  "357": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countNumbersWithUniqueDigits(1)); // Output: 10\n        System.out.println(countNumbersWithUniqueDigits(2)); // Output: 91\n        System.out.println(countNumbersWithUniqueDigits(3)); // Output: 739\n    }\n\n    public static int countNumbersWithUniqueDigits(int n) {\n        if (n <= 0) return 1;\n        int unique = 9;\n        for (int i = 2; i < n; i++) {\n            unique *= (10 - i);\n        }\n        return unique + 1;\n    }\n}",
  "358": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(new Solution().maximumFrequency(\"aab\", 2)));\n        System.out.println(Arrays.toString(new Solution().maximumFrequency(\"aabcdbbe\", 3)));\n        System.out.println(Arrays.fromString(new Solution().maximumFrequency(\"abc\", 1)));\n    }\n}\n\nclass Solution {\n    public String[] rearrangeString(String s, int k) {\n        // Your code here\n    }\n}\n```",
  "359": "```\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LoggerRateLimiter {\n    private Map<String, Integer> map = new HashMap<>();\n    \n    public boolean shouldPrintMessage(int timestamp, String message) {\n        if (!map.containsKey(message)) {\n            map.put(message, timestamp);\n            return true;\n        } else {\n            int timeDiff = timestamp - map.get(message);\n            map.put(message, timestamp);\n            return timeDiff >= 10;\n        }\n    }\n\n    public static void main(String[] args) {\n        LoggerRateLimiter logger = new LoggerRateLimiter();\n        \n        System.out.println(logger.shouldPrintMessage(1, \"foo\")); // true\n        System.out.println(logger.shouldPrintMessage(2, \"bar\")); // true\n        System.out.println(logger.shouldPrintMessage(3, \"foo\")); // false\n    }\n}",
  "360": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] testCases = {\n                {2,1,5,3,4},{0,1,5,2,3,19},\n                {-5,-2,0,3,7}\n        };\n\n        for (int i = 0; i < testCases.length; i++) {\n            int[] result = new SortTransformedArray().sortTransformedArray(testCases[i]);\n            System.out.println(\"Test Case \" + (i+1) + \": \" + Arrays.toString(result));\n        }\n    }\n}\n\nclass SortTransformedArray {\n    public int[] sortTransformedArray(int[] arr) {\n        int n = arr.length;\n        if (n == 0) return new int[0];\n\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = Math.max(0, arr[i]) * (Math.abs(arr[i]) % 2 == 1 ? -1 : 1);\n        }\n\n        Arrays.sort(res);\n\n        return res;\n    }\n}\n```",
  "362": "```\npublic class Main {\n    public static void main(String[] args) {\n        HitCounter hitCounter = new HitCounter();\n        int[] hits1 = {1, 0};\n        for (int hit : hits1) {\n            hitCounter.hit(hit);\n            System.out.println(\"Hit count: \" + hitCounter.getHits());\n        }\n        System.out.println();\n\n        hitCounter = new HitCounter();\n        int[] hits2 = {5, 5, 5, 5, 0, 1, 5, 5, 5, 5};\n        for (int hit : hits2) {\n            hitCounter.hit(hit);\n            System.out.println(\"Hit count: \" + hitCounter.getHits());\n        }\n        System.out.println();\n\n        hitCounter = new HitCounter();\n        int[] hits3 = {1, 0, 1, 2, 5, 4, 0};\n        for (int hit : hits3) {\n            hitCounter.hit(hit);\n            System.out.println(\"Hit count: \" + hitCounter.getHits());\n        }\n    }\n}\n```",
  "361": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,2,0,0},{0,0,1,0},{1,1,1,0}};\n        System.out.println(\"Expected: 8\");\n        System.out.println(\"Actual: \" + maxAreaOfIsland(grid1));\n        \n        int[][] grid2 = {{0,0,0,0},{0,1,1,0},{0,0,1,0}};\n        System.out.println(\"Expected: 3\");\n        System.out.println(\"Actual: \" + maxAreaOfIsland(grid2));\n        \n        int[][] grid3 = {{0,0,0,0}};\n        System.out.println(\"Expected: 0\");\n        System.out.println(\"Actual: \" + maxAreaOfIsland(grid3));\n    }\n\n    public static int maxAreaOfIsland(int[][] grid) {\n        if (grid == null || grid.length == 0) return 0;\n        \n        int maxArea = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1) {\n                    maxArea = Math.max(maxArea, dfs(grid, i, j));\n                }\n            }\n        }\n        \n        return maxArea;\n    }\n\n    public static int dfs(int[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) return 0;\n        \n        grid[i][j] = 0; // mark as visited\n        \n        int area = 1;\n        for (int k = -1; k <= 1; k++) {\n            for (int l = -1; l <= 1; l++) {\n                if (k == 0 && l == 0) continue;\n                \n                int ni = i + k, nj = j + l;\n                if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\n                    area += dfs(grid, ni, nj);\n                }\n            }\n        }\n        \n        return area;\n    }\n}\n```",
  "363": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1,0,1},{0,0,1},{1,1,6}};\n        System.out.println(maxSumSubmatrix(matrix1, 8)); // expected output: 6\n\n        int[][] matrix2 = {{1,1,1},{0,1,1}};\n        System.out.println(maxSumSubmatrix(matrix2, 3)); // expected output: 4\n\n        int[][] matrix3 = {{1,0,1},{0,0,1},{1,1,5}};\n        System.out.println(maxSumSubmatrix(matrix3, 6)); // expected output: 5\n    }\n\n    public static int maxSumSubmatrix(int[][] matrix, int k) {\n        if (matrix.length == 0) return 0;\n        \n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        int ans = Integer.MIN_VALUE;\n        for (int l = 0; l < n; ++l) {\n            int[] temp = new int[m];\n            for (int r = l; r < n; ++r) {\n                for (int i = 0; i < m; ++i) {\n                    temp[i] += matrix[i][r];\n                }\n                int sum = 0;\n                int left = 0, right = m - 1;\n                while (left <= right) {\n                    if (sum + temp[left] > k) break;\n                    if (temp[left] > k) {\n                        right = left - 1;\n                        sum += temp[left];\n                        left++;\n                    } else {\n                        sum += temp[left];\n                        left++;\n                    }\n                }\n                ans = Math.max(ans, sum);\n            }\n        }\n        \n        return ans;\n    }\n}\n```",
  "364": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        NestedDepthList list1 = new NestedDepthList();\n        list1.vals = new int[][]{{4,5,6},{7,8},{9}};\n        System.out.println(weightSum(list1));\n        \n        NestedDepthList list2 = new NestedDepthList();\n        list2.vals = new int[][]{{3},{20,[10]}};\n        System.out.println(weightSum(list2));\n        \n        NestedDepthList list3 = new NestedDepthList();\n        list3.vals = new int[][]{[]};\n        System.out.println(weightSum(list3));\n    }\n\n    public static int weightSum(NestedDepthList nestedList) {\n        return dfs(nestedList, 0);\n    }\n\n    public static int dfs(NestedDepthList node, int depth) {\n        int sum = node.val;\n        if (node.vals != null && node.vals.length > 0) {\n            for (int i = 0; i < node.vals.length; i++) {\n                sum += dfs(new NestedDepthList(), depth + 1);\n            }\n        }\n        return (int) Math.pow(2, depth - 1) * sum;\n    }\n\n}\n\nclass NestedDepthList {\n    int[] vals;\n}\n```",
  "365": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canMeasure(3, 5, 4)); // Expected: true\n        System.out.println(canMeasure(2, 6, 5)); // Expected: false\n        System.out.println(canMeasure(1, 2, 3)); // Expected: true\n    }\n\n    public static boolean canMeasure(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n        if (targetCapacity > jug1Capacity || targetCapacity > jug2Capacity) {\n            return false;\n        }\n        for (int a = 0; a <= jug1Capacity; a++) {\n            for (int b = 0; b <= jug2Capacity; b++) {\n                int currentTotal = a + b;\n                if (currentTotal == targetCapacity) {\n                    return true;\n                }\n                if (currentTotal > targetCapacity && gcd(a, b) == targetCapacity) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n```",
  "366": "```\nclass Solution {\n    public List<List<Integer>> findLeaves(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        while (root != null) {\n            int oldLevel = getLevel(root);\n            root = trimTree(root, oldLevel);\n            if (oldLevel == result.size()) {\n                result.add(new ArrayList<>());\n            }\n        }\n        return result;\n    }\n\n    private int getLevel(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        int left = getLevel(node.left);\n        int right = getLevel(node.right);\n        return Math.max(left, right) + 1;\n    }\n\n    private TreeNode trimTree(TreeNode root, int level) {\n        if (root == null) {\n            return null;\n        }\n        if (level == 1) {\n            return null;\n        }\n        if (level % 2 != 0) {\n            root.left = trimTree(root.left, level - 1);\n        } else {\n            root.right = trimTree(root.right, level - 1);\n        }\n        return root;\n    }\n\n    public static void main(String[] args) {\n        TreeNode node4 = new TreeNode(4);\n        TreeNode node2 = new TreeNode(2);\n        TreeNode node7 = new TreeNode(7);\n        TreeNode node1 = new TreeNode(1);\n        TreeNode node3 = new TreeNode(3);\n        TreeNode node5 = new TreeNode(5);\n\n        node2.left = node4;\n        node2.right = node7;\n        node1.left = node2;\n        node1.right = node3;\n        node3.left = node5;\n\n        Solution solution = new Solution();\n        List<List<Integer>> result = solution.findLeaves(node1);\n\n        for (List<Integer> level : result) {\n            System.out.println(level);\n        }\n\n        // Test case 2\n        TreeNode root1 = new TreeNode(1);\n        TreeNode leftChild1 = new TreeNode(2);\n        TreeNode rightChild1 = new TreeNode(3);\n\n        root1.left = leftChild1;\n        root1.right = rightChild1;\n\n        solution = new Solution();\n        result = solution.findLeaves(root1);\n\n        for (List<Integer> level : result) {\n            System.out.println(level);\n        }\n\n        // Test case 3\n        TreeNode node6 = new TreeNode(6);\n        TreeNode node8 = new TreeNode(8);\n        TreeNode node9 = new TreeNode(9);\n        TreeNode node10 = new TreeNode(10);\n\n        node6.left = node8;\n        node6.right = node9;\n        node8.left = node10;\n\n        solution = new Solution();\n        result = solution.findLeaves(node6);\n\n        for (List<Integer> level : result) {\n            System.out.println(level);\n        }\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}",
  "367": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isPerfectSquare(16)); // true\n        System.out.println(isPerfectSquare(14)); // false\n        System.out.println(isPerfectSquare(625)); // true\n    }\n\n    public static boolean isPerfectSquare(int num) {\n        if (num < 2) return true;\n        int left = 2, right = num / 2;\n        while (left <= right) {\n            long mid = (long) left + ((right - left) / 2);\n            long square = mid * mid;\n            if (square == num) return true;\n            if (square < num) left = mid + 1;\n            else right = mid - 1;\n        }\n        return false;\n    }\n}\n```",
  "368": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] input1 = {{1, 2, 9}, 7};\n        System.out.println(\"Largest Divisible Subset for \" + input1[0].length + \": \" + largestDivisibleSubset(input1[0]).size());\n        \n        int[][] input2 = {{1, 2, 4, 10, 16, 24, 36}, 40};\n        System.out.println(\"Largest Divisible Subset for \" + input2[0].length + \": \" + largestDivisibleSubset(input2[0]).size());\n        \n        int[][] input3 = {{1, 13, 16, 24, 25, 30, 39}, 40};\n        System.out.println(\"Largest Divisible Subset for \" + input3[0].length + \": \" + largestDivisibleSubset(input3[0]).size());\n    }\n\n    public static List<Integer> largestDivisibleSubset(int[] nums) {\n        if (nums.length == 0) {\n            return new ArrayList<>();\n        }\n        \n        Arrays.sort(nums);\n        int[] dp = new int[nums.length];\n        int maxLen = 1, prevEnd = 0;\n        for (int i = 1; i < nums.length; i++) {\n            int prevStart = prevEnd, prevLen = 0;\n            for (int j = i - 1; j >= 0 && nums[i] % nums[j] == 0; j--) {\n                if (dp[j] + 1 > prevLen) {\n                    prevStart = j;\n                    prevLen = dp[j] + 1;\n                }\n            }\n            dp[i] = prevLen;\n            if (prevLen > maxLen) {\n                maxLen = prevLen;\n                prevEnd = i;\n            }\n        }\n        \n        List<Integer> res = new ArrayList<>();\n        for (int i = prevEnd; i >= 0 && dp[i] == maxLen; i--) {\n            res.add(0, nums[i]);\n        }\n        return res;\n    }\n}",
  "369": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(2);\n        System.out.println(\"Test case 1: \" + plusOne(head1));\n        \n        ListNode head2 = new ListNode(9);\n        head2.next = new ListNode(9);\n        System.out.println(\"Test case 2: \" + plusOne(head2));\n\n        ListNode head3 = new ListNode(0);\n        head3.next = new ListNode(8);\n        System.out.println(\"Test case 3: \" + plusOne(head3));\n    }\n\n    public static ListNode plusOne(ListNode head) {\n        int carry = 1;\n        ListNode current = head;\n        while (carry == 1 && current != null) {\n            if (current.next != null) {\n                current = current.next;\n            }\n            if (current.val + carry > 9) {\n                current.val += carry - 10;\n                carry = 1;\n            } else {\n                current.val += carry;\n                carry = 0;\n            }\n        }\n        if (carry == 1) {\n            ListNode newHead = new ListNode(1);\n            newHead.next = head;\n            return newHead;\n        }\n        return head;\n    }\n\n    public static class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode(int x) { val = x; }\n    }\n}",
  "371": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(getSum(1, 2)); // Expected output: 3\n        System.out.println(getSum(-1, 1)); // Expected output: 0\n        System.out.println(getSum(-2, -3)); // Expected output: -5\n    }\n\n    public static int getSum(int a, int b) {\n        while (b != 0) {\n            int carry = a ^ b;\n            b = (a & b) << 1;\n            a = carry;\n        }\n        return a;\n    }\n}",
  "370": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {1, -1, 5};\n        System.out.println(\"Expected: \" + 6 + \", Actual: \" + rangeSum(nums1));\n        \n        int[] nums2 = {5, 1, 5, 5};\n        System.out.println(\"Expected: \" + 15 + \", Actual: \" + rangeSum(nums2));\n\n        int[] nums3 = [0];\n        System.out.println(\"Expected: \" + 0 + \", Actual: \" + rangeSum([0]));\n    }\n\n    public static int rangeSum(int[] nums) {\n        int n = nums.length;\n        int[] prefix = new int[n+1];\n        \n        for (int i = 0; i < n; i++) {\n            prefix[i+1] = prefix[i] + nums[i];\n        }\n        \n        int sum = 0;\n        for (int i = 0; i <= n; i++) {\n            sum += Math.min(i, n-i-1) * (prefix[i+1]-prefix[i]);\n        }\n        \n        return sum;\n    }\n}",
  "372": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int a = 2;\n        int b = 5;\n        System.out.println(myPow(a, b));\n\n        a = 2;\n        b = 10;\n        System.out.println(myPow(a, b));\n\n        a = 3;\n        b = -1;\n        System.out.println(myPow(a, b));\n    }\n\n    public static double myPow(double x, int n) {\n        if (n < 0) {\n            return 1 / quickMul(x, Math.abs(n));\n        } else {\n            return quickMul(x, n);\n        }\n    }\n\n    private static double quickMul(double x, int n) {\n        double res = 1.0;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                res *= x;\n            }\n            x *= x;\n            n >>= 1;\n        }\n        return res;\n    }\n}",
  "373": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrays = {{1, 7}, {2, 3, 4}};\n        int k = 3;\n        Arrays.stream(new Integer[][]{{1, 1}, {1, 5}}).forEach(println);\n        System.out.println();\n        Arrays.stream(new Integer[][]{{-4,-1},{5,200}}).forEach(println);\n        System.out.println();\n        Arrays.stream(new Integer[][]{{34,23,4,3,1},{-47,19,15,8,5},{-94,-45,61}}).forEach(println);\n\n    }\n\n    private static void println(Object o) {\n        System.out.println(o);\n    }\n}\n```",
  "374": "```\npublic class Main {\n    public static void main(String[] args) {\n        GuessGame game = new GuessGame(10);\n        \n        System.out.println(game.guess(\"higher\")); // Test case 1\n        System.out.println(game.guess(\"lower\")); // Test case 2\n        System.out.println(game.guess(\"higher\")); // Test case 3\n        \n    }\n}\n\nclass GuessGame {\n    int secret;\n    \n    public GuessGame(int n) {\n        this.secret = n;\n    }\n    \n    public String guess(String tip) {\n        if (tip.equals(\"higher\")) {\n            return guess((secret + 1) / 2).equals(\"lower\") ? \"higher\" : \"lower\";\n        } else {\n            int left = 0, right = secret;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                if (mid == secret) return \"Bang!\";\n                String tipFromMid = guess(mid < secret ? \"higher\" : \"lower\");\n                if (tipFromMid.equals(\"higher\")) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            return tip.equals(\"higher\") ? \"higher\" : \"lower\";\n        }\n    }\n}\n```",
  "375": "```\npublic class Main {\n    public static void main(String[] args) {\n        GuessGame game = new GuessGame(10);\n        System.out.println(game.guess(\"8\") == -1 ? \"Not found\" : game.number); // Test case 1: number is not found\n        System.out.println(game.guess(\"5\") == 2 ? \"\" : \"Error\"); // Test case 2: number is found and the guess is correct\n        System.out.println(game.guess(\"7\") == 3 ? \"\" : \"Error\"); // Test case 3: number is found and the guess is incorrect\n    }\n}\n```",
  "376": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(wiggleMaxLength(new int[]{1,2,3,4,5,6,7,8,9})); // Output: 9\n        System.out.println(wiggleMaxLength(new int[]{1,5,7,10,11,12,13,14,15})); // Output: 6\n        System.out.println(wiggleMaxLength(new int[]{1,3,2,4,1,5,3,2,4,5})); // Output: 9\n    }\n\n    public static int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2) return nums.length;\n        int up = 1, down = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[i - 1]) {\n                up = down + 1;\n                down = 1;\n            } else if (nums[i] < nums[i - 1]) {\n                down = up + 1;\n                up = 1;\n            }\n        }\n        return Math.max(up, down);\n    }\n}\n```",
  "377": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] combinations1 = {{2, 3}, {7}};\n        System.out.println(combinationSum4(9, combinations1)); // Expected: 2\n\n        int[][] combinations2 = {{1, 2, 3}};\n        System.out.println(combinationSum4(10, combinations1)); // Expected: 0\n\n        int[][] combinations3 = {{4, 5, 6}};\n        System.out.println(combinationSum4(15, combinations3)); // Expected: 5\n    }\n\n    public static int combinationSum4(int target, int[][] combinations) {\n        int[] dp = new int[target + 1];\n        dp[0] = 1;\n        for (int i = 0; i <= target; i++) {\n            for (int j : combinations) {\n                if (i >= j[0]) {\n                    dp[i] += dp[i - j[0]];\n                }\n                if (i >= j[1]) {\n                    dp[i] += dp[i - j[1]];\n                }\n            }\n        }\n        return dp[target];\n    }\n}\n```",
  "378": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1, 5, 9}, {2, 6, 10}, {3, 8, 19}};\n        System.out.println(kthSmallest(matrix1, 6)); // Expected output: 6\n\n        int[][] matrix2 = {{1, 2}, {3, 4}};\n        System.out.println(kthSmallest(matrix2, 2)); // Expected output: 2.5\n\n        int[][] matrix3 = {{1, 3, 5}, {2, 5, 9}, {3, 6, 11}};\n        System.out.println(kthSmallest(matrix3, 4)); // Expected output: 8\n    }\n\n    public static double kthSmallest(int[][] matrix, int k) {\n        int rows = matrix.length;\n        if (rows == 0) return -1;\n\n        int cols = matrix[0].length;\n        if (cols == 0) return -1;\n\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> Integer.compare(matrix[a/cols][a%cols], matrix[b/cols][b%cols]));\n        for (int i = 0; i < rows * cols; i++) {\n            pq.add(i);\n        }\n\n        for (int i = 0; i < k - 1; i++) {\n            pq.poll();\n        }\n\n        return (double) pq.peek() / (double) Math.min(rows, cols);\n    }\n}",
  "379": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        PhoneDirectory directory = new PhoneDirectory(3);\n        System.out.println(directory.get() + \" \" + directory.get() + \" \" + directory.get()); // Output: 0 1 2\n        System.out.println(directory.checkAvailable(2)); // Output: true\n        System.out.println(directory.release(2)); // Output: null\n        System.out.println(directory.checkAvailable(2)); // Output: false\n\n        directory = new PhoneDirectory(10);\n        System.out.println(directory.get()); // Output: 0\n        System.out.println(directory.get()); // Output: 1\n        System.out.println(directory.get()); // Output: 2\n        System.out.println(directory.get()); // Output: 3\n        System.out.println(directory.checkAvailable(7)); // Output: true\n        System.out.println(directory.release(5)); // Output: 5\n        System.out.println(directory.get()); // Output: 4\n\n        directory = new PhoneDirectory(1);\n        System.out.println(directory.get()); // Output: 0\n        System.out.println(directory.release(0)); // Output: null\n    }\n}\n\nclass PhoneDirectory {\n    int max;\n    Map<Integer, Integer> available;\n    Queue<Integer> used;\n\n    public PhoneDirectory(int max) {\n        this.max = max;\n        this.available = new HashMap<>();\n        for (int i = 0; i < max; i++) {\n            available.put(i, 1);\n        }\n        this.used = new LinkedList<>();\n    }\n\n    public int get() {\n        if (!used.isEmpty()) {\n            int num = used.poll();\n            available.put(num, 1);\n            return num;\n        } else if (available.size() > 0) {\n            int num = (int) available.keySet().iterator().next();\n            available.remove(num);\n            return num;\n        }\n        return -1;\n    }\n\n    public boolean checkAvailable(int number) {\n        return available.containsKey(number) && available.get(number) == 1;\n    }\n\n    public void release(int number) {\n        if (number < max) {\n            available.put(number, 1);\n            used.add(number);\n        }\n    }\n}\n```",
  "380": "```\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        RandomizedQueue randomizedQueue = new RandomizedQueue();\n        \n        // Test case 1: Insert, delete and get random elements\n        for (int i = 0; i < 5; i++) {\n            randomizedQueue.enqueue(i);\n        }\n        System.out.println(\"Random element: \" + randomizedQueue.getRandomElement());\n        randomizedQueue.dequeue();\n        System.out.println(\"Random element after dequeue: \" + randomizedQueue.getRandomElement());\n\n        // Test case 2: Insert, insert and get random elements\n        for (int i = 0; i < 10; i++) {\n            randomizedQueue.enqueue(i);\n        }\n        System.out.println(\"Random element: \" + randomizedQueue.getRandomElement());\n        randomizedQueue.dequeue();\n        System.out.println(\"Random element after dequeue: \" + randomizedQueue.getRandomElement());\n\n        // Test case 3: Delete, delete and get random elements\n        for (int i = 0; i < 5; i++) {\n            randomizedQueue.enqueue(i);\n        }\n        randomizedQueue.dequeue();\n        randomizedQueue.dequeue();\n        System.out.println(\"Random element after two dequeues: \" + randomizedQueue.getRandomElement());\n    }\n}\n\nclass RandomizedQueue {\n    private List<Integer> queue;\n    private Random random;\n\n    public RandomizedQueue() {\n        this.queue = new ArrayList<>();\n        this.random = new Random();\n    }\n\n    public void enqueue(int val) {\n        this.queue.add(val);\n    }\n\n    public int dequeue() {\n        if (this.queue.isEmpty()) return -1;\n        int result = this.queue.remove(0);\n        return result;\n    }\n\n    public int getRandomElement() {\n        if (this.queue.isEmpty()) return -1;\n        return this.queue.get(random.nextInt(this.queue.size()));\n    }\n}\n```",
  "381": "```\nimport java.util.*;\n\nclass RandomizedCollection {\n    Map<Integer, Set<Integer>> valToIndex;\n    List<Integer> bucket;\n\n    public RandomizedCollection() {\n        valToIndex = new HashMap<>();\n        bucket = new ArrayList<>();\n    }\n\n    public boolean insert(int val) {\n        if (!valToIndex.containsKey(val)) {\n            valToIndex.put(val, new HashSet<>());\n        }\n        int index = bucket.size();\n        bucket.add(val);\n        valToIndex.get(val).add(index);\n        return valToIndex.get(val).size() == 1;\n    }\n\n    public boolean remove(int val) {\n        if (!valToIndex.containsKey(val)) {\n            return false;\n        }\n        int index = valToIndex.get(val).iterator().next();\n        bucket.set(index, bucket.get(bucket.size() - 1));\n        valToIndex.get(bucket.remove(bucket.size() - 1)).remove(index);\n        if (valToIndex.get(val).size() == 1) {\n            valToIndex.remove(val);\n        }\n        return true;\n    }\n\n    public int getRandom(int n) {\n        Random random = new Random();\n        return bucket.get(random.nextInt(n));\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        RandomizedCollection rc = new RandomizedCollection();\n\n        System.out.println(\"Test 1:\");\n        System.out.println(rc.insert(1)); // true\n        System.out.println(rc.getRandom(rc.bucket.size())); // 1\n\n        System.out.println(\"\\nTest 2:\");\n        rc.remove(1); // true\n        System.out.println(rc.getRandom(0)); // -1 (no elements)\n\n        System.out.println(\"\\nTest 3:\");\n        rc.insert(1);\n        rc.insert(1);\n        rc.insert(2);\n        System.out.println(rc.getRandom(3)); // 1 or 2 (either one is fine)\n    }\n}",
  "382": "```\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(3);\n        System.out.println(\"Test case 1: \" + solution.getRandom(head1));\n\n        // Test case 2\n        ListNode head2 = new ListNode(0);\n        head2.next = new ListNode(1);\n        System.out.println(\"Test case 2: \" + solution.getRandom(head2));\n\n        // Test case 3\n        ListNode head3 = new ListNode(1);\n        head3.next = new ListNode(2);\n        head3.next.next = new ListNode(3);\n        head3.next.next.next = new ListNode(4);\n        System.out.println(\"Test case 3: \" + solution.getRandom(head3));\n    }\n}\n\nclass Solution {\n    public int getRandom(ListNode head) {\n        if (head == null || head.next == null) return head.val;\n\n        Random random = new Random();\n        ListNode p1 = head;\n        ListNode p2 = head;\n        int result = 0;\n\n        for (int i = 0; i < 10000; i++) {\n            p2 = p2.next;\n            if (p2 == null) break;\n            if (random.nextInt(10001) > 9999) {\n                p1 = p2;\n                result = p1.val;\n            }\n        }\n\n        return result;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int x) { val = x; }\n}\n```",
  "383": "```\npublic class Main {\n    public static void main(String[] args) {\n        canConstruct(\"aa\", \"aab\"); // false\n        canConstruct(\"a\", \"b\"); // true\n        canConstruct(\"aa\", \"aaa\"); // false\n    }\n\n    public static boolean canConstruct(String ransomNote, String magazine) {\n        int[] map = new int[26];\n        for (int i = 0; i < magazine.length(); i++) {\n            map[magazine.charAt(i) - 'a']++;\n        }\n        for (int i = 0; i < ransomNote.length(); i++) {\n            if (map[ransomNote.charAt(i) - 'a'] == 0) return false;\n            else map[ransomNote.charAt(i) - 'a']--;\n        }\n        return true;\n    }\n}",
  "384": "```\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2,5,1,3};\n        shuffle(nums1);\n        System.out.println(Arrays.toString(nums1));\n\n        int[] nums2 = {1,2,3,4,5};\n        shuffle(nums2);\n        System.out.println(Arrays.toString(nums2));\n\n        int[] nums3 = {1};\n        shuffle(nums3);\n        System.out.println(Arrays.toString(nums3));\n    }\n\n    public static void shuffle(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            int j = (int) (Math.random() * (i + 1));\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n    }\n}",
  "385": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(parseMiniwG(\"8()\")); // true\n        System.out.println(parseMini(\"3+a(b(c))\")); // true\n        System.out.println(parseMini(\"3+3\")); // true\n    }\n\n    public static boolean parseMiniWG(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                stack.push(c);\n            } else if (c == ')') {\n                if (stack.isEmpty() || stack.pop() != '(') {\n                    return false;\n                }\n            }\n        }\n        return stack.isEmpty();\n    }\n\n    public static boolean parseMini(String s) {\n        int open = 0, close = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                open++;\n            } else if (c == ')') {\n                close++;\n            }\n        }\n        return open == close;\n    }\n}\n```",
  "386": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] num = {{12}, {8,9}, {1,2,6}};\n        \n        for (int i = 0; i < num.length; i++) {\n            List<Integer> result = lexicalNumbers(num[i]);\n            System.out.println(\"Input: \" + Arrays.toString(num[i]));\n            System.out.println(\"Output: \" + result);\n            System.out.println();\n        }\n    }\n\n    public static List<Integer> lexicalNumbers(int[] num) {\n        // your code here\n    }\n}\n```",
  "387": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(firstUniqChar(\"leetcode\")); // Output: 0\n        System.out.println(firstUniqChar(\"loveleetcode\")); // Output: 2\n        System.out.println(firstUniqChar(\"aabb\")); // Output: -1\n    }\n\n    public static int firstUniqChar(String s) {\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (count[s.charAt(i) - 'a'] == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
  "388": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(longestPath(\"~/file/level1/folderA/folderB/fileA.txt\"));\n        System.out.println(longestPath(\"/home/a/../../../../../usr/home/..../b/b.txt\"));\n        System.out.println(longestPath(\"/home/folderA/folderB/folderC/superfolder/folderD/folderE/file.txt\"));\n    }\n\n    public static String longestPath(String root) {\n        if (root == null || root.isEmpty()) return \"\";\n        \n        int maxLen = 0;\n        String res = \"\";\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < root.length(); i++) {\n            char c = root.charAt(i);\n            if (c == '/') {\n                if (sb.length() > maxLen) {\n                    maxLen = sb.length();\n                    res = sb.toString();\n                }\n                sb.setLength(0);\n            } else if (c == '.') {\n                int start = i;\n                while (i < root.length() && root.charAt(i) == '.') i++;\n                if (start + 1 < i) {\n                    sb.append(root, start + 1, i).append(\"/\");\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n        return res;\n    }\n}\n```",
  "389": "```\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = \"a\";\n        String s2 = \"bananas\";\n        System.out.println(findTheDifference(s1, s2)); // expected output: \"anana\"\n\n        s1 = \"abc\";\n        s2 = \"abcd\";\n        System.out.println(findTheDifference(s1, s2)); // expected output: \"d\"\n\n        s1 = \"\";\n        s2 = \"a\";\n        System.out.println(findTheDifference(s1, s2)); // expected output: \"a\"\n    }\n\n    public static char findTheDifference(String s1, String s2) {\n        int[] count = new int[26];\n        for (char c : s2.toCharArray()) {\n            count[c - 'a']++;\n        }\n        for (char c : s1.toCharArray()) {\n            count[c - 'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (count[i] > 0) {\n                return (char) (i + 'a');\n            }\n        }\n        return '\\0';\n    }\n}\n```",
  "390": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(nthPersonToSit(2, 7)); // Expected output: 4\n        System.out.println(nthPersonToSit(5, 10)); // Expected output: 5\n        System.out.println(nthPersonToSit(1, 9)); // Expected output: 6\n    }\n\n    public static int nthPersonToSit(int n, int m) {\n        return (m + 1) / 2;\n    }\n}",
  "391": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] rec1 = {{1,4},{4,8},{10,20},{5,15}};\n        System.out.println(\"Case 1: \" + perfectRectangle(rec1));\n        \n        int[][] rec2 = {{1,3},{2,6},{8,10},{9,11}};\n        System.out.println(\"Case 2: \" + perfectRectangle(rec2));\n\n        int[][] rec3 = {{0,5},{7,9},{4,15},{3,5},{20,23}};\n        System.out.println(\"Case 3: \" + perfectRectangle(rec3));\n    }\n\n    public static int perfectRectangle(int[][] rectangles) {\n        // Your code here\n        return 0; \n    }\n}\n```",
  "392": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isSubsequence(\"abc\", \"ahbgdc\") ? \"true\" : \"false\"); // Test case 1: Should return true\n        System.out.println(isSubsequence(\"axc\", \"ahbgdc\") ? \"true\" : \"false\"); // Test case 2: Should return false\n        System.out.println(isSubsequence(\"abc\", \"bca\") ? \"true\" : \"false\"); // Test case 3: Should return true\n    }\n\n    public static boolean isSubsequence(String s, String t) {\n        int i = 0, j = 0;\n        while (i < s.length() && j < t.length()) {\n            if (s.charAt(i) == t.charAt(j)) {\n                i++;\n            }\n            j++;\n        }\n        return i == s.length();\n    }\n}",
  "393": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        boolean[] cases = {\n            validateUtf8(\"a\"), // Test case 1: single byte\n            !validateUtf8(\"\\xc2\\x82\"), // Test case 2: invalid sequence\n            validateUtf8(\"\\xe4\\xb8\\xa4\") // Test case 3: valid UTF-8 sequence\n        };\n\n        for (int i = 0; i < cases.length; i++) {\n            System.out.println(\"Test case \" + (i+1) + \": \" + cases[i]);\n        }\n    }\n\n    public static boolean validateUtf8(String s) {\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            int c = s.charAt(i);\n            if ((c & 0x80) == 0) continue;\n            int count = 1;\n            while ((c & 0xc0) != 0) {\n                count++;\n                c = (c << 6) | (s.charAt(i + 1) & 0x3f);\n                i++;\n            }\n            return (count <= n - i) && ((1 << (5 - count)) & 0xe0) == 0;\n        }\n        return true;\n    }\n}\n```",
  "394": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(decoder(\"3[a]2[bc]\")); // Output: \"aaabcc\"\n        System.out.println(decoder(\"100[leetcode]\")); // Output: \"leetcodeleetcodeleetcodeleetcode\"\n        System.out.println(decoder(\"4[ab3[c]]\")); // Output: \"abcccccccadabcdabcdabcd\"\n    }\n\n    public static String decoder(String s) {\n        int i = 0;\n        return decodeHelper(s, i);\n    }\n\n    public static String decodeHelper(String s, int i) {\n        StringBuilder sb = new StringBuilder();\n        while (i < s.length()) {\n            if (Character.isDigit(s.charAt(i))) {\n                i = processNumerical(s, i, sb);\n            } else if (s.charAt(i) == ']') {\n                return sb.toString() + decodeHelper(sb.toString().substring(0, sb.length() - 2), 0).toString();\n            } else {\n                sb.append(s.charAt(i));\n                i++;\n            }\n        }\n        return sb.toString();\n    }\n\n    public static int processNumerical(String s, int i, StringBuilder sb) {\n        int count = 0;\n        while (i < s.length() && Character.isDigit(s.charAt(i))) {\n            count = count * 10 + Character.getNumericValue(s.charAt(i));\n            i++;\n        }\n        for (int j = 0; j < count; j++) {\n            sb.append(decodeHelper(sb.toString(), 0).toString().charAt(0));\n        }\n        return i;\n    }\n}\n```",
  "395": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestSubstringWithAtLeastKRepeatingCharacters(\"aaabb\", 3));\n        System.out.println(longestSubstringWithAtLeastKRepeatingCharacters(\"abccde\", 2));\n        System.out.println(longestSubstringWithAtLeastKRepeatingCharacters(\"aabbbb\", 1));\n    }\n\n    public static String longestSubstringWithAtLeastKRepeatingCharacters(String s, int k) {\n        // Your code here\n    }\n}\n```",
  "396": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(rotateFunc(new int[]{4, 2, 0}, 1)); // expected output: 8\n        System.out.println(rotateFunc(new int[]{1, 2, 3, 4, 5}, 2)); // expected output: 13\n        System.out.println(rotateFunc(new int[]{0, 1, 0], 2)); // expected output: 1\n    }\n\n    public static int rotateFunc(int[] nums, int k) {\n        k = k % nums.length;\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if ((i + 1) <= k) {\n                sum += nums[nums.length - 1 - i];\n            } else {\n                sum += nums[i];\n            }\n        }\n        return sum;\n    }\n}",
  "397": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n1 = 15;\n        System.out.println(\"Integer replacement for \" + n1 + \": \" + integerReplacement(n1));\n        \n        int n2 = 1234;\n        System.out.println(\"Integer replacement for \" + n2 + \": \" + integerReplacement(n2));\n        \n        int n3 = 10000;\n        System.out.println(\"Integer replacement for \" + n3 + \": \" + integerReplacement(n3));\n    }\n\n    public static int integerReplacement(int n) {\n        // Your code here\n    }\n}\n```",
  "398": "```\nimport java.util.Random;\n\npublic class Solution {\n    private Random rand;\n    private int[] nums;\n\n    public Solution(int[] nums) {\n        this.nums = nums;\n        this.rand = new Random();\n    }\n\n    public int pickIndex() {\n        for (int i = 0; i < nums.length; i++) {\n            double r = rand.nextDouble();\n            if (r <= (1.0 / (double) nums.length)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] nums1 = {1,2};\n        Solution solution1 = new Solution(nums1);\n        System.out.println(\"Test case 1: \" + solution1.pickIndex());\n\n        int[] nums2 = {0,1};\n        Solution solution2 = new Solution(nums2);\n        System.out.println(\"Test case 2: \" + solution2.pickIndex());\n\n        int[] nums3 = [1,2];\n        Solution solution3 = new Solution(nums3);\n        System.out.println(\"Test case 3: \" + solution3.pickIndex());\n    }\n}",
  "399": "```\npublic class Main {\n    public static void main(String[] args) {\n        String[] equations = { \"a=1,b=2,c=3\", \"b=10,c=5\" };\n        double[] values = { 3.0, 0.5 };\n        String[] queries = { \"a\", \"b\", \"c\" };\n\n        System.out.println(evaluateDivisions(equations, values, queries));\n    }\n\n    public static List<String> evaluateDivisions(String[] equations, double[] values, String[] queries) {\n        // Your code here\n    }\n}\n```",
  "400": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findNthDigit(3));\n        System.out.println(findNthDigit(9));\n        System.out.println(findNthDigit(4));\n    }\n\n    public static int findNthDigit(int n) {\n        long len = 1;\n        long start = 1;\n\n        while (n > len) {\n            n -= len;\n            len++;\n            start *= 10;\n        }\n\n        for (long i = start; n > 0; n--) {\n            if (n == 1) {\n                return (int) (i % 10);\n            }\n            i++;\n        }\n\n        return (int) ((i / 10) % 10);\n    }\n}\n```",
  "401": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + readBinaryWatch(1));\n        System.out.println(\"Test Case 2: \" + readBinaryWatch(9));\n        System.out.println(\"Test Case 3: \" + readBinaryWatch(10));\n    }\n\n    public static String readBinaryWatch(int N) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j <= N; j++) {\n                if (((i << 1 | j) & 15) < 60 && ((i << 4 | j >> 1) & 15) < 60) {\n                    sb.append(String.format(\"%02d:%02d\", i, j));\n                    sb.append(\"\\n\");\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "402": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removeKDigits(\"1432219\", 3)); // Expected: \"1219\"\n        System.out.println(removeKDigits(\"10200\", 1)); // Expected: \"100\"\n        System.out.println(removeKDigits(\"50050mighty\", 3)); // Expected: \"125\"\n    }\n\n    public static String removeKDigits(String num, int k) {\n        StringBuilder sb = new StringBuilder();\n        Stack<Character> stack = new Stack<>();\n\n        for (char c : num.toCharArray()) {\n            while (!stack.isEmpty() && stack.peek() > c && k-- > 0) {\n                stack.pop();\n            }\n            if (k == 0) break;\n            if (!stack.isEmpty() || c != '0') {\n                sb.append(c);\n                stack.push(c);\n            }\n        }\n\n        while (!stack.isEmpty()) {\n            sb.append(stack.pop());\n        }\n\n        return k > 0 ? \"0\".repeat(k) : sb.toString();\n    }\n}\n```",
  "403": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] positions = {{0,0}, {1,1}, {2,4}};\n        for (int i = 0; i < positions.length; i++) {\n            System.out.println(\"Frog jump at position \" + positions[i][0] + \": \" + canCross(positions[i][0], positions[i][1]));\n        }\n    }\n\n    public static boolean canCross(int target) {\n        int[] dp = new int[target + 1];\n        for (int i = 1; i <= target; i++) {\n            if (i - 1 >= 0 && i % (i - 1) == 0) {\n                dp[i] += dp[i - 1];\n            }\n            if (i - 2 >= 0 && i % (i - 2) == 0) {\n                dp[i] += dp[i - 2];\n            }\n            if (i - 3 >= 0 && i % (i - 3) == 0) {\n                dp[i] += dp[i - 3];\n            }\n        }\n        return dp[target] > 0;\n    }\n}",
  "404": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root = new Node(3);\n        root.left = new Node(9);\n        root.right = new Node(20);\n        root.right.left = new Node(15);\n        root.right.right = new Node(7);\n\n        System.out.println(\"Sum of left leaves for the given tree is \" + sumOfLeftLeaves(root));\n\n        Node root2 = new Node(1);\n        root2.left = new Node(2);\n        root2.right = new Node(3);\n\n        System.out.println(\"Sum of left leaves for the given tree is \" + sumOfLeftLeaves(root2));\n\n        Node root3 = null;\n\n        System.out.println(\"Sum of left leaves for the given tree is \" + sumOfLeftLeaves(root3));\n    }\n\n    public static int sumOfLeftLeaves(Node root) {\n        if (root == null) {\n            return 0;\n        }\n        int sum = 0;\n        if (root.left != null && isLeaf(root.left)) {\n            sum += root.left.val;\n        }\n        if (root.right != null) {\n            sum += sumOfLeftLeaves(root.right);\n        }\n        if (root.left != null && !isLeaf(root.left)) {\n            sum += sumOfLeftLeaves(root.left);\n        }\n        return sum;\n    }\n\n    public static boolean isLeaf(Node node) {\n        return node.left == null && node.right == null;\n    }\n}\n\nclass Node {\n    int val;\n    Node left, right;\n\n    Node(int x) {\n        val = x;\n    }\n}\n```",
  "405": "```\npublic class Main {\n    public static void main(String[] args) {\n        int num1 = 26;\n        System.out.println(\"26 in hexadecimal is \" + toHex(num1));\n        \n        int num2 = -5;\n        System.out.println(\"-5 in hexadecimal is \" + toHex(num2));\n\n        int num3 = Integer.MAX_VALUE;\n        System.out.println(\"2147483647 in hexadecimal is \" + toHex(num3));\n    }\n\n    public static String toHex(int n) {\n        if (n == 0) return \"0\";\n        StringBuilder result = new StringBuilder();\n        for (; n != 0; ) {\n            int remainder = n % 16;\n            n /= 16;\n            result.append(remainder < 10 ? remainder : (char)(remainder - 10 + 'A'));\n        }\n        return result.reverse().toString();\n    }\n}\n```",
  "406": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] people = {{7,0},{4,2},{7,1}};\n        reconstructQueue(people);\n\n        people = new int[][]{{9,0},{7,1},{5,2},{3,2},{2,1},{6,1},{5,0}};\n        reconstructQueue(people);\n\n        people = new int[][]{{6,0},{5,0},{4,2},{3,1},{2,1},{1,1},{0,0}};\n        reconstructQueue(people);\n    }\n\n    public static void reconstructQueue(int[][] people) {\n        Arrays.sort(people, (a, b) -> a[0] - b[0]);\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n\n        for (int[] person : people) {\n            pq.add(person);\n        }\n\n        int idx = 0;\n        while (!pq.isEmpty()) {\n            int[] front = pq.poll();\n            System.out.println(Arrays.toString(front));\n            idx++;\n        }\n    }\n}",
  "407": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(trappingRainWater(new int[][]{{0,1,0,0},{2,4,5,0},{7,6,3,0}}));\n        System.out.println(trappingRainWater(new int[][]{{12,13,1,14,15,0},{11,25,22,8,24,16},{57,58,47,33,52,17},{19,4,23,50,53,60},{63,21,44,46,54,20},{39,31,18,48,49,27}}));\n        System.out.println(trappingRainWater(new int[][]{{2,0,1},{1,3,2},{0,5,0}}));\n    }\n\n    public static int trappingRainWater(int[][] heightMap) {\n        if (heightMap.length == 0) return 0;\n        int m = heightMap[0].length, n = heightMap.length;\n        boolean[][] visited = new boolean[n][m];\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->(b[1]-a[1]));\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == 0 || j == 0 || i == n-1 || j == m-1) queue.add(new int[]{i, j});\n                else visited[i][j] = true;\n            }\n        }\n        while (!queue.isEmpty()) {\n            int[] cell = queue.poll();\n            int x = cell[0], y = cell[1];\n            if (visited[x][y]) continue;\n            visited[x][y] = true;\n            int h = heightMap[x][y];\n            for (int dx : new int[]{-1, 1}) {\n                for (int dy : new int[]{-1, 1}) {\n                    int nx = x + dx, ny = y + dy;\n                    if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n                    if (!visited[nx][ny] && heightMap[nx][ny] > h) {\n                        ans += Math.max(0, h - heightMap[nx][ny]);\n                        queue.add(new int[]{nx, ny});\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n```",
  "408": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeAbbreviated(\"Internationalization\", \"i18n\") + \"\\n\"); // Expected: true\n        System.out.println(canBeAbbreviated(\"Apple pie\", \"a3e1l\") + \"\\n\"); // Expected: false\n        System.out.println(canBeAbbreviated(\"Word\", \"2d\") + \"\\n\"); // Expected: false\n    }\n\n    public static boolean canBeAbbreviated(String word, String abbr) {\n        int wordIndex = 0;\n        int abbrIndex = 0;\n\n        while (wordIndex < word.length() && abbrIndex < abbr.length()) {\n            if (word.charAt(wordIndex) == abbr.charAt(abbrIndex)) {\n                wordIndex++;\n                abbrIndex++;\n            } else if (Character.isLetter(word.charAt(wordIndex))) {\n                return false;\n            } else {\n                abbrIndex++;\n            }\n        }\n\n        return true;\n    }\n}",
  "409": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestPalindrome(\"babad\")); // Output: \"bab\"\n        System.out.println(longestPalindrome(\"cbbd\")); // Output: \"bb\"\n        System.out.println(longestPalindrome(\"a\")); // Output: \"a\"\n    }\n\n    public static String longestPalindrome(String s) {\n        int start = 0, end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            start = expandAroundCenter(s, i, i);\n            end = expandAroundCenter(s, i, i + 1);\n            if (start > end) {\n                end = start;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n\n    public static int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n}",
  "410": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(splitArrayLargestSum(new int[]{10,2,-2,-20,0,9,-4,7,4,-4,-10}, new int[]{0, 2, 6}));\n        System.out.println(splitArrayLargestSum(new int[]{3, 1, -1, 2, 5}, new int[]{0, 2, 3}));\n        System.out.println(splitArrayLargestSum(new int[]{-7,-3,-2,-4,-1,-1,-3,-40}, new int[]{0, 3}));\n    }\n\n    public static int splitArrayLargestSum(int[] nums, int[][] splits) {\n        Arrays.sort(nums);\n        int max = 0;\n        for (int i : splits[0]) {\n            int sumLeft = 0;\n            for (int j = 0; j < i; j++) {\n                sumLeft += nums[j];\n            }\n            int sumRight = 0;\n            for (int k = i; k < nums.length; k++) {\n                sumRight += nums[k];\n            }\n            max = Math.max(max, Math.max(sumLeft, sumRight));\n        }\n        return max;\n    }\n}\n```",
  "412": "```\npublic class Main {\n    public static void main(String[] args) {\n        for (int i = 1; i <= 15; i++) {\n            System.out.println(fizzBuzz(i));\n        }\n\n        test(1);\n        test(5);\n        test(15);\n    }\n\n    public static String fizzBuzz(int n) {\n        if (n % 3 == 0 && n % 5 == 0) {\n            return \"FizzBuzz\";\n        } else if (n % 3 == 0) {\n            return \"Fizz\";\n        } else if (n % 5 == 0) {\n            return \"Buzz\";\n        } else {\n            return String.valueOf(n);\n        }\n    }\n\n    public static void test(int n) {\n        System.out.println(\"Test case for number: \" + n);\n        System.out.println(fizzBuzz(n));\n        System.out.println();\n    }\n}\n```",
  "411": "```\npublic class Main {\n    public static void main(String[] args) {\n        String[] words = {\"time\", \"me\", \"bell\"};\n        System.out.println(minAbbreviation(words));\n        \n        words = new String[]{\"pseudo\", \"code\"};\n        System.out.println(minAbbreviation(words));\n        \n        words = new String[]{\"like\", \"god\", \"order\", \"live\", \"san\", \"feed\", \"door\", \"seed\", \"weed\", \"date\", \"meal\", \"ride\", \"file\"};\n        System.out.println(minAbbreviation(words));\n    }\n\n    public static String minAbbreviation(String[] words) {\n        // your code here\n    }\n}",
  "413": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numberOfArithmeticSlices(new int[]{2,4,6})); // Test case 1\n        System.out.println(numberOfArithmeticSlices(new int[]{0,2,4,8,16,32,64,128,256,512})); // Test case 2\n        System.out.println(numberousArithmeticSlices(new int[]{-1,-3,-5,-7,-9})); // Test case 3\n    }\n\n    public static int numberOfArithmeticSlices(int[] nums) {\n        if (nums.length < 3) return 0;\n        int n = nums.length;\n        int res = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 2; i < n; i++) {\n            int diff = nums[i] - nums[i-1];\n            if (!map.containsKey(diff)) map.put(diff, i);\n            else {\n                int idx = map.get(diff) + 1;\n                res += (i - idx);\n            }\n        }\n        return res;\n    }\n}\n```",
  "414": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2, 2, 3, 1};\n        System.out.println(\"Third maximum of \" + Arrays.toString(nums1) + \": \" + thirdMax(nums1));\n\n        int[] nums2 = {1};\n        System.out.println(\"Third maximum of \" + Arrays.toString(nums2) + \": \" + thirdMax(nums2));\n\n        int[] nums3 = {1, 2};\n        System.out.println(\"Third maximum of \" + Arrays.toString(nums3) + \": \" + thirdMax(nums3));\n    }\n\n    public static int thirdMax(int[] nums) {\n        Integer max = null;\n        Integer secondMax = null;\n        for (int num : nums) {\n            if (num > max) {\n                secondMax = max;\n                max = num;\n            } else if (num > secondMax && num != max) {\n                secondMax = num;\n            }\n        }\n\n        return max == null ? max : max.equals(secondMax) ? Math.max(nums[0], nums[1]) : secondMax;\n    }\n}\n```",
  "415": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(addStrings(\"123\", \"456\") + \"\\n\");\n        System.out.println(addStrings(\"99999\", \"9999\") + \"\\n\");\n        System.out.println(addStrings(\"1\", \"111\") + \"\\n\");\n    }\n\n    public static String addStrings(String num1, String num2) {\n        int i = num1.length() - 1, j = num2.length() - 1;\n        StringBuilder sb = new StringBuilder();\n        int carry = 0;\n\n        while (i >= 0 || j >= 0 || carry > 0) {\n            int n1 = i >= 0 ? num1.charAt(i--) - '0' : 0;\n            int n2 = j >= 0 ? num2.charAt(j--) - '0' : 0;\n\n            int sum = n1 + n2 + carry;\n            sb.append(sum % 10);\n            carry = sum / 10;\n        }\n\n        return sb.reverse().toString();\n    }\n}\n```",
  "416": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canPartition(new int[]{1, 2, 5})); // true\n        System.out.println(canPartition(new int[]{1, 4, 5})); // false\n        System.out.println(canPartition(new int[]{1, 2, 3, 9})); // true\n    }\n\n    public static boolean canPartition(int[] nums) {\n        int total = 0;\n        for (int num : nums) {\n            total += num;\n        }\n        if (total % 2 != 0) return false;\n        int target = total / 2;\n        boolean[][] dp = new boolean[nums.length + 1][target + 1];\n        dp[0][0] = true;\n        for (int i = 0; i <= nums.length; i++) {\n            for (int j = 0; j <= target; j++) {\n                if (j < nums[i]) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[nums.length][target];\n    }\n}",
  "418": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canPlaceEqualParts(new String[]{\"w\",\"W\",\"ba\",\"bW\",\"nb\",\"NQ\"}, 2));\n        System.out.println(canPlaceEqualParts(new String[]{\"a\", \"abc\", \"bc\", \"def\", \"ghi\", \"jklm\", \"mllek\", \"ll\"}, 4));\n        System.out.println(!canPlaceEqualParts(new String[]{}, 1000));\n    }\n\n    public static boolean canPlaceEqualParts(String[] sentences, int rows) {\n        if (sentences.length == 0) {\n            return true;\n        }\n        int n = 0;\n        for (String sentence : sentences) {\n            n += sentence.length();\n        }\n        int totalLength = 0;\n        for (int i = 0; i < sentences.length; i++) {\n            totalLength += sentences[i].length() + 1;\n            if ((i + 1) % rows == 0) {\n                if (totalLength > n / rows) {\n                    return false;\n                }\n            }\n        }\n        int remainder = n % rows;\n        for (int i = 0; i < remainder; i++) {\n            totalLength += sentences[i].length() + 1;\n        }\n        return totalLength <= n;\n    }\n}",
  "417": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {\n            [1,2,2,3,5],\n            [3,2,3,4,5],\n            [1,1,1,2,3],\n            [4,3,2,2,3],\n            [5,5,5,5,5]\n        };\n        pacificAtlantic(matrix1);\n\n        int[][] matrix2 = {\n            [1,0,0,0,1],\n            [1,0,1,0,1],\n            [0,0,1,1,1],\n            [0,0,0,1,1],\n            [1,0,0,1,1]\n        };\n        pacificAtlantic(matrix2);\n\n        int[][] matrix3 = {\n            [0, 1, 2, 0, 1],\n            [0, 0, 1, 0, 1],\n            [0, 0, 1, 0, 1],\n            [0, 0, 0, 0, 1],\n            [0, 1, 1, 0, 1]\n        };\n        pacaticAtlantic(matrix3);\n    }\n\n    public static List<List> pacificAtlantic(int[][] matrix) {\n        int m = matrix.length;\n        if (m == 0) return new ArrayList<>();\n\n        int n = matrix[0].length;\n\n        boolean[][] visitedP = new boolean[m][n];\n        boolean[][] visitedA = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            dfs(matrix, visitedP, i, 0);\n            dfs(matrix, visitedA, i, n - 1);\n        }\n\n        for (int j = 0; j < n; j++) {\n            dfs(matrix, visitedP, 0, j);\n            dfs(matrix, visitedA, m - 1, j);\n        }\n\n        List<List> result = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (visitedP[i][j] && visitedA[i][j]) {\n                    result.add(Arrays.asList(i, j));\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private static void dfs(int[][] matrix, boolean[][] visited, int i, int j) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n\n        if (i < 0 || i >= m || j < 0 || j >= n) return;\n\n        if (!visited[i][j]) {\n            visited[i][j] = true;\n\n            int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n            for (int[] direction : directions) {\n                int x = i + direction[0];\n                int y = j + direction[1];\n\n                if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] >= matrix[i][j]) {\n                    dfs(matrix, visited, x, y);\n                }\n            }\n        }\n    }\n}",
  "419": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] board1 = {{'X', 'X', '.', '.'}, {'.', '.', '.', '.'}, {'.', '.', '.', '.'}};\n        System.out.println(\"Expected: 2, Actual: \" + new Solution().numBattleships(board1));\n        \n        int[][] board2 = {{'X', '.'}, {'.' , '.'}};\n        System.out.println(\"Expected: 1, Actual: \" + new Solution().numBattleships(board2));\n\n        int[][] board3 = {{'.', '.'} };\n        System.out.println(\"Expected: 0, Actual: \" + new Solution().numBattleships(board3));\n    }\n}\n\nclass Solution {\n    public int numBattleships(int[][] board) {\n        int count = 0;\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if (board[i][j] == 'X' && \n                    ((i == 0 || board[i-1][j] != 'X') && \n                     (j == 0 || board[i][j-1] != 'X'))) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n```",
  "420": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(strongPasswordChecker(\"a\")); // Expected: [1,0]\n        System.out.println(strongPasswordChecker(\"aa1234\")); // Expected: [3,2]\n        System.out.println(strongPasswordChecker(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ123456\")); // Expected: [4,0]\n    }\n\n    public static int[] strongPasswordChecker(String password) {\n        // Your code here\n    }\n}\n```",
  "421": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {3, 5, 6, 8};\n        System.out.println(\"Maximum XOR of two numbers in array: \" + findMaximumXOR(arr1));\n        \n        int[] arr2 = {10, 16, 12};\n        System.out.println(\"Maximum XOR of two numbers in array: \" + findMaximumXOR(arr2));\n        \n        int[] arr3 = {0, 1, 5, 7};\n        System.out.println(\"Maximum XOR of two numbers in array: \" + findMaximumXOR(arr3));\n    }\n\n    public static int findMaximumXOR(int[] nums) {\n        TrieNode root = new TrieNode();\n        for (int num : nums) {\n            TrieNode cur = root;\n            int temp = 0;\n            for (int i = 31; i >= 0; i--) {\n                int bit = ((num >> i) & 1);\n                if (!cur.children[bit].exists) {\n                    cur.children[bit] = new TrieNode();\n                }\n                cur = cur.children[bit];\n                temp |= (bit << i);\n            }\n            cur.maxXor = Math.max(cur.maxXor, num ^ temp);\n        }\n        int max_xor = 0;\n        for (int i = 31; i >= 0; i--) {\n            int bit = 1;\n            while ((1 << i) & max_xor) {\n                bit = 0;\n                i--;\n                if (i < 0) break;\n            }\n            max_xor |= (bit << i);\n        }\n        return max_xor;\n    }\n\n    static class TrieNode {\n        boolean exists;\n        int maxXor;\n        TrieNode[] children = new TrieNode[2];\n    }\n}",
  "422": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeSquare(new String[]{\"abcd\",\"bnrt\",\"cnql\",\"dnre\",\"enml\",\"fxpg\"})); // true\n        System.out.println(canBeSquare(new String[]{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"})); // false\n        System.out.println(canBeSquare(new String[]{})); // false\n    }\n\n    public static boolean canBeSquare(String[] words) {\n        for (String word : words) {\n            if (!isWordSquare(word)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isWordSquare(String word) {\n        int len = word.length();\n        for (int i = 0; i < len; i++) {\n            String row = word.substring(i).trim().toLowerCase();\n            if (!row.equals(new StringBuilder(word.substring(0, len-i)).reverse().toString())) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "423": "```\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"112358\";\n        System.out.println(reconstructOriginalDigits(s));\n        \n        s = \"0201111177\";\n        System.out.println(reconstructOriginalDigits(s));\n        \n        s = \"1234567890\";\n        System.out.println(reconstructOriginalDigits(s));\n    }\n\n    public static String reconstructOriginalDigits(String s) {\n        // Your code here\n    }\n}",
  "424": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestRepeatingCharacterReplacement(\"ababc\", 2));\n        System.out.println(longestRepeatingCharacterReplacement(\"aabccba\", 2));\n        System.out.println(longestRepeatingCharacterReplacement(\"abcba\", 3));\n    }\n\n    public static int longestRepeatingCharacterReplacement(String s, int k) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        \n        int n = s.length();\n        int maxLen = 0;\n        int left = 0;\n        int count = 0;\n        for (int right = 0; right < n; right++) {\n            if (s.charAt(right) == s.charAt(left)) {\n                count++;\n            } else {\n                count--;\n            }\n            \n            while (count <= 0 && right > left) {\n                if (right - left + 1 > maxLen) {\n                    maxLen = right - left + 1;\n                }\n                if (s.charAt(left) == s.charAt(right)) {\n                    count++;\n                } else {\n                    count--;\n                }\n                left++;\n            }\n        }\n        \n        return maxLen;\n    }\n}\n```",
  "425": "```\npublic class Main {\n    public static void main(String[] args) {\n        WordSquares ws = new WordSquares();\n        \n        String[][] words1 = {{\"a\", \"b\", \"c\"}, {\"x\", \"y\", \"z\"}};\n        System.out.println(\"Test 1: \" + Arrays.deepToString(ws.wordSquares(words1)));\n        \n        String[][] words2 = {{\"example\", \"program\", \"language\"}, {\"description\", \"document\", \"software\"}, {\"let\", \"level\", \"life\"}};\n        System.out.println(\"Test 2: \" + Arrays.deepToString(ws.wordSquares(words2)));\n        \n        String[][] words3 = {{\"hello\", \"world\", \"java\"}, {\"test\", \"case\", \"study\"}, {\"data\", \"type\", \"class\"}};\n        System.out.println(\"Test 3: \" + Arrays.deepToString(ws.wordSquares(words3)));\n    }\n}",
  "426": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root1 = new Node(5);\n        root1.left = new Node(1);\n        root1.right = new Node(7);\n        root1.left.left = new Node(3);\n        root1.left.right = new Node(4);\n\n        Solution solution = new Solution();\n        Node head1 = solution.treeToDoublyList(root1);\n        \n        System.out.println(\"Test Case 1:\");\n        printList(head1);\n        \n        Node root2 = new Node(10);\n        root2.left = new Node(5);\n        root2.right = new Node(15);\n\n        Node head2 = solution.treeToDoublyList(root2);\n        \n        System.out.println(\"\\nTest Case 2:\");\n        printList(head2);\n        \n        Node root3 = new Node(20);\n        root3.left = new Node(10);\n        root3.right = new Node(25);\n        root3.left.left = new Node(5);\n\n        Node head3 = solution.treeToDoublyList(root3);\n        \n        System.out.println(\"\\nTest Case 3:\");\n        printList(head3);\n    }\n\n    public static void printList(Node node) {\n        while (node != null) {\n            System.out.print(node.val + \" \");\n            node = node.next;\n        }\n        System.out.println();\n    }\n}\n```",
  "428": "```\npublic class Main {\n    public static void main(String[] args) {\n        NaryTree tree = new NaryTree(1);\n        tree.children.add(new NaryTreeNode(3));\n        tree.children.add(new NaryTreeNode(5));\n        tree.children.add(new NaryTreeNode(7));\n\n        tree.children.get(0).children.add(new NaryTreeNode(9));\n        tree.children.get(0).children.add(new NaryTreeNode(2));\n\n        String serialized = serialize(tree);\n        System.out.println(serialized);\n\n        NaryTree deserialized = deserialize(serialized);\n        System.out.println(deserialized.val);\n        for (NaryTreeNode child : deserialized.children) {\n            System.out.println(child.val);\n        }\n\n        tree = new NaryTree(1);\n        tree.children.add(new NaryTreeNode(2));\n        tree.children.add(new NaryTreeNode(3));\n\n        String serialized2 = serialize(tree);\n        System.out.println(serialized2);\n\n        NaryTree deserialized2 = deserialize(serialized2);\n        System.out.println(deserialized2.val);\n        for (NaryTreeNode child : deserialized2.children) {\n            System.out.println(child.val);\n        }\n\n        tree = new NaryTree(1);\n        tree.children.add(new NaryTreeNode(4));\n        tree.children.add(new NaryTreeNode(5));\n        tree.children.add(new NaryTreeNode(6));\n\n        String serialized3 = serialize(tree);\n        System.out.println(serialized3);\n\n        NaryTree deserialized3 = deserialize(serialized3);\n        System.out.println(deserialized3.val);\n        for (NaryTreeNode child : deserialized3.children) {\n            System.out.println(child.val);\n        }\n    }\n\n    public static String serialize(NaryTree tree) {\n        // implement serialization\n    }\n\n    public static NaryTree deserialize(String data) {\n        // implement deserialization\n    }\n}\n\nclass NaryTree {\n    int val;\n    List<NaryTreeNode> children = new ArrayList<>();\n\n    public NaryTree(int val) {\n        this.val = val;\n    }\n}\n\nclass NaryTreeNode {\n    int val;\n    List<NaryTreeNode> children = new ArrayList<>();\n\n    public NaryTreeNode(int val) {\n        this.val = val;\n    }\n}",
  "427": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        QuadTree quadTree1 = new QuadTree(4, true);\n        System.out.println(\"Test case 1: \" + quadTree1.Sum(-3 - 4 - 5 - 2, -3, -3));\n\n        QuadTree quadTree2 = new QuadTree(1, false);\n        System.out.println(\"Test case 2: \" + quadTree2.Sum(10, 0, 0));\n\n        QuadTree quadTree3 = new QuadTree(8, true);\n        System.out.println(\"Test case 3: \" + quadTree3.Sum(-1 - 3 - 5 - 4 - 6 - 7, 1, 1));\n    }\n}\n\nclass QuadTree {\n    // Your code here\n}\n```",
  "429": "```\nimport java.util.*;\n\nclass Node {\n    int val;\n    List<Node> children = new ArrayList<>();\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        test(\"1,null,3,2,4,null,5,6\", \"[1,#,2,3,#,4,5,6]\");\n        test(\"1\", \"1\");\n        test(null, null);\n    }\n\n    public static void test(String root, String expected) {\n        Node node = stringToNode(root);\n        List<List<Integer>> result = levelOrder(node);\n        System.out.println(result);\n        System.out.println(expected.equals(stringToList(expected)));\n    }\n\n    public static Node stringToNode(String s) {\n        if (s == null) return null;\n        String[] nodes = s.split(\",\");\n        Node root = new Node();\n        for (int i = 1; i < nodes.length; ) {\n            Node node = new Node();\n            node.val = Integer.parseInt(nodes[i]);\n            i++;\n            while (i < nodes.length && !nodes[i].equals(\"#\")) {\n                node.children.add(stringToNode(nodes[i++]));\n            }\n            if (root.val == 0) root = node;\n            else {\n                if (root.children == null) root.children = new ArrayList<>();\n                root.children.add(node);\n            }\n        }\n        return root;\n    }\n\n    public static List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n            for (int i = 0; i < size; i++) {\n                Node node = queue.poll();\n                level.add(node.val);\n                for (Node child : node.children) {\n                    if (child != null) queue.offer(child);\n                }\n            }\n            result.add(level);\n        }\n        return result;\n    }\n\n    public static List<String> stringToList(String s) {\n        return Arrays.asList(s.split(\",\"));\n    }\n}",
  "430": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node node1 = new Node(1);\n        Node node2 = new Node(2);\n        Node node3 = new Node(3);\n        Node node4 = new Node(4);\n        Node node5 = new Node(5);\n\n        node1.next = node2;\n        node1.prev = null;\n        node2.next = node3;\n        node2.prev = node1;\n        node3.next = node4;\n        node3.prev = node2;\n        node4.next = node5;\n        node4.prev = node3;\n        node5.prev = node4;\n\n        Node head = new Node(1);\n        head.next = new Node(2);\n        head.next.prev = head;\n        head.next.next = node1;\n        node1.prev = head.next;\n        head.next.next.next = null;\n\n        flatten(head);\n\n        System.out.println(\"Case 1: \");\n        printList(node5); // Expected output: 1->2->3->4->5\n\n        System.out.println(\"\\nCase 2: \");\n        Node node6 = new Node(10);\n        node6.prev = new Node(9);\n        node6.prev.prev = new Node(8);\n        node6.prev.prev.prev = head;\n        head.prev = node6.prev.prev;\n\n        flatten(head);\n\n        System.out.println(\"Case 3: \");\n        printList(node5); // Expected output: 1->2->3->4->5\n    }\n\n    public static void flatten(Node head) {\n        Node curr = head;\n        while (curr != null) {\n            if (curr.next == null || !isSameLevel(curr, curr.next)) {\n                curr = curr.next;\n                continue;\n            }\n            mergeLists(curr, curr.next);\n            curr = curr.next;\n        }\n    }\n\n    public static boolean isSameLevel(Node node1, Node node2) {\n        while (node1.prev != null && node1.prev.next == node1) {\n            node1 = node1.prev;\n        }\n        while (node2.prev != null && node2.prev.next == node2) {\n            node2 = node2.prev;\n        }\n        return node1 == node2;\n    }\n\n    public static void mergeLists(Node head1, Node head2) {\n        if (head1.val > head2.val) {\n            Node temp = head1;\n            head1 = head2;\n            head2 = temp;\n        }\n        while (head2.next != null) {\n            head2 = head2.next;\n        }\n        head2.next = head1.next;\n        if (head1.next != null) {\n            head1.next.prev = head2;\n        } else {\n            head1.next = null;\n        }\n    }\n\n    public static void printList(Node node) {\n        while (node != null) {\n            System.out.print(node.val + \" \");\n            node = node.next;\n        }\n        System.out.println();\n    }\n}\n\nclass Node {\n    int val;\n    Node prev;\n    Node next;\n\n    public Node(int val) {\n        this.val = val;\n    }\n}\n```",
  "431": "```\nclass Codec {\n    // Your code here\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Codec codec = new Codec();\n        \n        TreeNode root1 = new TreeNode(1);\n        root1.children.add(new TreeNode(2));\n        root1.children.add(new TreeNode(3));\n        root1.children.add(new TreeNode(4));\n        root1.children.add(new TreeNode(5));\n\n        TreeNode root2 = new TreeNode(1);\n        root2.children.add(new TreeNode(2));\n        root2.children.add(new TreeNode(3));\n\n        TreeNode root3 = new TreeNode(1);\n\n        String encoded1 = codec.encode(root1);\n        String decoded1 = codec.decode(encoded1);\n        \n        String encoded2 = codec.encode(root2);\n        String decoded2 = codec.decode(encoded2);\n        \n        String encoded3 = codec.encode(root3);\n        String decoded3 = codec.decode(encoded3);\n        \n        System.out.println(\"Test Case 1: \" + (isIdentical(root1, decoded1) ? \"Passed\" : \"Failed\"));\n        System.out.println(\"Test Case 2: \" + (isIdentical(root2, decoded2) ? \"Passed\" : \"Failed\"));\n        System.out.println(\"Test Case 3: \" + (isIdentical(root3, decoded3) ? \"Passed\" : \"Failed\"));\n    }\n\n    public static boolean isIdentical(TreeNode tree1, TreeNode tree2) {\n        if (tree1 == null && tree2 == null) return true;\n        if (tree1 == null || tree2 == null) return false;\n\n        if (tree1.val != tree2.val) return false;\n\n        for (int i = 0; i < tree1.children.size(); i++) {\n            TreeNode child1 = tree1.children.get(i);\n            if (!isIdentical(child1, tree2.children.get(i))) return false;\n        }\n\n        for (int i = tree2.children.size(); i > tree1.children.size(); i--) {\n            if (!tree2.children.isEmpty()) return false;\n        }\n\n        return true;\n    }\n}\n\nclass TreeNode {\n    int val;\n    List<TreeNode> children;\n\n    public TreeNode(int val) {\n        this.val = val;\n        this.children = new ArrayList<>();\n    }\n}\n```",
  "432": "```\npublic class Main {\n    public static void main(String[] args) {\n        AllOne obj = new AllOne();\n        obj.touch(\"hello\");\n        obj.touch(\"world\");\n        System.out.println(obj.getMostRecentKey());\n        \n        // Test Case 2\n        for (int i = 0; i < 10; i++) {\n            obj.touch(String.valueOf(i));\n        }\n        for (int i = 8; i >= 3; i--) {\n            obj.touch(String.valueOf(i));\n        }\n        System.out.println(obj.getMostRecentKey());\n        \n        // Test Case 3\n        for (int i = 0; i < 5; i++) {\n            obj.touch(String.valueOf(i));\n        }\n        for (int i = 4; i >= 0; i--) {\n            obj.touch(String.valueOf(i));\n        }\n        System.out.println(obj.getMostRecentKey());\n    }\n}\n```",
  "433": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumGeneticMutation(\"AACCGGTT\", \"AACCTTT\", new int[][]{{0, 1}, {1, 2}, {8, 7}}));\n        System.out.println(minimumGeneticMutation(\"AAA\", \"AAH\"));\n        System.out.println(minimumGeneticMutation(\"AAAAACCCCC\", \"CCCCCCYYYY\"));\n    }\n\n    public static int minimumGeneticMutation(String start, String end, int[][] mutations) {\n        // Your code here\n    }\n}\n```",
  "434": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countSegments(\"Hello world\")); // Output: 2\n        System.out.println(countSegments(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\")); // Output: 31\n        System.out.println(countSegments(\"aa bb cc dd ee\")); // Output: 6\n    }\n\n    public static int countSegments(String s) {\n        if (s.trim().isEmpty()) return 0;\n        return (int)java.lang.Math.ceil(s.indexOf(' ')/1.0);\n    }\n}\n```",
  "435": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals1 = {{0,2},{1,3},{4,5}};\n        System.out.println(\"Number of non-overlapping intervals for the first set: \" + eraseOverlapIntervals(intervals1));\n        \n        int[][] intervals2 = {{1,3},{2,4},{3,5},{4,6}};\n        System.out.println(\"Number of non-overlapping intervals for the second set: \" + eraseOverlapIntervals(intervals2));\n\n        int[][] intervals3 = {{0,10},{5,12},{13,15},{18,19}};\n        System.out.println(\"Number of non-overlapping intervals for the third set: \" + eraseOverlapIntervals(intervals3));\n    }\n\n    public static int eraseOverlapIntervals(int[][] intervals) {\n        if (intervals == null || intervals.length == 0) {\n            return 0;\n        }\n        \n        Arrays.sort(intervals, (a, b) -> a[1] - b[1]);\n        \n        int[] dp = new int[intervals.length];\n        dp[0] = 1;\n        \n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[i][0] >= intervals[i-1][1]) {\n                dp[i] = dp[i-1] + 1;\n            } else {\n                dp[i] = Math.max(dp[i-1], dp[i-1]);\n            }\n        }\n        \n        return intervals.length - Arrays.stream(dp).max().getAsInt();\n    }\n}\n```",
  "436": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals = {{1,3},{2,5},{7,12},{5,8}};\n        System.out.println(\"Test Case 1: \" + findRightInterval(intervals));\n        \n        int[][] intervals2 = {{1,4},{2,3}};\n        System.out.println(\"Test Case 2: \" + findRightInterval(intervals2));\n        \n        int[][] intervals3 = {{3,4},{1,2}};\n        System.out.println(\"Test Case 3: \" + findRightInterval(intervals3));\n    }\n\n    public static int[] findRightInterval(int[][] intervals) {\n        List<int[]> list = new ArrayList<>();\n        for (int i = 0; i < intervals.length; i++) {\n            list.add(new int[]{i, intervals[i][1]});\n        }\n        \n        Collections.sort(list, (a, b) -> a[1] - b[1]);\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < list.size(); i++) {\n            map.put(list.get(i)[1], list.get(i)[0]);\n        }\n        \n        List<int[]> result = new ArrayList<>();\n        for (int[] interval : intervals) {\n            int rightIntervalIndex = -1;\n            for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n                if (entry.getKey() > interval[1]) {\n                    rightIntervalIndex = entry.getValue();\n                    break;\n                }\n            }\n            \n            result.add(new int[]{interval[0], rightIntervalIndex});\n        }\n        \n        return result.stream().mapToInt((x) -> x[1]).toArray();\n    }\n}\n```",
  "437": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode tree1 = new TreeNode(10);\n        tree1.left = new TreeNode(5);\n        tree1.right = new TreeNode(-3);\n        tree1.left.left = new TreeNode(3);\n        tree1.left.right = new TreeNode(2);\n        tree1.right.right = 7;\n        tree1.left.left.left = 4;\n        tree1.left.left.right = 6;\n\n        System.out.println(\"Test case 1: \" + pathSum(tree1, 8) + \"\\n\");\n        System.out.println(\"Test case 2: \" + pathSum(tree1, -2) + \"\\n\");\n        System.out.println(\"Test case 3: \" + pathSum(null, 0) + \"\\n\");\n    }\n\n    public static int pathSum(TreeNode root, int targetSum) {\n        // Your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) { val = x; }\n}\n```",
  "438": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1:\");\n        List<String> anagrams = findAnagrams(\"cba\", \"abc\");\n        for (String s : anagrams) {\n            System.out.println(s);\n        }\n        \n        System.out.println(\"\\nTest case 2:\");\n        anagrams = findAnagrams(\"rat\", \"tar\", \"art\", \"rart\", \"raa\");\n        for (String s : anagrams) {\n            System.out.println(s);\n        }\n        \n        System.out.println(\"\\nTest case 3:\");\n        anagrams = findAnagrams(\"\", \"\", \"listen\", \"silent\", \"enlist\", \"tinsel\");\n        for (String s : anagrams) {\n            System.out.println(s);\n        }\n    }\n\n    public static List<String> findAnagrams(String... strs) {\n        Map<String, List<String>> map = new HashMap<>();\n        for (String str : strs) {\n            char[] ch = str.toCharArray();\n            Arrays.sort(ch);\n            String sortedStr = new String(ch);\n            if (!map.containsKey(sortedStr)) {\n                map.put(sortedStr, new ArrayList<>());\n            }\n            map.get(sortedStr).add(str);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (List<String> list : map.values()) {\n            if (list.size() > 1) {\n                result.addAll(list);\n            } else {\n                result.add(list.get(0));\n            }\n        }\n        return result;\n    }\n}",
  "439": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(parseTernary(\"IsSmall? x : y\")); // true\n        System.out.println(parseTernary(\"AreBigger? 4 > 5 ? y : n\")); // false\n        System.out.println(parseTernary(\"x ? y : z\")); // null\n    }\n\n    public static String parseTernary(String expression) {\n        return new TernaryParser().parse(expression);\n    }\n}\n\nclass TernaryParser {\n\n    public String parse(String s) {\n        int pos = s.indexOf('?');\n        if (pos == -1) {\n            return s;\n        } else {\n            int leftPos = s.substring(0, pos).lastIndexOf('?');\n            if (leftPos != -1) {\n                return \"?\" + new TernaryParser().parse(s.substring(0, leftPos)) + \" ? \" +\n                        new TernaryParser().parse(s.substring(leftPos, pos)) + \" : \" +\n                        new TernaryParser().parse(s.substring(pos + 1));\n            } else {\n                int rightPos = s.indexOf(':');\n                return \"?\" + new TernaryParser().parse(s.substring(0, pos)) + \" ? \" +\n                        new TernaryParser().parse(s.substring(pos + 1, rightPos)) + \" : \" +\n                        new TernaryParser().parse(s.substring(rightPos + 1));\n            }\n        }\n    }\n}\n```",
  "441": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numberOfArrangements(2)); // Test case 1: n = 2\n        System.out.println(numberOfArrangements(4)); // Test case 2: n = 4\n        System.out.println(numberOfArrangements(10)); // Test case 3: n = 10\n    }\n\n    public static int numberOfArrangements(int n) {\n        int low = 1, high = n;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            long total = mid * (mid + 1) / 2;\n            if (total == n) return mid;\n            if (total < n) low = mid + 1;\n            else high = mid - 1;\n        }\n        return high;\n    }\n}",
  "440": "```\npublic class Solution {\n    public String kthSmallest(String[] words, int k) {\n        TrieNode root = new TrieNode();\n        for (String word : words) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                if (!node.children.containsKey(c)) {\n                    node.children.put(c, new TrieNode());\n                }\n                node = node.children.get(c);\n            }\n            node.isEndOfWord = true;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        int index = 0;\n        dfs(root, k, sb, index);\n\n        return sb.toString();\n    }\n\n    private void dfs(TrieNode root, int k, StringBuilder sb, int index) {\n        if (root.isEndOfWord && ++index == k) {\n            for (int i = 0; i < sb.length(); i++) {\n                char c = sb.charAt(i);\n                while (!root.children.containsKey(c)) {\n                    c++;\n                }\n                root = root.children.get(c);\n            }\n            return;\n        }\n\n        for (Map.Entry<Character, TrieNode> entry : root.children.entrySet()) {\n            if (entry.getValue().isEndOfWord) {\n                sb.append(entry.getKey());\n                dfs(entry.getValue(), k, sb, index);\n                sb.deleteCharAt(sb.length() - 1);\n            } else {\n                sb.append(entry.getKey());\n                dfs(entry.getValue(), k, sb, index);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words = {\"t\", \"o\", \"th\"};\n        System.out.println(solution.kthSmallest(words, 3)); // expected output: \"the\"\n\n        words = new String[]{\"music\", \"list\", \"apple\", \"hello\", \"world\", \"abc\"};\n        System.out.println(solution.kthSmallest(words, 1)); // expected output: \"abc\"\n        System.out.println(solution.kthSmallest(words, 3)); // expected output: \"app\"\n        System.out.println(solution.kthSmallest(words, 5)); // expected output: \"hello\"\n\n        words = new String[]{\"a\", \"b\", \"c\"};\n        System.out.println(solution.kthSmallest(words, 2)); // expected output: \"bc\"\n    }\n}\n\nclass TrieNode {\n    Map<Character, TrieNode> children = new HashMap<>();\n    boolean isEndOfWord;\n}\n```",
  "442": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {4, 3, 2, 7, 8, 3, 1};\n        System.out.println(\"Duplicates in array: \" + findDuplicates(nums1));\n\n        int[] nums2 = {1, 2, 3, 4};\n        System.out.println(\"Duplicates in array: \" + findDuplicates(nums2));\n\n        int[] nums3 = {1, 3, 2, 5, 3, 4};\n        System.out.println(\"Duplicates in array: \" + findDuplicates(nums3));\n    }\n\n    public static List<Integer> findDuplicates(int[] nums) {\n        Set<Integer> seen = new HashSet<>();\n        Set<Integer> duplicates = new HashSet<>();\n\n        for (int num : nums) {\n            if (!seen.add(num)) {\n                duplicates.add(num);\n            }\n        }\n\n        return new ArrayList<>(duplicates);\n    }\n}",
  "443": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(stringCompression(\"aabbcccc\")); // expected \"a2b1c4\"\n        System.out.println(stringCompression(\"abc\")); // expected \"abc\"\n        System.out.println(stringCompression(\"aaaabbbccc\")); // expected \"a4b3c3\"\n    }\n\n    public static String stringCompression(String s) {\n        if (s == null || s.length() == 0) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        int count = 1;\n        for (int i = 1; i <= s.length(); i++) {\n            if (i == s.length() || s.charAt(i - 1) != s.charAt(i)) {\n                sb.append(s.charAt(i - 1));\n                if (count > 1) {\n                    sb.append(count);\n                }\n                count = 1;\n            } else {\n                count++;\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "444": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sequenceReconstruction(new String[]{\"a\", \"b\", \"c\"}, new int[][]{{}, {\"b\"}, {\"bc\"}}));\n        System.out.println(sequenceReconstruction(new String[]{\"abc\"}, new int[][]{{},{1,2}}));\n        System.out.println(sequenceReconstruction(new String[]{\"shoenix\",\"apple\",\"banana\",\"orange\"}, new int[][]{{},{0,1},{1,2},{3},{2,3}}));\n    }\n\n    public static boolean sequenceReconstruction(String[] seqSplices, int[][] clips) {\n        if (seqSplices.length != clips.length + 1) return false;\n        \n        Map<String, Set<String>> graph = new HashMap<>();\n        for (int i = 0; i < seqSplices.length; i++) {\n            graph.put(seqSplices[i], new HashSet<>());\n        }\n        \n        for (int[] clip : clips) {\n            graph.get(seqSplices[clip[0]]).add(seqSplices[clip[1]]);\n        }\n        \n        List<String> order = new ArrayList<>();\n        Map<String, Integer> inDeg = new HashMap<>();\n        for (String node : graph.keySet()) {\n            inDeg.put(node, 0);\n        }\n        \n        for (String node : graph.keySet()) {\n            for (String neighbor : graph.get(node)) {\n                inDeg.put(neighbor, inDeg.getOrDefault(neighbor, 0) + 1);\n            }\n        }\n        \n        Queue<String> queue = new LinkedList<>();\n        for (String node : graph.keySet()) {\n            if (inDeg.get(node) == 0) queue.offer(node);\n        }\n        \n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            order.add(node);\n            \n            for (String neighbor : graph.get(node)) {\n                inDeg.put(neighbor, inDeg.getOrDefault(neighbor, 0) - 1);\n                if (inDeg.get(neighbor) == 0) queue.offer(neighbor);\n            }\n        }\n        \n        return order.size() == seqSplices.length;\n    }\n}\n```",
  "445": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode l1 = new ListNode(2);\n        l1.next = new ListNode(4);\n        l1.next.next = new ListNode(3);\n\n        ListNode l2 = new ListNode(5);\n        l2.next = new ListNode(6);\n        l2.next.next = new ListNode(4);\n\n        ListNode result = addTwoNumbers(l1, l2);\n\n        printList(result);\n\n        l1 = null;\n        l2 = null;\n\n        l1 = new ListNode(9);\n        l1.next = new ListNode(9);\n        l1.next.next = new ListNode(9);\n\n        l2 = new ListNode(1);\n\n        result = addTwoNumbers(l1, l2);\n\n        printList(result);\n\n        l1 = null;\n        l2 = null;\n\n        l1 = new ListNode(0);\n\n        l2 = new ListNode(7);\n\n        result = addTwoNumbers(l1, l2);\n\n        printList(result);\n    }\n\n    public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummyHead = new ListNode(0);\n        ListNode p = l1;\n        ListNode q = l2;\n        ListNode curr = dummyHead;\n        int carry = 0;\n\n        while (p != null || q != null) {\n            int x = (p != null) ? p.val : 0;\n            int y = (q != null) ? q.val : 0;\n\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr.next = new ListNode(sum % 10);\n            curr = curr.next;\n\n            if (p != null) {\n                p = p.next;\n            }\n            if (q != null) {\n                q = q.next;\n            }\n        }\n\n        if (carry > 0) {\n            curr.next = new ListNode(carry);\n        }\n\n        return dummyHead.next;\n    }\n\n    public static void printList(ListNode node) {\n        while (node != null) {\n            System.out.print(node.val + \" \");\n            node = node.next;\n        }\n        System.out.println();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n```",
  "446": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{2,4},{3,5}};\n        System.out.println(\"Expected: 3, Got: \" + numberOfArithmeticSlices(arr1));\n        \n        int[][] arr2 = {{0, -1,-1},{-1,-2,-2},{-3,-3,-4]];\n        System.out.println(\"Expected: 6, Got: \" + numberOfArithmeticSlices(arr2));\n\n        int[][] arr3 = {{1}};\n        System.out.println(\"Expected: 0, Got: \" + numberOfArthicmeticSlices(arr3));\n    }\n\n    public static int numberOfArithmeticSlices(int[][] arr) {\n        if (arr.length == 0) return 0;\n        int n = arr[0].length;\n        int[] diffCount = new int[n];\n        int total = 0;\n        \n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < n - 1; j++) {\n                if (arr[j][i] - arr[j][i-1] != arr[j+1][i] - arr[j+1][i-1]) {\n                    diffCount[j]++;\n                    total += diffCount[j];\n                }\n            }\n        }\n        \n        return total;\n    }\n}",
  "447": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfBoomerangs(new int[][]{{0,0},{1,0},{2,0}})); // Test case 1: Expected output is 2\n        System.out.println(numberOfBoomerangs(new int[][]{{1,1},{2,2},{3,3}})); // Test case 2: Expected output is 8\n        System.out.println(numberOfBoomerangs(new int[][]{{0,0},{0,1},{1,1}})); // Test case 3: Expected output is 4\n    }\n\n    public static int numberOfBoomerangs(int[][] grid) {\n        int n = grid.length;\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            Map<Integer, Integer> xCount = new HashMap<>();\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) continue;\n                int dist = grid[j][i];\n                xCount.put(dist, xCount.getOrDefault(dist, 0) + 1);\n            }\n            for (int d : xCount.keySet()) {\n                long a = Math.pow(xCount.get(d), 2);\n                count += (int) a;\n            }\n        }\n        return count;\n    }\n}",
  "448": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {4, 3, 2, 7, 8, 3, 1, 5};\n        System.out.println(\"Expected: [1, 2, 6]\");\n        System.out.println(\"Actual: \" + findDisappearedNumbers(nums1));\n        \n        int[] nums2 = {1, 1};\n        System.out.println(\"Expected: [2]\";\n        System.out.println(\"Actual: \" + findDisappearedNumbers(nums2));\n        \n        int[] nums3 = {[0], 1, 2};\n        System.out.println(\"Expected: [3]\"\n        System.out.println(\"Actual: \" + findDisappearedNumbers(nums3));\n    }\n    \n    public static List<Integer> findDisappearedNumbers(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            set.add(num);\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= nums.length + 1; i++) {\n            if (!set.contains(i)) {\n                result.add(i);\n            }\n        }\n        \n        return result;\n    }\n}\n```",
  "449": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Node root = new Node(2);\n        root.left = new Node(1);\n        root.right = new Node(3);\n\n        Codec codec = new Codec();\n        String serialized = codec.serialize(root);\n        System.out.println(serialized); // Output: \"2,1,#,#,3,#,#\"\n\n        Node deserializedRoot = codec.deserialize(serialized);\n        System.out.println(deserializedRoot.val); // Output: 2\n        System.out.println(deserializedRoot.left.val); // Output: 1\n        System.out.println(deserializedRoot.right.val); // Output: 3\n\n        root = new Node(5);\n        root.left = new Node(3);\n        root.right = new Node(6);\n\n        serialized = codec.serialize(root);\n        System.out.println(serialized); // Output: \"5,3,#,#,6,#,#\"\n\n        deserializedRoot = codec.deserialize(serialized);\n        System.out.println(deserializedRoot.val); // Output: 5\n        System.out.println(deserializedRoot.left.val); // Output: 3\n        System.out.println(deserializedRoot.right.val); // Output: 6\n\n        root = new Node(1);\n        serialized = codec.serialize(root);\n        System.out.println(serialized); // Output: \"1,#,#\"\n    }\n}\n\nclass Codec {\n    public String serialize(Node t) {\n        if (t == null) return \"null,\";\n        return t.val + \",\" + serialize(t.left) + serialize(t.right);\n    }\n\n    public Node deserialize(String data) {\n        return deserializeHelper(data.split(\",\"));\n    }\n\n    private Node deserializeHelper(String[] nodes) {\n        Node node = null;\n        if (nodes[0].equals(\"null\")) {\n            return null;\n        }\n        node = new Node(Integer.parseInt(nodes[0]));\n        int i = 1;\n        while (!nodes[i].equals(\"#\")) {\n            node.left = deserializeHelper(Arrays.copyOfRange(nodes, i + 1, nodes.length));\n            i += nodes[i].length() + 1;\n        }\n        return node;\n    }\n}\n\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n\n    public Node(int v) {\n        val = v;\n    }\n}\n```",
  "450": "```\npublic class Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) return null;\n\n        if (key < root.val) {\n            root.left = deleteNode(root.left, key);\n            return root;\n        }\n\n        if (key > root.val) {\n            root.right = deleteNode(root.right, key);\n            return root;\n        }\n\n        // This node is the one to be deleted\n        if (root.left == null) {\n            return root.right;\n        }\n        if (root.right == null) {\n            return root.left;\n        }\n\n        // Node has two children; replace with inorder successor\n        TreeNode temp = root.right;\n        while (temp != null && temp.left != null) {\n            temp = temp.left;\n        }\n        root.val = temp.val;\n        root.right = deleteNode(root.right, temp.val);\n        return root;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(3);\n        root1.right = new TreeNode(6);\n        root1.left.left = new TreeNode(2);\n        root1.left.right = new TreeNode(4);\n        root1.right.right = new TreeNode(7);\n\n        System.out.println(\"Test case 1: Delete node with no children\");\n        TreeNode result1 = solution.deleteNode(root1, 3);\n        // Print the tree here\n\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(6);\n        root2.left.left = new TreeNode(2);\n        root2.left.right = new TreeNode(4);\n        root2.right.right = new TreeNode(7);\n\n        System.out.println(\"Test case 2: Delete node with one child\");\n        TreeNode result2 = solution.deleteNode(root2, 4);\n        // Print the tree here\n\n        TreeNode root3 = new TreeNode(5);\n        root3.left = new TreeNode(3);\n        root3.right = new TreeNode(6);\n\n        System.out.println(\"Test case 3: Delete node with two children\");\n        TreeNode result3 = solution.deleteNode(root3, 5);\n        // Print the tree here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "451": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sortedFrequency(\"tree\"));\n        System.out.println(sortedFrequency(\"cccaaa\"));\n        System.out.println(sortedFrequency(\"Aa\")); \n    }\n\n    public static String sortedFrequency(String s) {\n        if (s == null || s.length() == 0) return \"\";\n        \n        Map<Character, Integer> frequency = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            frequency.put(c, frequency.getOrDefault(c, 0) + 1);\n        }\n        \n        List<Map.Entry<Character, Integer>> list = new ArrayList<>(frequency.entrySet());\n        list.sort((a, b) -> a.getValue().compareTo(b.getValue()));\n        \n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<Character, Integer> entry : list) {\n            for (int i = 0; i < entry.getValue(); i++) {\n                sb.append(entry.getKey());\n            }\n        }\n        return sb.toString();\n    }\n}",
  "452": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] points1 = {{9,12},{1,10},{2,5},{8,7}};\n        System.out.println(\"Minimum number of arrows for first set of balloons: \" + new Solution().findMinArrowShots(points1));\n        \n        int[][] points2 = {{10,16},{2,8},{1,6},{7,9}};\n        System.out.println(\"Minimum number of arrows for second set of balloons: \" + new Solution().findMinArrowShots(points2));\n\n        int[][] points3 = {{0,2},{4,3},{4,7},{5,6},{8,5},{10,4},{11,12}};\n        System.out.println(\"Minimum number of arrows for third set of balloons: \" + new Solution().findMinArrowShots(points3));\n    }\n}\n\nclass Solution {\n    public int findMinArrowShots(int[][] points) {\n        if (points.length == 0) return 0;\n        \n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\n        \n        int minArrows = 1;\n        int endOfLastArrow = points[0][1];\n        \n        for (int i = 1; i < points.length; i++) {\n            if (points[i][0] > endOfLastArrow) {\n                minArrows++;\n                endOfLastArrow = points[i][1];\n            }\n        }\n        \n        return minArrows;\n    }\n}",
  "453": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minMoves(new int[]{1, 2, 3}) + \" Expected: 3\");\n        System.out.println(minMoves(new int[]{5, 10, 25, 2}) + \" Expected: 8\");\n        System.out.println(minMoves(new int[]{7, 9, 6, 4, 3, 2, 0, 1}) + \" Expected: 7\");\n    }\n\n    public static int minMoves(int[] nums) {\n        int n = nums.length;\n        int median = findMedian(nums);\n        int moves = 0;\n\n        for (int num : nums) {\n            moves += Math.abs(num - median);\n        }\n        return moves;\n    }\n\n    public static int findMedian(int[] nums) {\n        Arrays.sort(nums);\n        if (nums.length % 2 == 1) {\n            return nums[nums.length / 2];\n        } else {\n            return (nums[nums.length / 2 - 1] + nums[nums.length / 2]) / 2;\n        }\n    }\n}\n```",
  "455": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(assignCookies(new int[]{1,2}, new int[]{1,2})); // Expected: 2\n        System.out.println(assignCookies(new int[]{1,2}, new int[]{1,3})); // Expected: 1\n        System.out.println(assign.Cookies(new int[]{1,2}, new int[]{1,4})); // Expected: 0\n    }\n\n    public static int assignCookies(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n\n        int i = g.length - 1;\n        int j = s.length - 1;\n\n        int count = 0;\n        while (i >= 0 && j >= 0) {\n            if (s[j] >= g[i]) {\n                count++;\n                i--;\n                j--;\n            } else {\n                j--;\n            }\n        }\n\n        return count;\n    }\n}\n```",
  "454": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums1 = {{-2,-1,-1,1,1},{-5,-4,-2,0,0}};\n        int target1 = -1;\n        System.out.println(\"Test case 1: \" + fourSumCount(nums1, target1));\n        \n        int[][] nums2 = {{1,1,1,-1,-1}};\n        int target2 = 0;\n        System.out.println(\"Test case 2: \" + fourSumCount(nums2, target2));\n\n        int[][] nums3 = {{-5,5,-5,5},{-5,-5,-5,-5},{5,5,5,5}};\n        int target3 = 15;\n        System.out.println(\"Test case 3: \" + fourSumCount(nums3, target3));\n    }\n\n    public static int fourSumCount(int[][] A, int C) {\n        Map<int[], Integer> map = new HashMap<>();\n        for (int i = 0; i < A.length; i++) {\n            for (int j = i + 1; j < A[i].length; j++) {\n                int[] pair = {A[i][i], A[i][j]};\n                if (!map.containsKey(pair)) map.put(pair, 0);\n                map.put(pair, map.get(pair) + 1);\n            }\n        }\n\n        int count = 0;\n        for (Map.Entry<int[], Integer> entry : map.entrySet()) {\n            for (int i = 0; i < A.length; i++) {\n                for (int j = i + 1; j < A[i].length; j++) {\n                    int[] triple = {A[i][i], A[i][j]};\n                    if (Arrays.equals(entry.getKey(), triple)) {\n                        count += entry.getValue() * calculateCombinations(A.length, 2) - map.getOrDefault(triple, 0);\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    public static int calculateCombinations(int n, int k) {\n        if (k > n - k) k = n - k;\n        int res = 1;\n        for (int i = 1; i <= k; ++i)\n            res = res * (n - i + 1) / i;\n        return res;\n    }\n}\n```",
  "456": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(find132pattern(new int[]{1, 2, 3, 4}) ? \"True\" : \"False\"); // Test case 1: True\n        System.out.println(find132pattern(new int[]{3, 1, 4, 0, -2, 1}) ? \"True\" : \"False\"); // Test case 2: True\n        System.out.println(find132pattern(new int[]{1, 3, 5, 4, 6}) ? \"True\" : \"False\"); // Test case 3: False\n    }\n\n    public static boolean find132pattern(int[] nums) {\n        int n = nums.length;\n        if (n < 3) return false;\n\n        int b = Integer.MIN_VALUE; // boundary for middle part\n\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[i] > nums[j]) {\n                    b = Math.max(b, nums[j]);\n                    break;\n                }\n            }\n        }\n\n        for (int k = 0; k < n - 2; k++) {\n            if (nums[k] < b) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}",
  "457": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] circularArrays = new int[][]{\n            {{2, 1, 1}, 4}, // Expected: 2\n            {{-3, 2, -3, 2, 0,-3, 2}, 3}, // Expected: 2\n            {{-2,-3,1,-5,-2,-4}, 23} // Expected: 1\n        };\n\n        for (int[] circularArray : circularArrays) {\n            int result = findCircularArrayLoop(circularArray[0], circularArray[1]);\n            System.out.println(\"The length of the loop in array \" + Arrays.toString(circularArray[0]) + \" is \" + result);\n        }\n    }\n\n    public static int findCircularArrayLoop(int[] nums) {\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i] == 0 || nums[nums[i]] != nums[i+1]) continue;\n            int start = i;\n            int slow = i, fast = i;\n            while (true) {\n                slow = nums[slow];\n                fast = nums[fast]; fast = nums[fast];\n                if (slow == fast) break;\n                if (nums[start] != slow) break;\n            }\n            return nums.length - start - (slow == start ? 1 : 0);\n        }\n        return 0;\n    }\n}\n```",
  "458": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minCost(1, new int[]{1, 2, 5})); // Expected: 1\n        System.out.println(minCost(2, new int[]{1, 3, 5})); // Expected: 4\n        System.out.println(minCost(3, new int[]{10, 12, 11})); // Expected: 14\n    }\n\n    public static int minCost(int p, int[] costs) {\n        if (p == 1) return Math.min(costs[0], costs[1]);\n        int[][] dp = new int[p + 1][2];\n        dp[1][0] = costs[0]; \n        dp[1][1] = costs[1]; \n\n        for (int i = 2; i <= p; i++) {\n            dp[i][0] = Math.min(dp[i-1][0], dp[i-1][1]) + costs[0];\n            dp[i][1] = Math.min(Math.min(dp[i-1][0], dp[i-1][1]), dp[i-2][0] > dp[i-2][1] ? dp[i-2][0] : dp[i-2][1]) + costs[1];\n        }\n\n        return Math.min(dp[p][0], dp[p][1]);\n    }\n}\n```",
  "459": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(repeatedSubstringPattern(\"abab\")); // true\n        System.out.println(repeatedSubstringPattern(\"aba\")); // false\n        System.out.println(repeatedSubstringPattern(\"abc\")); // false\n    }\n\n    public static boolean repeatedSubstringPattern(String s) {\n        if (s.length() == 0) return true;\n        for (int len = s.length() / 2; len > 0; len--) {\n            String sub = s.substring(0, len);\n            if (s.indexOf(sub + sub) != -1 && s.length() % (len * 2) == 0)\n                return true;\n        }\n        return false;\n    }\n}\n```",
  "461": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(hammingDistance(1, 4)); // Test case 1\n        System.out.println(hammingDistance(3, 5)); // Test case 2\n        System.out.println(hammingDistance(0, 2)); // Test case 3\n    }\n\n    public static int hammingDistance(int x, int y) {\n        return Integer.bitCount(x ^ y);\n    }\n}\n```",
  "460": "```\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class LFUCache {\n    private Map<Integer, Integer> keyValMap;\n    private Map<Integer, Integer> frequencyMap;\n    private LinkedHashMap<Integer, Integer> cache;\n    private int minFreq;\n\n    public LFUCache(int capacity) {\n        this.keyValMap = new HashMap<>();\n        this.frequencyMap = new HashMap<>();\n        this.cache = new LinkedHashMap<>(capacity, 0.75f, true);\n        this.minFreq = 0;\n    }\n\n    public int get(int key) {\n        if (!keyValMap.containsKey(key)) {\n            return -1;\n        }\n        int oldFreq = frequencyMap.get(key);\n        frequencyMap.put(key, oldFreq + 1);\n        cache.remove(key);\n        cache.put(key, keyValMap.get(key));\n        minFreq = Math.min(minFreq, oldFreq + 1);\n        return keyValMap.get(key);\n    }\n\n    public void put(int key, int value) {\n        if (cache.size() >= cache.capacity()) {\n            int lfuKey = getLFUKey();\n            cache.remove(lfuKey);\n            frequencyMap.remove(lfuKey);\n            keyValMap.remove(lfuKey);\n        }\n        keyValMap.put(key, value);\n        frequencyMap.put(key, 1);\n        cache.put(key, value);\n        minFreq = 1;\n    }\n\n    private int getLFUKey() {\n        return (int) cache.keySet().iterator().next();\n    }\n\n    public static void main(String[] args) {\n        LFUCache cache = new LFUCache(2);\n\n        System.out.println(cache.get(1)); // returns 1\n        cache.put(2, 2);\n        System.out.println(cache.get(1)); // returns -1 (not found)\n        System.out.println(cache.get(3)); // returns -1 (not found)\n        cache.put(4, 4); \n        System.out.println(cache.get(3)); // returns 1\n        cache.put(3, 3); // evicts key 2\n        System.out.println(cache.get(4)); // returns 4\n    }\n}",
  "462": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minMoves2(new int[]{1, 2, 3}) + \" expected: 2\");\n        System.out.println(minMoves2(new int[]{5, 10, 25, 30}) + \" expected: 15\");\n        System.out.println(minMoves2(new int[]{0, 2, 4, 8, 6}) + \" expected: 14\");\n    }\n\n    public static int minMoves2(int[] nums) {\n        Arrays.sort(nums);\n        int mid = nums[nums.length / 2];\n        int moves = 0;\n        for (int num : nums) {\n            moves += Math.abs(num - mid);\n        }\n        return moves;\n    }\n}\n```",
  "463": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(islandPerimeter(new int[][]{{0,1},{1,0}})); // Expected output: 4\n        System.out.println(islandPerimeter(new int[][]{{0,1,0},{0,1,0},{0,1,0}})); // Expected output: 10\n        System.out.println(islandPerimeter(new int[][]{{1,1,1},{1,0,1},{1,1,1}})); // Expected output: 14\n    }\n\n    public static int islandPerimeter(int[][] grid) {\n        int perimeter = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1) {\n                    // Check top\n                    if (i == 0 || grid[i - 1][j] == 0) perimeter += 1;\n                    // Check bottom\n                    if (i == grid.length - 1 || grid[i + 1][j] == 0) perimeter += 1;\n                    // Check left\n                    if (j == 0 || grid[i][j - 1] == 0) perimeter += 1;\n                    // Check right\n                    if (j == grid[0].length - 1 || grid[i][j + 1] == 0) perimeter += 1;\n                }\n            }\n        }\n        return perimeter;\n    }\n}\n```",
  "464": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canIWin(2, 2));\n        System.out.println(canIWin(1, 4));\n        System.out.println(canIWin(4, 5));\n    }\n\n    public static boolean canIWin(int maxChoosableInteger, int numWanted) {\n        // Your code here\n    }\n}",
  "465": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] accounts = {{10,20}, {1,2},{5,9}};\n        System.out.println(maximalAverage(accounts));\n        \n        accounts = new int[][]{{0,2,10,0,5,1},{4,11,3,8,12,6},{13,1,6,7,15,14},{18,16,10,2,4,19}};\n        System.out.println(maximalAverage(accounts));\n        \n        accounts = new int[][]{{10, 20},{1,2},{5,9},{1,10},{0,2}};\n        System.out.println(maximalAverage(accounts));\n    }\n\n    public static double maximalAverage(int[][] accounts) {\n        // Your code here\n    }\n}\n```",
  "466": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countRepetitions(\"aaabaaa\")); // expected: 3\n        System.out.println(countRepetitions(\"abcde\")); // expected: 0\n        System.out.println(countRepetitions(\"aaaaa\")); // expected: 5\n    }\n\n    public static int countRepetitions(String s) {\n        if (s == null || s.length() < 2) return 0;\n        int n = s.length();\n        int maxCount = 0, currCount = 1, prevChar = s.charAt(0);\n        for (int i = 1; i < n; i++) {\n            char c = s.charAt(i);\n            if (c == prevChar) currCount++;\n            else {\n                maxCount = Math.max(maxCount, currCount);\n                currCount = 1;\n            }\n            prevChar = c;\n        }\n        return Math.max(maxCount, currCount);\n    }\n}",
  "467": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countGoodStrings(\"aba#\", 3));\n        System.out.println(countGoodStrings(\"leetcode\", 2));\n        System.out.println(countGoodStrings(\"#aaaa\", 1));\n    }\n\n    public static int countGoodStrings(String s, int n) {\n        char[] str = s.toCharArray();\n        int res = 0;\n        for (int i = 0; i <= s.length() - n; i++) {\n            boolean isUnique = true;\n            for (int j = 0; j < n; j++) {\n                if (str[i + j] == '#') {\n                    str[i + j] = 'a' + ((str[i + j] - 'a' - 1) % 3);\n                }\n                for (int k = i; k <= i + n - 1; k++) {\n                    if (str[k] == str[i + j]) {\n                        isUnique = false;\n                        break;\n                    }\n                }\n            }\n            if (isUnique) res++;\n        }\n        return res;\n    }\n}\n```",
  "468": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(validateIP(\"192.168.1.1\")); // true\n        System.out.println(validateIP(\"256.256.256.256\")); // false\n        System.out.println(validateIP(\"123.456.789.012\")); // false\n    }\n\n    public static boolean validateIP(String IP) {\n        String[] parts = IP.split(\"\\\\.\");\n        if (parts.length != 4) return false;\n\n        for (String part : parts) {\n            if (part.length() > 3 || !isDigit(part)) return false;\n            if (!isValidOctet(Integer.parseInt(part))) return false;\n        }\n\n        return true;\n    }\n\n    public static boolean isDigit(String str) {\n        for (int i = 0; i < str.length(); i++) {\n            char c = str.charAt(i);\n            if ((c < '0' || c > '9')) return false;\n        }\n        return true;\n    }\n\n    public static boolean isValidOctet(int octet) {\n        return octet >= 0 && octet <= 255;\n    }\n}\n```",
  "469": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] polygon1 = {{0, 0}, {0, 2}, {2, 2}, {2, 0}};\n        System.out.println(isConvex(polygon1));\n\n        int[][] polygon2 = {{0, 0}, {1, 1}, {2, 2}, {3, 3}, {4, 4}, {5, 5}};\n        System.out.println(isConvex(polygon2));\n\n        int[][] polygon3 = {{-1, -1}, {-1, 1}, {1, 1}, {1, -1}};\n        System.out.println(isConvex(polygon3));\n    }\n\n    public static boolean isConvex(int[][] polygon) {\n        int n = polygon.length;\n        for (int i = 0; i < n; i++) {\n            int x1 = polygon[i][0], y1 = polygon[i][1];\n            int x2 = polygon[(i + 1) % n][0], y2 = polygon[(i + 1) % n][1];\n            int x3 = polygon[(i + 2) % n][0], y3 = polygon[(i + 2) % n][1];\n            if ((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "470": "```\nimport java.util.Random;\n\npublic class Solution {\n    public int rand10() {\n        Random random = new Random();\n        while (true) {\n            int num = random.nextInt(7);\n            if (num == 6) continue;\n            return ((random.nextInt(5)+1)*7 + num) % 10 + 1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        for (int i = 0; i < 3; i++) {\n            System.out.println(solution.rand10());\n        }\n    }\n}",
  "471": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(shortestToLongest(\"aaabaaaaa\")); // Expected: \"12[aaa]\"\n        System.out.println(shortestToLongest(\"aaa\")); // Expected: \"3[a]\"\n        System.out.println(shortestToLongest(\"123\")); // Expected: \"123\"\n    }\n\n    public static String shortestToLongest(String s) {\n        StringBuilder sb = new StringBuilder();\n        int count = 1;\n        for (int i = 0; i < s.length(); i++) {\n            if (Character.isDigit(s.charAt(i))) {\n                while (i + 1 < s.length() && Character.isDigit(s.charAt(i + 1))) {\n                    i++;\n                }\n                sb.append(count).append('[');\n                for (int j = i; j <= i; j++) {\n                    sb.append(s.charAt(j));\n                }\n                sb.append(']');\n                count++;\n            } else {\n                if (count > 0) {\n                    sb.append(count).append('[');\n                    for (int j = i - count + 1; j <= i; j++) {\n                        sb.append(s.charAt(j));\n                    }\n                    sb.append(']');\n                    count--;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}",
  "472": "```\npublic class Main {\n    public static void main(String[] args) {\n        String[] words = {\"apple\", \"banana\", \"cat\", \"dog\"};\n        System.out.println(canBeConverted(\"applepenapple\", words));\n        \n        words = new String[]{\"cats\",\"dogs\",\"sand\",\"dream\",\"cell\"};\n        System.out.println(canBeConverted(\"leetcodeentriesannouncementsdariandreamedofcissofdogsdayafterday\", words));\n        \n        words = new String[]{\"a\", \"banana\", \"app\", \"appl\"};\n        System.out.println(canBeConverted(\"blaappleblanapppleblananabana\", words));\n    }\n\n    public static boolean canBeConverted(String root, String[] wordList) {\n        TrieNode rootNode = new TrieNode();\n        for (String word : wordList) {\n            TrieNode node = rootNode;\n            for (char c : word.toCharArray()) {\n                if (!node.children.containsKey(c)) {\n                    node.children.put(c, new TrieNode());\n                }\n                node = node.children.get(c);\n            }\n        }\n\n        boolean result = false;\n        for (int i = 0; i < root.length(); i++) {\n            TrieNode node = rootNode;\n            for (int j = i; j < root.length(); j++) {\n                if (!node.children.containsKey(root.charAt(j))) {\n                    break;\n                }\n                node = node.children.get(root.charAt(j));\n                if (j == root.length() - 1) {\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\nclass TrieNode {\n    Map<Character, TrieNode> children = new HashMap<>();\n}\n```",
  "473": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canMakeSquare(new int[]{1,5,2,1}, 7));\n        System.out.println(canMakeSquare(new int[]{1,2,4}, 6));\n        System.out.println(canMakeSquare(new int[]{1,3,3,3}, 9));\n    }\n\n    public static boolean canMakeSquare(int[] matchsticks, int target) {\n        // Your code here...\n    }\n}\n```",
  "474": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{0, 1}, {1, 0}};\n        System.out.println(\"Expected: 2, Actual: \" + onesAndZeroes(grid1));\n        \n        int[][] grid2 = {{0, 0, 0}, {0, 1, 1}};\n        System.out.println(\"Expected: 6, Actual: \" + onesAndZeroes(grid2));\n        \n        int[][] grid3 = {{0, 0, 0, 1}, {1, 1, 1, 1}};\n        System.out.println(\"Expected: 7, Actual: \" + onesAndZeroes(grid3));\n    }\n\n    public static int onesAndZeroes(int[][] grid) {\n        int m = grid.length;\n        if (m == 0) return 0;\n\n        int n = grid[0].length;\n        int[][] dp = new int[m][n];\n        dp[0] = grid[0];\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1]) + (j > 0 ? grid[i][j - 1] : 0);\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1]) + (j < n - 1 ? grid[i][j + 1] : 0);\n                }\n            }\n        }\n\n        return dp[m - 1][n - 1];\n    }\n}",
  "475": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \");\n        int[] locations = {1,2,3};\n        int startValue = 2;\n        int result = totalHeatingTime(locations, startValue);\n        System.out.println(\"The time to heat the entire street is \" + result);\n\n        System.out.println(\"\\nTest Case 2: \");\n        locations = new int[]{10,30};\n        startValue = 20;\n        result = totalHeatingTime(locations, startValue);\n        System.out.println(\"The time to heat the entire street is \" + result);\n\n        System.out.println(\"\\nTest Case 3: \");\n        locations = new int[]{1,4,25};\n        startValue = 15;\n        result = totalHeatingTime(locations, startValue);\n        System.out.println(\"The time to heat the entire street is \" + result);\n    }\n\n    public static int totalHeatingTime(int[] locations, int startValue) {\n        Arrays.sort(locations);\n        int min = Math.min(startValue - 1, locations[0]);\n        int max = Math.max(startValue, locations[locations.length - 1]);\n        int time = 0;\n        for (int i = 0; i < locations.length; i++) {\n            if (locations[i] > startValue) {\n                time += Math.abs(locations[i] - startValue);\n            } else {\n                if (startValue <= min + 1) {\n                    time += Math.min(startValue - min, locations[i] - min);\n                }\n                time += locations[i];\n            }\n        }\n        for (int i = max; i < startValue; i++) {\n            time += i;\n        }\n        return time;\n    }\n}",
  "476": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findComplement(5)); // Output: 2\n        System.out.println(findComplement(10)); // Output: 5\n        System.out.println(findComplement(9)); // Output: 6\n    }\n\n    public static int findComplement(int num) {\n        return ~num;\n    }\n}",
  "477": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(totalHammingDistance(new int[]{4,14,2})) ; \n        System.out.println(totalHammingDistance(new int[]{4,9,0})) ; \n        System.out.println(totalHammingDistance(new int[]{3,8,1,0}));\n    }\n\n    public static int totalHammingDistance(int[] nums) {\n        int res = 0;\n        for (int i = 0; i < (1 << 20); i++) {\n            for (int j = 0; j < 20; j++) {\n                if (((i >> j) & 1) == ((nums[j] >> j) & 1)) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```",
  "478": "```\nimport java.util.Random;\n\npublic class Solution {\n    public double[] generateTheGrid(int radius) {\n        Random rand = new Random();\n        while (true) {\n            double x = rand.nextDouble() * 2 - 1;\n            double y = rand.nextDouble() * 2 - 1;\n            if (x * x + y * y <= 1) return new double[]{radius * Math.sqrt(x * x + y * y), Math.atan2(y, x)};\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(\"Test Case 1:\");\n        double[] result1 = solution.generateTheGrid(3);\n        for (double d : result1) {\n            System.out.print(d + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Test Case 2:\");\n        double[] result2 = solution.generateTheGrid(5);\n        for (double d : result2) {\n            System.out.print(d + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Test Case 3:\");\n        double[] result3 = solution.generateTheGrid(7);\n        for (double d : result3) {\n            System.out.print(d + \" \");\n        }\n        System.out.println();\n    }\n}",
  "479": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(largestPalindrome(2)); // Test case 1: Expected output = 9009\n        System.out.println(largestPalindrome(3)); // Test case 2: Expected output = 906609\n        System.out.println(largestPalindrome(4)); // Test case 3: Expected output = 990000989\n    }\n\n    public static int largestPalindrome(int n) {\n        if (n < 1) return -1;\n        long left = (long) Math.pow(10, n);\n        long right = left - 1;\n        long maxPalindrome = 0;\n\n        for (long i = right; i >= left / 10L; --i) {\n            long num = i * i + i;\n            long rev = Long.reverse(num);\n\n            if (num == rev && num > maxPalindrome) {\n                maxPalindrome = num;\n            }\n        }\n\n        return (int)maxPalindrome;\n    }\n}\n```",
  "480": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input = {{1}, {3}, {2}};\n        for (int i = 0; i < input.length; i++) {\n            System.out.println(\"Input: \" + Arrays.toString(input[i]));\n            System.out.println(\"Expected Output: [\" + String.join(\", \", getSlidingWindowMedian(input[i])) + \"]\");\n            System.out.println();\n        }\n    }\n\n    public static double[] getSlidingWindowMedian(int[] nums) {\n        int n = nums.length;\n        double[] res = new double[(n + 1) / 2];\n        for (int i = 0, j = 0; i < n; i++) {\n            if (i > j + 1) j++;\n            int m = Math.min(i + 1, j + 1);\n            if (m == 1) res[j] = nums[i];\n            else {\n                double mid = (nums[m - 2] + nums[m - 1]) / 2.0;\n                res[j] = mid;\n            }\n        }\n        return res;\n    }\n}",
  "481": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(magicalString(\"123456789\", 4));\n        System.out.println(magicalString(\"abacaba\", 2));\n        System.out.println(magicalString(\"\", 1));\n    }\n\n    public static int magicalString(int n, int m) {\n        if (n < m) return -1;\n        boolean[] used = new boolean[n];\n        char[] str = new char[n];\n        int i = 0, j = 0, k = 1;\n        while (k <= n) {\n            if (!used[i]) {\n                str[j++] = (char)(k + '0');\n                used[i] = true;\n                if (++i == m - 1) break;\n            }\n            k++;\n        }\n        return j;\n    }\n}\n```",
  "482": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(formatLicenseKey(\"5-1-1\")); // expected \"1-1-5\"\n        System.out.println(formatLicenseKey(\"2-4A0r7-1S116nL\")); // expected \"4A0r7-116nL-2\"\n        System.out.println(formatLicenseKey(\"a0f0u-1p6y9-b7k5-l3e2-t1v1\")); // expected \"1-6y9-b75-k3-e2-T1V1\"\n    }\n\n    public static String formatLicenseKey(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (String part : s.split(\"-\")) {\n            sb.append(part.toUpperCase());\n            if (!sb.toString().endsWith(part)) {\n                sb.append(\"-\");\n            }\n        }\n        return sb.toString();\n    }\n}",
  "483": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(smallestGoodBase(16)); // Expected output: 2\n        System.out.println(smallestGoodBase(27)); // Expected output: 3\n        System.out.println(smallestGoodBase(45)); // Expected output: 6\n    }\n\n    public static int smallestGoodBase(int n) {\n        for (int base = 2; ; base++) {\n            int k = (int) Math.floor(Math.log(n) / Math.log(base));\n            if ((1 << k) == n) {\n                return base;\n            }\n        }\n    }\n}",
  "484": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(arrayRankTransforms(new int[]{40, 10, 20, 30}) + \" Expected: 4\");\n        System.out.println(arrayRankTransforms(new int[]{100, 99, 98}) + \" Expected: 3\");\n        System.out.println(arrayRankTransforms(new int[]{37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}) + \" Expected: 22\");\n    }\n\n    public static String arrayRankTransforms(int[] arr) {\n        int[][] dp = new int[arr.length][];\n        for (int i = 0; i < arr.length; i++) {\n            dp[i] = new int[]{arr[i], i};\n        }\n        Arrays.sort((o1, o2) -> Integer.compare(o1[0], o2[0]));\n        StringBuilder sb = new StringBuilder();\n        int rank = 1;\n        for (int[] pair : dp) {\n            if (pair[0] != dp[dp.length - 1][0]) {\n                sb.append(rank).append(\"\\n\");\n                rank++;\n            }\n        }\n        return sb.toString().trim();\n    }\n}",
  "485": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {8, 0, 0, 1, 1, 0};\n        System.out.println(\"Max Consecutive Ones for array \" + Arrays.toString(arr1) + \": \" + findMaxConsecutiveOnes(arr1));\n\n        int[] arr2 = {1, 0, 1, 0, 1, 1, 1, 1};\n        System.out.println(\"Max Consecutive Ones for array \" + Arrays.toString(arr2) + \": \" + findMaxConsecutiveOnes(arr2));\n\n        int[] arr3 = {0, 0, 0};\n        System.out.println(\"Max Consecutive Ones for array \" + Arrays.toString(arr3) + \": \" + findMaxConsecutiveOnes(arr3));\n    }\n\n    public static int findMaxConsecutiveOnes(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n        int maxCount = 0, currentCount = 0;\n        for (int num : nums) {\n            if (num == 1) {\n                currentCount++;\n                maxCount = Math.max(maxCount, currentCount);\n            } else {\n                currentCount = 0;\n            }\n        }\n        return maxCount;\n    }\n}\n```",
  "486": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new PredictTheWinner().predictTheWinner(new int[]{1, 2}, 1).equals(\"Alice\")) ?\n                \"Test case 1 passed\" : \"Test case 1 failed\";\n        \n        System.out.println(new PredictTheWinner().predictTheWinner(new int[]{10, 5, 3}, 0).equals(\"Bob\")) ?\n                \"Test case 2 passed\" : \"Test case 2 failed\";\n        \n        System.out.println(new PredictTheWinner().predictTheWinner(new int[]{1, 3, 2}, 1).equals(\"Alice\")) ?\n                \"Test case 3 passed\" : \"Test case 3 failed\";\n    }\n}\n```",
  "487": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1,0,1,1,0,0};\n        System.out.println(\"Test case 1: \" + findMaxConsecutiveOnes(nums1));\n        \n        int[] nums2 = {0,1,0,1,0,1};\n        System.out.println(\"Test case 2: \" + findMaxConsecutiveOnes(nums2));\n        \n        int[] nums3 = {1,1,1,1,1};\n        System.out.println(\"Test case 3: \" + findMaxConsecutiveOnes(nums3));\n    }\n\n    public static int findMaxConsecutiveOnes(int[] nums) {\n        int maxCount = 0;\n        int left = 0;\n        int right = 0;\n        while (right < nums.length) {\n            if (nums[right] == 1) {\n                right++;\n            } else {\n                if (left <= right && (right - left + 1) > maxCount) {\n                    maxCount = right - left + 1;\n                }\n                left = right + 1;\n                right = left;\n            }\n        }\n        return maxCount;\n    }\n}",
  "489": "```\npublic class Main {\n    public static void main(String[] args) {\n        RobotRoomCleaner room = new RobotRoomCleaner(new int[][]{{1, 0}, {2, 0}});\n        System.out.println(\"Test case 1: \");\n        clean(room);\n        \n        room = new RobotRoomCleaner(new int[][]{{3, 4}, {0, 4}});\n        System.out.println(\"Test case 2: \");\n        clean(room);\n\n        room = new RobotRoomCleaner(new int[][]{{7,6},{4,5},{3,1},{2,3},{0,5}});\n        System.out.println(\"Test case 3: \");\n        clean(room);\n    }\n\n    public static void clean(RobotRoomCleaner room) {\n        while (room.hasMoreDirections()) {\n            room.move();\n            System.out.print(room.roomCleaned() + \" \");\n        }\n        System.out.println();\n    }\n}\n```",
  "488": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minMoves(\"WZZZWW\", \"XXX\"));// Expected: 4\n        System.out.println(minMoves(\"XYZ\", \"ABC\"));// Expected: 2\n        System.out.println(minMoves(\"X\", \"X\"));// Expected: 0\n    }\n\n    public static int minMoves(String board, String stones) {\n        // Your code here...\n    }\n}\n```",
  "491": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr = { {1, 3, 6, 7}, {2, 6, 9}, {3, 5, 26} };\n        \n        for (int i = 0; i < arr.length; i++) {\n            System.out.println(\"The number of non-decreasing subsequences in \" + Arrays.toString(arr[i]) + \" is: \" + numSubseqWidths(arr[i]));\n        }\n    }\n\n    public static int numSubseqWidths(int[] A) {\n        // Your code here\n    }\n}\n```",
  "490": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] maze = {\n                {0,0,1,0,0},\n                {0,0,1,0,0},\n                {0,0,0,0,0},\n                {0,1,1,5,0},\n                {4,3,1,0,2}\n        };\n\n        System.out.println(hasPath(maze, 1, 1));\n        System.out.println(hasPath(maze, 0, 0));\n        System.out.println(hasPath(maze, 4, 4));\n\n    }\n\n    public static boolean hasPath(int[][] maze, int startRow, int startCol) {\n        if (startRow < 0 || startCol < 0 || startRow >= maze.length || startCol >= maze[0].length) {\n            return false;\n        }\n        if (maze[startRow][startCol] == 1) {\n            return false;\n        }\n\n        boolean[][] visited = new boolean[maze.length][maze[0].length];\n\n        dfs(maze, startRow, startCol, visited);\n\n        for (int i = 0; i < maze.length; i++) {\n            for (int j = 0; j < maze[0].length; j++) {\n                if (visited[i][j]) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static void dfs(int[][] maze, int row, int col, boolean[][] visited) {\n        visited[row][col] = true;\n\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n        for (int[] direction : directions) {\n            int newRow = row + direction[0];\n            int newCol = col + direction[1];\n\n            while (newRow >= 0 && newCol >= 0 && newRow < maze.length && newCol < maze[0].length) {\n                if (!visited[newRow][newCol] && maze[newRow][newCol] == 0) {\n                    dfs(maze, newRow, newCol, visited);\n                    break;\n                } else if (maze[newRow][newCol] != 1) {\n                    return;\n                }\n\n                newRow += direction[0];\n                newCol += direction[1];\n            }\n        }\n    }\n}",
  "492": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int width1 = 4;\n        int height1 = 17;\n        System.out.println(\"Expected: \" + calculateArea(width1, height1) + \" - Actual: \" + calculateRectangleArea(width1, height1));\n        \n        int width2 = 5;\n        int height2 = 8;\n        System.out.println(\"Expected: \" + (width2 * height2) + \" - Actual: \" + calculateRectangleArea(width2, height2));\n\n        int width3 = 10;\n        int height3 = 1;\n        System.out.println(\"Expected: \" + (width3 * height3) + \" - Actual: \" + calculateRectangleArea(width3, height3));\n    }\n\n    public static int calculateRectangleArea(int w, int h) {\n        int area = 0;\n        for (int i = 1; i <= h; i++) {\n            area += Math.max(0, w);\n        }\n        return area;\n    }\n}",
  "493": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] array1 = {{1,2},{3,4}};\n        System.out.println(reversePairs(array1));\n        \n        int[][] array2 = {{1,3},{5,6}};\n        System.out.println(reversePairs(array2));\n\n        int[][] array3 = {{1,5},{2,3},{5,7}};\n        System.out.println(reversePairs(array3));\n    }\n\n    public static int reversePairs(int[][] nums) {\n        // Your code here\n        return 0;\n    }\n}\n```",
  "494": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findTargetSumWays(new int[]{1, -1, 1, 1}, 2)); // Expected output: 2\n        System.out.println(findTargetSumWays(new int[]{0}, 0)); // Expected output: 1\n        System.out.println(findTargetSumWays(new int[]{3,-2,2,-1,4}, 0)); // Expected output: 7\n    }\n\n    public static int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        int onesCount = 0;\n\n        for (int num : nums) {\n            sum += num;\n            if (num > 0) {\n                onesCount++;\n            }\n        }\n\n        if ((sum + target) % 2 != 0 || Math.abs(target) > sum) {\n            return 0;\n        }\n\n        int halfSum = (sum + target) / 2;\n\n        int[] dp = new int[10001];\n\n        for (int num : nums) {\n            for (int i = 10000; i >= Math.max(num, halfSum); i--) {\n                dp[i] += dp[i - num];\n            }\n        }\n\n        return dp[halfSum];\n    }\n}",
  "495": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] people = {{1, 2}, {4, 7}, {3, 4}};\n        System.out.println(numberOfBoomerangs(people));\n        \n        people = new int[][]{{1, 2}, {5, 6}};\n        System.out.println(numberOfBoomerangs(people));\n\n        people = new int[][]{{0, 0}, {3, 9}, {7, 12}};\n        System.out.println(numberOfBoomerangs(people));\n    }\n\n    public static int numberOfBoomerangs(int[][] people) {\n        int total = 0;\n        for (int[] person : people) {\n            int x1 = person[0];\n            int y1 = person[1];\n            int distance = 0;\n            for (int[] otherPerson : people) {\n                if ((otherPerson[0] == x1 && Math.abs(otherPerson[1] - y1) > distance) || \n                    (otherPerson[1] == y1 && Math.abs(otherPerson[0] - x1) > distance)) {\n                    distance = Math.max(distance, Math.abs(otherPerson[1] - y1), Math.abs(otherPerson[0] - x1));\n                }\n            }\n            total += distance;\n        }\n        return total;\n    }\n}\n```",
  "496": "```\nimport org.junit.Test;\n\npublic class NextGreaterElementI {\n    public int[] nextGreaterElements(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            int idx = (i + 1) % n;\n            while (nums[idx] <= nums[i]) {\n                idx = (idx + 1) % n;\n            }\n            res[i] = idx != n ? nums[idx] : -1;\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        NextGreaterElementI solution = new NextGreaterElementI();\n        \n        // Test case 1\n        int[] test1 = {2, 1, 3};\n        int[] result1 = solution.nextGreaterElements(test1);\n        System.out.println(\"Test case 1: \" + Arrays.toString(result1));\n\n        // Test case 2\n        int[] test2 = {1, 2, 3, 2, 4};\n        int[] result2 = solution.nextGreaterElements(test2);\n        System.out.println(\"Test case 2: \" + Arrays.toString(result2));\n\n        // Test case 3\n        int[] test3 = {1, 1, 1};\n        int[] result3 = solution.nextGreaterElements(test3);\n        System.out.println(\"Test case 3: \" + Arrays.toString(result3));\n    }\n}",
  "497": "```\nimport java.util.Random;\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] rectangles1 = {{0, 1}, {2, 3}};\n        System.out.println(\"Test case 1: \" + solution.randomPoint(rectangles1));\n        \n        int[][] rectangles2 = {{1, 3}, {3, 4}, {7, 8}, {9, 11}};\n        System.out.println(\"Test case 2: \" + solution.randomPoint(rectangles2));\n        \n        int[][] rectangles3 = {{1, 3}, {5, 6}};\n        System.out.println(\"Test case 3: \" + solution.randomPoint(rectangles3));\n    }\n}\n\nclass Solution {\n    public int[] randomPoint(int[][] rectangles) {\n        // Your code here\n    }\n}\n```",
  "498": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] mat = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        diagonalTraverse(mat);\n        \n        mat = new int[][]{{1, 2, 3, 4},{5, 6, 7, 8},{9,10,11,12}};\n        diagonalTraverse(mat);\n\n        mat = new int[][]{{1,2}};\n        diagonalTraverse(mat);\n    }\n\n    public static void diagonalTraverse(int[][] mat) {\n        for (int k = Math.min(0, mat[0].length - 1); k < Math.max(mat.length, mat[0].length); ) {\n            for (int i = k >= mat.length ? 0 : k; i <= Math.min(k, mat.length - 1); i++) {\n                System.out.print(mat[i][k] + \" \");\n            }\n            System.out.println();\n            \n            if (k < mat[0].length) {\n                for (int j = k + 1; j >= 0 && j < Math.max(0, k - mat.length + 2); j--) {\n                    System.out.print(mat[k][j] + \" \");\n                }\n                System.out.println();\n            } else {\n                k++;\n            }\n        }\n    }\n}\n```",
  "499": "```\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Solution {\n    public int shortestDistance(int[][] grid) {\n        // Your implementation here\n    }\n\n    @Test\n    public void test1() {\n        int[][] grid = {\n            {0, 1, 0},\n            {1, 1, 0},\n            {0, 0, 2}\n        };\n        assertEquals(6, shortestDistance(grid));\n    }\n\n    @Test\n    public void test2() {\n        int[][] grid = {\n            {0, 0, 0},\n            {1, 1, 1},\n            {1, 1, 1}\n        };\n        assertEquals(-1, shortestDistance(grid));\n    }\n\n    @Test\n    public void test3() {\n        int[][] grid = {\n            {0, 0, 1},\n            {1, 0, 2},\n            {4, 1, 3}\n        };\n        assertEquals(6, shortestDistance(grid));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.test1();\n        solution.test2();\n        solution.test3();\n    }\n}",
  "500": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeTyped(\"Hello World\"));\n        System.out.println(canBeTyped(\"Apple Pen\"));\n\n        String[][] keyboard = {{\"q\", \"w\", \"e\", \"r\", \"t\"}, {\"y\", \"u\", \"i\", \"o\", \"p\"}, {\"a\", \"s\", \"d\", \"f\", \"g\"}};\n        System.out.println(canBeTyped(keyboard, \"hello\"));\n\n        String[][] keyboard1 = {{\"q\", \"w\", \"e\", \"r\", \"t\"}, {\"y\", \"u\", \"i\", \"o\", \"p\"}, {\"a\", \"s\", \"d\", \"f\", \"g\"}, {\"h\", \"j\", \"k\"}};\n        System.out.println(canBeTyped(keyboard1, \"hjkl\"));\n    }\n\n    public static boolean canBeTyped(String word) {\n        for (char c : word.toLowerCase().toCharArray()) {\n            if (!isPresentInKeyboard(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean canBeTyped(String[][] keyboard, String word) {\n        for (char c : word.toLowerCase().toCharArray()) {\n            char key = findKey(keyboard, c);\n            if (key == '0') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static char findKey(String[][] keyboard, char c) {\n        for (int i = 0; i < keyboard.length; i++) {\n            for (int j = 0; j < keyboard[i].length; j++) {\n                if (keyboard[i][j].charAt(0) == Character.toLowerCase(c)) {\n                    return keyboard[i][j].charAt(0);\n                }\n            }\n        }\n        return '0';\n    }\n\n    public static boolean isPresentInKeyboard(char c) {\n        for (String[] row : new String[][]{{\"q\", \"w\", \"e\", \"r\", \"t\"}, {\"y\", \"u\", \"i\", \"o\", \"p\"}, {\"a\", \"s\", \"d\", \"f\", \"g\"}}) {\n            for (String key : row) {\n                if (key.charAt(0) == Character.toLowerCase(c)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```",
  "502": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        int[] cost = {7, 6, 5, 4, 3};\n        int[] mktVal = {100, 70, 60, 40, 20};\n        ipo(cost, mktVal);\n        System.out.println();\n\n        System.out.println(\"Test Case 2:\");\n        cost = new int[]{1, 2, 3, 4, 5};\n        mktVal = new int[]{10, 10, 10, 10, 20};\n        ipo(cost, mktVal);\n        System.out.println();\n\n        System.out.println(\"Test Case 3:\");\n        cost = new int[]{9, 8, 7, 6, 5};\n        mktVal = new int[]{2, 1, 2, 4, 2};\n        ipo(cost, mktVal);\n        System.out.println();\n    }\n\n    public static void ipo(int[] cost, int[] mktVal) {\n        Arrays.sort(mktVal);\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int i = 0; i < mktVal.length; i++) {\n            if (i + 1 <= mktVal[i]) {\n                pq.offer(cost[i]);\n            }\n        }\n        while (!pq.isEmpty()) {\n            System.out.println(pq.poll());\n        }\n    }\n}\n```",
  "501": "```\nclass Solution {\n    int max = Integer.MIN_VALUE;\n    int count = 0;\n    int res = 0;\n\n    public int findMode(TreeNode root) {\n        inOrder(root);\n        return res;\n    }\n\n    public void inOrder(TreeNode node) {\n        if (node == null)\n            return;\n        inOrder(node.left);\n        if (node.val > max) {\n            max = node.val;\n            count = 1;\n        } else if (node.val == max) {\n            count++;\n        }\n        if (count > 1) {\n            res = node.val;\n        }\n        inOrder(node.right);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        TreeNode root1 = new TreeNode(7);\n        root1.left = new TreeNode(3);\n        root1.right = new TreeNode(2);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(6);\n\n        System.out.println(\"Test Case 1: \" + solution.findMode(root1)); // expected output: 3\n\n        TreeNode root2 = new TreeNode(7);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n        root2.left.left = new TreeNode(4);\n        root2.left.right = new TreeNode(5);\n\n        System.out.println(\"Test Case 2: \" + solution.findMode(root2)); // expected output: 7\n\n        TreeNode root3 = new TreeNode(0);\n\n        System.out.println(\"Test Case 3: \" + solution.findMode(root3)); // expected output: 0\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "503": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {{\"1\", \"2\", \"3\"}, {\"6\", \"7\", \"10\", \"14\", \"4\", \"7\", \"8\"}, {\"1\", \"2\", \"3\"}};\n        for (int i = 0; i < inputs.length; i++) {\n            int[] nums = new int[inputs[i].length];\n            for (int j = 0; j < inputs[i].length; j++) {\n                nums[j] = Integer.parseInt(inputs[i][j]);\n            }\n            int[] result = nextGreaterElements(nums);\n            System.out.println(Arrays.toString(result));\n        }\n    }\n\n    public static int[] nextGreaterElements(int[] nums) {\n        int n = nums.length;\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            int j = i;\n            while (j > 0 && i >= j) {\n                j--;\n            }\n            res[i] = findNextGreater(nums, i);\n        }\n        return res;\n    }\n\n    public static int findNextGreater(int[] nums, int index) {\n        for (int i = index; i < nums.length; i++) {\n            if (nums[i] > nums[index]) {\n                return nums[i];\n            }\n        }\n        for (int i = 0; i < index; i++) {\n            if (nums[i] > nums[index]) {\n                return nums[i];\n            }\n        }\n        return -1;\n    }\n}",
  "504": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(convertToBase7(-8)); // Test case 1\n        System.out.println(convertToBase7(0)); // Test case 2\n        System.out.println(convertToBase7(10)); // Test case 3\n    }\n\n    public static String convertToBase7(int n) {\n        if (n == 0) return \"0\";\n        StringBuilder sb = new StringBuilder();\n        boolean isNegative = false;\n        if (n < 0) {\n            isNegative = true;\n            n = -n;\n        }\n        while (n > 0) {\n            sb.insert(0, n % 7);\n            n /= 7;\n        }\n        return isNegative ? \"-\" + sb.toString() : sb.toString();\n    }\n}",
  "506": "```\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] scores1 = {5, 4, 8, 2, 6};\n        System.out.println(Arrays.toString(findRelativeRanks(scores1)));\n\n        int[] scores2 = {10, 3, 8, 9, 6};\n        System.out.println(Arrays.toString(findRelativeRanks(scores2)));\n\n        int[] scores3 = {0, 0, 5, 7, 11};\n        System.out.println(Arrays.toString(findRelativeRanks(scores3)));\n    }\n\n    public static String[] findRelativeRanks(int[] score) {\n        Integer[] integers = new Integer[score.length];\n        for (int i = 0; i < score.length; i++) {\n            integers[i] = i;\n        }\n        Arrays.sort(integers, (a, b) -> score[b] - score[a]);\n\n        String[] ranks = new String[score.length];\n        for (int i = 0; i < score.length; i++) {\n            if (i == 0) {\n                ranks[integers[i]] = \"Gold Medal\";\n            } else if (i == 1) {\n                ranks[integers[i]] = \"Silver Medal\";\n            } else if (i == 2) {\n                ranks[integers[i]] = \"Bronze Medal\";\n            } else {\n                ranks[integers[i]] = (i + 1) + \"\";\n            }\n        }\n\n        return ranks;\n    }\n}",
  "505": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] maze = {{0,1,0,0,0},{0,1,0,0,0},{0,0,0,1,0},{1,1,0,0,0}};\n        System.out.println(\"Shortest Distance: \" + shortestDistance(maze, 2, 5));\n        \n        int[][] maze2 = {{0,0,1,0,0},{0,0,1,0,0},{0,0,1,0,0},{1,1,1,1,1}};\n        System.out.println(\"Shortest Distance: \" + shortestDistance(maze2, 2, 5));\n        \n        int[][] maze3 = {{0,1,0,0,0},{0,1,0,0,0},{0,0,0,1,0},{1,1,0,0,0}};\n        System.out.println(\"Shortest Distance: \" + shortestDistance(maze3, 2, 5));\n    }\n\n    public static int shortestDistance(int[][] maze) {\n        if (maze == null || maze.length == 0 || maze[0].length == 0)\n            return -1;\n        \n        boolean[][] visited = new boolean[maze.length][maze[0].length];\n        int[][] directions = {{-1,0},{1,0},{0,-1},{0,1}};\n        \n        int minSteps = getShortestPath(maze, visited, 0, 0, (int)1e9, directions);\n        return minSteps == (int)1e9 ? -1 : minSteps;\n    }\n\n    public static int getShortestPath(int[][] maze, boolean[][] visited, int i, int j, int steps, int[][] directions) {\n        if (i < 0 || i >= maze.length || j < 0 || j >= maze[0].length)\n            return (int)1e9;\n        \n        if (visited[i][j])\n            return (int)1e9;\n        \n        visited[i][j] = true;\n        \n        if (maze[i][j] == 1)\n            return steps;\n        \n        int minPath = (int)1e9;\n        \n        for (int[] direction : directions) {\n            int newX = i + direction[0];\n            int newY = j + direction[1];\n            \n            minPath = Math.min(minPath, getShortestPath(maze, visited, newX, newY, steps + 1, directions));\n        }\n        \n        return minPath;\n    }\n}\n```",
  "507": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isPerfectNumber(6)); // true\n        System.out.println(isPerfectNumber(28)); // true\n        System.out.println(isPerfectNumber(12)); // false\n    }\n\n    public static boolean isPerfectNumber(int num) {\n        if (num <= 0) return false;\n        int sum = 0;\n        for (int i = 1; i < num; i++) {\n            if (num % i == 0) {\n                sum += i;\n            }\n        }\n        return sum == num;\n    }\n}",
  "508": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(-3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(1);\n\n        int[] result1 = findFrequentTreeSum(root1);\n        System.out.println(\"Expected: [2, 2; -3], Actual: \" + Arrays.toString(result1));\n\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(4);\n        root2.right = new TreeNode(-3);\n\n        int[] result2 = findFrequentTreeSum(root2);\n        System.out.println(\"Expected: [7, -3], Actual: \" + Arrays.toString(result2));\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(-2);\n        root3.right = new TreeNode(-3);\n\n        int[] result3 = findFrequentTreeSum(root3);\n        System.out.println(\"Expected: [0, 0], Actual: \" + Arrays.toString(result2));\n    }\n\n    public static int[] findFrequentTreeSum(TreeNode root) {\n        // Your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n```",
  "509": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Fibonacci Number Test Cases:\");\n        System.out.println(fib(2) + \" for input 2\");\n        System.out.println(fib(3) + \" for input 3\");\n        System.out.println(fib(10) + \" for input 10\");\n    }\n\n    public static int fib(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        int[] memo = new int[n+1];\n        memo[0] = 0;\n        memo[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            memo[i] = memo[i-1] + memo[i-2];\n        }\n        return memo[n];\n    }\n}",
  "511": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = {\n            {1, \"Peter\", \"Peter\"},\n            {2, \"Alice\", \"Bob\"},\n            {1, \"Bob\", \"Carol\"},\n            {3, \"Alice\", \"Peter\"}\n        };\n\n        System.out.println(minTimeToWin(logs));\n    }\n\n    public static int minTimeToWin(int[][] logs) {\n        Map<String, Integer> times = new HashMap<>();\n        for (int[] log : logs) {\n            if (!times.containsKey(log[1])) {\n                times.put(log[1], 0);\n            }\n            times.put(log[1], Math.max(times.get(log[1]), log[2] - log[0]));\n        }\n        int minTime = Integer.MAX_VALUE;\n        for (int time : times.values()) {\n            minTime = Math.min(minTime, time);\n        }\n        return minTime;\n    }\n}",
  "510": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        // Test case 1:\n        Node root = new Node(2);\n        root.left = new Node(1);\n        root.right = new Node(4);\n        root.right.left = new Node(3);\n\n        System.out.println(\"Inorder successor of node with value 5 is \" + inorderSuccessor(root, new Node(5)).val);\n\n        // Test case 2:\n        root = null;\n\n        System.out.println(\"Inorder successor of node with value 1 is \" + inorderSuccessor(root, new Node(1)));\n\n        // Test case 3:\n        root = new Node(8);\n        root.left = new Node(7);\n        root.right = new Node(9);\n\n        System.out.println(\"Inorder successor of node with value 7 is \" + inorderSuccessor(root, new Node(7)).val);\n    }\n\n    static class Node {\n        int val;\n        Node left, right;\n\n        public Node(int v) {\n            val = v;\n        }\n    }\n\n    public static Node inorderSuccessor(Node root, Node p) {\n        if (p == null || root == null) return null;\n        if (root.val <= p.val) {\n            return inorderSuccessor(root.right, p);\n        } else {\n            Node node = inorderSuccessor(root.left, p);\n            return node != null ? node : root;\n        }\n    }\n}",
  "512": "```\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Solution {\n    public int[] findIndices(String id, String sequence) {\n        // Your implementation here\n        return new int[]{1, 2};\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] result1 = solution.findIndices(\"player1\", \"WLRLLW\");\n        assertEquals(new int[]{0, 2}, result1);\n        \n        int[] result2 = solution.findIndices(\"player2\", \"WLHRLL\");\n        assertEquals(new int[]{1, 3}, result2);\n\n        int[] result3 = solution.findIndices(\"player3\", \"LWRWWLR\");\n        assertEquals(new int[]{1, 5}, result3);\n    }\n}",
  "513": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test case 1\n        TreeNode root1 = new TreeNode(2);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(4);\n        root1.left.left = new TreeNode(0);\n        System.out.println(\"Test case 1: \" + findBottomLeftValue(root1));\n        \n        // Test case 2\n        TreeNode root2 = new TreeNode(2);\n        root2.left = new TreeNode(1);\n        root2.right = new TreeNode(3);\n        root2.right.left = new TreeNode(4);\n        System.out.println(\"Test case 2: \" + findBottomLeftValue(root2));\n        \n        // Test case 3\n        TreeNode root3 = null;\n        System.out.println(\"Test case 3: \" + findBottomLeftValue(root3));\n    }\n\n    public static int findBottomLeftValue(TreeNode root) {\n        if (root == null) return 0;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        int result = -1;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (i == size - 1) {\n                    result = node.val;\n                }\n                if (node.left != null) queue.add(node.left);\n                if (node.right != null) queue.add(node.right);\n            }\n        }\n        return result;\n    }\n\n    static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode(int x) { val = x; }\n    }\n}",
  "514": "```\npublic class Solution {\n    public int maxQuality(int[][] quality) {\n        // Your code here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] quality1 = {{10, 20}, {30, 40}};\n        System.out.println(\"Test case 1: \" + solution.maxQuality(quality1));\n        \n        int[][] quality2 = {{5, 10}, {15, 25}};\n        System.out.println(\"Test case 2: \" + solution.maxQuality(quality2));\n        \n        int[][] quality3 = {{100, 200}, {300, 400}, {500, 600}};\n        System.out.println(\"Test case 3: \" + solution.maxQuality(quality3));\n    }\n}\n```",
  "516": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestPalindromicSubsequence(\"bba\", \"ababa\")); // Output: 4\n        System.out.println(longestPalindromicSubsequence(\"bbbk\", \"ababa\")); // Output: 3\n        System.out.println(longestPalindromicSubsequence(\"abcba\", \"abcba\")); // Output: 7\n    }\n\n    public static int longestPalindromicSubsequence(String s1, String s2) {\n        int m = s1.length();\n        int n = s2.length();\n        int dp[][] = new int[m + 1][n + 1];\n\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0) {\n                    dp[i][j] = j;\n                } else if (j == 0) {\n                    dp[i][j] = i;\n                } else if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 2;\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n}",
  "515": "```\nclass Solution {\n    public int[] largestValues(TreeNode root) {\n        if (root == null) return new int[0];\n        \n        List<Integer> res = new ArrayList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        \n        while (!queue.isEmpty()) {\n            int maxVal = Integer.MIN_VALUE;\n            int levelSize = queue.size();\n            \n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                maxVal = Math.max(maxVal, node.val);\n                \n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            \n            res.add(maxVal);\n        }\n        \n        int[] result = new int[res.size()];\n        for (int i = 0; i < res.size(); i++) {\n            result[i] = res.get(i);\n        }\n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(3);\n        root1.right = new TreeNode(2);\n        System.out.println(Arrays.toString(solution.largestValues(root1)));\n        \n        // Test case 2\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(4);\n        root2.right = new TreeNode(8);\n        root2.left.left = new TreeNode(11);\n        root2.left.right = new TreeNode(13);\n        root2.right.left = new TreeNode(4);\n        root2.right.right = new TreeNode(2);\n        System.out.println(Arrays.toString(solution.largestValues(root2)));\n        \n        // Test case 3\n        TreeNode root3 = null;\n        System.out.println(Arrays.toString(solution.largestValues(root3)));\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "517": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] machines = {{1,2,2,4},{3,6,7,10}};\n        System.out.println(maxWashed(0, machines));\n        \n        machines = new int[][]{{8,14,5,9,3,7,15,2,11},{4,12,6,2,10,16,1,15,7}};\n        System.out.println(maxWashed(1, machines));\n\n        machines = new int[][]{{0,2,0,0},{3,4,6,5}};\n        System.out.println(maxWashed(0, machines));\n    }\n\n    public static int maxWashed(int startMachine, int[][] machines) {\n        int time = 0;\n        for (int i = startMachine; i < machines.length; i++) {\n            time += Math.min(machines[i].length, i + 1);\n        }\n        return time;\n    }\n}",
  "518": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] coins = {1, 2, 5};\n        System.out.println(\"Test case 1: \" + coinChange(5, coins));\n        System.out.println(\"Test case 2: \" + coinChange(3, coins));\n        System.out.println(\"Test case 3: \" + coinChange(11, coins));\n    }\n\n    public static int coinChange(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        for (int i = 0; i <= amount; i++) {\n            for (int j = 0; j < coins.length; j++) {\n                if (i - coins[j] >= 0) {\n                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}\n```",
  "519": "```\nimport java.util.Random;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{0,1},{1,0}};\n        System.out.println(\"Matrix 1: \" + flipAndStack(new Random().ints(4, 0, 2).toArray()));\n        \n        int[][] matrix2 = {{0,1,0},{0,0,1},{0,1,1}};\n        System.out.println(\"Matrix 2: \" + flipAndStack(new Random().ints(9, 0, 2).toArray()));\n\n        int[][] matrix3 = {{0,1,1,1},{1,0,0,0},{1,1,1,1},{1,0,1,0}};\n        System.out.println(\"Matrix 3: \" + flipAndStack(new Random().ints(16, 0, 2).toArray()));\n    }\n\n    public static String flipAndStack(int[] nums) {\n        StringBuilder result = new StringBuilder();\n        for (int i : nums) {\n            if (i == 1) {\n                if (new Random().nextBoolean()) {\n                    result.append('0');\n                } else {\n                    result.append('1');\n                }\n            } else {\n                result.append(i);\n            }\n        }\n        return result.toString();\n    }\n}\n```",
  "520": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(detectCapitalWord(\"USA\")); // Expected: true\n        System.out.println(detectCapitalWord(\"leetcode\")); // Expected: false\n        System.out.println(detectCapitalWord(\"Google\")); // Expected: false\n    }\n\n    public static boolean detectCapitalWord(String word) {\n        if (word.length() == 0) return true;\n        boolean isAllLowerCase = true;\n        boolean isAllUpperCase = true;\n\n        for (int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            if (!Character.isLetter(c)) continue;\n            if (Character.isUpperCase(c)) {\n                isAllUpperCase = false;\n            } else {\n                isAllLowerCase = false;\n            }\n        }\n\n        return Character.isUpperCase(word.charAt(0)) && (isAllUpperCase || Character.isLowerCase(word.charAt(1)));\n    }\n}\n```",
  "521": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findLUSlength(\"aba\", \"cd\")); // Expected: 2\n        System.out.println(findLUSlength(\"aaa\", \"aaa\")); // Expected: -1\n        System.out.println(findLUSlength(\"xyz\", \"xy1\")); // Expected: 2\n    }\n\n    public static int findLUSlength(String a, String b) {\n        if (a.equals(b)) return -1;\n        if (a.length() > b.length()) return a.length();\n        if (b.length() > a.length()) return b.length();\n        return a.length();\n    }\n}\n```",
  "522": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(longestUncommonSubsequenceII(new String[]{\"uncommon\", \"common\", \"a\"}, new String[]{\"uncommon\", \"one\", \"two\"})); // Expected: 5\n        System.out.println(longestUncommonSubsequenceII(new String[]{\"aaaa\", \"asasap/ppp/aaa/\"}, new String[]{\"\"})); // Expected: 4\n        System.out.println(longestUncommonSubsequenceII(new String[]{\"cool\",\"lasts\",\"coolest\"}, new String[]{\"cool\",\"last\",\"cool\"})); // Expected: 5\n    }\n\n    public static int longestUncommonSubsequenceII(String[] uncommon, String[] common) {\n        Set<String> set = new HashSet<>();\n        for (String s : common) {\n            set.add(s);\n        }\n        int max = 0;\n        for (String s : uncommon) {\n            if (!set.contains(s)) {\n                max = Math.max(max, s.length());\n            }\n        }\n        return max;\n    }\n}",
  "523": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        int[] nums1 = {23, 2, 4, 6, 7};\n        System.out.println(continuousSubarraySum(nums1)); // Expected output: true\n\n        System.out.println(\"\\nTest Case 2:\");\n        int[] nums2 = {23, 5, -4, 7};\n        System.out.println(continuousSubarraySum(nums2)); // Expected output: false\n\n        System.out.println(\"\\nTest Case 3:\");\n        int[] nums3 = {0, 1, 2, 3, 4, 5};\n        System.out.println(continuousSubarraySum(nums3)); // Expected output: true\n    }\n\n    public static boolean continuousSubarraySum(int[] nums) {\n        int n = nums.length;\n        if (n == 1) return false;\n\n        int totalSum = 0;\n        for (int num : nums) totalSum += num;\n\n        if ((totalSum & 1) == 0) {\n            int target = totalSum / 2;\n            boolean found = false;\n            for (int i = 0; i < n; i++) {\n                int currSum = 0;\n                for (int j = i; j < n; j++) {\n                    currSum += nums[j];\n                    if (currSum == target) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n}\n```",
  "524": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestWord(\"God is power\", new String[]{\"MOOD\", \"DISTANCE\", \"FEARLESS\"}));\n        System.out.println(longestWord(\"abc\", new String[]{\"app\", \"apple\", \"ap\"}));\n        System.out.println(longestWord(\"\", new String[]{\"\"}));\n    }\n\n    public static String longestWord(String s, String[] wordDict) {\n        String res = \"\";\n        for (String word : wordDict) {\n            if (canBeFormed(s, word)) {\n                if (word.length() > res.length()) {\n                    res = word;\n                } else if (word.length() == res.length()) {\n                    res = res.compareTo(word) < 0 ? res : word;\n                }\n            }\n        }\n        return res;\n    }\n\n    public static boolean canBeFormed(String s, String word) {\n        int i = 0, j = 0;\n        while (i < s.length() && j < word.length()) {\n            if (s.charAt(i) == word.charAt(j)) {\n                j++;\n            }\n            i++;\n        }\n        return j == word.length();\n    }\n}",
  "526": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numBeautifulArrangements(2) == 2);\n        System.out.println(numBeautifulArrangements(3) == 3);\n        System.out.println(numBeautifulArrangements(4) == 8);\n    }\n\n    public static int numBeautifulArrangements(int N) {\n        if (N < 1) return 0;\n        long res = 2; // 1 and N\n        for (int i = 3; i <= N; i++) {\n            res *= i; // multiply by i\n        }\n        return (int)res;\n    }\n}\n```",
  "525": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrices = {{[0, 1], [1, 0]}, [[0, 0, 1], [0, 0, 1], [1, 1, 0]}, [[1, 1, 1], [1, 0, 1], [0, 1, 1]}};\n        for (int i = 0; i < matrices.length; i++) {\n            boolean[][] result = {{false}, {true}, {true}};\n            System.out.println(\"Test case \" + (i+1) + \":\");\n            int count = 0;\n            for (boolean[] matrix : result) {\n                for (boolean b : matrix) {\n                    if (b == matrices[i][count++]) {\n                        System.out.print(b + \" \");\n                    } else {\n                        System.out.println(\"Expected: \" + b + \", got: \" + matrices[i][count-1]);\n                        return;\n                    }\n                }\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "528": "```\nimport java.util.Random;\n\npublic class Solution {\n    int[] w;\n    Random rand = new Random();\n\n    public Solution(int[] w) {\n        this.w = w;\n    }\n\n    public int pickIndex() {\n        double target = rand.nextDouble() * 10000;\n        for (int i = 0; i < w.length; i++) {\n            target -= w[i];\n            if (target <= 0) return i;\n        }\n        return w.length - 1;\n    }\n\n    public static void main(String[] args) {\n        int[] w1 = {1};\n        Solution s1 = new Solution(w1);\n        System.out.println(s1.pickIndex()); // Output: 0\n\n        int[] w2 = {3, 2, 9};\n        Solution s2 = new Solution(w2);\n        System.out.println(s2.pickIndex()); // Output: 2\n\n        int[] w3 = [1, 2];\n        Solution s3 = new Solution(w3);\n        System.out.println(s3.pickIndex()); // Output: 0 or 1\n    }\n}",
  "527": "```\npublic class Main {\n    public static void main(String[] args) {\n        String[] words = {\"internationalization\", \"international\", \"national\", \"north\"};\n        int n = words.length;\n        String[] result = wordAbbreviation(words);\n        \n        System.out.println(\"Test Case 1:\");\n        for (int i = 0; i < n; i++) {\n            System.out.println(words[i] + \": \" + result[i]);\n        }\n        \n        words = new String[]{\"like\", \"love\"};\n        n = words.length;\n        result = wordAbbreviation(words);\n        \n        System.out.println(\"Test Case 2:\");\n        for (int i = 0; i < n; i++) {\n            System.out.println(words[i] + \": \" + result[i]);\n        }\n        \n        words = new String[]{\"apple\", \"app\"};\n        n = words.length;\n        result = wordAbbreviation(words);\n        \n        System.out.println(\"Test Case 3:\");\n        for (int i = 0; i < n; i++) {\n            System.out.println(words[i] + \": \" + result[i]);\n        }\n    }\n\n    public static String[] wordAbbreviation(String[] words) {\n        TrieNode root = new TrieNode();\n        List<String> abbreviations = new ArrayList<>();\n        \n        for (String word : words) {\n            TrieNode node = root;\n            StringBuilder abbreviation = new StringBuilder();\n            \n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                \n                if (!node.children.containsKey(c)) {\n                    node.children.put(c, new TrieNode());\n                }\n                \n                node = node.children.get(c);\n                \n                if (i == word.length() - 1 || !Character.isLetter(word.charAt(i + 1))) {\n                    abbreviation.append((char) c).append(String.format(\"%02d\", i + 1));\n                    break;\n                }\n            }\n            \n            abbreviations.add(abbreviation.toString());\n        }\n        \n        return abbreviations.toArray(new String[0]);\n    }\n\n    private static class TrieNode {\n        Map<Character, TrieNode> children = new HashMap<>();\n    }\n}\n```",
  "530": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + getMinimumDifference(new TreeNode(4, new TreeNode(2), new TreeNode(6, new TreeNode(1), new TreeNode(3)))));\n        System.out.println(\"Test Case 2: \" + getMinimumDifference(new TreeNode(8, new TreeNode(3), new TreeNode(10, new TreeNode(1), new TreeNode(2, new TreeNode(4), new TreeNode(9))))));\n        System.out.println(\"Test Case 3: \" + getMinimumDifference(null));\n    }\n\n    public static int getMinimumDifference(TreeNode root) {\n        if (root == null || root.left == null && root.right == null) return 0;\n        int minDiff = Integer.MAX_VALUE;\n        TreeNode prev = null;\n        inorder(root, minDiff, prev);\n        return minDiff;\n    }\n\n    public static void inorder(TreeNode node, int minDiff, TreeNode prev) {\n        if (node != null) {\n            inorder(node.left, minDiff, node);\n            if (prev != null && Math.abs(node.val - prev.val) < minDiff) minDiff = Math.abs(node.val - prev.val);\n            prev = node;\n            inorder(node.right, minDiff, prev);\n        }\n    }\n\n    public static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode(int x) { val = x; }\n        TreeNode(int x, TreeNode left, TreeNode right) {\n            this(x);\n            this.left = left;\n            this.right = right;\n        }\n    }\n}",
  "529": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] board1 = {{0, 0, 0}, {0, 3, 0}};\n        System.out.println(\"Board 1: \" + minesweeper(board1));\n        \n        int[][] board2 = {{1, 0}, {0, 2}};\n        System.out.println(\"Board 2: \" + minesweeper(board2));\n\n        int[][] board3 = {{1, 1}, {1, 2}, {1, 3}, {1, 4}};\n        System.out.println(\"Board 3: \" + minesweeper(board3));\n    }\n\n    public static String[] minesweeper(int[][] board) {\n        if (board == null || board.length == 0) return new String[0];\n        \n        int rows = board.length;\n        int cols = board[0].length;\n        String[] result = new String[rows];\n\n        for (int i = 0; i < rows; i++) {\n            StringBuilder sb = new StringBuilder();\n            for (int j = 0; j < cols; j++) {\n                if (board[i][j] == 0) {\n                    int count = dfs(board, i, j);\n                    sb.append(count).append(\" \");\n                } else {\n                    sb.append(\"X \");\n                }\n            }\n            result[i] = sb.toString();\n        }\n\n        return result;\n    }\n\n    private static int dfs(int[][] board, int i, int j) {\n        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != 0) {\n            return 0;\n        }\n        \n        int count = 0;\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                if (x == 0 && y == 0) continue;\n                int newX = i + x, newY = j + y;\n                if (newX >= 0 && newX < board.length && newY >= 0 && newY < board[0].length && board[newX][newY] == 1) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n}",
  "531": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] picture1 = {{0,0,0},{0,1,0}};\n        System.out.println(\"Result for picture1: \" + findLonelyPixels(picture1));\n\n        int[][] picture2 = {{1,1,3},{4,2,2},{8,8,1}};\n        System.out.println(\"Result for picture2: \" + findLonelyPixels(picture2));\n\n        int[][] picture3 = {{0,0,0},{2,2,1}};\n        System.out.println(\"Result for picture3: \" + findLonelyPixels(picture3));\n    }\n\n    public static int findLonelyPixels(int[][] picture) {\n        if (picture == null || picture.length == 0)\n            return 0;\n\n        int rows = picture.length;\n        int cols = picture[0].length;\n        boolean[] rowCounts = new boolean[rows];\n        boolean[] colCounts = new boolean[cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (picture[i][j] == 1) {\n                    rowCounts[i] = true;\n                    colCounts[j] = true;\n                }\n            }\n        }\n\n        int lonelyPixels = 0;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (picture[i][j] == 1 && !rowCounts[i] && !colCounts[j]) {\n                    lonelyPixels++;\n                }\n            }\n        }\n\n        return lonelyPixels;\n    }\n}",
  "532": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] pairs1 = {{3,1}, {5,2},{6,3},{8,4},{10,5}};\n        System.out.println(\"Expected: 2. Actual: \" + findPairs(pairs1, 3));\n        \n        int[][] pairs2 = {{1,3},{5,1},{5,2},{2,4},{3,5},{4,6}};\n        System.out.println(\"Expected: 4. Actual: \" + findPairs(pairs2, 1));\n\n        int[][] pairs3 = {{1,3},{5,1},{5,2},{10,2},{8,9}};\n        System.out.println(\"Expected: 0. Actual: \" + findPairs(pairs3, 2));\n    }\n\n    public static int findPairs(int[][] pairs, int k) {\n        Arrays.sort(pairs, (a,b)->(a[0]-b[0]));\n        int count = 0;\n        for(int i = 0; i < pairs.length; i++){\n            for(int j = i+1; j < pairs.length; j++){\n                if(Math.abs(pairs[i][0] - pairs[j][0]) == k){\n                    count++;\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n}\n```",
  "533": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] picture1 = {{0,0,0},{0,2,2},{2,2,2}};\n        System.out.println(\"Test case 1: \" + findLonelyPixel(picture1));\n        \n        int[][] picture2 = {{1,1,3},{1,5,2},{4,2,3}};\n        System.out.println(\"Test case 2: \" + findLonelyPixel(picture2));\n\n        int[][] picture3 = {{0,0,0},{2,1,1}};\n        System.out.println(\"Test case 3: \" + findLonelyPixel(picture3));\n    }\n\n    public static List<int[]> findLonelyPixel(int[][] picture) {\n        // your code here\n    }\n}\n```",
  "534": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(playTheGame(\"Wini\", \"Player2\", new String[][]{{\"Wini\", \"Player2\", \"1\"}, {\"Player1\", \"Wini\", \"0\"}}));\n        \n        System.out.println(playTheGame(\"Alice\", \"Bob\", new String[][]{\n                {\"Alice\", \"Bob\", \"0\"},\n                {\"Bob\", \"Alice\", \"1\"}\n        }));\n\n        System.out.println(playTheGame(\"Eve\", \"Adam\", new String[][]{}));\n    }\n\n    public static int playTheGame(String player1Name, String player2Name, String[][] scores) {\n        Map<String, Integer> map = new HashMap<>();\n        \n        for (String[] score : scores) {\n            if (!map.containsKey(score[0])) {\n                map.put(score[0], 0);\n            }\n            if (!map.containsKey(score[1])) {\n                map.put(score[1], 0);\n            }\n            map.put(score[0], map.getOrDefault(score[0], 0) + Integer.parseInt(score[2]));\n            map.put(score[1], map.getOrDefault(score[1], 0) + Integer.parseInt(score[2]));\n        }\n        \n        if (!map.containsKey(player1Name)) {\n            return -1;\n        } else if (!map.containsKey(player2Name)) {\n            return 1;\n        } else if (map.get(player1Name) > map.get(player2Name)) {\n            return 1;\n        } else if (map.get(player1Name) < map.get(player2Name)) {\n            return -1;\n        } else {\n            return 0;\n        }\n    }\n}\n```",
  "535": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String originalUrl1 = \"https://www.example.com/short\";\n        System.out.println(\"Original URL: \" + originalUrl1);\n        String tinyUrl1 = solution.shorten(originalUrl1);\n        System.out.println(\"Tiny URL: \" + tinyUrl1);\n        String decodedUrl1 = solution.decode(tinyUrl1);\n        System.out.println(\"Decoded URL: \" + decodedUrl1);\n\n        String originalUrl2 = \"https://leetcode.com/problems/all-paths-from-source-to-target\";\n        System.out.println(\"\\nOriginal URL: \" + originalUrl2);\n        String tinyUrl2 = solution.shorten(originalUrl2);\n        System.out.println(\"Tiny URL: \" + tinyUrl2);\n        String decodedUrl2 = solution.decode(tinyUrl2);\n        System.out.println(\"Decoded URL: \" + decodedUrl2);\n\n        String originalUrl3 = \"https://www.example.com/short/path\";\n        System.out.println(\"\\nOriginal URL: \" + originalUrl3);\n        String tinyUrl3 = solution.shorten(originalUrl3);\n        System.out.println(\"Tiny URL: \" + tinyUrl3);\n        String decodedUrl3 = solution.decode(tinyUrl3);\n        System.out.println(\"Decoded URL: \" + decodedUrl3);\n    }\n}\n```",
  "536": "```\npublic class Main {\n    public static void main(String[] args) {\n        String str1 = \"4(2(3),6(5))\";\n        TreeNode root1 = new Solution().str2tree(str1);\n        System.out.println(\"Root of tree 1: \" + root1.val);\n\n        String str2 = \"0(2,1,3)\";\n        TreeNode root2 = new Solution().str2tree(str2);\n        System.out.println(\"Root of tree 2: \" + root2.val);\n\n        String str3 = \"1(4,2)\";\n        TreeNode root3 = new Solution().str2tree(str3);\n        System.out.println(\"Root of tree 3: \" + root3.val);\n    }\n}\n```",
  "537": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(multiply(\"1+1i\", \"2+2i\") == new Complex(0, 4));\n        System.out.println(multiply(\"0+0i\", \"5-5i\") == new Complex(0, 0));\n        System.out.println(multiply(\"3+4i\", \"-1-2i\") == new Complex(-1, 14));\n    }\n\n    public static boolean multiply(String num1, String num2) {\n        int[] a = parseComplex(num1);\n        int[] b = parseComplex(num2);\n        return new Complex(a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]).equals(new Complex(0, 4));\n    }\n\n    public static int[] parseComplex(String s) {\n        String[] parts = s.split(\"i\");\n        return new int[]{Integer.parseInt(parts[0].replace(\"+\", \"\")), Integer.parseInt(parts[1].substring(0, parts[1].indexOf(\" \"))}};\n    }\n}\n\nclass Complex {\n    int real;\n    int imag;\n\n    public Complex(int real, int imag) {\n        this.real = real;\n        this.imag = imag;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Complex)) return false;\n        Complex complex = (Complex) o;\n        return real == complex.real && imag == complex.imag;\n    }\n}\n```",
  "538": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(7);\n        root1.left.left = new TreeNode(3);\n        root1.right.left = new TreeNode(6);\n        root1.right.right = new TreeNode(8);\n\n        greaterTree(root1);\n\n        System.out.println();\n\n        TreeNode root2 = new TreeNode(4);\n        root2.left = new TreeNode(1);\n        root2.right = new TreeNode(6);\n        root2.left.left = new TreeNode(0);\n        root2.left.right = new TreeNode(2);\n        root2.right.left = new TreeNode(5);\n        root2.right.right = new TreeNode(7);\n\n        greaterTree(root2);\n\n        System.out.println();\n\n        TreeNode root3 = null;\n\n        greaterTree(root3);\n    }\n\n    public static void greaterTree(TreeNode root) {\n        if (root == null) return;\n        inOrder(root);\n    }\n\n    private static void inOrder(TreeNode node) {\n        if (node == null) return;\n        inOrder(node.right);\n        node.val += sum(node.left);\n        inOrder(node.left);\n    }\n\n    private static int sum(TreeNode node) {\n        if (node == null) return 0;\n        return node.val + sum(node.left) + sum(node.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n```",
  "540": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \");\n        int[] nums = {1};\n        int result = singleElement(nums);\n        if (result == 1) {\n            System.out.println(\"Pass\");\n        } else {\n            System.out.println(\"Fail\");\n        }\n\n        System.out.println(\"\\nTest Case 2: \");\n        int[] nums2 = {1, 2};\n        int result2 = singleElement(nums2);\n        if (result2 == -1) {\n            System.out.println(\"Pass\");\n        } else {\n            System.out.println(\"Fail\");\n        }\n\n        System.out.println(\"\\nTest Case 3: \");\n        int[] nums3 = {1, 2, 3, 4};\n        int result3 = singleElement(nums3);\n        if (result3 == -1) {\n            System.out.println(\"Pass\");\n        } else {\n            System.out.println(\"Fail\");\n        }\n    }\n\n    public static int singleElement(int[] nums) {\n        int start = 0;\n        int end = nums.length - 1;\n\n        while (start < end) {\n            int mid = start + (end - start) / 2;\n\n            if ((mid % 2 == 1 && nums[mid] > nums[mid - 1])) {\n                end = mid;\n            } else if ((mid % 2 == 0 && nums[mid] < nums[mid + 1])) {\n                start = mid + 1;\n            } else if (mid % 2 == 1) {\n                end = mid;\n            } else {\n                start = mid + 1;\n            }\n        }\n\n        return nums[start];\n    }\n}\n```",
  "539": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] timePoints1 = {\"02:15\", \"08:00\"};\n        System.out.println(\"Test case 1: \" + minTimeDifference(timePoints1));\n        \n        int[] timePoints2 = {\"05:41\", \"04:12\", \"06:58\", \"06:25\", \"07:14\"};\n        System.out.println(\"Test case 2: \" + minTimeDifference(timePoints2));\n        \n        int[] timePoints3 = {\"23:59\", \"00:01\"};\n        System.out.println(\"Test case 3: \" + minTimeDifference(timePoints3));\n    }\n\n    public static int minTimeDifference(int[][] watchTimes) {\n        String[] times = new String[watchTimes.length];\n        for (int i = 0; i < watchTimes.length; i++) {\n            times[i] = watchTimes[i][0].substring(0, 5);\n        }\n        \n        Arrays.sort(times);\n        \n        int minTimeDiff = Integer.MAX_VALUE;\n        for (int i = 0; i < times.length - 1; i++) {\n            String time1 = times[i];\n            String time2 = times[i + 1];\n            \n            if (Integer.parseInt(time1.substring(0, 2)) * 60 + Integer.parseInt(time1.substring(3, 5)) > \n                Integer.parseInt(time2.substring(0, 2)) * 60 + Integer.parseInt(time2.substring(3, 5))) {\n                time1 = times[i + 1];\n                time2 = times[0];\n            }\n            \n            minTimeDiff = Math.min(minTimeDiff, (Integer.parseInt(time2.substring(0, 2)) * 60 + \n                Integer.parseInt(time2.substring(3, 5))) - (Integer.parseInt(time1.substring(0, 2)) * 60 + \n                Integer.parseInt(time1.substring(3, 5))));\n        }\n        \n        return minTimeDiff;\n    }\n}",
  "541": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reverseStr(\"HelloWorld\", 2));\n        System.out.println(reverseStr(\"abcdefg\", 1));\n        System.out.println(reverseStr(\"ab\", 0));\n    }\n\n    public static String reverseStr(String s, int k) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (i % (2 * k) >= k || (s.length() - i) % (2 * k) < k) {\n                sb.append(s.charAt(i));\n            } else {\n                sb.insert(0, s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}",
  "542": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrix1 = {{0,1},{2,3}};\n        System.out.println(\"Matrix 1: \");\n        solve01Matrix(matrix1);\n        \n        int[][] matrix2 = {{0,1,2},{4,5,6},{7,8,9}};\n        System.out.println(\"\\nMatrix 2: \");\n        solve01Matrix(matrix2);\n\n        int[][] matrix3 = {{1,0,1},{0,0,0},{1,1,1}};\n        System.out.println(\"\\nMatrix 3: \");\n        solve01Matrix(matrix3);\n    }\n\n    public static void solve01Matrix(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) return;\n        \n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if (i == 0 || j == 0 || i == matrix.length - 1 || j == matrix[0].length - 1) {\n                    System.out.print(matrix[i][j] + \" \");\n                } else {\n                    System.out.print(0 + \" \");\n                }\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "543": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode node1 = new TreeNode(1);\n        node1.left = new TreeNode(3);\n        node1.right = new TreeNode(4);\n        node1.left.left = new TreeNode(5);\n        node1.left.right = new TreeNode(6);\n\n        System.out.println(\"Diameter of the binary tree is \" + diameterOfBinaryTree(node1));\n\n        TreeNode node2 = new TreeNode(0);\n        System.out.println(\"Diameter of the binary tree is \" + diameterOfBinaryTree(node2));\n\n        TreeNode node3 = null;\n        System.out.println(\"Diameter of the binary tree is \" + diameterOfBinaryTree(node3));\n    }\n\n    public static int diameterOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n\n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n\n        int maxLeft = diameter(root.left);\n        int maxRight = diameter(root.right);\n\n        return Math.max(leftHeight + rightHeight, Math.max(maxLeft, maxRight));\n    }\n\n    public static int height(TreeNode node) {\n        if (node == null)\n            return 0;\n\n        return 1 + Math.max(height(node.left), height(node.right));\n    }\n\n    public static int diameter(TreeNode node) {\n        if (node == null)\n            return 0;\n\n        int left = height(node.left);\n        int right = height(node.right);\n\n        if (left > right)\n            return 1 + left;\n        else\n            return 1 + right;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "544": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(waysToMatch(\"LeetCode\", \"BattleTests\")); // Expected output: [[1,2],[2,3]]\n        System.out.println(waysToMatch(\"Kitten\", \"CodingWithKittens\")); // Expected output: [[1,2],[5,6]]\n        System.out.println(waysToMatch(\"Xiao\", \"Yi\")); // Expected output: []\n    }\n\n    public static List<List<Integer>> waysToMatch(String beginWord, String endWord, List<String> wordList) {\n        // Your code here\n    }\n}\n```",
  "545": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(2);\n        root1.left.left = new TreeNode(3);\n\n        boundaryOfBinaryTree(root1);\n\n        System.out.println();\n\n        TreeNode root2 = new TreeNode(1);\n        root2.right = new TreeNode(4);\n        root2.right.left = new TreeNode(5);\n        root2.right.right = new TreeNode(6);\n\n        boundaryOfBinaryTree(root2);\n\n        System.out.println();\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n\n        boundaryOfBinaryTree(root3);\n    }\n\n    public static void boundaryOfBinaryTree(TreeNode root) {\n        // write your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "546": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] boxes1 = {{1,4,10},{2,6,7},{3,8,9}};\n        System.out.println(\"Result for \" + Arrays.deepToString(boxes1) + \": \" + removeBoxes(boxes1));\n        \n        int[][] boxes2 = {{2,5,3},{4,2,10}, {5, 5, 11}};\n        System.out.println(\"Result for \" + Arrays.deepToString(boxes2) + \": \" + removeBoxes(boxes2));\n        \n        int[][] boxes3 = {};\n        System.out.println(\"Result for \" + Arrays.deepToString(boxes3) + \": \" + removeBoxes(boxes3));\n    }\n\n    public static int removeBoxes(int[][] boxes) {\n        // your code here\n    }\n}\n```",
  "547": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{1,1,0},{1,1,1},{0,1,1}};\n        System.out.println(\"Number of provinces for grid1: \" + findCircleNum(grid1));\n        \n        int[][] grid2 = {{1,1,0,1},{1,1,6,1},{0,1,1,7},{1,1,8,1}};\n        System.out.println(\"Number of provinces for grid2: \" + findCircleNum(grid2));\n        \n        int[][] grid3 = {{1,1},{1,1}};\n        System.out.println(\"Number of provinces for grid3: \" + findCircleNum(grid3));\n    }\n\n    public static int findCircleNum(int[][] M) {\n        if (M == null || M.length == 0) return 0;\n        \n        int n = M.length;\n        boolean[] visited = new boolean[n];\n        \n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(M, i, visited);\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static void dfs(int[][] M, int i, boolean[] visited) {\n        int n = M.length;\n        for (int j = 0; j < n; j++) {\n            if (M[i][j] == 1 && !visited[j]) {\n                visited[j] = true;\n                dfs(M, j, visited);\n            }\n        }\n    }\n}",
  "548": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canSplitArray(new int[]{10,4,-2,7,17,-7,18,-5,1,9})); // true\n        System.out.println(canSplitArray(new int[]{3,-1,0,1,2,-2})) ;// false\n        System.out.println(canSplitArray(new int[]{-5,0,-5,0,0})) ;// true\n    }\n\n    public static boolean canSplitArray(int[] nums) {\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n        if(totalSum %2 != 0){\n            return false;\n        }\n        int targetSum = totalSum /2 ;\n        Map<Integer, Integer> prefixSumMap = new HashMap<>();\n        prefixSumMap.put(0, -1);\n        int currentSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            currentSum += nums[i];\n            if(prefixSumMap.containsKey(currentSum-targetSum)){\n                return true;\n            }\n            prefixSumMap.put(currentSum, i);\n        }\n        return false;\n    }\n}",
  "550": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] logs = {\n                {1, \"female\", \"red\"},\n                {2, \"male\", \"blue\"},\n                {3, \"female\", \"blue\"}\n        };\n\n        System.out.println(calculateScore(logs));\n    }\n\n    public static int calculateScore(int[][] logs) {\n        Map<String, Integer> userMap = new HashMap<>();\n        Map<String, Integer> colorMap = new HashMap<>();\n\n        for (int[] log : logs) {\n            String userId = String.valueOf(log[0]);\n            String gender = log[1];\n            String color = log[2];\n\n            if (!userMap.containsKey(userId)) {\n                userMap.put(userId, 0);\n            }\n            if (!colorMap.containsKey(color)) {\n                colorMap.put(color, 0);\n            }\n\n            int score = (gender.equals(\"male\") ? 1 : -1) + (color.equals(\"blue\") ? 1 : -1);\n            userMap.put(userId, userMap.getOrDefault(userId, 0) + score);\n            colorMap.put(color, colorMap.getOrDefault(color, 0) + score);\n\n        }\n\n        int overallScore = 0;\n        for (int userScore : userMap.values()) {\n            overallScore += userScore;\n        }\n        for (int colorScore : colorMap.values()) {\n            overallScore += colorScore;\n        }\n\n        return overallScore;\n    }\n}\n```",
  "549": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(0);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(2);\n        System.out.println(longestConsecutive(root1));  // Output: 4\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(4);\n        System.out.println(longestConsecutive(root2));  // Output: 2\n\n        TreeNode root3 = new TreeNode(8);\n        root3.left = new TreeNode(7);\n        root3.right = new TreeNode(9);\n        root3.left.left = new TreeNode(1);\n        root3.left.right = new TreeNode(6);\n        System.out.println(longestConsecutive(root3));  // Output: 2\n    }\n\n    public static int longestConsecutive(TreeNode root) {\n        if (root == null) return 0;\n        Map<Integer, Integer> nodeToIndex = new HashMap<>();\n        List<TreeNode> nodes = new ArrayList<>();\n        dfs(root, nodeToIndex, nodes);\n        int maxLength = 0;\n        for (int i = 0; i < nodes.size(); i++) {\n            if (!nodeToIndex.containsKey(nodes.get(i).val)) continue;\n            int start = nodeToIndex.get(nodes.get(i).val);\n            int end = start + 1;\n            while (end < nodes.size() && nodes.get(end) != null\n                    && nodes.get(start).val == nodes.get(end).val - 1) {\n                end++;\n            }\n            maxLength = Math.max(maxLength, end - start);\n        }\n        return maxLength;\n    }\n\n    private static void dfs(TreeNode node, Map<Integer, Integer> nodeToIndex, List<TreeNode> nodes) {\n        if (node == null) return;\n        nodes.add(node);\n        nodeToIndex.put(node.val, nodes.size() - 1);\n        dfs(node.left, nodeToIndex, nodes);\n        dfs(node.right, nodeToIndex, nodes);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "551": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numStudentsUnableToParticipate(\"PPALLL\")); // Expected: 1\n        System.out.println(numStudentsUnableToParticipate(\"MAPS\")); // Expected: 1\n        System.out.println(numStudentsUnableToParticipate(\"NNX\")); // Expected: 3\n    }\n\n    public static int numStudentsUnableToParticipate(String attendance) {\n        int count = 0;\n        for (int i = 0; i < attendance.length(); i++) {\n            if (attendance.charAt(i) == 'A') {\n                if (i > 0 && attendance.charAt(i - 1) == 'P' || i < attendance.length() - 1 && attendance.charAt(i + 1) == 'P') {\n                    count++;\n                }\n            } else if (attendance.charAt(i) != 'P') {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
  "552": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] attendances1 = {0,0};\n        System.out.println(nthDistinct(\"PUPUP\")); // Expected: 2\n        System.out.println(nthDistinct(\"RRRP\"));// Expected: 1\n        System.out.println(nthDistinct(attendances1)); // Expected: 3\n    }\n\n    public static int nthDistinct(String s) {\n        String[] arr = s.split(\"\");\n        Map<String, Integer> map = new HashMap<>();\n        for (String str : arr) {\n            if (!map.containsKey(str)) {\n                map.put(str, 0);\n            } else {\n                map.put(str, map.get(str) + 1);\n            }\n        }\n\n        int distinctCount = 0;\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            if (entry.getValue() == 1) {\n                distinctCount++;\n            }\n            if (distinctCount == 3) {\n                return arr.length - map.size();\n            }\n        }\n        return -1;\n    }\n}\n```",
  "553": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {9};\n        System.out.println(\"Optimal result for \" + Arrays.toString(nums1) + \": \" + optimalDivision(nums1));\n        \n        int[] nums2 = {4, 13, 5, 11};\n        System.out.println(\"Optimal result for \" + Arrays.toString(nums2) + \": \" + optimalDivision(nums2));\n        \n        int[] nums3 = {7, 8};\n        System.out.println(\"Optimal result for \" + Arrays.toString(nums3) + \": \" + optimalDivision(nums3));\n    }\n\n    public static double optimalDivision(int[] nums) {\n        if (nums.length == 1) {\n            return 1.0;\n        }\n        \n        int n = nums.length;\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n - 1; i++) {\n            sb.append(nums[i]).append(\"/\");\n        }\n        sb.append(nums[n - 1]);\n        \n        try {\n            return eval(sb.toString());\n        } catch (Exception e) {\n            // This will not happen in the actual test cases.\n            // If you need to handle it, you can add more code here.\n            return 1.0;\n        }\n    }\n\n    private static double eval(String s) throws Exception {\n        Object value = new Object();\n        Class<?> type = Double.class;\n        try {\n            type = Class.forName(s.substring(s.indexOf('/') + 1));\n        } catch (Exception ignore) {}\n        \n        if (\"m\".equals(s.charAt(0))) {\n            java.lang.Math math = Math.class;\n            return Math.class.getMethod(s.substring(4)).invoke(null, value).doubleValue();\n        }\n        \n        if (type.equals(Integer.class)) {\n            return Double.parseDouble(Executions.createExecutor().execute(new SimpleExpression()).getValue().toString());\n        } else if (type.equals(Double.class)) {\n            return new Function().evaluate(value).getValue().doubleValue();\n        }\n        throw new Exception(\"Invalid operation\");\n    }\n}\n```",
  "554": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] wall1 = {{1,2,2,1},{3,1,2},{1,4}};\n        System.out.println(\"Expected: 5, Actual: \" + minimumPerimeter(wall1));\n        \n        int[][] wall2 = {{7,6,8},{1,2,10},{9,10}};\n        System.out.println(\"Expected: 15, Actual: \" + minimumPerimeter(wall2));\n        \n        int[][] wall3 = {{5,4},{6,7}};\n        System.out.println(\"Expected: 11, Actual: \" + minimumPerformer(wall3));\n    }\n\n    public static int minimumPerimeter(int[][] wall) {\n        // Your code here\n        // Example solution:\n        int minPerimeter = Integer.MAX_VALUE;\n        for (int i = 0; i < wall.length; i++) {\n            int perimeter = 2 * (wall[0].length + wall[i].length);\n            for (int j = 0; j < wall[i].length; j++) {\n                if (wall[i][j] == 1) {\n                    perimeter -= 2;\n                }\n            }\n            minPerimeter = Math.min(minPerimeter, perimeter);\n        }\n        return minPerimeter;\n    }\n}",
  "555": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(splitStrings(\"aa bb cc dd aa bb\")); // expected output: [\"aa bb\", \"cc dd\", \"aa bb\"]\n        System.out.println(splitStrings(\"abcd\")); // expected output: [\"abcd\"]\n        System.out.println(splitStrings(\"a 001 b 002 c 003 d 004 e 005 f g h 006\")); // expected output: [\"a 001 b 002\", \"c 003 d 004\", \"e 005 f g\", \"h 006\"]\n    }\n\n    public static List<String> splitStrings(String s) {\n        List<String> result = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                sb.append(c);\n            } else if (sb.length() > 0) {\n                result.add(sb.toString());\n                sb.setLength(0);\n                sb.append(c);\n            }\n        }\n        if (sb.length() > 0) {\n            result.add(sb.toString());\n        }\n        return result;\n    }\n}",
  "556": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(nextGreaterElement(\"55656\") + \" should be 56765\");\n        System.out.println(nextGreaterElement(\"6666\") + \" should be 66766\");\n        System.out.println(nextGreaterElement(\"5555\") + \" should be 66666\");\n    }\n\n    public static String nextGreaterElement(String n) {\n        char[] chars = n.toCharArray();\n        int i = chars.length - 1;\n        while (i > 0 && chars[i] <= chars[i - 1]) {\n            i--;\n        }\n        if (i == 0) return \"-1\";\n        int j = chars.length - 1;\n        while (j > i && chars[j] <= chars[i - 1]) {\n            j--;\n        }\n        swap(chars, i, j);\n        reverse(chars, i + 1);\n        return new String(chars);\n    }\n\n    private static void swap(char[] chars, int i, int j) {\n        char temp = chars[i];\n        chars[i] = chars[j];\n        chars[j] = temp;\n    }\n\n    private static void reverse(char[] chars, int start) {\n        int end = chars.length - 1;\n        while (start < end) {\n            swap(chars, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n```",
  "557": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reverseWords(\"Hello world\")); // expected output: \"world Hello\"\n        System.out.println(reverseWords(\"a b c d e\")); // expected output: \"e d c b a\"\n        System.out.println(reverseWords(\"abc def ghi jkl\")); // expected output: \"jkl ihi fend cab\"\n    }\n\n    public static String reverseWords(String s) {\n        String[] words = s.split(\" \");\n        StringBuilder sb = new StringBuilder();\n        for (String word : words) {\n            sb.append(new StringBuilder(word).reverse().toString()).append(\" \");\n        }\n        return sb.toString().trim();\n    }\n}",
  "559": "```\nimport java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node(int _val) {\n        val = _val;\n        children = new ArrayList<>();\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        test(\"1,null,3,5,6,null,2,4,null,null,7,8\");\n        test(\"1\");\n        test(null);\n    }\n\n    public static int maxDepth(Node root) {\n        if (root == null) return 0;\n        int max = 0;\n        for (Node child : root.children) {\n            int depth = maxDepth(child) + 1;\n            if (depth > max) max = depth;\n        }\n        return max;\n    }\n\n    public static void test(String naryTree) {\n        Node root = null;\n        if (naryTree != null) {\n            String[] nodes = naryTree.split(\",\");\n            Node current = new Node(Integer.parseInt(nodes[0]));\n            root = current;\n            for (int i = 1; i < nodes.length; i++) {\n                Node child = new Node(Integer.parseInt(nodes[i]));\n                if (i % 2 == 1) {\n                    current.children.add(child);\n                    current = child;\n                } else {\n                    while (current.parent != null) {\n                        current = current.parent;\n                    }\n                    current = child;\n                }\n            }\n        }\n        System.out.println(\"Maximum Depth: \" + maxDepth(root));\n    }\n}",
  "558": "```\npublic class Solution {\n    public boolean findNodes(Node root1, Node root2) {\n        if (root1.val == root2.val) {\n            return true;\n        } else if (root1.val || root2.val) {\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        Node node11 = new Node(0);\n        Node node12 = new Node(0);\n        Node node13 = new Node(1);\n        Node node14 = new Node(0);\n\n        Node node21 = new Node(1);\n        Node node22 = new Node(1);\n        Node node23 = new Node(0);\n        Node node24 = new Node(1);\n\n        Node root1 = new Node(0, node11, node12, node13, node14);\n        Node root2 = new Node(1, node21, node22, node23, node24);\n\n        boolean result1 = solution.findNodes(root1, root2);\n        System.out.println(\"Test Case 1: \" + (result1 ? \"Pass\" : \"Fail\"));\n\n        Node node31 = new Node(0);\n        Node node32 = new Node(0);\n        Node node33 = new Node(1);\n        Node node34 = new Node(0);\n\n        Node node41 = new Node(0);\n        Node node42 = new Node(0);\n        Node node43 = new Node(1);\n        Node node44 = new Node(1);\n\n        Node root3 = new Node(1, node31, node32, node33, node34);\n        Node root4 = new Node(1, node41, node42, node43, node44);\n\n        boolean result2 = solution.findNodes(root3, root4);\n        System.out.println(\"Test Case 2: \" + (result2 ? \"Pass\" : \"Fail\"));\n\n        Node node51 = new Node(0);\n        Node node52 = new Node(1);\n        Node node53 = new Node(0);\n        Node node54 = new Node(0);\n\n        Node node61 = new Node(1);\n        Node node62 = new Node(0);\n        Node node63 = new Node(1);\n        Node node64 = new Node(1);\n\n        Node root5 = new Node(1, node51, node52, node53, node54);\n        Node root6 = new Node(0, node61, node62, node63, node64);\n\n        boolean result3 = solution.findNodes(root5, root6);\n        System.out.println(\"Test Case 3: \" + (result3 ? \"Pass\" : \"Fail\"));\n    }\n}\n\nclass Node {\n    int val;\n    Node tl, tr, bl, br;\n\n    public Node(int v) {\n        val = v;\n        tl = null;\n        tr = null;\n        bl = null;\n        br = null;\n    }\n\n    public Node(int v, Node tl, Node tr, Node bl, Node br) {\n        val = v;\n        this.tl = tl;\n        this.tr = tr;\n        this.bl = bl;\n        this.br = br;\n    }\n}\n```",
  "560": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1};\n        System.out.println(subarraySum(nums1, 0));\n        \n        int[] nums2 = [4,5,6];\n        System.out.println(subarraySum([4,5,6], 7));\n        \n        int[] nums3 = [23, 2, 4, -9];\n        System.out.println(subarraySum([23, 2, 4, -9], 10));\n    }\n\n    public static int subarraySum(int[] nums, int k) {\n        int sum = 0;\n        int count = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int num : nums) {\n            sum += num;\n\n            if (sum == k) {\n                count++;\n            }\n\n            if (map.containsKey(sum - k)) {\n                count += map.get(sum - k);\n            }\n\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\n        }\n\n        return count;\n    }\n}\n```",
  "561": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1,4,3,2};\n        System.out.println(\"Expected: 4, Actual: \" + arrayPairSum(nums1));\n        \n        int[] nums2 = {3,2,5,1,2,5};\n        System.out.println(\"Expected: 9, Actual: \" + arrayPairSum(nums2));\n        \n        int[] nums3 = {3,3,3,3};\n        System.out.println(\"Expected: 6, Actual: \" + arrayPairSum(nums3));\n    }\n    \n    public static int arrayPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int sum = 0;\n        for (int i = 0; i < nums.length; i += 2) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n}",
  "563": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(10);\n        root1.right = new TreeNode(5);\n\n        System.out.println(\"Test Case 1: \" + findTilt(root1));\n        \n        TreeNode root2 = new TreeNode(4);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(7);\n        root2.left.left = new TreeNode(3);\n        root2.left.right = new TreeNode(5);\n\n        System.out.println(\"Test Case 2: \" + findTilt(root2));\n        \n        TreeNode root3 = null;\n\n        System.out.println(\"Test Case 3: \" + findTilt(root3));\n    }\n\n    public static int findTilt(TreeNode root) {\n        // your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode leftchild;\n    TreeNode right;\n    TreeRightNode child;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "562": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrix1 = {{0,1,0,0},{0,0,1,1},{0,0,1,0}};\n        System.out.println(longestLine(matrix1));\n        \n        int[][] matrix2 = {{1,0,1,1},{1,0,1,0},{0,0,1,0}};\n        System.out.println(longestLine(matrix2));\n\n        int[][] matrix3 = {{1,1,1,1},{1,1,1,1},{1,1,1,1}};\n        System.out.println(longestLine(matrix3));\n    }\n\n    public static int longestLine(int[][] A) {\n        if(A == null || A.length == 0) return 0;\n        int m = A.length;\n        int n = A[0].length;\n        boolean[][] horizontal = new boolean[m][n];\n        boolean[][] vertical = new boolean[m][n];\n        boolean[][] diagonal1 = new boolean[m][n];\n        boolean[][] diagonal2 = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(A[i][j] == 1) {\n                    horizontal[i][j] = true;\n                    vertical[i][j] = true;\n                    diagonal1[i][j] = true;\n                    diagonal2[i][j] = true;\n                }\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if(A[i][j] == 1) {\n                    res = Math.max(res, longestLine(i, j, horizontal, vertical, diagonal1, diagonal2));\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public static int longestLine(int i, int j, boolean[][] horizontal, boolean[][] vertical, boolean[][] diagonal1, boolean[][] diagonal2) {\n        int res = 0;\n        if(i > 0 && j > 0 && A[i-1][j-1] == 1) {\n            res = Math.max(res, 1 + longestLine(i - 1, j - 1, horizontal, vertical, diagonal1, diagonal2));\n        }\n        if(i > 0 && A[i-1][j] == 1) {\n            res = Math.max(res, 1 + (horizontal[i-1][j]) ? longestLine(i - 1, j, horizontal, vertical, diagonal1, diagonal2) : 0);\n        }\n        if(j > 0 && A[i][j-1] == 1) {\n            res = Math.max(res, 1 + (vertical[i][j-1]) ? longestLine(i, j - 1, horizontal, vertical, diagonal1, diagonal2) : 0);\n        }\n        if(A[i][j] == 1) {\n            res = Math.max(res, 1 + ((diagonal1[i][j]) || (diagonal2[i][j])) ? longestLine(i, j, horizontal, vertical, diagonal1, diagonal2) : 0);\n        }\n\n        return res;\n    }\n}\n```",
  "564": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(closetPalindrome(\"aabb\")); // Expected: \"abba\"\n        System.out.println(closetPalindrome(\"aba\")); // Expected: \"aba\"\n        System.out.println(closetPalindrome(\"abc\")); // Expected: \"abc\"\n    }\n\n    public static String closetPalindrome(String s) {\n        for (int len = s.length(); len > 0; len--) {\n            for (int i = 0; i <= s.length() - len; i++) {\n                String str = s.substring(i, i + len);\n                if (isPalindrome(str)) {\n                    return str;\n                }\n            }\n        }\n        return \"\";\n    }\n\n    public static boolean isPalindrome(String str) {\n        int left = 0, right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n```",
  "565": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(arrayNesting(new int[]{4,2,3})); // Expected output: 8\n        System.out.println(arrayNesting(new int[]{8,3,2,6,2,7})); // Expected output: 1\n        System.out.println(arrayNesting(new int[]{0,2,10,6,20})); // Expected output: 5\n    }\n\n    public static int arrayNesting(int[] nums) {\n        int max = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int start = i;\n            while (nums[start] != start) {\n                start = nums[start];\n            }\n            max = Math.max(max, start + 1);\n        }\n        return max;\n    }\n}",
  "566": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{1,2},{3,4}};\n        int[][] expected1 = {{1,3},{2,4}};\n        reshape(arr1, 4);\n        \n        int[][] arr2 = {{1,2}, {3,5,7}};\n        int[][] expected2 = {{1,2,3},{5,7}};\n        reshape(arr2, 2);\n        \n        int[][] arr3 = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};\n        int[][] expected3 = {{1,5,9},{2,6,10},{3,7,11},{4,8,12}};\n        reshape(arr3, 4);\n    }\n\n    public static void reshape(int[][] mat, int n) {\n        if (mat.length * mat[0].length != n) return;\n        int newRow = (int) Math.sqrt(n);\n        if (newRow * newRow != n) return;\n\n        int[][] result = new int[newRow][newRow];\n        for (int i = 0; i < mat.length; i++) {\n            for (int j = 0; j < mat[0].length; j++) {\n                result[i % newRow][j] = mat[i][j];\n            }\n        }\n        for (int[] row : result) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
  "567": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(checkInclusion(\"ab\", \"ad\")); // true\n        System.out.println(checkInclusion(\"aa\", \"aaa\")); // false\n        System.out.println(checkInclusion(\"engineer\", \"geeky\")); // true\n    }\n\n    public static boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) return false;\n        \n        int[] count = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            count[s1.charAt(i) - 'a']++;\n            count[s2.charAt(i) - 'a']--;\n        }\n        \n        for (int i = s1.length(); i < s2.length(); i++) {\n            if (isInclusion(count)) return true;\n            count[s2.charAt(i) - 'a']--;\n            count[s2.charAt(i - s1.length()) - 'a']++;\n        }\n        \n        return isInclusion(count);\n    }\n\n    public static boolean isInclusion(int[] count) {\n        for (int i = 0; i < 26; i++) {\n            if (count[i] != 0) return false;\n        }\n        return true;\n    }\n}\n```",
  "568": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] flights = {{2,1,1},{4,5,20},{1,3,10}};\n        System.out.println(\"Maximum Vacation Days: \" + maxVacationDays(flights));\n        \n        int[][] flights2 = {{1,2,1},{3,3,2}};\n        System.out.println(\"Maximum Vacation Days: \" + maxVacationDays(flights2));\n        \n        int[][] flights3 = {{5,4,0},{4,5,10},{1,3,20}};\n        System.out.println(\"Maximum Vacation Days: \" + maxVacationDays(flights3));\n    }\n\n    public static int maxVacationDays(int[][] flights) {\n        if (flights.length == 0 || flights[0].length < 2) return 0;\n        \n        int n = flights.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = flights[0][1];\n        \n        for (int i = 1; i < n; i++) {\n            int maxDays = Integer.MIN_VALUE;\n            for (int j = 0; j <= i; j++) {\n                if (j == 0) continue;\n                maxDays = Math.max(maxDays, dp[j - 1] + flights[i][2]);\n            }\n            dp[i] = Math.max(dp[i - 1], maxDays);\n        }\n        \n        return dp[n - 1];\n    }\n}",
  "569": "```\npublic class Solution {\n    public double[] medianSalary(int[][] salary_info) {\n        // Your logic here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] salaryInfo1 = {{100, 200}, {300, 400}};\n        System.out.println(\"Test Case 1:\");\n        double[] result1 = solution.medianSalary(salaryInfo1);\n        for (double r : result1) {\n            System.out.print(r + \" \");\n        }\n        System.out.println();\n\n        int[][] salaryInfo2 = {{1000, 2000}, {3000, 4000}};\n        System.out.println(\"Test Case 2:\");\n        double[] result2 = solution.medianSalary(salaryInfo2);\n        for (double r : result2) {\n            System.out.print(r + \" \");\n        }\n        System.out.println();\n\n        int[][] salaryInfo3 = {{100, 200}, {300, 400}, {500, 600}};\n        System.out.println(\"Test Case 3:\");\n        double[] result3 = solution.medianSalary(salaryInfo3);\n        for (double r : result3) {\n            System.out.print(r + \" \");\n        }\n        System.out.println();\n    }\n}",
  "571": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2};\n        System.out.println(findMedian(nums1)); // expected output: 2.0\n\n        int[] nums2 = {0,1};\n        System.out.println(findMedian(nums2)); // expected output: 0.5\n\n        int[] nums3 = {1, 3};\n        System.out.println(findMedian(nums3)); // expected output: 1.0\n    }\n\n    public static double findMedian(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        if (n % 2 == 0) {\n            return ((double)nums[n/2 - 1] + nums[n/2]) / 2;\n        } else {\n            return (double)nums[n/2];\n        }\n    }\n}\n```",
  "570": "```\npublic class Solution {\n    public List<Integer> getManagers(int[][] employees) {\n        Map<Integer, Integer> employeeManagerMap = new HashMap<>();\n        for (int[] employee : employees) {\n            employeeManagerMap.put(employee[0], employee[1]);\n        }\n        List<Integer> result = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : employeeManagerMap.entrySet()) {\n            if (entry.getValue() < 10000 && getDirectReports(employeeManagerMap, entry.getKey()).size() >= 5) {\n                result.add(entry.getKey());\n            }\n        }\n        return result;\n    }\n\n    public List<Integer> getDirectReports(Map<Integer, Integer> employeeManagerMap, int managerId) {\n        List<Integer> directReports = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : employeeManagerMap.entrySet()) {\n            if (entry.getValue() == managerId) {\n                directReports.add(entry.getKey());\n            }\n        }\n        return directReports;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] employees1 = {{1, 2}, {2, 3}};\n        System.out.println(solution.getManagers(employees1)); // [1]\n\n        int[][] employees2 = {{50, 1}, {100, 2}, {40, 50}, {20, 40}, {10, 30}, {60, 1}, {70, 6}, {80, 7}};\n        System.out.println(solution.getManagers(employees2)); // [50]\n\n        int[][] employees3 = {{1, 1000}, {5, 1}, {4, 5}, {2, 3}, {3, 2}};\n        System.out.println(solution.getManagers(employees3)); // []\n    }\n}",
  "573": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new SquirrelSimulation().nuts(5, new int[]{1, 2, 3, 4, 5})); // Test case 1\n        System.out.println(new SquirrelSimulation().nuts(7, new int[]{10, 6, 8, 4})); // Test case 2\n        System.out.println(new SquirrelSimulation().nuts(9, new int[]{3, 2, 5, 8, 12, 20, 15})); // Test case 3\n    }\n}\n\nclass SquirrelSimulation {\n    public int nuts(int n, int[] trees) {\n        Arrays.sort(trees);\n        long sum = 0;\n        for (int i = 1; i < trees.length; i++) {\n            sum += Math.max(0, trees[i] - trees[i - 1]);\n        }\n        return (int) ((sum / n) + (n * 2));\n    }\n}\n```",
  "572": "```\nclass Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if (root == null) return false;\n        if (isIdentical(root, subRoot)) return true;\n        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n    }\n\n    private boolean isIdentical(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        return p.val == q.val && isIdentical(p.left, q.left) && isIdentical(p.right, q.right);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(4);\n        root1.right = new TreeNode(5);\n        root1.left.left = new TreeNode(1);\n        root1.left.right = new TreeNode(2);\n        boolean result1 = solution.isSubtree(root1, new TreeNode(4));\n        System.out.println(result1); // Expected output: true\n        \n        // Test case 2\n        TreeNode root2 = new TreeNode(3);\n        root2.left = new TreeNode(4);\n        root2.right = new TreeNode(5);\n        root2.left.left = new TreeNode(1);\n        root2.left.right = new TreeNode(2);\n        boolean result2 = solution.isSubtree(root2, new TreeNode(6));\n        System.out.println(result2); // Expected output: false\n        \n        // Test case 3\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n        root3.right = new TreeNode(3);\n        boolean result3 = solution.isSubtree(root3, new TreeNode(2));\n        System.out.println(result3); // Expected output: true\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}",
  "574": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findWinner(\"Alice,Bob,Carmen\", \"Alice:10,Alice:5,Alice:7,Bob:15,Bob:6,Carmen:12,Carmen:9\"));\n        System.out.println(findWinner(\"John,Anna,Jane\", \"John:1,Anna:2,Jane:4,John:3,Anna:5,Jane:8,John:0,Anna:1\"));\n        System.out.println(findWinner(\"\", \"\"));\n    }\n\n    public static String findWinner(String candidates, String votes) {\n        if (candidates.isEmpty() || votes.isEmpty()) return \"\";\n\n        String[] candidateArray = candidates.split(\",\");\n        Map<String, Integer> voteMap = new HashMap<>();\n\n        for (String[] vote : votes.split(\",\")) {\n            String candidate = vote[0];\n            int count = Integer.parseInt(vote[2]);\n            voteMap.put(candidate, voteMap.getOrDefault(candidate, 0) + count);\n        }\n\n        Map.Entry<String, Integer> maxEntry = null;\n        for (Map.Entry<String, Integer> entry : voteMap.entrySet()) {\n            if (maxEntry == null || entry.getValue().compareTo(maxEntry.getValue()) > 0)\n                maxEntry = entry;\n        }\n        return maxEntry.getKey();\n    }\n}\n```",
  "575": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2,2,1,1,1,2};\n        System.out.println(\"Test Case 1: \" + new Solution().distributeCandies(nums1));\n        \n        int[] nums2 = {4,3,2,2,3,4,2};\n        System.out.println(\"Test Case 2: \" + new Solution().distributeCandies(nums2));\n\n        int[] nums3 = {6,9,7,8,9,8,8,8,8};\n        System.out.println(\"Test Case 3: \" + new Solution().distributeCandies(nums3));\n    }\n}\n\nclass Solution {\n    public int distributeCandies(int[] nums) {\n        int n = nums.length;\n        int res = 0, count = 0;\n        \n        for (int num : nums) {\n            if (num == 1) {\n                count++;\n            } else {\n                res += Math.min(count, 1);\n                count = 0;\n            }\n        }\n        \n        return res + Math.min(count, 1);\n    }\n}\n```",
  "577": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] salary_info = { {1, 10000}, {2, 20000}, {3, 5000} };\n        System.out.println(\"Bonus for employee 1: \" + employee_bonus(salary_info, 1));\n        System.out.println(\"Bonus for employee 2: \" + employee_bonus(salary_info, 2));\n        System.out.println(\"Bonus for employee 4: \" + employee_bonus(salary_info, 4));\n    }\n\n    public static double employee_bonus(int[][] salary_info, int id) {\n        if (id < 1 || id > salary_info.length) {\n            return -1.0;\n        }\n        int total = 0;\n        for (int[] row : salary_info) {\n            total += row[1];\n        }\n        double average = (double)total / salary_info.length;\n        double bonus = Math.max(0, average * 0.5 - salary_info[id-1][1]);\n        return bonus;\n    }\n}",
  "576": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] m1 = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};\n        System.out.println(\"Expected: 2, Actual: \" + outOfBoundaryPaths(m1));\n        \n        int[][] m2 = {{0, 0, 0, 0}, {1, 1, 1, 0}, {0, 0, 0, 0}, {0, 1, 1, 0}};\n        System.out.println(\"Expected: 4, Actual: \" + outOfBoundaryPaths(m2));\n        \n        int[][] m3 = {{0, 0, 0, 0, 0}, {1, 1, 1, 1, 0}, {0, 0, 0, 0, 0}};\n        System.out.println(\"Expected: 5, Actual: \" + outOfBoundaryPaths(m3));\n    }\n\n    public static int outOfBoundaryPaths(int[][] maze) {\n        if (maze == null || maze.length == 0) return 0;\n        \n        int m = maze.length;\n        int n = maze[0].length;\n        boolean[][] visited = new boolean[m][n];\n        \n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (maze[i][j] == 0 && !visited[i][j]) {\n                    dfs(maze, visited, i, j);\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    public static void dfs(int[][] maze, boolean[][] visited, int i, int j) {\n        int m = maze.length;\n        int n = maze[0].length;\n        \n        if (i < 0 || i >= m || j < 0 || j >= n || maze[i][j] == 1 || visited[i][j]) return;\n        \n        visited[i][j] = true;\n        if (i == 0 || j == 0 || i == m - 1 || j == n - 1) {\n            return;\n        }\n        \n        dfs(maze, visited, i + 1, j);\n        dfs(maze, visited, i - 1, j);\n        dfs(maze, visited, i, j + 1);\n        dfs(maze, visited, i, j - 1);\n    }\n}\n```",
  "578": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<List<String>> questions = new ArrayList<>();\n        questions.add(Arrays.asList(\"Khoor\", \"Q\"));\n        questions.add(Arrays.asList(\"The sun\", \"sun\"));\n        questions.add(Arrays.asList(\"What is your name?\", \"name\"));\n\n        System.out.println(getHighestAnswerRateQuestion(questions));\n    }\n\n    public static String getHighestAnswerRateQuestion(List<List<String>> questions) {\n        Map<String, Integer> questionCountMap = new HashMap<>();\n        for (List<String> question : questions) {\n            if (!questionCountMap.containsKey(question.get(1))) {\n                questionCountMap.put(question.get(1), 0);\n            }\n            questionCountMap.put(question.get(1), questionCountMap.get(question.get(1)) + 1);\n        }\n\n        String highestAnswerRateQuestion = null;\n        int maxCount = 0;\n        for (Map.Entry<String, Integer> entry : questionCountMap.entrySet()) {\n            if (entry.getValue() > maxCount) {\n                highestAnswerRateQuestion = entry.getKey();\n                maxCount = entry.getValue();\n            }\n        }\n\n        return highestAnswerRateQuestion;\n    }\n}\n```",
  "579": "```\nimport java.util.*;\n\nclass Solution {\n    public int totalSalary(String[] logs) {\n        Map<String, Integer> salaries = new HashMap<>();\n        for (String log : logs) {\n            String[] parts = log.split(\" \");\n            if (parts[1].equals(\"Enter\")) {\n                salaries.put(parts[0], 100000);\n            } else if (parts[1].equals(\"Leave\")) {\n                int salary = salaries.get(parts[0]);\n                salaries.remove(parts[0]);\n                salaries.put(parts[0], salary + Integer.parseInt(parts[2]));\n            }\n        }\n        return Arrays.stream(salaries.values().toArray()).sum();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        String[] logs1 = {\"John Enter\", \"Alice Leave 1000\", \"Bob Enter\", \"Alice Enter\", \"Charlie Leave 500\"};\n        System.out.println(\"Test case 1: \" + solution.totalSalary(logs1)); // Output: 120000\n\n        // Test case 2\n        String[] logs2 = {\"Alice Enter\", \"Bob Leave 200\", \"Alice Leave 3000\", \"Bob Enter\", \"Charlie Leave 400\"};\n        System.out.println(\"Test case 2: \" + solution.totalSalary(logs2)); // Output: 2900\n\n        // Test case 3\n        String[] logs3 = {\"John Enter\", \"Alice Leave 10000\", \"John Leave\", \"John Enter\", \"Bob Leave 2000\"};\n        System.out.println(\"Test case 3: \" + solution.totalSalary(logs3)); // Output: 21000",
  "580": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countStudents(new String[][]{{\"A\", \"1\"}, {\"B\", \"2\"}, {\"C\", \"1\"}}, new int[][]{{0, 1}, {1, 3}}));\n        System.out.println(countStudents(new String[][]{ {\"A\", \"1\"}, {\"B\", \"2\"}, {\"C\", \"1\"} }, new int[][]{ {0, 1} }));\n        System.out.println(countStudents(new String[][]{{\"A\", \"1\"}, {\"B\", \"2\"}, {\"C\", \"1\"}}, new int[][]{}));\n    }\n\n    public static int countStudents(String[][] students, int[][] department) {\n        Map<String, List<Integer>> studentMap = new HashMap<>();\n        for (int i = 0; i < students.length; i++) {\n            String departmentName = students[i][0];\n            int studentId = Integer.parseInt(students[i][1]);\n            if (!studentMap.containsKey(departmentName)) {\n                studentMap.put(departmentName, new ArrayList<>());\n            }\n            studentMap.get(departmentName).add(studentId);\n        }\n\n        int totalStudents = 0;\n        for (int[] d : department) {\n            String departmentName = \"\";\n            for (String str : students) {\n                if (Integer.parseInt(str[1]) >= d[0] && Integer.parseInt(str[1]) <= d[1]) {\n                    departmentName = str[0];\n                }\n            }\n            totalStudents += studentMap.getOrDefault(departmentName, new ArrayList<>()).size();\n        }\n\n        return totalStudents;\n    }\n}",
  "581": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findUnsortedSubarray(new int[]{2, 6, 4, 8, 10, 1, 9}));\n        System.out.println(findUnsortedSubarray(new int[]{1, 3, 5, 8, 9, 4}));\n        System.out.println(findUnsortedSubarray(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9}));\n    }\n\n    public static int findUnsortedSubarray(int[] nums) {\n        int[] sorted = nums.clone();\n        Arrays.sort(sorted);\n        int start = -1;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != sorted[i]) {\n                if (start == -1) {\n                    start = i;\n                }\n                break;\n            }\n        }\n        if (start == -1) return 0;\n\n        int end = -1;\n        for (int i = nums.length - 1; i >= 0; i--) {\n            if (nums[i] != sorted[sorted.length - 1 - i]) {\n                if (end == -1) {\n                    end = i;\n                }\n                break;\n            }\n        }\n\n        return end - start + 1;\n    }\n}",
  "582": "```\nimport java.util.*;\n\nclass Solution {\n    public List<Integer> killProcess(List<Integer> pid, List<Integer> ppId) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int i = 0; i < pid.size(); i++) {\n            int id = pid.get(i);\n            if (!graph.containsKey(id)) {\n                graph.put(id, new ArrayList<>());\n            }\n            graph.get(id).add(ppId.get(i));\n        }\n        \n        List<Integer> result = new ArrayList<>();\n        for (int id : graph.keySet()) {\n            List<Integer> children = graph.get(id);\n            while (!children.isEmpty()) {\n                int childId = children.remove(0);\n                if (!graph.containsKey(childId)) {\n                    break;\n                }\n                children.addAll(graph.get(childId));\n            }\n            result.add(id);\n        }\n        \n        return result;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Integer> pid = new ArrayList<>();\n        List<Integer> ppId = new ArrayList<>();\n\n        // Test case 1\n        pid = Arrays.asList(1, 3, 10);\n        ppId = Arrays.asList(3, 6, 10);\n        Solution solution = new Solution();\n        List<Integer> result = solution.killProcess(pid, ppId);\n        System.out.println(result); // [1, 3]\n\n        // Test case 2\n        pid = Arrays.asList(1, 3, 4, 5);\n        ppId = Arrays.asList(5, 6, 7, 8);\n        solution = new Solution();\n        result = solution.killProcess(pid, ppId);\n        System.out.println(result); // [1]\n\n        // Test case 3\n        pid = Arrays.asList(10, 20);\n        ppId = Arrays.asList(20, 30, 40);\n        solution = new Solution();\n        result = solution.killProcess(pid, ppId);\n        System.out.println(result); // []\n    }\n}",
  "583": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSteps(\"sea\", \"eat\") == 2 ? \"Pass\" : \"Fail\");\n        System.out.println(minSteps(\"leetcode\", \"etco\") == 4 ? \"Pass\" : \"Fail\");\n        System.out.println(minSteps(\"blackboard\", \"whiteboard\") == 8 ? \"Pass\" : \"Fail\");\n    }\n\n    public static int minSteps(String s, String t) {\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        for (char c : t.toCharArray()) {\n            if (--count[c - 'a'] < 0) return -1;\n        }\n        int res = 0;\n        for (int i : count) {\n            res += i;\n        }\n        return res;\n    }\n}",
  "584": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(\"Test case 1: \" + solution.findReferee(new String[]{\"Bob\", \"Charlie\"}, \"Alice\"));\n        System.out.println(\"Test case 2: \" + solution.findReferee(new String[]{\"Alice\"}, \"Bob\"));\n        System.out.println(\"Test case 3: \" + solution.findReferee(new String[]{\"Alice\", \"Bob\", \"Charlie\"}, \"David\"));\n    }\n}\n\nclass Solution {\n    public int findReferee(String[] customer) {\n        // your code here\n    }\n}\n```",
  "585": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] accounts = {\n            {1, 2, 10},\n            {3, 4, 20},\n            {5, 6, 30}\n        };\n\n        for (int i = 0; i < accounts.length; i++) {\n            System.out.println(\"Case \" + (i+1) + \":\");\n            int totalMoney = calculateTotalMoney(accounts[i][0], accounts[i][1], accounts[i][2]);\n            System.out.println(\"The total money is: \" + totalMoney);\n            System.out.println();\n        }\n    }\n\n    public static int calculateTotalMoney(int a, int b, int c) {\n        return (a * 100) + (b * 50) + c;\n    }\n}\n```",
  "586": "```\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        // Test Case 1\n        List<Integer> columnNums = Arrays.asList(9, 3, 9);\n        int result = findMaxOrders(columnNums);\n        System.out.println(\"Test Case 1: \" + result);\n\n        // Test Case 2\n        columnNums = Arrays.asList(7, 12, 6, 4, 5, 8);\n        result = findMaxOrders(columnNums);\n        System.out.println(\"Test Case 2: \" + result);\n\n        // Test Case 3\n        columnNums = Arrays.asList(1, 2, 3, 4);\n        result = findMaxOrders(columnNums);\n        System.out.println(\"Test Case 3: \" + result);\n    }\n\n    public static int findMaxOrders(List<Integer> orders) {\n        // Your solution here\n        // For example:\n        if (orders == null || orders.size() == 0) {\n            return 0;\n        }\n        Collections.sort(orders);\n        int maxOrders = 1, currentOrders = 1;\n        for (int i = 1; i < orders.size(); i++) {\n            if (orders.get(i) != orders.get(i - 1)) {\n                currentOrders++;\n                if (currentOrders > maxOrders) {\n                    maxOrders = currentOrders;\n                }\n                currentOrders = 1;\n            }\n        }\n        return maxOrders;\n    }\n}",
  "587": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input1 = {{3,1},{1,3}};\n        System.out.println(\"Test Case 1: \" + calculateArea(input1));\n        \n        int[][] input2 = {{0,2},{1,4},{3,1}};\n        System.out.println(\"Test Case 2: \" + calculateArea(input2));\n\n        int[][] input3 = {{5,6},{7,8}};\n        System.out.println(\"Test Case 3: \" + calculateArea(input3));\n    }\n\n    public static int calculateArea(int[][] points) {\n        // Your solution here\n    }\n}\n```",
  "588": "```\npublic class FileSystem {\n    // Your solution here...\n\n    public static void main(String[] args) {\n        FileSystem fileSystem = new FileSystem();\n        System.out.println(fileSystem.mkdir(\"/a\"));\n        System.out.println(fileSystem.mkdir(\"/a/b\"));\n        System.out.println(fileSystem.create(\"/a/b/file.txt\", \"Hello, World!\"));\n        System.out.println(fileSystem.get(\"/a/b/file.txt\"));\n    }\n}\n\nclass Node {\n    String name;\n    Map<String, Node> children = new HashMap<>();\n    boolean isFile;\n\n    public Node(String name) {\n        this.name = name;\n    }\n}\n\npublic class FileSystem {\n    private Node root = new Node(\"/\");\n    \n    public String mkdir(String path) {\n        Node current = root;\n        for (String component : path.split(\"/\")) {\n            if (!component.isEmpty()) {\n                Node child = current.children.get(component);\n                if (child == null) {\n                    child = new Node(component);\n                    current.children.put(component, child);\n                }\n                current = child;\n            } else {\n                current = root;\n            }\n        }\n        return \"\";\n    }\n\n    public String create(String path, String contents) {\n        Node current = root;\n        for (String component : path.split(\"/\")) {\n            if (!component.isEmpty()) {\n                Node child = current.children.get(component);\n                if (child == null) {\n                    child = new Node(component);\n                    current.children.put(component, child);\n                }\n                current = child;\n            } else {\n                current = root;\n            }\n        }\n        Node node = root;\n        for (String component : path.split(\"/\")) {\n            if (!component.isEmpty()) {\n                node = node.children.get(component);\n            }\n        }\n        node.isFile = true;\n        ((Node)node).contents = contents;\n        return \"\";\n    }\n\n    public String get(String path) {\n        Node current = root;\n        for (String component : path.split(\"/\")) {\n            if (!component.isEmpty()) {\n                Node child = current.children.get(component);\n                if (child == null) {\n                    return \"No such file or directory\";\n                }\n                current = child;\n            } else {\n                current = root;\n            }\n        }\n        if (current.isFile) {\n            return ((Node) current).contents;\n        } else {\n            return \"No such file or directory\";\n        }\n    }\n}",
  "589": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<Integer> preorder(Node root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Stack<Node> stack = new Stack<>();\n        stack.push(root);\n\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            result.add(node.val);\n            for (Node child : node.children) {\n                stack.push(child);\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        Node root1 = new Node(1);\n        root1.children = Arrays.asList(new Node(3), new Node(5));\n        root1.children.get(0).children = Arrays.asList(new Node(6), new Node(7));\n        root1.children.get(1).children = Arrays.asList(new Node(8));\n\n        List<Integer> result1 = solution.preorder(root1);\n        System.out.println(\"Test case 1: \" + result1);\n\n        // Test case 2\n        Node root2 = new Node(5);\n        root2.children = Arrays.asList(new Node(3), new Node(6));\n        root2.children.get(0).children = Arrays.asList(new Node(4));\n\n        List<Integer> result2 = solution.preorder(root2);\n        System.out.println(\"Test case 2: \" + result2);\n\n        // Test case 3\n        Node root3 = null;\n\n        List<Integer> result3 = solution.preorder(root3);\n        System.out.println(\"Test case 3: \" + result3);\n    }\n}\n\nclass Node {\n    int val;\n    List<Node> children = new ArrayList<>();\n\n    public Node(int v) { val = v; }\n}\n```",
  "591": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(validateTag(\"AAAAAA\")); // true\n        System.out.println(validateTag(\"<a>Q<a></a>\"));// false\n        System.out.println(validateTag(\"<div><p>This is a paragraph.</p><p>This looks like HTML to me.</p></div>\")); // true\n    }\n\n    public static boolean validateTag(String s) {\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '<') {\n                stack.push(c);\n            } else if (c == '>') {\n                if (stack.isEmpty() || stack.pop() != '<') {\n                    return false;\n                }\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```",
  "590": "```\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Node root1 = new Node(1);\n        root1.children.add(new Node(3));\n        root1.children.add(new Node(5));\n\n        Node root2 = new Node(2);\n        root2.children.add(new Node(4));\n\n        postorder(root1);\n        System.out.println();\n\n        postorder(root2);\n\n        root1 = null;\n        postorder(null);\n    }\n\n    public static void postorder(Node root) {\n        Stack<Node> stack = new Stack<>();\n        Set<Node> visited = new HashSet<>();\n\n        if (root == null) return;\n\n        stack.push(root);\n\n        while (!stack.isEmpty()) {\n            Node node = stack.peek();\n            boolean hasVisited = false;\n            for (Node child : node.children) {\n                if (!visited.contains(child)) {\n                    stack.push(child);\n                    hasVisited = true;\n                    break;\n                }\n            }\n\n            if (!hasVisited) {\n                System.out.print(stack.pop().val + \" \");\n            } else {\n                visited.add(node);\n            }\n        }\n    }\n}\n\nclass Node {\n    int val;\n    List<Node> children = new ArrayList<>();\n\n    public Node(int _val) {\n        val = _val;\n    }\n}\n```",
  "592": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(addFraction(\"1/4\", \"1/2\")); // Expected output: \"3/4\"\n        System.out.println(addFraction(\"1/2\", \"1/2\")); // Expected output: \"1 1/2\"\n        System.out.println(addFraction(\"1/6\", \"1/2\")); // Expected output: \"1 1/3\"\n    }\n\n    public static String addFraction(String a, String b) {\n        // Your code here\n    }\n}\n```",
  "593": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canFormArray(new int[][]{{1,0}, {2,0}, {5,3}}, 3));\n        System.out.println(canFormArray(new int[][]{{5,3},{-1,-1}},{3,3}, 9));\n        System.out.println(canFormArray(new int[][]{-1,-1},{0,0},{1,1} , 8));\n    }\n\n    public static boolean canFormArray(int[][] points, int distance) {\n        for (int i = 0; i < points.length - 2; i++) {\n            double slope = calculateSlope(points[i], points[i + 1]);\n            if (slope == Double.NEGATIVE_INFINITY) return false;\n            for (int j = i + 2; j < points.length; j++) {\n                double newSlope = calculateSlope(points[i], points[j]);\n                if (Math.abs(newSlope - slope) > 0.0001) return false;\n            }\n        }\n        return true;\n    }\n\n    public static double calculateSlope(int[] point1, int[] point2) {\n        if (point1[0] == point2[0]) {\n            return Double.NEGATIVE_INFINITY;\n        } else {\n            return ((double)(point2[1] - point1[1])) / ((double)(point2[0] - point1[0]));\n        }\n    }\n}",
  "594": "```\npublic class Solution {\n    public int findLHS(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        \n        int maxLen = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (map.containsKey(entry.getKey() + 1)) {\n                maxLen = Math.max(maxLen, entry.getValue() + map.get(entry.getKey() + 1));\n            }\n        }\n        \n        return maxLen;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.findLHS(new int[]{1,3,2,2,5,2,1,7})); // expected output: 5\n        System.out.println(solution.findLHS(new int[]{1,2,3,4})); // expected output: 2\n        System.out.println(solution.findLHS(new int[]{1,1,2,2,3,3})); // expected output: 6\n    }\n}\n```",
  "595": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(bigCountries(new String[][]{\n            {\"China\", \"Asia\"},\n            {\"United States\", \"North America\"},\n            {\"Japan\", \"Asia\"},\n            {\"Mexico\", \"North America\"}\n        })); // Should return 2\n\n        System.out.println(bigCountries(new String[][]{\n            {\"France\", \"Europe\"},\n            {\"Germany\", \"Europe\"},\n            {\"Italy\", \"Europe\"}\n        })); // Should return 1\n\n        System.out.println(bigCountries(new String[][]{\n            {\"India\", \"Asia\"},\n            {\"Pakistan\", \"Asia\"},\n            {\"Bangladesh\", \"Asia\"}\n        })); // Should return 2\n    }\n\n    public static int bigCountries(String[][] countries) {\n        Map<String, Integer> countryCount = new HashMap<>();\n        for (String[] country : countries) {\n            String continent = country[1];\n            if (!countryCount.containsKey(continent)) {\n                countryCount.put(continent, 0);\n            }\n            countryCount.put(continent, countryCount.get(continent) + 1);\n        }\n\n        int bigCountries = 0;\n        for (Map.Entry<String, Integer> entry : countryCount.entrySet()) {\n            if (entry.getValue() > 1) {\n                bigCountries++;\n            }\n        }\n        return bigCountries;\n    }\n}",
  "596": "```\npublic class Solution {\n    public int countClasses(int[][] schedules) {\n        int total = 0;\n        for (int[] schedule : schedules) {\n            if (schedule.length > 5) {\n                total++;\n            }\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.countClasses(new int[][]{{}, {1, 2}, {3, 4, 5}})); // Expected: 0\n        System.out.println(solution.countClasses(new int[][]{{1, 2}, {3, 4, 5}, {6}})); // Expected: 1\n        System.out.println(solution.countClasses(new int[][]{ {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}, {11, 12, 13, 14, 15, 16}})); // Expected: 2\n    }\n}",
  "597": "```\npublic class Solution {\n    public double overallAcceptRate(int[][] requests) {\n        int totalRequests = 0;\n        int acceptedRequests = 0;\n        \n        for (int[] request : requests) {\n            if (request[1] == 1) { // Accept\n                acceptedRequests++;\n            }\n            totalRequests++;\n        }\n        \n        return (double) acceptedRequests / totalRequests;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] request1 = {{1, 0}, {2, 1}};\n        System.out.println(\"Acceptance Rate for request1: \" + solution.overallAcceptRate(request1));\n\n        int[][] request2 = {{0, 0}, {1, 1}, {2, 0}};\n        System.out.println(\"Acceptance Rate for request2: \" + solution.overallAcceptRate(request2));\n\n        int[][] request3 = {{1, 1}, {2, 0}, {3, 1}};\n        System.out.println(\"Acceptance Rate for request3: \" + solution.overallAcceptRate(request3));\n    }\n}",
  "598": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] intervals = {{1,5},{6,7},{12,16},{17,19}};\n        System.out.println(\"Expected: [8], Actual: \" + rangeSum(intervals));\n        \n        int[][] intervals2 = {{1,3},{4,10},{11,15}};\n        System.out.println(\"Expected: 18, Actual: \" + rangeSum(intervals2));\n        \n        int[][] intervals3 = {{0,5},{6,12}};\n        System.out.println(\"Expected: 9, Actual: \" + rangeSum(intervals3));\n    }\n\n    public static int rangeSum(int[][] intervals) {\n        int n = intervals.length;\n        if(n == 0) return 0;\n\n        Arrays.sort((int[][]) intervals, (a, b) -> a[0] - b[0]);\n\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += (intervals[i][1] - intervals[i][0]) + ((i > 0) ? (intervals[i-1][1] - intervals[i-1][0]) : 0);\n        }\n\n        return sum;\n    }\n}",
  "599": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] list1 = {{0, 9}, {7, 10}};\n        int[][] list2 = {{5, 6}, {1, 8}};\n        System.out.println(minIndexSum(list1, list2)); // Output: 14\n\n        int[][] list3 = {{1, 4}, {5, 7}};\n        int[][] list4 = {{2, 3}};\n        System.out.println(minIndexSum(list3, list4)); // Output: 6\n\n        int[][] list5 = {{10, 12}};\n        int[][] list6 = {{7, 8}, {9, 11}};\n        System.out.println(minIndexSum(list5, list6)); // Output: 15\n    }\n\n    public static int minIndexSum(int[][] list1, int[][] list2) {\n        Map<Integer, Integer> map1 = new HashMap<>();\n        for (int i = 0; i < list1.length; i++) {\n            map1.put(list1[i][1], i);\n        }\n        int sum = 0;\n        for (int[] pair : list2) {\n            sum += Math.min(map1.getOrDefault(pair[0], Integer.MAX_VALUE), map1.getOrDefault(pair[1], Integer.MAX_VALUE));\n        }\n        return sum;\n    }\n}\n```",
  "600": "```\npublic class Main {\n    public static void main(String[] args) {\n        int num1 = 7;\n        System.out.println(\"For \" + num1 + \": \" + findIntegersWithoutConsecutiveOnes(num1));\n        \n        int num2 = 5;\n        System.out.println(\"For \" + num2 + \": \" + findIntegersWithoutConsecutiveOnes(num2));\n\n        int num3 = 13;\n        System.out.println(\"For \" + num3 + \": \" + findIntegersWithoutConsecutiveOnes(num3));\n    }\n\n    public static int findIntegersWithoutConsecutiveOnes(int n) {\n        if (n < 1) {\n            return 0;\n        }\n        int ones = 0;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                ones++;\n                n >>= 1;\n            } else {\n                n >>= 1;\n            }\n        }\n        return Math.max(ones, findIntegersWithoutConsecutiveOnes(n));\n    }\n}\n```",
  "601": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Solution().averageWaitingTime(new int[][]{{79,60},{8,15}}));\n        System.out.println(new Solution().averageWaitingTime(new int[][]{{1,2}}));\n        System.out.println(new Solution().averageWaitingTime(new int[][]{ {5,10 }, { 2,4 } }));\n    }\n}\n\nclass Solution {\n    public double averageWaitingTime(int[][] seats) {\n        // your code here\n    }\n}",
  "603": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] seats = new int[][]{{1, 2}, {5}, {4, 6, 7}, {1, 3}};\n        System.out.println(consecutiveAvailableSeats(seats));\n        \n        seats = new int[][]{{8}, {9, 10, 11, 12, 13, 14, 15}};\n        System.out.println(consecutiveAvailableSeats(seats));\n        \n        seats = new int[][]{};\n        System.out.println(consecutiveAvailableSeats(seats));\n    }\n\n    public static String consecutiveAvailableSeats(int[][] seats) {\n        List<Integer> availableSeats = new ArrayList<>();\n        for (int i = 0; i < seats.length; i++) {\n            if (seats[i].length == 1) {\n                int seat = seats[i][0];\n                if (!availableSeats.isEmpty() && availableSeats.get(availableSeats.size() - 1) + 1 != seat) {\n                    availableSeats.add(seat);\n                }\n            } else {\n                for (int j = 0; j < seats[i].length - 1; j++) {\n                    int startSeat = seats[i][j];\n                    int endSeat = seats[i][j + 1] - 1;\n                    if (!availableSeats.isEmpty() && availableSeats.get(availableSeats.size() - 1) + 1 != startSeat) {\n                        availableSeats.add(startSeat);\n                    }\n                    for (int k = startSeat; k <= endSeat; k++) {\n                        availableSeats.add(k);\n                    }\n                }\n            }\n        }\n        return Arrays.toString(availableSeats.stream().distinct().mapToInt(Integer::intValue).toArray());\n    }\n}",
  "602": "```\nimport java.util.*;\n\npublic class Solution {\n    public int[] mostFriends(int n, int[][] requests) {\n        Map<Integer, List<Integer>> friends = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            friends.put(i, new ArrayList<>());\n        }\n        \n        for (int[] request : requests) {\n            friends.get(request[0]).add(request[1]);\n            friends.get(request[1]).add(request[0]);\n        }\n        \n        List<Map.Entry<Integer, List<Integer>>> list = new LinkedList<>(friends.entrySet());\n        Collections.sort(list, new Comparator<Map.Entry<Integer, List<Integer>>>() {\n            public int compare(Map.Entry<Integer, List<Integer>> o1,\n                               Map.Entry<Integer, List<Integer>> o2) {\n                return o2.getValue().size() - o1.getValue().size();\n            }\n        });\n        \n        int[] result = new int[1];\n        for (Map.Entry<Integer, List<Integer>> entry : list) {\n            if (entry.getValue().size() > result[0]) {\n                result[0] = entry.getValue().size();\n                result = new int[]{entry.getKey()};\n            } else if (entry.getValue().size() == result[0]) {\n                result = new int[]{entry.getKey(),};\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n1 = 4;\n        int[][] requests1 = {{0, 1}, {2, 3}};\n        int[] expected1 = {3};\n        test(solution, n1, requests1, expected1);\n\n        int n2 = 5;\n        int[][] requests2 = {{0, 1}, {1, 3}, {2, 4}};\n        int[] expected2 = {4};\n        test(solution, n2, requests2, expected2);\n\n        int n3 = 7;\n        int[][] requests3 = {{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}};\n        int[] expected3 = {6};\n        test(solution, n3, requests3, expected3);\n    }\n\n    public static void test(Solution solution, int n, int[][] requests, int[] expected) {\n        int[] result = solution.mostFriends(n, requests);\n        if (!Arrays.equals(result, expected)) {\n            throw new AssertionError(\"Test failed. Expected \" + Arrays.toString(expected) + \", but got \" + Arrays.toString(result));\n        } else {\n            System.out.println(\"Test passed.\");\n        }\n    }\n}",
  "604": "```\npublic class Main {\n    public static void main(String[] args) {\n        CompressedStringIterator iterator = new CompressedStringIterator(\"aabcccccaaa\");\n\n        System.out.println(iterator.next()); // prints \"a\"\n        System.out.println(iterator.next()); // prints \"a\"\n        System.out.println(iterator.next()); // prints \"b\"\n\n        int iterations = 0;\n        while (iterator.hasNext()) {\n            System.out.println(iterator.next());\n            iterations++;\n        }\n\n        iterator = new CompressedStringIterator(\"aa\");\n        System.out.println(iterations); // prints 5\n\n        iterator = new CompressedStringIterator(\"\");\n        System.out.println(iterator.hasNext()); // prints false\n    }\n}\n\nclass CompressedStringIterator {\n    private int ptr;\n    private char[] arr;\n\n    public CompressedStringIterator(String s) {\n        arr = s.toCharArray();\n        ptr = 0;\n    }\n\n    public boolean hasNext() {\n        return ptr < arr.length;\n    }\n\n    public char next() {\n        if (!hasNext()) {\n            throw new RuntimeException(\"No more elements\");\n        }\n        return arr[ptr++];\n    }\n}\n```",
  "605": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] flowerbed = {1,0,2,0,1};\n        System.out.println(canPlaceFlowers(flowerbed, 2)); // Expected: 2\n\n        int[] flowerbed2 = {1,0,0,0,1};\n        System.out.println(canPlaceFlowers(flowerbed2, 1)); // Expected: 3\n\n        int[] flowerbed3 = {1,0,0};\n        System.out.println(canPlaceFlowers(flowerbed3, 1)); // Expected: 1\n    }\n\n    public static int canPlaceFlowers(int[] flowerbed, int n) {\n        int count = 0;\n        for (int i = 0; i < flowerbed.length; i++) {\n            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i - 1] == 0) && (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {\n                flowerbed[i] = 1;\n                count++;\n                if (count >= n) {\n                    return n;\n                }\n            }\n        }\n        return count;\n    }\n}",
  "607": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(calculateAmount(\"John\", \"john@example.com\")); // Test case 1\n        System.out.println(calculateAmount(\"Jane\", \"jane@example.com\")); // Test case 2\n        System.out.println(calculateAmount(\"Bob\", \"bob@example.com\")); // Test case 3\n    }\n\n    public static int calculateAmount(String name, String email) {\n        return 100;\n    }\n}\n```",
  "606": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(5);\n\n        System.out.println(constructorString(root1));  // Output: \"1(2(4))(3)(5)\"\n\n        TreeNode root2 = new TreeNode(1);\n        root2.right = new TreeNode(2);\n\n        System.out.println(constructorString(root2));  // Output: \"1()2\"\n\n        TreeNode root3 = null;\n\n        System.out.println(constructorString(root3));  // Output: \"\"\n    }\n\n    public static String constructorString(TreeNode root) {\n        if (root == null) return \"\";\n        StringBuilder sb = new StringBuilder();\n        constructorStringHelper(root, sb);\n        return sb.toString();\n    }\n\n    private static void constructorStringHelper(TreeNode node, StringBuilder sb) {\n        if (node == null) return;\n        sb.append(node.val);\n        sb.append(\"(\");\n        constructorStringHelper(node.left, sb);\n        sb.append(\")\");\n        if (node.right != null) sb.append(\"(\").append(node.right.val).append(\")\");\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "608": "```\npublic class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Solution {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(6);\n        root2.right = new TreeNode(7);\n\n        TreeNode root3 = new TreeNode(9);\n\n        testTree(root1);\n        testTree(root2);\n        testTree(root3);\n    }\n\n    public static void testTree(TreeNode root) {\n        System.out.println(\"Root: \" + root.val);\n        if (root.left != null) {\n            System.out.println(\"Left child: \" + root.left.val);\n        } else {\n            System.out.println(\"No left child\");\n        }\n        if (root.right != null) {\n            System.out.println(\"Right child: \" + root.right.val);\n        } else {\n            System.out.println(\"No right child\");\n        }\n    }\n}\n```",
  "609": "```\nimport java.io.File;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] paths1 = {\"/root/a.txt\", \"/root/c.txt\", \"/root/a.txt\"};\n        findDuplicate(paths1);\n\n        String[] paths2 = {\"/root/a.txt\", \"/root/b.txt\", \"/root/.\"};\n        findDuplicate(paths2);\n\n        String[] paths3 = {\"/root/d.txt\", \"/root/a.txt\", \"/root/a.txt\"};\n        findDuplicate(paths3);\n    }\n\n    public static List<List<String>> findDuplicate(String[] paths) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String path : paths) {\n            File file = new File(path);\n            String name = file.getName();\n            map.put(name, map.getOrDefault(name, 0) + 1);\n        }\n\n        List<List<String>> result = new ArrayList<>();\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            if (entry.getValue() > 1) {\n                List<String> files = new ArrayList<>();\n                for (String path : paths) {\n                    File file = new File(path);\n                    String name = file.getName();\n                    if (name.equals(entry.getKey())) {\n                        files.add(path);\n                    }\n                }\n                result.add(files);\n            }\n        }\n\n        return result;\n    }\n}",
  "610": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(judge(1, 2, 3)); // Expected output: False\n        System.out.println(judge(5, 1, 2)); // Expected output: True\n        System.out.println(judge(0, 2, 3)); // Expected output: True\n    }\n\n    public static boolean judge(int a, int b, int c) {\n        if (a + b > c && a + c > b && b + c > a)\n            return true;\n        else\n            return false;\n    }\n}\n```",
  "611": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canMakeArithmeticProgression(20)); // true\n        System.out.println(canMakeArithmeticProgression(10)); // false\n        System.out.println(canMakeArithmeticProgression(3)); // false\n    }\n\n    public static boolean canMakeArithmeticProgression(int n) {\n        for (int i = 1; i <= n / 2; i++) {\n            int j = n - i;\n            if ((n - i) * 2 == i || n % i == 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "613": "```\npublic class Main {\n    public static void main(String[] args) {\n        int result1 = shortestDistance(new Pair(1, 2), new Pair(3, 4));\n        System.out.println(\"Test case 1: Expected 5.0, got \" + result1);\n\n        int result2 = shortestDistance(new Pair(8, 10), new Pair(6, 8));\n        System.out.println(\"Test case 2: Expected 3.0, got \" + result2);\n\n        int result3 = shortestDistance(new Pair(-3, -7), new Pair(1, 5));\n        System.out.println(\"Test case 3: Expected 12.0, got \" + result3);\n    }\n\n    public static double shortestDistance(Pair p1, Pair p2) {\n        return Math.abs(p2.x - p1.x);\n    }\n}\n\nclass Pair {\n    int x;\n    int y;\n\n    public Pair(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n```",
  "612": "```\npublic class Solution {\n    public int shortDist(int[][] points) {\n        if (points == null || points.length <= 1) return 0;\n        \n        Arrays.sort(points, (a, b) -> Double.compare(Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2)), \n            Math.sqrt(Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2))));\n        \n        int minDist = Integer.MAX_VALUE;\n        for (int i = 1; i < points.length; i++) {\n            minDist = Math.min(minDist, Math.sqrt(Math.pow(points[i][0] - points[i-1][0], 2) + Math.pow(points[i][1] - points[i-1][1], 2)));\n        }\n        \n        return minDist;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1\n        int[][] points1 = {{0,0},{1,1}};\n        System.out.println(\"Test Case 1: \" + solution.shortDist(points1));\n        \n        // Test Case 2\n        int[][] points2 = {{3,1},{5,-1},{4,0},{-9,6},{6,7}};\n        System.out.println(\"Test Case 2: \" + solution.shortDist(points2));\n        \n        // Test Case 3\n        int[][] points3 = {{0,0},{10,10}};\n        System.out.println(\"Test Case 3: \" + solution.shortDist(points3));\n    }\n}",
  "614": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Solution().secondDegreeFollowers(\"John\", Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"), Arrays.asList(\"Alice,Charlie\", \"Bob,Charlie\"))));\n        System.out.println(new Solution().secondDegreeFollowers(\"John\", Arrays.asList(\"Jane,Jim\", \"Madeline,Frank\"), Arrays.asList()));\n        System.out.println(new Solution().secondDegreeFollowers(\"Eva\", Arrays.asList(), Arrays.asList(\"Frank\")));\n    }\n}\n\nclass Solution {\n    public String secondDegreeFollowers(String account, List<String> accountsFollowing, List<String> accountsFollowed) {\n        // your solution here\n    }\n}\n```",
  "615": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] salaryInfo = {{1, 100}, {2, 200}, {3, 300}, {4, 400}};\n        System.out.println(\"Test Case 1: \" + getAverageSalary(salaryInfo));\n        \n        int[][] salaryInfo2 = {{1, 1500}, {2, 3500}, {3, 5000}, {4, 6000}};\n        System.out.println(\"Test Case 2: \" + getAverageSalary(salaryInfo2));\n        \n        int[][] salaryInfo3 = {{1, 20000}, {2, 25000}, {3, 30000}, {4, 35000}};\n        System.out.println(\"Test Case 3: \" + getAverageSalary(salaryInfo3));\n    }\n\n    public static double getAverageSalary(int[][] salaryInfo) {\n        Map<Integer, List<Integer>> departmentSalaries = new HashMap<>();\n        for (int[] info : salaryInfo) {\n            int id = info[0];\n            int salary = info[1];\n            if (!departmentSalaries.containsKey(id)) {\n                departmentSalaries.put(id, new ArrayList<>());\n            }\n            departmentSalaries.get(id).add(salary);\n        }\n\n        double totalSalary = 0;\n        for (List<Integer> salaries : departmentSalaries.values()) {\n            totalSalary += salaries.stream().mapToInt(i -> i).sum();\n        }\n\n        return totalSalary / salaryInfo.length;\n    }\n}\n```",
  "616": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(addBoldTag(\"abcxyz123\", new String[]{\"ab\",\"cd\"}));\n        System.out.println(addBoldTag(\"We love leetcode\", new String[]{\"love\",\"leetcode\"}));\n        System.out.println(addBoldTag(\"LeetCodeLove\", new String[]{\"Love\",\"e\"}));\n    }\n\n    public static String addBoldTag(String s, String[] dict) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            boolean found = false;\n            for (String word : dict) {\n                if (s.startsWith(word, i)) {\n                    sb.append(\"<b>\").append(word).append(\"</b>\");\n                    i += word.length() - 1;\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "617": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode tree1 = new TreeNode(1);\n        tree1.left = new TreeNode(3);\n        tree1.right = new TreeNode(2);\n\n        TreeNode tree2 = new TreeNode(2);\n        tree2.left = new TreeNode(1);\n        tree2.right = new TreeNode(3);\n\n        mergeTrees(tree1, tree2).printTree();\n\n        System.out.println();\n\n        tree1 = null;\n        tree2 = new TreeNode(5);\n        tree2.left = new TreeNode(1);\n        tree2.right = new TreeNode(0);\n        mergeTrees(tree1, tree2).printTree();\n\n        System.out.println();\n\n        tree1 = new TreeNode(4);\n        tree1.left = new TreeNode(7);\n        tree1.right = new TreeNode(3);\n        tree2 = new TreeNode(5);\n        tree2.left = new TreeNode(6);\n        tree2.right = new TreeNode(8);\n\n        mergeTrees(tree1, tree2).printTree();\n    }\n\n    public static TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) {\n            return null;\n        }\n        if (t1 == null) {\n            return t2;\n        }\n        if (t2 == null) {\n            return t1;\n        }\n\n        t1.val += t2.val;\n\n        t1.left = mergeTrees(t1.left, t2.left);\n        t1.right = mergeTrees(t1.right, t2.right);\n\n        return t1;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n\n    public void printTree() {\n        if (this == null) {\n            return;\n        }\n        System.out.print(this.val + \" \");\n        this.left.printTree();\n        this.right.printTree();\n    }\n}\n```",
  "618": "```\npublic class Solution {\n    public List<List<String>> geographicalReport(String[] report) {\n        Map<String, List<String>> geographyToStudents = new HashMap<>();\n        for (String entry : report) {\n            String[] parts = entry.split();\n            String geography = parts[0];\n            String student = parts[1];\n            if (!geographyToStudents.containsKey(geography)) {\n                geographyToStudents.put(geography, new ArrayList<>());\n            }\n            geographyToStudents.get(geography).add(student);\n        }\n        List<List<String>> result = new ArrayList<>();\n        for (List<String> students : geographyToStudents.values()) {\n            Collections.sort(students);\n            result.add(new ArrayList<>(Arrays.asList(geographyToStudents.getKey(), students)));\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] report1 = {\"Ralph 10\", \"Alice 20\", \"Bob 30\"};\n        System.out.println(solution.geographicalReport(report1));\n\n        String[] report2 = {\"John 1\", \"Mike 2\", \"Lily 3\", \"Eve 4\", \"Hannah 5\"};\n        System.out.println(solution.geographicalReport(report2));\n\n        String[] report3 = {\"Tom 15\", \"Alex 25\", \"Sam 35\"};\n        System.out.println(solution.geographicalReport(report3));\n    }\n}",
  "619": "```\npublic class Solution {\n    public int findLargest(int[] nums) {\n        int max = Integer.MIN_VALUE;\n        for (int num : nums) {\n            if (num > max) {\n                max = num;\n            }\n        }\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[] test1 = {1, 2, 3, 4, 5};\n        System.out.println(\"Largest single number in \" + Arrays.toString(test1) + \": \" + solution.findLargest(test1));\n        \n        // Test case 2\n        int[] test2 = {10, 20, -30, 50, -100};\n        System.out.println(\"Largest single number in \" + Arrays.toString(test2) + \": \" + solution.findLargest(test2));\n        \n        // Test case 3\n        int[] test3 = {-1, -2, -3, -4, -5};\n        System.out.println(\"Largest single number in \" + Arrays.toString(test3) + \": \" + solution.findLargest(test3));\n    }\n}\n```",
  "620": "```\nimport java.util.*;\n\npublic class Solution {\n    public String[] findNotBoring(String[] watchedBefore, String[] notBoring) {\n        List<String> result = new ArrayList<>();\n        for (String movie : watchedBefore) {\n            if (!notBoring.contains(movie)) {\n                result.add(movie);\n            }\n        }\n        return result.toArray(new String[0]);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        String[] watchedBefore1 = {\"A\", \"B\", \"C\"};\n        String[] notBoring1 = {\"B\", \"C\"};\n        System.out.println(Arrays.toString(solution.findNotBoring(watchedBefore1, notBoring1)));\n        \n        // Test case 2\n        String[] watchedBefore2 = {\"A\", \"D\", \"E\"};\n        String[] notBoring2 = {\"A\", \"E\"};\n        System.out.println(Arrays.toString(solution.findNotBoring(watchedBefore2, notBoring2)));\n        \n        // Test case 3\n        String[] watchedBefore3 = {\"F\", \"G\", \"H\", \"I\"};\n        String[] notBoring3 = {};\n        System.out.println(Arrays.toString(solution.findNotBoring(watchedBefore3, notBoring3)));\n    }\n}",
  "621": "```\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Solution {\n    public String[] sortTasks(String[] tasks) {\n        Arrays.sort(tasks, new Comparator<String>() {\n            @Override\n            public int compare(String s1, String s2) {\n                return Integer.compare(Integer.parseInt(s2.substring(5)), Integer.parseInt(s1.substring(5)));\n            }\n        });\n        StringBuilder sb = new StringBuilder();\n        for (String task : tasks) {\n            if (!task.startsWith(\"sleep\")) {\n                sb.append(task);\n            } else {\n                sb.deleteCharAt(sb.length() - 1);\n                sb.append(\"\\n\");\n            }\n        }\n        return sb.toString().split(\"\\n\");\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] tasks1 = {\"Wkup\", \"Code\", \"Eeat\", \"Sleep\"};\n        System.out.println(Arrays.deepToString(solution.sortTasks(tasks1)));\n\n        String[] tasks2 = {\"Wkup\", \"Code\", \"Eeat\", \"Sleep10\"};\n        System.out.println(Arrays.deepToString(solution.sortTasks(tasks2)));\n\n        String[] tasks3 = {\"Snooze\", \"WakeUp\", \"Code\", \"Eat\", \"Sleep15\", \"WatchTV\", \"Relax\"};\n        System.out.println(Arrays.deepToString(solution.sortTasks(tasks3)));\n    }\n}",
  "622": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        CircularQueue circularQueue1 = new CircularQueue(3);\n        circularQueue1.enQueue(1);\n        System.out.println(circularQueue1.front()); // prints: 1\n        System.out.println(circularQueue1.rear()); // prints: 1\n        circularQueue1.enQueue(2);\n        System.out.println(circularQueue1.front()); // prints: 1\n        System.out.println(circularQueue1.rear()); // prints: 2\n        circularQueue1.enQueue(3);\n        System.out.println(circularQueue1.front()); // prints: 1\n        System.out.println(circularQueueNode); // prints: 3\n        circularQueue1.deQueue();\n        System.out.println(circularQueue1.front()); // prints: 2\n        System.out.println(circularQueue1.rear()); // prints: 2\n\n        CircularQueue circularQueue2 = new CircularQueue(5);\n        circularQueue2.enQueue(4);\n        circularQueue2.enQueue(8);\n        circularQueue2.deQueue();\n        System.out.println(circularQueue2.front()); // prints: 8\n        circularQueue2.enQueue(16);\n        System.out.println(circularQueue2.rear()); // prints: 16\n\n        CircularQueue circularQueue3 = new CircularQueue(10);\n        for (int i = 0; i < 10; i++) {\n            circularQueue3.enQueue(i);\n        }\n        while (!circularQueue3.isEmpty()) {\n            System.out.println(circularQueue3.deQueue());\n        }\n    }\n}\n\n```",
  "623": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n\n        Solution solution = new Solution();\n        solution.addOneRowToTree(root, 3, \"abc\");\n        printTree(root);\n\n        root = null;\n        solution = new Solution();\n        solution.addOneRowToTree(root, 1, \"a\");\n        printTree(root);\n\n        root = new TreeNode(4);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(6);\n        root.left.left = new TreeNode(3);\n        root.left.right = new TreeNode(5);\n\n        solution = new Solution();\n        solution.addOneRowToTree(root, 1, \"adding\");\n        printTree(root);\n    }\n\n    private static void printTree(TreeNode node) {\n        if (node == null) return;\n        System.out.println(node.val);\n        printTree(node.left);\n        printTree(node.right);\n    }\n}\n\nclass Solution {\n\n    public TreeNode addOneRowToTree(TreeNode root, int val, String s) {\n        if (root == null) {\n            return new TreeNode(val);\n        }\n\n        TreeNode newRoot = new TreeNode(val);\n        TreeNode curNode = root;\n        int index = 0;\n\n        while (curNode != null && index < s.length()) {\n            if (index == s.length() - 1) {\n                newRoot.left = new TreeNode(s.charAt(index));\n                newRoot.right = curNode.right;\n                return newRoot;\n            }\n            if (s.charAt(index) == 'L') {\n                newRoot.left = new TreeNode(s.charAt(index + 1));\n                curNode.left = new TreeNode(val);\n                curNode.left.left = curNode.left;\n                curNode.left.right = newRoot.left;\n                return newRoot;\n            } else {\n                curNode = curNode.right;\n            }\n            index++;\n        }\n\n        if (index == s.length()) {\n            newRoot.left = root.left;\n            newRoot.right = root.right;\n            return newRoot;\n        }\n\n        while (curNode.right != null) {\n            if (s.charAt(index) == 'R') {\n                newRoot.right = new TreeNode(s.charAt(index + 1));\n                curNode.right = new TreeNode(val);\n                curNode.right.left = newRoot.right;\n                curNode.right.right = curNode.right.right;\n                return newRoot;\n            }\n            curNode = curNode.right;\n            index++;\n        }\n\n        if (index == s.length()) {\n            newRoot.left = root.left;\n            newRoot.right = root.right;\n            return newRoot;\n        }\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "624": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = { {1, 6, 5}, {1, 2, 3, 17 }, {0, 9} };\n        for (int i = 0; i < arrays.length; i++) {\n            System.out.println(\"Maximum Distance in Arrays: \" + maxDistance(arrays[i]));\n        }\n    }\n\n    public static int maxDistance(int[] arr) {\n        if (arr.length == 0) return 0;\n        int maxDist = 0, prev = arr[0], dist = 1;\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > prev) {\n                dist++;\n                maxDist = Math.max(maxDist, dist);\n            } else {\n                dist = 1;\n            }\n            prev = arr[i];\n        }\n        return maxDist;\n    }\n}\n```",
  "625": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minFactorization(12));\n        System.out.println(minFactorization(8));\n        System.out.println(minFactorization(24));\n    }\n\n    public static int minFactorization(int N) {\n        if (N < 2) return N;\n        for (int i = 2; i * i <= N; i++) {\n            while (N % i == 0) {\n                N /= i;\n            }\n        }\n        return N;\n    }\n}\n```",
  "626": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] seatID = {{1,2},{1,3},{5}};\n        exchangeSeats(seatID);\n        \n        int[][] seatID1 = {{1,2,3},{4,6,7}};\n        exchangeSeats(seatID1);\n        \n        int[][] seatID2 = {{1}};\n        exchangeSeats(seatID2);\n    }\n\n    public static void exchangeSeats(int[][] seats) {\n        if (seats == null || seats.length < 1) return;\n        for (int i = 0; i < seats.length; i++) {\n            int[] row = seats[i];\n            int n = row.length;\n            for (int j = 0; j < n; j += 2) {\n                if (j + 1 < n) {\n                    int temp = row[j];\n                    row[j] = row[j+1];\n                    row[j+1] = temp;\n                }\n            }\n        }\n    }\n}",
  "627": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Employee[] employees = new Employee[3];\n        employees[0] = new Employee(1, \"John\", 20000);\n        employees[1] = new Employee(2, \"Alice\", 30000);\n        employees[2] = new Employee(3, \"Bob\", 40000);\n\n        swapSalary(employees);\n    }\n\n    public static void swapSalary(Employee[] employees) {\n        for (int i = 0; i < employees.length; i++) {\n            if (i % 2 == 0) {\n                int temp = employees[i].salary;\n                employees[i].salary = employees[employees.length - 1 - i].salary;\n                employees[employees.length - 1 - i].salary = temp;\n            }\n        }\n    }\n\n    static class Employee {\n        int id;\n        String name;\n        int salary;\n\n        public Employee(int id, String name, int salary) {\n            this.id = id;\n            this.name = name;\n            this.salary = salary;\n        }\n    }\n}\n```",
  "628": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {-1, 0, 1};\n        System.out.println(\"Maximum Product of Three Numbers for \" + Arrays.toString(nums1) + \": \" + maximumProduct(new int[]{nums1[0], nums1[1], nums1[2]}));\n        \n        int[] nums2 = {1, 2, 3, 4};\n        System.out.println(\"Maximum Product of Three Numbers for \" + Arrays.toString(nums2) + \": \" + maximumProduct(new int[]{nums2[0], nums2[1], nums2[2]}));\n        \n        int[] nums3 = {-1, -10, 0, 2};\n        System.out.println(\"Maximum Product of Three Numbers for \" + Arrays.toString(nums3) + \": \" + maximumProduct(new int[]{nums3[0], nums3[1], nums3[2]}));\n    }\n\n    public static int maximumProduct(int[] nums) {\n        Arrays.sort(nums);\n        return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[0]);\n    }\n}",
  "629": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {2,6,7,8};\n        System.out.println(\"Output for input \" + Arrays.toString(nums1) + \": \" + findKInversePairs(3, nums1));\n\n        int[] nums2 = {1,3,2,1,3};\n        System.out.println(\"Output for input \" + Arrays.toString(nums2) + \": \" + findKInversePairs(2, nums2));\n\n        int[] nums3 = {1,4,5,2,7};\n        System.out.println(\"Output for input \" + Arrays.toString(nums3) + \": \" + findKInversePairs(0, nums3));\n    }\n\n    public static int findKInversePairs(int K, int[] P) {\n        // your logic here\n        return 0; // just a placeholder, replace it with the actual code\n    }\n}",
  "630": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] prerequisites = {{1,0},{2,0}};\n        System.out.println(\"Test case 1: \" + courseSchedule(prerequisites));\n        \n        int[][] prerequisites2 = {{1,4},{2,5},{3,4},{4,7},{5,6},{6,7},{8,9}};\n        System.out.println(\"Test case 2: \" + courseSchedule(prerequisites2));\n\n        int[][] prerequisites3 = {{1,0}};\n        System.out.println(\"Test case 3: \" + courseSchedule(prerequisites3));\n    }\n\n    public static boolean canFinish(int numCourses, int[][] prerequisites) {\n        List<Integer> order = new ArrayList<>();\n        int[] inDegree = new int[numCourses];\n        \n        for (int i = 0; i < numCourses; i++) {\n            inDegree[i] = 0;\n        }\n        \n        for (int i = 0; i < prerequisites.length; i++) {\n            int course = prerequisites[i][0];\n            int prereq = prerequisites[i][1];\n            inDegree[prereq]++;\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        \n        for (int i = 0; i < numCourses; i++) {\n            if (inDegree[i] == 0) {\n                queue.add(i);\n            }\n        }\n        \n        while (!queue.isEmpty()) {\n            int course = queue.poll();\n            order.add(course);\n            \n            for (int i = 0; i < prerequisites.length; i++) {\n                if (prerequisites[i][0] == course) {\n                    inDegree[prerequisites[i][1]]--;\n                    if (inDegree[prerequisites[i][1]] == 0) {\n                        queue.add(prerequisites[i][1]);\n                    }\n                }\n            }\n        }\n        \n        if (order.size() < numCourses) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n}\n```",
  "631": "```\npublic class ExcelSumFormula {\n    public static void main(String[] args) {\n        // Test case 1\n        int[][] cells = {{}, {\"A1\",\"B2\"}};\n        String[] formula = {\"SUM(A1:B2)\"};\n        System.out.println(\"Test Case 1: \" + excelColIndex(ExcelSumFormula.new FormulaParser().parse(formula).evaluate(cells)));\n\n        // Test case 2\n        int[][] cells1 = {{}, {\"A1\",\"B2\", \"C3\"}};\n        formula = new String[]{\"SUM(A1:C3)\"};\n        System.out.println(\"Test Case 2: \" + ExcelSumFormula.new FormulaParser().parse(formula).evaluate(cells1));\n\n        // Test case 3\n        int[][] cells2 = {{}, {\"A1\",\"B2\", \"C3\", \"D4\"}};\n        formula = new String[]{\"SUM(A1:D4)\"};\n        System.out.println(\"Test Case 3: \" + ExcelSumFormula.new FormulaParser().parse(formula).evaluate(cells2));\n    }\n}\n\nclass Cell {\n    int row;\n    String col;\n\n    public Cell(int row, String col) {\n        this.row = row;\n        this.col = col;\n    }\n\n    @Override\n    public String toString() {\n        return \"Cell{\" +\n                \"row=\" + row +\n                \", col='\" + col + '\\'' +\n                '}';\n    }\n}\n\nclass FormulaParser {\n    Map<String, Cell> cellMap;\n\n    public FormulaParser() {\n        cellMap = new HashMap<>();\n    }\n\n    public int evaluate(int[][] cells) {\n        // This is a placeholder method. You would implement the actual evaluation logic here.\n        return 0;\n    }\n\n    public String parse(String[] formulas) {\n        for (String formula : formulas) {\n            String[] parts = formula.split(\"\\\\((.*)\\\\)\");\n            if (!parts[1].isEmpty()) {\n                int row = Integer.parseInt(parts[1].split(\":\")[0].substring(1));\n                String col = parts[1].split(\":\")[1].substring(1);\n                cellMap.put(col, new Cell(row, col));\n            }\n        }\n        return \"\";\n    }\n\n    public int excelColIndex(String col) {\n        int index = 0;\n        for (char c : col.toCharArray()) {\n            if (Character.isUpperCase(c)) {\n                index += Character.toUpperCase(c) - 'A' + 1;\n            } else {\n                index *= 26;\n            }\n        }\n        return index;\n    }\n}\n```",
  "632": "```\nimport java.util.*;\n\nclass Solution {\n    public int[] smallestRange(int[][] nums) {\n        int m = nums.length;\n        int n = nums[0].length;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        \n        int left = 0;\n        int right = 0;\n        for (int i = 0; i < m; i++) {\n            pq.offer(new int[]{i, nums[i][0]});\n        }\n        \n        int minRange = Integer.MAX_VALUE;\n        List<int[]> res = new ArrayList<>();\n        while (!pq.isEmpty()) {\n            int[] arr = pq.poll();\n            right = Math.max(right, arr[1]);\n            \n            if (right - left + 1 < minRange) {\n                minRange = right - left + 1;\n                res.clear();\n                res.add(new int[]{arr[0], left});\n            }\n            \n            for (int i = m - 1; i >= 0 && !pq.isEmpty(); i--) {\n                if (pq.peek()[1] <= right) {\n                    pq.poll();\n                    left = right + 1;\n                } else {\n                    break;\n                }\n            }\n        }\n        \n        int[] resArray = new int[2];\n        res.get(0)[1] = minRange;\n        System.arraycopy(res.get(0), 0, resArray, 0, 2);\n        return resArray;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[][] nums1 = {{4,9},{2,5},{10,19}};\n        System.out.println(\"Test case 1: \" + Arrays.toString(solution.smallestRange(nums1)));\n        \n        // Test case 2\n        int[][] nums2 = {{1,2},{3,5},{6,7}};\n        System.out.println(\"Test case 2: \" + Arrays.toString(solution.smallestRange(nums2)));\n        \n        // Test case 3\n        int[][] nums3 = {{1,10,4},{3,20,5},{8,25,24}};\n        System.out.println(\"Test case 3: \" + Arrays.toString(solution.smallestRange(nums3)));\n    }\n}",
  "633": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int result1 = judgeSquareSum(18);\n        System.out.println(\"Test case 1: \" + result1);\n\n        int result2 = judgeSquareSum(805);\n        System.out.println(\"Test case 2: \" + result2);\n\n        int result3 = judgeSquareSum(987);\n        System.out.println(\"Test case 3: \" + result3);\n    }\n\n    public static boolean judgeSquareSum(int n) {\n        for (int a = 0; ; a++) {\n            int b = (int)Math.sqrt(n - a * a);\n            if (a * a + b * b == n)\n                return true;\n            else if (a * a + b * b > n)\n                break;\n        }\n        return false;\n    }\n}\n```",
  "634": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        System.out.println(derangements(input));\n        \n        input = new int[][]{{1, 0, 2}, {0, 1, 2}, {0, 0, 1}};\n        System.out.println(deranglements(input));\n        \n        input = {{0, 1, 3}, {2, 4, 5}, {6, 7, 8}};\n        System.out.println(derangements(input));\n    }\n\n    public static int derangements(int[][] array) {\n        int n = array.length;\n        if (n == 0) return 1;\n\n        int mod = 1000000007;\n        long[] f = new long[n + 1];\n        f[0] = 1;\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < i; j++) {\n                f[i] += f[j] * (n - i) % mod;\n            }\n        }\n\n        return (int) ((f[n] + mod - 1) % mod);\n    }\n}\n```",
  "635": "```\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class LogSystem {\n\n    private class Log {\n        String ip;\n        int timestamp;\n        String message;\n\n        public Log(String ip, int timestamp, String message) {\n            this.ip = ip;\n            this.timestamp = timestamp;\n            this.message = message;\n        }\n    }\n\n    private Map<String, TreeMap<Integer, List<Log>>> logSystem;\n\n    public LogSystem() {\n        logSystem = new HashMap<>();\n    }\n\n    public void put(String ip, int timestamp, String message) {\n        String hour = leftZeroes(Integer.toString(timestamp / 3600));\n        String minute = leftZeroes(Integer.toString((timestamp / 60) % 60));\n        String second = leftZeroes(Integer.toString(timestamp % 60));\n\n        String key = hour + minute + second;\n        logSystem.computeIfAbsent(ip, k -> new TreeMap<>()).put(timestamp, new ArrayList<>(Arrays.asList(new Log(ip, timestamp, message))));\n    }\n\n    public List<String> retrieve(String ip, int start, int end) {\n        List<String> result = new ArrayList<>();\n        Map<Integer, List<Log>> ipLogs = logSystem.get(ip);\n\n        if (ipLogs != null) {\n            for (int ts : ipLogs.subMap(start, true, end, true).keySet()) {\n                for (Log log : ipLogs.get(ts)) {\n                    result.add(log.ip + \" \" + log.timestamp + \" \" + log.message);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private String leftZeroes(String s) {\n        return String.format(\"%05d\", Integer.parseInt(s));\n    }\n\n    public static void main(String[] args) {\n        LogSystem log = new LogSystem();\n        log.put(\"127.0.0.1\", 911526047, \"Hello\");\n        assertEquals(1, log.retrieve(\"127.0.0.1\", 911528047, 911530047).size);\n        assertEquals(\"127.0.0.1 911526047 Hello\", log.retrieve(\"127.0.0.1\", 911526047, 911530047).get(0));\n        log.put(\"192.168.1.1\", 911537527, \"Hello\");\n        assertEquals(2, log.retrieve(\"127.0.0.1\", 911528047, 911538047).size);\n    }\n}",
  "636": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(exclusiveTimeOut(new String[]{\"A\", \"0:01:04\"}, new String[]{\"A\", \"0:02:16\", \"A\", \"0:03:32\"}));\n        System.out.println(exclusiveTimeOut(new String[]{\"L1\", \"00:34:56\"}, new String[]{\"L1\", \"00:37:04\", \"L2\", \"00:38:29\", \"L1\", \"02:10:16\"}));\n        System.out.println(exclusiveTimeOut(new String[]{\"A\", \"0:01:01\"}, new String[]{\"A\", \"0:14:03\", \"B\", \"0:23:39\"}));\n    }\n\n    public static List<List<Integer>> exclusiveTimeOut(String[] logs) {\n        List<List<Integer>> res = new ArrayList<>();\n        Map<String, Integer> startMap = new HashMap<>();\n        int maxTime = 0;\n        for (String log : logs) {\n            String[] split = log.split(\":\");\n            String func = split[0];\n            int time = Integer.parseInt(split[2].split(\",\")[0]);\n            if (log.startsWith(\"start\")) {\n                startMap.put(func, time);\n            } else {\n                res.add(Arrays.asList(func, time - startMap.getOrDefault(func, 0)));\n                maxTime = Math.max(maxTime, time);\n            }\n        }\n        return res;\n    }\n\n}",
  "637": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(3);\n        root.left = new TreeNode(9);\n        root.right = new TreeNode(20);\n        root.right.left = new TreeNode(15);\n        root.right.right = new TreeNode(7);\n\n        double[] result = averageOfLevels(root);\n\n        System.out.println(Arrays.toString(result));\n\n        // Test case 2\n        root = null;\n        result = averageOfLevels(root);\n        System.out.println(Arrays.toString(result));\n\n        // Test case 3\n        root = new TreeNode(1);\n        result = averageOfLevels(root);\n        System.out.println(Arrays.toString(result));\n    }\n\n    public static double[] averageOfLevels(TreeNode root) {\n        List<Double> averages = new ArrayList<>();\n        if (root == null) return new double[0];\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            double sum = 0;\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                sum += node.val;\n                if (node.left != null) queue.add(node.left);\n                if (node.right != null) queue.add(node.right);\n            }\n            averages.add((double) sum / levelSize);\n        }\n\n        return averages.stream().mapToDouble(Double::doubleValue).toArray();\n    }\n}\n```",
  "638": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(shoppingOffers(new int[]{2,5,3}, new int[][]{{10,25},{3,4}})); // Test Case 1\n        System.out.println(shoppingOffers(new int[]{1,2}, new int[][]{})); // Test Case 2\n        System.out.println(shoppingOffers(new int[]{1,2,3,4}, new int[][]{{5,11},{6,12}})); // Test Case 3\n    }\n\n    public static int shoppingOffers(int[] price, int[][] special) {\n        int n = price.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, price[0]);\n        for (int i = 1; i < n; i++) {\n            dp[i] = Math.max(dp[i-1], price[i]);\n        }\n        for (int[] offer : special) {\n            int val = 0;\n            for (int i = 0; i < offer.length - 1; i++) {\n                val += price[offer[i]];\n            }\n            if (val + offer[offer.length - 1] > dp[offer.length - 2]) {\n                continue;\n            }\n            int newPrice = val;\n            for (int i = offer.length - 1; i < n; i++) {\n                newPrice += price[i];\n            }\n            for (int i = 0; i < n; i++) {\n                dp[i] = Math.max(dp[i], newPrice);\n            }\n        }\n        return dp[n-1];\n    }\n}\n```",
  "639": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + decodeWays(\"0*2#1\")); // Expected output: 6\n        System.out.println(\"Test case 2: \" + decodeWays(\"123\")); // Expected output: 3\n        System.out.println(\"Test case 3: \" + decodeWays(\"26\")); // Expected output: 2\n    }\n\n    public static int decodeWays(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        int[] dp = new int[s.length()];\n        dp[0] = 1;\n        for (int i = 1; i < s.length(); i++) {\n            if (Character.isDigit(s.charAt(i))) {\n                dp[i] = dp[i - 1];\n            } else if ((s.charAt(i) == '0' && Character.isDigit(s.charAt(i - 1)))) {\n                dp[i] = dp[i - 2];\n            } else {\n                dp[i] = dp[i - 1] + (dp[i - 1] > 0 ? 1 : 0);\n            }\n        }\n        return dp[s.length() - 1];\n    }\n}",
  "640": "```\npublic class Solution {\n    public String solveEquation(String equation) {\n        // your solution here\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.solveEquation(\"x+2=3\")); \n        System.out.println(solution.solveEquation(\"2x=x+1\")); \n        System.out.println(solution.solveEquation(\"x*x+5*x-6=0\"));\n    }\n}\n```",
  "641": "```\npublic class Main {\n    public static void main(String[] args) {\n        MyCircularDeque obj = new MyCircularDeque(8);\n\n        System.out.println(obj.insertLast(45)); // Returns true or false\n        System.out.println(obj.insertFront(30)); // Returns true or false\n        System.out.println(obj.deleteLast());  // Returns true or false\n    }\n}\n\nclass MyCircularDeque {\n    private int[] data;\n    private int front;\n    private int rear;\n\n    public MyCircularDeque(int k) {\n        data = new int[k];\n        front = 0;\n        rear = 0;\n    }\n\n    public boolean insertFront(int value) {\n        if ((rear - front + 1) % data.length == 0) {\n            return false; // deque is full\n        }\n        if (front == 0) {\n            front = 1; // circular boundary\n        } else {\n            front--;\n        }\n        data[front] = value;\n        return true;\n    }\n\n    public boolean insertLast(int value) {\n        if ((rear + 1) % data.length == front) {\n            return false; // deque is full\n        }\n        data[rear] = value;\n        rear = (rear + 1) % data.length;\n        return true;\n    }\n\n    public boolean deleteFront() {\n        if (front == rear) {\n            return false; // deque is empty\n        }\n        front = (front + 1) % data.length;\n        return true;\n    }\n\n    public boolean deleteLast() {\n        if (front == rear) {\n            return false; // deque is empty\n        }\n        rear = (rear - 1 + data.length) % data.length;\n        return true;\n    }\n\n    public int getFront() {\n        if (front == rear) {\n            return -1; // deque is empty\n        }\n        return data[front];\n    }\n\n    public int getRear() {\n        if (front == rear) {\n            return -1; // deque is empty\n        }\n        return data[(rear - 1 + data.length) % data.length];\n    }\n\n    public boolean isEmpty() {\n        return front == rear;\n    }\n\n    public boolean isFull() {\n        return (rear + 1) % data.length == front;\n    }\n}",
  "642": "```\nimport java.util.*;\n\nclass AutocompleteSystem {\n    class TrieNode {\n        Map<Character, TrieNode> children = new HashMap<>();\n        String content;\n    }\n\n    TrieNode root;\n\n    public AutocompleteSystem(String[] sentences) {\n        root = new TrieNode();\n        for (String sentence : sentences) {\n            TrieNode node = root;\n            for (char c : sentence.toCharArray()) {\n                if (!node.children.containsKey(c)) {\n                    node.children.put(c, new TrieNode());\n                }\n                node = node.children.get(c);\n            }\n            node.content = sentence;\n        }\n    }\n\n    public List<String> input(char c) {\n        List<String> result = new ArrayList<>();\n        TrieNode node = root;\n        while (node.children.containsKey(c)) {\n            node = node.children.get(c);\n            if (node.content != null) {\n                result.add(node.content);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        AutocompleteSystem system = new AutocompleteSystem(new String[]{\"i love you\", \"isabella sought to\", \"i ate it\"});\n        System.out.println(system.input('i')); // [\"i love you\",\"isabella sought to\"]\n        System.out.println(system.input('s')); // [\"isabella sought to\"]\n        System.out.println(system.input('a')); // []",
  "643": "```\npublic class Main {\n    public static void main(String[] args) {\n        int result1 = maxAverage(new int[]{1, 12,-5, -6, 50, 3}), 9, 1});\n        System.out.println(\"Test case 1: \" + result1);\n        \n        int result2 = maxAverage(new int[]{-1, -10, 3, 2});\n        System.out.println(\"Test case 2: \" + result2);\n        \n        int result3 = maxAverage(new int[]{0, -4, 0, 2, 7, -5, 7, 8, -3, -5});\n        System.out.println(\"Test case 3: \" + result3);\n    }\n    \n    public static double maxAverage(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        \n        int sum = 0, maxSum = nums[0], minSum = nums[0];\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            maxSum = Math.max(maxSum, sum);\n            if (i > 0) {\n                sum -= nums[i - 1];\n                minSum = Math.min(minSum, sum);\n            }\n        }\n        \n        return (maxSum + minSum) / 2.0;\n    }\n}\n```",
  "644": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + maxAverage(new int[]{1,12,-5,-6,50,3}, 3));\n        System.out.println(\"Test Case 2: \" + maxAverage(new int[]{0,-4,-3,2,10,8,-200,15}, 9));\n        System.out.println(\"Test Case 3: \" + maxAverage(new int[]{-7,1,5,13,21}, 6));\n    }\n\n    public static double maxAverage(int[] nums, int k) {\n        int n = nums.length;\n        long sum = 0;\n        for (int i = 0; i < k; i++) {\n            sum += nums[i];\n        }\n        long maxSum = sum;\n        long minSum = sum;\n\n        for (int i = k; i < n; i++) {\n            sum = sum - nums[i-k] + nums[i];\n            maxSum = Math.max(maxSum, sum);\n            minSum = Math.min(minSum, sum);\n        }\n        \n        return (double)(maxSum - minSum) / (n - k + 1);\n    }\n}",
  "645": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums = {{1,2,3},{2,3},{}};\n        for (int i = 0; i < nums.length; i++) {\n            System.out.println(\"Test case \" + (i+1) + \":\");\n            System.out.println(\"Result: \" + findErrorNums(nums[i][0], nums[i]).toString());\n            System.out.println();\n        }\n    }\n\n    public static int[] findErrorNums(int[] nums) {\n        int[] result = new int[2];\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            if (!map.containsKey(num)) {\n                map.put(num, 1);\n            } else {\n                map.put(num, map.get(num) + 1);\n            }\n        }\n\n        for (int i = 1; i <= nums.length; i++) {\n            if (!map.containsKey(i) || map.get(i) == 0) {\n                result[0] = i;\n            } else if (map.get(i) > 1) {\n                result[1] = i;\n            }\n        }\n\n        return result;\n    }\n}",
  "646": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] inputs = {\n            {{1, 5},{2, 3},{3, 4}},\n            {{20, 50},{10, 40},{5, 25},{35, 39},{30, 60},{45, 65},{70, 80}},\n            {{0, 9}]\n        };\n\n        for (int i = 0; i < inputs.length; i++) {\n            System.out.println(\"Maximum Length of Pair Chain: \" + findMaxLength(inputs[i]));\n        }\n    }\n\n    public static int findMaxLength(int[][] pairs) {\n        Arrays.sort(pairs, (a, b) -> a[1] - b[1]);\n        int maxLength = 0;\n        int lastEnd = Integer.MIN_VALUE;\n\n        for (int[] pair : pairs) {\n            if (pair[0] > lastEnd) {\n                maxLength++;\n                lastEnd = pair[1];\n            }\n        }\n\n        return maxLength;\n    }\n}\n```",
  "647": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countSubstrings(\"abc\")); // Expected output: 3\n        System.out.println(countSubstrings(\"a\")); // Expected output: 1\n        System.out.println(countSubstrings(\"aaa\")); // Expected output: 6\n    }\n\n    public static int countSubstrings(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            count += countPalindrome(s, i, i); // odd length palindromes\n            count += countPalindrome(s, i, i + 1); // even length palindromes\n        }\n        return count;\n    }\n\n    public static int countPalindrome(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left + 1;\n    }\n}\n```",
  "649": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countPairs(\"WDDDDDDWWWWWW\", 1)); // Expected: 8\n        System.out.println(countPairs(\"WWWWWWWWWW\", 1)); // Expected: 12\n        System.out.println(countPairs(\"LLLLUUUUUL\", 3)); // Expected: 4\n    }\n\n    public static int countPairs(String vote, int k) {\n        int W = 0, L = 0;\n        for (char c : vote.toCharArray()) {\n            if (c == 'W') W++;\n            else L++;\n        }\n        return Math.min(W / k, L / k);\n    }\n}",
  "648": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(replaceWords(new String[]{\"cat\",\"bt\",\"hello\"}, \"hit\")); // expected output: [\"hits\"]\n        System.out.println(replaceWords(new String[]{\"kthttp://www.google.com/\",\"kthttp://www.leetcode.com/\",\"log\",\"whoisit\"), \"a\")); // expected output: [\"http://www.google.com/a\",\"http://www.leetcode.com/a\",\"log\",\"whoisit\"]\n        System.out.println(replaceWords(new String[]{\"hello\",\"hi\",\"hive\"}, \"ii\"));// expected output: [\"ihh\",\"ih\"]\n    }\n\n    public static List<String> replaceWords(String[] words, String sentence) {\n        TrieNode root = new TrieNode();\n        for (String word : words) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                if (!node.children.containsKey(c)) {\n                    node.children.put(c, new TrieNode());\n                }\n                node = node.children.get(c);\n            }\n            node.endOfWord = true;\n        }\n\n        List<String> result = new ArrayList<>();\n        StringBuilder sb = new StringBuilder();\n        for (char c : sentence.toCharArray()) {\n            TrieNode node = root;\n            while (node != null && !node.endOfWord) {\n                node = node.children.get(c);\n                if (node == null) {\n                    break;\n                }\n            }\n            if (node != null) {\n                sb.append(node.word);\n            } else {\n                sb.append(c);\n            }\n        }\n        result.add(sb.toString());\n        return result;\n    }\n\n    static class TrieNode {\n        Map<Character, TrieNode> children = new HashMap<>();\n        boolean endOfWord;\n        String word;\n\n        public TrieNode() {\n            word = \"\";\n        }\n    }\n}",
  "650": "```\npublic class Solution {\n    public int minSteps(String s) {\n        int steps = 0;\n        int countA = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'a') {\n                countA++;\n            } else {\n                steps += Math.max(0, countA);\n                countA = 0;\n            }\n        }\n        return steps + Math.max(0, countA);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.minSteps(\"aaaa...a\")); // Expected: 6\n        System.out.println(solution.minSteps(\"cooking\")); // Expected: 1\n        System.out.println(solution.minSteps(\"thereisno0\"); // Expected: 9\n    }\n}",
  "651": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minStepsToMakeKeys(\"abcdefghijklmnopqrstuvwxyz\", \"aaaaccckkstttuu\"));//test case1\n        System.out.println(minStepsToMakeKeys(\"abcdefghijklmnopqrstuvwxyz\", \"ba1b1a1b1a1b1a\"));//test case2\n        System.out.println(minStepsToMakeKeys(\"abcdefghijklmnopqrstuvwxyz\", \"leet1234in\"));//test case3\n    }\n\n    public static int minStepsToMakeKeys(String str, String keys) {\n        // your code here\n    }\n}\n```",
  "652": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(2);\n        root1.right.right = new TreeNode(4);\n\n        System.out.println(findDuplicateSubtrees(root1));\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n        root2.left.left = new TreeNode(4);\n        root2.left.right = new TreeNode(5);\n\n        System.out.println(findDuplicateSubtrees(root2));\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n        root3.right = new TreeNode(3);\n        root3.left.left = new TreeNode(2);\n        root3.right.left = new TreeNode(4);\n        root3.right.right = new TreeNode(5);\n\n        System.out.println(findDuplicateSubtrees(root3));\n    }\n\n    public static List<String> findDuplicateSubtrees(TreeNode root) {\n        Map<String, Integer> map = new HashMap<>();\n        List<String> result = new ArrayList<>();\n\n        findDuplicateSubtreesHelper(root, map, result);\n\n        return result;\n    }\n\n    private static void findDuplicateSubtreesHelper(TreeNode node, Map<String, Integer> map, List<String> result) {\n        if (node == null) {\n            return;\n        }\n\n        String serial = \"\";\n        TreeNode temp = node;\n\n        while (temp != null) {\n            serial += temp.val + \",\";\n            temp = temp.left;\n        }\n        temp = node.right;\n        while (temp != null) {\n            serial += temp.val + \",\";\n            temp = temp.right;\n        }\n\n        if (map.containsKey(serial)) {\n            map.put(serial, map.get(serial) + 1);\n            if (map.get(serial) == 2) {\n                result.add(\"[\" + node.val + \",\" + serial.substring(0, serial.length() - 1) + \"]\");\n            }\n        } else {\n            map.put(serial, 1);\n        }\n\n        findDuplicateSubtreesHelper(node.left, map, result);\n        findDuplicateSubtreesHelper(node.right, map, result);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) { val = x; }\n}\n```",
  "653": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + twoSum(new TreeNode(5), 5, 10));\n        System.out.println(\"Test case 2: \" + twoSum(new TreeNode(3), 8, 12));\n        System.out.println(\"Test case 3: \" + twoSum(null, 20, 30));\n\n    }\n\n    public static boolean twoSum(TreeNode root, int target, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        Set<Integer> set = new HashSet<>();\n\n        while (root != null || !set.isEmpty()) {\n            if (root != null) {\n                int left = search(root.left, map);\n                if (left >= 0) {\n                    if (map.containsKey(target - k + left)) return true;\n                    map.put(target - k + left, root.val);\n                } else {\n                    set.add(root.val);\n                }\n                root = root.right;\n            } else {\n                int right = search(set, map);\n                if (right >= 0) {\n                    if (map.containsKey(target - k + right)) return true;\n                    map.put(target - k + right, set.iterator().next());\n                } else {\n                    break;\n                }\n                set.remove(set.iterator().next());\n            }\n        }\n        return false;\n    }\n\n    public static int search(TreeNode node, Map<Integer, Integer> map) {\n        if (node == null) return 0;\n        if (map.containsKey(node.val)) return map.get(node.val);\n        int left = search(node.left, map);\n        if (left >= 0) return left;\n        map.put(node.val, node.val);\n        return search(node.right, map);\n    }\n\n    public static int search(Set<Integer> set, Map<Integer, Integer> map) {\n        for (int num : set) {\n            if (map.containsKey(num)) return num;\n        }\n        return 0;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) {\n        val = x;\n    }\n}",
  "654": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + new Solution().constructMaximumBinaryTree(new int[]{6,2,5,4,5,1,6})); // Expected output: [6,4,5,3,null,null,2]\n        System.out.println(\"Test case 2: \" + new Solution().constructMaximumBinaryTree(new int[]{3,2,1,6,0,2,5,4})) ;// Expected output: [6,4,5,3,2,null,null,null,null,null,null,0,1]\n        System.out.println(\"Test case 3: \" + new Solution().constructMaximumBinaryTree(new int[]{4,2,7,1,3,6,5})); // Expected output: [7,2,6,1,null,null,null,null,null,null,4,5,3]\n\n    }\n}\n\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        if (nums == null || nums.length == 0) return null;\n        \n        int maxIndex = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[maxIndex]) {\n                maxIndex = i;\n            }\n        }\n        \n        TreeNode root = new TreeNode(nums[maxIndex]);\n        root.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, 0, maxIndex));\n        root.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + 1, nums.length));\n        \n        return root;\n    }\n\n    public class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode() {}\n        TreeNode(int val) { this.val = val; }\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }\n}",
  "655": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root1 = new Node(1);\n        root1.left = new Node(2);\n        root1.right = new Node(3);\n        root1.left.left = new Node(4);\n        root1.left.right = new Node(5);\n\n        printTree(root1);\n\n        System.out.println();\n\n        Node root2 = new Node(8);\n        root2.left = new Node(9);\n        root2.right = new Node(10);\n        root2.left.left = new Node(11);\n        root2.left.right = new Node(12);\n        root2.right.left = new Node(13);\n        root2.right.right = new Node(14);\n\n        printTree(root2);\n\n        System.out.println();\n\n        Node root3 = null;\n\n        printTree(root3);\n    }\n\n    public static void printTree(Node node) {\n        if (node == null) return;\n        System.out.print(node.val + \" \");\n        printTree(node.left);\n        printLayer(node, 0);\n    }\n\n    private static void printLayer(Node node, int level) {\n        if (node == null) return;\n        if (level > 0) System.out.print(\" \");\n        for (int i = 0; i < level; i++) System.out.print(\"     \");\n        System.out.println(node.val);\n        printLayer(node.left, level + 1);\n        printLayer(node.right, level + 1);\n    }\n}\n\nclass Node {\n    int val;\n    Node left;\n    Node right;\n\n    public Node(int val) {\n        this.val = val;\n    }\n}\n```",
  "657": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canPlaceFlowers(new String[]{\"\", \"\", \"\"}, 1) + \" \"); // Test case 1\n        System.out.println(canPlaceFlowers(new String[]{\"\", \"X\", \"\"}, 2) + \" \"); // Test case 2\n        System.out.println(canPlaceFlowers(new String[]{\".\", \"X\", \".\"}, 3) + \" \"); // Test case 3\n    }\n\n    public static boolean canPlaceFlowers(String[] flowers, int n) {\n        for (int i = 0; i < flowers.length; i++) {\n            if (flowers[i].equals(\"X\")) continue;\n            if (i > 0 && !flowers[i - 1].equals(\".\")) break;\n            if (i == flowers.length - 1 || !flowers[i + 1].equals(\".\")) return true;\n        }\n        return false;\n    }\n}\n```",
  "656": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minCoinPath(new int[]{1, 2, 5}, new int[]{5, 3, 4}, 500)) + \"\\n\");\n        System.out.println(minCoinPath(new int[]{3, 7, 9}, new int[]{2, 6, 8}, 300)) + \"\\n\");\n        System.out.println(minCoinPath(new int[]{1, 4, 10}, new int[]{1, 5, 3}, 20));\n    }\n\n    public static int minCoinPath(int[] coins, int[] amount, int target) {\n        int[][] dp = new int[amount.length][target + 1];\n        for (int i = 0; i <= target; i++) {\n            if (i % amount[0] == 0) {\n                dp[0][i] = i / amount[0];\n            } else {\n                dp[0][i] = Integer.MAX_VALUE;\n            }\n        }\n\n        for (int i = 1; i < amount.length; i++) {\n            for (int j = 0; j <= target; j++) {\n                if (j % amount[i] == 0) {\n                    dp[i][j] = Math.min(dp[i - 1][j], j / amount[i]) + 1;\n                } else {\n                    dp[i][j] = Integer.MAX_VALUE;\n                }\n            }\n        }\n\n        return dp[amount.length - 1][target];\n    }\n}\n```",
  "658": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr = {{1,2,3,4,5},{0,10,20,30,40},{100,101}};\n        for (int i = 0; i < arr.length; i++) {\n            findClosestElements(arr[i], 3);\n        }\n    }\n\n    public static void findClosestElements(int[] arr, int k) {\n        Arrays.sort(arr);\n        int left = 0;\n        int right = arr.length - k;\n\n        for (int i = 0; i < arr.length; i++) {\n            if (i >= right) {\n                break;\n            }\n            System.out.println(\"Closest elements: \");\n            for (int j = i; j < Math.min(i + k, arr.length); j++) {\n                System.out.print(arr[j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "659": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {{1}, {1, 2}, {0}};\n        for (int i = 0; i < inputs.length; i++) {\n            System.out.println(\"Input: \" + Arrays.toString(inputs[i]) + \", Output: \" + splitArray(inputToMap(inputs[i])) + \".\");\n        }\n    }\n\n    public static int splitArray(int[] nums) {\n        Map<Integer, Integer> numCount = new HashMap<>();\n        for (int num : nums) {\n            numCount.put(num, numCount.getOrDefault(num, 0) + 1);\n        }\n        \n        List<List<Integer>> res = new ArrayList<>();\n        while (!numCount.isEmpty()) {\n            boolean found = false;\n            int maxKey = -1;\n            for (Map.Entry<Integer, Integer> entry : numCount.entrySet()) {\n                if (entry.getValue() > 0 && (maxKey == -1 || entry.getKey() < maxKey)) {\n                    maxKey = entry.getKey();\n                    found = true;\n                    break;\n                }\n            }\n            \n            if (!found) {\n                return -1; // no way to split\n            }\n            \n            List<Integer> list = new ArrayList<>();\n            int curr = maxKey;\n            while (numCount.get(curr) > 0 && numCount.containsKey(curr + 1)) {\n                list.add(curr);\n                numCount.put(curr, numCount.get(curr) - 1);\n                curr++;\n            }\n            res.add(list);\n        }\n        \n        return res.size();\n    }\n\n    public static Map<Integer, Integer> inputToMap(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        return map;\n    }\n}\n```",
  "660": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removeNine(123) == \"12\"); // Test Case 1\n        System.out.println(removeNine(999) == \"0\"); // Test Case 2\n        System.out.println(removeNine(9) == \"0\"); // Test Case 3\n    }\n\n    public static String removeNine(int num) {\n        StringBuilder sb = new StringBuilder();\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit != 9) {\n                sb.insert(0, digit);\n            }\n            num /= 10;\n        }\n        return sb.toString();\n    }\n}\n```",
  "661": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] img1 = {{0,0,0},{0,10,0},{0,0,0}};\n        int[][] expected1 = {{0,0,0},{5,5,5},{0,0,0}};\n        test(img1, expected1);\n\n        int[][] img2 = {{1,1,1},{4,4,4},{7,7,7}};\n        int[][] expected2 = {{3,3,3},{4,4,4},{3,3,3}};\n        test(img2, expected2);\n\n        int[][] img3 = {{10,11,12},{13,14,15},{16,17,18}};\n        int[][] expected3 = {{11,11,11},{13,13,13},{11,11,11}};\n        test(img3, expected3);\n    }\n\n    public static void test(int[][] img, int[][] expected) {\n        for (int i = 0; i < img.length; i++) {\n            for (int j = 0; j < img[0].length; j++) {\n                if (img[i][j] != expected[i][j]) {\n                    System.out.println(\"Test failed. Image: \" + Arrays.deepToString(img) + \", Expected: \" + Arrays.deepToString(expected));\n                    return;\n                }\n            }\n        }\n        System.out.println(\"All test cases passed.\");\n    }\n}\n```",
  "662": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] expect = {new Integer[]{6}, new Integer[]{2,4,5}, new Integer[]{1,3}};\n        TreeNode tree1 = TreeNode.createTree(new Integer[]{1,3,2,null,null,4,5,7});\n        System.out.println(\"Width of tree 1: \" + widthOfBinaryTree(tree1));\n        \n        TreeNode tree2 = TreeNode.createTree(new Integer[]{1,3});\n        System.out.println(\"Width of tree 2: \" + widthOfBinaryTree(tree2));\n\n        TreeNode tree3 = TreeNode.createTree(new Integer[]{1,2});\n        System.out.println(\"Width of tree 3: \" + widthOfBinaryTree(tree3));\n    }\n\n    public static int widthOfBinaryTree(TreeNode root) {\n        if (root == null)\n            return 0;\n        int maxWid = 0;\n        Queue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            int levelSize = q.size();\n            int minLeft = Integer.MAX_VALUE, maxRight = 0;\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = q.poll();\n                if (node.left != null)\n                    q.add(node.left);\n                if (node.right != null)\n                    q.add(node.right);\n                minLeft = Math.min(minLeft, node.val);\n                maxRight = Math.max(maxRight, node.val);\n            }\n            maxWid = Math.max(maxWid, maxRight - minLeft + 1);\n        }\n        return maxWid;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n\n    static class Builder {\n        private TreeNode root;\n\n        public Builder(int[] nodes) {\n            for (int i = 0; i < nodes.length; i++) {\n                if ((i << 1) + 1 >= nodes.length)\n                    break;\n                int left = i << 1 | 1;\n                int right = left + 1;\n                if (nodes[left] != null && nodes[right] != null) {\n                    root = new TreeNode(nodes[left]);\n                    root.right = new TreeNode(nodes[right]);\n                    root.left = null;\n                } else if (nodes[left] != null) {\n                    root = new TreeNode(nodes[left]);\n                    root.right = null;\n                    root.left = null;\n                }\n            }\n        }\n\n        public TreeNode createTree(int[] nodes) {\n            return root;\n        }\n    }\n}\n```",
  "663": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canCrossPartition(new TreeNode(10), 5)); // Expected: true\n        System.out.println(canCrossPartition(new TreeNode(6), 6)); // Expected: false\n        System.out.println(canCrossPartition(new TreeNode(1, new TreeNode(2, new TreeNode(3), null), new TreeNode(4, null, new TreeNode(5)) ), 7)); // Expected: true\n    }\n}\n\nclass Solution {\n    public boolean canCrossPartition(TreeNode root, int target) {\n        if (root.val > target) return false;\n        if (Math.abs(root.val - target) <= 0) return true;\n\n        return canCrossPartition(root.left, target - root.val) || canCrossPartition(root.right, target - root.val);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n```",
  "664": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSteps(\"aba\", \"aba\"));\n        System.out.println(minSteps(\"abc\", \"cba\"));\n        System.out.println(minSteps(\"aaabbbcccddd\", \"abcdefg\"));\n    }\n\n    public static int minSteps(String s, String t) {\n        int m = s.length();\n        int n = t.length();\n\n        if (m != n) return -1;\n\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = Math.max(i, j);\n                } else if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n}\n```",
  "665": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numOfArrays(new int[]{4,2,3}) + \" expected: 2\");\n        System.out.println(numOfArrays(new int[]{7,6,5,4,3}) + \" expected: 0\");\n        System.out.println(numOfArrays(new int[]{1,2,10,11,1,2}) + \" expected: 1\");\n    }\n\n    public static int numOfArrays(int[] nums) {\n        if (nums.length < 2) return 1;\n        int count = 1;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] <= nums[i - 1]) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n}\n```",
  "666": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(0);\n        root1.right = new TreeNode(0);\n        root1.left.left = new TreeNode(1);\n        System.out.println(pathSum(root1, 5)); // expected: 2\n\n        TreeNode root2 = new TreeNode(10);\n        root2.left = new TreeNode(5);\n        root2.right = new TreeNode(-3);\n        root2.left.left = new TreeNode(3);\n        root2.left.right = new TreeNode(2);\n        System.out.println(pathSum(root2, 8)); // expected: 1\n\n        TreeNode root3 = new TreeNode(5);\n        System.out.println(pathSum(root3, 10)); // expected: 2\n    }\n\n    public static int pathSum(TreeNode root, int sum) {\n        if (root == null) return 0;\n        \n        int count = dfs(root, sum);\n        return count + pathSum(root.left, sum) + pathSum(root.right, sum);\n    }\n\n    private static int dfs(TreeNode node, int sum) {\n        if (node == null) return 0;\n\n        sum -= node.val;\n        if (sum == 0 && node.left == null && node.right == null) return 1;\n        return dfs(node.left, sum) + dfs(node.right, sum);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "667": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n = 2;\n        System.out.println(\"Expected: [1, 2]\\nActual: \" + beautifulArrangmentII(n));\n        \n        n = 3;\n        System.out.println(\"\\nExpected: [1, 3, 2]\\nActual: \" + beautifulArrangmentII(n));\n        \n        n = 4;\n        System.out.println(\"\\nExpected: [1, 3, 4, 2]\\nActual: \" + beautifulArrangmentII(n));\n    }\n\n    public static String beautifulArrangmentII(int n) {\n        StringBuilder sb = new StringBuilder();\n        boolean[] used = new boolean[n + 1];\n        dfs(sb, \"\", 0, used);\n        return sb.toString();\n    }\n\n    private static void dfs(StringBuilder sb, String cur, int lastUsed, boolean[] used) {\n        if (cur.length() == sb.length()) {\n            sb.append(cur);\n            return;\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            if (!used[i]) {\n                if (i % lastUsed != 0) {\n                    used[i] = true;\n                    dfs(sb, cur + String.valueOf(i), i, used);\n                    used[i] = false;\n                }\n            }\n        }\n    }\n}",
  "668": "```\npublic class Main {\n    public static void main(String[] args) {\n        findKthSmaller(new int[][]{{1,1},{1,2},{1,3}}, 8);\n        findKthSmaller(new int[][]{{5,13},{9,4},{3,7}},{8});\n        findKthSmaller(new int[][]{{1,2}},{1});\n    }\n\n    public static void findKthSmaller(int[][] logs, int k) {\n        Arrays.sort(logs, (a, b) -> Integer.compare(b[0], a[0]));\n        int left = 1;\n        int right = 30000;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            int count = 0;\n            for (int[] log : logs) {\n                if (log[1] >= mid) {\n                    count += (log[0] - log[1]) / (mid - 1) + 1;\n                }\n            }\n\n            if (count < k) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        System.out.println(\"The \" + k + \"th smallest number is: \" + left);\n    }\n}\n```",
  "669": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(3);\n        root1.right = new TreeNode(6);\n        root1.left.left = new TreeNode(2);\n        root1.left.right = new TreeNode(4);\n\n        trimBST(root1, 0, 6);\n\n        System.out.println(\"Test case 1: \");\n        printTree(root1);\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(0);\n        root2.right = new TreeNode(2);\n\n        trimBST(root2, 1, 3);\n\n        System.out.println(\"Test case 2: \");\n        printTree(root2);\n\n        TreeNode root3 = new TreeNode(5);\n        root3.left = new TreeNode(-3);\n        root3.right = new TreeNode(11);\n\n        trimBST(root3, -2, 9);\n\n        System.out.println(\"Test case 3: \");\n        printTree(root3);\n    }\n\n    public static void printTree(TreeNode node) {\n        if (node == null) return;\n        System.out.print(node.val + \" \");\n        printTree(node.left);\n        print.out(node.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "670": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {3, 4, 5, 0};\n        System.out.println(\"Maximum Swap for nums1: \" + maximumSwap(nums1));\n        \n        int[] nums2 = {7,6,4,3,1};\n        System.out.println(\"Maximum Swap for nums2: \" + maximumSwap(nums2));\n        \n        int[] nums3 = {1, 3, 2};\n        System.out.println(\"Maximum Swap for nums3: \" + maximumSwap(nums3));\n    }\n\n    public static int maximumSwap(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nums[j] > nums[i]) {\n                    return Math.max(maximumSwapRecursive(nums, i, j), maximumSwapRecursive(nums, j, i));\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static int maximumSwapRecursive(int[] nums, int i, int j) {\n        while (i < j) {\n            if (nums[i] > nums[j]) {\n                return Math.max(maximumSwapRecursiveRecursive(nums, i + 1, j), maximumSwapRecursiveRecursive(nums, i, j - 1));\n            }\n            i++;\n            j--;\n        }\n        return Math.max(nums[i], nums[j]);\n    }\n\n    public static int maximumSwapRecursiveRecursive(int[] nums, int i, int j) {\n        if (i >= j) {\n            return nums[i];\n        } else {\n            return Math.max(maximumSwapRecursiveRecursive(nums, i + 1, j), maximumSwapRecursiveRecursive(nums, i, j - 1));\n        }\n    }\n}",
  "672": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numLightFlickers(3)); // Expected output: 2\n        System.out.println(numLightFlickers(4)); // Expected output: 1\n        System.out.println(numLightFlickers(5)); // Expected output: 0\n    }\n\n    public static int numLightFlickers(int n) {\n        return (n + 1) / 3;\n    }\n}\n```",
  "671": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root = new Node(2);\n        root.left = new Node(1);\n        root.right = new Node(3);\n        \n        System.out.println(\"Test case 1: \");\n        System.out.println(\"Expected: 1, Got: \" + findSecondMinimumValue(root));\n        \n        root = new Node(5);\n        root.left = new Node(4);\n        root.right = new Node(7);\n        root.left.left = new Node(3);\n        \n        System.out.println(\"\\nTest case 2: \");\n        System.out.println(\"Expected: 3, Got: \" + findSecondMinimumValue(root));\n        \n        root = new Node(8);\n        root.left = new Node(6);\n        root.right = new Node(9);\n        \n        System.out.println(\"\\nTest case 3: \");\n        System.out.println(\"Expected: null, Got: \" + findSecondMinimumValue(root));\n    }\n\n    public static Integer findSecondMinimumValue(Node root) {\n        if (root == null || root.val >= root.left.val && root.val >= root.right.val) {\n            return null;\n        }\n        \n        int firstMin = root.left.val;\n        int secondMin = root.right.val;\n\n        Node node = root;\n        while (node != null) {\n            if (node.val < firstMin) {\n                secondMin = firstMin;\n                firstMin = node.val;\n            } else if (node.val > firstMin && node.val <= secondMin) {\n                secondMin = node.val;\n            }\n            node = node.left;\n        }\n\n        return secondMin == Integer.MAX_VALUE ? null : secondMin;\n    }\n}\n\nclass Node {\n    int val;\n    Node left, right;\n\n    public Node(int val) {\n        this.val = val;\n    }\n}\n```",
  "673": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] input1 = {{1,3,5,4,2}};\n        System.out.println(\"Test Case 1: \" + numberOfLongestIncreasingSubsequence(input1));\n        \n        int[][] input2 = {{1,3}};\n        System.out.println(\"Test Case 2: \" + numberOfLongestIncreasingSubsequence(input2));\n        \n        int[][] input3 = {{1,2,3,4,5}};\n        System.out.println(\"Test Case 3: \" + numberOfLongestIncreasingSubsequence(input3));\n    }\n\n    public static int numberOfLongestIncreasingSubsequence(int[][] A) {\n        if (A.length == 0) return 0;\n\n        int m = A[0].length;\n        int[] dp = new int[m];\n        Arrays.fill(dp, 1);\n\n        for (int i = 0; i < A.length; i++) {\n            int max = -1;\n            for (int j = 0; j < m; j++) {\n                if (dp[j] > max) max = dp[j];\n\n                for (int k = j + 1; k < m; k++) {\n                    if (A[i][k] > A[i][j]) dp[k] = Math.max(dp[k], dp[j] + 1);\n                }\n            }\n        }\n\n        int res = -1;\n        for (int i = 0; i < m; i++) {\n            res = Math.max(res, dp[i]);\n        }\n        return res;\n    }\n}\n```",
  "674": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(longestContinuousIncreasingSubsequence(new int[]{1,3,5,4,7}) == 3);\n        System.out.println(longestContinuousIncreasingSubsequence(new int[]{2,1,1,1}) == 2);\n        System.out.println(longestContinuousIncreasingSubsequence(new int[]{0,1}) == 1);\n\n    }\n\n    public static int longestContinuousIncreasingSubsequence(int[] nums) {\n        if (nums.length == 0) return 0;\n        \n        int max = 1;\n        int current = 1;\n\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[i - 1]) {\n                current++;\n            } else {\n                max = Math.max(max, current);\n                current = 1;\n            }\n        }\n\n        return Math.max(max, current);\n    }\n}\n```",
  "675": "```\nimport java.util.*;\n\npublic class Solution {\n    public int cutOffTree(int[][] forest) {\n        // Your implementation here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        int[][] forest1 = {{1,2,3},{8,0,4},{7,6,5}};\n        System.out.println(\"Expected: \" + 8);\n        System.out.println(\"Actual:   \" + solution.cutOffTree(forest1));\n        System.out.println();\n\n        // Test Case 2\n        int[][] forest2 = {{1,2,3},{0,3,4},{7,6,5}};\n        System.out.println(\"Expected: \" + 6);\n        System.out.println(\"Actual:   \" + solution.cutOffTree(forest2));\n        System.out.println();\n\n        // Test Case 3\n        int[][] forest3 = {{1,2},{8,9}};\n        System.out.println(\"Expected: \" + 5);\n        System.out.println(\"Actual:   \" + solution.cutOffTree(forest3));\n        System.out.println();\n    }\n}",
  "676": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        MagicDictionary magic = new MagicDictionary();\n        magic.buildDict(new String[]{\"hello\", \"aloha\"});\n        \n        System.out.println(magic.search(\"hello\")); // returns true\n        System.out.println(magic.search(\"al\"));      // returns false\n        System.out.println(magic.search(\"HAL\"));     // returns true\n    }\n}\n\nclass MagicDictionary {\n    private TrieNode root;\n\n    public MagicDictionary() {\n        this.root = new TrieNode();\n    }\n\n    public void buildDict(String[] dictionary) {\n        for (String word : dictionary) {\n            TrieNode current = root;\n            for (char c : word.toCharArray()) {\n                if (!current.children.containsKey(c)) {\n                    current.children.put(c, new TrieNode());\n                }\n                current = current.children.get(c);\n            }\n            current.isEndOfWord = true;\n        }\n    }\n\n    public boolean search(String query) {\n        TrieNode current = root;\n        for (char c : query.toCharArray()) {\n            if (!current.children.containsKey(c)) {\n                return false;\n            }\n            current = current.children.get(c);\n        }\n        return current.isEndOfWord || !current.children.isEmpty();\n    }\n\n    private class TrieNode {\n        Map<Character, TrieNode> children = new HashMap<>();\n        boolean isEndOfWord;\n\n        public TrieNode() {}\n    }\n}\n```",
  "678": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeValid(\"(()())\")); // true\n        System.out.println(canBeValid(\"()))((\")); // false\n        System.out.println(canBeValid(\"((()))\")); // true\n    }\n\n    public static boolean canBeValid(String s) {\n        int left = 0, right = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') left++;\n            else right++;\n            if (left > right) return false;\n        }\n        left = right = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == '(') right++;\n            else left++;\n            if (right > left) return false;\n        }\n        return true;\n    }\n}\n```",
  "677": "```\npublic class Main {\n    public static void main(String[] args) {\n        MapSum m = new MapSum();\n        m.insert(\"apple\", 3);\n        System.out.println(m.sum(\"ap\")); // returns 3 (apple)\n        System.out.println(m.sum(\"app\")); // returns 1 (as apple will do)\n        System.out.println(m.sum(\"ad\")); // returns 0\n    }\n}\n\nclass MapSum {\n    private class TrieNode {\n        boolean isEnd;\n        Map<Character, TrieNode> children = new HashMap<>();\n    }\n\n    private TrieNode root;\n\n    public MapSum() {\n        this.root = new TrieNode();\n    }\n\n    public void insert(String word, int val) {\n        TrieNode node = root;\n        for (int i = 0; i < word.length(); i++) {\n            char c = word.charAt(i);\n            if (!node.children.containsKey(c)) {\n                node.children.put(c, new TrieNode());\n            }\n            node = node.children.get(c);\n        }\n        node.isEnd = true;\n    }\n\n    public int sum(String prefix) {\n        TrieNode node = root;\n        for (int i = 0; i < prefix.length(); i++) {\n            char c = prefix.charAt(i);\n            if (!node.children.containsKey(c)) {\n                return 0;\n            }\n            node = node.children.get(c);\n        }\n        return dfs(node, true);\n    }\n\n    private int dfs(TrieNode node, boolean isPrefix) {\n        int sum = 0;\n        for (Map.Entry<Character, TrieNode> entry : node.children.entrySet()) {\n            if (!isPrefix || !entry.getValue().isEnd) {\n                sum += dfs(entry.getValue(), false);\n            } else if (isPrefix) {\n                sum++;\n            }\n        }\n        return sum;\n    }\n}\n```",
  "679": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Solution().largestDivisibleSubset(new int[]{4, 6, 8, 10})[0]);\n        System.out.println(new Solution().largestDivisibleSubset(new int[]{1, 2, 3, 4, 5, 6})[0]);\n        System.out.println(new Solution().largestDivisibleSubset(new int[]{7, 13, 16, 24, 28, 32})[0]);\n    }\n}\n\nclass Solution {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n        // Write your solution here\n    }\n}\n```",
  "680": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBePalindrome(\"aba\")); // true\n        System.out.println(canBePalindrome(\"abcde\")); // false\n        System.out.println(canBePalindrome(\"a\")); // true\n    }\n\n    public static boolean canBePalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return isPalindrome(s.substring(0, left + 1)) || isPalindrome(s.substring(left + 1));\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}",
  "681": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(nextClosestTime(\"19:34\")); // Output: \"02:39\"\n        System.out.println(nextClosestTime(\"23:59\")); // Output: \"22:22\"\n        System.out.println(nextClosestTime(\"00:00\")); // Output: \"00:01\"\n    }\n\n    public static String nextClosestTime(String time) {\n        String[] timeArray = time.split(\":\");\n        int hour = Integer.parseInt(timeArray[0]);\n        int minute = Integer.parseInt(timeArray[1]);\n\n        if (hour >= 23 || minute >= 59) {\n            return \"00:00\";\n        }\n\n        for (int i = 0; i <= 1359; i++) { // 1359 is the number of minutes from 00:00 to 23:59\n            int newHour = i / 60;\n            int newMinute = i % 60;\n\n            if (newHour >= hour || (newHour == hour && newMinute >= minute)) {\n                return String.format(\"%02d:%02d\", newHour, newMinute);\n            }\n        }\n\n        return time;\n    }\n}",
  "682": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(scoreOfParentheses(\"(()())\")); // Output: 2\n        System.out.println(scoreOfParentheses(\"(())()\")); // Output: 2\n        System.out.println(scoreOfParentheses(\"()()()\")); // Output: 0\n    }\n\n    public static int scoreOfParentheses(String S) {\n        int score = 0;\n        int openCount = 0;\n\n        for (int i = 0; i < S.length(); i++) {\n            if (S.charAt(i) == '(') {\n                openCount++;\n            } else if (S.charAt(i) == ')') {\n                if (openCount > 1) {\n                    score += scoreOfParentheses(S.substring(1, i)) + 2;\n                    return score;\n                }\n                score += 1;\n                openCount--;\n            }\n        }\n\n        return score;\n    }\n}",
  "683": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Solution().superFair(3, new int[]{1,2,NULL,-1,5,4}));\n        System.out.println(new Solution().superFair(4, new int[]{0,3,2,NULL,1,5,NULL,NULL}));\n        System.out.println(new Solution().superFair(7, new int[]{1,NULL,NULL,NULL,NULL,NULL,6,7,8}));\n    }\n}\n\nclass Solution {\n    public static final int NULL = -1;\n\n    // your code here\n}\n```",
  "684": "```\nclass Solution {\n    public int[] findRedundantConnection(int[][] edges) {\n        UnionFind uf = new UnionFind(edges.length + 1);\n        for (int[] edge : edges) {\n            if (!uf.union(edge[0], edge[1])) {\n                return edge;\n            }\n        }\n        return new int[]{};\n    }\n\n    static class UnionFind {\n        int[] parent;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        boolean union(int x, int y) {\n            if (parent[x] == parent[y]) {\n                return true;\n            }\n            parent[parent[x]] = parent[y];\n            return false;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] edges1 = {{1, 2}, {2, 3}, {2, 4}, {1, 5}};\n        System.out.println(Arrays.toString(solution.findRedundantConnection(edges1))); // [2, 3]\n\n        int[][] edges2 = {{1, 2}, {1, 3}, {2, 3}};\n        System.out.println(Arrays.toString(solution.findRedundantConnection(edges2))); // [2, 3]\n\n        int[][] edges3 = {{1, 2}, {2, 3}, {3, 4}, {1, 5}};\n        System.out.println(Arrays.toString(solution.findRedundantConnection(edges3))); // [5, 4]\n    }\n}",
  "686": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(repeatedStringMatch(\"a\", \"aa\")); // Expected output: 2\n        System.out.println(repeatedStringMatch(\"ab\", \"aba\")); // Expected output: 1\n        System.out.println(repeatedStringMatch(\"abc\", \"bcbcba\")); // Expected output: 3\n    }\n\n    public static int repeatedStringMatch(String A, String B) {\n        int lenA = A.length();\n        int lenB = B.length();\n        if (lenB > lenA * 2) return -1;\n        \n        for (int i = 0; ; i++) {\n            String AB = A + A;\n            if (AB.substring(i, i+lenB).equals(B)) return i / lenA + 1;\n        }\n    }\n}\n```",
  "685": "```\nimport java.util.*;\n\npublic class Solution {\n    public int[] findRedundantConnection(int[][] edges) {\n        UnionFind uf = new UnionFind(edges.length + 1);\n        for (int[] edge : edges) {\n            if (!uf.union(edge[0], edge[1])) {\n                return edge;\n            }\n        }\n        return null;\n    }\n\n    public class UnionFind {\n        private int[] parent;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public boolean union(int x, int y) {\n            if (find(x) == find(y)) {\n                return false;\n            }\n            parent[find(x)] = find(y);\n            return true;\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        int[][] edges1 = {{1,2},{1,3},{2,3}};\n        System.out.println(Arrays.toString(solution.findRedundantConnection(edges1)));\n\n        // Test case 2\n        int[][] edges2 = {{1,2},{2,3},{3,4},{1,3},{1,4}};\n        System.out.println(Arrays.toString(solution.findRedundantConnection(edges2)));\n\n        // Test case 3\n        int[][] edges3 = {{1,2},{1,3},{2,3},{5,4},{3,4}};\n        System.out.println(Arrays.toString(solution.findRedundantConnection(edges3)));\n    }\n}",
  "687": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode tree1 = new TreeNode(1);\n        tree1.left = new TreeNode(1);\n        tree1.right = new TreeNode(1);\n\n        System.out.println(\"Tree1: \" + longestUnivaluePath(tree1));\n\n        TreeNode tree2 = new TreeNode(3);\n        tree2.left = new TreeNode(4);\n        tree2.left.left = new TreeNode(5);\n        tree2.left.right = new TreeNode(1);\n        tree2.right = new TreeNode(3);\n\n        System.out.println(\"Tree2: \" + longestUnivaluePath(tree2));\n\n        TreeNode tree3 = new TreeNode(2);\n        tree3.left = new TreeNode(1);\n        tree3.right = new TreeNode(1);\n\n        System.out.println(\"Tree3: \" + longestUnivaluePath(tree3));\n    }\n\n    public static int longestUnivaluePath(TreeNode root) {\n        if (root == null) return 0;\n        int leftMax = longestUnivaluePath(root.left);\n        int rightMax = longestUnivaluePath(root.right);\n\n        int maxPath = Math.max(leftMax, rightMax);\n        if (root.val == root.left.val && root.val == root.right.val) {\n            maxPath = Math.max(maxPath, 1 + Math.max(leftMax, rightMax));\n        }\n        return maxPath;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "688": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(knightProbability(2, 3)); // expected: 0.0625\n        System.out.println(knightProbability(1, 1)); // expected: 1.0\n        System.out.println(knightProbability(4, 4)); // expected: 0.1875\n    }\n\n    public static double knightProbability(int N, int K) {\n        if (K > N * N / 2) return 0;\n        double[] dp = new double[N * N];\n        Arrays.fill(dp, 1.0 / 8);\n        for (int k = 1; k <= K; k++) {\n            double[] temp = new double[N * N];\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (i == 0 || i == N - 1 || j == 0 || j == N - 1) continue;\n                    int x = 2 * i + ((j + i) % 2 == 0) ? 1 : -1;\n                    int y = 2 * j + ((i + j) % 2 == 0) ? 1 : -1;\n                    if (x < N && x >= 0 && y < N && y >= 0) {\n                        temp[i * N + j] += dp[x * N + y];\n                    }\n                }\n            }\n            System.arraycopy(temp, 0, dp, 0, N * N);\n        }\n        double sum = 0;\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (i == 0 || i == N - 1 || j == 0 || j == N - 1) continue;\n                sum += dp[i * N + j];\n            }\n        }\n        return sum;\n    }\n}\n```",
  "689": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {3,2,1,4,5};\n        System.out.println(\"Maximum sum for first test case: \" + maxSumOfThreeSubarrays(nums1));\n\n        int[] nums2 = {1,2,1,2,1,100};\n        System.out.println(\"Maximum sum for second test case: \" + maxSumOfThreeSubarrays(nums2));\n\n        int[] nums3 = {0,0,0};\n        System.out.println(\"Maximum sum for third test case: \" + maxSumOfThreeSubarrays(nums3));\n    }\n\n    public static int maxSumOfThreeSubarrays(int[] nums) {\n        int n = nums.length;\n        long prefixSum = 0;\n        int[] leftMax = new int[n];\n        int[] rightMin = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            prefixSum += nums[i];\n            leftMax[i] = Math.max(leftMax[i - 1], prefixSum);\n            rightMin[i] = Math.min(rightMin[i + 1], prefixSum);\n        }\n\n        int ans = 0;\n        for (int i = 2; i < n - 2; i++) {\n            ans = Math.max(ans, leftMax[i - 2] + nums[i] + rightMin[i + 2]);\n        }\n\n        return (int)ans;\n    }\n}",
  "690": "```\npublic class Main {\n    public static void main(String[] args) {\n        EmployeeImportance ei = new EmployeeImportance();\n        Employee e1 = new Employee(\"parent\", 1);\n        Employee e2 = new Employee(\"child\", 2);\n        Employee e3 = new Employee(\"child\", 3);\n        e1.addSubordinate(e2);\n        e1.addSubordinate(e3);\n\n        System.out.println(ei.getImportance(e1));\n    }\n}\n\nclass EmployeeImportance {\n    public int getImportance(Employee employee) {\n        Map<String, Integer> importance = new HashMap<>();\n        importance.put(\"parent\", 5);\n        importance.put(\"child\", 2);\n\n        return dfs(employee, importance);\n    }\n\n    private int dfs(Employee employee, Map<String, String> importanceMap) {\n        if (importanceMap.containsKey(employee.id)) {\n            return importanceMap.get(employee.id);\n        } else {\n            int importance = 0;\n            for (Employee sub : employee.subordinates) {\n                importance += dfs(sub, importanceMap);\n            }\n            return importance + (importanceMap.containsKey(employee.name) ? importanceMap.get(employee.name) : 0);\n        }\n    }\n}\n\nclass Employee {\n    public String name;\n    public int id;\n    public List<Employee> subordinates;\n\n    public Employee(String name, int id) {\n        this.name = name;\n        this.id = id;\n        this.subordinates = new ArrayList<>();\n    }\n\n    public void addSubordinate(Employee employee) {\n        this.subordinates.add(employee);\n    }\n}\n```",
  "691": "```\npublic class Main {\n    public static void main(String[] args) {\n        int numRobs = minStickers(new String[]{\"shop\", \"tarts\", \"art\"}, \"boards\");\n        System.out.println(numRobs);\n\n        numRobs = minStickers(new String[]{\"stop\", \"talk\", \"train\"}, \"stop\");\n        System.out.println(numRobs);\n\n        numRobs = minStickers(new String[]{\"a\", \"b\", \"c\", \"d\"}, \"abcd\");\n        System.out.println(numRobs);\n    }\n\n    public static int minStickers(String[] stickers, String target) {\n        // Your code here\n        return 0;\n    }\n}",
  "693": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(hasAlternatingBits(5)); // Expected: true\n        System.out.println(hasAlternatingBits(7)); // Expected: false\n        System.out.println(hasAlternatingBits(11)); // Expected: true\n    }\n\n    public static boolean hasAlternatingBits(int n) {\n        int prevBit = (n >> Integer.highestOneBit(n).length - 1) & 1;\n        for (int bit : Long.valueOf(n).toString().getBytes()) {\n            if ((bit & 1) == prevBit) return false;\n            prevBit = bit;\n        }\n        return true;\n    }\n}",
  "692": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> wordCount = new HashMap<>();\n        for (String word : words) {\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n\n        List<String> result = new ArrayList<>(wordCount.size());\n        PriorityQueue<Map.Entry<String, Integer>> queue = new PriorityQueue<>((a, b) -> a.getValue().compareTo(b.getValue()));\n\n        for (Map.Entry<String, Integer> entry : wordCount.entrySet()) {\n            queue.offer(entry);\n        }\n\n        while (!queue.isEmpty() && result.size() < k) {\n            result.add(queue.poll().getKey());\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words1 = {\"the\", \"is\", \"and\", \"that\", \"is\", \"of\", \"and\", \"to\", \"not\"};\n        System.out.println(solution.topKFrequent(words1, 3));\n        \n        String[] words2 = {\"love\", \"leetcode\", \"love\", \"code\"};\n        System.out.println(solution.topKFrequent(words2, 1));\n        \n        String[] words3 = {\"the\", \"eagle\", \"is\", \"a\", \"rare\", \"bird\", \"in\", \"the\", \"forest\", \"and\", \"never\", \"flies\", \"out\", \"of\", \"sight\"};\n        System.out.println(solution.topKFrequent(words3, 2));\n    }\n}",
  "694": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,0,1},{0,1,1},{0,2,1}};\n        System.out.println(\"Number of Distinct Islands for grid1: \" + numDistinctIslands(grid1));\n        \n        int[][] grid2 = {{0,0,0},{0,1,1},{0,2,1}};\n        System.out.println(\"Number of Distinct Islands for grid2: \" + numDistinctIslands(grid2));\n        \n        int[][] grid3 = {{1,1},{1,0},{0,0}};\n        System.out.println(\"Number of Distinct Islands for grid3: \" + numDistinctIslands(grid3));\n    }\n\n    public static int numDistinctIslands(int[][] grid) {\n        if (grid == null || grid.length == 0) return 0;\n        \n        Set<String> islands = new HashSet<>();\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1) {\n                    String island = dfs(grid, i, j);\n                    islands.add(island);\n                }\n            }\n        }\n        \n        return islands.size();\n    }\n\n    public static String dfs(int[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) return \"\";\n        \n        grid[i][j] = 0;\n        StringBuilder sb = new StringBuilder();\n        sb.append((i + \",\").concat(j));\n        for (int[] dir : dirs) {\n            int ni = i + dir[0];\n            int nj = j + dir[1];\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[0].length && grid[ni][nj] == 1) {\n                sb.append(dfs(grid, ni, nj));\n            }\n        }\n        \n        return sb.toString();\n    }\n\n    private static final int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n}\n```",
  "695": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,0,1,0,0},{0,0,1,0,0},{0,0,1,0,0},{0,0,0,1,1}};\n        System.out.println(\"Max area of island in grid1: \" + maxAreaOfIsland(grid1));\n\n        int[][] grid2 = {{1,1,0,0,0},{1,1,0,0,0},{0,0,1,0,0},{0,0,1,1,1}};\n        System.out.println(\"Max area of island in grid2: \" + maxAreaOfIsland(grid2));\n\n        int[][] grid3 = {{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1},{1,1,1,1,1}};\n        System.out.println(\"Max area of island in grid3: \" + maxAreaOfIsland(grid3));\n    }\n\n    public static int maxAreaOfIsland(int[][] grid) {\n        if (grid.length == 0) return 0;\n        int maxArea = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1) {\n                    maxArea = Math.max(maxArea, dfs(grid, i, j));\n                }\n            }\n        }\n        return maxArea;\n    }\n\n    public static int dfs(int[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\n            return 0;\n        }\n        grid[i][j] = 0; // mark as visited\n        return 1 + dfs(grid, i - 1, j) + dfs(grid, i + 1, j) + dfs(grid, i, j - 1) + dfs(grid, i, j + 1);\n    }\n}\n```",
  "696": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countBinarySubstrings(\"10000100001\")); // Expected: 6\n        System.out.println(countBinarySubstrings(\"10101\")); // Expected: 4\n        System.out.println(countBinarySubstrings(\"1111\")); // Expected: 2\n    }\n\n    public static int countBinarySubstrings(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            int start = i;\n            while (i + 1 < s.length() && s.charAt(i) == s.charAt(i + 1)) {\n                i++;\n            }\n            if (s.charAt(start) != s.charAt(i)) {\n                count += Math.max(0, i - start);\n            }\n        }\n        return count;\n    }\n}\n```",
  "697": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {2,1,2};\n        System.out.println(\"Degree of array: \" + findDegrees(arr1));\n        \n        int[] arr2 = {1,2,2,3,5};\n        System.out.println(\"Degree of array: \" + findDegrees(arr2));\n        \n        int[] arr3 = {0,2,1,3};\n        System.out.println(\"Degree of array: \" + findDegrees(arr3));\n    }\n\n    public static int findDegrees(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            if (!map.containsKey(num)) {\n                map.put(num, 1);\n            } else {\n                map.put(num, map.get(num) + 1);\n            }\n        }\n\n        int maxCount = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() > maxCount) {\n                maxCount = entry.getValue();\n            }\n        }\n\n        return maxCount;\n    }\n}\n```",
  "698": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canPartition(new int[]{4, 3, 2, 3, 5, 2}, 4));\n        System.out.println(canPartition(new int[]{1, 2, 3, 4}, 3));\n        System.out.println(canPartition(new int[]{5}, 2));\n    }\n\n    public static boolean canPartition(int[] nums, int k) {\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n        if (totalSum % k != 0) return false;\n\n        int target = totalSum / k;\n        boolean[][] dp = new boolean[k + 1][target + 1];\n        dp[0][0] = true;\n\n        for (int i = 0; i <= k; i++) {\n            for (int j = 0; j <= target; j++) {\n                if (i > 0 && j >= nums[0]) dp[i][j] |= dp[i - 1][j - nums[0]];\n                if (dp[i][j]) System.out.println(\"Partitioned set: \" + i);\n            }\n        }\n\n        return dp[k][target];\n    }\n}\n```",
  "699": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] squares = {\n            {1,2,3},\n            {5,6},\n            {}\n        };\n\n        System.out.println(\"Test case 1: \" + fallingSquares(squares));\n        \n        squares = new int[][]{\n            {4,8,10},\n            {9,10,12},\n            {15,20}\n        };\n        \n        System.out.println(\"Test case 2: \" + fallingSquares(squares));\n\n        squares = new int[][]{\n            {1,2},\n            {6,8,7,5,3,2},\n            {11,25,30}\n        };\n\n        System.out.println(\"Test case 3: \" + fallingSquares(squares));\n    }\n\n    public static int[] fallingSquares(int[][] positions) {\n        // Your code here\n    }\n}",
  "700": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(4);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(7);\n        root.left.left = new TreeNode(1);\n        root.left.right = new TreeNode(3);\n\n        System.out.println(\"Test case 1: \" + searchBST(root, 2)); // Expected output: 2\n        System.out.println(\"Test case 2: \" + searchBST(root, 5)); // Expected output: null\n        System.out.println(\"Test case 3: \" + searchBST(root, 6)); // Expected output: 7\n    }\n\n    public static int searchBST(TreeNode root, int val) {\n        if (root == null || root.val == val) return root.val;\n        return val < root.val ? searchBST(root.left, val) : searchBST(root.right, val);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "701": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(4);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(6);\n        root.left.left = new TreeNode(1);\n        root.left.right = new TreeNode(3);\n\n        int val1 = 5;\n        insertIntoBST(root, val1);\n\n        int val2 = 0;\n        insertIntoBST(root, val2);\n\n        int val3 = 7;\n        insertIntoBST(root, val3);\n    }\n\n    public static void insertIntoBST(TreeNode root, int val) {\n        // Your code to insert the value into the binary search tree\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "702": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(searchRange(new int[]{5,7,7,8,8,10}, 8) + \", \" + searchRange(new int[]{5,7,7,8,8,10}, 6));\n        System.out.println(searchRange(new int[]{1,3}, 3));\n        System.out.println(searchRange(new int[]{1,2}, 0));\n    }\n\n    public static int[] searchRange(int[] nums, int target) {\n        int left = findLeft(nums, target);\n        if (left == -1) return new int[]{-1,-1};\n        int right = findRight(nums, target);\n        return new int[]{left, right};\n    }\n\n    public static int findLeft(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left == nums.length || nums[left] != target ? -1 : left;\n    }\n\n    public static int findRight(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] > target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```",
  "703": "```\nimport java.util.*;\n\npublic class KthLargestElement {\n    public static void main(String[] args) {\n        KthLargestElement sol = new KthLargestElement();\n        \n        // Test case 1\n        StreamTracker tracker1 = sol.new StreamTracker(3);\n        tracker1.add(4); \n        tracker1.add(2); \n        System.out.println(tracker1.kthLargest()); // prints 4\n        \n        // Test case 2\n        StreamTracker tracker2 = sol.new StreamTracker(1);\n        tracker2.add(-1); \n        tracker2.add(5); \n        tracker2.add(-3); \n        System.out.println(tracker2.kthLargest()); // prints 5\n        \n        // Test case 3\n        StreamTracker tracker3 = sol.new StreamTracker(4);\n        tracker3.add(8); \n        tracker3.add(9); \n        tracker3.add(6); \n        tracker3.add(7); \n        tracker3.add(1); \n        System.out.println(tracker3.kthLargest()); // prints 7\n    }\n}\n\nclass StreamTracker {\n    private PriorityQueue<Integer> queue;\n    \n    public StreamTracker(int k) {\n        this.queue = new PriorityQueue((a, b) -> b - a);\n        this.queue.add(Integer.MIN_VALUE); // dummy value to keep the size of the queue as K\n    }\n\n    public void add(int val) {\n        queue.offer(val);\n        \n        if (queue.size() > 1) {\n            queue.poll(); // remove the smallest element to maintain the size as K\n        }\n    }\n\n    public int kthLargest() {\n        return queue.peek();\n    }\n}\n```",
  "704": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(searchRange(new int[]{5,7,7,8,8,10}, 8)); // [4, 4]\n        System.out.println(searchRange(new int[]{5,7,7,8,9,10}, 8)); // [-1, -1]\n        System.out.println(searchRange(new int[]{1,2,3}, 0)); // [-1, -1]\n    }\n\n    public static int[] searchRange(int[] nums, int target) {\n        int[] result = new int[2];\n        result[0] = binarySearch(nums, target);\n        if(result[0] != -1) {\n            result[1] = binarySearch(nums, target + 1) - 1;\n        } else {\n            result[1] = -1;\n        }\n        return result;\n    }\n\n    public static int binarySearch(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1;\n    }\n}",
  "705": "```\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static void main(String[] args) {\n        MyHashSet myHashSet = new MyHashSet();\n        myHashSet.add(1);\n        myHashSet.add(2);\n\n        System.out.println(myHashSet.get(1)); // prints 1\n        System.out.println(myHashSet.get(3)); // prints -1\n\n        myHashSet.remove(2);\n\n        System.out.println(myHashSet.get(2)); // prints -1\n    }\n}\n\nclass MyHashSet {\n    private Map<Integer, Boolean> map;\n\n    public MyHashSet() {\n        this.map = new HashMap<>();\n    }\n\n    public void add(int key) {\n        map.put(key, true);\n    }\n\n    public void remove(int key) {\n        map.remove(key);\n    }\n\n    public boolean get(int key) {\n        return map.containsKey(key);\n    }\n}\n```",
  "706": "```\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        MyHashMap myHashMap1 = new MyHashMap();\n        myHashMap1.put(1, \"one\");\n        myHashMap1.put(2, \"two\");\n        System.out.println(myHashMap1.get(1)); // prints: one\n        System.out.println(myHashMap1.get(3)); // prints: null\n\n        MyHashMap myHashMap2 = new MyHashMap();\n        myHashMap2.put(\"hello\", 123);\n        myHashMap2.put(\"world\", 456);\n        System.out.println(myHashMap2.get(\"hello\")); // prints: 123\n        System.out.println(myHashMap2.get(\"java\")); // prints: null\n\n        MyHashMap myHashMap3 = new MyHashMap();\n        for (int i = 0; i < 10; i++) {\n            myHashMap3.put(i, i * i);\n        }\n        for (int i = 0; i < 5; i++) {\n            System.out.println(myHashMap3.get(i)); // prints: 0, 1, 4, 9, null\n        }\n    }\n}\n\nclass MyHashMap {\n\n    private Map<Integer, String> map;\n\n    public MyHashMap() {\n        this.map = new HashMap<>();\n    }\n\n    public void put(int key, String value) {\n        map.put(key, value);\n    }\n\n    public String get(int key) {\n        return map.getOrDefault(key, null);\n    }\n}\n```",
  "707": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        MyLinkedList list1 = new MyLinkedList();\n        list1.add(1);\n        list1.add(2);\n        list1.add(3);\n\n        System.out.println(\"Test Case 1: \");\n        printList(list1);\n\n        MyLinkedList list2 = new MyLinkedList();\n        list2.add(0, -1);\n        list2.add(1, 2);\n        list2.add(2, 3);\n\n        System.out.println(\"\\nTest Case 2: \");\n        printList(list2);\n\n        MyLinkedList list3 = new MyLinkedList();\n        list3.add(5);\n        list3.add(10);\n        list3.add(15);\n        list3.removeLast();\n\n        System.out.println(\"\\nTest Case 3: \");\n        printList(list3);\n    }\n\n    public static void printList(MyLinkedList list) {\n        Node current = list.head;\n        while (current != null) {\n            System.out.print(current.val + \" \");\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n\nclass MyLinkedList {\n    Node head;\n\n    public void add(int val) {\n        Node newNode = new Node(val);\n        if (head == null) {\n            head = newNode;\n        } else {\n            Node current = head;\n            while (current.next != null) {\n                current = current.next;\n            }\n            current.next = newNode;\n        }\n    }\n\n    public void add(int val, int index) {\n        if (index < 0 || index > size()) {\n            return;\n        }\n        if (index == 0) {\n            head = new Node(val);\n        } else {\n            Node prev = getPrev(index - 1);\n            prev.next = new Node(val);\n        }\n    }\n\n    public int removeLast() {\n        if (head == null) {\n            return 0;\n        }\n        if (head.next == null) {\n            int val = head.val;\n            head = null;\n            return val;\n        }\n        Node current = head;\n        while (current.next.next != null) {\n            current = current.next;\n        }\n        int val = current.next.val;\n        current.next = null;\n        return val;\n    }\n\n    public int size() {\n        int count = 0;\n        Node current = head;\n        while (current != null) {\n            count++;\n            current = current.next;\n        }\n        return count;\n    }\n\n    public Node getPrev(int index) {\n        if (index < 0 || index > size()) {\n            return null;\n        }\n        Node current = head;\n        for (int i = 0; i < index - 1; i++) {\n            current = current.next;\n        }\n        return current;\n    }\n\n    public class Node {\n        int val;\n        Node next;\n\n        public Node(int val) {\n            this.val = val;\n            this.next = null;\n        }\n    }\n}",
  "708": "```\nclass Node {\n    int val;\n    Node prev;\n    Node next;\n\n    public Node(int val) {\n        this.val = val;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        test1();\n        test2();\n        test3();\n    }\n\n    private static void test1() {\n        Node head = new Node(5);\n        head.next = head.prev = head;\n        insertIntoSortedList(head, 6);\n        System.out.println(\"Test 1: Pass\");\n    }\n\n    private static void test2() {\n        Node head = new Node(3);\n        head.next = head.prev = head;\n        insertIntoSortedList(head, 1);\n        System.out.println(\"Test 2: Pass\");\n    }\n\n    private static void test3() {\n        Node head = new Node(5);\n        head.next = head.prev = head;\n        insertIntoSortedList(head, 10);\n        System.out.println(\"Test 3: Pass\");\n    }\n\n    public static Node insertIntoSortedList(Node head, int val) {\n        if (head.val >= val) {\n            Node newNode = new Node(val);\n            newNode.next = head;\n            newNode.prev = head.prev;\n            head.prev.next = newNode;\n            head.prev = newNode;\n            return newNode;\n        }\n        Node curr = head;\n        while (curr.next != head && curr.next.val < val) {\n            curr = curr.next;\n        }\n        if (val == curr.val) {\n            return head;\n        }\n        Node newNode = new Node(val);\n        newNode.next = curr.next;\n        newNode.prev = curr;\n        curr.next.prev = newNode;\n        curr.next = newNode;\n        return head;\n    }\n}",
  "709": "```\npublic class Solution {\n    public String toLowerCase(String s) {\n        return s.toLowerCase();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.toLowerCase(\"Hello\")); // \"hello\"\n        System.out.println(solution.toLowerCase(\"here COMES THE SUN\")); // \"here comes the sun\"\n        System.out.println(solution.toLowerCase(\"LOVELY DAY\")); // \"lovely day\"\n    }\n}\n```",
  "710": "```\nimport java.util.*;\n\npublic class Solution {\n    int[] nums;\n    Random random = new Random();\n    Map<Integer, Integer> countMap;\n\n    public Solution(int[] w) {\n        this.nums = w;\n        countMap = new HashMap<>();\n        for (int num : nums) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n    }\n\n    public int pickIndex() {\n        int target = random.nextInt(1000000);\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (target <= sum + nums[i] * countMap.getOrDefault(i, 1)) {\n                return i;\n            }\n            sum += nums[i] * countMap.getOrDefault(i, 1);\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution(new int[]{1,3,5,2,4});\n        \n        System.out.println(solution.pickIndex());\n        \n        solution = new Solution(new int[]{1,1,2,3,3,4,4,5,5});\n        System.out.println(solution.pickIndex());\n\n        solution = new Solution(new int[]{0,1,1,1,2});\n        System.out.println(solution.pickIndex());\n    }\n}",
  "711": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {\n            {0,0,0},{0,1,1},{0,1,1},\n            {0,1,1},{1,1,1},{1,1,0}\n        };\n        System.out.println(countDistinctIslands(grid1));  // Expected output: 3\n\n        int[][] grid2 = {\n            {1,1,0},{0,0,1},{0,1,1}\n        };\n        System.out.println(countDistinctIslands(grid2));  // Expected output: 1\n\n        int[][] grid3 = {\n            {1,1,0,0,0},{0,1,1,0,0},{0,0,1,0,0},{0,0,0,1,1}\n        };\n        System.out.println(countDistinctIslands(grid3));  // Expected output: 2\n    }\n\n    public static int countDistinctIslands(int[][] grid) {\n        // Your code here...\n    }\n}",
  "713": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {{10,1}, {3,7}, {4,3}};\n        for (int i = 0; i < inputs.length; i++) {\n            int[] input = inputs[i];\n            System.out.println(\"Input: \" + input[0] + \", Output: \" + numSubarrayProductLessThanK(input[0], input[1]) + \".\");\n        }\n    }\n\n    public static int numSubarrayProductLessThanK(int n, int k) {\n        if (k < 2) return 0;\n        long res = 0;\n        long curProd = 1;\n        int left = 0;\n        for (int right = 0; right < n; right++) {\n            curProd *= n - right;\n            while (curProd >= k && left <= right) {\n                curProd /= n - left++;\n            }\n            res += right - left + 1;\n        }\n        return (int)res;\n    }\n}",
  "712": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minimumDeleteSum(\"sea\", \"eat\") == 3);\n        System.out.println(minimumDeleteSum(\"testing\", \"test\") == 0);\n        System.out.println(minimumDeleteSum(\"a\", \"b\") == 3);\n    }\n\n    public static int minimumDeleteSum(String s1, String s2) {\n        int len1 = s1.length();\n        int len2 = s2.length();\n\n        int[][] dp = new int[len1 + 1][len2 + 1];\n        for (int i = 0; i <= len1; i++) {\n            for (int j = 0; j <= len2; j++) {\n                if (i == 0) {\n                    dp[i][j] = j;\n                } else if (j == 0) {\n                    dp[i][j] = i;\n                } else if (s1.charAt(i - 1) != s2.charAt(j - 1)) {\n                    dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);\n                } else {\n                    dp[i][j] = dp[i - 1][j - 1];\n                }\n            }\n        }\n\n        return dp[len1][len2];\n    }\n}",
  "714": "```\npublic class Main {\n    public static void main(String[] args) {\n        int fee = 2;\n        int result1 = maxProfit(new int[]{1, 3, 4, 5}, fee);\n        System.out.println(\"Test Case 1: \" + result1);\n\n        int result2 = maxProfit(new int[]{7,6,8,10}, fee);\n        System.out.println(\"Test Case 2: \" + result2);\n\n        int result3 = maxProfit(new int[]{1, 2}, fee);\n        System.out.println(\"Test Case 3: \" + result3);\n    }\n\n    public static int maxProfit(int[] prices, int fee) {\n        if (prices.length < 2) return 0;\n        \n        int buy = -prices[0], sell = 0;\n        \n        for (int i = 1; i < prices.length; i++) {\n            int newBuy = Math.max(buy, sell - fee);\n            sell = Math.max(sell, buy + prices[i]);\n            buy = newBuy;\n        }\n        \n        return sell;\n    }\n}\n```",
  "715": "```\nclass Number_of_Range_Sum_Query_Object {\n    private int[] tree;\n    private int n;\n\n    public Number_of_Range_Sum_Query_Object(int[] nums) {\n        n = nums.length;\n        tree = new int[4 * n];\n        buildTree(nums, 0, n - 1);\n    }\n\n    private void buildTree(int[] nums, int start, int end) {\n        if (start == end) {\n            tree[2 * start + 1] = nums[start];\n            return;\n        }\n        int mid = (start + end) / 2;\n        buildTree(nums, start, mid);\n        buildTree(nums, mid + 1, end);\n\n        tree[2 * start + 1] = nums[mid];\n    }\n\n    public int sumRange(int left, int right) {\n        return query(left, right, 0, n - 1);\n    }\n\n    private int query(int left, int right, int start, int end) {\n        if (left > end || right < start) {\n            return 0;\n        }\n        if (left <= start && right >= end) {\n            return getSum(start, end);\n        }\n        int mid = (start + end) / 2;\n        int p1 = query(left, Math.min(right, mid), start, mid);\n        int p2 = query(Math.max(left, mid + 1), right, mid + 1, end);\n\n        return p1 + p2;\n    }\n\n    private int getSum(int start, int end) {\n        int sum = tree[2 * start + 1];\n        while (start != end) {\n            if ((end - start) % 2 == 0) {\n                start = (start + end) / 2;\n            } else {\n                end = (start + end) / 2;\n            }\n            sum += tree[2 * start + 1];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Number_of_Range_Sum_Query_Object obj = new Number_of_Range_Sum_Query_Object(new int[]{1, 3, 5, 7, 9});\n        System.out.println(obj.sumRange(0, 4)); // Output: 25\n        System.out.println(obj.sumRange(2, 3)); // Output: 7\n        System.out.println(obj.sumRange(0, 1)); // Output: 6\n    }\n}",
  "716": "```\npublic class Main {\n    public static void main(String[] args) {\n        MaxStack maxStack = new MaxStack();\n        maxStack.push(1);\n        maxStack.push(2);\n        System.out.println(\"Max value is \" + maxStack.getMax());\n        \n        maxStack = new MaxStack();\n        maxStack.push(-1);\n        maxStack.push(0);\n        maxStack.push(1);\n        System.out.println(\"Max value is \" + maxStack.getMax());\n        \n        maxStack = new MaxStack();\n        for (int i = 10; i > 5; i--) {\n            maxStack.push(i);\n        }\n        System.out.println(\"Max value is \" + maxStack.getMax());\n    }\n}\n\nclass MaxStack {\n    Node head;\n    int max;\n\n    public void push(int val) {\n        Node newNode = new Node(val);\n        if (head == null || val >= head.val) {\n            newNode.next = head;\n            head = newNode;\n        } else {\n            Node current = head;\n            while (current.next != null && current.next.val > val) {\n                current = current.next;\n            }\n            newNode.next = current.next;\n            current.next = newNode;\n        }\n        max = Math.max(max, val);\n    }\n\n    public int getMax() {\n        return max;\n    }\n}\n\nclass Node {\n    int val;\n    Node next;\n\n    public Node(int val) {\n        this.val = val;\n    }\n}\n```",
  "717": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \");\n        int n = 5;\n        String chars = \"0000\";\n        int expected = 3;\n        System.out.println(\"Expected: \" + expected);\n        System.out.println(\"Result: \" + oneBitCharacter(n, chars));\n        System.out.println();\n\n        System.out.println(\"Test Case 2: \");\n        n = 1;\n        chars = \"01\";\n        expected = 2;\n        System.out.println(\"Expected: \" + expected);\n        System.out.println(\"Result: \" + oneBitCharacter(n, chars));\n        System.out.println();\n\n        System.out.println(\"Test Case 3: \");\n        n = 10;\n        chars = \"01101001111\";\n        expected = 9;\n        System.out.println(\"Expected: \" + expected);\n        System.out.println(\"Result: \" + oneBitCharacter(n, chars));\n    }\n\n    public static int oneBitCharacter(int n, String chars) {\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if ((i < n - 1 && chars.charAt(i) == '1' && chars.charAt(i + 1) == '0') || chars.charAt(i) == '0') {\n                res++;\n            }\n        }\n        return res;\n    }\n}",
  "718": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrays = {{1,2,3,2,1},{0,0,0,0,0},{0,1,1,1,1}};\n\n        for (int[] array : arrays) {\n            System.out.println(\"Maximum length of repeated subarray: \" + findLength(array));\n        }\n    }\n\n    public static int findLength(int[] A, int[] B) {\n        int m = A.length;\n        int n = B.length;\n        int maxLength = 0;\n\n        for (int i = 0; i <= m - n; i++) {\n            for (int j = 0; j <= m - n; j++) {\n                int k = 0;\n                while (k < n && A[i + k] == B[j + k]) {\n                    k++;\n                }\n                maxLength = Math.max(maxLength, k);\n            }\n        }\n\n        return maxLength;\n    }\n}\n```",
  "719": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] sequences = { {{1,2},{5,6}} };\n        int k = 3;\n        for (int i = 0; i < sequences.length; i++) {\n            System.out.println(\"For sequence \" + Arrays.toString(sequences[i]) + \", the \" + k + \"th smallest pair distance is: \" + findKthSmallestPairDistance(sequences[i], k));\n        }\n    }\n\n    public static int findKthSmallestPairDistance(int[][] sequences, int k) {\n        // Your code here\n        Arrays.sort(sequences[0]);\n        int left = 0;\n        int right = sequences[0].length - 1;\n        for (int i = 0; i < k; i++) {\n            if (left >= right) return -1;\n            int mid = (left + right) / 2;\n            int pairDistance = sequences[0][mid] - sequences[0][left];\n            left++;\n            right--;\n        }\n        return sequences[0][k-1] - sequences[0][0];\n    }\n}",
  "720": "```\nimport org.junit.Test;\n\npublic class Solution {\n    public String longestWord(String[] words) {\n        TrieNode root = new TrieNode();\n        for (String word : words) {\n            TrieNode current = root;\n            for (char c : word.toCharArray()) {\n                if (!current.children.containsKey(c)) {\n                    current.children.put(c, new TrieNode());\n                }\n                current = current.children.get(c);\n            }\n            current.isWord = true;\n        }\n\n        String longest = \"\";\n        for (String word : words) {\n            int length = 0;\n            TrieNode current = root;\n            boolean valid = true;\n            for (char c : word.toCharArray()) {\n                if (!current.children.containsKey(c)) {\n                    valid = false;\n                    break;\n                }\n                current = current.children.get(c);\n                if (current.isWord) {\n                    length++;\n                } else {\n                    length += 1;\n                }\n            }\n            if (valid && length > words[0].length()) {\n                longest = word;\n            }\n        }\n\n        return longest;\n    }\n\n    public class TrieNode {\n        Map<Character, TrieNode> children = new HashMap<>();\n        boolean isWord = false;\n    }\n\n    @Test\n    public void test1() {\n        String[] words = {\"wheat\", \"flower\", \"flowered\"};\n        System.out.println(longestWord(words));\n    }\n\n    @Test\n    public void test2() {\n        String[] words = {\"dog\", \"cat\", \"mouse\", \"bear\", \"catbird\"};\n        System.out.println(longestWord(words));\n    }\n\n    @Test\n    public void test3() {\n        String[] words = {\"a\", \"app\", \"banana\", \"apricot\", \"apple\"};\n        System.out.println(longestWord(words));\n    }\n}",
  "721": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<List<String>> accounts = new ArrayList<>();\n        accounts.add(Arrays.asList(\"John\", \"johnsmith26@gmail.com\", \"j7vN0U5fOpD3\"));\n        accounts.add(Arrays.asList(\"John\", \"john.smith\", \"J4lW8X2PiyG\"));\n        accounts.add(Arrays.asList(\"Eve\", \"eve.jansen@gmail.com\", \"K5Rj2yA2L\"),);\n\n        List<String> result = accountsMerge(accounts);\n        \n        for (String account : result) {\n            System.out.println(account);\n        }\n    }\n\n    public static List<String> accountsMerge(List<List<String>> accounts) {\n        // TO DO: your code here\n        Map<String, String> emailToName = new HashMap<>();\n        Map<String, Set<String>> graph = new HashMap<>();\n        for (List<String> account : accounts) {\n            String name = account.get(0);\n            for (int i = 1; i < account.size(); i++) {\n                String email = account.get(i);\n                if (!emailToName.containsKey(email)) {\n                    emailToName.put(email, name);\n                }\n                graph.computeIfAbsent(email, k -> new HashSet<>()).add(account.get(i-1));\n            }\n        }\n        \n        Set<String> visited = new HashSet<>();\n        List<String> mergedAccounts = new ArrayList<>();\n        for (Map.Entry<String, Set<String>> entry : graph.entrySet()) {\n            if (!visited.contains(entry.getKey())) {\n                dfs(graph, visited, entry.getKey(), \"\", mergedAccounts);\n            }\n        }\n        \n        return mergedAccounts;\n    }\n\n    public static void dfs(Map<String, Set<String>> graph, Set<String> visited, String email, String path, List<String> mergedAccounts) {\n        visited.add(email);\n        path += email + \" \";\n        for (String neighbor : graph.get(email)) {\n            if (!visited.contains(neighbor)) {\n                dfs(graph, visited, neighbor, path, mergedAccounts);\n            } else if (!path.equals(path + neighbor + \" \")) {\n                mergedAccounts.add(name(emailToName, email) + \": \" + path.trim());\n            }\n        }\n    }\n\n    public static String name(Map<String, String> emailToName, String email) {\n        return emailToName.getOrDefault(email, \"\");\n    }\n}\n```",
  "722": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removeComments(\"hello world // comment\")); // \"hello world\"\n        System.out.println(removeComments(\"// hello world\", true)); // \"\"\n        System.out.println(removeComments(\"a // b c d\")); // \"a c d\"\n    }\n\n    public static String removeComments(String s, boolean hasNestedComment) {\n        StringBuilder sb = new StringBuilder();\n        int nestedCommentDepth = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (hasNestedComment && i + 1 < s.length() && c == '/' && s.charAt(i + 1) == '*') {\n                nestedCommentDepth++;\n                sb.append(c);\n            } else if (c == '*' && hasNestedComment && nestedCommentDepth > 0) {\n                nestedCommentDepth--;\n                sb.append(c);\n            } else if (c == '\\n' && nestedCommentDepth == 0) {\n                sb.append(c);\n            } else if (nestedCommentDepth == 0) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "724": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1, 7, 3, 6, 5, 2};\n        System.out.println(pivotIndex(nums1)); // Output: 3\n        \n        int[] nums2 = {1, 2, 3, 4, 5, -6, 0};\n        System.out.println(pivotIndex(nums2)); // Output: 6\n\n        int[] nums3 = {1, -1, 0, -2, 0, -1};\n        System.out.println(pivotIndex(nums3)); // Output: 4\n    }\n\n    public static int pivotIndex(int[] nums) {\n        int totalSum = 0;\n        int leftSum = 0;\n\n        for (int num : nums) {\n            totalSum += num;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (leftSum == totalSum - nums[i]) {\n                return i;\n            }\n            leftSum += nums[i];\n        }\n\n        return -1;\n    }\n}",
  "723": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(candyCrush(new int[][]{{1,2,5},{4,7,8},{9,10,6}}));\n        System.out.println(candyCrush(new int[][]{{3,1,2},{5,4,3},{1,2,1}}));\n        System.out.println(candyCrush(new int[][]{{4,4,4},{5,5,5},{6,6,6}}));\n    }\n\n    public static int candyCrush(int[][] grid) {\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n        \n        int totalCandies = 0;\n        \n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (i > 0 && Math.abs(grid[i][j] - grid[i-1][j]) == 1) {\n                    totalCandies += 2;\n                } else if (j > 0 && Math.abs(grid[i][j] - grid[i][j-1]) == 1) {\n                    totalCandies += 2;\n                } else if (grid[i][j] != 0) {\n                    totalCandies++;\n                }\n            }\n        }\n        \n        return totalCandies;\n    }\n}",
  "725": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head.next.next.next.next = new ListNode(5);\n\n        splitListToParts(head, 3);\n\n        head = null;\n\n        head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n\n        splitListToParts(head, 10);\n\n        head = null;\n    }\n\n    public static void splitListToParts(ListNode head, int k) {\n        if (head == null) return;\n\n        int length = 0;\n        ListNode current = head;\n        while (current != null) {\n            length++;\n            current = current.next;\n        }\n\n        for (int i = 1; i <= length % k; i++) {\n            current = current.next;\n        }\n\n        ListNode newHead = current;\n        current = current.next;\n        newHead.next = null;\n\n        while (current != null) {\n            int i = 0;\n            while (i < k - 1 && current.next != null) {\n                current = current.next;\n                i++;\n            }\n            ListNode nextNode = current.next;\n            current.next = null;\n            if (nextNode != null) {\n                ListNode newNextHead = nextNode;\n                int j = 0;\n                while (j < k - length % k && nextNode.next != null) {\n                    nextNode = nextNode.next;\n                    j++;\n                }\n                nextNode.next = null;\n                current = newNextHead;\n            } else {\n                break;\n            }\n        }\n    }\n\n    static class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode(int x) { val = x; }\n    }\n}",
  "726": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numberOfAtoms(\"H2O\"), \" should be 5\"); // Test case 1\n        System.out.println(numberOfAtoms(\"MgKXe\"), \" should be 3\"); // Test case 2\n        System.out.println(numberOfAtoms(\"N3P\"), \" should be 4\"); // Test case 3\n    }\n\n    public static int numberOfAtoms(String formula) {\n        Map<String, Integer> map = new HashMap<>();\n        StringBuilder sb = new StringBuilder();\n        for (char c : formula.toCharArray()) {\n            if (Character.isDigit(c)) {\n                sb.append(c);\n            } else {\n                String atom = sb.toString();\n                int count = 1;\n                if (!atom.isEmpty() && Character.isDigit(formula.charAt(formula.indexOf(atom) + atom.length()))) {\n                    count = Integer.parseInt(sb.toString());\n                    sb.setLength(0);\n                }\n                map.put(atom, map.getOrDefault(atom, 0) + count);\n            }\n        }\n        long res = 1;\n        for (int val : map.values()) {\n            res *= (long) Math.pow(val, 1);\n        }\n        return (int) res;\n    }\n}",
  "728": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numOfWays(2));\n        System.out.println(numOfWays(4));\n        System.out.println(numOfWays(12));\n    }\n\n    public static int numOfWays(int n) {\n        int count = 0;\n        for (int i = 1; ; i++) {\n            if (!isSelfDividing(i)) continue;\n            if (++count == n) return i;\n        }\n    }\n\n    public static boolean isSelfDividing(int n) {\n        int temp = n;\n        while (temp > 0) {\n            int digit = temp % 10;\n            if (digit == 0 || !isPrime(digit)) return false;\n            if (!(n % digit == 0)) return false;\n            temp /= 10;\n        }\n        return true;\n    }\n\n    public static boolean isPrime(int n) {\n        if (n < 2) return false;\n        for (int i = 2, sqrt = (int)Math.sqrt(n); i <= sqrt; i++) {\n            if ((n % i) == 0) return false;\n        }\n        return true;\n    }\n}",
  "727": "```\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = \"BCA\";\n        System.out.println(\"Minimum Window Subsequence for 'BCA': \" + minWindowSubsequence(s1, \"ABC\"));\n        \n        String s2 = \"AEFCDABEEF\";\n        System.out.println(\"Minimum Window Subsequence for '\" + s2 + \"': \" + minWindowSubsequence(s2, \"CAD\"));\n        \n        String s3 = \"SREYANJANYANAASRE\";\n        System.out.println(\"Minimum Window Subsequence for '\" + s3 + \"': \" + minWindowSubsequence(s3, \"ANE\")); \n    }\n\n    public static String minWindowSubsequence(String s, String t) {\n        // Your code here\n    }\n}\n```",
  "729": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        MyCalendar myCalendar = new MyCalendar();\n        \n        // Test case 1: Add event without conflicts\n        myCalendar.book(10, 20);\n        System.out.println(\"Test case 1 passed\");\n        \n        // Test case 2: Add overlapping events\n        myCalendar.book(15, 25);\n        System.out.println(\"Test case 2 passed\");\n        \n        // Test case 3: Try to add conflicting event\n        try {\n            myCalendar.book(10, 15);\n            System.out.println(\"Test case 3 failed\");\n        } catch (Exception e) {\n            System.out.println(\"Test case 3 passed\");\n        }\n    }\n}\n```",
  "730": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countPalindromes(\"abcda\")); // Expected output: 4\n        System.out.println(countPalindromes(\"bac\"));// Expected output: 2\n        System.out.println(countPalindromes(\"aab\")); // Expected output: 3\n    }\n\n    public static int countPalindromes(String s) {\n        // Your logic goes here...\n    }\n}",
  "732": "```\npublic class Main {\n    public static void main(String[] args) {\n        MyCalendarThree calendar = new MyCalendarThree();\n        System.out.println(calendar.query(10, \"01-31\")); // Expected: [1,2]\n        System.out.println(calendar.query(5, \"08-15\")); // Expected: [2,3,4]\n        System.out.println(calendar.query(7, \"09-12\")); // Expected: []\n    }\n}\n```",
  "731": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        MyCalendarTwo calendar = new MyCalendarTwo();\n        System.out.println(calendar.book(10)); // Output: true\n        System.out.println(calendar.book(5));  // Output: false\n        System.out.println(calendar.book(12));  // Output: true\n\n    }\n}\n\nclass MyCalendarTwo {\n\n    private int[] start;\n    private int[] end;\n\n    public boolean book(int start, int end) {\n        for (int i = 0; i < start.length; i++) {\n            if (start[i] <= start && end > end[i]) {\n                return false;\n            }\n            if (start <= start[i] && end[i] >= end) {\n                return false;\n            }\n        }\n        this.start = new int[start.length + 1];\n        System.arraycopy(start, 0, this.start, 0, start.length);\n        this.end = new int[end.length + 1];\n        System.arraycopy(end, 0, this.end, 0, end.length);\n        return true;\n    }\n}\n```",
  "734": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sentenceSimilarity(new String[]{\"great\", \"acting\", \"skills\"}, new String[]{\"fine\", \"acting\", \"good\"})); // Expected: 0.5\n        System.out.println(sentenceSimilarity(new String[]{\"awesome\", \"house\"}, new String[]{\"strong\", \"home\"})); // Expected: 1.0\n        System.out.println(sentenceSimilarity(new String[]{\"java\", \"programming\", \"is\", \"fun\"}, new String[]{\"programming\", \"in\", \"java\", \"is\", \"fun\"})); // Expected: 1.0\n    }\n\n    public static double sentenceSimilarity(String[] words1, String[] words2) {\n        int same = 0;\n        for (int i = 0; i < Math.min(words1.length, words2.length); i++) {\n            if (words1[i].equals(words2[i])) {\n                same++;\n            }\n        }\n        return (double) same / Math.min(words1.length, words2.length);\n    }\n}\n```",
  "733": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] image1 = {{0,0,0},{0,1,1},{0,0,0}};\n        floodFill(image1, 1, 1, 1);\n        printImage(image1);\n\n        int[][] image2 = {{0,0,0},{0,1,1},{1,1,1}};\n        floodFill(image2, 0, 0, 2);\n        printImage(image2);\n\n        int[][] image3 = {{0,0,0},{0,1,1},{1,1,1}};\n        floodFill(image3, 1, 1, 2);\n        printImage(image3);\n    }\n\n    public static void floodFill(int[][] image, int x, int y, int newColor) {\n        if (x < 0 || x >= image.length || y < 0 || y >= image[0].length)\n            return;\n        \n        if (image[x][y] == newColor)\n            return;\n\n        image[x][y] = newColor;\n\n        floodFill(image, x - 1, y, newColor);\n        floodFill(image, x + 1, y, newColor);\n        floodFill(image, x, y - 1, newColor);\n        floodFill(image, x, y + 1, newColor);\n    }\n\n    public static void printImage(int[][] image) {\n        for (int i = 0; i < image.length; i++) {\n            for (int j = 0; j < image[0].length; j++) {\n                System.out.print(image[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
  "735": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] asteroids1 = {10, 2, -5};\n        int[] result1 = asteroidCollision(asteroids1);\n        System.out.println(Arrays.toString(result1)); // [-5]\n\n        int[] asteroids2 = {5, 10, -3, 2, 1, -5, 2];\n        int[] result2 = asteroidCollision(asteroids2);\n        System.out.println(Arrays.toString(result2)); // [5, 10]\n\n        int[] asteroids3 = {1, 1};\n        int[] result3 = asteroidCollision(asteroids3);\n        System.out.println(Arrays.toString(result3)); // []\n    }\n\n    public static int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i : asteroids) {\n            while (!stack.isEmpty() && Math.abs(stack.peek()) > i) {\n                if (Math.abs(stack.peek()) > Math.abs(i)) {\n                    break;\n                }\n                if (Math.abs(stack.peek()) == Math.abs(i)) {\n                    stack.pop();\n                }\n            }\n            if (i > 0) {\n                stack.push(i);\n            } else {\n                while (!stack.isEmpty() && Math.abs(stack.peek()) < i) {\n                    stack.pop();\n                }\n                if (stack.isEmpty() || Math.abs(stack.peek()) > i) {\n                    continue;\n                }\n                if (Math.abs(stack.peek()) == i) {\n                    stack.pop();\n                }\n            }\n        }\n        int[] result = new int[stack.size()];\n        for (int i = 0; i < stack.size(); i++) {\n            result[i] = stack.get(i);\n        }\n        return result;\n    }\n}",
  "736": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(parseLisp(\"((1 2) (3 4))\")); // output: [[1, 2], [3, 4]]\n        System.out.println(parseLisp(\"(a (b c))\")); // output: [[\"a\"], [\"b\", \"c\"]]\n        System.out.println(parseLisp(\"(5 6 7 (8 9) a b)\")); // output: [[5, 6, 7], [8, 9], [\"a\", \"b\"]]\n    }\n\n    public static List<List<Object>> parseLisp(String s) {\n        List<List<Object>> result = new ArrayList<>();\n        Stack<Integer> parentheses = new Stack<>();\n        StringBuilder currentList = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                parentheses.push(i);\n            } else if (c == ')') {\n                int start = parentheses.pop();\n                String sublistString = s.substring(start + 1, i);\n                List<Object> sublist = new ArrayList<>();\n                for (String item : sublistString.split(\"\\\\s+\")) {\n                    sublist.add(item.equals(\"(\") ? parseLisp(sublistString) : item);\n                }\n                result.add(new ArrayList<>(sublist));\n                currentList = new StringBuilder();\n            } else if (!currentList.toString().isEmpty() && Character.isWhitespace(c)) {\n                List<Object> tempList = new ArrayList<>();\n                tempList.add(Integer.parseInt(currentList.toString()));\n                currentList = new StringBuilder();\n            } else {\n                currentList.append(c);\n            }\n        }\n        return result;\n    }\n}",
  "737": "```\npublic class Main {\n    public static void main(String[] args) {\n        String[][] sentences1 = {{\"great\", \"working\"}, {\"good\", \"work\"}};\n        boolean expected1 = true;\n        System.out.println(\"Test Case 1: \" + sentenceSimilarity(sentences1, [\"eat\", \"tan\", \"sit\"]));\n\n        String[][] sentences2 = {{\"a\", \"b\", \"c\"}, {\"e\", \"f\", \"g\"}, {\"h\", \"i\", \"j\"}};\n        boolean expected2 = false;\n        System.out.println(\"Test Case 2: \" + sentenceSimilarity(sentences2, [\"e\", \"f\", \"g\"]));\n\n        String[][] sentences3 = {{\"love is\", \"the\", \"solution\"}, {\"love\", \"or\", \"the\", \"world\"}};\n        boolean expected3 = true;\n        System.out.println(\"Test Case 3: \" + sentenceSimilarity(sentences3, [\"this\", \"is\", \"love\"]));\n    }\n\n    public static boolean sentenceSimilarity(String[][] sentences, String[] words) {\n        Set<String> set1 = new HashSet<>();\n        for (String[] sentence : sentences) {\n            set1.addAll(Arrays.asList(sentence));\n        }\n        return set1.equals(new HashSet<>(Arrays.asList(words)));\n    }\n}\n```",
  "738": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numDecodings(\"10*1*2\"));//Expected output: 9\n        System.out.println(numDecodings(\"123456\"));//Expected output: 16\n        System.out.println(numDecodings(\"*5/\")); // Expected output: 0\n    }\n\n    public static int numDecodings(String s) {\n        if (s == null || s.length() == 0) return 0;\n        int[] dp = new int[s.length()];\n        dp[0] = s.charAt(0) != '0' ? 1 : 0;\n\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) != '0') {\n                dp[i] += dp[i - 1];\n            }\n            if (i > 0 && (s.charAt(i-1) == '1' || (s.charAt(i-1) >= '2' && s.charAt(i-1) <= '9')) && (s.charAt(i) >= '1' && s.charAt(i) <= '9')) {\n                dp[i] += dp[i - 2];\n            }\n        }\n\n        return dp[s.length() - 1];\n    }\n}",
  "739": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] temperatures1 = {73, 74, 75, 71, 69, 72, 76, 73};\n        int[] result1 = dailyTemperatures(temperatures1);\n        for (int i : result1) {\n            System.out.println(i);\n        }\n\n        int[] temperatures2 = {30};\n        int[] result2 = dailyTemperatures(temperatures2);\n        for (int i : result2) {\n            System.out.println(i);\n        }\n\n        int[] temperatures3 = {30, 40, 50};\n        int[] result3 = dailyTemperatures(temperatures3);\n        for (int i : result3) {\n            System.out.println(i);\n        }\n    }\n\n    public static int[] dailyTemperatures(int[] T) {\n        // Your code here\n    }\n}",
  "740": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2, 2, 3, 3, 3};\n        System.out.println(\"Expected: 9, Actual: \" + new Solution().maximumEarnings(nums1));\n        \n        int[] nums2 = {4, 4, 5};\n        System.out.println(\"Expected: 14, Actual: \" + new Solution().maximumEarnings(nums2));\n        \n        int[] nums3 = {1, 2, 3, 4, 5};\n        System.out.println(\"Expected: 15, Actual: \" + new Solution().maximumEarnings(nums3));\n    }\n}\n\nclass Solution {\n    public int maximumEarnings(int[] nums) {\n        // Your code here\n    }\n}\n```",
  "741": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] positions = {\n            {0, 1, 2},\n            {{0, 1}, {2, 3}},\n            {{7, 5, 10, 9}, {8, 4, 6, 12}}\n        };\n        for (int i = 0; i < positions.length; i++) {\n            System.out.println(cherryPickup(positions[i][0].length, positions[i].length, positions[i]));\n        }\n    }\n\n    public static int cherryPickup(int rows, int cols, int[][] grid) {\n        // Your logic goes here\n        // For simplicity, let's assume the base case is when there are no more moves to make.\n        if (rows == 0) return 0;\n\n        // Create a dynamic programming table with dimensions (rows - 1) x cols\n        int[][] dp = new int[rows - 1][cols];\n\n        // Fill in the table based on whether we pick up the cherry at the current position.\n        for (int i = rows - 2; i >= 0; i--) {\n            for (int j = 0; j < cols; j++) {\n                if (i == rows - 2) {\n                    dp[i][j] = grid[i + 1][j] + grid[i + 1][cols - 1];\n                } else {\n                    int leftPickup = i > 0 ? dp[i - 1][j] : 0;\n                    int rightPickup = i < rows - 2 ? dp[i + 1][cols - 1] : 0;\n\n                    // We can only pick up the cherry if there are no more moves to make.\n                    if (i == rows - 2) {\n                        leftPickup = rightPickup = 0;\n                    }\n\n                    // Choose the maximum between picking up cherries and not picking them up.\n                    dp[i][j] = Math.max(leftPickup + grid[i][j], rightPickup + grid[i][cols - 1]);\n                }\n            }\n        }\n\n        // The total number of cherries we can pick is stored in the top-right corner of the table.\n        return dp[0][0];\n    }\n}",
  "742": "```\nclass Solution {\n    class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode() {}\n        TreeNode(int x) { val = x; }\n        TreeNode(int x, TreeNode y, TreeNode z) {\n            val = x; left = y; right = z;\n        }\n    }\n\n    public TreeNode getClosestLeaf(TreeNode root) {\n        // Your code here\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        TreeNode root1 = new Solution.TreeNode(1);\n        root1.left = new Solution.TreeNode(3);\n        root1.right = new Solution.TreeNode(2);\n        System.out.println(\"Closest leaf in test case 1: \" + solution.getClosestLeaf(root1).val);\n\n        // Test case 2\n        TreeNode root2 = new Solution.TreeNode(1);\n        root2.left = new Solution.TreeNode(3);\n        root2.right = new Solution.TreeNode(4);\n        root2.left.left = new Solution.TreeNode(5);\n        System.out.println(\"Closest leaf in test case 2: \" + solution.getClosestLeaf(root2).val);\n\n        // Test case 3\n        TreeNode root3 = new Solution.TreeNode(1);\n        root3.right = new Solution.TreeNode(2);\n        root3.right.left = new Solution.TreeNode(6);\n        root3.right.right = new Solution.TreeNode(7);\n        System.out.println(\"Closest leaf in test case 3: \" + solution.getClosestLeaf(root3).val);\n    }\n}",
  "744": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + smallestLetter(\"abc\", 'b')); // Expected output: 'c'\n        System.out.println(\"Test Case 2: \" + smallestLetter(\"hi\", 'j')); // Expected output: 'h'\n        System.out.println(\"Test Case 3: \" + smallestLetter(\"lovelace\", 'd')); // Expected output: 'e'\n    }\n\n    public static Character smallestLetter(String letters, char target) {\n        int left = 0;\n        int right = letters.length() - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (letters.charAt(mid) > target) {\n                return letters.charAt(mid);\n            } else if (letters.charAt(mid) <= target) {\n                left = mid + 1;\n            }\n        }\n\n        return null; // No such letter found\n    }\n}",
  "743": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] times = {{2,1,1},{2,3,1},{3,4,1}};\n        int n = 4;\n        System.out.println(networkDelayTime(times, n));\n        \n        // Test case 2\n        times = new int[][]{{5,1,5},{4,2,3},{3,3,2},{1,4,2}};\n        n = 4;\n        System.out.println(networkDelayTime(times, n));\n\n        // Test case 3\n        times = {{1,2,1},{2,3,7},{1,3,3}};\n        n = 3;\n        System.out.println(networkDelayTime(times, n));\n    }\n\n    public static int networkDelayTime(int[][] times, int n) {\n        List<List<pair>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] time : times) {\n            graph.get(time[0] - 1).add(new pair(time[1] - 1, time[2]));\n        }\n\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n\n        PriorityQueue<pair> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\n\n        pq.offer(new pair(0, 0));\n\n        while (!pq.isEmpty()) {\n            pair node = pq.poll();\n            for (pair neighbor : graph.get(node.idx)) {\n                int oldDist = dist[neighbor.idx];\n                int newDist = node.val + neighbor.val;\n                if (newDist < oldDist) {\n                    dist[neighbor.idx] = newDist;\n                    pq.offer(new pair(newDist, neighbor.idx));\n                }\n            }\n        }\n\n        int maxDelayTime = 0;\n        for (int i = 1; i < n; i++) {\n            maxDelayTime = Math.max(maxDelayTime, dist[i]);\n        }\n        return maxDelayTime == Integer.MAX_VALUE ? -1 : maxDelayTime;\n    }\n\n    static class pair implements Comparable<pair> {\n        int idx;\n        int val;\n\n        public pair(int idx, int val) {\n            this.idx = idx;\n            this.val = val;\n        }\n\n        @Override\n        public int compareTo(pair o) {\n            return this.val - o.val;\n        }\n    }\n}",
  "745": "```\nclass Node {\n    char val;\n    Node[] children = new Node[26];\n}\n\npublic class WordFilter {\n    private Node root;\n\n    public WordFilter(String[] words) {\n        this.root = new Node();\n        for (String word : words) {\n            Node node = root;\n            for (char c : word.toCharArray()) {\n                if (node.children[c - 'a'] == null) {\n                    node.children[c - 'a'] = new Node();\n                }\n                node = node.children[c - 'a'];\n            }\n            node.val = '#';\n        }\n    }\n\n    public List<String> FFilter(String prefix) {\n        List<String> result = new ArrayList<>();\n        Node node = root;\n        for (char c : prefix.toCharArray()) {\n            if (node.children[c - 'a'] == null) {\n                return result;\n            }\n            node = node.children[c - 'a'];\n        }\n        dfs(node, \"\", 0, prefix.length(), result);\n        return result;\n    }\n\n    private void dfs(Node node, String suffix, int index, int length, List<String> result) {\n        if (node.val == '#') {\n            result.add(suffix);\n        }\n        for (int i = 0; i < 26; i++) {\n            if (node.children[i] != null) {\n                dfs(node.children[i], suffix + (char)(i + 'a'), index + 1, length, result);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        String[] words = {\"apple\",\"ot\", \"add\"};\n        WordFilter wf = new WordFilter(words);\n\n        System.out.println(\"Test case 1: prefix = apple\");\n        List<String> result1 = wf.FFilter(\"app\");\n        for (String s : result1) {\n            System.out.print(s + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Test case 2: prefix = add\");\n        List<String> result2 = wf.FFilter(\"ad\");\n        for (String s : result2) {\n            System.out.print(s + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Test case 3: prefix = ot\");\n        List<String> result3 = wf.FFilter(\"o\");\n        for (String s : result3) {\n            System.out.print(s + \" \");\n        }\n        System.out.println();\n    }\n}",
  "746": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minCostClimbingStairs(new int[]{10,15,20})); // Expected output: 15\n        System.out.println(minCostClimbingStairs(new int[]{1,100,1,1,1})); // Expected output: 6\n        System.out.println(minCostClimbingStairs(new int[]{1,2,4,8})); // Expected output: 6\n    }\n\n    public static int minCostClimbingStairs(int[] cost) {\n        if (cost.length == 0) return 0;\n        if (cost.length <= 2) return Math.min(cost[0], cost[1]);\n\n        for (int i = 2; i < cost.length; i++) {\n            cost[i] += Math.min(cost[i-1], cost[i-2]);\n        }\n\n        return Math.min(cost[cost.length - 1], cost[cost.length - 2]);\n    }\n}\n```",
  "747": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2, 7, 11};\n        System.out.println(findMax(nums1));\n        \n        int[] nums2 = {5, 4, 8, 3};\n        System.out.println(findMax(nums2));\n        \n        int[] nums3 = {6, 9, 14, 12};\n        System.out.println(findMax(nums3));\n    }\n\n    public static int findMax(int[] nums) {\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 1; i++) {\n            if ((nums[i] <= nums[i + 1] * 2)) {\n                return nums[i];\n            }\n        }\n        return nums[nums.length - 1];\n    }\n}",
  "749": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,1},{1,0}};\n        System.out.println(\"Expected: 2, Actual: \" + containVirus(grid1));\n        \n        int[][] grid2 = {{0,1,0},{1,1,0},{0,0,0}};\n        System.out.println(\"Expected: 4, Actual: \" + containVirus(grid2));\n\n        int[][] grid3 = {{1,1,1,0},{1,1,1,0}};\n        System.out.println(\"Expected: -1, Actual: \" + containVirus(grid3));\n    }\n\n    public static int containVirus(int[][] grid) {\n        // Your code goes here\n    }\n}\n```",
  "748": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(shortestCompletingWord(new String[]{\"a\", \"banana\"}, new String[]{\"kbana\", \"bana\"})); // Expected: banana\n        System.out.println(shortestCompletingWord(new String[]{\"msmt\", \"zebra\", \"robot\", \"bee\", \"are\", \"apple\", \"orange\", \"zoo\"}, new String[]{\"zoo\", \"embark\"})); // Expected: embark\n        System.out.println(shortestCompletingWord(new String[]{\"dog\", \"cat\", \"fish\"}, new String[]{\"catwalk\", \"dogfight\"})); // Expected: walk\n    }\n\n    public static String shortestCompletingWord(String[] words, String[] queries) {\n        Map<Character, Integer> wordMap = new HashMap<>();\n        for (String word : words) {\n            for (char c : word.toCharArray()) {\n                wordMap.put(c, wordMap.getOrDefault(c, 0) + 1);\n            }\n        }\n\n        for (String query : queries) {\n            int missingCount = 0;\n            Map<Character, Integer> queryMap = new HashMap<>();\n            for (char c : query.toLowerCase().toCharArray()) {\n                queryMap.put(c, queryMap.getOrDefault(c, 0) + 1);\n            }\n            for (Map.Entry<Character, Integer> entry : wordMap.entrySet()) {\n                if (!queryMap.containsKey(entry.getKey())) {\n                    missingCount++;\n                } else if (entry.getValue() > queryMap.get(entry.getKey())) {\n                    missingCount++;\n                }\n            }\n            if (missingCount == 0) {\n                return query;\n            }\n        }\n\n        for (String word : words) {\n            int missingCount = 0;\n            Map<Character, Integer> wordMapTemp = new HashMap<>(wordMap);\n            for (char c : word.toLowerCase().toCharArray()) {\n                wordMapTemp.put(c, wordMapTemp.getOrDefault(c, 0) - 1);\n            }\n            for (Map.Entry<Character, Integer> entry : wordMapTemp.entrySet()) {\n                if (entry.getValue() < 0) {\n                    missingCount++;\n                } else if (entry.getValue() == 0) {\n                    missingCount++;\n                }\n            }\n            if (missingCount == 0) {\n                return word;\n            }\n        }\n\n        return \"\";\n    }\n}",
  "750": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,1,0,1},{1,1,1,1},{0,1,0,1}};\n        System.out.println(\"Number of Corner Rectangles for grid1: \" + countCornerRectangles(grid1));\n\n        int[][] grid2 = {{1,0,1},{1,1,1},{1,0,1}};\n        System.out.println(\"Number of Corner Rectangles for grid2: \" + countCornerRectangles(grid2));\n\n        int[][] grid3 = {{1,1,1},{1,1,1},{1,1,1}};\n        System.out.println(\"Number of Corner Rectangles for grid3: \" + countCornerRectangles(grid3));\n    }\n\n    public static int countCornerRectangles(int[][] grid) {\n        // Write your code here\n        return 0;\n    }\n}\n```",
  "751": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(ipToCIDR(\"1.1.1.1/24\")); // Expected: \"1.1.1.0/24\"\n        System.out.println(ipToCIDR(\"255.255.255.255/32\")); // Expected: \"255.255.255.255/32\"\n        System.out.println(ipToCIDR(\"192.168.5.100/16\")); // Expected: \"192.168.0.0/16\"\n    }\n\n    public static String ipToCIDR(String ip) {\n        String[] parts = ip.split(\"/\");\n        long networkAddress = getNetworkAddress(parts[0]);\n        int subnetMaskLength = Integer.parseInt(parts[1]);\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(getIPv4Address(networkAddress));\n        sb.append(\"/\").append(subnetMaskLength);\n\n        return sb.toString();\n    }\n\n    private static long getNetworkAddress(String ip) {\n        String[] parts = ip.split(\"\\\\.\");\n        long address = 0;\n        for (int i = 0; i < 4; i++) {\n            address |= Long.parseLong(parts[i]) << ((3 - i) * 8);\n        }\n        return address;\n    }\n\n    private static String getIPv4Address(long networkAddress) {\n        StringBuilder sb = new StringBuilder();\n        sb.append((networkAddress >> 24));\n        sb.append(\".\").append(((networkAddress >> 16) & 0xFF)).append(\".\").append(((networkAddress >> 8) & 0xFF)).append(\".\").append(networkAddress & 0xFF);\n        return sb.toString();\n    }\n}\n```",
  "752": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] tests = {\"0000\", \"1001\", \"1342\"};\n        \n        for (String test : tests) {\n            System.out.println(\"Test case: \" + test);\n            System.out.println(\"Expected result: \" + canBeOpen(test));\n            System.out.println();\n        }\n    }\n\n    public static boolean canBeOpen(String deadends, String target) {\n        Set<String> set = new HashSet<>();\n        for (String end : deadends.split(\"\")) {\n            set.add(end);\n        }\n\n        if (set.contains(target)) {\n            return false;\n        }\n\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(\"0000\");\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n\n            if (current.equals(target)) {\n                return true;\n            }\n\n            for (int i = 0; i < 4; i++) {\n                char[] arr = current.toCharArray();\n                char prev = arr[i];\n                arr[i]++;\n\n                if (arr[i] > '9') {\n                    arr[i] = '0';\n                } else if (arr[i] == '9' && prev != '8') {\n                    continue;\n                }\n\n                String next = new String(arr);\n\n                if (!set.contains(next)) {\n                    queue.offer(next);\n                }\n            }\n        }\n\n        return false;\n    }\n}",
  "753": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] graph1 = {{0, 1}, {1, 2}, {2, 3}};\n        System.out.println(\"Test case 1: \" + Arrays.toString(solution.canCrack(graph1)));\n        \n        int[][] graph2 = {{0, 1}, {1, 2}, {2, 2}};\n        System.out.println(\"Test case 2: \" + Arrays.toString(solution.canCrack(graph2)));\n        \n        int[][] graph3 = {{0, 1}, {1, 0}};\n        System.out.println(\"Test case 3: \" + Arrays.toString(solution.canCrack(graph3)));\n    }\n}\n\nclass Solution {\n    public List<Integer> canCrack(int[][] graphs) {\n        // Your code here\n    }\n}\n```",
  "754": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reachNumber(2)); // Expected output: 3\n        System.out.println(reachNumber(7)); // Expected output: 11\n        System.out.println(reachNumber(13)); // Expected output: 23\n    }\n\n    public static int reachNumber(int target) {\n        if (target < 0) target = -target;\n        int sum = 0, step = 1;\n        while (sum <= target) {\n            if (sum == target) return 1 + ((target % 2) != 0);\n            sum += step;\n            step += 1;\n        }\n        return 1 + (int) Math.ceil(Math.sqrt(2 * target));\n    }\n}\n```",
  "755": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] result1 = pourWater(new int[]{2, 1, 1, 2}, 2);\n        System.out.println(Arrays.deepToString(result1));\n        \n        int[][] result2 = pourWater(new int[]{1, 1, 4, 2, 3}, 6);\n        System.out.println(Arrays.deepToString(result2));\n        \n        int[][] result3 = pourWater(new int[]{5, 4, 7}, 10);\n        System.out.println(Arrays.deepToString(result3));\n    }\n\n    public static int[][] pourWater(int[] heights, int V) {\n        List<int[]> res = new ArrayList<>();\n        for (int i = 0; i < heights.length; i++) {\n            if (V > 0 && isPourable(heights, i)) {\n                pour(heights, i, V, res);\n                return res.toArray(new int[0][]);\n            }\n        }\n        return res.toArray(new int[0][]);\n    }\n\n    public static boolean isPourable(int[] heights, int index) {\n        for (int i = 0; i < index; i++) {\n            if (heights[i] > heights[index]) {\n                return false;\n            }\n        }\n        for (int i = index + 1; i < heights.length; i++) {\n            if (heights[i] > heights[index]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void pour(int[] heights, int index, int V, List<int[]> res) {\n        int left = 0, right = 0;\n        while (V > 0 && (left < index || right >= heights.length - index - 1)) {\n            if (V >= Math.max(1, heights[index] + 1)) {\n                res.add(new int[]{index, Math.min(V, heights[index] + 1)});\n                V -= Math.min(V, heights[index] + 1);\n                left = index;\n            } else if (V >= Math.max(1, heights[heights.length - index - 1] + 1)) {\n                res.add(new int[]{heights.length - index - 1, Math.min(V, heights[heights.length - index - 1] + 1)});\n                V -= Math.min(V, heights[heights.length - index - 1] + 1);\n                right = heights.length - index - 1;\n            } else {\n                int nextIndex = left < right ? left : right;\n                if (nextIndex > index) {\n                    res.add(new int[]{nextIndex, Math.min(V, 1)});\n                    V -= Math.min(V, 1);\n                }\n            }\n        }\n    }\n}",
  "756": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.deepToString(pyramidTransition(new String[]{\"BCD\", \"AAB\", \"CDE\"}, \"AAA\")));\n        System.out.println(Arrays.deepToString(pyramidTransition(new String[]{\"ABC\", \"DEF\", \"GHI\", \"JKL\"}, \"GIG\")))\n                .equals(\"[[1,0],[2,1]]\");\n        System.out.println(Arrays.deepToString(pyramidTransition(new String[]{\"A\",\"B\",\"C\"}, \"A\")));\n    }\n\n    public static int[][] pyramidTransition(String[] bottom, String target) {\n        Map<String, List<Character>> graph = new HashMap<>();\n        for (String s : bottom) {\n            for (int i = 0; i < s.length() - 1; i++) {\n                if (!graph.containsKey(s.substring(i, i + 1))) {\n                    graph.put(s.substring(i, i + 1), new ArrayList<>());\n                }\n                graph.get(s.substring(i, i + 1)).add(s.charAt(i + 1));\n            }\n        }\n\n        int[][] result = new int[graph.size()][2];\n        for (Map.Entry<String, List<Character>> entry : graph.entrySet()) {\n            if (!entry.getValue().contains(target.charAt(0))) {\n                return new int[0][];\n            }\n            result[entry.getKey().charAt(0) - 'A'] = new int[]{1, 0};\n        }\n        return result;\n    }\n}\n```",
  "757": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] datasets = { {1, 2, 2, 1}, {4, 4, 3, 2, 4}, {1, 3, 3} };\n        for (int[] dataset : datasets) {\n            System.out.println(intersectionSizeAtLeastTwo(dataset));\n        }\n    }\n\n    public static int intersectionSizeAtLeastTwo(int[][] datasets) {\n        int count = 0;\n        for (int i = 0; i < datasets[0].length; i++) {\n            int setA[] = new int[]{datasets[0][i], datasets[1][i]};\n            Arrays.sort(setA);\n            if (setA[0] == setA[1]) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
  "758": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(boldWords(\"aaabaab!\", new String[]{\"a\", \"b\"}));\n        System.out.println(boldWords(\"abc\", new String[]{\"a\", \"b\", \"c\"}));\n        System.out.println(boldWords(\"aabbcc\", new String[]{\"a\", \"bb\", \"ccc\"}));\n    }\n\n    public static String boldWords(String s, String[] words) {\n        TrieNode root = new TrieNode();\n        for (String word : words) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                if (!node.children.containsKey(c)) {\n                    node.children.put(c, new TrieNode());\n                }\n                node = node.children.get(c);\n            }\n            node.isWord = true;\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (!root.children.containsKey(c)) {\n                result.append(c);\n            } else {\n                TrieNode node = root.children.get(c);\n                while (node != null) {\n                    if (node.isWord) {\n                        result.append(\"<b>\").append(String.valueOf(c)).append(\"</b>\");\n                        break;\n                    }\n                    for (char nextChar : node.children.keySet()) {\n                        node = node.children.get(nextChar);\n                        if (node.isWord) {\n                            result.append(\"<b>\").append(String.valueOf(c)).append(\"</b>\");\n                            i += node.children.size() - 1; // skip the word\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return result.toString();\n    }\n\n    static class TrieNode {\n        Map<Character, TrieNode> children = new HashMap<>();\n        boolean isWord;\n\n        public TrieNode() {}\n    }\n}",
  "759": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<List<Integer>> employeeFreeTime(List<List<Integer>> workTimes) {\n        // Your implementation here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        List<List<Integer>> workTimes1 = Arrays.asList(\n            Arrays.asList(0, 10),\n            Arrays.asList(5, 18)\n        );\n        List<List<Integer>> expected1 = Arrays.asList(\n            Arrays.asList(0, 5),\n            Arrays.asList(10, 12),\n            Arrays.asList(13, 18)\n        );\n        System.out.println(\"Test case 1:\");\n        List<List<Integer>> result1 = solution.employeeFreeTime(workTimes1);\n        for (List<Integer> freeTime : result1) {\n            System.out.println(freeTime);\n        }\n        System.out.println();\n\n        // Test case 2\n        List<List<Integer>> workTimes2 = Arrays.asList(\n            Arrays.asList(1, 4),\n            Arrays.asList(2, 5)\n        );\n        List<List<Integer>> expected2 = Arrays.asList(\n            Arrays.asList(0, 1),\n            Arrays.asList(4, 5),\n            Arrays.asList(6, 7)\n        );\n        System.out.println(\"Test case 2:\");\n        List<List<Integer>> result2 = solution.employeeFreeTime(workTimes2);\n        for (List<Integer> freeTime : result2) {\n            System.out.println(freeTime);\n        }\n        System.out.println();\n\n        // Test case 3\n        List<List<Integer>> workTimes3 = Arrays.asList(\n            Arrays.asList(23, 26),\n            Arrays.asList(1, 4),\n            Arrays.asList(5, 8)\n        );\n        List<List<Integer>> expected3 = Arrays.asList(\n            Arrays.asList(0, 1),\n            Arrays.asList(4, 5),\n            Arrays.asList(6, 7),\n            Arrays.asList(8, 12),\n            Arrays.asList(23, 26)\n        );\n        System.out.println(\"Test case 3:\");\n        List<List<Integer>> result3 = solution.employeeFreeTime(workTimes3);\n        for (List<Integer> freeTime : result3) {\n            System.out.println(freeTime);\n        }\n    }\n}",
  "760": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Map<String, String> result1 = findAnagrams(new String[]{\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"});\n        System.out.println(\"Test case 1: \" + result1);\n\n        Map<String, String> result2 = findAnagrams(new String[]{\"a\", \"b\", \"c\", \"d\", \"e\"});\n        System.out.println(\"Test case 2: \" + result2);\n\n        Map<String, String> result3 = findAnagrams(new String[]{\"abc\", \"xyz\", \"xyx\", \"zyz\"});\n        System.out.println(\"Test case 3: \" + result3);\n    }\n\n    public static Map<String, String> findAnagrams(String[] strings) {\n        Map<String, String> anagramMap = new HashMap<>();\n        for (String str : strings) {\n            char[] strArray = str.toCharArray();\n            Arrays.sort(strArray);\n            String sortedStr = new String(strArray);\n            if (!anagramMap.containsKey(sortedStr)) {\n                anagramMap.put(sortedStr, str);\n            } else {\n                anagramMap.put(sortedStr, anagramMap.get(sortedStr) + \", \" + str);\n            }\n        }\n        return anagramMap;\n    }\n}",
  "761": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(specialBinary(\"111000\")); // Expected: true\n        System.out.println(specialBinary(\"1100\")); // Expected: false\n        System.out.println(specialBinary(\"1010101\")); // Expected: true\n    }\n\n    public static boolean specialBinary(String s) {\n        return specialBinaryHelper(s, 0, 0);\n    }\n\n    private static boolean specialBinaryHelper(String s, int start, int end) {\n        if (start >= end) {\n            return true;\n        }\n        for (int i = start; i < end; i++) {\n            if ((s.charAt(i) == '1' && s.charAt(i + 1) == '0') ||\n                    (s.charAt(i) == '0' && s.charAt(i + 1) == '1')) {\n                return false;\n            }\n        }\n        return specialBinaryHelper(s, end, s.length());\n    }\n}\n```",
  "762": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfSetBits(10)); // Test case 1\n        System.out.println(numberOfSetBits(9)); // Test case 2\n        System.out.println(numberOfSetBits(11)); // Test case 3\n    }\n\n    public static int numberOfSetBits(int n) {\n        int count = 0;\n        while (n > 0) {\n            n &= (n - 1);\n            count++;\n        }\n        return count;\n    }\n}\n```",
  "763": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(partitionLabels(\"abacdef\"));\n        System.out.println(partitionLabels(\"eaeaaea\"));\n        System.out.println(partitionLabels(\"aapaaaaya\"));\n    }\n\n    public static int partitionLabels(String s) {\n        int n = s.length();\n        int[] lastSeen = new int[26];\n        for (int i = 0; i < n; i++) {\n            lastSeen[s.charAt(i) - 'a'] = i;\n        }\n        int start = 0, end = 0;\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            end = Math.max(end, lastSeen[s.charAt(i) - 'a']);\n            if (i == end) {\n                ans += (end - start + 1);\n                start = i + 1;\n            }\n        }\n        return ans;\n    }\n}\n```",
  "764": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(largestPlusSign(\"uisse+++s++us+s\"));//Expected output: 7\n        System.out.println(largestPlusSign(\"++++++...+++++\"));//Expected output: 8\n        System.out.println(largestPlusSign(\"+++++++++++\"));//Expected output: 11\n    }\n\n    public static int largestPlusSign(String grid) {\n        // Your logic here\n        return 0; \n    }\n}\n```",
  "765": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(couplesHoldingHands(new int[][]{{1, 2}, {3, 4}})); // Expected: 1\n        System.out.println(couplesHoldingHands(new int[][]{{1, 2}, {5, 6}, {7, 8}})); // Expected: 4\n        System.out.println(couplesHoldingHands(new int[][]{{1, 2}, {3, 4}, {10, 20}})); // Expected: 3\n    }\n\n    public static int couplesHoldingHands(int[][] couples) {\n        UnionFind uf = new UnionFind(40001);\n        for (int[] couple : couples) {\n            uf.union(couple[0], couple[1]);\n        }\n        return uf.getCount();\n    }\n}\n\nclass UnionFind {\n    private int count;\n    private int[] parent;\n\n    public UnionFind(int n) {\n        this.count = n;\n        this.parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public void union(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x != y) {\n            parent[x] = y;\n            count--;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n```",
  "766": "```\npublic class Main {\n    public static void main(String[] args) {\n        boolean[][] matrix1 = {\n                {1,2,3},\n                {5,6,9},\n                {10,11,12}\n        };\n        System.out.println(\"Is Toeplitz Matrix: \" + isToeplitzMatrix(matrix1));\n\n        boolean[][] matrix2 = {\n                {1,2},\n                {2,3}\n        };\n        System.out.println(\"Is Toeplitz Matrix: \" + isToeplitzMatrix(matrix2));\n\n        boolean[][] matrix3 = {\n                {1,2,3,4,5},\n                {5,6,7,8,9},\n                {10,11,12,13,14},\n                {15,16,17,18,19}\n        };\n        System.out.println(\"Is Toeplitz Matrix: \" + isToeplitzMatrix(matrix3));\n    }\n\n    public static boolean isToeplitzMatrix(boolean[][] matrix) {\n        int m = matrix.length;\n        if (m == 0) return true;\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < matrix[0].length; j++) {\n                if (matrix[i][j] != matrix[i-1][j-1]) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n```",
  "767": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minMoves(\"aabaa\")); // Output: \"ab\"\n        System.out.println(minMoves(\"baabb\")); // Output: \"b\"\n        System.out.println(minMoves(\"aabbcc\")); // Output: \"abc\"\n    }\n\n    public static String minMoves(String s) {\n        int[] count = new int[256];\n        for (char c : s.toCharArray()) {\n            count[c]++;\n        }\n        char maxChar = ' ';\n        int maxCount = 0;\n        for (int i = 0; i < 256; i++) {\n            if (count[i] > maxCount) {\n                maxCount = count[i];\n                maxChar = (char) i;\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (maxCount-- > 0) {\n            sb.append(maxChar);\n        }\n\n        for (int i = 0; i < 256; i++) {\n            if (count[i] > 0) {\n                char c = (char) i;\n                int left = maxCount;\n                while (left-- > 0) {\n                    sb.append(c);\n                }\n                maxCount--;\n            }\n        }\n\n        return sb.toString();\n    }\n}\n```",
  "768": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxChunksToSorted(new int[]{5,4,3,2,1,0})); // Expected: 1\n        System.out.println(maxChunksToSorted(new int[]{0,1,2,3,4})); // Expected: 1\n        System.out.println(maxChunksToSorted(new int[]{0,1,51,52,100,101})); // Expected: 4\n    }\n\n    public static int maxChunksToSorted(int[] arr) {\n        int res = 0, maxSoFar = 0;\n        for (int i = 0; i < arr.length; i++) {\n            maxSoFar = Math.max(maxSoFar, arr[i]);\n            if (arr[i] >= maxSoFar) res++;\n            else if (maxSoFar > arr[i]) continue;\n        }\n        return res;\n    }\n}",
  "769": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maxChunksToSorted(new int[]{0,1,2,0,3,4})); // Expected: 5\n        System.out.println(maxChunksToSorted(new int[]{0,1,3,2})); // Expected: 2\n        System.out.println(maxChunksToSorted(new int[]{0,1,0,0})); // Expected: 3\n    }\n\n    public static int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        int res = 0;\n        int last = -1;\n\n        for (int i = 0; i < n; i++) {\n            if (i > last + 1 && arr[i] > arr[last + 1]) {\n                res++;\n                last = i;\n            }\n        }\n\n        return res;\n    }\n}",
  "770": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(evalExpr(\"1+2*3\")); // Expected: 7\n        System.out.println(evalExpr(\"(3+2)*3\")); // Expected: 15\n        System.out.println(evalExpr(\"0+(5-3)*(2-4)\")); // Expected: -2\n    }\n}\n```",
  "771": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numJewelsInStones(\"aA\", \"adD\")); // Expected: 2\n        System.out.println(numJewelsInStones(\"\", \"aaa\"));// Expected: 0\n        System.out.println(numJewelsInStones(\"Leet\", \"CodeLeet\"));// Expected: 5\n    }\n\n    public static int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n        for (char stone : stones.toCharArray()) {\n            if (jewels.indexOf(String.valueOf(stone)) != -1) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "772": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(eval(\"14-3/2\")); // expected output: 13\n        System.out.println(eval(\"10+(5*9)-3\")); // expected output: 88\n        System.out.println(eval(\"(3+2)*(4-1)\")); // expected output: 14\n    }\n}\n```",
  "773": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] board1 = {{1,2,3}, {4,0,5}, {7,8,6}};\n        System.out.println(\"Expected: 1\\nActual: \" + slidingPuzzle(board1));\n\n        int[][] board2 = {{1,2,3}, {4,5,0}, {7,8,6}};\n        System.out.println(\"Expected: 3\\nActual: \" + slidingPuzzle(board2));\n\n        int[][] board3 = {{1,2}, {4,0,3}, {7,5,6,8}};\n        System.out.println(\"Expected: -1\\nActual: \" + slidingPuzzle(board3));\n    }\n\n    public static int slidingPuzzle(int[][] board) {\n        // Your solution here\n    }\n}\n```",
  "774": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minimizeMaxDistance(new int[]{1,4,6,8,10}, 5));\n        System.out.println(minimizeMaxDistance(new int[]{7,5,3,9}, 2));\n        System.out.println(minimizeMaxDistance(new int[]{23,24,36,39,42}, 14));\n    }\n\n    public static int minimizeMaxDistance(int[] stations, int k) {\n        Arrays.sort(stations);\n        int left = 0, right = stations[stations.length - 1];\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (canPlaceStations(stations, k, mid)) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    public static boolean canPlaceStations(int[] stations, int k, int maxDist) {\n        int count = 0, prevStation = 0;\n        for (int station : stations) {\n            if (station - prevStation > maxDist) {\n                if (++count >= k) return false;\n                prevStation = station;\n            }\n        }\n        return true;\n    }\n}\n```",
  "775": "```\npublic class Solution {\n    public int findGlobalInversions(int[] nums) {\n        int count = 0;\n        for (int i = 1; i < nums.length; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[j] > nums[i]) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] test1 = {2,3};\n        System.out.println(\"Test 1: \" + solution.findGlobalInversions(test1));\n        \n        int[] test2 = {1,3,5};\n        System.out.println(\"Test 2: \" + solution.findGlobalInversions(test2));\n        \n        int[] test3 = {3,3,3,3};\n        System.out.println(\"Test 3: \" + solution.findGlobalInversions(test3));\n    }\n}",
  "776": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(4);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(6);\n        root1.left.left = new TreeNode(1);\n        root1.left.right = new TreeNode(3);\n        splitBST(root1, 2);\n\n        System.out.println();\n\n        TreeNode root2 = new TreeNode(4);\n        root2.left = new TreeNode(1);\n        root2.right = new TreeNode(3);\n        splitBST(root2, 2);\n\n        System.out.println();\n\n        TreeNode root3 = new TreeNode(5);\n        splitBST(root3, 10);\n    }\n\n    public static void splitBST(TreeNode root, int val) {\n        // your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) { val = x; }\n}\n```",
  "777": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"RLR\", \"RLL\")); // expected: true\n        System.out.println(canBeEqual(\"RRLL\", \"RLLT\")); // expected: false\n        System.out.println(canBeEqual(\"LL\", \"P\")); // expected: false\n    }\n\n    public static boolean canBeEqual(String left, String right) {\n        int i = 0, j = 0;\n        while (i < left.length() && j < right.length()) {\n            if (left.charAt(i) == 'L' && right.charAt(j) == 'R') {\n                i++;\n                j++;\n            } else if (left.charAt(i) == 'R' && right.charAt(j) == 'L') {\n                j++;\n            } else if (left.charAt(i) == 'L' && right.charAt(j) == 'L') {\n                i++;\n            } else if (left.charAt(i) == 'R' && right.charAt(j) == 'R') {\n                j++;\n            }\n        }\n        return i == left.length() && j == right.length();\n    }\n}",
  "778": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,2},{0,1}};\n        System.out.println(\"Test case 1: \" + swimTime(grid1));\n        \n        int[][] grid2 = {{3,2,4,2,4,4,3,2},{2,2,1,4,3,1,5,1},{1,2,2,2,3,4,5,1},{2,3,2,2,3,4,3,2},{3,3,3,3,2,4,3,3},{2,4,3,2,3,2,3,3},{1,2,1,3,2,2,2,2}};\n        System.out.println(\"Test case 2: \" + swimTime(grid2));\n        \n        int[][] grid3 = {{1,5,1,1,4,1,4,3},{1,8,6,6,7,9,10,12},{2,3,3,2,1,2,2,2},{4,11,14,13,13,13,5,15},{13,19,21,18,20,16,17,25}};\n        System.out.println(\"Test case 3: \" + swimTime(grid3));\n    }\n\n    public static int swimTime(int[][] grid) {\n        // Your code here\n    }\n}\n```",
  "779": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(kthSymbolInGrammar(1, 3));\n        System.out.println(kthSymbolInGrammar(2, 4));\n        System.out.println(kthSymbolInGrammar(3, 10));\n    }\n\n    public static int kthSymbolInGrammar(int n, int k) {\n        if (k > (1 << n)) return 0;\n        for (int i = 2; i <= n; i++) {\n            k = k % (1 << i);\n            if ((k & (1 << (i - 1))) != 0) {\n                k = k | (~((1 << i) - 1));\n            }\n        }\n        return k;\n    }\n}\n```",
  "780": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canReach(new int[]{2,3,4}, 5)); // True\n        System.out.println(canReach(new int[]{4,2,3,0,9}, 10)); // False\n        System.out.println(canReach(new int[]{7}, 2)); // True\n    }\n\n    public static boolean canReach(int[] reach, int target) {\n        for (int i = reach.length - 1; i >= 0; i--) {\n            if (reach[i] <= target) {\n                return true;\n            }\n            target -= reach[i];\n        }\n        return false;\n    }\n}\n```",
  "781": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] forest = {1, 0, 3};\n        System.out.println(\"Number of rabbits: \" + numRabbits(forest));\n        \n        forest = new int[]{0, 0, 7, 5, 2, 20, 19};\n        System.out.println(\"Number of rabbits: \" + numRabbits(forest));\n        \n        forest = new int[]{1, 1, 4};\n        System.out.println(\"Number of rabbits: \" + numRabbits(forest));\n    }\n\n    public static int numRabbits(int[] forest) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < forest.length; i++) {\n            if (!map.containsKey(forest[i])) {\n                map.put(forest[i], 1);\n            } else {\n                map.put(forest[i], map.get(forest[i]) + 1);\n            }\n        }\n\n        int totalRabbits = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            int type = entry.getKey();\n            int count = entry.getValue();\n\n            int groupCount = type + 1;\n            int remainder = count % groupCount;\n\n            if (remainder == 0) {\n                totalRabbits += (count / groupCount) * groupCount;\n            } else {\n                totalRabbits += count;\n            }\n        }\n\n        return totalRabbits;\n    }\n}\n```",
  "782": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{0,1},{1,1}};\n        transformArray(arr1);\n        \n        int[][] arr2 = {{0,1},{1,1},{1,0}};\n        transformArray(arr2);\n        \n        int[][] arr3 = {{1,0,0},{1,0,1},{0,1,1}};\n        transformArray(arr3);\n    }\n\n    public static void transformArray(int[][] board) {\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                if ((board[i][j] + i/2 + j/3) % 2 == 1) {\n                    board[i][j] = 1;\n                } else {\n                    board[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n```",
  "783": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root1 = new Node(2);\n        root1.left = new Node(1);\n        root1.right = new Node(3);\n\n        System.out.println(\"Test case 1: \" + minDistance(root1));\n        \n        Node root2 = new Node(5);\n        root2.left = new Node(4);\n        root2.right = new Node(7);\n        root2.left.left = new Node(3);\n        root2.left.right = new Node(6);\n\n        System.out.println(\"Test case 2: \" + minDistance(root2));\n        \n        Node root3 = null;\n\n        System.out.println(\"Test case 3: \" + minDistance(root3));\n    }\n\n    public static int minDistance(Node root) {\n        if (root == null || root.left == null && root.right == null) {\n            return 0;\n        }\n        return Math.min(minDistance(root.left), minDistance(root.right)) + 1;\n    }\n\n    public static class Node {\n        int val;\n        Node left;\n        Node right;\n\n        public Node(int val) {\n            this.val = val;\n        }\n    }\n}",
  "784": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        allPermutations(\"a1b2\"); // Output: [ \"a1b2\", \"A1B2\" ]\n        System.out.println();\n\n        System.out.println(\"Test Case 2:\");\n        allPermutations(\"AA\"); // Output: [ \"AA\", \"Aa\", \"aa\" ]\n        System.out.println();\n\n        System.out.println(\"Test Case 3:\");\n        allPermutations(\"izz\"); // Output: [ \"izz\", \"IzZ\", \"iZZ\", \"IZZ\" ]\n        System.out.println();\n    }\n\n    public static void allPermutations(String s) {\n        List<String> result = new ArrayList<>();\n        backtrack(result, \"\", s);\n        for (String str : result) {\n            System.out.print(\"[\" + str + \"]\");\n        }\n        System.out.println();\n    }\n\n    private static void backtrack(List<String> result, String current, String remaining) {\n        if (remaining.isEmpty()) {\n            result.add(current);\n        } else {\n            char c = remaining.charAt(0);\n            backtrack(result, current + Character.toLowerCase(c), remaining.substring(1));\n            backtrack(result, current + Character.toUpperCase(c), remaining.substring(1));\n        }\n    }\n}",
  "785": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isBipartite(new int[][]{{1, 3}, {0, 2}, {1, 2}})); // true\n        System.out.println(isBipartite(new int[][]{{0, 3}, {1, 4}, {3, 2}, {2, 1}, {3, 4}, {4, 0}})); // false\n        System.out.println(isBipartite(new int[][]{})); // true\n    }\n\n    public static boolean isBipartite(int[][] graph) {\n        if (graph == null || graph.length == 0) return true;\n        int[] color = new int[graph.length];\n        for (int i = 0; i < graph.length; i++) {\n            if (!dfs(graph, i, 0, color)) return false;\n        }\n        return true;\n    }\n\n    public static boolean dfs(int[][] graph, int node, int color, int[] c) {\n        c[node] = color;\n        for (int neighbor : getNeighbors(graph, node)) {\n            if (c[neighbor] == -1) {\n                if (!dfs(graph, neighbor, 1 - color, c)) return false;\n            } else if (c[neighbor] == color) return false;\n        }\n        return true;\n    }\n\n    public static List<Integer> getNeighbors(int[][] graph, int node) {\n        List<Integer> neighbors = new ArrayList<>();\n        for (int i = 0; i < graph.length; i++) {\n            if (graph[node][i] == 1) neighbors.add(i);\n        }\n        return neighbors;\n    }\n}\n```",
  "786": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs1 = {{1, 2}, 3};\n        System.out.println(kthSmallestPrimeFraction(inputs1));\n\n        int[][] inputs2 = {{4,6},{5,7},{8,9},{10,11},{12,15}};\n        System.out.println(kthSmallestPrimeFraction(inputs2));\n\n        int[][] inputs3 = {{1, 3}, 4};\n        System.out.println(kthSmallestPrimeFraction(inputs3));\n    }\n\n    public static double kthSmallestPrimeFraction(int[][] primes) {\n        // Your code here\n    }\n}\n```",
  "787": "```\nimport java.util.*;\n\npublic class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        Map<Integer, List<int[]>> graph = new HashMap<>();\n        for (int[] flight : flights) {\n            if (!graph.containsKey(flight[0])) {\n                graph.put(flight[0], new ArrayList<>());\n            }\n            graph.get(flight[0]).add(new int[]{flight[1], flight[2]});\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        pq.offer(new int[]{src, 0, 0});\n        Map<Integer, Integer> distance = new HashMap<>();\n        while (!pq.isEmpty()) {\n            int[] node = pq.poll();\n            if (node[0] == dst) {\n                return node[1];\n            }\n            if (k < node[2]) continue;\n            for (int[] neighbor : graph.getOrDefault(node[0], Collections.emptyList())) {\n                int nextDistance = node[1] + neighbor[1];\n                if (!distance.containsKey(neighbor[0]) || distance.get(neighbor[0]) > nextDistance) {\n                    distance.put(neighbor[0], nextDistance);\n                    pq.offer(new int[]{neighbor[0], nextDistance, k - (node[2] - 1)});\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.findCheapestPrice(3, new int[][]{{0, 1, 100}, {1, 2, 100}}, 0, 2, 1)); // Output: 200\n        System.out.println(solution.findCheapestPrice(3, new int[][]{{0, 1, 100}, {1, 2, 500}, {2, 0, 1000}}, 0, 2, 1)); // Output: 500\n        System.out.println(solution.findCheapestPrice(4, new int[][]{{0, 1, 10}, {1, 2, 5}, {2, 3, 3}}, 0, 3, 1)); // Output: 9\n    }\n}",
  "788": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(24, \"1024\")); // Expected: true\n        System.out.println(canBeEqual(15, \"1015\")); // Expected: false\n        System.out.println(canBeEqual(8170, \"90187654\")); // Expected: true\n    }\n\n    public static boolean canBeEqual(int n, String s) {\n        int rotations = 0;\n        while (!isRotated(n, s)) {\n            n = (n % 10) * 10 + (n / 10);\n            s = rotate(s);\n            rotations++;\n        }\n        return rotations <= 100;\n    }\n\n    public static boolean isRotated(int n, String s) {\n        int num = n;\n        for (char c : s.toCharArray()) {\n            if ((c - '0') != num % 10) {\n                return false;\n            }\n            num /= 10;\n        }\n        return true;\n    }\n\n    public static String rotate(String s) {\n        char[] arr = s.toCharArray();\n        int start = 0, end = arr.length - 1;\n        while (start < end) {\n            char temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n        return new String(arr);\n    }\n}",
  "789": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minTime(\"ugknbfqjp\", \"trtnczdhp\"));//Expected: 18\n        System.out.println(minTime(\"aaa\", \"aaaaa\"));//Expected: 6\n        System.out.println(minTime(\"bbbaa\", \"aba\"));//Expected: 8\n    }\n\n    public static int minTime(String s, String t) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            if (!t.contains(String.valueOf(c))) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
  "790": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(trominoTiling(2)) ; // Test case 1\n        System.out.println(trominoTiling(4)) ; // Test case 2\n        System.out.println(trominoTiling(6)) ; // Test case 3\n\n    }\n\n    public static int trominoTiling(int n) {\n        if (n <= 0) return 0;\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            dp[i] = (dp[i - 1] * 2) + ((i > 1) ? dp[i - 2] : 1);\n        }\n        return dp[n];\n    }\n}\n```",
  "792": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfMatchingSubsequences(\"abc\", \"abbcbaca\")); // Expected output: 3\n        System.out.println(numberOfMatchingSubsequences(\"baa\", \"aba\")); // Expected output: 2\n        System.out.println(numberOfMatchingSubsequences(\"abar autocd\", \"abacus\")); // Expected output: 4\n    }\n\n    public static int numberOfMatchingSubsequences(String s, String t) {\n        // Your code goes here...\n    }\n}\n```",
  "791": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sortString(\"aaaabbb\")); // [\"a\",\"aa\",\"b\",\"bb\"]\n        System.out.println(sortString(\"zzyzx\")); // [\"z\",\"y\",\"x\",\"z\"]\n        System.out.println(sortString(\"gggg\")); // [\"g\",\"gg\",\"gg\",\"gg\"]\n    }\n\n    public static String sortString(String s) {\n        int[] charCount = new int[26];\n        for (char c : s.toCharArray()) {\n            charCount[c - 'a']++;\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        while (true) {\n            boolean added = false;\n            for (int i = 0; i < 26; i++) {\n                if (charCount[i] > 0) {\n                    for (int j = 0; j < charCount[i]; j++) {\n                        sb.append((char)('a' + i));\n                    }\n                    added = true;\n                    break;\n                }\n            }\n            if (!added) {\n                break;\n            }\n        }\n        \n        return sb.toString();\n    }\n}\n```",
  "793": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(preImageSizeOfFactorialZeroes(10));\n        System.out.println(preImageSizeOfFactorialZeroes(11));\n        System.out.println(preImageSizeOfFactorialZeroes(25));\n    }\n\n    public static int preImageSizeOfFactorialZeroes(int n) {\n        long res = 0;\n        for (int i = 5; ; i *= 5) {\n            int cnt = (int)((n + 1.0) / i);\n            res += cnt * (i - 1) - (cnt * cnt * i) / 2;\n            if (cnt < n / i + 1) break;\n        }\n        return (int)res;\n    }\n}",
  "794": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canWin(\".....\") + \" expected: true\");\n        System.out.println(canWin(\"...X..\") + \" expected: false\");\n        System.out.println(canWin(\"..X.X.\") + \" expected: true\");\n    }\n\n    public static boolean canWin(String state) {\n        for (int i = 0; i < 3; i++) {\n            if (state.charAt(i * 4) == 'X' && state.charAt(i * 4 + 1) == 'X' && state.charAt(i * 4 + 2) == 'X') return true;\n            if (state.charAt(i * 4) == 'O' && state.charAt(i * 4 + 1) == 'O' && state.charAt(i * 4 + 2) == 'O') return false;\n        }\n        for (int i = 0; i < 3; i++) {\n            if (state.charAt(i) == 'X' && state.charAt(i + 4) == 'X' && state.charAt(i + 8) == 'X') return true;\n            if (state.charAt(i) == 'O' && state.charAt(i + 4) == 'O' && state.charAt(i + 8) == 'O') return false;\n        }\n        for (int i = 0; i < 3; i++) {\n            if (state.charAt(0) == 'X' && state.charAt(4) == 'X' && state.charAt(8) == 'X') return true;\n            if (state.charAt(0) == 'O' && state.charAt(4) == 'O' && state.charAt(8) == 'O') return false;\n        }\n        return true;\n    }\n}",
  "795": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numSubarrays(new int[]{10,1,10,1}, 2, 3)); // Expected output: 15\n        System.out.println(numSubarrays(new int[]{2,1,4,3}, 2, 3)); // Expected output: 3\n        System.out.println(numSubarrays(new int[]{0,0}, 0, 1)); // Expected output: 6\n    }\n\n    public static int numSubarrays(int[] nums, int max, int min) {\n        int res = 0;\n        int left = 0;\n        for (int right = 0; right < nums.length; right++) {\n            while (nums[right] > max) {\n                if (nums[left] <= min) res += right - left;\n                left++;\n            }\n        }\n        return res + nums.length - left;\n    }\n}\n```",
  "796": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"aaca\", \"caa\")); // true\n        System.out.println(canBeEqual(\"aa\", \"aa\")); // false\n        System.out.println(canBeEqual(\"aa\", \"baa\")); // true\n    }\n\n    public static boolean canBeEqual(String s, String goal) {\n        if (s.length() != goal.length()) return false;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == goal.charAt(s.length() - 1 - i)) continue;\n            int j = s.length() - 1;\n            while (j > i && s.charAt(j) != goal.charAt(i)) j--;\n            if (j <= i) return false;\n            s = s.substring(0, i) + s.substring(i + 1);\n            goal = goal.substring(0, i) + goal.substring(i + 1);\n        }\n        return true;\n    }\n}",
  "797": "```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph = {{1,2},{2,3},{3,4},{4,2,{5}}};\n        List<List<Integer>> res = allPathsSourceTarget(graph, 0);\n        for (List<Integer> path : res) {\n            System.out.println(path);\n        }\n    }\n\n    public static List<List<Integer>> allPathsSourceTarget(int[][] graph, int source) {\n        List<List<Integer>> ans = new ArrayList<>();\n        backtrack(ans, new ArrayList<>(), graph, source, 0);\n        return ans;\n    }\n\n    private static void backtrack(List<List<Integer>> ans, List<Integer> path, int[][] graph, int target, int start) {\n        if (start == target) {\n            ans.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = 0; i < graph[start].length; i++) {\n            if (graph[start][i] > 0) {\n                path.add(i);\n                backtrack(ans, path, graph, target, i);\n                path.remove(path.size() - 1);\n            }\n        }\n    }\n}",
  "798": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + highestScoreChars(\"RYWZ\", \"ROR\"));\n        System.out.println(\"Test case 2: \" + highestScoreChars(\"XYZ\", \"XZY\"));\n        System.out.println(\"Test case 3: \" + highestScoreChars(\"ABCA\", \"CBAC\"));\n\n    }\n\n    public static int highestScoreChars(String s, String t) {\n        // Your code here\n    }\n}",
  "800": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(new String[]{\"123456\", \"234567\"}, new String[]{\"111156\", \"223333\"})); // true\n        System.out.println(canBeEqual(new String[]{\"123456\", \"234567\"}, new String[]{\"111156\", \"223444\"})); // false\n        System.out.println(canBeEqual(new String[]{\"123456\", \"123456\"}, new String[]{\"111156\", \"111156\"})); // true\n    }\n\n    public static boolean canBeEqual(String[] target, String[] restricted) {\n        for (int i = 0; i < target.length; i++) {\n            if (!canEqual(target[i], restricted[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean canEqual(String s1, String s2) {\n        int diffCount = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                diffCount++;\n            }\n        }\n        return diffCount == 3;\n    }\n}\n```",
  "799": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] testCases = {\n            {2, [5,4,1,3]},\n            {3, [6,7,8,12]},\n            {10, [10,10,10,10]}\n        };\n\n        for (int[] testCase : testCases) {\n            int champagne = testCase[0];\n            int[][] pours = testCase[1];\n            System.out.println(\"Champagne tower height for \" + champagne + \" bottles and \" + pours.length + \" pours: \" + champagneTower(pours));\n        }\n    }\n\n    public static int champagneTower(int poured, int[] bottle) {\n        int[][] piles = new int[101][2];\n\n        for (int i = 0; i < 100; i++) {\n            piles[i][1] = Math.min(99, Math.max(i - 100 * poured / bottle[i], 0));\n        }\n\n        for (int i = 0; i < bottle.length; i++) {\n            int pour = Math.min(piles[bottle[i]][0], bottle[i]);\n            int excess = pour;\n            for (int j = bottle[i]; j >= 1; j--) {\n                if (j <= piles[0].length) {\n                    int height = Math.max(0, Math.min(piles[j - 1][1] + excess, 99));\n                    piles[j][1] = height;\n                    excess -= height;\n                    if (excess == 0) break;\n                }\n            }\n        }\n\n        int maxPileHeight = 0;\n\n        for (int i = 0; i < piles.length; i++) {\n            maxPileHeight = Math.max(maxPileHeight, piles[i][1]);\n        }\n\n        return maxPileHeight;\n    }\n}",
  "801": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arr1 = {{1, 3, 5, 4}, {6, 7, 2, 5}};\n        System.out.println(\"Minimum Swaps To Make Sequences Increasing for \" + arr1[0].length + \": \" + minSwaps(arr1));\n        \n        int[][] arr2 = {{1, 3, 5, 4, 2}, {6, 7, 2, 5, 3}};\n        System.out.println(\"Minimum Swaps To Make Sequences Increasing for \" + arr2[0].length + \": \" + minSwaps(arr2));\n        \n        int[][] arr3 = {{1, 3, 5, 4, 2, 6}, {6, 7, 2, 5, 8, 9}};\n        System.out.println(\"Minimum Swaps To Make Sequences Increasing for \" + arr3[0].length + \": \" + minSwaps(arr3));\n    }\n\n    public static int minSwaps(int[][] arrays) {\n        if (arrays == null || arrays.length < 2) return 0;\n        \n        int n = arrays[0].length;\n        int swaps = 0;\n\n        for (int i = 0; i < n; i++) {\n            boolean[] visited = new boolean[n];\n            Arrays.fill(visited, false);\n            \n            for (int j = i; j < n; j++) {\n                if (!canIncrease(arrays[0], arrays[1], i, j, visited)) {\n                    swaps++;\n                    break;\n                }\n            }\n        }\n\n        return swaps;\n    }\n\n    public static boolean canIncrease(int[] arr1, int[] arr2, int pos1, int pos2, boolean[] visited) {\n        if (pos1 >= arr1.length || pos2 >= arr2.length) return false;\n\n        for (int i = 0; i < pos1; i++) {\n            if (visited[i]) continue;\n            if (arr1[i] > arr1[pos1] && arr2[i] <= arr2[pos2]) return false;\n            visited[i] = true;\n        }\n\n        for (int i = 0; i < pos2; i++) {\n            if (visited[i]) continue;\n            if (arr2[i] > arr2[pos2] && arr1[i] <= arr1[pos1]) return false;\n            visited[i] = true;\n        }\n\n        return true;\n    }\n}",
  "802": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph1 = {{0, 2}, {2, 3}, {1, 3}};\n        System.out.println(Arrays.toString(attemptToEscape(graph1)));\n        \n        int[][] graph2 = {{0, 1}, {2, 0}};\n        System.out.println(Arrays.toString(attemptToEscape(graph2)));\n        \n        int[][] graph3 = {{0, 1}, {1, 2}};\n        System.out.println(Arrays.toString(attemptToEscape(graph3)));\n    }\n\n    public static List<Integer> attemptToEscape(int[][] graph) {\n        int n = graph.length;\n        List<Integer> result = new ArrayList<>();\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                Arrays.fill(visited, false);\n                boolean isSafe = dfs(graph, i, visited);\n                if (!isSafe) {\n                    result.add(i);\n                }\n            }\n        }\n        return result;\n    }\n\n    public static boolean dfs(int[][] graph, int node, boolean[] visited) {\n        visited[node] = true;\n        for (int neighbor : getNeighbors(graph, node)) {\n            if (!visited[neighbor]) {\n                if (!dfs(graph, neighbor, visited)) {\n                    return false;\n                }\n            } else if (!getNeighborEdges(graph, node).contains(neighbor)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static List<Integer> getNeighbors(int[][] graph, int node) {\n        List<Integer> neighbors = new ArrayList<>();\n        for (int i = 0; i < graph.length; i++) {\n            if (graph[i].length > 0 && graph[i][0] == node) {\n                neighbors.add(i);\n            }\n        }\n        return neighbors;\n    }\n\n    public static List<Integer> getNeighborEdges(int[][] graph, int node) {\n        List<Integer> edges = new ArrayList<>();\n        for (int i = 0; i < graph.length; i++) {\n            if (graph[i].length > 0 && graph[i][0] == node) {\n                edges.add(i);\n            }\n        }\n        return edges;\n    }\n}\n```",
  "804": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numberOfUniqueEmails(new String[]{\"john.doe@johndoe.com\", \"foo@bar.com\", \"a@b.com\"}));\n        System.out.println(numberOfUniqueEmails(new String[]{\"joe.smith@example.com\", \"bob.smith@example.com\", \"joe.smith2@example.com\"}));\n        System.out.println(numberOfUniqueEmails(new String[]{\"\"}));\n    }\n\n    public static int numberOfUniqueEmails(String[] emails) {\n        Set<String> set = new HashSet<>();\n        for (String email : emails) {\n            int atSignIndex = email.indexOf('@');\n            String localPart = email.substring(0, atSignIndex).replaceAll(\"\\\\+|\\\\.\", \"\");\n            if (!set.add(localPart + \"@\" + email.substring(atSignIndex))) {\n                set.remove(localPart + \"@\" + email.substring(atSignIndex));\n            }\n        }\n        return set.size();\n    }\n}\n```",
  "803": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] wall = {{1,0,2,5,0},{4,2,0,0,3},{2,5,0,0,1},{1,1,7,3,6},{1,7,6,7,2}};\n        System.out.println(\"Case 1: \" + fallingBricks(wall));\n        \n        wall = new int[][]{{0,0,0},{0,1,0},{1,2,3}};\n        System.out.println(\"Case 2: \" + fallingBricks(wall));\n        \n        wall = new int[][]{{1,1,4},{7,6,5},{9,8,7}};\n        System.out.println(\"Case 3: \" + fallingBricks(wall));\n    }\n\n    public static int fallingBricks(int[][] wall) {\n        UnionFind uf = new UnionFind();\n        \n        for (int i = 0; i < wall.length; i++) {\n            for (int j = 0; j < wall[0].length; j++) {\n                if (wall[i][j] > 0) {\n                    uf.makeSet(i * wall[0].length + j);\n                }\n            }\n        }\n        \n        for (int i = 0; i < wall.length; i++) {\n            for (int j = 0; j < wall[0].length; j++) {\n                if (wall[i][j] > 0) {\n                    int left = j - 1;\n                    while (left >= 0 && wall[i][left] == 0) left--;\n                    int right = j + 1;\n                    while (right < wall[0].length && wall[i][right] == 0) right++;\n                    \n                    if (wall[i][j-1] > 0) {\n                        uf.union(uf.find(i * wall[0].length + j - 1), uf.find(i * wall[0].length + left));\n                    }\n                    if (wall[i][j+1] > 0) {\n                        uf.union(uf.find(i * wall[0].length + j + 1), uf.find(i * wall[0].length + right - 1));\n                    }\n                }\n            }\n        }\n        \n        int res = 0;\n        for (int i = 0; i < wall.length; i++) {\n            for (int j = 0; j < wall[0].length; j++) {\n                if (wall[i][j] > 0) {\n                    int set = uf.find(i * wall[0].length + j);\n                    res += uf.size(set);\n                }\n            }\n        }\n        \n        return res;\n    }\n\n    class UnionFind {\n        Map<Integer, Integer> parent = new HashMap<>();\n        Map<Integer, Integer> size = new HashMap<>();\n\n        public void makeSet(int x) {\n            parent.put(x, x);\n            size.put(x, 1);\n        }\n\n        public int find(int x) {\n            if (parent.get(x) != x) {\n                parent.put(x, find(parent.get(x)));\n            }\n            return parent.get(x);\n        }\n\n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n\n            if (rootX == rootY)\n                return;\n\n            if (size.get(rootX) < size.get(rootY)) {\n                parent.put(rootX, rootY);\n                size.put(rootY, size.get(rootY) + size.get(rootX));\n            } else {\n                parent.put(rootY, rootX);\n                size.put(rootX, size.get(rootX) + size.get(rootY));\n            }\n        }\n\n        public int size(int x) {\n            return size.get(find(x));\n        }\n    }\n}",
  "805": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canSplit(\"102002\")); // true\n        System.out.println(canSplit(\"00820619\"));// false\n        System.out.println(canSplit(\"30546\")); // true\n    }\n\n    public static boolean canSplit(String nums) {\n        int n = nums.length();\n        for (int i = 1; i < n; i++) {\n            long sum1 = 0, sum2 = 0;\n            for (int j = 0; j < i; j++) {\n                sum1 += nums.charAt(j) - '0';\n            }\n            for (int j = i; j < n; j++) {\n                sum2 += nums.charAt(j) - '0';\n            }\n            if ((sum1 * 2 == sum2) || (sum2 * 2 == sum1)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
  "806": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countLines(\"abc\"));\n        System.out.println(countLines(\"leet = encode\"));\n        System.out.println(countLines(\"abcdefghijklmnopqrstuvwxyz\"));\n    }\n\n    public static int countLines(String text) {\n        int lines = 1;\n        for (char c : text.toCharArray()) {\n            if (c == '\\n') {\n                lines++;\n            }\n        }\n        return lines;\n    }\n}\n```",
  "807": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{5, 3}, {4, 2}};\n        System.out.println(maxIncreaseKeepingSkyline(grid1));\n        \n        int[][] grid2 = {{9, 8}, {6, 7}};\n        System.out.println(maxIncreaseKeepingSkyline(grid2));\n        \n        int[][] grid3 = {{1, 3, 5}, {2, 4, 7}, {3, 5, 8}};\n        System.out.println(maxIncreaseKeepingSkyline(grid3));\n    }\n\n    public static int maxIncreaseKeepingSkyline(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        int[] rowMax = new int[m];\n        int[] colMax = new int[n];\n\n        for (int i = 0; i < m; i++) {\n            int maxRow = Integer.MIN_VALUE;\n            for (int j = 0; j < n; j++) {\n                maxRow = Math.max(maxRow, grid[i][j]);\n            }\n            rowMax[i] = maxRow;\n        }\n\n        for (int j = 0; j < n; j++) {\n            int maxCol = Integer.MIN_VALUE;\n            for (int i = 0; i < m; i++) {\n                maxCol = Math.max(maxCol, grid[i][j]);\n            }\n            colMax[j] = maxCol;\n        }\n\n        int totalIncrease = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int increase = Math.min(rowMax[i], colMax[j]) - grid[i][j];\n                if (increase > 0) {\n                    totalIncrease += increase;\n                    grid[i][j] += increase;\n                }\n            }\n        }\n\n        return totalIncrease;\n    }\n}",
  "808": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] amount = {10, 10};\n        System.out.println(\"Expected: \" + soupServings(amount));\n        amount = new int[]{4, 8};\n        System.out.println(\"Expected: \" + soupServings(amount));\n        amount = new int[]{5, 0};\n        System.out.println(\"Expected: \" + soupServings(amount));\n    }\n\n    public static int soupServings(int[] amount) {\n        if (amount[0] == 0 || amount[1] == 0) return (amount[0] > amount[1]) ? 1 : 2;\n        int min = Math.min(amount[0], amount[1]);\n        for (int i = 1; ; i++) {\n            double p1 = 1.0 / 2.0, p2 = 1.0 / 3.0, p3 = 1.0 - p1 - p2;\n            if (i >= min) break;\n            amount[0] -= i;\n            amount[1] -= i;\n        }\n        return (amount[0] > amount[1]) ? 1 : 2;\n    }\n}\n```",
  "809": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeExpressed(new String[]{\"short\", \"it\", \"president\", \"sweet\"}, new String[]{\"presidentisaleadytooexpressiveit\"});\n        System.out.println(canBeExpressed(new String[]{\"apple\", \"pig\", \"yellow\", \"blue\"}, new String[]{\"\"}));\n        System.out.println(canBeExpressed(new String[]{\"a\", \"b\", \"c\", \"d\"}, new String[]{\"abracadabra\"}));\n    }\n\n    public static boolean canBeExpressed(String[] words, String expression) {\n        int left = 0;\n        for (int right = 0; right < expression.length(); right++) {\n            if (expression.charAt(right) == ' ') {\n                left = right + 1;\n            }\n        }\n        for (String word : words) {\n            int pos = expression.indexOf(word);\n            while (pos != -1) {\n                left = Math.min(left, pos);\n                right = Math.max(right, pos + word.length());\n                pos = expression.indexOf(word, pos + 1);\n            }\n        }\n        return left <= right;\n    }\n}\n```",
  "810": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(new Solution().newGame(2, new int[]{1, 0}) == 1);\n        System.out.println(new Solution().newGame(4, new int[]{3, 2, 1, 0}) == 6);\n        System.out.println(new Solution().newGame(5, new int[]{1, 2, 3, 4, 5}) == 7);\n    }\n}\n\nclass Solution {\n    public int newGame(int n, int[] array) {\n        int res = 0;\n        for (int i : array) {\n            res ^= i;\n        }\n        return res;\n    }\n}",
  "811": "```\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        String[] cpdomains = {\"900 google.mail.com\", \"50 yahoo.com\", \"10 www.googlemail.com\"};\n        Map<String, Integer> map = countDomains(cpdomains);\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n    }\n\n    public static Map<String, Integer> countDomains(String[] cpdomains) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String domain : cpdomains) {\n            String[] splitDomain = domain.split(\" \");\n            int count = Integer.parseInt(splitDomain[0]);\n            String subdomain = splitDomain[1];\n            if (!map.containsKey(subdomain)) {\n                map.put(subdomain, 0);\n            }\n            map.put(subdomain, map.get(subdomain) + count);\n        }\n        return map;\n    }\n}",
  "812": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(largestTriangleArea(new int[][]{{0,1},{2,3}}) == 2);\n        System.out.println(largestTriangleArea(new int[][]{{4,7},{5,6},{3,10}}) == 9);\n        System.out.println(largestTriangleArea(new int[][]{{1,2},{2,3},{4,5}}) == 6);\n\n    }\n\n    public static double largestTriangleArea(int[][] coordinates) {\n        double max = 0;\n        for (int i = 0; i < coordinates.length; i++) {\n            for (int j = i + 1; j < coordinates.length; j++) {\n                for (int k = j + 1; k < coordinates.length; k++) {\n                    int[] p1 = {coordinates[i][0], coordinates[i][1]};\n                    int[] p2 = {coordinates[j][0], coordinates[j][1]};\n                    int[] p3 = {coordinates[k][0], coordinates[k][1]};\n\n                    double area = Math.abs((p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) / 2.0);\n                    max = Math.max(max, area);\n                }\n            }\n        }\n\n        return max;\n    }\n}\n```",
  "813": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] nums1 = {{9, 1, 2, 3, 9}};\n        System.out.println(\"Test case 1: \" + largestSumOfAverages(nums1));\n        \n        int[][] nums2 = {{7, 7, 6, 9, 3, 1, 8}];\n        System.out.println(\"Test case 2: \" + largestSumOfAverages(nums2));\n\n        int[][] nums3 = {{10, 12}};\n        System.out.println(\"Test case 3: \" + largestSumOfAverages(nums3));\n    }\n\n    public static double largestSumOfAverages(int[][] scores) {\n        int n = scores[0].length;\n        int[] totalScore = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= i; j++) {\n                totalScore[i + 1] += scores[j][i];\n            }\n        }\n\n        double maxSum = -1e9;\n        for (int i = 1; i < n; i++) {\n            double sum = (totalScore[i] - totalScore[i - 1]) / (i);\n            int remainder = (totalScore[i] - totalScore[i - 1]) % i;\n            if (remainder > 0) {\n                sum += (double) remainder / i;\n            }\n            maxSum = Math.max(maxSum, sum);\n        }\n\n        return maxSum;\n    }\n}",
  "814": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1\n        TreeNode root1 = new TreeNode(0);\n        root1.right = new TreeNode(1);\n        System.out.println(\"Test Case 1: \" + solution.pruneTree(root1));\n        \n        // Test Case 2\n        TreeNode root2 = new TreeNode(0);\n        root2.left = new TreeNode(1);\n        root2.right = new TreeNode(2);\n        System.out.println(\"Test Case 2: \" + solution.pruneTree(root2));\n        \n        // Test Case 3\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(0);\n        root3.right = new TreeNode(1);\n        System.out.println(\"Test Case 3: \" + solution.pruneTree(root3));\n    }\n}\n\nclass Solution {\n    public static TreeNode pruneTree(TreeNode root) {\n        // Your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "816": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numAmbiguousCoordinates(\"00000\"));\n        System.out.println(numAmbiguousCoordinates(\".87654\"));\n        System.out.println(numAmbiguousCoordinates(\".9999\"));\n    }\n}\n```",
  "815": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] bus Routes = {{1,2},{2,3},{3,4},{4,5}};\n        System.out.println(numBusesToDestination(busRoutes, 1, 6)); // test case 1\n        busRoutes = new int[][]{{1,2},{2,3},{7,6},{6,7},{6,1},{7,0},{4,7},{0,23},{23,0},{1,0},{0,1}};\n        System.out.println(numBusesToDestination(busRoutes, 14, 1)); // test case 2\n        busRoutes = new int[][]{{20,11},{11,18},{13,5},{5,6},{8,4},{15,3},{7,19},{12,5},{16,8}};\n        System.out.println(numBusesToDestination(busRoutes, 15, 2)); // test case 3\n    }\n\n    public static int numBusesToDestination(int[][] routes, int source, int target) {\n        if (source == target) return 0;\n        Map<Integer, List<Integer>> busStopMap = new HashMap<>();\n        for (int i = 0; i < routes.length; i++) {\n            for (int stop : routes[i]) {\n                busStopMap.computeIfAbsent(stop, k -> new ArrayList<>()).add(i);\n            }\n        }\n\n        Set<Integer> visited = new HashSet<>();\n        Queue<Integer> queue = new LinkedList<>();\n        int minDistance = Integer.MAX_VALUE;\n\n        queue.offer(source);\n        while (!queue.isEmpty()) {\n            int stop = queue.poll();\n            if (stop == target) {\n                return minDistance;\n            }\n            for (int bus : busStopMap.getOrDefault(stop, Collections.emptyList())) {\n                if (!visited.contains(bus)) {\n                    visited.add(bus);\n                    for (int stopOnBus : routes[bus]) {\n                        if (!visited.contains(stopOnBus)) {\n                            queue.offer(stopOnBus);\n                        }\n                    }\n                    minDistance = Math.min(minDistance, busStopMap.size() - visited.size());\n                }\n            }\n        }\n\n        return -1;\n    }\n}",
  "817": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1:\");\n        ListNode head = new ListNode(0);\n        ListNode node2 = new ListNode(1);\n        ListNode node3 = new ListNode(2);\n        head.next = node2;\n        node2.next = node3;\n        System.out.println(\"Number of components: \" + numComponents(head, new int[]{0, 1}));\n        \n        System.out.println(\"\\nTest case 2:\");\n        head = new ListNode(0);\n        node2 = new ListNode(1);\n        node3 = new ListNode(2);\n        head.next = node2;\n        node2.next = node3;\n        System.out.println(\"Number of components: \" + numComponents(head, new int[]{0, 2}));\n        \n        System.out.println(\"\\nTest case 3:\");\n        head = null;\n        System.out.println(\"Number of components: \" + numComponents(head, new int[]{}));\n    }\n\n    public static int numComponents(ListNode head, int[] G) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int g : G) {\n            map.put(g, 1);\n        }\n        \n        int count = 0;\n        boolean connected = false;\n        ListNode curr = head;\n        while (curr != null) {\n            if (!map.containsKey(curr.val)) {\n                connected = true;\n            } else {\n                connected = false;\n            }\n            if (!connected && map.containsKey(curr.next.val)) {\n                connected = true;\n            }\n            if (!connected) {\n                count++;\n            }\n            curr = curr.next;\n        }\n        return count;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) { val = x; }\n}\n```",
  "818": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1:\");\n        System.out.println(\"Expected: \" + raceCar(\"CACTCA\"));\n        System.out.println(\"Result: \" + raceCar(\"CACTCA\"));\n\n        System.out.println(\"\\nTest case 2:\");\n        System.out.println(\"Expected: \" + raceCar(\"AAAAAAA\"));\n        System.out.println(\"Result: \" + raceCar(\"AAAAAAA\"));\n\n        System.out.println(\"\\nTest case 3:\");\n        System.out.println(\"Expected: \" + raceCar(\"CABC\"));\n        System.out.println(\"Result: \" + raceCar(\"CABC\"));\n    }\n\n    public static int raceCar(String s) {\n        // Your code here\n        return -1; // Replace with your implementation\n    }\n}\n```",
  "819": "```\npublic class Main {\n    public static void main(String[] args) {\n        String words[] = {\"hello\", \"world\", \"leetcode\", \"world\", \"world\"};\n        System.out.println(mostCommonWord(words, 0));\n        \n        words = new String[]{\"bob\",\"alex\",\"hit\",\"ba\",\"sue\"];\n        System.out.println(mostCommonWord(words, -1));\n\n        words = new String[]{};\n        System.out.println(mostCommonWord(words, -1));\n    }\n\n    public static String mostCommonWord(String[] words, int num) {\n        if (words.length == 0) return \"\";\n        \n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            word = word.toLowerCase().replaceAll(\"[^a-zA-Z]\", \"\");\n            if (!map.containsKey(word)) {\n                map.put(word, 1);\n            } else {\n                map.put(word, map.get(word) + 1);\n            }\n        }\n\n        String maxWord = \"\";\n        int maxCount = 0;\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            if (entry.getValue() > maxCount) {\n                maxCount = entry.getValue();\n                maxWord = entry.getKey();\n            } else if (entry.getValue().equals(maxCount)) {\n                maxWord += \", \" + entry.getKey();\n            }\n        }\n\n        return num >= 0 ? maxWord : \"\";\n    }\n}\n```",
  "820": "```\npublic class Solution {\n    public String[] wordSubsequences(String[] words) {\n        TrieNode root = new TrieNode();\n        List<String> result = new ArrayList<>();\n        \n        for (String word : words) {\n            TrieNode current = root;\n            for (char c : word.toCharArray()) {\n                if (!current.children.containsKey(c)) {\n                    current.children.put(c, new TrieNode());\n                }\n                current = current.children.get(c);\n            }\n            current.isWord = true;\n        }\n        \n        for (String word : words) {\n            TrieNode current = root;\n            StringBuilder sb = new StringBuilder();\n            for (char c : word.toCharArray()) {\n                sb.append(c);\n                if (!current.children.containsKey(c)) {\n                    break;\n                }\n                current = current.children.get(c);\n            }\n            if (current.isWord && !sb.toString().equals(word)) {\n                result.add(sb.toString());\n            }\n        }\n        \n        return result.toArray(new String[0]);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words1 = {\"kink\", \"knit\", \"kinetic\", \"knight\"};\n        System.out.println(Arrays.deepToString(solution.wordSubsequences(words1)));\n        \n        String[] words2 = {\"time\", \"meant\", \"mentally\", \"mentee\", \"mentum\"};\n        System.out.println(Arrays.deepToString(solution.wordSubsequences(words2)));\n        \n        String[] words3 = {\"apple\", \"banana\", \"orange\", \"grape\"};\n        System.out.println(Arrays.deepToString(solution.wordSubsequences(words3)));\n    }\n}\n```",
  "821": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(shortestToChar(\"loveleetcode\", 'e')); // 0\n        System.out.println(shortestToChar(\"aaabbbbbbaabbabaabaaaa\", 'a')); // 1\n        System.out.println(shortestToChar(\"bbbabbbbababababa\", 'b')); // 2\n    }\n\n    public static int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = Math.min(i, n - i - 1);\n        }\n        int left = 0;\n        int right = n - 1;\n        while (left <= right) {\n            if (s.charAt(left) == c) {\n                for (int i = 0; i <= left; i++) {\n                    res[i] = Math.min(res[i], left - i);\n                }\n                break;\n            }\n            if (s.charAt(right) == c) {\n                for (int i = right; i >= 0; i--) {\n                    res[i] = Math.min(res[i], right - i);\n                }\n                break;\n            }\n            int mid = left + (right - left) / 2;\n            if (s.charAt(mid) < c) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return res;\n    }\n}",
  "822": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] cards = {{1, 2}, {2, 3}, {4, 5}};\n        System.out.println(\"Test case 1: \" + flipGame(cards));\n        \n        int[][] cards2 = {{1, 2}, {2, 3}, {3, 4}};\n        System.out.println(\"Test case 2: \" + flipGame(cards2));\n        \n        int[][] cards3 = {{1, 1}};\n        System.out.println(\"Test case 3: \" + flipGame(cards3));\n    }\n\n    public static String flipGame(int[][] positions) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < positions.length; i++) {\n            map.put(positions[i][0], positions[i][1]);\n            map.put(positions[i][1], positions[i][0]);\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            sb.append(entry.getKey());\n            sb.append(\" \");\n        }\n        \n        return sb.toString().trim();\n    }\n}\n```",
  "823": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(7);\n        root1.left.left = new TreeNode(2);\n        System.out.println(\"Expected: 2, Got: \" + countFactors(root1));\n\n        TreeNode root2 = new TreeNode(100);\n        System.out.println(\"Expected: 0, Got: \" + countFactors(root2));\n\n        TreeNode root3 = new TreeNode(4);\n        root3.left = new TreeNode(8);\n        root3.right = new TreeNode(10);\n        root3.left.left = new TreeNode(7);\n        root3.left.right = new TreeNode(8);\n        System.out.println(\"Expected: 5, Got: \" + countFactors(root3));\n    }\n\n    public static int countFactors(TreeNode root) {\n        // Your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode leftMostSetLeft;\n    TreeNode right;\n    TreeNode leftMostSetRight;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "824": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(goatLatin(\"I\"));\"Ilmaa\");\n        System.out.println(goatLatin(\"Run\"));\"Runninga\");\n        System.out.println(goatLatin(\"Hello\"));\"Ellohay\");\n    }\n\n    public static String goatLatin(String S) {\n        if(S == null || S.length() == 0){\n            return S;\n        }\n        StringBuilder sb = new StringBuilder();\n        String[] words = S.split(\"\\\\s+\");\n        for (String word : words) {\n            if(word.length() > 0 && !word.equalsIgnoreCase(\"a\") && !word.equalsIgnoreCase(\"e\")\n                    && !word.equalsIgnoreCase(\"i\") && !word.equalsIgnoreCase(\"o\") && !word.equalsIgnoreCase(\"u\")) {\n                sb.append(word).append(\"oa\");\n            } else {\n                sb.append(word).append(\"a\");\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "825": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] social = {{1,4},{2,3}};\n        System.out.println(numFriendPairs(social)); // 1\n\n        int[][] social1 = {{1,2},{2,3},{3,4},{4,5}};\n        System.out.println(numFriendPairs(social1)); // 0\n\n        int[][] social2 = {{1,3},{2,3},{5,7}};\n        System.out.println(numFriendPairs(social2)); // 3\n    }\n\n    public static int numFriendPairs(int[][] ages) {\n        Arrays.sort(ages, (a, b) -> a[0] - b[0]);\n        int res = 0;\n        for (int i = 1; i < ages.length; i++) {\n            if (ages[i][0] > ages[i-1][1]) break;\n            for (int j = i + 1; j < ages.length && ages[j][0] <= ages[i][1]; j++) {\n                res += Math.max(0, j - i - 1);\n            }\n        }\n        return res;\n    }\n}",
  "826": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] chargingTimes = new int[]{10,6,8,5};\n        System.out.println(\"Maximum profit is: \" + maxProfit(chargingTimes));\n        \n        int[] chargingTimes2 = new int[]{3, 11, 1, 12, 4, 7};\n        System.out.println(\"Maximum profit is: \" + maxProfit(chargingTimes2));\n\n        int[] chargingTimes3 = new int[]{1, 5, 3, 6, 9, 10, 8, 7, 2, 4};\n        System.out.println(\"Maximum profit is: \" + maxProfit(chargingTimes3));\n    }\n\n    public static int maxProfit(int[] charges) {\n        Arrays.sort(charges);\n        int max = 0;\n        for (int i = 1; i < charges.length; i++) {\n            if (charges[i] - charges[i-1] > 0) {\n                max += charges[i] - charges[i-1];\n            }\n        }\n        return max;\n    }\n}\n```",
  "828": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countUniqueChars(\"ABC\"));//Expected: 91\n        System.out.println(countUniqueChars(\"AEFCASTL\"));//Expected: 260\n        System.out.println(countUniqueChars(\"abcdefghijklmnopqrstuvwxyz\"));//Expected: 650\n    }\n\n    public static int countUniqueChars(String s) {\n        int n = s.length();\n        int[] charCount = new int[26];\n        for (int i = 0; i < n; i++) {\n            charCount[s.charAt(i) - 'A']++;\n        }\n        int uniqueCount = 0;\n        for (int count : charCount) {\n            if (count == 1) {\n                uniqueCount++;\n            }\n        }\n        long totalSubstrings = (long) Math.pow(n, n);\n        return (int)(totalSubstrings - Math.pow(uniqueCount, n));\n    }\n}\n```",
  "829": "```\npublic class Main {\n    public static void main(String[] args) {\n        int num = 15;\n        System.out.println(consecutiveNumbersSum(num));\n        \n        num = 9;\n        System.out.println(consecutiveNumbersSum(num));\n        \n        num = 4;\n        System.out.println(consecutiveNumbersSum(num));\n    }\n\n    public static boolean consecutiveNumbersSum(int n) {\n        for (int i = 1; ; i++) {\n            int sum = 0;\n            for (int j = 1; ; j++) {\n                sum += j;\n                if (sum == n) return true;\n                if (sum > n) break;\n            }\n        }\n    }\n}\n```",
  "827": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {\n            {0,0,1,0},\n            {0,1,1,0},\n            {0,1,1,0},\n            {0,0,0,1}\n        };\n        System.out.println(\"Expected 4, got \" + largestIsland(grid1) + \".\");\n\n        int[][] grid2 = {\n            {5,4,4,5,8,13,15,14,12,11},\n            {4,6,9,10,9,7,3,6,14,11},\n            {8,12,11,13,9,9,6,4,1,3},\n            {2,11,6,8,5,6,4,3,7,6},\n            {5,1,1,1,1,1,2,10,3,5},\n            {0,2,1,3,4,0,2,5,5,6},\n            {9,7,6,8,6,3,4,11,12,14},\n            {6,2,10,13,11,10,13,8,10,12},\n            {4,5,7,15,1,9,12,8,5,4},\n            {4,11,12,4,4,8,3,16,0,7}\n        };\n        System.out.println(\"Expected 6, got \" + largestIsland(grid2) + \".\");\n\n        int[][] grid3 = {\n            {1,0,1},\n            {0,0,1},\n            {1,0,1}\n        };\n        System.out.println(\"Expected 4, got \" + largestIsland(grid3) + \".\");\n    }\n\n    public static int largestIsland(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\n\n        int m = grid.length;\n        int n = grid[0].length;\n        int maxArea = 0;\n\n        UnionFind uf = new UnionFind(m * n);\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int x = i;\n                    int y = j;\n\n                    if (i > 0 && grid[i - 1][j] == 1) x -= 1;\n                    if (j > 0 && grid[i][j - 1] == 1) y -= 1;\n\n                    maxArea = Math.max(maxArea, uf.union(x * n + y, x * n + y));\n                }\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int x = i;\n                    int y = j;\n\n                    if (i > 0 && grid[i - 1][j] == 1) x -= 1;\n                    if (j > 0 && grid[i][j - 1] == 1) y -= 1;\n\n                    maxArea = Math.max(maxArea, uf.union(x * n + y, uf.find(x * n + y)));\n                }\n            }\n        }\n\n        return maxArea;\n    }\n}\n\nclass UnionFind {\n    int[] parent;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public void union(int a, int b) {\n        if (parent[a] != parent[b]) {\n            int rootA = find(a);\n            int rootB = find(b);\n\n            parent[rootA] = rootB;\n        }\n    }\n\n    public int find(int x) {\n        return parent[x];\n    }\n}",
  "830": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + largeGroupPositions(\"abbxxxxzyy\")); // [6,9]\n        System.out.println(\"Test Case 2: \" + largeGroupPositions(\"Ohhhoo\")); // [[8,11]]\n        System.out.println(\"Test Case 3: \" + largeGroupPositions(\"aaa\")); // [[0,2]]\n    }\n\n    public static List<List<Integer>> largeGroupPositions(String s) {\n        List<List<Integer>> res = new ArrayList<>();\n        int start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            if (end + 1 == s.length() || s.charAt(end) != s.charAt(start)) {\n                if (end - start >= 3) {\n                    res.add(Arrays.asList(start, end));\n                }\n                start = end;\n            }\n        }\n        return res;\n    }\n}\n```",
  "831": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(mask(\"hello world\")); // \"h**** **w***d\")\n        System.out.println(mask(\"abc123def456\")); // \"a*c12*d45e*f56\")\n        System.out.println(mask(\"abc\")); // \"a**c\")\n    }\n\n    public static String mask(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (Character.isDigit(s.charAt(i))) {\n                sb.append('*');\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}",
  "832": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] flipAndInvertImage = new int[][]{{1,0,1},{1,1,1},{0,0,0}};\n        int[][] result = flipAndInvertImage(new int[][]{flipAndInvertImage});\n        printArray(result);\n\n        flipAndInvertImage = new int[][]{{1,1,0,0},{1,0,1,1},{0,1,1,1},{1,1,1,1}};\n        result = flipAndInvertImage(new int[][]{flipAndInvertImage});\n        printArray(result);\n\n        flipAndInvertImage = new int[][]{{1,0,1},{1,1,0},{0,0,1}};\n        result = flipAndInvertImage(new int[][]{flipAndInvertImage});\n        printArray(result);\n    }\n\n    public static int[][] flipAndInvertImage(int[][] A) {\n        int[][] B = new int[A.length][A[0].length];\n        for (int i = 0; i < A.length; i++) {\n            int[] row = A[i];\n            int left = 0, right = row.length - 1;\n            while (left <= right) {\n                if (row[left] == row[right]) {\n                    B[i][right - left + 1] = 1;\n                } else {\n                    B[i][right - left + 1] = 0;\n                }\n                left++;\n                right--;\n            }\n        }\n        return B;\n    }\n\n    public static void printArray(int[][] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[0].length; j++) {\n                System.out.print(arr[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "833": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findReplaceString(\"Hello World\", new int[][]{{1,2,\"world\"}},new String[]{\"your\",\"new\" }));\n        \n        System.out.println(findReplaceString(\"Abba\", new int[][]{{0,2,\"a\"}} , new String[]{ \"cd\"}));\n        \n        System.out.println(findReplaceString(\"abc\", new int[][]{} , new String[]{ \"pqr\"}));\n\n    }\n\n    public static String findReplaceString(String S, int[][] indexes, String[] replacements) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i <= S.length(); i++) {\n            boolean found = false;\n            for (int[] index : indexes) {\n                if (i == index[0] && i == index[1]) {\n                    sb.append(replacements[indexes.indexOf(index)]);\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                sb.append(S.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}",
  "834": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfDistances(new TreeNode(1, new TreeNode(2, null, new TreeNode(3)), new TreeNode(4))));\n        System.out.println(sumOfDistances(new TreeNode(5, new TreeNode(6), new TreeNode(7))));\n\n        System.out.println(sumOfDistances(new TreeNode(10, new TreeNode(11, new TreeNode(12), new TreeNode(13)), new TreeNode(14))));\n\n    }\n\n    public static int sumOfDistances(TreeNode root) {\n        return sumOfDistances(root, 0);\n    }\n\n    public static int sumOfDistances(TreeNode node, int prevLevel) {\n        if (node == null)\n            return 0;\n        int level = 1 + (prevLevel == 0 ? 0 : sumOfDistances(node.left, prevLevel - 1));\n        int leftSum = sumOfDistances(node.left, level);\n        int rightSum = sumOfDistances(node.right, level);\n\n        return leftSum + (level * (level - 1) / 2) + rightSum;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) {\n        val = x;\n    }\n\n    public TreeNode(int x, TreeNode y, TreeNode z) {\n        val = x;\n        left = y;\n        right = z;\n    }\n}\n```",
  "835": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] img1 = {{1, 1, 0}, {0, 1, 0}, {0, 0, 1}};\n        int[][] img2 = {{1, 1, 1}, {1, 1, 0}, {0, 0, 1}};\n        System.out.println(\"Test case 1: \" + hasOverlap(img1, img2));\n        \n        int[][] img3 = {{1, 0, 1}, {0, 1, 1}, {0, 1, 1}};\n        int[][] img4 = {{1, 0, 1}, {0, 1, 1}, {0, 1, 1}};\n        System.out.println(\"Test case 2: \" + hasOverlap(img3, img4));\n        \n        int[][] img5 = {{1, 0, 0}, {0, 1, 0}, {0, 0, 0}};\n        int[][] img6 = {{1, 0, 0}, {0, 1, 0}, {0, 0, 0}};\n        System.out.println(\"Test case 3: \" + hasOverlap(img5, img6));\n    }\n    \n    public static boolean hasOverlap(int[][] img1, int[][] img2) {\n        for (int i = 0; i < Math.min(img1.length, img2.length); i++) {\n            for (int j = 0; j < Math.min(img1[0].length, img2[0].length); j++) {\n                if (img1[i][j] == 1 && img2[i][j] == 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```",
  "836": "```\npublic class Main {\n    public static void main(String[] args) {\n        RectangleOverlap solution = new RectangleOverlap();\n        \n        // Test case 1\n        int x1 = 0, y1 = 0, x2 = 2, y2 = 2;\n        int x3 = 1, y3 = 1, x4 = 3, y4 = 3;\n        System.out.println(solution.rectangleArea(x1, y1, x2, y2, x3, y3, x4, y4));\n        \n        // Test case 2\n        int x5 = -3, y5 = -3, x6 = -1, y6 = -1;\n        int x7 = 0, y7 = 0, x8 = 3, y8 = 3;\n        System.out.println(solution.rectangleArea(x5, y5, x6, y6, x7, y7, x8, y8));\n        \n        // Test case 3\n        int x9 = -10, y9 = 0, x10 = -2, y10 = 0;\n        int x11 = -1, y11 = 5, x12 = -5, y12 = 5;\n        System.out.println(solution.rectangleArea(x9, y9, x10, y10, x11, y11, x12, y12));\n    }\n}\n```",
  "837": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Solution().new21Game(2, 10, 1));\n        System.out.println(new Solution().new21Game(11, 26, 8));\n        System.out.println(new Solution().new21Game(3, 6, 2));\n    }\n}\n\nclass Solution {\n    public double new21Game(int n, int k, int max) {\n        if (k == n || n <= max) return 1.0;\n        double[] dp = new double[n + 1];\n        dp[0] = 1.0;\n        for (int i = 1; i < n; i++) {\n            dp[i] = dp[i - 1] / (i == k - 1 ? 1 : max);\n            if (i + max <= n) dp[i + max] += dp[i];\n        }\n        return dp[n - 1];\n    }\n}\n```",
  "838": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(pushDominoes(\"DDRR!\"));\n        System.out.println(pushDominoes(\"RDR!\"));\n        System.out.println(pushDominoes(\"RORR!RORR!\"));\n    }\n\n    public static String pushDominoes(String dominoes) {\n        char[] arr = dominoes.toCharArray();\n        int left = 0, right = arr.length - 1;\n        while (left < right) {\n            if (arr[left] == 'L') {\n                for (int i = left + 1; i <= right; i++) {\n                    if (arr[i] == 'R') {\n                        swap(arr, i, right);\n                        right--;\n                        break;\n                    }\n                }\n            } else if (arr[right] == 'R') {\n                for (int i = right - 1; i >= left; i--) {\n                    if (arr[i] == 'L') {\n                        swap(arr, i, left);\n                        left++;\n                        break;\n                    }\n                }\n            } else if (Character.isDigit(arr[left])) {\n                int i = left + 1;\n                while (i <= right && Character.isDigit(arr[i])) {\n                    i++;\n                }\n                for (; i <= right; i++) {\n                    arr[i - 1] = (char) (arr[i - 1] + arr[i] - '0');\n                }\n                right = i - 1;\n            } else if (Character.isDigit(arr[right])) {\n                int i = right - 1;\n                while (i >= left && Character.isDigit(arr[i])) {\n                    i--;\n                }\n                for (; i >= left; i--) {\n                    arr[i + 1] = (char) (arr[i + 1] + arr[i] - '0');\n                }\n                left = i + 1;\n            }\n        }\n        return new String(arr);\n    }\n\n    private static void swap(char[] arr, int i, int j) {\n        char temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}",
  "839": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(groupStrings(new String[]{\"abc\", \"bcd\", \"abe\"}).size()); // Expected: 1\n        System.out.println(groupStrings(new String[]{\"aaa\", \"aab\", \"aaz\", \"aae\"}).size()); // Expected: 3\n        System.out.println(groupStrings(new String[]{}).size()); // Expected: 0\n    }\n\n    public static List<List<String>> groupStrings(String[] strings) {\n        if (strings.length == 0) return new ArrayList<>();\n        \n        Map<String, Integer> parent = new HashMap<>();\n        Map<String, Integer> size = new HashMap<>();\n        for (String s : strings) {\n            int p = 0;\n            boolean firstUniqCharFound = false;\n            for (char c : s.toCharArray()) {\n                if (!firstUniqCharFound && !parent.containsKey(String.valueOf(c))) {\n                    firstUniqCharFound = true;\n                    p++;\n                }\n                parent.put(String.valueOf(c), p);\n                size.put(String.valueOf(c), 1);\n            }\n        }\n\n        Map<String, Integer> rank = new HashMap<>();\n        List<List<String>> ans = new ArrayList<>();\n\n        for (String s : strings) {\n            int p = parent.get(s.charAt(0));\n            if (rank.containsKey(p)) {\n                int r = rank.get(p);\n                while (size.get(String.valueOf(s.charAt(0))) > 1 && r < size.get(String.valueOf(s.charAt(0))) - 1) {\n                    s = s.substring(1) + s.charAt(0);\n                    p = parent.get(s.charAt(0));\n                    r++;\n                }\n            }\n\n            if (!ans.isEmpty() && !ans.get(ans.size() - 1).contains(s)) {\n                while (true) {\n                    int oldParent = p;\n                    p = find(parent, p);\n                    rank.put(oldParent, r);\n                    if (p == s.charAt(0) + \"\") break;\n                    size.put(String.valueOf(p), size.get(String.valueOf(p)) + size.get(String.valueOf(s.charAt(0))) - 1);\n                }\n            } else {\n                ans.add(new ArrayList<>(Arrays.asList(s)));\n                rank.clear();\n                size.clear();\n            }\n        }\n\n        return ans;\n    }\n\n    public static int find(Map<String, Integer> parent, String p) {\n        if (!parent.containsKey(p)) return p;\n        if (parent.get(p).equals(p)) return p;\n        parent.put(p, find(parent, parent.get(p)));\n        return parent.get(p);\n    }\n}",
  "841": "```\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Solution {\n    public int openLock(String[] keys, String[] rooms) {\n        // Your logic here\n    }\n\n    @Test\n    public void test1() {\n        Solution solution = new Solution();\n        assertEquals(1, solution.openLock(new String[]{\"w\", \"0\"}, new String[]{\"eat\", \"pot\", \"bad\", \"leo\"}));\n    }\n    \n    @Test\n    public void test2() {\n        Solution solution = new Solution();\n        assertEquals(-1, solution.openLock(new String[]{\"w\", \"00\", \"000\"}, new String[]{}));\n    }\n    \n    @Test\n    public void test3() {\n        Solution solution = new Solution();\n        assertEquals(7, solution.openLock(new String[]{\"eat\", \"pot\", \"bad\", \"leo\", \"1\", \"2\"}, new String[]{\"eat\", \"pot\", \"bad\", \"leo\", \"0\", \"0\"}));\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.test1();\n        solution.test2();\n        solution.test3();\n    }\n}",
  "840": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{4, 8, 5}, {3, 2, 1}, {6, 7, 3}};\n        System.out.println(numMagicSquaresInside(grid1)); // Expected: 1\n\n        int[][] grid2 = {{10, 11, 12}, {13, 14, 15}, {16, 17, 18}};\n        System.out.println(numMagicSquaresInside(grid2)); // Expected: 0\n\n        int[][] grid3 = {{7, 6, 9}, {5, 4, 1}, {8, 3, 2}};\n        System.out.println(numMagicSquaresInside(grid3)); // Expected: 1\n    }\n\n    public static int numMagicSquaresInside(int[][] grid) {\n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (isMagicSquare(grid, i, j)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public static boolean isMagicSquare(int[][] grid, int row, int col) {\n        int n = grid.length;\n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            total += grid[i][col];\n        }\n        if (!isMagicTotal(total)) return false;\n\n        for (int i = 0; i < n; i++) {\n            total = 0;\n            for (int j = 0; j < n; j++) {\n                total += grid[row][j];\n            }\n            if (!isMagicTotal(total)) return false;\n        }\n\n        for (int i = 0, k = row, j = col; i < n; i++, k++) {\n            if (k >= n) break;\n            total = 0;\n            for (int l = 0; l < n; l++) {\n                total += grid[k][l];\n            }\n            if (!isMagicTotal(total)) return false;\n        }\n\n        for (int i = row, k = col, j = 0; j < n; j++) {\n            if (i >= n) break;\n            total = 0;\n            for (int l = 0; l < n; l++) {\n                total += grid[i][l];\n            }\n            if (!isMagicTotal(total)) return false;\n            i++;\n        }\n\n        return true;\n    }\n\n    public static boolean isMagicTotal(int num) {\n        int sum = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9;\n        return num == sum;\n    }\n}",
  "843": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(masterMind(new int[]{1, 2, 0}, new char[]{'r', 'o', 'c'}, 2, \"cor\"));\n        System.out.println(masterMind(new int[]{5, 3, 0}, new char[]{'e', 'a', 'r', 't'}, 1, \"ear\"));\n        System.out.println(masterMind(new int[]{8, 7, 6}, new char[]{'o', 'l', 'n'}, 2, \"lon\"));\n    }\n\n    public static String masterMind(int[] code, char[] hints, int numBulls, String answer) {\n        // Your solution here\n    }\n}\n```",
  "842": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(new int[]{1, 2}, new int[]{1, 1, 2})); // Test case 1\n        System.out.println(canBeEqual(new int[]{1, 1, 2, 3, 5, 8}, new int[]{0, 1, 1, 2, 3, 5, 8})); // Test case 2\n        System.out.println(!canBeEqual(new int[]{1, 10}, new int[]{1, 0, 1, 7, 10, 2})); // Test case 3\n    }\n\n    public static boolean canBeEqual(int[] arr, int[] target) {\n        if (arr.length != target.length) return false;\n        if (arr[0] == target[0]) {\n            if (canBeFibonacci(target)) return true;\n        }\n        for (int i = 1; i < arr.length; i++) {\n            if (Math.abs(arr[i] - arr[i - 1]) != Math.abs(target[i] - target[i - 1])) return false;\n        }\n        return canBeFibonacci(target);\n    }\n\n    public static boolean canBeFibonacci(int[] arr) {\n        int a = 0, b = 1;\n        for (int i = 0; i < arr.length; i++) {\n            if (i == 0 || i == 1) continue;\n            if (arr[i] != a + b) return false;\n            int temp = a;\n            a = b;\n            b = temp + b;\n        }\n        return true;\n    }\n}\n```",
  "844": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(backspaceCompare(\"ab#c\", \"ad#c\")); // true\n        System.out.println(backspaceCompare(\"a#b\", \"c#d\")) ;// false\n        System.out.println(backspaceCompare(\"a##c\", \"#a#c\")) ;// true\n    }\n\n    public static boolean backspaceCompare(String s, String t) {\n        int i = s.length() - 1;\n        int j = t.length() - 1;\n\n        while (i >= 0 || j >= 0) {\n            while (i >= 0 && ((s.charAt(i)) == '#' || s.charAt(i) == ' ')) {\n                i--;\n            }\n            while (j >= 0 && ((t.charAt(j)) == '#' || t.charAt(j) == ' ')) {\n                j--;\n            }\n\n            if (i >= 0 && j >= 0) {\n                if (s.charAt(i) != t.charAt(j))\n                    return false;\n                i--;\n                j--;\n            } else if (i < 0 && j < 0)\n                return true;\n            else\n                return false;\n        }\n        return true;\n    }\n}\n```",
  "845": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestMountain(new int[]{2, 2, 2, 4, 6, 8, 10}) == 5);\n        System.out.println(longestMountain(new int[]{2, 1, 1}) == 2);\n        System.out.println(longestMountain(new int[]{0,3,2}) == 1);\n    }\n\n    public static int longestMountain(int[] arr) {\n        int n = arr.length;\n        int ans = 0;\n        for (int i = 1; i < n - 1; i++) {\n            if (arr[i] < arr[i - 1] && arr[i] < arr[i + 1]) {\n                int up = down = 1;\n                while (i - up >= 0 && arr[i - up] < arr[i - up + 1]) up++;\n                while (i + down < n && arr[i + down] > arr[i + down - 1]) down++;\n                ans = Math.max(ans, up + down);\n            }\n        }\n        return ans;\n    }\n}",
  "846": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(handOfStraights(new int[]{1,2,3,3,4,5})); // expected output: true\n        System.out.println(handOfStraights(new int[]{1,2,4})); // expected output: false\n        System.out.println(handOfStraights(new int[]{1,3,5,2,4})); // expected output: true\n    }\n\n    public static boolean handOfStraights(int[] deck) {\n        Arrays.sort(deck);\n        for (int i = 0; i < deck.length - 4; i++) {\n            if (isStraight(deck, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static boolean isStraight(int[] cards, int start) {\n        int currentCard = cards[start];\n        for (int i = start + 1; i <= start + 4; i++) {\n            if (cards[i] != currentCard + 1) {\n                return false;\n            }\n            currentCard++;\n        }\n        return true;\n    }\n}",
  "847": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph = {{1,2},{2,3},{3,1},{4,2}};\n        System.out.println(shortestPathVisitingAllNodes(graph));\n        \n        int[][] graph1 = {{1,2},{2,3},{3,4},{4,5},{5,1},{1,5}};\n        System.out.println(shortestPathVisitingAllNodes(graph1));\n\n        int[][] graph2 = {{1}};\n        System.out.println(shortestPathVisitingAllNodes(graph2));\n    }\n\n    public static int shortestPathVisitingAllNodes(int[][] graph) {\n        // Your code here\n    }\n}\n```",
  "848": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(shiftingLetters(\"abc\")); // Expected output: \"def\"\n        System.out.println(shiftingLetters(\"aaabbbcc\")); // Expected output: \"aaaabbcccdd\"\n        System.out.println(shiftingLetters(\"abcdefghijklmnopqrstuvwxyz\")); // Expected output: \"bcdfghijklmnopqrstuvwxyz\"\n    }\n\n    public static String shiftingLetters(String s) {\n        StringBuilder sb = new StringBuilder();\n        int shift = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            char c = (char) ((s.charAt(i) + shift) % 26);\n            if (c < 'a') c += 26;\n            sb.append(c);\n            shift = (shift + (s.charAt(i) - 'a' + 1)) % 26;\n        }\n        return sb.reverse().toString();\n    }\n}\n```",
  "849": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxDistToClosest(new int[]{2,3,1,1,5,6})); // Output: 3\n        System.out.println(maxDistToClosest(new int[]{1,0,0,0})); // Output: 3\n        System.out.println(maxDistToClosest(new int[]{1,1})); // Output: 1\n    }\n\n    public static int maxDistToClosest(int[] people) {\n        int n = people.length;\n        int res = 0;\n        for (int i = 0; i < n; ++i) {\n            if (people[i] == 0) {\n                int left = Math.max(0, i - 1);\n                int right = Math.min(n - 1, i + 1);\n                res = Math.max(res, (left + right) / 2);\n            }\n        }\n        return n - 1 - res;\n    }\n}\n```",
  "850": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1:\");\n        int[][] rec1 = {{0,2},{1,3},{1,3}};\n        System.out.println(\"Expected: 6, Actual: \" + rectangleArea(rec1));\n\n        System.out.println(\"\\nTest case 2:\");\n        int[][] rec2 = {{0,3},{1,2},{2,4},{3,3},{3,4}};\n        System.out.println(\"Expected: 8, Actual: \" + rectangleArea(rec2));\n\n        System.out.println(\"\\nTest case 3:\");\n        int[][] rec3 = {{1,3},{3,2},{5,4}};\n        System.out.println(\"Expected: 4, Actual: \" + rectangleArea(rec3));\n    }\n\n    public static int rectangleArea(int[][] rec) {\n        // Your solution here\n    }\n}",
  "851": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] richFriends = {{1, 2}, {1, 3}, {2, 3}};\n        System.out.println(numLoudFriends(richFriends)); // Expected output: 3\n\n        richFriends = new int[][]{{0, 1}, {1, 3}, {4, 5}};\n        System.out.println(numLoudFriends(richFriends)); // Expected output: 1\n\n        richFriends = new int[][]{{0, 1}, {1, 2}, {3, 4}, {4, 5}};\n        System.out.println(numLoudFriends(richFriends)); // Expected output: 1\n    }\n\n    public static int numLoudFriends(int[][] friends) {\n        int n = friends.length;\n        List<Integer> loud = new ArrayList<>();\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\n\n        for (int[] pair : friends) {\n            graph.computeIfAbsent(pair[0], k -> new HashSet<>()).add(pair[1]);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!graph.containsKey(i)) {\n                loud.add(i);\n            } else {\n                graph.get(i).remove(null);\n                if (graph.get(i).isEmpty()) {\n                    loud.add(i);\n                }\n            }\n        }\n\n        return loud.size();\n    }\n}\n```",
  "852": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {0,2,1};\n        System.out.println(\"Test case 1: \" + peakIndexInMountainArray(arr1));\n        \n        int[] arr2 = {3,5,3,4,2};\n        System.out.println(\"Test case 2: \" + peakIndexInMountainArray(arr2));\n        \n        int[] arr3 = {0,1,0};\n        System.out.println(\"Test case 3: \" + peakIndexInMountainArray(arr3));\n    }\n\n    public static int peakIndexInMountainArray(int[] arr) {\n        int start = 0;\n        int end = arr.length - 1;\n\n        while (start < end) {\n            int mid = start + (end - start) / 2;\n\n            if (arr[mid] > arr[mid + 1]) {\n                end = mid;\n            } else {\n                start = mid + 1;\n            }\n        }\n\n        return start;\n    }\n}\n```",
  "853": "```\npublic class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        List<int[]> cars = new ArrayList<>();\n        for (int i = 0; i < position.length; i++) {\n            cars.add(new int[]{position[i], speed[i]});\n        }\n        \n        Collections.sort(cars, (a, b) -> a[0] - b[0]);\n        \n        int fleet = 0;\n        double time = 0.0;\n        for (int[] car : cars) {\n            if ((target - car[0]) / (double)car[1] > time) {\n                fleet++;\n                time = (target - car[0]) / (double)car[1];\n            }\n        }\n        \n        return fleet;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.carFleet(12, new int[]{10, 8, 9}, new int[]{3, 2, 1}));\n        System.out.println(solution.carFleet(100, new int[]{50, 30, 20, 40, 0}, new int[]{5, 7, 7, 6, 4}));\n        System.out.println(solution.carFleet(10, new int[]{3}, new int[]{3}));\n    }\n}",
  "854": "```\nimport java.util.*;\n\nclass Solution {\n    public boolean areKSimilar(String s1, String s2) {\n        Map<Character, Character> map = new HashMap<>();\n        for (int i = 0; i < s1.length(); i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                char c1 = s1.charAt(i);\n                char c2 = s2.charAt(i);\n                if (!map.containsKey(c1)) map.put(c1, c2);\n                else if (!map.get(c1).equals(c2)) return false;\n            }\n        }\n        for (int i = 0; i < s1.length(); i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                char c1 = map.getOrDefault(s1.charAt(i), 'z');\n                if (c1 == s1.charAt(i)) return false;\n                int idx = i + 1;\n                while (idx < s1.length() && map.containsKey(s1.charAt(idx))) idx++;\n                if (idx >= s1.length()) idx = s2.length();\n                char c2 = s2.charAt(idx);\n                if (!c2.equals(c1)) return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.areKSimilar(\"abc\", \"cab\")); // Expected: true\n        System.out.println(solution.areKSimilar(\"abcde\", \"caedb\")); // Expected: true\n        System.out.println(solution.areKSimilar(\"ab\", \"bc\")); // Expected: false\n    }\n}",
  "856": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(scoreOfParentheses(\"(()())(())\")); // Output: 4\n        System.out.println(scoreOfParentheses(\"(())((()))\")); // Output: 12\n        System.out.println(scoreOfParentheses(\"()()()\")); // Output: 0\n    }\n\n    public static int scoreOfParentheses(String S) {\n        int score = 0;\n        int depth = 0;\n        for (int i = 0; i < S.length(); i++) {\n            if (S.charAt(i) == '(') {\n                if (depth > 0) {\n                    score += 1 << (depth - 1);\n                }\n                depth++;\n            } else if (S.charAt(i) == ')') {\n                depth--;\n            }\n        }\n        return score;\n    }\n}",
  "855": "```\nimport java.util.PriorityQueue;\nimport java.util.Arrays;\n\npublic class ExamRoom {\n    private PriorityQueue<Integer> pq;\n\n    public ExamRoom(int n) {\n        pq = new PriorityQueue<>((a, b) -> Integer.compare(b, a));\n        for (int i = 1; i <= n; i++) {\n            pq.offer(i);\n        }\n    }\n\n    public int[] examRoom(int n) {\n        pq = new PriorityQueue<>((a, b) -> Integer.compare(b, a));\n        for (int i = 1; i <= n; i++) {\n            pq.offer(i);\n        }\n        int[] res = new int[0];\n        while (!pq.isEmpty()) {\n            int capacity = pq.poll();\n            if (res.length == 0 || capacity - res[res.length-1] > 5) {\n                res = Arrays.copyOf(res, res.length + 1);\n                res[res.length - 1] = capacity;\n            } else {\n                res = Arrays.copyOf(res, res.length + 2);\n                res[res.length - 2] = capacity - 1;\n                res[res.length - 1] = capacity;\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        ExamRoom room = new ExamRoom(4);\n        System.out.println(Arrays.toString(room.examRoom(4))); // Output: [0, 3]\n        System.out.println(Arrays.toString(room.examRoom(7))); // Output: [0, 2, 6]\n        System.out.println(Arrays.toString(room.examRoom(10))); // Output: [0, 3, 6, 9]\n    }\n}",
  "858": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(mirrorReflection(2, 1, 4)); // Expected output: 2\n        System.out.println(mirrorReflection(3, 1, 5)); // Expected output: 1\n        System.out.println(mirrorReflection(1000000019, 999983012, 1000000009)); // Expected output: 7\n    }\n\n    public static int mirrorReflection(int p, int q, int target) {\n        if (p > q) {\n            return (target - q) / (q - p);\n        } else {\n            return (target - p) / (p - q);\n        }\n    }\n}\n```",
  "857": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] costs = {{10,20},{5,9},{3,4}};\n        System.out.println(minCostToHireKWorkers(costs, 2));\n\n        int[][] costs1 = {{16,8},{7,5},{3,6}};\n        System.out.println(minCostToHireKWorkers(costs1, 2));\n\n        int[][] costs2 = {{70,50},{11,42},{5,30}};\n        System.out.println(minCostToHireKWorkers(costs2, 3));\n    }\n\n    public static double minCostToHireKWorkers(int[][] costs, int k) {\n        Arrays.sort(costs, (a, b) -> a[0] - b[0]);\n        \n        PriorityQueue<Integer> pq = new PriorityQueue<>((x,y)->y-x);\n        double totalCost = 0;\n        for(int i=0;i<k;i++){\n            totalCost += costs[i][1];\n            pq.offer(costs[i][0]);\n        }\n        \n        while(!pq.isEmpty()){\n            int wage = pq.poll();\n            while(!pq.isEmpty() && pq.peek()<=wage){\n                pq.poll();\n            }\n            if(!pq.isEmpty()) {\n                totalCost += (double) wage / pq.size();\n            }\n        }\n        return totalCost;\n    }\n}",
  "859": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeBuddy(\"aa\", \"bb\")); // Expected: true\n        System.out.println(canBeBuddy(\"ter qb\", \"i lo\")) // Expected: false\n        System.out.println(canBeBuddy(\"\", \"\")) // Expected: true\n    }\n\n    public static boolean canBeBuddy(String s, String goal) {\n        if (s.length() != goal.length()) return false;\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n            count[goal.charAt(i) - 'a']--;\n        }\n        for (int i : count) {\n            if (i != 0) return false;\n        }\n        return true;\n    }\n}\n```",
  "860": "```\npublic class Main {\n    public static void main(String[] args) {\n        int money = canChange(new int[]{5, 5, 5}, 10);\n        System.out.println(money); // expected output: 20\n\n        money = canChange(new int[]{10}, 15);\n        System.out.println(money); // expected output: 0\n\n        money = canChange(new int[]{1, 2, 3, 4, 5}, 11);\n        System.out.println(money); // expected output: 6\n    }\n\n    public static int canChange(int[] bills, int change) {\n        int fiveCount = 0;\n        int oneCount = 0;\n\n        for (int bill : bills) {\n            if (bill == 5) {\n                fiveCount++;\n            } else if (bill == 1) {\n                oneCount++;\n            }\n        }\n\n        int fiveUsed = fiveCount;\n        while (change >= 5 && fiveUsed > 0) {\n            change -= 5;\n            fiveUsed--;\n        }\n\n        int remainingChange = change;\n\n        while (remainingChange >= 1 && oneCount > 0) {\n            if (remainingChange < 1) {\n                break;\n            }\n            remainingChange -= 1;\n            oneCount--;\n        }\n\n        return change;\n    }\n}\n```",
  "861": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{0,1},{1,1}};\n        System.out.println(\"Score for matrix1: \" + scoreAfterFlippingMatrix(matrix1));\n        \n        int[][] matrix2 = {{0,0,0},{0,0,1},{1,1,1}};\n        System.out.println(\"Score for matrix2: \" + scoreAfterFlippingMatrix(matrix2));\n\n        int[][] matrix3 = {{0,1,1},{1,1,0},{1,1,1}};\n        System.out.println(\"Score for matrix3: \" + scoreAfterFlippingMatrix(matrix3));\n    }\n\n    public static int scoreAfterFlippingMatrix(int[][] matrix) {\n        int score = 0;\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[0].length; j++) {\n                if ((matrix[i][j] ^ 1) == matrix[i][j]) {\n                    score += (1 << (i + j));\n                }\n            }\n        }\n        return score;\n    }\n}",
  "862": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(shortestSubArray(new int[]{1,2,3},4) + \" expected: 3\");\n        System.out.println(shortestSubArray(new int[]{1,15,20},5) + \" expected: 6\");\n        System.out.println(shortestSubArray(new int[]{8,1,2,10,3,9},11) + \" expected: 3\");\n    }\n\n    public static int shortestSubArray(int[] nums, int k) {\n        int n = nums.length;\n        int ans = n;\n        for (int i = 0; i < n; i++) {\n            int cur_sum = 0;\n            for (int j = i; j < n; j++) {\n                cur_sum += nums[j];\n                if (cur_sum >= k) {\n                    ans = Math.min(ans, j - i + 1);\n                    break;\n                }\n            }\n        }\n        return ans;\n    }\n}",
  "863": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(3);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(4);\n        root.left.left = new TreeNode(2);\n        root.left.right = new TreeNode(5);\n\n        System.out.println(\"Test Case 1: Distance K for node 2 is \" + distanceK(root, 2, 3));\n        System.out.println(\"Test Case 2: Distance K for node 4 is \" + distanceK(root, 4, 3));\n        System.out.println(\"Test Case 3: Distance K for node 1 is \" + distanceK(root, 1, 1));\n\n    }\n\n    public static List<Integer> distanceK(TreeNode root, int target, int K) {\n        // Your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "864": "```\nimport org.junit.Test;\nimport static org.junit.Assert.assertEquals;\n\npublic class Solution {\n    public int shortestToChar(String S, char C) {\n        int[] res = new int[S.length()];\n        for (int i = 0; i < S.length(); i++) {\n            res[i] = Math.min(Math.abs(i - S.indexOf(C)), Math.max(0, i - S.indexOf(C)) + 1);\n        }\n        return res[0];\n    }\n\n    @Test\n    public void testShortestToChar() {\n        assertEquals(3, new Solution().shortestToChar(\"loveleetcode\", 'e'));\n    }\n\n    @Test\n    public void testShortestToChar2() {\n        assertEquals(1, new Solution().shortestToChar(\"aa\", 'a'));\n    }\n\n    @Test\n    public void testShortestToChar3() {\n        assertEquals(0, new Solution().shortestToChar(\"abarbecue\", 'b'));\n    }\n}\n```",
  "865": "```\nimport java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Solution {\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\n        // Your code here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        TreeNode tree1 = new TreeNode(3);\n        tree1.left = new TreeNode(5);\n        tree1.right = new TreeNode(1);\n        tree1.left.left = new TreeNode(6);\n        tree1.left.right = new TreeNode(2);\n        tree1.right.left = new TreeNode(0);\n        tree1.right.right = new TreeNode(8);\n        tree1.left.left.left = new TreeNode(7);\n        tree1.left.left.right = new TreeNode(4);\n\n        System.out.println(\"Test case 1:\");\n        System.out.println(solution.subtreeWithAllDeepest(tree1));\n\n        TreeNode tree2 = new TreeNode(3);\n        tree2.left = new TreeNode(5);\n        tree2.right = new TreeNode(1);\n        tree2.left.left = new TreeNode(6);\n\n        System.out.println(\"Test case 2:\");\n        System.out.println(solution.subtreeWithAllDeepest(tree2));\n\n        TreeNode tree3 = null;\n\n        System.out.println(\"Test case 3:\");\n        System.out.println(solution.subtreeWithAllDeepest(tree3));\n    }\n}",
  "866": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isPrimePalindrome(7)); // Expected: true\n        System.out.println(isPrimePalindrome(11)); // Expected: true\n        System.out.println(isPrimePalindrome(13)); // Expected: false\n    }\n\n    public static boolean isPrimePalindrome(int n) {\n        if (n <= 1) return false;\n        int reversed = 0;\n        int original = n;\n        while (n > 0) {\n            int digit = n % 10;\n            reversed = reversed * 10 + digit;\n            n /= 10;\n        }\n        return isPrime(reversed);\n    }\n\n    public static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n}\n```",
  "868": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(binaryGap(9)); // Output: 3\n        System.out.println(binaryGap(529)); // Output: 4\n        System.out.println(binaryGap(154389645); // Output: 1\n    }\n\n    public static int binaryGap(int N) {\n        String bin = Integer.toBinaryString(N);\n        int maxGap = 0;\n        int currentGap = 0;\n\n        for (int i = 0; i < bin.length(); i++) {\n            if (bin.charAt(i) == '1') {\n                if (currentGap > maxGap) {\n                    maxGap = currentGap;\n                }\n                currentGap = 0;\n            } else {\n                currentGap++;\n            }\n        }\n\n        return maxGap;\n    }\n}",
  "867": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}};\n        printMatrix(transpose(matrix1));\n\n        System.out.println();\n\n        int[][] matrix2 = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        printMatrix(transpose(matrix2));\n\n        System.out.println();\n\n        int[][] matrix3 = {{1}};\n        printMatrix(transpose(matrix3));\n    }\n\n    public static int[][] transpose(int[][] matrix) {\n        int[][] result = new int[matrix[0].length][matrix.length];\n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[i].length; j++) {\n                result[j][i] = matrix[i][j];\n            }\n        }\n        return result;\n    }\n\n    public static void printMatrix(int[][] matrix) {\n        for (int[] row : matrix) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "869": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reorderedPowerOf2(1)); // expected: true\n        System.out.println(reorderedPowerOf2(10)); // expected: false\n        System.out.println(reorderedPowerOf2(1000000)); // expected: true\n    }\n\n    public static boolean reorderedPowerOf2(int N) {\n        int count[] = new int[10];\n        while (N > 0) {\n            count[N % 10]++;\n            N /= 10;\n        }\n        for (int i = 0; i < 9; i++) {\n            if (count[i] > 1)\n                return false;\n        }\n        for (int i = 9; i >= 1; i--) {\n            if (Math.pow(2, Math.log(i) / Math.log(2)) == N) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
  "870": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {{1,2,3}, [1,-1,3]},\n            {{1,8,2}, [4,5,6]},\n            {{1,3}, [-3,7]}\n        };\n\n        for (int i = 0; i < arrays.length; i++) {\n            int[] nums = arrays[i][0];\n            int[] cost = arrays[i][1];\n\n            AdvantageShuffle solution = new AdvantageShuffle();\n            int[] result = solution.advantageShuffle(nums, cost);\n\n            System.out.println(\"Test Case \" + (i+1) + \":\");\n            for (int j = 0; j < result.length; j++) {\n                System.out.print(result[j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "871": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + minRefuelStops(new int[]{1,2,4,7}, 10) + \"\\n\");\n        System.out.println(\"Test Case 2: \" + minRefuelStops(new int[]{1,3,5}, 7) + \"\\n\");\n        System.out.println(\"Test Case 3: \" + minRefuelStops(new int[]{1,3,4,4}, 10));\n    }\n\n    public static int minRefuelStops(int[] fuel, int target) {\n        // Your code here\n    }\n}\n```",
  "872": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode tree1 = new TreeNode(3);\n        tree1.left = new TreeNode(4);\n        tree1.right = new TreeNode(1);\n        tree1.left.left = new TreeNode(1);\n        tree1.left.right = new TreeNode(2);\n\n        TreeNode tree2 = new TreeNode(3);\n        tree2.left = new TreeNode(4);\n        tree2.right = new TreeNode(2);\n        tree2.left.left = new TreeNode(1);\n\n        TreeNode tree3 = new TreeNode(5);\n        tree3.left = new TreeNode(1);\n        tree3.right = new TreeNode(5);\n\n        System.out.println(canBeEqual(tree1, tree2)); // expected true\n        System.out.println(canBeEqual(tree1, tree3)); // expected false\n        System.out.println(canBeEqual(tree3, tree3)); // expected true\n    }\n\n    public static boolean canBeEqual(TreeNode root1, TreeNode root2) {\n        if (root1 == null && root2 == null) return true;\n        if ((root1 == null || !isLeaf(root1)) && (root2 == null || !isLeaf(root2))) return isMirror(root1, root2);\n        return false;\n    }\n\n    public static boolean isLeaf(TreeNode node) {\n        return node.left == null && node.right == null;\n    }\n\n    public static boolean isMirror(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) return true;\n        if (t1 == null || t2 == null) return false;\n        return (t1.val == t2.val) && isMirror(t1.right, t2.left) && isMirror(t1.left, t2.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "873": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(lengthOfLargestFibSubseq(new int[]{1,2,3,4,5,6,7,8})); // Test case 1\n        System.out.println(lengthOfLargestFibSubseq(new int[]{1,3,7,10,13,16,19,21,34,50,89,150})); // Test case 2\n        System.out.println(lengthOfLargestFibSubseq(new int[]{0,1,2})); // Test case 3\n    }\n\n    public static int lengthOfLargestFibSubseq(int[] A) {\n        int n = A.length;\n        if (n < 2) return 0;\n\n        Map<Integer,Integer> map = new HashMap<>();\n        for (int i : A) map.put(i, i);\n\n        int maxLen = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i+1; j < n; j++) {\n                int sum = A[i] + A[j];\n                if (map.containsKey(sum)) {\n                    int len = 2;\n                    int a = A[i], b = A[j], c = map.get(sum);\n                    while (map.containsKey(a+b)) {\n                        a = b; b = c; c = map.get(a+b);\n                        len++;\n                    }\n                    maxLen = Math.max(maxLen, len);\n                }\n            }\n        }\n        return maxLen;\n    }\n}\n```",
  "875": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] piles = new int[]{2,0,5};\n        System.out.println(\"TestCase 1: \" + minEatingTime(piles));\n        \n        piles = new int[]{true,true,false,true,false];\n        System.out.println(\"TestCase 2: \" + minEatingTime(piles));\n        \n        piles = new int[]{10,6,8,4};\n        System.out.println(\"TestCase 3: \" + minEatingTime(piles));\n    }\n    \n    public static int minEatingTime(int[] piles) {\n        Arrays.sort(piles);\n        int low = 1;\n        int high = piles[piles.length - 1];\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            \n            if (canEatAll(piles, mid)) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        \n        return low;\n    }\n    \n    public static boolean canEatAll(int[] piles, int kokoTime) {\n        int eatingCount = 0;\n        for (int pile : piles) {\n            eatingCount += pile / kokoTime;\n            \n            if ((pile % kokoTime) != 0) {\n                eatingCount++;\n            }\n        }\n        \n        return eatingCount <= kokoTime;\n    }\n}\n```",
  "874": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] commands = {\n            {1, 3},\n            {2, -10, 5, -20},\n            {0, 9, 100}\n        };\n        for (int i = 0; i < commands.length; i++) {\n            System.out.println(\"Commands: \" + Arrays.toString(commands[i]));\n            simulateWalkingRobot(commands[i]);\n            System.out.println();\n        }\n    }\n\n    public static void simulateWalkingRobot(int[] commands) {\n        int x = 0;\n        int y = 0;\n\n        for (int command : commands) {\n            switch (command) {\n                case -2:\n                    if (x > 0) {\n                        x--;\n                    } else {\n                        System.out.println(\"Invalid move: \" + command);\n                    }\n                    break;\n                case -1:\n                    if (y > 0) {\n                        y--;\n                    } else {\n                        System.out.println(\"Invalid move: \" + command);\n                    }\n                    break;\n                case 1:\n                    x++;\n                    break;\n                case 2:\n                    y++;\n                    break;\n                default:\n                    System.out.println(\"Invalid command: \" + command);\n            }\n        }\n\n        System.out.println(\"Final position: (\" + x + \", \" + y + \")\");\n    }\n}\n```",
  "876": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(3);\n        head1.next.next.next = new ListNode(4);\n        head1.next.next.next.next = new ListNode(5);\n\n        System.out.println(\"Test case 1: \" + middle(head1));\n\n        ListNode head2 = new ListNode(1);\n        head2.next = new ListNode(2);\n\n        System.out.println(\"Test case 2: \" + middle(head2));\n\n        ListNode head3 = null;\n\n        System.out.println(\"Test case 3: \" + middle(head3));\n    }\n\n    public static ListNode middle(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    public ListNode(int val) {\n        this.val = val;\n        this.next = null;\n    }\n}\n```",
  "877": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canWin(5, new int[]{1,2,3,1,2})); // True\n        System.out.println(canWin(7, new int[]{1,2,3,1,2,4,5,1000})); // False\n        System.out.println(canWin(10, new int[]{1,3,1,3,20,1,5,3,16,10})); // True\n    }\n\n    public static boolean canWin(int piles, int[] stones) {\n        if (piles == 0) return false;\n        if (piles == 1) return true;\n\n        for (int i = 0; i < stones.length - 1; i++) {\n            if (stones[i] >= piles / 2 + 1) return true;\n        }\n        return false;\n    }\n}\n```",
  "878": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(nthMagicalNumber(1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n        System.out.println(nthMagicalNumber(64, 74, 75, 84, 85, 86, 95, 96, 97, 98));\n        System.out.println(nthMagicalNumber(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20));\n    }\n\n    public static long nthMagicalNumber(int n, int start, int end) {\n        if (n <= 0 || start > end) {\n            return -1;\n        }\n        long lo = start, hi = end;\n        while (lo < hi) {\n            long mid = lo + (hi - lo) / 2;\n            if ((mid / start) % n != 0) {\n                lo = mid + 1;\n            } else {\n                hi = mid;\n            }\n        }\n        return lo;\n    }\n}\n```",
  "879": "```\npublic class Main {\n    public static void main(String[] args) {\n        int group = 4;\n        int minProfits = 2;\n        int maxCoolTime = 5;\n\n        System.out.println(\"Test case 1: \" + profitableSchemes(group, minProfits, new int[]{2, 7, 9, 3, 7, 11}));\n        System.out.println(\"Test case 2: \" + profitableSchemes(group, minProfits, new int[]{1, 6, 5, 4, 3, 2}));\n        System.out.println(\"Test case 3: \" + profitableSchemes(5, 10, new int[]{10, 20, 30, 40, 50}));\n\n    }\n\n    public static long profitableSchemes(int group, int minProfits, int[] profits) {\n        long[][] dp = new long[group][maxCoolTime+1];\n        for (int i = 0; i < group; i++) {\n            for (int j = 0; j <= maxCoolTime; j++) {\n                if (j == 0) {\n                    dp[i][j] = profits[i];\n                } else {\n                    int totalProfits = 0;\n                    for (int k = 0; k < i && j - 1 >= k; k++) {\n                        totalProfits += dp[k][j-1];\n                    }\n                    if (totalProfits >= minProfits) {\n                        dp[i][j] = profits[i] + totalProfits;\n                    } else {\n                        dp[i][j] = 0;\n                    }\n                }\n            }\n        }\n\n        long count = 0;\n        for (int i = 0; i < group; i++) {\n            for (int j = 1; j <= maxCoolTime; j++) {\n                if (dp[i][j] >= minProfits) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n```",
  "880": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(decodedString(\"3[a]2[bc]\", 0).equals(\"aaabcc\")); // Test Case 1\n        System.out.println(decodedString(\"4[ab]c\", 1) == \"abca\"); // Test Case 2\n        System.out.println(decodedString(\"10[a]b[c]\", 5) == \"a[abc][abc][abc][abc][abc][abc][abc][abc][abc][abc]\"); // Test Case 3\n\n    }\n\n    public static String decodedString(String s, int index) {\n        StringBuilder sb = new StringBuilder();\n        int stackSize = 0;\n        while (index < s.length()) {\n            if (Character.isDigit(s.charAt(index))) {\n                int multiplier = Integer.parseInt(String.valueOf(s.charAt(index)));\n                index++;\n                for (int i = 0; i < multiplier; i++) {\n                    sb.append(s.substring(index, index + stackSize + 1));\n                    index += stackSize + 1;\n                }\n            } else if (s.charAt(index) == '[') {\n                stackSize++;\n            } else if (s.charAt(index) == ']') {\n                stackSize--;\n            } else {\n                sb.append(s.charAt(index));\n                index++;\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "881": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSteps(new int[][]{{0,1},{2,3}})); // Expected: 1\n        System.out.println(minSteps(new int[][]{{0,1},{2,3},{4,5}})); // Expected: 4\n        System.out.println(minSteps(new int[][]{{0,1},{2,3},{4,5},{6,7}})); // Expected: 7\n    }\n\n    public static int minSteps(int[][] people) {\n        Arrays.sort(people, (a, b) -> a[0] - b[0]);\n        int steps = 0;\n        for (int i = 1; i < people.length; i++) {\n            if (people[i][0] <= people[i-1][0]) {\n                steps += Math.max(0, people[i][1] - people[i-1][1]);\n            }\n        }\n        return steps;\n    }\n}\n```",
  "882": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph1 = {{0, 1}, {0, 2}, {1, 2}};\n        System.out.println(\"graph1: \" + reachableNodes(4, graph1));\n\n        int[][] graph2 = {{0, 1, 3}, {1, 2}, {2, 3}};\n        System.out.println(\"graph2: \" + reachableNodes(6, graph2));\n\n        int[][] graph3 = {{0, 1, 3, 4, 5}, {1, 2}, {2, 3}, {3, 4}, {4, 5}};\n        System.out.println(\"graph3: \" + reachableNodes(7, graph3));\n    }\n\n    public static int reachableNodes(int n, int[][] edges) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n\n        int[][] queries = new int[][]{{0, 2}, {3, 4}};\n        Arrays.sort(queries, (a, b) -> a[0] - b[0]);\n        int res = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        for (int[] query : queries) {\n            while (!pq.isEmpty() && pq.peek()[0] <= query[1]) {\n                pq.poll();\n            }\n            int node = query[0];\n            res += dfs(graph, node, pq);\n        }\n\n        return res;\n    }\n\n    private static int dfs(List<List<Integer>> graph, int node, PriorityQueue<int[]> pq) {\n        if (pq.contains(new int[]{node, Integer.MAX_VALUE})) {\n            pq.remove(new int[]{node, Integer.MAX_VALUE});\n            return 1;\n        } else {\n            for (int neighbor : graph.get(node)) {\n                if (!pq.contains(new int[]{neighbor, Integer.MAX_VALUE})) {\n                    pq.add(new int[]{neighbor, node});\n                }\n            }\n        }\n        return 0;\n    }\n}\n```",
  "883": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr = {{2, 2}, {1, 1}};\n        System.out.println(\"Projection Area of 3D Shapes: \" + totalSurfaceArea(arr));\n        \n        int[][] arr2 = {{9,4,6,8},{5,2,7,3},{1,6,5,2}};\n        System.out.println(\"Projection Area of 3D Shapes: \" + totalSurfaceArea(arr2));\n        \n        int[][] arr3 = {{10,12,11},{14,15,13},{10,12,11}};\n        System.out.println(\"Projection Area of 3D Shapes: \" + totalSurfaceArea(arr3));\n    }\n\n    public static int totalSurfaceArea(int[][] r) {\n        int n = r.length;\n        if(n == 0)\n            return 0;\n        \n        int area = 0; \n        for (int i = 0; i < n; i++) { \n            for (int j = 0; j < n; j++) { \n                int val = r[i][j];\n                \n                // calculate side surface area\n                if(val > 0) {\n                    area += 2 + ((val - 1) * (r.length - 1));\n                }\n                \n                // calculate visible top and bottom areas\n                for(int k = 0; k < n; k++) {\n                    if(r[i][k] > r[j][k]) {\n                        int h = r[i][k];\n                        area += h;\n                    } else if(r[i][k] < r[j][k]) {\n                        int h = r[j][k];\n                        area += h;\n                    }\n                }\n            }\n        }\n        \n        return area; \n    }\n}",
  "884": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(uncommonFromSentences(\"apple apple\", \"banana\"));\n        System.out.println(uncommonFromSentences(\"apple banana apple\", \"dog cat dog dog\"));\n        System.out.println(uncommonFromSentences(\"\", \"dog cat dog dog\"));\n    }\n\n    public static String[] uncommonFromSentences(String s1, String s2) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : s1.split(\" \")) {\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        }\n        for (String word : s2.split(\" \")) {\n            if (!map.containsKey(word)) {\n                map.put(word, 1);\n            } else {\n                int count = map.get(word);\n                if (count > 1) {\n                    map.remove(word);\n                } else {\n                    map.put(word, 1);\n                }\n            }\n        }\n\n        List<String> result = new ArrayList<>();\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            if (entry.getValue() == 1) {\n                result.add(entry.getKey());\n            }\n        }\n\n        return result.toArray(new String[0]);\n    }\n}",
  "885": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        System.out.println(\"Test case 1: \" + spiralOrder(matrix1));\n        \n        int[][] matrix2 = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        System.out.println(\"Test case 2: \" + spiralOrder(matrix2));\n        \n        int[][] matrix3 = {{1, 2, 3, 4, 5}, \n                            {16, 17, 18, 19, 6},\n                            {15, 24, 25, 20, 7},\n                            {14, 23, 22, 21, 8},\n                            {13, 12, 11, 10, 9}};\n        System.out.println(\"Test case 3: \" + spiralOrder(matrix3));\n    }\n\n    public static List<Integer> spiralOrder(int[][] matrix) {\n        // Your code here\n    }\n}\n```",
  "887": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(superEggDrop(2, 6)); // Test case 1\n        System.out.println(superEggDrop(1, 2)); // Test case 2\n        System.out.println(superEggDrop(3, 14)); // Test case 3\n    }\n\n    public static int superEggDrop(int K, int N) {\n        int res = 0;\n        while (N > 1 && (1 << res) < N) {\n            res++;\n        }\n        return res + K;\n    }\n}\n```",
  "886": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph1 = {{1,2},{2,3},{1,3}};\n        System.out.println(\"Test case 1: \" + possibleBipartition(graph1));\n\n        int[][] graph2 = {{1,2},{1,3},{2,3}};\n        System.out.println(\"Test case 2: \" + possibleBipartition(graph2));\n\n        int[][] graph3 = {{1,2},{1,3},{2,3,4},{3,4}};\n        System.out.println(\"Test case 3: \" + possibleBipartition(graph3));\n    }\n\n    public static boolean possibleBipartition(int[][] graph) {\n        int n = graph.length;\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                if (!bfs(graph, i, visited)) return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean bfs(int[][] graph, int start, boolean[] visited) {\n        int[] color = new int[graph.length];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        visited[start] = true;\n        color[start] = 0;\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int neighbor : graph[node]) {\n                if (!visited[neighbor]) {\n                    queue.add(neighbor);\n                    visited[neighbor] = true;\n                    color[neighbor] = 1 - color[node];\n                } else if (color[neighbor] == color[node]) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n```",
  "888": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] alice = {2,1,5,4}, bob = {1,5,2,4};\n        System.out.println(fairCandySwap(alice, bob)); // Output: 3\n\n        alice = new int[]{3,6,8}; bob = new int[]{2,1,5,4};\n        System.out.println(fairCandySwap(alice, bob)); // Output: 6\n\n        alice = new int[]{7,10}; bob = new int[]{9,6};\n        System.out.println(fairCandySwap(alice, bob)); // Output: 0\n    }\n\n    public static int fairCandySwap(int[] Alice, int[] Bob) {\n        int sumAlice = 0, sumBob = 0;\n        for (int i : Alice) {\n            sumAlice += i;\n        }\n        for (int i : Bob) {\n            sumBob += i;\n        }\n\n        int diff = Math.abs(sumAlice - sumBob);\n        for (int i = 1; i <= Math.max(sumAlice, sumBob); i++) {\n            if ((sumAlice - i) + (sumBob + i) == 0) return i;\n        }\n        return diff;\n    }\n}",
  "889": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] preorder = {1,2,4,5,3};\n        int[] postorder = {3,5,4,2,1};\n        Node root = new Solution().constructFromPrePost(preorder, postorder);\n        System.out.println(\"Test Case 1: \");\n        printTree(root);\n\n        preorder = new int[]{1,2};\n        postorder = new int[]{2,1};\n        root = new Solution().constructFromPrePost(preorder, postorder);\n        System.out.println(\"\\nTest Case 2: \");\n        printTree(root);\n\n        preorder = new int[]{1,2,3,4,5,6,7,8,9,10};\n        postorder = new int[]{10,9,8,7,6,5,4,3,2,1};\n        root = new Solution().constructFromPrePost(preorder, postorder);\n        System.out.println(\"\\nTest Case 3: \");\n        printTree(root);\n    }\n\n    public static void printTree(Node node) {\n        if (node == null) {\n            return;\n        }\n        System.out.print(node.val + \" \");\n        printTree(node.left);\n        printTree(node.right);\n    }\n}\n\nclass Solution {\n    Node constructFromPrePost(int[] preorder, int[] postorder) {\n        // Your code here\n    }\n\n    class Node {\n        int val;\n        Node left;\n        Node right;\n\n        public Node(int val) {\n            this.val = val;\n        }\n    }\n}",
  "890": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.equals(findAndReplaceString(\"massive\", new String[]{\"this\", \"is\"}, new String[]{\"not\", \"huge\"}), new String[]{\"not this\", \"not is\"}));\n        System.out.println(Arrays.equals(findAndReplaceString(\"hello\", new String[]{\"a\", \"e\", \"o\"}, new String[]{\"b\", \"f\", \"g\"}), new String[]{\"bflo\"}));\n        System.out.println(Arrays.equals(findAndReplaceString(\"aba\", new String[]{\"a\", \"1\", \"b\"}, new String[]{\"b\", \"2\", \"a\"}), new String[]{\"1 2\"}));\n    }\n\n    public static String[] findAndReplaceString(String S, String[] words, String[] change) {\n        Map<String, String> map = new HashMap<>();\n        for (int i = 0; i < words.length; i++) {\n            map.put(words[i], change[i]);\n        }\n        StringBuilder sb = new StringBuilder();\n        boolean isFound = false;\n        for (char c : S.toCharArray()) {\n            if (!isFound && !map.containsKey(String.valueOf(c))) {\n                continue;\n            } else {\n                isFound = true;\n                sb.append(map.getOrDefault(String.valueOf(c), String.valueOf(c)));\n            }\n        }\n        return new String[]{sb.toString()};\n    }\n}\n```",
  "891": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] seq1 = {3, 8, 3};\n        System.out.println(\"Sum of subsequence widths for \" + Arrays.toString(seq1) + \": \" + sumOfSubsequenceWidths(seq1));\n        \n        int[] seq2 = {4, 6, 5, 5, 3, 5};\n        System.out.println(\"Sum of subsequence widths for \" + Arrays.toString(seq2) + \": \" + sumOfSubsequenceWidths(seq2));\n        \n        int[] seq3 = {1, 2, 1};\n        System.out.println(\"Sum of subsequence widths for \" + Arrays.toString(seq3) + \": \" + sumOfSubsequenceWidths(seq3));\n    }\n\n    public static int sumOfSubsequenceWidths(int[] nums) {\n        Arrays.sort(nums);\n        int result = 0;\n        for (int i = 0; i < nums.length - 1; i++) {\n            result += Math.abs(nums[i] - nums[i + 1]);\n        }\n        return result;\n    }\n}",
  "892": "```\npublic class Solution {\n    public int surfaceArea(int[][] grid) {\n        int sum = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] > 0) {\n                    sum += 2;\n                    sum += grid[i][j];\n                    int leftHeight = i == 0 ? 0 : grid[i - 1][j];\n                    int rightHeight = i == grid.length - 1 ? 0 : grid[i + 1][j];\n                    int topHeight = j == 0 ? 0 : grid[i][j - 1];\n                    int bottomHeight = j == grid[0].length - 1 ? 0 : grid[i][j + 1];\n                    sum += Math.max(0, leftHeight) + Math.max(0, rightHeight) + Math.max(0, topHeight) + Math.max(0, bottomHeight);\n                }\n            }\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid1 = {{2}};\n        System.out.println(\"Test case 1: \" + solution.surfaceArea(grid1));\n        \n        int[][] grid2 = {{1,1,1},{1,0,1},{1,1,1}};\n        System.out.println(\"Test case 2: \" + solution.surfaceArea(grid2));\n        \n        int[][] grid3 = {{4,6,7,8},{5,3,9,4},{9,8,1,2},{7,1,6,5}};\n        System.out.println(\"Test case 3: \" + solution.surfaceArea(grid3));\n    }\n}",
  "893": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \");\n        String[] strs1 = {\"a\", \"b\", \"c\"};\n        int result1 = countComponents(strs1);\n        System.out.println(result1);\n\n        System.out.println(\"\\nTest case 2: \");\n        String[] strs2 = { \"a\", \"ab\", \"abc\", \"abcd\" };\n        int result2 = countComponents(strs2);\n        System.out.println(result2);\n\n        System.out.println(\"\\nTest case 3: \");\n        String[] strs3 = {\"aaa\", \"aaa\", \"aaaa\", \"aaaaa\"};\n        int result3 = countComponents(strs3);\n        System.out.println(result3);\n    }\n\n    public static int countComponents(String[] strs) {\n        // Your code here\n        Map<String, Boolean> map = new HashMap<>();\n        for (String s : strs) {\n            char[] chars = s.toCharArray();\n            Arrays.sort(chars);\n            String sortedStr = new String(chars);\n            map.put(sortedStr, !map.containsKey(sortedStr));\n        }\n        return map.size();\n    }\n}",
  "894": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numFullBinaryTrees(2));\n        System.out.println(numFullBinaryTrees(4));\n        System.out.println(numFullBinaryTrees(7));\n    }\n\n    public static int numFullBinaryTrees(int n) {\n        int[][] dp = new int[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            dp[i] = new int[i + 1];\n        }\n        return dfs(n, 0, dp);\n    }\n\n    public static int dfs(int n, int val, int[][] dp) {\n        if (n == 0) {\n            return 1;\n        } else if (val > n) {\n            return 0;\n        }\n        if (dp[n][val] != 0) {\n            return dp[n][val];\n        }\n        int sum = 0;\n        for (int i = 1; i <= n; i++) {\n            sum += dfs(n - i, val + 1, dp);\n        }\n        dp[n][val] = sum;\n        return sum;\n    }\n}",
  "895": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        MaximumFrequencyStack stack = new MaximumFrequencyStack();\n        System.out.println(stack.maxSlack());\n        System.out.println(stack.push(5));\n        System.out.println(stack.push(6));\n        System.out.println(stack.pop());\n        System.out.println(stack.top());\n        System.out.println(stack.push(1));\n        System.out.println(stack.push(2));\n        System.out.println(stack.push(3));\n        System.out.println(stack.pop());\n        System.out.println(stack.top());\n    }\n}\n\nclass MaximumFrequencyStack {\n    private Map<Integer, Integer> map;\n    private Map<Integer, Stack<Integer>> stackMap;\n    private int maxFreq;\n\n    public MaximumFrequencyStack() {\n        map = new HashMap<>();\n        stackMap = new HashMap<>();\n        maxFreq = 0;\n    }\n\n    public int push(int x) {\n        map.put(x, map.getOrDefault(x, 0) + 1);\n        stackMap.computeIfAbsent(map.get(x), k -> new Stack<>()).push(x);\n        maxFreq = Math.max(maxFreq, map.get(x));\n        return map.get(x);\n    }\n\n    public int pop() {\n        int x = getTopElement();\n        map.put(x, map.get(x) - 1);\n        if (map.get(x) == 0) {\n            stackMap.remove(x);\n        }\n        return x;\n    }\n\n    public int top() {\n        return getTopElement();\n    }\n\n    private int getTopElement() {\n        Stack<Integer> maxStack = stackMap.get(maxFreq);\n        while (!maxStack.isEmpty()) {\n            return maxStack.pop();\n        }\n        for (int i = maxFreq - 1; i >= 0; i--) {\n            if (!stackMap.get(i).isEmpty()) {\n                return stackMap.get(i).pop();\n            }\n        }\n        throw new RuntimeException(\"No element in the stack\");\n    }\n\n    public int maxSlack() {\n        return maxFreq;\n    }\n}\n```",
  "896": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isMonotonic(new int[]{1, 1, 1, 2, 3, 4, 5, 5, 6}) ? \"Is monotonic\" : \"Not monotonic\");\n        System.out.println(isMonotonic(new int[]{6, 5, 4, 3, 2, 1}) ? \"Is monotonic\" : \"Not monotonic\");\n        System.out.println(isMonotonic(new int[]{-1, -10, -12, 0, 3, 4, 5, 7, 8, 9}) ? \"Is monotonic\" : \"Not monotonic\");\n    }\n\n    public static boolean isMonotonic(int[] nums) {\n        boolean increasing = true;\n        boolean decreasing = true;\n\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[i - 1]) {\n                decreasing = false;\n            } else if (nums[i] < nums[i - 1]) {\n                increasing = false;\n            }\n        }\n\n        return increasing || decreasing;\n    }\n}",
  "897": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(5);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(4);\n        root.right.left = new TreeNode(3);\n        root.right.right = new TreeNode(2);\n\n        InorderTraversal(root);\n\n        System.out.println();\n\n        root = null;\n\n        InorderTraversal(null);\n\n        System.out.println();\n\n        root = new TreeNode(6);\n        root.left = new TreeNode(5);\n        root.right = new TreeNode(4);\n\n        InorderTraversal(root);\n    }\n\n    public static void InorderTraversal(TreeNode root) {\n        if (root == null) return;\n\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode current = root;\n        while (current != null || !stack.isEmpty()) {\n            while (current != null) {\n                stack.push(current);\n                current = current.left;\n            }\n            current = stack.pop();\n            System.out.print(current.val + \" \");\n            current = current.right;\n        }\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "898": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {0};\n        System.out.println(\"Expected: 0. Actual: \" + bitwiseOrsOfSubarrays(nums1));\n        \n        int[] nums2 = [3,2,5,7,8];\n        System.out.println(\"Expected: 15. Actual: \" + bitwiseOrsOfSubarrays(nums2));\n        \n        int[] nums3 = {2,1,4,0};\n        System.out.println(\"Expected: 7. Actual: \" + bitwiseOrsOfSubarrays(nums3));\n    }\n\n    public static int bitwiseOrsOfSubarrays(int[] nums) {\n        int max = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int subarrayMax = 0;\n            for (int j = i; j < nums.length; j++) {\n                subarrayMax |= nums[j];\n            }\n            max = Math.max(max, subarrayMax);\n        }\n        return max;\n    }\n}",
  "899": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {\n            {7, 1, 5, 3, 8, 9},\n            {16, 14, 20, 18, 15},\n            {10, 4, 2, 1}\n        };\n        String[][] expecteds = {\n            {\"1\", \"2\", \"3\", \"7\", \"5\", \"8\", \"9\"},\n            {\"14\", \"18\", \"15\", \"20\"},\n            {\"1\", \"2\", \"4\", \"10\"}\n        };\n\n        for (int i = 0; i < inputs.length; i++) {\n            int[] input = inputs[i];\n            String[] expected = expecteds[i];\n\n            orderlyQueue(input);\n            assertArrayEquals(expected, toStrArr());\n            System.out.println(\"Test case \" + i + \": Passed\");\n        }\n    }\n\n    public static void orderlyQueue(int[] order) {\n        // Your code here\n    }\n\n    public static String[] toStrArr() {\n        // Your code here\n    }\n\n    static void assertArrayEquals(String[] expected, String[] actual) {\n        if (!java.util.Arrays.equals(expected, actual)) {\n            throw new AssertionError(\"Expected \" + Arrays.toString(expected) + \" but was \" + Arrays.toString(actual));\n        }\n    }\n}\n```",
  "900": "```\npublic class Main {\n    public static void main(String[] args) {\n        RLEIterator iterator1 = new RLEIterator(new int[]{3, 8, 0, 9, 2, 3, 4, 2, 3, 5});\n        System.out.println(iterator1.next()); // prints: 3\n        System.out.println(iterator1.next()); // prints: 8\n        System.out.println(iterator1.next()); // prints: 0\n\n        RLEIterator iterator2 = new RLEIterator(new int[]{1, 1, 1, 9, 2, 3});\n        while (iterator2.hasNext()) {\n            System.out.println(iterator2.next()); // prints: 1 -> 1 -> 1 -> 9 -> 2 -> 3\n        }\n\n        RLEIterator iterator3 = new RLEIterator(new int[]{4, 2, 0, 0});\n        while (iterator3.hasNext()) {\n            System.out.println(iterator3.next()); // prints: 4 -> 2 -> \n        }\n    }\n}\n\nclass RLEIterator {\n    private int[] nums;\n    private int index;\n\n    public RLEIterator(int[] nums) {\n        this.nums = nums;\n        for (int i = 0; i < nums.length - 1; i += 2) {\n            if (nums[i] > 0) {\n                index = i + 1;\n                break;\n            }\n        }\n    }\n\n    public int next() {\n        while (index < nums.length && (nums[index] == 0 || nums[index + 1] % 2 == 0)) {\n            index += 2;\n        }\n        if (index >= nums.length) {\n            return -1;\n        }\n        return nums[index];\n    }\n\n    public boolean hasNext() {\n        while (index < nums.length && (nums[index] == 0 || nums[index + 1] % 2 == 0)) {\n            index += 2;\n        }\n        return index < nums.length;\n    }\n}\n```",
  "901": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        StockSpanner stockSpanner = new StockSpanner();\n        System.out.println(stockSpanner.calculate(100)); // Output: 1\n        System.out.println(stockSpanner.calculate(80)); // Output: 2\n        System.out.println(stockSpanner.calculate(60)); // Output: 3\n    }\n}\n\nclass StockSpanner {\n\n    int[][] knowledge;\n    int idx;\n\n    public StockSpanner() {\n        idx = 0;\n    }\n\n    public int calculate(int price) {\n        if (knowledge == null || knowledge.length < idx + 1) {\n            knowledge = new int[idx + 2][];\n        }\n        knowledge[idx][0] = price;\n        int span = 1;\n        for (int i = idx; i > 0 && knowledge[i][0] >= knowledge[i - 1][0]; i--) {\n            span += i;\n        }\n        knowledge[idx++][1] = span;\n        return span;\n    }\n}\n```",
  "902": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n = 23;\n        int maxLen = atMostNGivenDigitSet(new String[]{\"a1c1e1\", \"ado\",\"b2f2b2\"}, n);\n        System.out.println(maxLen);\n\n        n = 1000000;\n        maxLen = atMostNGivenDigitSet(new String[]{\"74654736474\", \"7455465438\", \"72143569\", \"75143\"}, n);\n        System.out.println(maxLen);\n\n        n = 10;\n        maxLen = atMostNGivenDigitSet(new String[]{\"\"}, n);\n        System.out.println(maxLen);\n    }\n\n    public static int atMostNGivenDigitSet(String[] digits, int n) {\n        // Your code here\n    }\n}",
  "903": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(findPerms(\"D\"))); // [[\"DD\"], [\"DI\"], [\"ID\"], [\"II\"]]\n        System.out.println(Arrays.toString(findPerms(\"ID\"))) ;// []\n        System.out.println(Arrays.toString(findPerms(\"IDD\")));  // [[ \"IDD\"], [\"IIDI\"], [\"DIDI\"], [\"DDDD\"], [\"IDDD\"], [\"DI DD\"], [\"D D D\"], [\"I D D\"], [\"D I D\"], [\"I I D\"], [\"D D I\"], [\"I D I\"], [\"D I I\"], [\"I I I\"]]\n    }\n\n    public static List<List<String>> findPerms(String s) {\n        // Write your code here\n    }\n}",
  "904": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + fruitIntoBaskets(new int[]{1,2,3,1,2,1}) + \"\\n\");\n        System.out.println(\"Test Case 2: \" + fruitIntoBaskets(new int[]{0,1,2,2}) + \"\\n\");\n        System.out.println(\"Test Case 3: \" + fruitIntoBaskets(new int[]{1,2,3,4,5,6,7,8,9,10})) + \"\\n\");\n\n    }\n\n    public static int fruitIntoBaskets(int[] fruits) {\n        if (fruits == null || fruits.length == 0) return 0;\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        int start = 0, maxLen = 0, lastFruit = -1;\n        \n        for (int i = 0; i < fruits.length; i++) {\n            if (map.getOrDefault(fruits[i], 0) == 0) {\n                start = i;\n                lastFruit = fruits[i];\n                map.put(lastFruit, 1);\n            } else if (fruits[i] == lastFruit) {\n                map.put(lastFruit, map.get(lastFruit) + 1);\n            } else {\n                maxLen = Math.max(maxLen, i - start);\n                map.clear();\n                map.put(fruits[i], 1);\n                start = i;\n                lastFruit = fruits[i];\n            }\n        }\n        \n        return Math.max(maxLen, fruits.length - start);\n    }\n}\n```",
  "905": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {3,1,2};\n        sortArrayByParity(nums1);\n        for (int num : nums1) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n\n        int[] nums2 = {0};\n        sortArrayByParity(nums2);\n        for (int num : nums2) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n\n        int[] nums3 = {4,2,5,3,1};\n        sortArrayByParity(nums3);\n        for (int num : nums3) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void sortArrayByParity(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left < right) {\n            if ((nums[left] & 1) == 0) {\n                left++;\n            } else if ((nums[right] & 1) != 0) {\n                right--;\n            } else {\n                int temp = nums[left];\n                nums[left] = nums[right];\n                nums[right] = temp;\n                left++;\n                right--;\n            }\n        }\n    }\n}",
  "906": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countSuperPalindromes(\"12321\")); // expected: 2\n        System.out.println(countSuperPalindromes(\"234543\")); // expected: 4\n        System.out.println(countSuperPalindromes(\"1111311\")); // expected: 3\n    }\n\n    public static int countSuperPalindromes(String num) {\n        int count = 0;\n        for (int i = 0; i < Math.pow(2, num.length()); i++) {\n            String s = Integer.toString(i);\n            String rev = new StringBuilder(s).reverse().toString();\n            if (num.contains(s) && num.contains(rev)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
  "907": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfSubarrayMinimums(new int[]{28,14,5,3,7})); // Expected output: 30\n        System.out.println(sumOfSubarrayMinimums(new int[]{10,6,8,20,9,3})); // Expected output: 24\n        System.out.println(sumOfSubarrayMinimums(new int[]{1,2,3,4,5})); // Expected output: 15\n    }\n\n    public static int sumOfSubarrayMinimums(int[] arr) {\n        int n = arr.length;\n        int minSum = 0;\n        int[] minIndex = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                minIndex[i] = i;\n            } else if (arr[i] <= arr[i - 1]) {\n                minIndex[i] = i;\n            } else {\n                minIndex[i] = minIndex[i - 1];\n            }\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (i == n - 1) {\n                minSum += arr[i];\n            } else if (arr[minIndex[i + 1]] > arr[i]) {\n                minSum += arr[i];\n            }\n        }\n\n        return minSum;\n    }\n}\n```",
  "908": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals = {{0,10},{1,5},{2,6}};\n        System.out.println(minInterval(intervals));\n\n        int[][] intervals2 = {{1,5}};\n        System.out.println(minInterval(intervals2));\n\n        int[][] intervals3 = {{1,5},{5,10}};\n        System.out.println(minInterval(intervals3));\n    }\n\n    public static int minInterval(int[][] intervals) {\n        Arrays.sort(intervals, (a,b)-> a[0]-b[0]);\n        int res = Integer.MAX_VALUE;\n        for (int i = 1; i < intervals.length; i++) {\n            res = Math.min(res, intervals[i][0] - intervals[i-1][1]);\n        }\n        return res == Integer.MAX_VALUE ? 0 : res;\n    }\n}\n```",
  "910": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSubArrayRanges(new int[]{4, 2, 0, 3, 2, 5})); // Test case 1: [2, 3]\n        System.out.println(minSubArrayRanges(new int[]{1, 3, 6, 7, 2, 12})); // Test case 2: [3, 4]\n        System.out.println(minSubArrayRanges(new int[]{10, 11, 12})); // Test case 3: [5, 6]\n    }\n\n    public static List<Integer> minSubArrayRanges(int[] nums) {\n        int n = nums.length;\n        List<Integer> res = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int min = nums[i], max = nums[i];\n            for (int j = i; j >= 0 && j < n; j--) {\n                min = Math.min(min, nums[j]);\n                max = Math.max(max, nums[j]);\n                res.add(max - min);\n            }\n        }\n        return res;\n    }\n}",
  "909": "```\npublic class Solution {\n    public int snakesAndLadders(int[][] board) {\n        // Your code here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        int[][] board1 = {{-1,-1,-1,-1,-1,-1},{-1,2,16,3,-1,-1},{5,-1,-1,-1,2,17},{-1,-1,-1,-1,-1,8},{-1,27,-1,-1,-1,-1}};\n        System.out.println(\"Test Case 1: \" + solution.snakesAndLadders(board1));\n\n        // Test Case 2\n        int[][] board2 = {{-1,-1,-1,-1,-1,-1},{-1,5,16,3,-1,-1},{-1,-1,-1,-1,2,17},{-1,-1,-1,-1,-1,8},{-1,27,-1,-1,-1,-1}};\n        System.out.println(\"Test Case 2: \" + solution.snakesAndLadders(board2));\n\n        // Test Case 3\n        int[][] board3 = {{1,-1,-1,-1,-1,-1},{2,5,16,3,-1,-1},{-1,-1,-1,-1,4,17},{6,-1,-1,-1,-1,-1},{7,27,-1,-1,-1,-1}};\n        System.out.println(\"Test Case 3: \" + solution.snakesAndLadders(board3));\n    }\n}\n```",
  "911": "```\npublic class Solution {\n    public int[] getVotes(int[] timestamps, int[] votes) {\n        Map<Integer, Integer> voteMap = new HashMap<>();\n        List<int[]> timeVoteList = new ArrayList<>();\n\n        for (int i = 0; i < timestamps.length; i++) {\n            timeVoteList.add(new int[]{timestamps[i], votes[i]});\n        }\n\n        Collections.sort(timeVoteList, (a, b) -> a[0] - b[0]);\n\n        for (int[] timeVote : timeVoteList) {\n            voteMap.put(timeVote[1], timeMap.getOrDefault(timeVote[1], 0) + 1);\n        }\n\n        int[] result = new int[voteMap.size()];\n        int i = 0;\n        for (int vote : voteMap.values()) {\n            result[i] = vote;\n            i++;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[][] timestampsVotes1 = {{1, 1}, {4, 2}, {6, 3}};\n        System.out.println(Arrays.toString(solution.getVotes(timestampsVotes1[0], timestampsVotes1[1])));\n        \n        // Test case 2\n        int[][] timestampsVotes2 = {{12, 5}, {14, 7}, {16, 11}, {17, 10}, {19, 9}};\n        System.out.println(Arrays.toString(solution.getVotes(timestampsVotes2[0], timestampsVotes2[1])));\n        \n        // Test case 3\n        int[][] timestampsVotes3 = {{-1, -1}, {0, 4}, {2, 5}, {7, 8}, {9, 10}};\n        System.out.println(Arrays.toString(solution.getVotes(timestampsVotes3[0], timestampsVotes3[1])));\n    }\n}",
  "912": "```\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n                {5, 2, 8, 6, 1},\n                {4, 7, 9, 10, 3, 2, 1, 0},\n                {1, 1, 1, 1}\n        };\n\n        for (int[] array : arrays) {\n            System.out.println(\"Original Array: \" + Arrays.toString(array));\n            mergeSort(array);\n            System.out.println(\"Sorted Array: \" + Arrays.toString(array));\n            System.out.println();\n        }\n    }\n\n    public static void mergeSort(int[] array) {\n        if (array.length <= 1) return;\n\n        int mid = array.length / 2;\n        int[] left = Arrays.copyOfRange(array, 0, mid);\n        int[] right = Arrays.copyOfRange(array, mid, array.length);\n\n        mergeSort(left);\n        mergeSort(right);\n\n        merge(array, left, right);\n    }\n\n    public static void merge(int[] array, int[] left, int[] right) {\n        int i = 0;\n        int j = 0;\n        int k = 0;\n\n        while (i < left.length && j < right.length) {\n            if (left[i] <= right[j]) {\n                array[k++] = left[i++];\n            } else {\n                array[k++] = right[j++];\n            }\n        }\n\n        while (i < left.length) {\n            array[k++] = left[i++];\n        }\n\n        while (j < right.length) {\n            array[k++] = right[j++];\n        }\n    }\n}",
  "914": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + hasGroupsSizeX(new int[]{1, 1, 1, 2, 2, 3, 3}, 3));\n        System.out.println(\"Test Case 2: \" + hasGroupsSizeX(new int[]{0, 1, 2, 3, 4, 2}, 4));\n        System.out.println(\"Test Case 3: \" + hasGroupsSizeX(new int[]{1, 1, 1, 1, 2, 2, 3, 3, 3}, 3));\n\n    }\n\n    public static boolean hasGroupsSizeX(int[] deck, int x) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int card : deck) {\n            map.put(card, map.getOrDefault(card, 0) + 1);\n        }\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() < x) {\n                return false;\n            }\n        }\n        int gcd = map.values().stream().reduce(1, (a, b) -> gcd(a, b));\n        return gcd >= x;\n    }\n\n    public static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n```",
  "913": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minFlips(new int[][]{{0, 1}, {1, 2}})); // Test case 1\n        System.out.println(minFlips(new int[][]{{0, 1}, {1, 3}, {2, 3}})); // Test case 2\n        System.out.println(minFlips(new int[][]{{0, 1}, {1, 4}, {2, 5}, {3, 5}, {4, 5}})); // Test case 3\n    }\n\n    public static int minFlips(int[][] flips) {\n        int n = flips.length;\n        boolean[] visited = new boolean[n];\n        int[] order = new int[n];\n        int time = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(flips, visited, order, i, time);\n            }\n        }\n\n        for (int i = 1; i < n; i++) {\n            if (order[i] > order[0]) {\n                return -1;\n            }\n        }\n\n        int res = 0;\n        boolean[] prev = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                res += flip(flips, visited, prev, i);\n            }\n        }\n        return res;\n    }\n\n    public static void dfs(int[][] flips, boolean[] visited, int[] order, int u, int time) {\n        visited[u] = true;\n        for (int v : getNeighbors(flips, u)) {\n            if (!visited[v]) {\n                order[time++] = v;\n                dfs(flips, visited, order, v, time);\n            }\n        }\n    }\n\n    public static int[] getNeighbors(int[][] flips, int node) {\n        List<Integer> neighbors = new ArrayList<>();\n        for (int i = 0; i < flips.length; i++) {\n            if (flips[i][0] == node || flips[i][1] == node) {\n                neighbors.add(flips[i][0]);\n                neighbors.add(flips[i][1]);\n            }\n        }\n        return neighbors.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    public static int flip(int[][] flips, boolean[] visited, boolean[] prev, int node) {\n        if (!visited[node]) {\n            for (int i = 0; i < flips.length; i++) {\n                if (flips[i][0] == node || flips[i][1] == node) {\n                    if (visited[flips[i][0]] && visited[flips[i][1]]) {\n                        return 0;\n                    } else if (!visited[flips[i][0]] && !visited[flips[i][1]]) {\n                        return 2;\n                    }\n                }\n            }\n            return 1;\n        }\n        return prev[node] ? 0 : 1;\n    }\n}\n```",
  "915": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {10, 5, 2, 8};\n        System.out.println(\"Result for arr1: \" + partitionDisjoint(arr1));\n        \n        int[] arr2 = {3, 4, 7, 2, 3, 10, 1};\n        System.out.println(\"Result for arr2: \" + partitionDisjoint(arr2));\n        \n        int[] arr3 = {6, 5, 8, 1, 7, 2, 3};\n        System.out.println(\"Result for arr3: \" + partitionDisjoint(arr3));\n    }\n    \n    public static int[] partitionDisjoint(int[] nums) {\n        int n = nums.length;\n        int leftMax = 0;\n        int rightMin = Integer.MAX_VALUE;\n        int left = 0, right = 0;\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (nums[i] > leftMax) {\n                leftMax = nums[i];\n                left = i;\n            }\n            if (nums[n - 1 - i] < rightMin) {\n                rightMin = nums[n - 1 - i];\n                right = n - 1 - i;\n            }\n        }\n        \n        return new int[]{left + 1, right};\n    }\n}",
  "916": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(wordSubsets(new String[]{\"a\", \"ab\"}, new String[]{\"aaa\", \"aba\", \"b\"})); // expected output: [[0, 2], [1, 0]]\n        System.out.println(wordSubsets(new String[]{\"w\",\"wo\",\"wor\"}, new String[]{ \"wwoo\", \"wwow\", \"woo\" })); // expected output: [[0, 2, 3], [1, 1]]\n        System.out.println(wordSubsets(new String[]{\"a\",\"b\",\"c\"}, new String[]{})); // expected output: []\n    }\n\n    public static List<List<Integer>> wordSubsets(String[] words1, String[] words2) {\n        // Your code here\n    }\n}\n```",
  "917": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reverseOnlyLetters(\"Test1ng-Leet-CodE\"));\n        System.out.println(reverseOnlyLetters(\"a-bC-d*mk\"));  \n        System.out.println(reverseOnlyLetters(\"Sand-E-Java\"));\n    }\n\n    public static String reverseOnlyLetters(String s) {\n        int left = 0, right = s.length() - 1;\n        char[] arr = s.toCharArray();\n        while (left < right) {\n            if (!Character.isLetter(arr[left])) {\n                left++;\n            } else if (!Character.isLetter(arr[right])) {\n                right--;\n            } else {\n                swap(arr, left, right);\n                left++;\n                right--;\n            }\n        }\n        return new String(arr);\n    }\n\n    public static void swap(char[] arr, int i, int j) {\n        char temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n}\n```",
  "918": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maximumSumCircular(new int[]{1,-2,3,-5,3,,-1})) ; // expected output: 6\n        System.out.println(maximumSumCircular(new int[]{-5, -3, 5})); // expected output: 7\n        System.out.println(maximumSumCircular(new int[]{-1, -2, -3, -4})); // expected output: -1\n    }\n\n    public static int maximumSumCircular(int[] nums) {\n        int n = nums.length;\n        int totalMax = maxSubArray(nums);\n        int wrapMax = 0;\n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                sum += nums[j];\n                if (j == n - 1) break;\n            }\n            wrapMax = Math.max(wrapMax, sum);\n        }\n        return Math.max(totalMax, wrapMax);\n    }\n\n    public static int maxSubArray(int[] nums) {\n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n            if (maxEndingHere > maxSoFar) {\n                maxSoFar = maxEndingHere;\n            }\n        }\n        return maxSoFar;\n    }\n}",
  "919": "```\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass CBTInserter {\n\n    private TreeNode root;\n\n    public void insert(int v) {\n        if (root == null) {\n            root = new TreeNode(v);\n        } else {\n            insert(root, v);\n        }\n    }\n\n    private void insert(TreeNode node, int v) {\n        TreeNode leftChild = node.left;\n        if (leftChild == null) {\n            node.left = new TreeNode(v);\n        } else {\n            while (leftChild.right != null) {\n                leftChild = leftChild.right;\n            }\n            leftChild.right = new TreeNode(v);\n        }\n    }\n\n    public TreeNode getRoot() {\n        return root;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        CBTInserter cbtInserter = new CBTInserter();\n\n        // Test Case 1\n        cbtInserter.insert(1);\n        cbtInserter.insert(3);\n        cbtInserter.insert(4);\n        cbtInserter.insert(2);\n        cbtInserter.insert(5);\n\n        TreeNode root = cbtInserter.getRoot();\n        System.out.println(\"Test Case 1: \" + printTree(root));\n\n        // Test Case 2\n        cbtInserter = new CBTInserter();\n\n        cbtInserter.insert(5);\n        cbtInserter.insert(4);\n        cbtInserter.insert(3);\n\n        root = cbtInserter.getRoot();\n        System.out.println(\"Test Case 2: \" + printTree(root));\n\n        // Test Case 3\n        cbtInserter = new CBTInserter();\n\n        cbtInserter.insert(1);\n        cbtInserter.insert(2);\n        cbtInserter.insert(4);\n\n        root = cbtInserter.getRoot();\n        System.out.println(\"Test Case 3: \" + printTree(root));\n    }\n\n    private static String printTree(TreeNode node) {\n        if (node == null) return \"\";\n        StringBuilder sb = new StringBuilder();\n        queue(node, sb);\n        return sb.toString();\n    }\n\n    private static void queue(TreeNode node, StringBuilder sb) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(node);\n\n        while (!queue.isEmpty()) {\n            node = queue.poll();\n            if (node != null) {\n                sb.append(node.val).append(\" \");\n                queue.add(node.left);\n                queue.add(node.right);\n            }\n        }\n    }\n}",
  "920": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numMusicPlaylists(2, 3, 4)); // Test case 1\n        System.out.println(numMusicPlaylists(5, 3, 10)); // Test case 2\n        System.out.println(numMusicPlaylists(9, 18, 5)); // Test case 3\n    }\n\n    public static int numMusicPlaylists(int n, int share, int group) {\n        long mod = (long) Math.pow(10, 9) + 7;\n        long[] dp = new long[n + 1];\n        dp[0] = 1;\n\n        for (int i = 1; i <= n; i++) {\n            dp[i] = (dp[i - 1] * (i + share)) % mod;\n        }\n\n        int result = (int) ((dp[n] * group) % mod);\n        return result;\n    }\n}\n```",
  "921": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minAddToMakeValid(\"())\")); // expected: 1\n        System.out.println(minAddToMakeValid(\"((()))\")); // expected: 0\n        System.out.println(minAddToMakeValid(\"(\")); // expected: 1\n    }\n\n    public static int minAddToMakeValid(String S) {\n        int res = 0;\n        int count = 0;\n        for (char c : S.toCharArray()) {\n            if (c == '(') {\n                count++;\n            } else {\n                if (count > 0) {\n                    count--;\n                } else {\n                    res++;\n                }\n            }\n        }\n        return res + count;\n    }\n}\n```",
  "922": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = { {1,0}, {2,4,2,5,3}, {0} };\n        for (int i = 0; i < inputs.length; i++) {\n            int[] result = sortArrayByParityII(inputs[i]);\n            System.out.println(\"Input: \" + Arrays.toString(inputs[i]));\n            System.out.println(\"Result: \" + Arrays.toString(result));\n            System.out.println();\n        }\n    }\n\n    public static int[] sortArrayByParityII(int[] nums) {\n        int[] result = new int[nums.length];\n        int index = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if ((i % 2 == 0 && nums[i] % 2 != 0) || (i % 2 != 0 && nums[i] % 2 == 0)) {\n                result[index++] = nums[i];\n            }\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if ((i % 2 != 0 && nums[i] % 2 == 0) || (i % 2 == 0 && nums[i] % 2 != 0)) {\n                result[index++] = nums[i];\n            }\n        }\n        return result;\n    }\n}",
  "923": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums = { { -1, 0, 1, 2, -1, -4 }, \n                         { 1, 1, 1, 1 }, \n                         { 0, 0, 0, 0 } };\n        \n        for (int i = 0; i < nums.length; i++) {\n            threeSumWithMultiplicity(nums[i]);\n        }\n    }\n\n    public static void threeSumWithMultiplicity(int[] nums) {\n        Arrays.sort(nums);\n        int count = 0;\n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i > 0 && nums[i] == nums[i-1]) continue;\n            int j = i + 1, k = nums.length - 1;\n            while (j < k) {\n                long sum = (long)nums[i] + nums[j] + nums[k];\n                if (sum < 0) {\n                    while (j < k && nums[j] == nums[j+1]) j++;\n                    j++;\n                } else if (sum > 0) {\n                    while (j < k && nums[k] == nums[k-1]) k--;\n                    k--;\n                } else {\n                    count += k - j + 1;\n                    while (j < k && nums[j] == nums[j+1]) j++;\n                    while (j < k && nums[k] == nums[k-1]) k--;\n                    j++; k--;\n                }\n            }\n        }\n        System.out.println(\"Count: \" + count);\n    }\n}",
  "924": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph = {{1,2},{2,4},{4,5}};\n        System.out.println(minMalwareSpread(graph));\n        \n        graph = new int[][]{{1,2},{2,3},{3,4},{4,5}};\n        System.out.println(minMalwareSpread(graph));\n        \n        graph = new int[][]{{1,2},{2,3},{3,4},{4,5,6},{5,7}};\n        System.out.println(minMalwareSpread(graph));\n    }\n\n    public static int minMalwareSpread(int[][] M) {\n        // Add your code here.\n    }\n}",
  "925": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"alex\", \"aaleex\")); // Expected: true\n        System.out.println(canBeEqual(\"saeed\", \"Iesees\")); // Expected: false\n        System.out.println(canBeEqual(\"lrobe\", \"llloooobbee\")); // Expected: true\n    }\n\n    public static boolean canBeEqual(String name, String typed) {\n        int i = 0, j = 0;\n        while (i < name.length() && j < typed.length()) {\n            if (name.charAt(i) == typed.charAt(j)) {\n                i++;\n                j++;\n            } else if (j > 0 && typed.charAt(j - 1) == name.charAt(i)) {\n                j++;\n            } else {\n                break;\n            }\n        }\n        return i == name.length() && j == typed.length();\n    }\n}\n```",
  "926": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeIncreasing(\"abc\")); // Expected: true\n        System.out.println(canBeIncreasing(\"aa\")); // Expected: false\n        System.out.println(canBeIncreasing(\"aaba\")); // Expected: true\n    }\n\n    public static boolean canBeIncreasing(String s) {\n        int n = s.length();\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) > s.charAt(i + 1)) {\n                boolean isIncreasing = true;\n                for (int j = i + 2; j < n; j++) {\n                    if ((s.charAt(j) < s.charAt(i)) && (isIncreasing || s.charAt(i - 1) <= s.charAt(i))) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        return true;\n    }\n}",
  "927": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canEatEqualParts(new int[]{5,4,6})); // Expected: true\n        System.out.println(canEatEqualParts(new int[]{30,20,10,50})); // Expected: false\n        System.out.println(canEatEqualParts(new int[]{7,11})) ;// Expected: false\n    }\n\n    public static boolean canEatEqualParts(int[] arr) {\n        long total = 0;\n        for (int num : arr) {\n            total += num;\n        }\n        if(total%3!=0)\n            return false;\n\n        int partSize = total/3;\n        int equalParts = 0;\n        for (int num : arr) {\n            if(num <= partSize){\n                equalParts++;\n            } else{\n                break;\n            }\n        }\n        return equalParts*partSize == total;\n    }\n}\n```",
  "928": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph1 = {{1,2},{2,4},{4,5}};\n        System.out.println(minMalwareSpread(graph1));\n\n        int[][] graph2 = {{1,3},{0,2},{5,6}};\n        System.out.println(minMalwareSpread(graph2));\n\n        int[][] graph3 = {{1,2},{2,3},{4,5},{3,1},{1,5}};\n        System.out.println(minMalwareSpread(graph3));\n    }\n\n    public static int minMalwareSpread(int[][] graph) {\n        // your solution here\n    }\n}\n```",
  "929": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numUniqueEmails(new String[]{\"test.email+alex@leetcode.com\",\"test.eam+alex@leetcode.com\",\"test.email.alex@leetcode.com\"}));\n        System.out.println(numUniqueEmails(new String[]{\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"}));\n        System.out.println(numUniqueEmails(new String[]{}));\n    }\n\n    public static int numUniqueEmails(String[] emails) {\n        Set<String> uniqueEmails = new HashSet<>();\n        \n        for (String email : emails) {\n            int atSignIndex = email.indexOf('@');\n            String localPart = email.substring(0, atSignIndex);\n            String domain = email.substring(atSignIndex + 1);\n            \n            if (!localPart.isEmpty()) {\n                String[] parts = localPart.split('+');\n                localPart = parts[0];\n                for (int i = 1; i < parts.length; i++) {\n                    localPart += '+' + parts[i];\n                }\n            }\n            \n            uniqueEmails.add(localPart + '@' + domain);\n        }\n        \n        return uniqueEmails.size();\n    }\n}",
  "930": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(subarraySum(new int[]{1,0,1,0,1], 2)); // expected output: 4\n        System.out.println(subarraySum(new int[]{0,0,1,1,0,0,1,1,1,1,1,0,0,0,0,1,1,1,1}, 3)); // expected output: 23\n        System.out.println(subarraySum(new int[]{2,4,5,6}, 8)); // expected output: 20\n    }\n\n    public static int subarraySum(int[] nums, int k) {\n        int count = 0;\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            if (sum == k) {\n                count++;\n            }\n            sum -= k;\n            if (sum == k - k) {\n                sum = 0;\n            } else {\n                while (sum > k) {\n                    sum -= nums[i];\n                    i--;\n                }\n            }\n        }\n        return count;\n    }\n}\n```",
  "931": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{2,1,3},{6,5,4},{7,8,9}};\n        System.out.println(minFallingPathSum(matrix1));\n        \n        int[][] matrix2 = {{3,2,1},{1,4,5},{5,3,2}};\n        System.out.println(minFallingPathSum(matrix2));\n        \n        int[][] matrix3 = {{-19,67,5},{-40,-56,71},{55,82,100}};\n        System.out.println(minFallingPathSum(matrix3));\n    }\n\n    public static int minFallingPathSum(int[][] matrix) {\n        int m = matrix.length;\n        if (m == 0) return 0;\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 0; j < m; j++) {\n                int left = j > 0 ? matrix[i][j - 1] : Integer.MAX_VALUE;\n                int right = j < m - 1 ? matrix[i][j + 1] : Integer.MAX_VALUE;\n                matrix[i][j] += Math.min(left, right) == left ? left : right;\n            }\n        }\n\n        int minSum = Integer.MAX_VALUE;\n        for (int i = 0; i < m; i++) {\n            minSum = Math.min(minSum, matrix[m - 1][i]);\n        }\n\n        return minSum;\n    }\n}",
  "932": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2, 4, 6};\n        System.out.println(\"Result for \" + Arrays.toString(nums1) + \": \" + beautifulArray(nums1));\n        \n        int[] nums2 = {4, 6};\n        System.out.println(\"Result for \" + Arrays.toString(nums2) + \": \" + beautifulArray(nums2));\n        \n        int[] nums3 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n        System.out.println(\"Result for \" + Arrays.toString(nums3) + \": \" + beautifulArray(nums3));\n    }\n\n    public static boolean isBeautifulArray(int[] nums) {\n        boolean res = true;\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            if (!set.add(num)) {\n                res = false;\n                break;\n            }\n        }\n        return res;\n    }\n}",
  "933": "```\npublic class Main {\n    public static void main(String[] args) {\n        PhoneCallTracker tracker = new PhoneCallTracker();\n        \n        // Test case 1: One recent call\n        tracker.receiveCall();\n        System.out.println(\"Recent calls: \" + tracker.getRecentCallCount());\n        tracker.receiveCall();\n        System.out.println(\"Recent calls: \" + tracker.getRecentCallCount());\n\n        // Test case 2: Multiple recent calls\n        for (int i = 0; i < 5; i++) {\n            tracker.receiveCall();\n        }\n        System.out.println(\"Recent calls: \" + tracker.getRecentCallCount());\n\n        // Test case 3: No recent calls\n        tracker.receiveCall();\n        tracker.receiveCall();\n        tracker.receiveCall();\n        tracker.receiveCall();\n        tracker.receiveCall();\n        tracker.receiveCall();\n        System.out.println(\"Recent calls: \" + tracker.getRecentCallCount());\n    }\n}\n\nclass PhoneCallTracker {\n    private Queue<Integer> queue;\n\n    public PhoneCallTracker() {\n        this.queue = new LinkedList<>();\n    }\n\n    public void receiveCall() {\n        queue.add(1);\n    }\n\n    public int getRecentCallCount() {\n        return queue.size();\n    }\n}\n```",
  "934": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {\n            {0,1},\n            {1,0}\n        };\n        System.out.println(\"Case 1: \" + shortestBridge(grid1));\n        \n        int[][] grid2 = {\n            {0,1,0},\n            {0,1,0},\n            {0,0,1}\n        };\n        System.out.println(\"Case 2: \" + shortestBridge(grid2));\n\n        int[][] grid3 = {\n            {0,1,0,1,0},\n            {0,1,1,1,0},\n            {0,0,0,0,0},\n            {0,0,0,1,1}\n        };\n        System.out.println(\"Case 3: \" + shortestBridge(grid3));\n    }\n\n    public static int shortestBridge(int[][] grid) {\n        // Your code here\n    }\n}",
  "935": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(knightDialer(5)); // Expected: 10\n        System.out.println(knightDialer(4)); // Expected: 3\n        System.out.println(knightDialer(2)); // Expected: 1\n    }\n\n    public static int knightDialer(int n) {\n        if (n <= 0) return 1;\n        int[] dp = new int[n + 1];\n        dp[1] = 4;\n        dp[3] = 6;\n        dp[2] = 8;\n        for (int i = 4; i < n; i++) {\n            dp[i] = (dp[i - 1] * 3) % 10 + (dp[(i + 1) % n] * 2) % 10;\n        }\n        return (dp[n - 1] * 1) % 10;\n    }\n}",
  "936": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(stamping(new String[]{\"RRR\", \"RCC\", \"RCR\"})); // Expected: 2\n        System.out.println(stamping(new String[]{\"GIGSED\", \"EEDS\", \"DESJ\"})); // Expected: 3\n        System.out.println(stamping(new String[]{\"WWWW\", \"WBBWB\", \"WBBWW\"})); // Expected: 4\n    }\n\n    public static int stamping(String[] stamps) {\n        int count = 0;\n        Map<Character, Integer> map = new HashMap<>();\n        for (String stamp : stamps) {\n            StringBuilder sb = new StringBuilder();\n            for (char c : stamp.toCharArray()) {\n                if (!map.containsKey(c)) {\n                    map.put(c, 1);\n                } else {\n                    map.put(c, map.get(c) + 1);\n                }\n                sb.append(c);\n            }\n        }\n        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\n            count += Math.min(entry.getValue() / 2, entry.getKey() - 'A' + 1);\n        }\n        return count;\n    }\n}\n```",
  "937": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = {{20170630, \"0\t1\t2\t3\t4\t5\t6\t7\"}, \n                        {20170814, \"0\t1\t2\t3\t4\t5\t6\t7\"}, \n                        {20170701, \"0\t1\t2\t3\t4\t5\t6\t7\"}};\n        reorderLogs(logs);\n    }\n\n    public static void reorderLogs(int[][] logs) {\n        for (int i = 0; i < logs.length; i++) {\n            Arrays.sort((String[])logs[i].clone());\n        }\n    }\n}\n```",
  "938": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root = new Node(10);\n        root.left = new Node(5);\n        root.right = new Node(15);\n        root.left.left = new Node(3);\n        root.left.right = new Node(8);\n        System.out.println(\"Test case 1: \" + rangeSumBST(root, 7, 15));\n        \n        root = new Node(10);\n        root.left = new Node(5);\n        root.right = new Node(20);\n        root.left.left = new Node(3);\n        root.left.right = new Node(9);\n        System.out.println(\"Test case 2: \" + rangeSumBST(root, 7, 15));\n        \n        root = new Node(6);\n        root.left = new Node(4);\n        root.left.left = new Node(2);\n        root.left.right = new Node(6);\n        System.out.println(\"Test case 3: \" + rangeSumBST(root, 8, 10));\n    }\n\n    public static int rangeSumBST(Node root, int L, int R) {\n        int sum = 0;\n        if (root == null) {\n            return sum;\n        }\n        if (root.val >= L && root.val <= R) {\n            sum += root.val;\n        }\n        sum += rangeSumBST(root.left, L, R);\n        sum += rangeSumBST(root.right, L, R);\n        return sum;\n    }\n\n    static class Node {\n        int val;\n        Node left;\n        Node right;\n\n        Node(int v) {\n            val = v;\n        }\n    }\n}",
  "939": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimalAreaRect(new int[][]{{1,1},{1,3},{3,1},{3,3}})); // Output: 9\n        System.out.println(minimalAreaRect(new int[][]{{0,1},{1,0},{1,2},{2,1}})); // Output: 4\n        System.out.println(minimalAreaRect(new int[][]{{1,3},{3,1},{2,2},{2,4}})); // Output: 4\n    }\n\n    public static int minimalAreaRect(int[][] rec) {\n        Set<String> set = new HashSet<>();\n        for (int i = 0; i < rec.length; i++) {\n            for (int j = i + 1; j < rec.length; j++) {\n                String s1 = rec[i][0] + \",\" + rec[i][1];\n                String s2 = rec[j][0] + \",\" + rec[j][1];\n                if (!set.add(s1 + s2) && !set.remove(s1 + s2)) {\n                    set.remove(s2 + s1);\n                }\n            }\n        }\n\n        int minArea = Integer.MAX_VALUE;\n        for (String str : set) {\n            String[] pair = str.split(\",\");\n            int x1 = Integer.parseInt(pair[0]);\n            int y1 = Integer.parseInt(pair[1]);\n            int x2 = Integer.parseInt(pair[2]);\n            int y2 = Integer.parseInt(pair[3]);\n\n            minArea = Math.min(minArea, Math.abs((x2 - x1) * (y2 - y1)));\n        }\n\n        return minArea;\n    }\n}",
  "940": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findDistinctSubsequences(\"aba\")); // Output: 7\n        System.out.println(findDistinctSubsequences(\"abc\")); // Output: 4\n        System.out.println(findDistinctSubsequences(\"aaa\")); // Output: 3\n    }\n\n    public static int findDistinctSubsequences(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = 2;\n            } else {\n                dp[i][i + 1] = dp[i][i] + 1;\n            }\n        }\n        for (int length = 3; length <= n; length++) {\n            for (int i = 0; i < n - length + 1; i++) {\n                int j = i + length - 1;\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = 2 * dp[i + 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = dp[i][i + length - 1] + dp[i + 1][j];\n                }\n            }\n        }\n        return dp[0][n - 1];\n    }\n}\n```",
  "941": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(ValidMountainArray(new int[]{2,1})) ; \n        System.out.println(ValidMountainArray(new int[]{3,5,5})) ; \n        System.out.println(ValidMountainArray(new int[]{4,3,2,1})) ; \n    }\n\n    public static boolean ValidMountainArray(int[] arr) {\n        boolean isIncreasing = true;\n        boolean isDecreasing = false;\n\n        for (int i = 0; i < arr.length - 1; i++) {\n            if (arr[i] >= arr[i + 1]) {\n                isIncreasing = false;\n            } else if (arr[i] <= arr[i + 1]) {\n                isDecreasing = true;\n            }\n\n            if (!isIncreasing && !isDecreasing) {\n                return false;\n            }\n        }\n\n        return isDecreasing;\n    }\n}\n```",
  "942": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(arrayPairSum(new int[]{1,3,5,2,4}, 0) == \"13254\");\n        System.out.println(arrayPairSum(new int[]{1,1,2,2,3,3}, 3) == \"133223\");\n        System.out.println(arrayPairSum(new int[]{1,1,1,3}, 2) == \"11133\");\n    }\n\n    public static String arrayPairSum(int[] nums, int m) {\n        char[] res = new char[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            if ((i + 1) % 2 == 0) {\n                res[i] = Character.toString(nums[0]);\n            } else {\n                res[i] = Character.toString(nums[nums.length - 1]);\n            }\n        }\n        return new String(res);\n    }\n}\n```",
  "943": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(shortestSuperstring(new String[]{\"olleh\", \"naxi\", \"kxare\"}));\n        System.out.println(shortestSuperstring(new String[]{\"a\",\"b\",\"c\"}));\n        System.out.println(shortestSuperstring(new String[]{\"abc\", \"def\", \"ghi\"}));\n    }\n\n    public static String shortestSuperstring(String[] words) {\n        // Your code here\n    }\n}\n```",
  "944": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] tests = {\n                {{1,0,1},{1,1,0},{1}, // Test case 1\n                {{1,0,1},{1,1,1},{1,5}} ,// Test case 2\n                {{1,0,1},{1,1,0},{3}}   // Test case 3\n        };\n\n        for (int[] test : tests) {\n            System.out.println(\"Test Case: \" + Arrays.toString(test));\n            minDeletionSize(test);\n            System.out.println();\n        }\n    }\n\n    public static void minDeletionSize(int[][] arr) {\n        int res = 0;\n        for (int i = 0; i < arr[0].length; i++) {\n            boolean same = true;\n            char prev = ' ';\n            for (int j = 1; j < arr.length; j++) {\n                if (arr[j][i] <= prev) {\n                    same = false;\n                    break;\n                }\n                prev = (char) (arr[j][i]);\n            }\n            if (!same)\n                res++;\n        }\n        System.out.println(\"Minimum Deletion Size: \" + res);\n    }\n}\n```",
  "945": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {4,2,3};\n        System.out.println(\"Test case 1: \" + findMinIncrement(nums1));\n        \n        int[] nums2 = {1,2,3,4,5};\n        System.out.println(\"Test case 2: \" + findMinIncrement(nums2));\n        \n        int[] nums3 = {1,5,6,2,7};\n        System.out.println(\"Test case 3: \" + findMinIncrement(nums3));\n    }\n\n    public static int findMinIncrement(int[] nums) {\n        Arrays.sort(nums);\n        int minIncrement = 0;\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] <= nums[i - 1]) {\n                minIncrement += nums[i - 1] + 1 - nums[i];\n            }\n        }\n        return minIncrement;\n    }\n}\n```",
  "946": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isValidStackSequences(new String[][]{{1, 2, 3}, [4, 5], 6}));\n        System.out.println(isValidStackSequences(new String[][]{{1}, \"stay\", {3}}));\n        System.out.println(isValidStackSequences(new String[][]{[], [], []}));\n    }\n\n    public static boolean isValidStackSequences(String[][] pushed) {\n        Stack<Integer> stack = new Stack<>();\n        int i = 0;\n        for (String[] sequence : pushed) {\n            if (sequence.length > 0) {\n                for (String s : sequence) {\n                    while (!stack.isEmpty() && Integer.parseInt(stack.pop().toString()) >= Integer.parseInt(s)) {\n                        // do nothing\n                    }\n                    stack.push(s);\n                }\n            } else {\n                i++;\n            }\n        }\n        return true;\n    }\n}",
  "947": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] stones = {{0,1},{0,2},{1,2}};\n        System.out.println(\"Expected: 3, Actual: \" + mostStonesRemoved(stones));\n        \n        int[][] stones2 = {{0,1},{1,2},{2,3}};\n        System.out.println(\"Expected: 5, Actual: \" + mostStonesRemoved(stones2));\n\n        int[][] stones3 = {{0,1},{1,0}};\n        System.out.println(\"Expected: 3, Actual: \" + mostStonesRemoved(stones3));\n    }\n\n    public static int mostStonesRemoved(int[][] stones) {\n        // Write your code here\n        Map<Integer, Set<Integer>> rows = new HashMap<>();\n        Map<Integer, Set<Integer>> cols = new HashMap<>();\n\n        for (int[] stone : stones) {\n            rows.computeIfAbsent(stone[0], k -> new HashSet<>()).add(stone[1]);\n            cols.computeIfAbsent(stone[1], k -> new HashSet<>()).add(stone[0]);\n        }\n\n        int removedStones = 0;\n        for (Map.Entry<Integer, Set<Integer>> row : rows.entrySet()) {\n            if (row.getValue().size() > 1) {\n                removedStones += row.getValue().size() - 1;\n            }\n        }\n\n        for (Map.Entry<Integer, Set<Integer>> col : cols.entrySet()) {\n            if (col.getValue().size() > 1) {\n                removedStones += col.getValue().size() - 1;\n            }\n        }\n\n        return removedStones;\n    }\n}",
  "948": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {6, 5, 10, 8};\n        System.out.println(\"Test case 1: \" + bagOfTokensScore(arr1));\n        \n        int[] arr2 = {1, 3, 10, 4, 1};\n        System.out.println(\"Test case 2: \" + bagOfTokensScore(arr2));\n        \n        int[] arr3 = {1, 2, 3, 4, 5};\n        System.out.println(\"Test case 3: \" + bagOfTokensScore(arr3));\n    }\n\n    public static int bagOfTokensScore(int[] tokens) {\n        Arrays.sort(tokens);\n        int score = 0;\n        int left = 0;\n        int right = tokens.length - 1;\n\n        while (left <= right) {\n            if (tokens[left] == tokens[right]) {\n                score++;\n                left++;\n                right--;\n            } else if (tokens[right] > tokens[left]) {\n                score++;\n                left++;\n            } else {\n                score++;\n                right--;\n            }\n        }\n\n        return score;\n    }\n}",
  "949": "```\npublic class Solution {\n    public String largestTimeFromDigits(int[] A) {\n        // your solution here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.largestTimeFromDigits(new int[]{1, 2, 3, 4})); // should print \"23:41\"\n        System.out.println(solution.largestTimeFromDigits(new int[]{5,9,0,1})); // should print \"09:50\"\n        System.out.println(solution.largestTimeFromDigits(new int[]{6,7,0,8,2,9})) // should print \"06:28\"\n    }\n}\n```",
  "950": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] deck = {{1,6},{2,5},{3,4}};\n        revealDeck(deck);\n        \n        int[][] deck2 = {{1,10},{2,9},{7,8},{3,6},{5,5},{4,4}};\n        revealDeck(deck2);\n\n        int[][] deck3 = {{7,6},{3,3},{2,1}};\n        revealDeck(deck3);\n    }\n\n    public static void revealDeck(int[][] deck) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        \n        for (int[] card : deck) {\n            queue.offer(card[0]);\n            queue.offer(card[1]);\n        }\n        \n        int[] revealed = new int[queue.size()];\n        for (int i = 0; i < queue.size(); i++) {\n            revealed[i] = queue.poll();\n        }\n\n        System.out.println(Arrays.toString(revealed));\n    }\n}",
  "951": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test case 1:\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(2);\n        System.out.println(\"Test Case 1: \" + isFlipEquivalent(root1));\n\n        // Test case 2:\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(1);\n        root2.right = new TreeNode(1);\n        System.out.println(\"Test Case 2: \" + isFlipEquivalent(root2));\n\n        // Test case 3:\n        TreeNode root3 = null;\n        System.out.println(\"Test Case 3: \" + isFlipEquivalent(root3));\n    }\n\n    public static boolean isFlipEquivalent(TreeNode root) {\n        if (root == null) return true;\n\n        int[] inOrder = new int[1001];\n        int[] postOrder = new int[1001];\n\n        preOrder(root, inOrder);\n        postOrder(root, postOrder);\n\n        for (int i : inOrder) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        for (int i : postOrder) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        return Arrays.equals(inOrder, postOrder);\n    }\n\n    public static void preOrder(TreeNode root, int[] inOrder) {\n        if (root == null) return;\n\n        inOrder[inOrder.length / 2] = root.val;\n        preOrder(root.left, inOrder);\n        preOrder(root.right, inOrder);\n    }\n\n    public static void postOrder(TreeNode root, int[] postOrder) {\n        if (root == null) return;\n\n        postOrder(root.left, postOrder);\n        postOrder(root.right, postOrder);\n        postOrder[root.postOrderIndex++] = root.val;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    int postOrderIndex;\n\n    public TreeNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n        this.postOrderIndex = 0;\n    }\n}\n```",
  "952": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = { {{9, 32, 16}, 2 }, { {21, 4, 7}, 1 }, { {5, 20, 9, 13}, 6 } };\n        for (int[] input : inputs) {\n            System.out.println(\"Largest component size: \" + largestComponentSize(input[0], input[1]));\n        }\n    }\n\n    public static int largestComponentSize(int[] A, int B) {\n        // Your solution here\n    }\n}\n```",
  "954": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeArrayOfDoubledPairs(new int[]{4, 8, 2, 16})); // Test case 1: Expected true\n        System.out.println(canBeArrayOfDoubledPairs(new int[]{3, 1, 3, 6})); // Test case 2: Expected false\n        System.out.println(canBeArrayOfDoubledPairs(new int[]{0, 0, 0, 0, 0})); // Test case 3: Expected true\n    }\n\n    public static boolean canBeArrayOfDoubledPairs(int[] arr) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : arr) {\n            if (map.containsKey(num / 2)) {\n                map.put(num / 2, map.get(num / 2) + 1);\n            } else {\n                map.put(num / 2, 1);\n            }\n        }\n\n        int oddCount = 0;\n        for (int count : map.values()) {\n            if (count % 2 != 0) {\n                oddCount++;\n            }\n        }\n\n        return oddCount <= 1;\n    }\n}",
  "953": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        testCase1();\n        testCase2();\n        testCase3();\n    }\n\n    private static void testCase1() {\n        String[] words = {\"hello\",\"hi\"};\n        boolean result = wordComparator(words);\n        System.out.println(\"Test Case 1: \" + (result ? \"PASS\" : \"FAIL\"));\n    }\n\n    private static void testCase2() {\n        String[] words = {\"word\",\"world\",\"row\"};\n        boolean result = wordComparator(words);\n        System.out.println(\"Test Case 2: \" + (result ? \"PASS\" : \"FAIL\"));\n    }\n\n    private static void testCase3() {\n        String[] words = {\"kthxbye\", \"yertehk\"};\n        boolean result = wordComparator(words);\n        System.out.println(\"Test Case 3: \" + (result ? \"PASS\" : \"FAIL\"));\n    }\n\n    public static boolean wordComparator(String[] words) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (String word : words) {\n            for (int i = 0; i < word.length(); i++) {\n                char c = word.charAt(i);\n                if (!map.containsKey(c)) {\n                    map.put(c, i);\n                } else if (i > map.get(c)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```",
  "955": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrices = {{1,0},{1,1}};\n        System.out.println(minDeletionSize(matrices));\n        \n        matrices = new int[][]{{0,1},{2,3,4}};\n        System.out.println(minDeletionSize(matrices));\n\n        matrices = new int[][]{{1,3,5},{2,6,8},{4,7,9}};\n        System.out.println(minDeletionSize(matrices));\n    }\n\n    public static int minDeletionSize(int[][] A) {\n        int rows = A.length;\n        int cols = A[0].length;\n\n        for (int i = 0; i < cols; i++) {\n            boolean sorted = true;\n            char prev = 'a';\n            for (int j = 0; j < rows; j++) {\n                if (A[j][i] >= prev) {\n                    prev = (char)(A[j][i] + 1);\n                } else {\n                    sorted = false;\n                    break;\n                }\n            }\n\n            if (!sorted) return i;\n        }\n\n        return -1;\n    }\n}",
  "956": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] billboard = {{1, 2}, {4, 5}};\n        System.out.println(tallestBillboard(billboard)); // Expected output: 5\n\n        int[][] billboard1 = {{3, 6}, {8, 9}, {2, 4}};\n        System.out.println(tallestBillboard(billboard1)); // Expected output: 10\n\n        int[][] billboard2 = {{1, 2}, {4, 7}};\n        System.out.println(tallestBillboard(billboard2)); // Expected output: 7\n    }\n\n    public static int tallestBillboard(int[][] billboards) {\n        int n = billboards.length;\n        int[] heights = new int[n];\n        for (int i = 0; i < n; i++) {\n            heights[i] = billboards[i][1] - billboards[i][0];\n        }\n        \n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j <= n - 1; j++) {\n                if (heights[i] > heights[j]) {\n                    heights[j] -= heights[i];\n                }\n            }\n        }\n        \n        for (int height : heights) {\n            max = Math.max(max, height);\n        }\n        return max;\n    }\n}\n```",
  "957": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(prisonCellsAfterNDays(7, [[0,1],[5,6]]).toString());\n        System.out.println(prisonCellsAfterNDays(10, [[0,1],[1,0]]).toString());\n        System.out.println(prisonCellsAfterNDays(3, [[0,0,1],[0,1,0],[0,0,0],[0,1,1]]).toString());\n    }\n\n    public static int[] prisonCellsAfterNDays(int n, int[][] cells) {\n        // Your code here\n    }\n}",
  "958": "```\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n\n        System.out.println(\"Test case 1: \" + isCompleteTree(root1)); // true\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root2);\n        queue.offer(null);\n\n        System.out.println(\"Test case 2: \" + isCompleteTree(root2)); // false\n\n        TreeNode root3 = new TreeNode(1);\n        root3.right = new TreeNode(2);\n        System.out.println(\"Test case 3: \" + isCompleteTree(root3)); // true\n    }\n\n    public static boolean isCompleteTree(TreeNode root) {\n        if (root == null) return true;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.left != null) {\n                if (node.right == null || !isCompleteTree(node.left)) {\n                    return false;\n                }\n                queue.offer(node.left);\n            } else {\n                queue.offer(null); // mark this level as complete\n            }\n\n            if (node.right != null) {\n                queue.offer(node.right);\n            } else {\n                queue.poll(); // backtrack to the previous level\n            }\n        }\n\n        return true;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n}\n```",
  "960": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minDeletions(new char[][]{{\"a\",\"b\",\"c\"},{\"d\",\"e\",\"f\"},{\"g\",\"h\",\"i\"}})); // Output: 2\n        System.out.println(minDeletions(new char[][]{{\"aa\",\"aa\"},{\"ya\",\"ya\"},{\"uday\",\"yandu\"}})); // Output: 1\n        System.out.println(minDeletions(new char[][]{{\"XXX\",\"XXX\",\"XXX\"],[\"XXXX\",\"XXXX\",\"XXXE\"},\"ABCA\"})); // Output: 1\n    }\n\n    public static int minDeletions(char[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int res = 0;\n        boolean[][] vis = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            Arrays.fill(vis[i], false);\n        }\n        for (int l = 1; l <= n; l++) {\n            int cnt = 0;\n            for (int j = 0; j + l - 1 < n; j++) {\n                boolean sorted = true;\n                for (int i = 0; i < m; i++) {\n                    if (grid[i].charAt(j) > grid[i].charAt(j + l - 1)) {\n                        sorted = false;\n                        break;\n                    }\n                }\n                if (sorted) cnt++;\n            }\n            res += m - cnt;\n        }\n        return res;\n    }\n}",
  "959": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,1},{1,1}};\n        System.out.println(numRegions(grid1));\n        \n        int[][] grid2 = {{0,1,2},{0,1,0},{0,0,0}};\n        System.out.println(numRegions(grid2));\n        \n        int[][] grid3 = {{1,1,1},{1,0,1},{1,1,1}};\n        System.out.println(numRegions(grid3));\n    }\n\n    public static int numRegions(int[][] grid) {\n        // your code here\n    }\n}",
  "961": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1, 2, 3, 3};\n        System.out.println(findDuplicate(nums1)); // Output: 3\n\n        int[] nums2 = {1, 1};\n        System.out.println(findDuplicate(nums2)); // Output: 1\n\n        int[] nums3 = {1, 3, 4, 2, 2};\n        System.out.println(findDuplicate(nums3)); // Output: 2\n    }\n\n    public static int findDuplicate(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            int index = Math.abs(nums[i]) - 1;\n            if (nums[index] < 0) {\n                return Math.abs(nums[i]);\n            }\n            nums[index] *= -1;\n        }\n        return -1;\n    }\n}",
  "962": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumWidthRamp(new int[]{6,14,9,12,5,7,3,1}));\n        System.out.println(maximumWidthRamp(new int[]{9,8,6,6,6,1,1,1,10,4,3,2,1,0}));\n        System.out.println(maximumWidthRamp(new int[]{1, 3, 5, 3, 1}));\n    }\n\n    public static int maximumWidthRamp(int[] w) {\n        int n = w.length;\n        int[] leftMax = new int[n];\n        int[] rightMin = new int[n];\n\n        leftMax[0] = w[0];\n        for (int i = 1; i < n; i++) {\n            leftMax[i] = Math.max(leftMax[i - 1], w[i]);\n        }\n\n        rightMin[n - 1] = w[n - 1];\n        for (int i = n - 2; i >= 0; i--) {\n            rightMin[i] = Math.min(rightMin[i + 1], w[i]);\n        }\n\n        int maxWidth = 0;\n        int index = 0;\n        for (int i = 0; i < n; i++) {\n            if (leftMax[i] >= rightMin[i]) {\n                maxWidth = Math.max(maxWidth, rightMin[i] - leftMax[i] + 1);\n                index = i;\n            }\n        }\n\n        return index;\n    }\n}\n```",
  "963": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumAreaRect(new int[][]{{1,2},{1,3},{3,2},{3,3}})); // Expected: 4\n        System.out.println(minimumAreaRect(new int[][]{{0,1},{1,0},{1,1}})); // Expected: 1\n        System.out.println(minimumAreaRect(new int[][]{{1,5},{7,8},{3,9},{2,6}})); // Expected: 4\n    }\n\n    public static double minimumAreaRect(int[][] points) {\n        Set<String> set = new HashSet<>();\n        for (int[] point : points) {\n            set.add(point[0] + \",\" + point[1]);\n        }\n        \n        double minArea = Double.MAX_VALUE;\n        for (int[] point1 : points) {\n            for (int[] point2 : points) {\n                if (point1[0] == point2[0] || point1[1] == point2[1]) continue;\n                String s1 = point1[0] + \",\" + point1[1];\n                String s2 = point1[0] + \",\" + point2[1];\n                String s3 = point2[0] + \",\" + point1[1];\n                String s4 = point2[0] + \",\" + point2[1];\n                if (set.contains(s1) && set.contains(s2) && set.contains(s3) && set.contains(s4)) {\n                    double area = Math.abs((point1[0] - point2[0]) * (point1[1] - point2[1]));\n                    minArea = Math.min(minArea, area);\n                }\n            }\n        }\n        \n        return minArea;\n    }\n}",
  "964": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSteps(1)); // Expected output: 0\n        System.out.println(minSteps(8)); // Expected output: 4\n        System.out.println(minSteps(1000000000)); // Expected output: 1366\n    }\n\n    public static int minSteps(int n) {\n        return solve(n);\n    }\n\n    private static int solve(int n) {\n        int[] dp = new int[n + 1];\n        for (int i = 2; i <= n; i++) {\n            dp[i] = i;\n            for (int j = 2; j * j <= i; j++) {\n                if (i % j == 0) {\n                    dp[i] = Math.min(dp[i], 1 + dp[j]);\n                }\n            }\n        }\n        return dp[n];\n    }\n}",
  "965": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(1);\n        System.out.println(\"Is Univalued? \" + isUnivalued(root1));  // true\n\n        TreeNode root2 = new TreeNode(2);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n        System.out.println(\"Is Univalued? \" + isUnivalued(root2));  // false\n\n        TreeNode root3 = null;\n        System.out.println(\"Is Univalued? \" + isUnivalued(root3));  // true\n    }\n\n    public static boolean isUnivalued(TreeNode root) {\n        if (root == null) return true;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        int val = root.val;\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.val != val) return false;\n            if (node.left != null) queue.offer(node.left);\n            if (node.right != null) queue.offer(node.right);\n        }\n\n        return true;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n}\n```",
  "966": "```\npublic class Main {\n    public static void main(String[] args) {\n        VowelSpellChecker spellChecker = new VowelSpellChecker();\n        \n        System.out.println(\"Test Case 1: \");\n        System.out.println(\"Expected output: ['your', 'have'], Actual output: \" + Arrays.toString(spellChecker.spellCheck(new String[]{\"your\", \"friend\", \"have\", \"horse\"}, {\"your\", \"yore\", \"how\"})));\n        \n        System.out.println(\"\\nTest Case 2: \");\n        System.out.println(\"Expected output: [], Actual output: \" + Arrays.toString(spellChecker.spellCheck(new String[]{\"friends\", \"bells\", \"alex\", \"ay\"}, {\"ale\", \"x\", \"hope\"})));\n        \n        System.out.println(\"\\nTest Case 3: \");\n        System.out.println(\"Expected output: ['way'], Actual output: \" + Arrays.toString(spellChecker.spellCheck(new String[]{\"hello\", \"world\", \"leetcode\"], {\"hello\", \"leetcode\", \"world\"})));\n    }\n}\n\nclass VowelSpellChecker {\n    public List<String> spellCheck(String[] wordList, String[] wordDict) {\n        Map<Character, Character> dict = new HashMap<>();\n        for (String s : wordDict) {\n            for (char c : s.toCharArray()) {\n                if (!Character.isVowel(c)) {\n                    dict.putIfAbsent(c, c);\n                }\n            }\n        }\n\n        List<String> result = new ArrayList<>();\n        for (String word : wordList) {\n            boolean isSpellCorrect = true;\n            StringBuilder sb = new StringBuilder();\n            for (char c : word.toLowerCase().toCharArray()) {\n                if (!Character.isVowel(c)) {\n                    if (!dict.containsKey(c)) {\n                        isSpellCorrect = false;\n                        break;\n                    }\n                    sb.append(dict.get(c));\n                } else {\n                    sb.append(c);\n                }\n            }\n\n            if (isSpellCorrect) {\n                result.add(sb.toString());\n            }\n        }\n\n        return result;\n    }\n}",
  "967": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(findNumbers(new int[]{78,64,54,48,47}))); // [1,2]\n        System.out.println(Arrays.toString(findNumbers(new int[]{15,15,11}))); // []\n        System.out.println(Arrays.toString(findNumbers(new int[]{3,5}))); // [true,false]\n    }\n\n    public static int[] findNumbers(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        for (int num : nums) {\n            if (isSameConsecutiveDiff(num)) {\n                result.add(1);\n            } else {\n                result.add(0);\n            }\n        }\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    public static boolean isSameConsecutiveDiff(int n) {\n        String str = Integer.toString(n);\n        for (int i = 0; i < str.length() - 1; i++) {\n            if (!isConsecutiveDiff(str.charAt(i), str.charAt(i + 1))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isConsecutiveDiff(char a, char b) {\n        int diff = Math.abs(b - a);\n        return (diff == 1 && Character.getNumericValue(a) > Character.getNumericValue(b)) || diff == 1;\n    }\n}",
  "968": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(0);\n        root1.left = new TreeNode(0);\n        root1.right = new TreeNode(0);\n\n        System.out.println(\"Expected: 4, Got: \" + cameras(root1));\n\n        TreeNode root2 = new TreeNode(0);\n        root2.left = new TreeNode(0);\n        root2.right = new TreeNode(0);\n        root2.left.left = new TreeNode(0);\n        root2.left.right = new TreeNode(0);\n\n        System.out.println(\"Expected: 10, Got: \" + cameras(root2));\n\n        TreeNode root3 = new TreeNode(1);\n\n        System.out.println(\"Expected: 5, Got: \" + cameras(root3));\n    }\n\n    public static int cameras(TreeNode root) {\n        // Your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode leftmost;\n    TreeNode right;\n\n    public TreeNode(int x) { \n        val = x; \n    }\n}\n```",
  "969": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {\n            {1, 2, 3},\n            {5, 4, 3, 2, 1},\n            {1}\n        };\n        for (int i = 0; i < inputs.length; i++) {\n            System.out.println(\"Input: \" + Arrays.toString(inputs[i]));\n            pancakeSort(inputs[i]);\n            System.out.println(\"Sorted Output: \" + Arrays.toString(inputs[i]));\n            System.out.println();\n        }\n    }\n\n    public static void pancakeSort(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n; ) {\n            int maxIndex = findMaxIndex(arr, i);\n            if (maxIndex == i) {\n                i++;\n            } else {\n                reverse(arr, 0, maxIndex);\n                flip(arr, maxIndex);\n                i = maxIndex;\n            }\n        }\n    }\n\n    public static int findMaxIndex(int[] arr, int start) {\n        int maxIndex = start;\n        for (int i = start + 1; i < arr.length; i++) {\n            if (arr[i] > arr[maxIndex]) {\n                maxIndex = i;\n            }\n        }\n        return maxIndex;\n    }\n\n    public static void reverse(int[] arr, int start, int end) {\n        while (start < end) {\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n\n    public static void flip(int[] arr, int k) {\n        reverse(arr, 0, k);\n    }\n}\n```",
  "970": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] pairs = { { 3, 5 }, { 30, 9 }, { 1, 4 } };\n        for (int[] pair : pairs) {\n            System.out.println(pair[0] + \" and \" + pair[1] + \" are \" +\n                    isPowerfulIntegers(pair[0], pair[1]) ? \"powerful integers\" : \"not powerful integers\");\n        }\n    }\n\n    public static boolean isPowerfulIntegers(int a, int b) {\n        for (int i = 2; Math.pow(a, i) <= b; i++) {\n            if ((long) Math.pow(b, 1.0 / i) == (long) Math.pow(a, i / i)) return true;\n        }\n        return false;\n    }\n}\n```",
  "972": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"0/1\", \"0/1\")); // true\n        System.out.println(canBeEqual(\"4/6\", \"2/3\")); // true\n        System.out.println(canBeEqual(\"8/16\", \"4/8\")); // false\n    }\n\n    public static boolean canBeEqual(String fraction1, String fraction2) {\n        int numerator1 = 0;\n        int denominator1 = 0;\n        int numerator2 = 0;\n        int denominator2 = 0;\n\n        for (int i = 0; i < fraction1.length(); i++) {\n            if (Character.isDigit(fraction1.charAt(i))) {\n                numerator1 = Integer.parseInt(fraction1.substring(0, i));\n                denominator1 = Integer.parseInt(fraction1.substring(i));\n                break;\n            }\n        }\n\n        for (int i = 0; i < fraction2.length(); i++) {\n            if (Character.isDigit(fraction2.charAt(i))) {\n                numerator2 = Integer.parseInt(fraction2.substring(0, i));\n                denominator2 = Integer.parseInt(fraction2.substring(i));\n                break;\n            }\n        }\n\n        return numerator1 * denominator2 == numerator2 * denominator1;\n    }\n}",
  "971": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode tree1 = new TreeNode(1);\n        tree1.left = new TreeNode(2);\n        tree1.right = new TreeNode(2);\n        tree1.left.left = new TreeNode(4);\n        tree1.left.right = new TreeNode(3);\n        tree1.right.left = new TreeNode(4);\n        tree1.right.right = new TreeNode(3);\n\n        Node node1 = new Node(\"1\");\n        node1.left = new Node(\"2\");\n        node1.right = new Node(\"3\");\n\n        Node node2 = new Node(\"1\");\n        node2.left = new Node(\"3\");\n        node2.right = new Node(\"2\");\n\n        flipBinaryTree(tree1);\n        System.out.println(\"Expected Preorder: 1-2-4-3-4-3\");\n        System.out.println(\"Actual Preorder: \" + preorderTraversal(node1));\n        \n        TreeNode tree2 = new TreeNode(1);\n        tree2.left = new TreeNode(2);\n\n        Node node3 = new Node(\"1\");\n        node3.left = new Node(\"2\");\n\n        flipBinaryTree(tree2);\n        System.out.println(\"Expected Preorder: 1-2\");\n        System.out.println(\"Actual Preorder: \" + preorderTraversal(node3));\n        \n        tree2 = new TreeNode(1);\n        tree2.right = new TreeNode(0);\n\n        node3 = new Node(\"1\");\n\n        flipBinaryTree(tree2);\n        System.out.println(\"Expected Preorder: 1\");\n        System.out.println(\"Actual Preorder: \" + preorderTraversal(node3));\n    }\n\n    public static void flipBinaryTree(TreeNode root) {\n        if (root == null) return;\n        TreeNode node = new TreeNode(root.val);\n        node.right = root.left;\n        node.left = root.right;\n        flipBinaryTree(node.right);\n        flipBinaryTree(node.left);\n    }\n\n    public static String preorderTraversal(Node root) {\n        StringBuilder sb = new StringBuilder();\n        if (root == null) return \"\";\n        sb.append(root.val).append(\"-\");\n        sb.append(preorderTraversal(root.left));\n        sb.append(preorderTraversal(root.right));\n        return sb.toString();\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\nclass Node {\n    String val;\n    Node left;\n    Node right;\n    Node(String x) { val = x; }\n}",
  "973": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] points = {{1, 2}, {-2, -3}};\n        int K = 1;\n        kClosest(points, K);\n        \n        points = new int[][]{{3, 3}, {5 - 1, -2}, {-2, -2}};\n        K = 1;\n        kClosest(points, K);\n\n        points = new int[][]{{1, 0}, {0, 0}, {-1, 0}, {1, 0}};\n        K = 3;\n        kClosest(points, K);\n    }\n\n    public static void kClosest(int[][] points, int K) {\n        \n    }\n}\n```",
  "974": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(subarraySumsDivisibleByK(new int[]{4,5,0,-2,-3}, 3));\n        System.out.println(subarraySumsDivisibleByK(new int[]{5}, 5));\n        System.out.println(subarraySumsDivisibleByK(new int[]{-1,-1,-1}, 3));\n    }\n\n    public static int subarraySumsDivisibleByK(int[] nums, int k) {\n        int count = 0;\n        Map<Integer, Integer> sumMap = new HashMap<>();\n        sumMap.put(0, 1);\n        int currentSum = 0;\n\n        for (int num : nums) {\n            currentSum += num;\n            if ((currentSum % k == 0)) {\n                count += sumMap.getOrDefault(currentSum - k, 0);\n            }\n            sumMap.putOrDefault(currentSum % k, sumMap.getOrDefault(currentSum % k, 0) + 1);\n        }\n\n        return count;\n    }\n}\n```",
  "975": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] jumps = {{2,1,4,5,6,7},{0,1,2,3,4}};\n        for (int[] jump : jumps) {\n            System.out.println(\"The maximum number of odd-even jumps is \" + oddEvenJump(jump));\n        }\n    }\n\n    public static int oddEvenJump(int[] distances) {\n        // Code to solve the problem\n    }\n}\n```",
  "976": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] input1 = {2, 1, 3};\n        System.out.println(\"Largest Perimeter of \" + Arrays.toString(input1) + \": \" + largestPerimeter(input1));\n\n        int[] input2 = {5, 1, 5};\n        System.out.println(\"Largest Perimeter of \" + Arrays.toString(input2) + \": \" + largestPerimeter(input2));\n\n        int[] input3 = {3, 2, 3};\n        System.out.println(\"Largest Perimeter of \" + Arrays.toString(input3) + \": \" + largestPerimeter(input3));\n    }\n\n    public static int largestPerimeter(int[] A) {\n        Arrays.sort(A);\n        for (int i = A.length - 1; i >= 2; i--) {\n            if (A[i-1] + A[i-2] > A[i]) {\n                return A[i] + A[i-1] + A[i-2];\n            }\n        }\n        return 0;\n    }\n}",
  "977": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = new int[]{1, 2, 3, 4, 5};\n        System.out.println(\"Expected: [1, 4, 9, 16, 25]\");\n        System.out.println(\"Actual: \" + arraySquares(nums1));\n        \n        int[] nums2 = new int[]{-3, -1, 0, 2, 3};\n        System.out.println(\"Expected: [0, 1, 4, 9, 49]\");\n        System.out.println(\"Actual: \" + arraySquares(nums2));\n        \n        int[] nums3 = new int[]{0, 1};\n        System.out.println(\"Expected: [0, 1]\");\n        System.out.println(\"Actual: \" + arraySquares(nums3));\n    }\n    \n    public static String arraySquares(int[] nums) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < nums.length; i++) {\n            sb.append(nums[i] * nums[i]).append(\",\");\n        }\n        return \"[\" + sb.toString().substring(0, sb.length() - 1) + \"]\";\n    }\n}",
  "978": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {9,12,5,15,20};\n        System.out.println(\"Longest Turbulent Subarray of \" + Arrays.toString(nums1) + \": \" + longestTurbulentSubarray(nums1));\n        \n        int[] nums2 = {9,10,5,6,8};\n        System.out.println(\"Longest Turbulent Subarray of \" + Arrays.toString(nums2) + \": \" + longestTurbulentSubarray(nums2));\n\n        int[] nums3 = {4,17,12,11,16,14,15};\n        System.out.println(\"Longest Turbulent Subarray of \" + Arrays.toString(nums3) + \": \" + longestTurbulentSubarray(nums3));\n    }\n\n    public static int longestTurbulentSubarray(int[] nums) {\n        if (nums.length < 2) {\n            return 0;\n        }\n        \n        int max = 1, current = 1;\n        boolean previousOrder = nums[0] > nums[1];\n        \n        for (int i = 1; i < nums.length - 1; i++) {\n            if ((nums[i] > nums[i + 1]) == previousOrder) {\n                current++;\n            } else {\n                max = Math.max(max, current);\n                current = 2;\n            }\n            previousOrder = nums[i] > nums[i + 1];\n        }\n        \n        return Math.max(max, current);\n    }\n}",
  "979": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(0);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(0);\n        root.left.left = new TreeNode(6);\n        root.left.right = new TreeNode(5);\n        root.right.left = new TreeNode(4);\n        root.right.right = new TreeNode(7);\n\n        int[] expect1 = {7, 14, 5};\n        distributeCoins(root);\n        for (int coin : expect1) {\n            System.out.println(coin);\n        }\n\n        root = null;\n        int[] expect2 = {};\n        distributeCoins(root);\n        for (int coin : expect2) {\n            System.out.println(coin);\n        }\n\n        root = new TreeNode(3);\n        root.left = new TreeNode(0);\n        root.right = new TreeNode(0);\n\n        int[] expect3 = {1, 1};\n        distributeCoins(root);\n        for (int coin : expect3) {\n            System.out.println(coin);\n        }\n    }\n\n    public static void distributeCoins(TreeNode root) {\n        // Your solution here\n    }\n}\n```",
  "981": "```\npublic class TimeBasedKeyValueStore {\n    public static void main(String[] args) {\n        TimeBasedKeyValueStore store = new TimeBasedKeyValueStore();\n        \n        // Test case 1\n        store.set(\"hello\", \"world\", 2);\n        System.out.println(store.get(\"hello\")); // Output: world\n        \n        // Test case 2\n        store.set(\"goodbye\", \"cruelWorld\", 3);\n        System.out.println(store.get(\"goodbye\")); // Output: cruelWorld\n        \n        // Test case 3\n        store.set(\"test\", \"testValue\", 1);\n        store.set(\"test\", \"newTestValue\", 2);\n        System.out.println(store.get(\"test\", 1)); // Output: testValue\n        System.out.println(store.get(\"test\")); // Output: newTestValue\n    }\n}\n\nclass TimeBasedKeyValueStore {\n    \n    Map<String, TreeMap<Integer, String>> store;\n    \n    public TimeBasedKeyValueStore() {\n        this.store = new HashMap<>();\n    }\n    \n    public void set(String key, String value, int timestamp) {\n        if (!store.containsKey(key)) {\n            store.put(key, new TreeMap<>());\n        }\n        store.get(key).put(timestamp, value);\n    }\n    \n    public String get(String key, int timestamp) {\n        Map<Integer, String> map = store.getOrDefault(key, new HashMap<>());\n        Map.Entry<Integer, String> entry = map.floorEntry(timestamp);\n        \n        return entry != null ? entry.getValue() : \"None\";\n    }\n}\n```",
  "980": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(uniquePathsIII(new int[][]{\n                {0,1,0},\n                {0,0,0},\n                {0,2,0}\n            }, 1) == 2);\n        System.out.println(uniquePathsIII(new int[][]{\n                {0,1,0},\n                {0,0,0},\n                {0,2,0}\n            }, 2) == 0);\n        System.out.println(uniquePathsIII(new int[][]{\n                {3,0,0},\n                {5,0,1},\n                {0,0,0}\n            }, 1) == 20);\n    }\n\n    public static int uniquePathsIII(int[][] grid, int start) {\n        int m = grid.length;\n        if (m == 0) return 0;\n        int n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    dfs(grid, visited, start, 0);\n                }\n            }\n        }\n        return countPaths(grid, visited, 0, 0);\n    }\n\n    public static void dfs(int[][] grid, boolean[][] visited, int i, int j) {\n        int m = grid.length;\n        int n = grid[0].length;\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j]) return;\n        visited[i][j] = true;\n        if (grid[i][j] == 2) {\n            return;\n        }\n        dfs(grid, visited, i + 1, j);\n        dfs(grid, visited, i - 1, j);\n        dfs(grid, visited, i, j + 1);\n        dfs(grid, visited, i, j - 1);\n    }\n\n    public static int countPaths(int[][] grid, boolean[][] visited, int i, int j) {\n        int m = grid.length;\n        int n = grid[0].length;\n        if (i < 0 || i >= m || j < 0 || j >= n || visited[i][j]) return 0;\n        if (grid[i][j] == 2) return 1;\n        visited[i][j] = true;\n        int count = dfsCount(grid, visited, i + 1, j);\n        visited[i][j] = false;\n        count += dfsCount(grid, visited, i - 1, j);\n        visited[i][j] = true;\n        count += dfsCount(grid, visited, i, j + 1);\n        visited[i][j] = false;\n        count += dfsCount(grid, visited, i, j - 1);\n        return count;\n    }\n\n    public static int dfsCount(int[][] grid, boolean[][] visited, int i) {\n        int m = grid.length;\n        int n = grid[0].length;\n        if (i < 0 || i >= m) return 0;\n        if (j < 0 || j >= n) return 0;\n        if (visited[i][j]) return 0;\n        visited[i][j] = true;\n        if (grid[i][j] == 2) {\n            return 1;\n        }\n        int count = dfsCount(grid, visited, i + 1);\n        count += dfsCount(grid, visited, i - 1);\n        count += dfsCount(grid, visited, i, j + 1);\n        count += dfsCount(grid, visited, i, j - 1);\n        return count;\n    }\n}",
  "982": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{0, 1}, {1, 2}, {4, 7}};\n        System.out.println(countGoodTriplets(arr1)); // Expected output: 3\n\n        int[][] arr2 = {{0, 5}, {1, 4}, {5, 6}};\n        System.out.println(countGoodTriplets(arr2)); // Expected output: 8\n\n        int[][] arr3 = {{1, 2}, {2, 3}};\n        System.out.println(countGoodTriplets(arr3)); // Expected output: 0\n    }\n\n    public static int countGoodTriplets(int[][] triplets, int low, int high) {\n        int count = 0;\n        for (int[] triplet : triplets) {\n            if ((triplet[0] & triplet[1]) == 0 && (triplet[1] & triplet[2]) == 0 && (triplet[0] & triplet[2]) == 0) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "983": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] costs = {9, 26, 86};\n        System.out.println(\"Minimum cost for tickets: \" + minCostToVisitAllBusStops(costs));\n        \n        int[] costs1 = {2,5,3};\n        System.out.println(\"Minimum cost for tickets: \" + minCostToVisitAllBusStops(costs1));\n\n        int[] costs2 = {4,4,6};\n        System.out.println(\"Minimum cost for tickets: \" + minCostToVisitAllBusStops(costs2));\n    }\n\n    public static int minCostToVisitAllBusStops(int[] costs) {\n        int n = costs.length;\n        int dp[] = new int[n];\n        \n        dp[0] = costs[0];\n        for (int i = 1; i < n; i++) {\n            dp[i] = Math.min(dp[i-1], costs[i]);\n        }\n        \n        int minCost = dp[n-1];\n        for (int i = n - 2; i >= 0; i--) {\n            if (i > 0) {\n                minCost = Math.min(minCost, dp[i-1] + costs[i]);\n            } else {\n                minCost = Math.min(minCost, costs[i]);\n            }\n        }\n        \n        return minCost;\n    }\n}",
  "984": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(withoutAAAorBBB(\"aabba\")); // true\n        System.out.println(withoutAAAorBBB(\"aaaaa\")); // false\n        System.out.println(withoutAAAorBBB(\"abb\")); // true\n    }\n\n    public static boolean withoutAAAorBBB(String s) {\n        int aCount = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'a') {\n                aCount++;\n                if (i + 2 < s.length() && s.charAt(i + 1) == 'a' && s.charAt(i + 2) == 'a') {\n                    return false;\n                }\n            } else if (s.charAt(i) == 'b') {\n                int bCount = 1;\n                while (i + 1 < s.length() && s.charAt(i + 1) == 'b') {\n                    i++;\n                    bCount++;\n                }\n                if (bCount >= 3) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
  "985": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums = {{1,2,3,4},{7,8,9,10},{5}};\n        for (int i = 0; i < 3; i++) {\n            System.out.println(\"Sum of even numbers after queries: \" + sumOfEvenAfterQueries(nums[i]));\n        }\n    }\n\n    public static int sumOfEvenAfterQueries(int[][] nums) {\n        int totalSum = 0;\n        for (int num : nums[0]) {\n            if (num % 2 == 0) {\n                totalSum += num;\n            }\n        }\n\n        for (int i = 1; i < nums.length; i++) {\n            for (int j = 0; j < nums[i].length; j++) {\n                if (nums[i][j] % 2 == 0) {\n                    totalSum -= nums[i - 1][j];\n                }\n                totalSum += nums[i][j];\n            }\n        }\n\n        return totalSum;\n    }\n}",
  "986": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals1 = {{0,2},{5,10},{12,23}};\n        int[][] intervals2 = {{1,5},{6,8},{20,25}};\n        System.out.println(intersection(intervals1, intervals2));\n        \n        int[][] intervals3 = {{1,3},{5,7}};\n        int[][] intervals4 = {{0,2},{5,10}};\n        System.out.println(intersection(intervals3, intervals4));\n\n        int[][] intervals5 = {{1,3},{5,7}};\n        int[][] intervals6 = {{0,2},{4,8}};\n        System.out.println(intersection(intervals5, intervals6));\n    }\n\n    public static List<List<int[]>> intersection(int[][] A, int[][] B) {\n        Arrays.sort(A, (a, b) -> Integer.compare(a[0], b[0]));\n        Arrays.sort(B, (a, b) -> Integer.compare(a[0], b[0]));\n\n        List<List<int[]>> result = new ArrayList<>();\n        int i = 0;\n        int j = 0;\n\n        while(i < A.length && j < B.length){\n            if(A[i][0] < B[j][0]){\n                i++;\n            } else if(B[j][0] < A[i][0]){\n                j++;\n            } else {\n                List<int[]> list = new ArrayList<>();\n                int start = Math.max(A[i][0], B[j][0]);\n                int end = Math.min(A[i][1], B[j][1]);\n\n                while(i < A.length && A[i][0] <= end){\n                    if(A[i][0] == start){\n                        list.add(new int[]{start, end});\n                    }\n                    i++;\n                }\n\n                while(j < B.length && B[j][0] <= end){\n                    if(B[j][0] == start){\n                        list.add(new int[]{start, end});\n                    }\n                    j++;\n                }\n\n                result.add(list);\n            }\n        }\n\n        return result;\n    }\n}",
  "987": "```\nclass Solution {\n    public List<List<Integer>> verticalOrder(TreeNode root) {\n        if (root == null) return new ArrayList<>();\n\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        int min = 0;\n        int max = 0;\n\n        queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = q.poll();\n                int x = node.val;\n                int y = map.containsKey(x) ? map.get(x).size() : 0;\n\n                if (y > max) max = y;\n                if (y < min) min = y;\n\n                map.computeIfAbsent(y, k -> new ArrayList<>()).add(x);\n                if (node.left != null) q.offer(node.left);\n                if (node.right != null) q.offer(node.right);\n            }\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = min; i <= max; i++) {\n            res.add(new ArrayList<>(map.getOrDefault(i, Collections.emptyList())));\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(9);\n        root1.right = new TreeNode(20);\n        root1.right.left = new TreeNode(15);\n        root1.right.right = new TreeNode(7);\n\n        System.out.println(solution.verticalOrder(root1));\n\n        TreeNode root2 = new TreeNode(0);\n        root2.left = new TreeNode(8);\n        root2.right = new TreeNode(17);\n        root2.right.left = new TreeNode(15);\n        root2.right.right = new TreeNode(4);\n\n        System.out.println(solution.verticalOrder(root2));\n\n        TreeNode root3 = null;\n\n        System.out.println(solution.verticalOrder(root3));\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "988": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minmalTree(\"1(2)(3(4))\")); // Expected: \"434\"\n        System.out.println(minmalTree(\"1(2)3\")); // Expected: \"321\"\n        System.out.println(minmalTree(\"1(2(3))\")); // Expected: \"312\"\n    }\n\n    public static String minmalTree(String s) {\n        int n = s.length();\n        StringBuilder sb = new StringBuilder();\n        dfs(s, 0, \"\", true, sb);\n        return sb.toString();\n    }\n\n    private static void dfs(String s, int i, String path, boolean isLeft, StringBuilder sb) {\n        if (i == s.length()) {\n            sb.append(path);\n            return;\n        }\n        char c = s.charAt(i);\n        if (Character.isDigit(c)) {\n            sb.append(c);\n            dfs(s, i + 1, path + c, false, sb);\n        } else {\n            String newPath = (isLeft ? \"(\" : \")\") + path + c;\n            dfs(s, i + 1, newPath, !isLeft, sb);\n        }\n    }\n}\n```",
  "989": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int num = 34;\n        int k = 2;\n        int[][] result1 = addToArrayForm(new int[]{1, 2, 3}, num, k);\n        for (int i : result1) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        num = 432386;\n        k = 4;\n        int[][] result2 = addToArrayForm(new int[]{0,9,9,1,5,7}, num, k);\n        for (int i : result2) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        num = 12345;\n        k = 10;\n        int[][] result3 = addToArrayForm(new int[]{0,1,2,3}, num, k);\n        for (int i : result3) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n    }\n\n    public static int[][] addToArrayForm(int[] nums, int k, int length) {\n        for (int i = nums.length - 1; i >= 0; i--) {\n            k += nums[i];\n            int[] newNums = new int[nums.length + 1];\n            System.arraycopy(nums, 0, newNums, 1, nums.length);\n            newNums[0] = k % 10;\n            k /= 10;\n            if (k == 0 && length == 0) {\n                return new int[][]{newNums};\n            }\n            nums = newNums;\n        }\n        int[] result = {k};\n        return new int[][]{result};\n    }\n}",
  "990": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(new String[]{\"leetcode.com\",\"wincompiler.com\",\"apple.com\"}, new int[][]{{1,1},{1,1}})); // Test case 1\n        System.out.println(canBeEqual(new String[]{\"leetcode.com\"},\"leetcode.com\")); // Test case 2\n        System.out.println(canBeEqual(new String[]{},\"\")); // Test case 3\n    }\n\n    public static boolean canBeEqual(String[] equationChain, int[][] opinions) {\n        Map<String, Integer> opinionMap = new HashMap<>();\n        for (int i = 0; i < opinions.length; i++) {\n            if (!opinionMap.containsKey(equationChain[i])) {\n                opinionMap.put(equationChain[i], opinions[i][0]);\n            } else {\n                if (opinionMap.get(equationChain[i]) != opinions[i][0]) {\n                    return false;\n                }\n            }\n        }\n\n        for (int i = 1; i < equationChain.length; i++) {\n            int prevOpinion = opinionMap.getOrDefault(equationChain[i - 1], 0);\n            int currOpinion = opinionMap.getOrDefault(equationChain[i], 0);\n            if ((prevOpinion == 1 && currOpinion != 1) || (prevOpinion == -1 && currOpinion != -1)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```",
  "991": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(brokenCalc(2, 3)); // Expected: 4\n        System.out.println(brokenCalc(5, 15)); // Expected: 20\n        System.out.println(brokenCalc(3, 10)); // Expected: 9\n    }\n\n    public static int brokenCalc(int X, int Y) {\n        int res = 0;\n        while (Y > X) {\n            Y /= 2;\n            res++;\n        }\n        return res + (X - Y);\n    }\n}",
  "992": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(subarraySum(new int[]{1,2,1,3}, 2)); // Expected: 7\n        System.out.println(subarraySum(new int[]{1,2,1,3,4}, 3)); // Expected: 18\n        System.out.println(subarraySum(new int[]{99,99,99}, 2)); // Expected: 1\n    }\n\n    public static int subarraySum(int[] nums, int k) {\n        int n = nums.length;\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            HashSet<Integer> set = new HashSet<>();\n            for (int j = i; j < n; j++) {\n                if (set.size() == k - 1) {\n                    res += nums[j];\n                    break;\n                }\n                set.add(nums[j]);\n            }\n        }\n        return res;\n    }\n}\n```",
  "993": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode node1 = new TreeNode(1);\n        node1.left = new TreeNode(2);\n        node1.right = new TreeNode(3);\n        node1.left.left = new TreeNode(4);\n        node1.left.right = new TreeNode(5);\n\n        boolean result1 = isCousins(node1, 4, 5);\n        System.out.println(\"Test case 1: \" + result1);\n\n        TreeNode node2 = new TreeNode(1);\n        node2.left = new TreeNode(2);\n        node2.right = new TreeNode(3);\n        node2.left.left = new TreeNode(6);\n        node2.left.right = new TreeNode(7);\n\n        boolean result2 = isCousins(node2, 6, 7);\n        System.out.println(\"Test case 2: \" + result2);\n\n        TreeNode node3 = new TreeNode(1);\n        node3.left = new TreeNode(2);\n\n        boolean result3 = isCousins(node3, 2, null);\n        System.out.println(\"Test case 3: \" + result3);\n    }\n}\n```",
  "994": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{2,1,1},{1,1,0},{0,1,1}};\n        System.out.println(\"Expected: 4 Got: \" + orangesRotting(grid1));\n\n        int[][] grid2 = {{0,2}};\n        System.out.println(\"Expected: 0 Got: \" + orangesRotting(grid2));\n\n        int[][] grid3 = {{0,1,2},{0,0,0}};\n        System.out.println(\"Expected: 0 Got: \" + orangesRotting(grid3));\n    }\n\n    public static int orangesRotting(int[][] grid) {\n        int m = grid.length;\n        if (m == 0) return 0;\n\n        int n = grid[0].length;\n        int time = 0, freshCount = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) freshCount++;\n                else if (grid[i][j] == 2) grid[i][j] = -1;\n            }\n        }\n\n        List<int[]> queue = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 2) {\n                    queue.add(new int[]{i, j});\n                }\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] pos = queue.remove(0);\n                for (int x = -1; x <= 1; x++) {\n                    for (int y = -1; y <= 1; y++) {\n                        if ((x == 0) && (y == 0)) continue;\n                        int newX = pos[0] + x, newY = pos[1] + y;\n\n                        if ((newX >= 0) && (newX < m) && (newY >= 0) && (newY < n) && grid[newX][newY] == 1) {\n                            freshCount--;\n                            grid[newX][newY] = -1;\n                            queue.add(new int[]{newX, newY});\n                        }\n                    }\n                }\n            }\n            time++;\n        }\n\n        return freshCount == 0 ? time - 1 : -1;\n    }\n}",
  "995": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {0,1};\n        System.out.println(\"Test case 1: \" + minKBitFlips(nums1, 2)); // Expected output: 0\n\n        int[] nums2 = [1,1,1,0,0,0,1,1,1,1,1];\n        System.out.println(\"Test case 2: \" + minKBitFlips(nums2, 3)); // Expected output: 5\n\n        int[] nums3 = [0,1,0,1,0,1,1,0].\n        System.out.println(\"Test case 3: \" + minKBitFlips(nums3, 4)); // Expected output: 8\n    }\n\n    public static int minKBitFlips(int[] nums, int k) {\n        int n = nums.length;\n        for (int i = 0; i < n - k; i++) {\n            if ((nums[i] ^ nums[i + k]) == 1) return k;\n        }\n        return n % 2 == 0 ? n : 1;\n    }\n}\n```",
  "996": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numSquarefulArrays(2));\n        System.out.println(numSquarefulArrays(5));\n        System.out.println(numSquarefulArrays(7));\n    }\n\n    public static int numSquarefulArrays(int n) {\n        // write your code here\n    }\n}\n```",
  "997": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] trust = {{1,2},{2,3},{2,4},{5,6}};\n        System.out.println(findJudge(4, trust));\n        \n        int[][] trust1 = {{1,2},{2,3}};\n        System.out.println(findJudge(3, trust1));\n        \n        int[][] trust2 = {{1,2},{2,3},{3,4},{4,5},{5,6}};\n        System.out.println(findJudge(6, trust2));\n    }\n\n    public static int findJudge(int n, int[][] trust) {\n        int[] inDegree = new int[n+1];\n        for (int i = 0; i < trust.length; i++) {\n            inDegree[trust[i][0]]--;\n            inDegree[trust[i][1]]++;\n        }\n        \n        for (int i = 1; i <= n; i++) {\n            if (inDegree[i] == 0) return i;\n        }\n        \n        return -1;\n    }\n}",
  "998": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node root1 = new Node(4);\n        root1.left = new Node(2);\n        root1.right = new Node(7);\n        System.out.println(\"Max sum for tree 1: \" + maxSum(root1));\n\n        Node root2 = new Node(5);\n        root2.left = new Node(3);\n        root2.right = new Node(6);\n        System.out.println(\"Max sum for tree 2: \" + maxSum(root2));\n\n        Node root3 = new Node(7);\n        root3.left = new Node(1);\n        root3.right = new Node(8);\n        System.out.println(\"Max sum for tree 3: \" + maxSum(root3));\n    }\n\n    public static int maxSum(Node root) {\n        if (root == null) return 0;\n        int[] maxSums = new int[2];\n        maxSums[0] = helper(root, true, maxSums);\n        maxSums[1] = helper(root, false, maxSums);\n        return Math.max(maxSums[0], maxSums[1]);\n    }\n\n    public static int helper(Node node, boolean isRoot, int[] maxSums) {\n        if (node == null) return 0;\n        int leftSum = helper(node.left, true, maxSums);\n        int rightSum = helper(node.right, true, maxSums);\n        if (!isRoot) {\n            maxSums[0] = Math.max(maxSums[0], node.val + leftSum + rightSum);\n            return node.val;\n        }\n        int sum = node.val + leftSum + rightSum;\n        if (sum > maxSums[1]) {\n            maxSums[1] = sum;\n        }\n        return sum;\n    }\n\n    static class Node {\n        int val;\n        Node left, right;\n\n        public Node(int val) {\n            this.val = val;\n        }\n    }\n}",
  "999": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] board = {{0,1,6,5,7,0,0,9,2,0},{4,2,11,10,0,0,3,8,1,0},{5,12,14,13,3,15,16,0,0,0},\n                {1,1,1,1,1,0,0,0,0,5},{18,17,0,0,11,10,1,1,1,1},{19,0,23,22,4,4,7,6,15,14},\n                {21,20,13,12,2,3,16,15,8,9},{31,30,5,6,10,11,35,34,24,25},{32,33,27,26,25,24,29,28,23,22},\n                {33,34,35,36,37,38,39,40,41,42}};\n\n        int[][] availableCaptures = new Solution().numRookCaptures(board);\n\n        for (int i = 0; i < board.length; i++) {\n            for (int j = 0; j < board[0].length; j++) {\n                System.out.print(availableCaptures[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "1000": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minStones(5, new int[]{1,2,5}, new int[][]{{1,2},{2,4},{4,5}}));\n        System.out.println(minStones(6, new int[]{5}, new int[][]{}));\n        System.out.println(minStones(7, new int[]{3,4,5,6}, new int[][]{{1,2},{2,3},{3,4},{4,5},{5,6}}));\n    }\n\n    public static int minStones(int V, int[] stones, int[][] points) {\n        int n = stones.length;\n        // Sort the stones by value\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (stones[i] > stones[j]) {\n                    int temp = stones[i];\n                    stones[i] = stones[j];\n                    stones[j] = temp;\n                }\n            }\n        }\n\n        // Initialize a dynamic programming table\n        int[] dp = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            dp[i] = Integer.MAX_VALUE;\n        }\n        dp[0] = 0;\n\n        // Iterate over all stones and points\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n && Math.abs(stones[j] - stones[i]) <= V; j++) {\n                if (j >= i) {\n                    int temp = dp[j + 1];\n                    for (int k = 0; k < points.length; k++) {\n                        if (points[k][0] == i && points[k][1] == j) {\n                            temp += stones[j + 1];\n                            break;\n                        }\n                    }\n                    dp[i] = Math.min(dp[i], temp);\n                }\n            }\n        }\n\n        return dp[0];\n    }\n}\n```",
  "1001": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,0},{0,1},{1,2},{2,2}};\n        System.out.println(\"Test case 1: \" + gridIllumination(grid1));\n        \n        int[][] grid2 = {{0,0},{0,1},{1,3}});\n        System.out.println(\"Test case 2: \" + gridIllumination(grid2));\n        \n        int[][] grid3 = {{1,1},{1,2},{4,5}});\n        System.out.println(\"Test case 3: \" + gridIllumination(grid3));\n    }\n\n    public static boolean gridIllumination(int[][] grid) {\n        // TO DO\n    }\n}\n```",
  "1002": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        String[] word1 = {\"bella\", \"label\", \"roller\"};\n        String[] word2 = {\"roller\", \"label\", \"bella\"};\n\n        System.out.println(commonChars(word1));\n        System.out.println(commonChars(word2));\n        System.out.println(commonChars(new String[]{\"cool\", \"lock\", \"cook\"}));\n    }\n\n    public static List<String> commonChars(String[] words) {\n        Map<Character, Integer> countMap = new HashMap<>();\n        for (String word : words) {\n            Map<Character, Integer> wordCountMap = new HashMap<>();\n            for (char c : word.toLowerCase().toCharArray()) {\n                wordCountMap.put(c, wordCountMap.getOrDefault(c, 0) + 1);\n            }\n            for (Map.Entry<Character, Integer> entry : wordCountMap.entrySet()) {\n                countMap.put(entry.getKey(), countMap.getOrDefault(entry.getKey(), 0) + Math.min(countMap.getOrDefault(entry.getKey(), 0), entry.getValue()));\n            }\n        }\n\n        List<String> result = new ArrayList<>();\n        for (Map.Entry<Character, Integer> entry : countMap.entrySet()) {\n            result.add(String.valueOf(entry.getKey()).repeat(entry.getValue()));\n        }\n\n        return result;\n    }\n}",
  "1004": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {8,0,0,1,6,2,9};\n        System.out.println(\"Expected: 3, Actual: \" + maxConsecutiveOnes(nums1));\n\n        int[] nums2 = {0,1,0,1};\n        System.out.println(\"Expected: 3, Actual: \" + maxConsecutiveOnes(nums2));\n\n        int[] nums3 = {1,1,1};\n        System.out.println(\"Expected: 3, Actual: \" + maxConsecutiveOnes(nums3));\n    }\n\n    public static int maxConsecutiveOnes(int[] nums) {\n        int maxOnes = 0;\n        int currOnes = 0;\n        int left = 0;\n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] == 1) {\n                currOnes++;\n            } else {\n                left = right + 1;\n                currOnes = 0;\n            }\n            maxOnes = Math.max(maxOnes, currOnes);\n        }\n        return maxOnes;\n    }\n}",
  "1003": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeValid(\"annabelle\", \"nalbeabel\")); // Expected: true\n        System.out.println(canBeValid(\"bab\", \"aba\")); // Expected: false\n        System.out.println(canBeValid(\"\", \"\")); // Expected: true\n    }\n\n    public static boolean canBeValid(String word1, String word2) {\n        int i = 0, j = 0;\n        while (i < word1.length() && j < word2.length()) {\n            if (word1.charAt(i) == word2.charAt(j)) {\n                i++;\n                j++;\n            } else if (word1.charAt(i) != 'a' || word2.charAt(j) != 'b') {\n                return false;\n            } else {\n                if (i > 0 && word1.charAt(i - 1) == 'a') {\n                    while (j < word2.length() && word2.charAt(j) == 'b') {\n                        j++;\n                    }\n                    if (j >= word2.length()) {\n                        return true;\n                    }\n                } else if (j > 0 && word2.charAt(j - 1) == 'b') {\n                    while (i < word1.length() && word1.charAt(i) == 'a') {\n                        i++;\n                    }\n                    if (i >= word1.length()) {\n                        return true;\n                    }\n                }\n            }\n        }\n        while (j < word2.length()) {\n            if (word2.charAt(j) != 'b') {\n                return false;\n            }\n            j++;\n        }\n        while (i < word1.length()) {\n            if (word1.charAt(i) != 'a') {\n                return false;\n            }\n            i++;\n        }\n        return true;\n    }\n}",
  "1006": "```\npublic class Solution {\n    public int clumsyFactorial(int N) {\n        if (N == 0) return 1;\n        if (N == 1) return 1;\n        \n        long result = 2L * N * (N - 1);\n        N -= 2;\n        \n        while (N > 4) {\n            result *= N--;\n        }\n        \n        return (int)result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.clumsyFactorial(4)); // Output: 24\n        System.out.println(solution.clumsyFactorial(10)); // Output: 1152\n        System.out.println(solution.clumsyFactorial(12)); // Output: 479001600\n    }\n}\n```",
  "1005": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {4, 2, -3};\n        System.out.println(\"Expected: 0, Got: \" + maxEqualFreq(nums1, 1));\n\n        int[] nums2 = {3,-1,0,1};\n        System.out.println(\"Expected: 5, Got: \" + maxEqualFreq(nums2, 3));\n\n        int[] nums3 = [-1,-1,4,3,2];\n        System.out.println(\"Expected: 11, Got: \" + maxEqualFreq(nums3, 5));\n    }\n\n    public static int maxEqualFreq(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < k; i++) {\n            if (nums[i] < 0) {\n                nums[i] = -nums[i];\n            }\n        }\n\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\n        }\n\n        int maxFreq = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() > maxFreq) {\n                maxFreq = entry.getValue();\n            }\n        }\n\n        return maxFreq * maxFreq;\n    }\n}",
  "1007": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minDominoRotations(new int[][]{{0,1},{1,1},{1,1}})); // Expected: 2\n        System.out.println(minDominoRotations(new int[][]{{0,0,0},{0,0,0},{0,0,0}})); // Expected: 3\n        System.out.println(minDominoRotations(new int[][]{{1,2,1},{1,1,1},{1,1,1}})); // Expected: 4\n    }\n\n    public static int minDominoRotations(int[][] dominoes) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] domino : dominoes) {\n            for (int val : domino) {\n                map.put(val, map.getOrDefault(val, 0) + 1);\n            }\n        }\n\n        int res = Integer.MAX_VALUE;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() == dominoes.length) {\n                continue;\n            }\n            int rotations = 0;\n            int[] val = {entry.getKey()};\n            boolean hasBoth = false;\n            for (int i = 1; i < dominoes.length; i++) {\n                if ((dominoes[i - 1][i] == val[0]) && (dominoes[i][i] == val[0])) {\n                    continue;\n                } else if ((dominoes[i - 1][i] == val[0]) || (dominoes[i][i] == val[0])) {\n                    rotations++;\n                } else {\n                    rotations += 2;\n                    hasBoth = true;\n                }\n            }\n\n            res = Math.min(res, hasBoth ? rotations : rotations / 2);\n        }\n        return res;\n    }\n}\n```",
  "1008": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] preorder1 = {3,9,20,null,null,15,7};\n        TreeNode root1 = buildTree(preorder1);\n        printTree(root1);\n\n        int[] preorder2 = {1,null,2};\n        TreeNode root2 = buildTree(preorder2);\n        printTree(root2);\n\n        int[] preorder3 = {5,2,4,null,this/null,null,6,1,3};\n        TreeNode root3 = buildTree(preorder3);\n        printTree(root3);\n    }\n\n    public static TreeNode buildTree(int[] preorder) {\n        if (preorder == null || preorder.length == 0) return null;\n        \n        TreeNode root = new TreeNode(preorder[0]);\n        TreeNode current = root;\n        Stack<TreeNode> stack = new Stack<>();\n        int i = 1;\n\n        while (i < preorder.length) {\n            while ((i < preorder.length) && \n                    (preorder[i] < preorder[0])) {\n                current.right = new TreeNode(preorder[i++]);\n                stack.push(current);\n                current = current.right;\n            }\n            \n            if (!stack.isEmpty()) {\n                current = stack.pop();\n            } else {\n                current = root;\n            }\n\n            while ((i < preorder.length) && \n                    (preorder[i] > preorder[0])) {\n                current.left = new TreeNode(preorder[i++]);\n                current = current.left;\n            }\n        }\n        \n        return root;\n    }\n\n    public static void printTree(TreeNode node) {\n        if (node == null) return;\n        System.out.print(node.val + \" \");\n        printTree(node.left);\n        printTree(node.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n        left = null;\n        right = null;\n    }\n}\n```",
  "1009": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findComplement(5)); // Output: 2\n        System.out.println(findComplement(8)); // Output: 7\n        System.out.println(findComplement(10)); // Output: 1\n    }\n\n    public static int findComplement(int N) {\n        return Integer.parseInt(Integer.toBinaryString(N).replace('0', '1').replace('1', '0'));\n    }\n}",
  "1011": "```\npublic class Main {\n    public static void main(String[] args) {\n        int capacity1 = 6;\n        System.out.println(\"Expected output: \" + canMeetDemand(capacity1, 2));\n        \n        int capacity2 = 10;\n        System.out.println(\"Expected output: \" + canMeetDemand(capacity2, 3));\n\n        int capacity3 = 20;\n        System.out.println(\"Expected output: \" + canMeetDemand(capacity3, 5));\n\n    }\n\n    public static boolean canMeetDemand(int maximumWeight, int numLoads) {\n        int[] weights = {1, 4, 3};\n        Arrays.sort(weights);\n        \n        int i = 0;\n        for (int j = 1; j <= numLoads && i < weights.length; ) {\n            if (weights[i] + (j * maximumWeight / numLoads) >= weights[i + 1]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        return i == weights.length;\n    }\n}",
  "1010": "```\npublic class Main {\n    public static void main(String[] args) {\n        int result1 = numPairsDivisibleBy60(new int[]{30,20,150,100,40});\n        System.out.println(result1); // expected output: 3\n\n        int result2 = numPairsDivisibleBy60(new int[]{60,60,60});\n        System.out.println(result2); // expected output: 3\n\n        int result3 = numPairsDivisibleBy60(new int[]{60,30,20,40});\n        System.out.println(result3); // expected output: 5\n    }\n\n    public static int numPairsDivisibleBy60(int[] time) {\n        int count = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int t : time) {\n            int mod = t % 60;\n            map.put(mod, map.getOrDefault(mod, 0) + 1);\n        }\n        \n        for (int i = 0; i <= 59; i += 60) {\n            if (map.containsKey(i)) {\n                count += map.get(i) * map.getOrDefault(60 - i, 0);\n            }\n        }\n        \n        return count;\n    }\n}\n```",
  "1012": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countNumbersWithRepeatedDigits(2)); // Expected output: 15\n        System.out.println(countNumbersWithRepeatedDigits(5)); // Expected output: 220\n        System.out.println(countNumbersWithRepeatedDigits(10)); // Expected output: 37483\n    }\n\n    public static int countNumbersWithRepeatedDigits(int n) {\n        return process(n, new boolean[n + 1]);\n    }\n\n    public static int process(int n, boolean[] isRepeat) {\n        int res = 0;\n        for (int i = 1; i <= n; ++i) {\n            int cur = i;\n            boolean isRepeatCur = false;\n            int count = 0;\n            while (cur > 0) {\n                int digit = cur % 10;\n                if (digit == 0) break;\n                if (!isRepeat[digit]) {\n                    ++count;\n                    --cur /= 10;\n                } else {\n                    isRepeatCur = true;\n                    ++count;\n                    while (cur > 0 && cur % 10 == digit) {\n                        --cur /= 10;\n                    }\n                    break;\n                }\n            }\n            if (!isRepeatCur) res += 1 << count;\n        }\n        return res;\n    }\n}",
  "1013": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {0,2,5};\n        System.out.println(canPartition(arr1)); // Expected: true\n        \n        int[] arr2 = {0,4,8,6};\n        System.out.println(canPartition(arr2)); // Expected: true\n\n        int[] arr3 = {0,1,2,5};\n        System.out.println(canPartition(arr3)); // Expected: false\n    }\n\n    public static boolean canPartition(int[] nums) {\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n        \n        if (totalSum % 3 != 0) {\n            return false;\n        }\n        \n        int targetSum = totalSum / 3;\n        int currentSum = 0;\n        \n        for (int num : nums) {\n            currentSum += num;\n            \n            if (currentSum == targetSum) {\n                currentSum = 0;\n            } else if (currentSum > targetSum) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n```",
  "1015": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(smallestDivisor(12, 6));\n        System.out.println(smallestDivisor(37, 2));\n        System.out.println(smallestDivisor(1041, 100));\n    }\n\n    public static int smallestDivisor(int num, int k) {\n        for (int i = k; ; i++) {\n            if (i % k == 0 && isPowerOfK(i)) {\n                return i;\n            }\n        }\n    }\n\n    public static boolean isPowerOfK(int n) {\n        while (n > 1) {\n            if (n % k != 0) {\n                return false;\n            }\n            n /= k;\n        }\n        return true;\n    }\n}",
  "1014": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {8, 7, 15};\n        System.out.println(\"Test case 1: \" + bestSightseeingPair(arr1));\n        \n        int[] arr2 = {1, 2, 3, 4, 5};\n        System.out.println(\"Test case 2: \" + bestSightseeingPair(arr2));\n        \n        int[] arr3 = {1, -1, -1, 3, 61};\n        System.out.println(\"Test case 3: \" + bestSightseeingPair(arr3));\n    }\n    \n    public static int bestSightseeingPair(int[] values) {\n        int res = 0;\n        int max_ending_here = 0;\n        \n        for (int i = 0; i < values.length; i++) {\n            max_ending_here = Math.max(max_ending_here, i + values[i]);\n            res = Math.max(res, max_ending_here - values[i]);\n        }\n        \n        return res;\n    }\n}",
  "1016": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeDivided(\"011101\"));//true\n        System.out.println(canBeDivided(\"1\"));//false\n        System.out.println(canBeDivided(\"111\"));//false\n    }\n\n    public static boolean canBeDivided(String s) {\n        for (int i = 0; i < s.length(); i++) {\n            if ((s.charAt(i) == '1' && i % 2 == 0) || (s.charAt(i) == '0' && i % 2 != 0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1017": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input = { { 1 }, { -1 }, { 2 } };\n        for (int i = 0; i < input.length; i++) {\n            System.out.println(convertToBase2(input[i][0]));\n        }\n    }\n\n    public static String convertToBase2(int n) {\n        if (n == 0) return \"0\";\n        StringBuilder sb = new StringBuilder();\n        int sign = ((n >= 0) ? 1 : -1);\n        n = Math.abs(n);\n        while (n > 0) {\n            n -= n & (-n);\n            sb.append((sign > 0) ? '1' : '-');\n            sign = -sign;\n        }\n        return sb.toString();\n    }\n}",
  "1018": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeDividedByFive(new int[]{0,1,1})) ; // Expected: true\n        System.out.println(canBeDividedByFive(new int[]{1,1})) ; // Expected: false\n        System.out.println(canBeDividedByFive(new int[]{0,1,1,0,0,0})) ; // Expected: true\n    }\n\n    public static boolean canBeDividedByFive(int[] nums) {\n        int ones = 0;\n        for (int num : nums) {\n            if ((num & 1) == 1) {\n                ones++;\n            }\n        }\n        return ones % 2 == 0;\n    }\n}\n```",
  "1019": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1:\n        ListNode head1 = new ListNode(1, new ListNode(2, new ListNode(3)));\n        System.out.println(\"Next Greater Node In Linked List for head1: \" + Arrays.toString(solution.nextGreaterNodes(head1)));\n\n        // Test case 2:\n        ListNode head2 = new ListNode(2, new ListNode(1));\n        System.out.println(\"Next Greater Node In Linked List for head2: \" + Arrays.toString(solution.nextGreaterNodes(head2)));\n\n        // Test case 3:\n        ListNode head3 = new ListNode(1);\n        System.out.println(\"Next Greater Node In Linked List for head3: \" + Arrays.toString(solution.nextGreaterNodes(head3)));\n    }\n}\n```",
  "1020": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,0,0},{1,1,1},{0,0,0}};\n        System.out.println(numEnclaves(grid1)); // expected output: 3\n\n        int[][] grid2 = {{1,1,1,1,1,1},{1,1,1,1,1,1},{1,1,1,1,1,1},{1,1,1,1,1,1}};\n        System.out.println(numEnclaves(grid2)); // expected output: 0\n\n        int[][] grid3 = {{0,1},{0,1}};\n        System.out.println(numEnclaves(grid3)); // expected output: 2\n    }\n\n    public static int numEnclaves(int[][] grid) {\n        if (grid.length == 0 || grid[0].length == 0) return 0;\n        boolean[][] visited = new boolean[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1 && !visited[i][j]) {\n                    dfs(grid, visited, i, j);\n                }\n            }\n        }\n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1 && (!visited[i+1][j] || !visited[i-1][j] || !visited[i][j+1] || !visited[i][j-1])) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public static void dfs(int[][] grid, boolean[][] visited, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || visited[i][j] || grid[i][j] == 0) return;\n        visited[i][j] = true;\n        dfs(grid, visited, i-1, j);\n        dfs(grid, visited, i+1, j);\n        dfs(grid, visited, i, j-1);\n        dfs(grid, visited, i, j+1);\n    }\n}\n```",
  "1021": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(removeOutermostParentheses(\"(()())(())\")); // \"()()()\"\n        System.out.println(removeOutermostParentheses(\"(()())(())(()())\")); // \"()()()(())\"\n        System.out.println(removeOutermostParentheses(\"()()()\")); // \"()()\"\n    }\n\n    public static String removeOutermostParentheses(String S) {\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n        for (int i = 0; i < S.length(); i++) {\n            char c = S.charAt(i);\n            if (c == '(' && count++ > 0 || c == ')' && count-- > 0) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
  "1023": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.camelMatch(\"FooBar\", \"FooBar\")); // true\n        System.out.println(solution.camelMatch(\"Foobar\", \"foobar\")); // false\n        System.out.println(solution.camelMatch(\"Foo\", \"F1R2\")); // false\n    }\n}\n\nclass Solution {\n    public boolean camelMatch(String s, String p) {\n        int i = 0;\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                if (!p.startsWith(String.valueOf(c).toLowerCase())) return false;\n                i++;\n            } else {\n                while (i < p.length() && p.charAt(i) != c) i++;\n                if (i == p.length()) return false;\n                i++;\n            }\n        }\n        return p.length() <= i;\n    }\n}",
  "1022": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(0);\n        root1.right = new TreeNode(1);\n        root1.left.left = new TreeNode(0);\n        root1.left.right = new TreeNode(1);\n        root1.right.left = new TreeNode(0);\n        root1.right.right = new TreeNode(1);\n\n        System.out.println(\"Test case 1: \" + sumRootToLeaf(root1)); // Expected output: 25\n\n        TreeNode root2 = new TreeNode(10);\n        root2.left = new TreeNode(5);\n        root2.right = new TreeNode(15);\n        root2.left.left = new TreeNode(3);\n        root2.left.right = new TreeNode(8);\n\n        System.out.println(\"Test case 2: \" + sumRootToLeaf(root2)); // Expected output: 105\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(0);\n\n        System.out.println(\"Test case 3: \" + sumRootToLeaf(root3)); // Expected output: 1\n    }\n\n    public static int sumRootToLeaf(TreeNode root) {\n        if (root == null) return 0;\n        if (root.val == 0) return 0;\n\n        int result = root.val;\n        for (TreeNode node : getLeaves(root)) {\n            result += node.val;\n        }\n        return result;\n    }\n\n    public static List<TreeNode> getLeaves(TreeNode root) {\n        List<TreeNode> leaves = new ArrayList<>();\n        getLeaves(root, leaves);\n        return leaves;\n    }\n\n    private static void getLeaves(TreeNode root, List<TreeNode> leaves) {\n        if (root == null) return;\n\n        if (isLeaf(root)) {\n            leaves.add(root);\n            return;\n        }\n\n        getLeaves(root.left, leaves);\n        getLeaves(root.right, leaves);\n    }\n\n    public static boolean isLeaf(TreeNode node) {\n        return node.left == null && node.right == null;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "1025": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canIWin(2, 7)); // true\n        System.out.println(canIWin(3, 9)); // false\n        System.out.println(canIwin(4, 15)); // true\n    }\n\n    public static boolean canIWin(int n, int max) {\n        int[] divisors = new int[n + 1];\n        for (int i = 2; i <= n; i++) {\n            for (int j = i; j <= n; j += i) {\n                divisors[j]++;\n            }\n        }\n\n        boolean[][] dp = new boolean[1 << n][n + 1];\n        for (int i = 0; i < (1 << n); i++) {\n            for (int j = 0; j <= n; j++) {\n                if (((i >> j) & 1) == 0) {\n                    dp[i][j] = true;\n                } else {\n                    for (int k = max; k > 0; k--) {\n                        if ((divisors[k] > 0) && (!dp[i ^ (1 << j)][k])) {\n                            dp[i][j] = false;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return dp[(1 << n) - 1][n];\n    }\n}",
  "1024": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] clips = new int[][]{{0, 2}, {4, 8}, {10, 12}};\n        System.out.println(videoStitching(5, clips));\n        \n        clips = new int[][]{{0, 1}, {6, 8}, {12, 14}};\n        System.out.println(videoStitching(5, clips));\n        \n        clips = new int[][]{{0, 4}, {2, 8}};\n        System.out.println(videoStitching(5, clips));\n    }\n\n    public static int videoStitching(int totalFrames, int[][] clips) {\n        int[][] dp = new int[totalFrames][21];\n        int maxReachableIndex = 0;\n        \n        for (int i = 0; i < totalFrames; i++) {\n            for (int j = 0; j <= maxReachableIndex; j++) {\n                if (i == 0) {\n                    dp[i][j] = 1;\n                } else if (j >= clips[i][0] && j <= clips[i][1]) {\n                    dp[i][j] = i > 0 ? Math.max(dp[i-1][Math.min(clips[i][1], j)], dp[i-1][Math.max(clips[i][0], j)]) : 1;\n                } else {\n                    dp[i][j] = 0;\n                }\n            }\n            maxReachableIndex = 0;\n            for (int j = 0; j <= 20; j++) {\n                if (dp[i][j] == 1) {\n                    maxReachableIndex = Math.max(maxReachableIndex, j);\n                }\n            }\n        }\n        \n        int maxStitchedFrames = 0;\n        for (int i = 0; i < totalFrames; i++) {\n            for (int j = 0; j <= maxReachableIndex; j++) {\n                if (i > 0 && dp[i][j] == 1) {\n                    maxStitchedFrames = i;\n                }\n            }\n        }\n        \n        return maxStitchedFrames + 1;\n    }\n}\n```",
  "1027": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestArithSeqLength(new int[]{3, 6, 9, 12}) == 4);\n        System.out.println(longestArithSeqLength(new int[]{9, 4, 7, 2, 10}) == 3);\n        System.out.println(longestArithSeqLength(new int[]{20, 1, 15}) == 6);\n    }\n\n    public static int longestArithSeqLength(int[] A) {\n        // Your code here\n    }\n}\n```",
  "1026": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(8);\n        root1.left = new TreeNode(3);\n        root1.right = new TreeNode(2);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(6);\n        root1.right.left = new TreeNode(1);\n        root1.right.right = new TreeNode(5);\n\n        System.out.println(\"Maximum difference in tree 1: \" + maxAncestorDiff(root1));\n\n        TreeNode root2 = new TreeNode(1);\n        root2.right = new TreeNode(6);\n        root2.right.left = new TreeNode(0);\n        root2.right.right = new TreeNode(4);\n        root2.right.left.left = new TreeNode(2);\n\n        System.out.println(\"Maximum difference in tree 2: \" + maxAncestorDiff(root2));\n\n        TreeNode root3 = null;\n\n        System.out.println(\"Maximum difference in tree 3: \" + maxAncestorDiff(root3));\n    }\n\n    public static int maxAncestorDiff(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int ans = Math.max(Math.abs(root.val - Integer.MAX_VALUE), Math.abs(root.val - Integer.MIN_VALUE));\n        ans = Math.max(ans, maxAncestorDiff(root.left));\n        ans = Math.max(ans, maxAncestorDiff(root.right));\n        return ans;\n    }\n\n    public static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode(int x) { val = x; }\n    }\n}\n```",
  "1029": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] costs = {\n                {10, 20},\n                {30, 40},\n                {50, 100}\n        };\n        System.out.println(minFlights(costs));\n        \n        costs = new int[][]{\n            {10, 60},\n            {70, 80},\n            {130, 90},\n            {160, 110}\n        };\n        System.out.println(minFlights(costs));\n        \n        costs = new int[][]{\n            {5, 15},\n            [8, 14],\n            [12, 30]\n        };\n        System.out.println(minFlights(costs));\n    }\n\n    public static int minFlights(int[][] costs) {\n        Arrays.sort(costs, (a, b) -> a[1] - b[1]);\n        int totalCost = 0;\n        for (int i = 0; i < costs.length / 2; i++) {\n            totalCost += costs[i][1];\n        }\n        return totalCost;\n    }\n}\n```",
  "1028": "```\nclass Solution {\n    public TreeNode recoverFromPreorder(String s) {\n        if (s == null || s.isEmpty()) return null;\n        \n        String[] parts = s.split(\" \");\n        return reconstructTree(parts, 0);\n    }\n\n    private TreeNode reconstructTree(String[] parts, int index) {\n        if (index >= parts.length) return null;\n\n        StringBuilder sb = new StringBuilder();\n        while (index < parts.length && !parts[index].equals(\"\")) {\n            sb.append(parts[index]);\n            if (index + 1 < parts.length) {\n                if (parts[index + 1].length() == 2) break;\n                sb.append(\"-\");\n            }\n            index++;\n        }\n\n        int val = Integer.parseInt(sb.toString());\n        TreeNode node = new TreeNode(val);\n\n        if (index >= parts.length || !parts[index].equals(\"\")) return node;\n\n        String[] leftParts = new String[0];\n        while (index < parts.length && !parts[index].equals(\"\")) {\n            String[] oldLeftParts = leftParts;\n            leftParts = new String[oldLeftParts.length + 1];\n            System.arraycopy(oldLeftParts, 0, leftParts, 0, oldLeftParts.length);\n            leftParts[leftParts.length - 1] = parts[index];\n            index++;\n        }\n\n        node.left = reconstructTree(leftParts, 0);\n\n        if (index >= parts.length) return node;\n\n        String[] rightParts = new String[0];\n        while (index < parts.length && !parts[index].equals(\"\")) {\n            String[] oldRightParts = rightParts;\n            rightParts = new String[oldRightParts.length + 1];\n            System.arraycopy(oldRightParts, 0, rightParts, 0, oldRightParts.length);\n            rightParts[rightParts.length - 1] = parts[index];\n            index++;\n        }\n\n        node.right = reconstructTree(rightParts, 0);\n\n        return node;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(\"Test Case 1:\");\n        TreeNode root1 = solution.recoverFromPreorder(\"1-2--3--4-5--6--7\");\n        printTree(root1);\n        System.out.println(\"\\nTest Case 2:\");\n        TreeNode root2 = solution.recoverFromPreorder(\"1-2--3---4-5--6---7\");\n        printTree(root2);\n        System.out.println(\"\\nTest Case 3:\");\n        TreeNode root3 = solution.recoverFromPreorder(\"1-2--3---4----5--6---7\");\n        printTree(root3);\n    }\n\n    public static void printTree(TreeNode node) {\n        if (node == null) return;\n        System.out.print(node.val + \" \");\n        printTree(node.left);\n        printTree(node.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n        left = null;\n        right = null;\n    }\n}\n```",
  "1030": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix = {{9,16,6},{3,2,5},{10,15,7}};\n        int R = 2;\n        int C = 4;\n        distanceOrder(matrix, R, C);\n        \n        matrix = new int[][]{{1,2,3},{8,9,4},{7,6,5}};\n        R = 3;\n        C = 3;\n        distanceOrder(matrix, R, C);\n        \n        matrix = new int[][]{{1,3},{5,4}};\n        R = 2;\n        C = 2;\n        distanceOrder(matrix, R, C);\n    }\n\n    public static void distanceOrder(int[][] matrix, int R, int C) {\n        List<int[]> list = new ArrayList<>();\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                int x1 = i;\n                int y1 = j;\n                int res = manhattanDistance(i, j, R, C);\n                list.add(new int[]{x1, y1, res});\n            }\n        }\n        Collections.sort(list, (a, b) -> a[2] - b[2]);\n        \n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                System.out.print(matrix[list.get(i*C+j)[0]][list.get(i*C+j)[1]] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static int manhattanDistance(int x, int y, int R, int C) {\n        return Math.abs(x - 0) + Math.abs(y - 0);\n    }\n}",
  "1031": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] test1 = {{1,8,1,0,2,5},4,6};\n        System.out.println(maxSumTwoNoOverlap(test1[0], test1[1], test1[2]));\n\n        int[][] test2 = {{3,8,1,0,2,5,4,7,1,3}, 3, 10 };\n        System.out.println(maxSumTwoNoOverlap(test2[0], test2[1], test2[2]));\n\n        int[][] test3 = {{5,6,1,9,5,7,1,5,5,8,3,2,9,4,5}, 2, 4};\n        System.out.println(maxSumTwoNoOverlap(test3[0], test3[1], test3[2]));\n    }\n\n    public static int maxSumTwoNoOverlap(int[] nums, int left, int right) {\n        int total = 0;\n        int sumLeft = 0;\n        for (int i = 0; i < left; i++) {\n            if (nums[i] > 0) {\n                sumLeft += nums[i];\n            }\n        }\n        for (int i = left; i <= right; i++) {\n            total += nums[i];\n            if (total > sumLeft) {\n                sumLeft = total;\n            }\n        }\n        int total2 = 0;\n        int sumRight = 0;\n        for (int i = 0; i < left; i++) {\n            total2 += nums[i];\n            if (total2 > sumRight) {\n                sumRight = total2;\n            }\n        }\n        for (int i = right + 1; i <= nums.length - 1; i++) {\n            total2 += nums[i];\n            if (total2 > sumRight) {\n                sumRight = total2;\n            }\n        }\n        return Math.max(sumLeft, sumRight);\n    }\n}\n```",
  "1032": "```\npublic class Main {\n    public static void main(String[] args) {\n        CharacterStream stream = new CharacterStream();\n        \n        // Test Case 1: Single character\n        stream.push('a');\n        System.out.println(stream.characterStreamToString());\n        System.out.println(\"Expected output: a\");\n        \n        // Test Case 2: Multiple characters\n        for (char c : \"abc\".toCharArray()) {\n            stream.push(c);\n        }\n        System.out.println(stream.characterStreamToString());\n        System.out.println(\"Expected output: abc\");\n        \n        // Test Case 3: Empty string and single character\n        stream.reset();\n        stream.push('x');\n        System.out.println(stream.characterStreamToString());\n        System.out.println(\"Expected output: x\");\n    }\n}\n\nclass CharacterStream {\n    private TrieNode root;\n    private StringBuilder sb;\n\n    public CharacterStream() {\n        this.root = new TrieNode();\n        this.sb = new StringBuilder();\n    }\n\n    public void push(char c) {\n        TrieNode current = root;\n        for (TrieNode node : current.children.values()) {\n            if (node.c == c) {\n                current = node;\n                break;\n            }\n        }\n        if (!current.children.containsKey(c)) {\n            current.children.put(c, new TrieNode());\n            current = current.children.get(c);\n        }\n        sb.append(c);\n    }\n\n    public String characterStreamToString() {\n        return sb.toString();\n    }\n\n    public void reset() {\n        sb.setLength(0);\n        root = new TrieNode();\n    }\n}\n\nclass TrieNode {\n    char c;\n    Map<Character, TrieNode> children;\n\n    public TrieNode() {\n        this.c = '\\0';\n        this.children = new HashMap<>();\n    }\n}\n```",
  "1033": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(movingStonesUntilConsecutive(new int[]{5,1,2,4,3})); // 7\n        System.out.println(movingStonesUntilConsecutive(new int[]{1,1,1})); // 0\n        System.out.println(movingStonesUntilConsecutive(new int[]{1,3,5,2,4})); // 6\n    }\n\n    public static int movingStonesUntilConsecutive(int[] stones) {\n        Arrays.sort(stones);\n        int moves = 0;\n        for (int i = 1; i < stones.length; i++) {\n            if (stones[i] - stones[i-1] > 1) {\n                moves += Math.min(stones[i-1] + 1 - stones[i], stones[i] - stones[i-1] - 1);\n            }\n        }\n        return moves;\n    }\n}",
  "1034": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] image = {{0,1},{1,1}};\n        int[][] v = {{\"FL\",\"HI\"}};\n        solve(image,v);\n        \n        image = new int[][]{{0,1},{1,0}};\n        v = new int[][]{{\"FL\",\"FL\"},{\"FL\",\"FL\"}};\n        solve(image,v);\n        \n        image = new int[][]{{0,1},{1,1},{1,1}};\n        v = new int[][]{{\"HI\",\"MI\"},{\"MI\",\"OK\"},{\"OK\",\"OK\"}};\n        solve(image,v);\n    }\n\n    public static void solve(int[][] image, int[][] v) {\n        // TO DO\n    }\n}\n```",
  "1035": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] p1 = {{1,3},{5,9}};\n        System.out.println(\"Test case 1: \" + findMinArrowShots(p1));\n        \n        int[][] p2 = {{2,3},{5,7},{17,19},{20,25}};\n        System.out.println(\"Test case 2: \" + findMinArrowShots(p2));\n        \n        int[][] p3 = {{0,2},{5,10},{13,23},{24,25}};\n        System.out.println(\"Test case 3: \" + findMinArrowShots(p3));\n    }\n\n    public static int findMinArrowShots(int[][] points) {\n        if (points.length == 0) {\n            return 0;\n        }\n        \n        Arrays.sort(points, (a, b) -> a[1] - b[1]);\n        \n        int minArrows = 1;\n        int end = points[0][1];\n        \n        for (int i = 1; i < points.length; i++) {\n            if (points[i][0] > end) {\n                minArrows++;\n                end = points[i][1];\n            }\n        }\n        \n        return minArrows;\n    }\n}\n```",
  "1037": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeBoomerang(new int[][]{{1, 2}, {5, 10}, {-99, -1}})); // Test case 1: True\n        System.out.println(canBeBoomerang(new int[][]{{0, 4},{-1, 2},{3, 1}})); // Test case 2: False\n        System.out.println(canBeBoomerang(new int[][]{ {1, 1}, {5, 0}, {-2, -3} })); // Test case 3: True\n    }\n\n    public static boolean canBeBoomerang(int[][] points) {\n        for (int i = 0; i < points.length - 2; i++) {\n            int x1 = points[i][0], y1 = points[i][1];\n            int x2 = points[i + 1][0], y2 = points[i + 1][1];\n            int x3 = points[i + 2][0], y3 = points[i + 2][1];\n\n            if ((x2 - x1) * (y3 - y1) == (x3 - x1) * (y2 - y1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "1036": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] maze = {{0,0,1,0,0},{0,0,1,0,0},{0,0,0,0,0},{0,0,1,0,0}};\n        System.out.println(numOfSteps(maze));\n        \n        int[][] maze2 = {{0,0,0},{1,1,0},{0,0,0}};\n        System.out.println(numOfSteps(maze2));\n        \n        int[][] maze3 = {{0,0},{0,0}};\n        System.out.println(numOfSteps(maze3));\n    }\n\n    public static int numOfSteps(int[][] maze) {\n        int rows = maze.length;\n        if(rows == 0) return 0;\n\n        int cols = maze[0].length;\n        if(cols == 0) return 0;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if(maze[i][j] == 1) {\n                    maze[i][j] = -1;\n                }\n            }\n        }\n\n        int startRow = -1;\n        int startCol = -1;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if(maze[i][j] == 0) {\n                    startRow = i;\n                    startCol = j;\n                    break;\n                }\n            }\n            if(startRow != -1) break;\n        }\n\n        int steps = dfs(maze, startRow, startCol);\n        return steps;\n    }\n\n    public static int dfs(int[][] maze, int row, int col) {\n        int rows = maze.length;\n        int cols = maze[0].length;\n\n        if(row < 0 || row >= rows || col < 0 || col >= cols || maze[row][col] != 0) return 0;\n\n        if(row == rows - 1 && col == cols - 1) return 1;\n\n        maze[row][col] = -1;\n        int leftSteps = dfs(maze, row - 1, col);\n        int rightSteps = dfs(maze, row + 1, col);\n        int upSteps = dfs(maze, row, col - 1);\n        int downSteps = dfs(maze, row, col + 1);\n\n        return Math.max(leftSteps, Math.max(rightSteps, Math.max(upSteps, downSteps)));\n    }\n}",
  "1038": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test case 1:\n        TreeNode root = new TreeNode(4);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(7);\n        root.left.left = new TreeNode(1);\n        root.left.right = new TreeNode(3);\n        greaterSumBST(root);\n        System.out.println();\n\n        // Test case 2:\n        root = null;\n        greaterSumBST(root);\n        System.out.println();\n\n        // Test case 3:\n        root = new TreeNode(5);\n        root.right = new TreeNode(4);\n        root.right.left = new TreeNode(3);\n        root.right.right = new TreeNode(2);\n        root.right.right.left = new TreeNode(1);\n        greaterSumBST(root);\n        System.out.println();\n    }\n\n    public static void greaterSumBST(TreeNode root) {\n        if (root == null) return;\n        \n        // Traverse the tree\n        root.val += dfs(root.left, 0) + dfs(root.right, root.val);\n        \n        // Traverse the left subtree\n        greaterSumBST(root.left);\n        \n        // Traverse the right subtree\n        greaterSumBST(root.right);\n    }\n\n    public static int dfs(TreeNode node, int sum) {\n        if (node == null) return 0;\n        if (node.val > sum) return node.val + dfs(node.left, node.val) + dfs(node.right, node.val);\n        else return dfs(node.left, sum) + dfs(node.right, sum);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1039": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumScoreTriangulation(new int[]{1,2,3,4,5})); // Output: 9\n        System.out.println(minimumScoreTriangulation(new int[]{2,8,7,6,5,4,3,1})); // Output: 16\n        System.out.println(minimumScoreTriangulation(new int[]{0,1,1,1})); // Output: 1\n    }\n\n    public static int minimumScoreTriangulation(int[] nums) {\n        int n = nums.length;\n        if(n < 4) return 0;\n\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 0;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = i + 1; j < n; j++) {\n                if(i+1==j) dp[i][j]=0;\n                else{\n                    int min = Integer.MAX_VALUE;\n                    for (int k = i+1; k < j; k++) {\n                        min = Math.min(min, nums[k-1]*(nums[i]+nums[j])-dp[i][k-1]-dp[k][j]);\n                    }\n                    dp[i][j]=min;\n                }\n            }\n        }\n\n        return dp[0][n-1];\n    }\n}",
  "1040": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] stones1 = {5,1,3};\n        System.out.println(\"Stones: \" + Arrays.toString(stones1));\n        System.out.println(\"Result: \" + moveStones(stones1));\n\n        int[] stones2 = {6, 2, 1, 4};\n        System.out.println(\"Stones: \" + Arrays.toString(stones2));\n        System.out.println(\"Result: \" + moveStones(stones2));\n\n        int[] stones3 = {25,10,5,7};\n        System.out.println(\"Stones: \" + Arrays.toString(stones3));\n        System.out.println(\"Result: \" + moveStones(stones3));\n    }\n\n    public static List<Integer> moveStones(int[] stones) {\n        // Your implementation here\n    }\n}",
  "1041": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canPlaceFlowers(new String[]{\"...\", \"..#\", \"...\"}, true)); // Expected: True\n        System.out.println(canPlaceFlowers(new String[]{\"#\",\"#\",\".\"}, false)); // Expected: False\n        System.out.println(canPlaceFlowers(new String[]{\".\",\".\",\"#\"}, true)); // Expected: True\n    }\n\n    public static boolean canPlaceFlowers(String[] flowers, boolean predict) {\n        for (int i = 0; i < flowers.length; i++) {\n            if ((flowers[i].equals(\".\") || flowers[i].equals(\"#\")) && (i == 0 || flowers[i - 1] != \"#\") && (i == flowers.length - 1 || flowers[i + 1] != \"#\")) {\n                if (!predict) {\n                    flowers[i] = \"#\";\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "1042": "```\npublic class Solution {\n    public int[] garden(String path, int n) {\n        char[] flowers = path.toCharArray();\n        int[] plants = new int[n];\n        \n        for (int i = 0; i < flowers.length; i++) {\n            plants[i] = flowers[i] - 'A';\n        }\n        \n        return plants;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String path1 = \"AAAB\";\n        int n1 = 3;\n        int[] result1 = solution.garden(path1, n1);\n        System.out.println(\"Test Case 1: \");\n        for (int i : result1) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        String path2 = \"B\";\n        int n2 = 1;\n        int[] result2 = solution.garden(path2, n2);\n        System.out.println(\"Test Case 2: \");\n        for (int i : result2) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n\n        String path3 = \"AABB\";\n        int n3 = 4;\n        int[] result3 = solution.garden(path3, n3);\n        System.out.println(\"Test Case 3: \");\n        for (int i : result3) {\n            System.out.print(i + \" \");\n        }\n    }\n}\n```",
  "1043": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + maxSumAfterPartition(new int[]{1, 15, 7}) + \" expected: 23\");\n        System.out.println(\"Test case 2: \" + maxSumAfterPartition(new int[]{5, 6, 8, 7}) + \" expected: 24\");\n        System.out.println(\"Test case 3: \" + maxSumAfterPartition(new int[]{10, 20, 30, 40}) + \" expected: 60\");\n\n    }\n\n    public static int maxSumAfterPartition(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        if (nums.length == 1) {\n            return nums[0];\n        }\n        if (nums.length % 2 == 0) {\n            int mid = nums.length / 2;\n            int sum1 = maxSumAfterPartition(Arrays.copyOfRange(nums, 0, mid));\n            int sum2 = maxSumAfterPartition(Arrays.copyOfRange(nums, mid, nums.length));\n            return Math.max(sum1, sum2);\n        } else {\n            int mid = nums.length / 2;\n            int sum1 = maxSumAfterPartition(Arrays.copyOfRange(nums, 0, mid + 1));\n            int sum2 = maxSumAfterPartition(Arrays.copyOfRange(nums, mid + 1, nums.length));\n            return Math.max(sum1, sum2);\n        }\n    }\n}\n```",
  "1044": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestDuplicateSubstring(\"banana\"));\n        System.out.println(longestDuplicateSubstring(\"abcd\"));\n        System.out.println(longestDuplicateSubstring(\"yzzzy\"));\n    }\n\n    public static String longestDuplicateSubstring(String s) {\n        // your code here\n    }\n}\n```",
  "1045": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1\n        String[] purchase1 = {\"John\", \"johnny\"};\n        String[] people1 = {\"John\", \"Johnny\", \"Tom\", \"Jerry\"};\n        List<String> result1 = Arrays.asList(solution.customerWhoBoughtAllProducts(people1, Arrays.asList(purchase1)));\n        System.out.println(result1); // Expected: [John]\n\n        // Test Case 2\n        String[] purchase2 = {};\n        String[] people2 = {\"Tom\", \"Jerry\"};\n        List<String> result2 = Arrays.asList(solution.customerWhoBoughtAllProducts(people2, Arrays.asList(purchase2)));\n        System.out.println(result2); // Expected: []\n\n        // Test Case 3\n        String[] purchase3 = {\"Tom\", \"John\", \"Johnny\", \"Jerry\"};\n        String[] people3 = {\"John\", \"Tom\", \"Jerry\", \"Johnny\", \"Eve\", \"Bob\", \"Alice\"};\n        List<String> result3 = Arrays.asList(solution.customerWhoBoughtAllProducts(people3, Arrays.asList(purchase3)));\n        System.out.println(result3); // Expected: [John, Tom]\n    }\n}\n\nclass Solution {\n    public List<String> customerWhoBoughtAllProducts(String[] people, List<String[]> purchases) {\n        Map<String, Integer> productCount = new HashMap<>();\n        \n        for (String[] purchase : purchases) {\n            for (String product : purchase) {\n                productCount.put(product, productCount.getOrDefault(product, 0) + 1);\n            }\n        }\n        \n        List<String> result = new ArrayList<>();\n        for (String person : people) {\n            boolean boughtAllProducts = true;\n            for (Map.Entry<String, Integer> entry : productCount.entrySet()) {\n                if (entry.getValue() > 0 && !Arrays.stream(purchases.get(people.indexOf(person))).anyMatch(p -> p.equals(entry.getKey()))) {\n                    boughtAllProducts = false;\n                    break;\n                }\n            }\n            if (boughtAllProducts) {\n                result.add(person);\n            }\n        }\n        \n        return result;\n    }\n}\n```",
  "1046": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] stone1 = {2,7,4,2,8};\n        System.out.println(lastStoneWeight(stone1));\n        \n        int[] stone2 = {31,26,33,17,28};\n        System.out.println(lastStoneWeight(stone2));\n        \n        int[] stone3 = {1,5};\n        System.out.println(lastStoneWeight(stone3));\n    }\n\n    public static int lastStoneWeight(int[] stones) {\n        while (stones.length > 1) {\n            Arrays.sort(stones);\n            int y = stones[stones.length - 1];\n            int x = stones[stones.length - 2];\n            if (x < y) {\n                stones = new int[]{y - x};\n            } else {\n                stones = new int[]{0};\n            }\n        }\n        return stones[0];\n    }\n}",
  "1047": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removeDuplicates(\"abcdef\")); // expected: \"abcdef\"\n        System.out.println(removeDuplicates(\"azxxzy\")); // expected: \"azy\"\n        System.out.println(removeDuplicates(\"y1z2\"); // expected: \"y1z2\"\n    }\n\n    public static String removeDuplicates(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (i > 0 && s.charAt(i) == s.charAt(i - 1)) {\n                continue;\n            }\n            sb.append(s.charAt(i));\n        }\n        return sb.toString();\n    }\n}",
  "1049": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(lastStoneWeightII(new int[]{2,7,4,1,8,1})); // Test case 1\n        System.out.println(lastStoneWeightII(new int[]{1,5})); // Test case 2\n        System.out.println(lastStoneWeightII(new int[]{31})); // Test case 3\n    }\n\n    public static int lastStoneWeightII(int[] stones) {\n        int n = stones.length;\n        if (n < 2) return 0;\n\n        int max1 = 0, max2 = 0;\n        for (int i : stones) {\n            if (i > max1) {\n                max2 = max1; max1 = i;\n            } else if (i > max2) {\n                max2 = i;\n            }\n        }\n\n        int totalWeight = 0;\n        for (int i : stones) {\n            if (i != max1 && i != max2) totalWeight += i;\n        }\n\n        return Math.max(max1, max2) + totalWeight;\n    }\n}\n```",
  "1048": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestStringChain(new String[]{\"abc\", \"bcd\", \"bca\", \"bcc\"})); // expected output: 4\n        System.out.println(longestStringChain(new String[]{\"ksxw\", \"kssx\", \"kywy\", \"kwws\"})); // expected output: 3\n        System.out.println(longestStringChain(new String[]{\"a\", \"aa\", \"aaa\", \"aaaa\"})); // expected output: 2\n    }\n\n    public static int longestStringChain(String[] words) {\n        if (words == null || words.length == 0) return 0;\n\n        Arrays.sort(words, (a, b) -> a.compareTo(b));\n\n        int maxLength = 1;\n        int currentLength = 1;\n\n        for (int i = 1; i < words.length; i++) {\n            String prevWord = words[i - 1];\n            String currWord = words[i];\n\n            if (isChainable(prevWord, currWord)) {\n                currentLength++;\n            } else {\n                maxLength = Math.max(maxLength, currentLength);\n                currentLength = 1;\n            }\n        }\n\n        return Math.max(maxLength, currentLength);\n    }\n\n    public static boolean isChainable(String word1, String word2) {\n        if (Math.abs(word1.length() - word2.length()) > 1) return false;\n\n        for (int i = 0; i < Math.min(word1.length(), word2.length()); i++) {\n            if (word1.charAt(i) != word2.charAt(i)) {\n                if (word1.length() == word2.length()) return false;\n                else if (word1.length() > word2.length()) {\n                    if (i >= word2.length()) return true;\n                    else if (word1.charAt(i) != word2.charAt(word2.length() - 1)) return false;\n                } else {\n                    if (i >= word1.length()) return true;\n                    else if (word1.charAt(word1.length() - 1) != word2.charAt(i)) return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}\n```",
  "1051": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] cases = {\n                {5, 1, 2, 3, 4},\n                {6, 9, 7, 8, 5},\n                {3, 12, 1, 22}\n        };\n\n        for (int[] case_ : cases) {\n            System.out.println(\"Input: \" + Arrays.toString(case_));\n            System.out.println(\"Output: \" + heightChecker(case_));\n            System.out.println();\n        }\n    }\n\n    public static int heightChecker(int[][] students) {\n        int[] sortedStudents = new int[students.length];\n        for (int i = 0; i < students.length; i++) {\n            sortedStudents[i] = students[i][1]; // Store the heights\n        }\n        Arrays.sort(sortedStudents);\n\n        int count = 0;\n        for (int i = 0; i < students.length; i++) {\n            if (students[i][1] != sortedStudents[i]) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n}",
  "1050": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Solution().countCooperations(new String[][]{\n                {\"Joseph Gordon-Levitt\", \"James Gunn\"},\n                {\"Robert Downey Jr.\", \"James Gunn\"},\n                {\"Edward Norton\", \"James Gunn\"},\n                {\"Jessica Alba\", \"Gail Singer\"},\n                {\"Benicio del Toro\", \"James Gunn\"}}));\n        System.out.println(new Solution().countCooperations(new String[][]{\n                {\"Actor1\", \"Director1\"},\n                {\"Actor2\", \"Director3\"},\n                {\"Actor1\", \"Director2\"},\n                {\"Actor2\", \"Director3\"},\n                {\"Actor3\", \"Director2\"},\n                {\"Actor1\", \"Director1\"}}));\n        System.out.println(new Solution().countCooperations(new String[][]{\n                {\"John Smith\", \"Jane Doe\"},\n                {\"John Smith\", \"John Doe\"},\n                {\"Bob Johnson\", \"Jane Doe\"}}));\n    }\n}\n\nclass Solution {\n    public int countCooperations(String[][] cooperations) {\n        Map<String, Integer> actorMap = new HashMap<>();\n        for (String[] cooperation : cooperations) {\n            String actor = cooperation[0];\n            String director = cooperation[1];\n            actorMap.putIfAbsent(actor, 0);\n            actorMap.put(actor, actorMap.get(actor) + 1);\n        }\n        int count = 0;\n        for (int i : actorMap.values()) {\n            if (i >= 3) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
  "1052": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] ratings = {1, 4, 2, 3};\n        System.out.println(minStickers(ratings));\n        \n        int[] ratings2 = {5, 6};\n        System.out.println(minStickers(ratings2));\n\n        int[] ratings3 = {0, 1};\n        System.out.println(minStickers(ratings3));\n    }\n\n    public static int minStickers(int[] ratings) {\n        // Your code here\n    }\n}",
  "1053": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(previousPermuation(new int[]{3,2,1}))); // [3,2,1]\n        System.out.println(Arrays.toString(previousPermuation(new int[]{1,2,3}))); // [3,2,1]\n        System.out.println(Arrays.toString(previousPermuation(new int[]{4,4,3,2,1}))); // [4,4,3,2,1]\n    }\n\n    public static int[] previousPermuation(int[] nums) {\n        for (int i = nums.length - 1; i > 0; i--) {\n            if (nums[i-1] < nums[i]) {\n                for (int j = nums.length - 1; j > i; j--) {\n                    if (nums[j] < nums[i-1]) {\n                        int temp = nums[i-1];\n                        nums[i-1] = nums[j];\n                        nums[j] = temp;\n                        return nums;\n                    }\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n```",
  "1054": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \");\n        int[] barcodes = {1, 1, 2, 2, 3, 3};\n        int minimumDistance = new Solution().reorganizeBarCodes(barcodes);\n        System.out.println(minimumDistance);\n\n        System.out.println(\"\\nTest Case 2: \");\n        int[] barcodes2 = {1, 1, 1, 2, 2, 2};\n        int minimumDistance2 = new Solution().reorganizeBarCodes(barcodes2);\n        System.out.println(minimumDistance2);\n\n        System.out.println(\"\\nTest Case 3: \");\n        int[] barcodes3 = {a, a, b, b, c, d};\n        int minimumDistance3 = new Solution().reorganizeBarCodes(barcodes3);\n        System.out.println(minimumDistance3);\n    }\n}\n```",
  "1055": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(shortestWayToFormString(\"a\", \"abca\"));//1\n        System.out.println(shortestWayToFormString(\"abc\", \"abccba\"));//2\n        System.out.println(shortestWayToFormString(\"wink\", \"woooink\"));//3\n    }\n\n    public static int shortestWayToFormString(String word1, String word2) {\n        // Your code here\n    }\n}",
  "1056": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(2020, 20)); // Expected output: true\n        System.out.println(canBeEqual(1234, 12)); // Expected output: false\n        System.out.println(canBeEqual(10, 1)); // Expected output: false\n    }\n\n    public static boolean canBeEqual(int n, int reg) {\n        String strN = Integer.toString(n);\n        String strReg = Integer.toString(reg);\n\n        while (strN.length() > strReg.length()) {\n            if (!isConfusing(strN)) {\n                return false;\n            }\n            strN = removeLastDigit(strN);\n        }\n\n        while (strN.length() < strReg.length()) {\n            if (!isConfusing(strReg)) {\n                return false;\n            }\n            reg /= 10;\n        }\n\n        return isConfusing(strN) && strN.equals(Integer.toString(reg));\n    }\n\n    public static boolean isConfusing(String s) {\n        for (int i = 0; i < s.length() - 1; i++) {\n            if ((s.charAt(i) - '0') * 2 + (s.charAt(i + 1) - '0') >= 10) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static String removeLastDigit(String s) {\n        return s.substring(0, s.length() - 1);\n    }\n}",
  "1058": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimizeRoundingErrorToMeetTarget(new int[]{1, 2, 5}, 6));\n        \n        System.out.println(minimizeRoundingErrorToMeetTarget(new int[]{100, 200, 300}, 350));\n        \n        System.out.println(minimizeRoundingErrorToMeetTarget(new int[]{3, 4, 10}, 7));\n    }\n\n    public static double minimizeRoundingErrorToMeetTarget(int[] nums, int target) {\n        // Your code here\n    }\n}\n```",
  "1057": "```\npublic class Solution {\n    public int[] assignBikes(int[][] workers, int[][] bikes) {\n        // Your code here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[][] workers1 = {{0,1},{2,2},{3,3}};\n        int[][] bikes1 = {{1,1},{4,3},{5,2}};\n        int[] result1 = solution.assignBikes(workers1, bikes1);\n        System.out.println(\"Test case 1: \" + Arrays.toString(result1));\n        \n        // Test case 2\n        int[][] workers2 = {{0,10},{2,5},{4,3}};\n        int[][] bikes2 = {{0,5},{6,8},{7,9}};\n        int[] result2 = solution.assignBikes(workers2, bikes2);\n        System.out.println(\"Test case 2: \" + Arrays.toString(result2));\n        \n        // Test case 3\n        int[][] workers3 = {{1,1},{4,5},{6,6}};\n        int[][] bikes3 = {{0,4},{3,3},{5,2}};\n        int[] result3 = solution.assignBikes(workers3, bikes3);\n        System.out.println(\"Test case 3: \" + Arrays.toString(result3));\n    }\n}\n```",
  "1060": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1};\n        System.out.println(\"Missing element in \" + Arrays.toString(nums1) + \": \" + missingElement(nums1));\n        \n        int[] nums2 = [1, 2, 3];\n        System.out.println(\"Missing element in \" + Arrays.toString(nums2) + \": \" + missingElement(nums2));\n        \n        int[] nums3 = {1, 2, 4};\n        System.out.println(\"Missing element in \" + Arrays.toString(nums3) + \": \" + missingElement(nums3));\n    }\n\n    public static int missingElement(int[] nums) {\n        int start = 0;\n        int end = nums.length - 1;\n\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == mid) {\n                start = mid + 1;\n            } else {\n                end = mid - 1;\n            }\n        }\n\n        return start;\n    }\n}\n```",
  "1059": "```\npublic class Main {\n    public static void main(String[] args) {\n        Graph graph1 = new Graph(new int[][]{{0, 1}, {0, 2}});\n        System.out.println(canFinish(6, graph1, 0, 5));\n\n        Graph graph2 = new Graph(new int[][]{{0, 2}, {1, 2}, {2, 3}, {3, 4}});\n        System.out.println(canFinish(4, graph2, 0, 3));\n\n        Graph graph3 = new Graph(new int[][]{{0, 1}, {1, 2}, {2, 3}, {3, 4}, {4, 5}});\n        System.out.println(canFinish(6, graph3, 0, 5));\n    }\n}\n\nclass Graph {\n    private int[][] edges;\n\n    public Graph(int[][] edges) {\n        this.edges = edges;\n    }\n\n    public boolean hasCycle() {\n        boolean[] visited = new boolean[edges.length];\n        for (int i = 0; i < edges.length; i++) {\n            if (!visited[i]) {\n                if (hasCycleUtil(i, visited)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean hasCycleUtil(int node, boolean[] visited) {\n        visited[node] = true;\n\n        for (int[] edge : edges) {\n            if (edge[0] == node && !visited[edge[1]]) {\n                if (hasCycleUtil(edge[1], visited)) {\n                    return true;\n                }\n            } else if (edge[1] == node && !visited[edge[0]]) {\n                if (hasCycleUtil(edge[0], visited)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n\npublic class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites, int start, int end) {\n        Graph graph = new Graph(prerequisites);\n        return !graph.hasCycle();\n    }\n}\n```",
  "1062": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestRepeatingSubstring(\"abcabc\")); // expected output: \"ab\"\n        System.out.println(longestRepeatingSubstring(\"abababc\")); // expected output: \"ab\"\n        System.out.println(longestRepeatingSubstring(\"banana\")); // expected output: \"ana\"\n    }\n\n    public static String longestRepeatingSubstring(String s) {\n        // your implementation here\n    }\n}\n```",
  "1061": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(alternativeWords(new String[]{\"a\", \"cd\", \"bcd\", \"cba\"}, new String[]{\"aaa\",\"bcc\",\"xyx\"}));\n        System.out.println(alternativeWords(new String[]{\"kth\", \"yvqyfj\", \"wcvbct\", \"pflwijeo\"}, new String[]{\"wcvbct\", \"yvqyfj\", \"kth\", \"pflwijeo\"}));\n        System.out.println(alternativeWords(new String[]{\"abcdefghijklmnopqrstuvwxyz\"}, new String[]{\"abc\", \"defghijklmnopqrstuvwxyz\", \"xyz\"}));\n    }\n\n    public static String[] alternativeWords(String[] words, String[] choices) {\n        UnionFind uf = new UnionFind(words.length);\n        for (int i = 0; i < words.length; i++) {\n            for (char c : choices[i].toCharArray()) {\n                int j = getWordIndex(words, \"\" + c);\n                if (j != -1) {\n                    uf.union(i, j);\n                }\n            }\n        }\n\n        String[] result = new String[words.length];\n        for (int i = 0; i < words.length; i++) {\n            result[i] = uf.getRoot(i) == i ? words[i] : choices[uf.getParent(i)];\n        }\n        return result;\n    }\n\n    public static int getWordIndex(String[] words, String word) {\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].equals(word)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public void union(int x, int y) {\n            if (x != y) {\n                if (rank[x] > rank[y]) {\n                    parent[y] = x;\n                } else {\n                    parent[x] = y;\n                    if (rank[x] == rank[y]) {\n                        rank[y]++;\n                    }\n                }\n            }\n        }\n\n        public int getParent(int x) {\n            return parent[x];\n        }\n\n        public int getRoot(int x) {\n            if (parent[x] != x) {\n                parent[x] = getRoot(parent[x]);\n            }\n            return parent[x];\n        }\n    }\n}\n```",
  "1063": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {2,1,2};\n        System.out.println(numSubarraysWithSum(new int[]{2,1,2}, 3)); // Expected: 2\n\n        int[] nums2 = {0,0,0};\n        System.out.println(numSubarraysWithSum(new int[]{0,0,0}, 0)); // Expected: 6\n\n        int[] nums3 = {3,4,-7,8,-5};\n        System.out.println(numSubarraysWithSum(new int[]{3,4,-7,8,-5}, 1)); // Expected: 4\n    }\n\n    public static int numSubarraysWithSum(int[] nums, int sum) {\n        if (nums.length == 0) return 0;\n        int n = nums.length;\n        int left = 0, right = 0, count = 0;\n        int total = 0;\n\n        while (right < n) {\n            total += nums[right];\n            while (total > sum && left <= right) {\n                total -= nums[left++];\n            }\n            if (total == sum) {\n                count += 1;\n                while (left <= right && total == sum) {\n                    total -= nums[left++];\n                }\n            }\n            right++;\n        }\n        return count;\n    }\n}\n```",
  "1064": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {-10,-5,0,3,7};\n        System.out.println(\"Fixed point in array \" + arr1 + \": \" + fixedPoint(arr1));\n        \n        int[] arr2 = [-1, -1, 0];\n        System.out.println(\"Fixed point in array \" + arr2 + \": \" + fixedPoint(arr2));\n        \n        int[] arr3 = [1, 2, 3];\n        System.out.println(\"Fixed point in array \" + arr3 + \": \" + fixedPoint(arr3));\n    }\n\n    public static int fixedPoint(int[] A) {\n        for (int i = 0; i < A.length; i++) {\n            if (A[i] == i) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
  "1065": "```\npublic class Main {\n    public static void main(String[] args) {\n        indexPairs(\"massive\", new String[]{\"this\", \"that\", \"such\", \"very\"}).forEach(System.out::println);\n        System.out.println();\n        indexPairs(\"bangkok\", new String[]{\"shot\", \"bang\", \"can\"}).forEach(System.out::println);\n        System.out.println();\n        indexPairs(\"hello\", new String[]{\"hi\", \"world\"}).forEach(System.out.println);\n    }\n\n    public static List<List<Integer>> indexPairs(String words[], String[] pairs) {\n        TrieNode root = new TrieNode();\n        for (String pair : pairs) {\n            TrieNode node = root;\n            for (char c : pair.toCharArray()) {\n                if (!node.children.containsKey(c)) {\n                    node.children.put(c, new TrieNode());\n                }\n                node = node.children.get(c);\n            }\n        }\n\n        List<List<Integer>> result = new ArrayList<>();\n        for (String word : words) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                if (!node.children.containsKey(c)) {\n                    break;\n                }\n                node = node.children.get(c);\n                if (node == root && !result.isEmpty()) {\n                    result.add(new ArrayList<>(result.get(result.size() - 1)));\n                } else if (node != root) {\n                    result.add(new ArrayList<>());\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\nclass TrieNode {\n    Map<Character, TrieNode> children = new HashMap<>();\n}\n```",
  "1066": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] bikes = {{0, 1}, {2, 3}};\n        int[][] stations = {{0, 1}, {2, 3}};\n        System.out.println(numRides(0, bikes, stations));\n        \n        int[][] bikes2 = {{0, 2},{5,7}};\n        int[][] stations2 = {{0,1},{4,6},{5,9},{6,10}};\n        System.out.println(numRides(0, bikes2, stations2));\n\n        int[][] bikes3 = {{0,1},{2,3}};\n        int[][] stations3 = {{1,2},{5,7}};\n        System.out.println(numRides(0, bikes3, stations3));\n    }\n\n    public static int numRides(int startStation, int[][] bicycles, int[][] stations) {\n        // your code here\n    }\n}",
  "1067": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countNumbersInRange(1, 13, 2));\n        System.out.println(countNumbersInRange(1, 25, 3));\n        System.out.println(countNumbersInRange(19, 36, 4));\n    }\n\n    public static int countNumbersInRange(int low, int high, int k) {\n        // Your logic goes here\n        return 0;\n    }\n}",
  "1069": "```\npublic class Solution {\n    public int totalRevenue(String[] products, String[][] sales) {\n        Map<String, Integer> productSales = new HashMap<>();\n        for (String[] sale : sales) {\n            productSales.put(sale[1], productSales.getOrDefault(sale[1], 0) + Integer.parseInt(sale[2]));\n        }\n        return Arrays.stream(products).mapToLong(product -> productSales.computeIfAbsent(product, k -> 0)).sum();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        String[] products = {\"A\", \"B\", \"C\"};\n        String[][] sales1 = {{\"A\", \"A\", \"5\"}, {\"B\", \"B\", \"2\"}};\n        System.out.println(\"Test Case 1: \" + solution.totalRevenue(products, sales1)); // Expected output: 7\n\n        String[] products2 = {\"A\", \"B\", \"C\", \"D\"};\n        String[][] sales2 = {{\"A\", \"A\", \"3\"}, {\"B\", \"B\", \"6\"}, {\"D\", \"D\", \"5\"}};\n        System.out.println(\"Test Case 2: \" + solution.totalRevenue(products2, sales2)); // Expected output: 14\n\n        String[] products3 = {\"E\"};\n        String[][] sales3 = {{\"E\", \"E\", \"8\"}};\n        System.out.println(\"Test Case 3: \" + solution.totalRevenue(products3, sales3)); // Expected output: 8\n    }\n}",
  "1068": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] productSales = {{5, 2, 3}, {7, 1, 0}, {9, 4, 6}};\n        System.out.println(\"Test case 1: \" + Arrays.deepToString(solution.productSalesAnalysis(productSales)));\n        \n        productSales = new int[][]{{10, 0, 8}, {5, 3, 2}, {7, 5, 9}};\n        System.out.println(\"Test case 2: \" + Arrays.deepToString(solution.productSalesAnalysis(productSales)));\n        \n        productSales = new int[][]{{1, 2, 3}, {4, 0, 6}, {2, 7, 8}};\n        System.out.println(\"Test case 3: \" + Arrays.deepToString(solution.productSalesAnalysis(productSales)));\n    }\n}\n\nclass Solution {\n    public int[][] productSalesAnalysis(int[][] sales) {\n        int rows = sales.length;\n        int cols = sales[0].length;\n        \n        int[][] result = new int[rows][cols];\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (sales[i][j] == 0) {\n                    result[i][j] = -1;\n                } else if (i == 0 || j == 0) {\n                    result[i][j] = sales[i][j];\n                } else {\n                    int sum1 = 0, sum2 = 0;\n                    for (int k = 0; k < i; k++) {\n                        sum1 += sales[k][j];\n                    }\n                    for (int k = 0; k < j; k++) {\n                        sum2 += sales[i][k];\n                    }\n                    result[i][j] = sum1 * sum2;\n                }\n            }\n        }\n        \n        return result;\n    }\n}",
  "1071": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(gcdOfStrings(\"ABC\", \"AB\"));//Expected output: 1\n        System.out.println(gcdOfStrings(\"XYZ\", \"XZ\"));//Expected output: 2\n        System.out.println(gcdOfStrings(\"ABAB\", \"BABA\"));//Expected output: 1\n    }\n\n    public static String gcdOfStrings(String str1, String str2) {\n        if (!str1.equals(str2 + str1.substring(str1.length() / str2.length()))) {\n            return \"\";\n        }\n        return str2.substring(0, str2.length() / (str1.length() / str2.length()));\n    }\n}\n```",
  "1070": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] result1 = solution.productSalesAnalysisIII(new String[]{\"A\", \"B\", \"C\"}, new double[]{15.0, 30.0, 5.0}, 3);\n        System.out.println(Arrays.deepToString(result1));\n        \n        int[][] result2 = solution.productSalesAnalysisIII(new String[]{\"A\", \"B\", \"C\", \"D\"}, new double[]{10.0, 20.0, 30.0, 40.0}, 2);\n        System.out.println(Arrays.deepToString(result2));\n        \n        int[][] result3 = solution.productSalesAnalysisIII(new String[]{\"A\", \"B\"}, new double[]{1.0, 2.0}, 4);\n        System.out.println(Arrays.deepToString(result3));\n    }\n}\n\nclass Solution {\n    public int[][] productSalesAnalysisIII(String[] products, double[] sales, int days) {\n        List<List<Integer>> result = new ArrayList<>();\n        \n        for (int i = 0; i < products.length; i++) {\n            List<Integer> productSales = new ArrayList<>();\n            for (int j = 0; j < days; j++) {\n                productSales.add((int) Math.round(sales[i] / days));\n            }\n            result.add(productSales);\n        }\n        \n        return result.stream().mapToInt(List::size).toArray(int[][]::new);\n    }\n}\n```",
  "1072": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{0,1},{1,1}};\n        System.out.println(\"Result for matrix1: \" + maxEqualRowsAfterFlips(matrix1));\n        \n        int[][] matrix2 = {{0,1,0},{0,0,1},{1,1,1},{1,0,1}};\n        System.out.println(\"Result for matrix2: \" + maxEqualRowsAfterFlips(matrix2));\n\n        int[][] matrix3 = {{0, 1}, {1, 0}, {1, 1}};\n        System.out.println(\"Result for matrix3: \" + maxEqualRowsAfterFlips(matrix3));\n    }\n\n    public static int maxEqualRowsAfterFlips(int[][] matrix) {\n        // code here\n    }\n}",
  "1073": "```\npublic class Main {\n    public static void main(String[] args) {\n        NegabinaryNumber neg1 = new NegabinaryNumber(-2);\n        NegabinaryNumber neg2 = new NegabinaryNumber(-3);\n        NegabinaryNumber neg3 = new NegabinaryNumber(5);\n\n        System.out.println(\"Test case 1: \" + addNegabinary(neg1, neg2));\n        System.out.println(\"Test case 2: \" + addNegabinary(neg2, neg3));\n        System.out.println(\"Test case 3: \" + addNegabinary(neg1, neg3));\n    }\n\n    public static NegabinaryNumber addNegabinary(NegabinaryNumber a, NegabinaryNumber b) {\n        // Your code goes here\n    }\n}\n```",
  "1074": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{-1,-1,1,-1,-1,-1}};\n        System.out.println(\"Expected: 2, Actual: \" + numSubmatrixSum(matrix1, 0));\n        \n        int[][] matrix2 = {{3, -1}, 5, 3};\n        System.out.println(\"Expected: 4, Actual: \" + numSubmatrixSum(matrix2, 8));\n        \n        int[][] matrix3 = {{10,-3,0,4,2},{7,6,2,-1,-2},{-9,-9,-8,6,6},{5,0,3,4,0}};\n        System.out.println(\"Expected: 16, Actual: \" + numSubmatrixSum(matrix3, 15));\n    }\n\n    public static int numSubmatrixSum(int[][] matrix, int target) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] += matrix[i - 1][j];\n            }\n        }\n        \n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = j; k < n; k++) {\n                    int sum = matrix[i][k] - (matrix[i][j - 1]);\n                    if (sum == target) count++;\n                    else if (sum > target) break;\n                }\n            }\n        }\n        \n        return count;\n    }\n}",
  "1075": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + getAverageRating(new int[][]{{1, 5}, {10, 2}}));\n        System.out.println(\"Test Case 2: \" + getAverageRating(new int[][]{{4, 3}, {3, 2}}));\n        System.out.println(\"Test Case 3: \" + getAverageRating(new int[][]{{7, 1}, {8, 6}}));\n\n    }\n\n    public static double getAverageRating(int[][] ratings) {\n        Map<Integer, Double> ratingMap = new HashMap<>();\n        for (int[] rating : ratings) {\n            if (!ratingMap.containsKey(rating[0])) {\n                ratingMap.put(rating[0], (double) rating[1] / 2.0);\n            } else {\n                double currentRating = ratingMap.get(rating[0]);\n                ratingMap.put(rating[0], (currentRating + (double) rating[1]) / 2.0);\n            }\n        }\n        double total = 0;\n        for (double rating : ratingMap.values()) {\n            total += rating;\n        }\n        return total / ratingMap.size();\n    }\n}\n```",
  "1076": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + getAverageRating(new int[][]{{1, 3}, {2, -3}}));\n        System.out.println(\"Test Case 2: \" + getAverageRating(new int[][]{{1, 12}, {-5, 3}}));\n        System.out.println(\"Test Case 3: \" + getAverageRating(new int[][]{(-1, 7), (-10, 6)}));\n\n    }\n\n    public static double getAverageRating(int[][] ratings) {\n        double sum = 0;\n        for (int[] rating : ratings) {\n            sum += Math.abs(rating[1]);\n        }\n        return sum / ratings.length;\n    }\n}\n```",
  "1078": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(findOccurrences(\"AliceHello\", \"Hel\"))); // [2,5,6]\n        System.out.println(Arrays.toString(findOccurrences(\"BoboHey\", \"oy\"))); // [3,8]\n        System.out.println(Arrays.toString(findOccurrences(\"a b c d e f g h i j k\", \" a \"))); // [1,4,7,10,13,16,19,22,25,28]\n    }\n\n    public static int[] findOccurrences(String text, String bigram) {\n        List<Integer> occurrences = new ArrayList<>();\n        for (int i = 0; i < text.length() - bigram.length(); i++) {\n            if (text.substring(i, i + bigram.length()).equals(bigram)) {\n                occurrences.add(i + bigram.length());\n            }\n        }\n        return occurrences.stream().mapToInt(Integer::intValue).toArray();\n    }\n}",
  "1077": "```\npublic class Main {\n    public static void main(String[] args) {\n        test1();\n        test2();\n        test3();\n    }\n\n    private static void test1() {\n        List<Employee> employees = new ArrayList<>();\n        employees.add(new Employee(\"LeetCode\", 5));\n        employees.add(new Employee(\"Google\", 4));\n        employees.add(new Employee(\"Facebook\", 3));\n\n        System.out.println(\"Test 1: \" + getValleyEmployees(employees, 3));\n    }\n\n    private static void test2() {\n        List<Employee> employees = new ArrayList<>();\n        employees.add(new Employee(\"Apple\", 5));\n        employees.add(new Employee(\"Microsoft\", 4));\n        employees.add(new Employee(\"Amazon\", 3));\n\n        System.out.println(\"Test 2: \" + getValleyEmployees(employees, 3));\n    }\n\n    private static void test3() {\n        List<Employee> employees = new ArrayList<>();\n        employees.add(new Employee(\"Twitter\", 5));\n        employees.add(new Employee(\"Yahoo\", 4));\n        employees.add(new Employee(\"LinkedIn\", 3));\n\n        System.out.println(\"Test 3: \" + getValleyEmployees(employees, 3));\n    }\n\n    public static List<Employee> getValleyEmployees(List<Employee> employees, int valley) {\n        // your logic here\n        return null;\n    }\n}\n\nclass Employee {\n    String company;\n    int rating;\n\n    public Employee(String company, int rating) {\n        this.company = company;\n        this.rating = rating;\n    }\n}\n```",
  "1079": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(letterTilePossibilities(\"AAB\"));//5\n        System.out.println(letterTilePossibilities(\"AA\"));//8\n        System.out.println(letterTilePossibilities(\"a\"));//$1\n    }\n\n    public static int letterTilePossibilities(String tiles) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < tiles.length(); i++) {\n            String s = tiles.substring(i);\n            map.put(s, map.getOrDefault(s, 0) + 1);\n        }\n        int res = 0;\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            if (!entry.getKey().isEmpty()) {\n                res += factorial(entry.getValue());\n                for (int i = 1; i < entry.getKey().length(); i++) {\n                    res += factorial(entry.getKey().length() - 1) * (entry.getValue() - 1);\n                }\n            }\n        }\n        return res;\n    }\n\n    public static int factorial(int n) {\n        if (n == 0 || n == 1)\n            return 1;\n        else\n            return n * factorial(n - 1);\n    }\n}",
  "1080": "```\nclass Solution {\n    public int sufficientNodes(TreeNode root) {\n        if (root == null) return 0;\n        \n        int[] res = new int[1];\n        dfs(root, true, res);\n        return res[0];\n    }\n    \n    private void dfs(TreeNode node, boolean isLeaf, int[] res) {\n        if (node == null) return;\n        \n        if (!isLeaf && node.left == null && node.right == null) {\n            res[0]++;\n        } else if (isLeaf && (node.left != null || node.right != null)) {\n            res[0]++;\n        }\n        \n        dfs(node.left, !isLeaf && node.left == null, res);\n        dfs(node.right, !isLeaf && node.right == null, res);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        System.out.println(solution.sufficientNodes(root1));  // Output: 0\n\n        // Test case 2\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3, null, new TreeNode(4));\n        System.out.println(solution.sufficientNodes(root2));  // Output: 1\n        \n        // Test case 3\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n        root3.right = new TreeNode(3, new TreeNode(5), new TreeNode(6));\n        System.out.println(solution.sufficientNodes(root3));  // Output: 2\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1081": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSubsequence(\"BCA\")); // expected output: \"BCA\"\n        System.out.println(minSubsequence(\"ABBA\")); // expected output: \"AB\"\n        System.out.println(minSubsequence(\"ADOBECODEBANC\")); // expected output: \"ABC\"\n    }\n\n    public static String minSubsequence(String s) {\n        // Your code here\n    }\n}\n```",
  "1082": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countGoodTrips(new int[][]{{1,2},{4,5},{7,8}}, new String[]{\"John\", \"Amy\", \"Eva\"}));\n        System.out.println(countGoodTrips(new int[][]{{5,17},{16,19},{11,12},{15,18},{3,9},{13,14},{8,10},{1,2},{4,5},{7,8}}, new String[]{\"John\", \"Amy\", \"Eva\",\"Bob\",\"Alice\"}));\n        System.out.println(countGoodTrips(new int[][]{}, new String[]{}));\n    }\n\n    public static int countGoodTrips(int[][] trips, String[] people) {\n        int good = 0;\n        for (int i = 0; i < trips.length; i++) {\n            if (trips[i][1] - trips[i][0] >= 3) {\n                good++;\n            }\n        }\n        return good;\n    }\n}",
  "1083": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] accounts = { { 1, 5 }, { 2, 6 } };\n        System.out.println(minTransfers(accounts)); // Expected output: 1\n        \n        int[][] accounts2 = { { 3, 12 }, { 4, 13 }, { 5, 14 } };\n        System.out.println(minTransfers(accounts2)); // Expected output: 1\n        \n        int[][] accounts3 = { { 1, 10 }, { 2, 11 }, { 3, 12 } };\n        System.out.println(minTransfits(accounts3)); // Expected output: 2\n    }\n\n    public static int minTransfers(int[][] accounts) {\n        Arrays.sort(accounts, (a, b) -> a[0] - b[0]);\n        \n        int transfers = 0;\n        for (int i = 1; i < accounts.length; i++) {\n            if (accounts[i][0] > accounts[i - 1][1]) {\n                transfers++;\n            }\n        }\n        return transfers;\n    }\n}\n```",
  "1085": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfDigitsInTheMinimumNumber(new int[]{1, 10})); // Expected: 9\n        System.out.println(sumOfDigitsInTheMinimumNumber(new int[]{2, 3, 4, 5})); // Expected: 4\n        System.out.println(sumOfDigitsInTheMinimumNumber(new int[]{987, 12, 345})); // Expected: 6\n    }\n\n    public static int sumOfDigitsInTheMinimumNumber(int[] arr) {\n        int min = Arrays.stream(arr).min(Integer::compareTo).get();\n        int sum = 0;\n        while (min != 0) {\n            sum += min % 10;\n            min /= 10;\n        }\n        return sum;\n    }\n}\n```",
  "1084": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(salesAnalysis(new int[][]{{1, 2}, {2, 3}})); // Expected output: 0.5\n        System.out.println(salesAnalysis(new int[][]{{1, 4}, {2, 3}})); // Expected output: 1.0\n        System.out.println(salesAnalysis(new int[][]{{7, 6}, {8, 7}})); // Expected output: -1.0\n    }\n\n    public static double salesAnalysis(int[][] customers) {\n        int sum = 0;\n        for (int[] customer : customers) {\n            sum += Math.abs(customer[0] - customer[1]);\n        }\n        return (double)sum / customers.length;\n    }\n}",
  "1086": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        highFive(new int[][]{{1, 3}, {2, 5}, {4, 7}, {1, 5}}, new int[]{0, 1});\n        highFive(new int[][]{{1, 2}, {1, 3}, {5}}, new int[]{1});\n        highFive(new int[][]{{1, 9}, {2, 5}}, new int[]{0});\n    }\n\n    public static void highFive(int[][] scores, int[] idx) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < scores.length; i++) {\n            if (!map.containsKey(idx[i])) {\n                map.put(idx[i], 0);\n            }\n            map.put(idx[i], Math.max(map.get(idx[i]), scores[i][1]));\n        }\n        System.out.println(map.values());\n    }\n}",
  "1087": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(expandInterpolation(\"a{b,c}d\", new String[]{\"xy1\",\"xy2\"}));\n        System.out.println(expandInterpolation(\"{a,b}{c,d}\", new String[]{\"hi5\",\"hello\"}));\n        System.out.println(expandInterpolation(\"foo{bar,baz}\", new String[]{\"binary-search-algorithm\"});\n    }\n\n    public static List<String> expandInterpolation(String S, String[] L) {\n        List<String> result = new ArrayList<>();\n        for (String str : getCombinations(L)) {\n            StringBuilder sb = new StringBuilder();\n            int j = 0;\n            boolean inBrace = false;\n            for (int i = 0; i < S.length(); i++) {\n                if (inBrace) {\n                    if (S.charAt(i) == '}') {\n                        inBrace = false;\n                        j++;\n                    }\n                } else if (S.charAt(i) == '{ && str.equals(getCombination(str, j))) {\n                    inBrace = true;\n                }\n            }\n            result.add(sb.toString());\n        }\n        return result;\n    }\n\n    public static String getCombination(String str, int index) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : str) {\n            if (index == 0) {\n                sb.append(s);\n                break;\n            } else {\n                sb.append(s).append(\",\");\n            }\n            index--;\n        }\n        return sb.toString();\n    }\n\n    public static List<String> getCombinations(String[] L) {\n        List<String> result = new ArrayList<>();\n        if (L.length == 1) {\n            result.add(L[0]);\n        } else {\n            String first = L[0];\n            for (String s : getCombinations(Arrays.copyOfRange(L, 1, L.length))) {\n                for (int i = 0; i <= first.split(\",\").length; i++) {\n                    result.add(first.split(\",\")[i] + \",\" + s);\n                }\n            }\n        }\n        return result;\n    }\n}\n```",
  "1088": "```\nclass Solution {\n    public boolean getConfusingNumber(String s, int n) {\n        for (int i = 0; i <= n - 5; i++) {\n            if ((s.charAt(i) == '6' && s.charAt(i + 1) == '9' && s.charAt(i + 2) == '9' &&\n                    s.charAt(i + 3) == '6') ||\n                (s.charAt(i) == '9' && s.charAt(i + 1) == '6' && s.charAt(i + 2) == '6' &&\n                    s.charAt(i + 3) == '9')) {\n                if (i > 0 && i < n - 4 && (s.charAt(0) != '0' || i == 1)) continue;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        String s1 = \"2067669\";\n        int n1 = s1.length();\n        System.out.println(solution.getConfusingNumber(s1, n1)); // Expected output: true\n\n        // Test case 2\n        String s2 = \"969696\";\n        int n2 = s2.length();\n        System.out.println(solution.getConfusingNumber(s2, n2)); // Expected output: true\n\n        // Test case 3\n        String s3 = \"20920626\";\n        int n3 = s3.length();\n        System.out.println(solution.getConfusingNumber(s3, n3)); // Expected output: false\n    }\n}",
  "1089": "```\npublic class Main {\n    public static void duplicateZeros(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            if (arr[i] == 0) {\n                for (int j = n - 1; j > i; j--) {\n                    if (j > i && arr[j] != 0) {\n                        arr[i] = arr[j];\n                        break;\n                    }\n                }\n                arr[i + 1] = 0;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int[][] testCases = {\n            {1, 0, 2, 3, 0},\n            {9, 2, 5, 0, 3, 4, 0},\n            {1}\n        };\n\n        for (int[] testCase : testCases) {\n            int[] arrCopy = Arrays.copyOf(testCase, testCase.length);\n            System.out.println(\"Original: \" + Arrays.toString(arrCopy));\n            duplicateZeros(arrCopy);\n            System.out.println(\"After processing: \" + Arrays.toString(arrCopy));\n            System.out.println();\n        }\n    }\n}\n```",
  "1090": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] labels = {{\"hello\", \"leetcode\"}, {\"world\", \"codeforces\"}, {\"a\", \"b\"}};\n        System.out.println(maxValueAfterSubtracting(\"hello\"), \"\\n\");\n        System.out.println(maxValueAfterSubtracting(\"leetcode\"), \"\\n\");\n        System.out.println(maxValueAfterSubtracting(\"world\"));\n    }\n\n    public static int maxValueAfterSubtracting(String keyword) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int[] label : labels) {\n            if (!map.containsKey(label[0])) {\n                map.put(label[0], 1);\n            } else {\n                map.put(label[0], map.get(label[0]) + 1);\n            }\n        }\n        \n        Map<Integer, Integer> sortMap = new TreeMap<>();\n        for (int i : map.values()) {\n            if (!sortMap.containsKey(i)) {\n                sortMap.put(i, 1);\n            } else {\n                sortMap.put(i, sortMap.get(i) + 1);\n            }\n        }\n        \n        int maxValue = -1;\n        for (Map.Entry<Integer, Integer> entry : sortMap.entrySet()) {\n            if (entry.getKey() > maxValue) {\n                maxValue = entry.getKey();\n            }\n        }\n\n        Map<String, String> resMap = new HashMap<>();\n        for (int i = 0; i < labels.length; i++) {\n            if (!resMap.containsKey(labels[i][1])) {\n                resMap.put(labels[i][1], \"0\");\n            }\n            resMap.put(labels[i][1], Integer.toString(Integer.parseInt(resMap.get(labels[i][1])) - maxValue));\n        }\n\n        for (Map.Entry<String, String> entry : resMap.entrySet()) {\n            if (!keyword.equals(entry.getKey())) {\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\n            }\n        }\n    }\n}",
  "1091": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrix1 = {\n            {0, 1, 0},\n            {1, 1, 1},\n            {0, 0, 0}\n        };\n        System.out.println(\"Result for matrix1: \" + shortestPath(matrix1));\n        \n        int[][] matrix2 = {\n            {0, 1, 0, 0},\n            {0, 1, 0, 1},\n            {0, 0, 1, 0},\n            {0, 0, 0, 1}\n        };\n        System.out.println(\"Result for matrix2: \" + shortestPath(matrix2));\n        \n        int[][] matrix3 = {\n            {0, 0, 0},\n            {0, 1, 0},\n            {0, 1, 1}\n        };\n        System.out.println(\"Result for matrix3: \" + shortestPath(matrix3));\n    }\n\n    public static int shortestPath(int[][] matrix) {\n        int rows = matrix.length;\n        if (rows == 0) return -1;\n\n        int cols = matrix[0].length;\n        if (cols == 0) return -1;\n\n        boolean[][] visited = new boolean[rows][cols];\n        Queue<int[]> queue = new LinkedList<>();\n        int startRow = 0, startCol = 0;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (matrix[i][j] == 1) {\n                    startRow = i;\n                    startCol = j;\n                }\n            }\n        }\n\n        queue.add(new int[]{startRow, startCol});\n        visited[startRow][startCol] = true;\n\n        int minStep = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] pos = queue.poll();\n                int row = pos[0];\n                int col = pos[1];\n\n                if (row == rows - 1 && col == cols - 1) return minStep;\n\n                for (int j = -1; j <= 1; j++) {\n                    for (int k = -1; k <= 1; k++) {\n                        int newRow = row + j;\n                        int newCol = col + k;\n                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols\n                                && matrix[newRow][newCol] == 1 && !visited[newRow][newCol]) {\n                            queue.add(new int[]{newRow, newCol});\n                            visited[newRow][newCol] = true;\n                        }\n                    }\n                }\n\n            }\n            minStep++;\n        }\n\n        return -1;\n    }\n}",
  "1092": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(shortestCommonSupersequence(\"abc\", \"def\") + \" Expected: adbfce\");\n        System.out.println(shortestCommonSupersequence(\"coldwar\", \"warchill\") + \" Expected: coldwhilrchiraw\");\n        System.out.println(shortestCommonSupersequence(\"\", \"\") + \" Expected: \");\n    }\n\n    public static String shortestCommonSupersequence(String str1, String str2) {\n        int m = str1.length();\n        int n = str2.length();\n\n        // Create a table to store lengths of longest common subsequences\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0) {\n                    dp[i][j] = j;\n                } else if (j == 0) {\n                    dp[i][j] = i;\n                } else if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + 1;\n                }\n            }\n        }\n\n        // Reconstruct the shortest common supersequence\n        StringBuilder scs = new StringBuilder();\n        int i = m, j = n;\n        while (i > 0 || j > 0) {\n            if (i > 0 && j > 0 && str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                scs.append(str1.charAt(i - 1));\n                i--;\n                j--;\n            } else if (i > 0) {\n                scs.append(str1.charAt(i - 1));\n                i--;\n            } else {\n                scs.append(str2.charAt(j - 1));\n                j--;\n            }\n        }\n\n        // Reverse the result\n        return new StringBuilder(scs.toString()).reverse().toString();\n    }\n}\n```",
  "1093": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] sample1 = {1,2,1};\n        System.out.println(\"Expected: \" + 0.6666667 + \" Actual: \" + medianStream(sample1));\n        \n        int[] sample2 = {0,1,1,1};\n        System.out.println(\"Expected: \" + 1 + \" Actual: \" + medianStream(sample2));\n        \n        int[] sample3 = {1,1,1,1};\n        System.out.println(\"Expected: \" + 1 + \" Actual: \" + medianStream(sample3));\n    }\n\n    public static double medianStream(int[] arr) {\n        Arrays.sort(arr);\n        int n = arr.length;\n        if (n % 2 == 0) {\n            return ((double)arr[n/2 - 1] + arr[n/2]) / 2.0;\n        } else {\n            return (double) arr[n/2];\n        }\n    }\n}\n```",
  "1094": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] t1 = {{4,2}, {1,5}, {1,5}};\n        System.out.println(\"Test case 1: \" + canCarPool(t1));\n        \n        int[][] t2 = {{3,10}, {6,8},};\n        System.out.println(\"Test case 2: \" + canCarPool(t2));\n\n        int[][] t3 = {};\n        System.out.println(\"Test case 3: \" + canCarPool(t3));\n    }\n\n    public static boolean canCarPool(int[][] trips) {\n        Arrays.sort(trips, (a, b) -> a[0] - b[0]);\n        \n        for(int i = 0; i < trips.length; i++) {\n            int start = trips[i][0];\n            int end = trips[i][1];\n            \n            for(int j = i + 1; j < trips.length; j++) {\n                if(trips[j][0] < end) {\n                    return false;\n                }\n                else if(trips[j][0] >= start) {\n                    i = j;\n                    break;\n                }\n            }\n        }\n        \n        return true;\n    }\n}\n```",
  "1095": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + findInMountainArray(new int[]{2,1}, 1));\n        System.out.println(\"Test case 2: \" + findInMountainArray(new int[]{4,2,3,1,3}, 3));\n        System.out.println(\"Test case 3: \" + findInMountainArray(new int[]{0,1,0}, 1));\n    }\n\n    public static int findInMountainArray(int[] arr, int target) {\n        // Your code here\n    }\n}\n```",
  "1096": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(expand(\"(a)(b)\") == new String[]{\"ab\", \"a\",\"b\"});\n        System.out.println(expand(\"(a)(b)c\") == new String[]{\"ac\", \"abc\", \"bc\"});\n        System.out.println(expand(\"{a,b}{c,d}\") == new String[]{\"ac\", \"ad\", \"bc\", \"bd\"});\n    }\n\n    public static List<String> expand(String S) {\n        // Your code here\n    }\n}\n```",
  "1097": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        System.out.println(getTableScore(new String[]{\"Gale\", \"John\"}, new int[][]{{5, 4}, {10, 2}}));\n        \n        System.out.println(\"\\nTest Case 2:\");\n        System.out.println(getTableScore(new String[]{\"John\", \"Moe\", \"Curly\"}, new int[][]{{1, 3, 5}, {2, 7, 8}, {9, 4, 6}}));\n\n        System.out.println(\"\\nTest Case 3:\");\n        System.out.println(getTableScore(new String[]{\"Bob\", \"Alex\"}, new int[][]{}));\n    }\n\n    public static int getTableScore(String[] players, int[][] scores) {\n        // Your code here\n        return 0; \n    }\n}\n```",
  "1099": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {10, 5, 2, 3};\n        System.out.println(\"Test case 1: \" + twoSumLessThanK(nums1, 7));\n        \n        int[] nums2 = {1, 2, 3, 4};\n        System.out.println(\"Test case 2: \" + twoSumLessThanK(nums2, 5));\n        \n        int[] nums3 = {34, 23, 12, 45, 15};\n        System.out.println(\"Test case 3: \" + twoSumLessThanK(nums3, 24));\n    }\n\n    public static int twoSumLessThanK(int[] nums, int k) {\n        Arrays.sort(nums);\n        int result = -1;\n        \n        for (int i = 0; i < nums.length - 1; i++) {\n            int j = Arrays.binarySearch(nums, k - nums[i] - 1);\n            \n            if (j > i && j >= 0) {\n                return nums[i] * (k - nums[j] - 1);\n            }\n        }\n        \n        return result;\n    }\n}",
  "1098": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] orders = {{1, \"book1\", 2}, {2, \"book2\", 3}, {3, \"book3\", 4}};\n        List<String> result = popularBooks(orders);\n        System.out.println(result);\n\n        orders = new int[][]{{5, \"book1\", 1}, {10, \"book2\", 2}, {8, \"book3\", 4}};\n        result = popularBooks(orders);\n        System.out.println(result);\n\n        orders = new int[][]{{7, \"book1\", 3}, {7, \"book2\", 5}, {6, \"book3\", 2}};\n        result = popularBooks(orders);\n        System.out.println(result);\n    }\n\n    public static List<String> popularBooks(int[][] orders) {\n        // Your logic here\n        Map<String, Integer> bookOrderCounts = new HashMap<>();\n        for (int[] order : orders) {\n            int customerID = order[0];\n            String bookTitle = order[1];\n            int count = order[2];\n\n            if (!bookOrderCounts.containsKey(bookTitle)) {\n                bookOrderCounts.put(bookTitle, 0);\n            }\n            bookOrderCounts.put(bookTitle, bookOrderCounts.get(bookTitle) + count);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (Map.Entry<String, Integer> entry : bookOrderCounts.entrySet()) {\n            if (entry.getValue() < 3) {\n                result.add(entry.getKey());\n            }\n        }\n        return result;\n    }\n}\n```",
  "1100": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int k = 2;\n        System.out.println(substringsWithNoRepeats(\"abc\", k));\n        \n        k = 1;\n        System.out.println(substringsWithNoRepeats(\"abac\", k));\n\n        k = 3;\n        System.out.println(substringsWithNoRepeats(\"aabbc\", k));\n    }\n\n    public static int substringsWithNoRepeats(String s, int k) {\n        if (s.length() < k || k <= 0) {\n            return 0;\n        }\n        \n        int count = 0;\n        for (int i = 0; i + k - 1 < s.length(); i++) {\n            String substring = s.substring(i, i+k);\n            if (hasNoRepeats(substring)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n\n    public static boolean hasNoRepeats(String s) {\n        Set<Character> set = new HashSet<>();\n        for (char c : s.toCharArray()) {\n            if (!set.add(c)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1101": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(earliestTime(new int[]{7,10,4,14}, new int[]{20,50,9,13})); // Expected: 6\n        System.out.println(earliestTime(new int[]{3,1,4,0}, new int[]{5,2,8,12})); // Expected: 1\n        System.out.println(earliestTime(new int[]{1,2,10,40,9,50}, new int[]{15,30,20,1,17,28})); // Expected: 3\n    }\n\n    public static int earliestTime(int[] timeToWear, int[] getReady) {\n        int[] parent = new int[100001];\n        for (int i = 0; i < 100001; i++) {\n            parent[i] = i;\n        }\n        for (int i = 0; i < timeToWear.length; i++) {\n            union(parent, timeToWear[i], getReady[i]);\n        }\n        int res = -1;\n        for (int i = 0; i < timeToWear.length; i++) {\n            if (find(parent, timeToWear[i]) == find(parent, getReady[i])) {\n                res = Math.max(res, timeToWear[i] + getReady[i]);\n            }\n        }\n        return res;\n    }\n\n    public static void union(int[] parent, int a, int b) {\n        a = find(parent, a);\n        b = find(parent, b);\n        if (a < b) {\n            parent[b] = a;\n        } else if (a > b) {\n            parent[a] = b;\n        }\n    }\n\n    public static int find(int[] parent, int x) {\n        return parent[x] == x ? x : find(parent, parent[x]);\n    }\n}\n```",
  "1102": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{5, 4, 7}, {3, 2, 8, 3}, {1, 6, 2, 2}};\n        System.out.println(\"Grid 1: \" + maxMinPath(grid1));\n        \n        int[][] grid2 = {{1, 2, 3}, {3, 2, 1}, {4, 5, 0}};\n        System.out.println(\"Grid 2: \" + maxMinPath(grid2));\n\n        int[][] grid3 = {{2, 1, 3}, {8, 9, 4}, {7, 5, 6}};\n        System.out.println(\"Grid 3: \" + maxMinPath(grid3));\n    }\n\n    public static int maxMinPath(int[][] grid) {\n        // Your solution here\n    }\n}",
  "1103": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numBribes(new int[]{10, 2, 8, 1, 0}) == 4);\n        System.out.println(numBribes(new int[]{1, 2, 5, 3, 7, 4}) == 12);\n        System.out.println(numBribes(new int[]{2, 2, 3, 1}) == 6);\n    }\n\n    public static int numBribes(int[] dex) {\n        int bribes = 0;\n        for (int i = 0; i < dex.length; i++) {\n            if (dex[i] - (i + 1) > 2) return 0;\n            for (int j = Math.max(0, i-1); j >= 0; j--) {\n                if (dex[j] >= dex[i]) {\n                    bribes++;\n                    break;\n                }\n            }\n        }\n        return bribes;\n    }\n\n}",
  "1105": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(waysToFillBookShelf(new int[]{1, 2, 5}, 5)); // Output: 4\n        System.out.println(waysToFillBookShelf(new int[]{14, 9, 13, 12, 8}, 10)); // Output: 6\n        System.out.println(waysToFillBookShelf(new int[]{2, 3, 5, 7, 15}, 10)); // Output: 5\n    }\n\n    public static int waysToFillBookShelf(int[] shelf, int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            int ways = 0;\n            for (int j = 0; j < shelf.length && j <= i; j++) {\n                if (i - j >= 0) {\n                    ways += dp[i - j];\n                }\n            }\n            dp[i] = ways;\n        }\n        return dp[n];\n    }\n}",
  "1104": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] label = {{1},{4,2},{1}};\n        System.out.println(getImportance(label));\n\n        int[][] label2 = {{0,1,2},{3,4},{5,6}};\n        System.out.println(getImportance(label2));\n\n        int[][] label3 = {{0,1},{2},{3},{4},{20,11,10,12,21,19,18,23,22},{15,14}};\n        System.out.println(getImportance(label3));\n    }\n\n    public static int getImportance(int[][] employees) {\n        Map<Integer, Employee> map = new HashMap<>();\n        for (int[] employee : employees) {\n            Employee e = new Employee(employee[0], employee[1]);\n            map.put(employee[0], e);\n        }\n        \n        int importance = 0;\n        for (Map.Entry<Integer, Employee> entry : map.entrySet()) {\n            if (entry.getValue().importance > 0) {\n                importance += entry.getValue().importance;\n                findImportance(map, entry.getKey(), 1);\n            }\n        }\n        return importance;\n    }\n\n    public static void findImportance(Map<Integer, Employee> map, int employeeId, int level) {\n        if (!map.containsKey(employeeId)) return;\n\n        Employee e = map.get(employeeId);\n        e.importance += level * 2;\n        \n        for (int childId : e.children) {\n            findImportance(map, childId, level + 1);\n        }\n    }\n\n    static class Employee {\n        int id;\n        int importance;\n        List<Integer> children;\n\n        public Employee(int id, int importance) {\n            this.id = id;\n            this.importance = importance;\n            this.children = new ArrayList<>();\n        }\n    }\n}",
  "1106": "```\npublic class Main {\n    public static void main(String[] args) {\n        boolean[] results = {isBool(\"TRUE\"), isBool(\"FALSE || TRUE\"), isBool(\"!(TRUE && FALSE)\")};\n        System.out.println(results[0]);\n        System.out.println(results[1]);\n        System.out.println(results[2]);\n    }\n\n    public static boolean isBool(String s) {\n        // implement your solution here\n    }\n}\n```",
  "1108": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(defangIPaddr(\"1.1.1.1\")); // Output: \"1.[].1.[].1\"\n        System.out.println(defangIPaddr(\"255.100.500.0\")); // Output: \"255.[].500.[].0\"\n        System.out.println(defangIPaddr(\"198.51.100.152\")); // Output: \"198.[].100.[].152\"\n    }\n\n    public static String defangIPaddr(String address) {\n        return address.replace(\".\", \"[.]\");\n    }\n}\n```",
  "1107": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = {\n            {2017, 6, 15},\n            {2017, 6, 15},\n            {2017, 6, 15}\n        };\n        int result1 = dailyReports(logs);\n        System.out.println(\"Test Case 1: \" + result1);\n\n        int[][] logs2 = {\n            {2019, 1, 1},\n            {2018, 5, 30},\n            {2018, 7, 1},\n            {2019, 7, 31}\n        };\n        int result2 = dailyReports(logs2);\n        System.out.println(\"Test Case 2: \" + result2);\n\n        int[][] logs3 = {\n            {2020, 1, 1},\n            {2018, 7, 14},\n            {2020, 8, 15},\n            {2020, 10, 1}\n        };\n        int result3 = dailyReports(logs3);\n        System.out.println(\"Test Case 3: \" + result3);\n    }\n\n    public static int dailyReports(int[][] logs) {\n        Map<Integer, Integer> map = new TreeMap<>();\n        for (int[] log : logs) {\n            int year = log[0], month = log[1], day = log[2];\n            String key = year + \"_\" + month + \"_\" + day;\n            map.put(key, map.getOrDefault(key, 0) + 1);\n        }\n        int maxCount = 0;\n        for (int count : map.values()) {\n            maxCount = Math.max(maxCount, count);\n        }\n        return maxCount;\n    }\n}",
  "1109": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] bookings = {\n            {1, 10},\n            {2, 3},\n            {5, 8},\n            {4, 7}\n        };\n        System.out.println(totalBookings(bookings));\n        \n        int[][] bookings2 = {\n            {1, 5},\n            {2, 100}\n        };\n        System.out.println(totalBookings(bookings2));\n        \n        int[][] bookings3 = {\n            {}\n        };\n        System.out.println(totalBookings(bookings3));\n    }\n\n    public static int totalBookings(int[][] bookings) {\n        int n = bookings.length;\n        if (n == 0) return 0;\n\n        int[] prefixSum = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + bookings[i][1] - bookings[i][0];\n        }\n\n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            if (i > 0) {\n                total += prefixSum[i] - prefixSum[i - 1];\n            }\n        }\n        \n        return total;\n    }\n}\n```",
  "1110": "```\nclass Solution {\n    public TreeNode[] delNodes(TreeNode root, int target) {\n        boolean isTarget = false;\n        TreeNode[] trees = new TreeNode[2];\n        helper(root, isTarget, trees);\n        return trees;\n    }\n\n    private void helper(TreeNode node, boolean isTarget, TreeNode[] trees) {\n        if (node == null) return;\n\n        boolean isCurrentNodeTarget = node.val == target;\n        if (isCurrentNodeTarget && !isTarget) {\n            trees[1] = node;\n        } else if (!isCurrentNodeTarget && isTarget) {\n            trees[0] = node;\n        }\n\n        helper(node.left, isCurrentNodeNode, trees);\n        helper(node.right, isCurrentNodeTarget, trees);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(6);\n        root1.right = new TreeNode(2);\n        root1.left.left = new TreeNode(7);\n        root1.left.right = new TreeNode(2);\n        root1.right.left = new TreeNode(8);\n\n        TreeNode[] trees1 = solution.delNodes(root1, 5);\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(4);\n\n        TreeNode[] trees2 = solution.delNodes(root2, 3);\n\n        TreeNode root3 = new TreeNode(0);\n        root3.left = new TreeNode(1);\n        root3.right = new TreeNode(2);\n\n        TreeNode[] trees3 = solution.delNodes(root3, 0);\n\n        // Print the results\n        System.out.println(Arrays.toString(trees1));\n        System.out.println(Arrays.toString(trees2));\n        System.out.println(Arrays.toString(trees3));\n    }\n}\n```",
  "1111": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxDepth(\"(()())\")); // Output: 2\n        System.out.println(maxDepth(\"((()))\")); // Output: 4\n        System.out.println(maxDepth(\"(()(()))\")); // Output: 3\n    }\n\n    public static int maxDepth(String s1, String s2) {\n        int depth = 0;\n        for (int i = 0; i < Math.max(s1.length(), s2.length()); i++) {\n            if (i < s1.length() && s1.charAt(i) == '(') depth++;\n            if (i < s1.length() && s1.charAt(i) == ')') depth--;\n            if (i < s2.length() && s2.charAt(i) == '(') depth++;\n            if (i < s2.length() && s2.charAt(i) == ')') depth--;\n        }\n        return Math.max(depth, 0);\n    }\n}",
  "1112": "```\nimport java.util.*;\n\npublic class HighestGradeForEachStudent {\n    public static List<List<String>> highestGradeForEachStudent(List<List<String>> grades) {\n        Map<String, Integer> studentGrades = new HashMap<>();\n        for (List<String> grade : grades) {\n            String student = grade.get(0);\n            int gradeValue = Integer.parseInt(grade.get(1));\n            if (!studentGrades.containsKey(student)) {\n                studentGrades.put(student, gradeValue);\n            } else {\n                studentGrades.put(student, Math.max(studentGrades.get(student), gradeValue));\n            }\n        }\n        return new ArrayList<>(studentGrades.entrySet()).stream()\n                .map(entry -> Arrays.asList(entry.getKey(), String.valueOf(entry.getValue())))\n                .collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<List<String>> grades = Arrays.asList(\n                Arrays.asList(\"Alice\", \"A\"),\n                Arrays.asList(\"Bob\", \"B\"),\n                Arrays.asList(\"Alice\", \"A\"),\n                Arrays.asList(\"Charlie\", \"C\"),\n                Arrays.asList(\"Alice\", \"A\")\n        );\n        System.out.println(highestGradeForEachStudent(grades));\n\n        grades = Arrays.asList(\n                Arrays.asList(\"David\", \"F\"),\n                Arrays.asList(\"Eve\", \"B\"),\n                Arrays.asList(\"David\", \"D\"),\n                Arrays.asList(\"Eve\", \"B\")\n        );\n        System.out.println(highestGradeForEachStudent(grades));\n\n        grades = Arrays.asList();\n        System.out.println(highestGradeForEachStudent(grades));\n    }\n}",
  "1113": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println( ReportedPosts(new int[][]{{1, 2}, {2, 3}} , new String[]{\"A\", \"B\"} ) );\n        System.out.println( ReportedPosts(new int[][]{}, new String[]{}) );\n        System.out.println( ReportedPosts(new int[][]{{1}}, new String[]{\"A\"}) );\n    }\n\n    public static String ReportedPosts(int[][] watchedVideos, String[] users) {\n        Map<String, Set<Integer>> map = new HashMap<>();\n        for (int i = 0; i < users.length; i++) {\n            map.put(users[i], new HashSet<>());\n        }\n        for (int i = 0; i < watchedVideos.length; i++) {\n            map.get(users[watchedVideos[i][1] - 1]).add(watchedVideos[i][0]);\n        }\n        StringBuilder sb = new StringBuilder();\n        for (Map.Entry<String, Set<Integer>> entry : map.entrySet()) {\n            sb.append(entry.getKey()).append(\": \");\n            if (!entry.getValue().isEmpty()) {\n                sb.append(Arrays.toString(entry.getValue().toArray()));\n            } else {\n                sb.append(\"None\");\n            }\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n}\n```",
  "1114": "```\nclass Solution {\n    public void printInOrder(int n) {\n        for (int i = 1; i <= n; i++) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        solution.printInOrder(5);\n        solution.printInOrder(2);\n        solution.printInOrder(1);\n    }\n}",
  "1115": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        new FooBar().printFooBar(new Condition());\n    }\n}\n\nclass FooBar {\n    private boolean printFoo;\n    private Condition condition;\n\n    public FooBar() {\n        this.printFoo = true;\n        this.condition = new Condition();\n    }\n\n    public void printFooBar(Condition condition) {\n        while (condition.hasNext()) {\n            if (printFoo) {\n                System.out.println(\"foo\");\n                printFoo = false;\n            } else {\n                System.out.println(\"bar\");\n                printFoo = true;\n            }\n        }\n    }\n}\n\nclass Condition {\n    private int counter;\n\n    public Condition() {\n        this.counter = 0;\n    }\n\n    public boolean hasNext() {\n        return ++counter < 6; // Change 6 to your test case size\n    }\n}\n```",
  "1116": "```\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class PrintZeroEvenOdd {\n    public static void zeroEvenOdd(int n) {\n        AtomicInteger zero = new AtomicInteger(0);\n        AtomicInteger even = new AtomicInteger(0);\n        \n        while (zero.get() + even.get() < n) {\n            if (zero.get() % 2 == 0) {\n                System.out.print(even.incrementAndGet() + \" \");\n            } else if (even.get() < n/2) {\n                System.out.print(zero.incrementAndGet() + \" \");\n            } else {\n                System.out.print(even.incrementAndGet() + \" \");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        zeroEvenOdd(4); // Test case 1\n        System.out.println();\n        \n        zeroEvenOdd(2); // Test case 2\n        System.out.println();\n        \n        zeroEvenOdd(5); // Test case 3\n        System.out.println();\n    }\n}\n```",
  "1117": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(new H2O().check(\"H2O\"));\n        System.out.println(new H2O().check(\"HOH\"));\n        System.out.println(new H2O().check(\"H2O2CO2\"));\n    }\n}\n\nclass H2O {\n\n    public boolean check(String s) {\n        int hCount = 0;\n        int oCount = 0;\n\n        for (char c : s.toCharArray()) {\n            if (c == 'H') {\n                hCount++;\n            } else if (c == 'O') {\n                oCount++;\n            }\n        }\n\n        return hCount == 2 && oCount == 1;\n    }\n}\n```",
  "1118": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfDaysInMonth(1, 2022)); // Expected: 31\n        System.out.println(numberOfDaysInMonth(2, 2020)); // Expected: 29\n        System.out.println(numberOfDaysInMonth(12, 2015)); // Expected: 31\n    }\n\n    public static int numberOfDaysInMonth(int month, int year) {\n        if (month < 1 || month > 12) {\n            return -1;\n        }\n        if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0) {\n            // Leap year\n            if (month == 2) {\n                return 29;\n            } else {\n                return 28;\n            }\n        } else {\n            switch (month) {\n                case 1:\n                case 3:\n                case 5:\n                case 7:\n                case 8:\n                case 10:\n                case 12:\n                    return 31;\n                case 4:\n                case 6:\n                case 9:\n                case 11:\n                    return 30;\n            }\n        }\n        return -1; // Should never reach this point\n    }\n}",
  "1119": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removeVowels(\"Hello World\")); // Expected: \"Hll Wrld\"\n        System.out.println(removeVowels(\"aeiou\")); // Expected: \"\"\n        System.out.println(removeVowels(\"bcdfghjklmnpqrstvwxyz\")); // Expected: \"bcdfghjklmnpqrstvwxyz\"\n    }\n\n    public static String removeVowels(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (!isVowel(c)) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    private static boolean isVowel(char c) {\n        c = Character.toLowerCase(c);\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n}",
  "1120": "```\nclass Solution {\n    public int maximumAverageSubtree(TreeNode root) {\n        if (root == null) return 0;\n        int sum = root.val;\n        if (root.left != null) sum += maximumAverageSubtree(root.left);\n        if (root.right != null) sum += maximumAverageSubtree(root.right);\n        return sum / (1 + (root.left == null ? 0 : 1) + (root.right == null ? 0 : 1));\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(6);\n        root1.right = new TreeNode(5);\n        System.out.println(\"Maximum Average Subtree for test case 1: \" + solution.maximumAverageSubtree(root1));\n        \n        // Test Case 2\n        TreeNode root2 = new TreeNode(10);\n        root2.left = new TreeNode(4);\n        root2.right = new TreeNode(6);\n        System.out.println(\"Maximum Average Subtree for test case 2: \" + solution.maximumAverageSubtree(root2));\n        \n        // Test Case 3\n        TreeNode root3 = new TreeNode(5);\n        root3.left = new TreeNode(-1);\n        root3.right = new TreeNode(12);\n        System.out.println(\"Maximum Average Subtree for test case 3: \" + solution.maximumAverageSubtree(root3));\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}",
  "1121": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {{5, 2, 4}, 1},\n            {{1, 2, 3, 4}, 3},\n            {{10, 11, 12, 13, 14, 15}, 6}\n        };\n\n        for (int[] array : arrays) {\n            int result = new Solution().arrangingCoins(array[0]);\n            System.out.println(\"Array: \" + Arrays.toString(array[0]) + \", Result: \" + result);\n        }\n    }\n}\n\n```",
  "1122": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {2,3,1,3,3,2};\n        System.out.println(\"Expected: [1,2,2,3,3,3]\");\n        printArray(relativeSortArray(arr1));\n        \n        int[] arr2 = [4, 2, 9, 23, 5, 7, 15];\n        System.out.println(\"Expected: [2,4,5,7,9,15,23]\");\n        printArray(relativeSortArray(arr2));\n\n        int[] arr3 = [5, 1, 18, 10, 13];\n        System.out.println(\"Expected: [1, 5, 10, 13, 18]\");\n        printArray(relativeSortArray(arr3));\n    }\n\n    public static int[] relativeSortArray(int[] arr) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i : arr) {\n            if (!map.containsKey(i)) {\n                map.put(i, map.size());\n            }\n        }\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i : arr) {\n            list.add(map.get(i), i);\n        }\n        int[] result = new int[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            result[i] = list.get(i);\n        }\n        Arrays.sort(result);\n        return result;\n    }\n\n    public static void printArray(int[] array) {\n        for (int j : array) {\n            System.out.print(j + \" \");\n        }\n        System.out.println();\n    }\n}",
  "1123": "```\nimport java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, List<TreeNode> deepestLeaves) {\n        // Implement your logic here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        TreeNode node1 = new TreeNode(3);\n        node1.left = new TreeNode(5);\n        node1.right = new TreeNode(1);\n        node1.left.left = new TreeNode(6);\n        node1.left.right = new TreeNode(2);\n        node1.right.left = new TreeNode(0);\n        node1.right.right = new TreeNode(8);\n        List<TreeNode> deepestLeaves1 = new ArrayList<>();\n        deepestLeaves1.add(node1.left.left); // 6\n        deepestLeaves1.add(node1.left.right); // 2\n        System.out.println(\"Lowest Common Ancestor for test case 1: \" + solution.lowestCommonAncestor(node1, deepestLeaves1).val);\n\n        // Test case 2\n        TreeNode node2 = new TreeNode(4);\n        node2.left = new TreeNode(2);\n        node2.right = new TreeNode(7);\n        List<TreeNode> deepestLeaves2 = new ArrayList<>();\n        deepestLeaves2.add(node2.left); // 2\n        deepestLeaves2.add(node2.right); // 7\n        System.out.println(\"Lowest Common Ancestor for test case 2: \" + solution.lowestCommonAncestor(node2, deepestLeaves2).val);\n\n        // Test case 3\n        TreeNode node3 = new TreeNode(5);\n        node3.left = new TreeNode(1);\n        node3.right = new TreeNode(4);\n        List<TreeNode> deepestLeaves3 = new ArrayList<>();\n        deepestLeaves3.add(node3.left); // 1\n        deepestLeaves3.add(node3.right); // 4\n        System.out.println(\"Lowest Common Ancestor for test case 3: \" + solution.lowestCommonAncestor(node3, deepestLeaves3).val);\n    }\n}",
  "1124": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals = {{9,12},{15,20},{25,28},{5,6},{7,14},{0,2}};\n        System.out.println(\"The longest well-performing interval is: \" + longestWellPerformingInterval(intervals));\n        \n        intervals = new int[][]{{1,3},{2,4}};\n        System.out.println(\"The longest well-performing interval is: \" + longestWellPerformingInterval(intervals));\n\n        intervals = new int[][]{ {10,20}, {5,15} };\n        System.out.println(\"The longest well-performing interval is: \" + longestWellPerformingInterval(intervals));\n    }\n\n    public static int longestWellPerformingInterval(int[][] intervals) {\n        // Your solution here\n    }\n}\n```",
  "1125": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] team = new int[][]{{1, 2}, {2, 4}};\n        System.out.println(\"Expected: 5, Actual: \" + smallestSufficientTeam(team));\n        \n        int[][] team2 = new int[][]{{10, 12},{11, 13}, {14, 15}};\n        System.out.println(\"Expected: 20, Actual: \" + smallestSufficientTeam(team2));\n        \n        int[][] team3 = new int[][]{};\n        System.out.println(\"Expected: 0, Actual: \" + smallestSufficientTeam(team3));\n    }\n\n    public static int smallestSufficientTeam(int[][] reqs) {\n        // Your code here\n    }\n}",
  "1126": "```\npublic class Solution {\n    public String[] activeBusinesses(String[] customers) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String customer : customers) {\n            if (!map.containsKey(customer)) {\n                map.put(customer, 1);\n            } else {\n                map.put(customer, map.get(customer) + 1);\n            }\n        }\n        List<String[]> result = new ArrayList<>();\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            if (entry.getValue() > 0) {\n                result.add(new String[]{entry.getKey(), String.valueOf(entry.getValue())});\n            }\n        }\n        return result.stream().map(Object::toString).toArray(String[]::new);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] customers1 = {\"John23\", \"John23\", \"Jane42\"};\n        System.out.println(Arrays.deepToString(solution.activeBusinesses(customers1)));\n        \n        String[] customers2 = {\"Alice12\", \"Bob34\", \"Charlie56\", \"Alice12\", \"Bob34\"};\n        System.out.println(Arrays.deepToString(solution.activeBusinesses(customers2)));\n        \n        String[] customers3 = {\"John23\", \"Jane42\", \"John23\", \"Jane42\", \"John23\", \"Jane42\"};\n        System.out.println(ArraysdeepToString(solution.activeBusinesses(customers3)));\n    }\n}\n```",
  "1128": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] dominoes1 = {{1,2},{1,3},{2,3}};\n        System.out.println(\"Expected: 1, Got: \" + equivalentDominoPairs(dominoes1));\n        \n        int[][] dominoes2 = {{1,2},{5,6}};\n        System.out.println(\"Expected: 1, Got: \" + equivalentDominoPairs(dominoes2));\n        \n        int[][] dominoes3 = {{1,4},{2,3},{1,3}};\n        System.out.println(\"Expected: 2, Got: \" + equivalentDominoPairs(dominoes3));\n    }\n\n    public static int equivalentDominoPairs(int[][] dominoes) {\n        Map<String,Integer> map = new HashMap<>();\n        for (int[] d : dominoes) {\n            String key = String.valueOf(d[0]) + \",\" + String.valueOf(d[1]);\n            map.put(key, map.getOrDefault(key, 0)+1);\n        }\n        int count = 0;\n        for (Map.Entry<String,Integer> entry:map.entrySet()) {\n            if(entry.getValue() > 1) {\n                count += entry.getValue()/2;\n            }\n        }\n        return count;\n    }\n}\n```",
  "1127": "```\npublic class Solution {\n    public int[] findUsers(int numOrders, int[][] orders) {\n        Map<Integer, List<String>> purchaseMap = new HashMap<>();\n        \n        for (int i = 0; i < numOrders; i++) {\n            String user = orders[i][1];\n            for (int j = 2; j < orders[i].length; j++) {\n                purchaseMap.computeIfAbsent(orders[i][j], k -> new ArrayList<>()).add(user);\n            }\n        }\n        \n        int[][] results = new int[numOrders][];\n        for (int i = 0; i < numOrders; i++) {\n            results[i] = new int[]{orders[i][0], purchaseMap.get(orders[i][2]).size()};\n        }\n        \n        return Arrays.stream(results).mapToInt(ints -> ints[1]).toArray();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] orders1 = {{1, \"user1\", 10}, {4, \"user3\", 20}};\n        System.out.println(Arrays.toString(solution.findUsers(2, orders1))); // [2]\n\n        int[][] orders2 = {{1, \"user1\", 5}, {2, \"user1\", 6}, {7, \"user3\", 10}};\n        System.out.println(Arrays.toString(solution.findUsers(3, orders2))); // [4]\n\n        int[][] orders3 = {{1, \"user1\", 5}, {2, \"user2\", 6}};\n        System.out.println(Arrays.toString(solution.findUsers(2, orders3))); // [1]\n    }\n}",
  "1130": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr = {{4,6,8,7},{1,2,3}}; // Test case 1\n        System.out.println(\"Test case 1: \" + minCostTreeFromLeaves(arr));\n        \n        arr = new int[][]{{5,2,10}, {9,13,15}, {4,12,7,6}}; // Test case 2\n        System.out.println(\"Test case 2: \" + minCostTreeFromLeaves(arr));\n\n        arr = new int[][]{{1,3,4},{8,6,7}}; // Test case 3\n        System.out.println(\"Test case 3: \" + minCostTreeFromLeaves(arr));\n    }\n\n    public static int minCostTreeFromLeaves(int[][] arr) {\n        // Your code here...\n    }\n}\n```",
  "1129": "```\nimport java.util.*;\n\npublic class Solution {\n    public int[] shortestAlternatingPath(int n, List<List<int[]>> redEdges, List<List<int[]>> blueEdges) {\n        Map<Integer, List<List<Integer>>> graph = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            graph.put(i, new ArrayList<>());\n        }\n        for (List<int[]> edge : redEdges) {\n            for (int[] pair : edge) {\n                graph.get(pair[0]).add(new ArrayList<>(Arrays.asList(pair[1], 1)));\n            }\n        }\n        for (List<int[]> edge : blueEdges) {\n            for (int[] pair : edge) {\n                graph.get(pair[0]).add(new ArrayList<>(Arrays.asList(pair[1], -1)));\n            }\n        }\n\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        Queue<int[]> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            queue.add(new int[]{i, 0});\n        }\n        Map<int[], Integer> visited = new HashMap<>();\n\n        while (!queue.isEmpty()) {\n            int[] node = queue.poll();\n            if (!visited.containsKey(node)) {\n                visited.put(node, 1);\n                for (List<Integer> neighbors : graph.get(node[0])) {\n                    int neighbor = neighbors.get(0), step = neighbors.get(1);\n                    if (step == 1) {\n                        for (int[] direction : directions) {\n                            int nextNode = node[0] + direction[0], nextStep = node[1] - 1;\n                            if (nextNode >= 0 && nextNode < n && !visited.containsKey(new int[]{nextNode, nextStep})) {\n                                queue.add(new int[]{nextNode, nextStep});\n                            }\n                        }\n                    } else {\n                        for (int[] direction : directions) {\n                            int nextNode = node[0] + direction[0], nextStep = node[1] + 1;\n                            if (nextNode >= 0 && nextNode < n && !visited.containsKey(new int[]{nextNode, nextStep})) {\n                                queue.add(new int[]{nextNode, nextStep});\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (!visited.containsKey(new int[]{i, 1})) {\n                result.add(1);\n            } else if (!visited.containsKey(new int[]{i, -1})) {\n                result.add(-1);\n            } else {\n                result.add(Math.min(visited.get(new int[]{i, 1}), visited.get(new int[]{i, -1})));\n            }\n        }\n\n        return result.stream().mapToInt(i -> i).toArray();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<List<int[]>> redEdges1 = new ArrayList<>();\n        List<List<int[]>> blueEdges1 = new ArrayList<>();\n\n        redEdges1.add(new ArrayList<>(Arrays.asList(new int[]{0, 1})));\n        blueEdges1.add(new ArrayList<>(Arrays.asList(new int[]{1, 2})));\n\n        System.out.println(Arrays.toString(solution.shortestAlternatingPath(3, redEdges1, blueEdges1)));\n\n        List<List<int[]>> redEdges2 = new ArrayList<>();\n        List<List<int[]>> blueEdges2 = new ArrayList<>();\n\n        redEdges2.add(new ArrayList<>(Arrays.asList(new int[]{0, 1})));\n        blueEdges2.add(new ArrayList<>(Arrays.asList(new int[]{1, 2})));\n        blueEdges2.add(new ArrayList<>(Arrays.asList(new int[]{2, 0})));\n\n        System.out.println(Arrays.toString(solution.shortestAlternatingPath(3, redEdges2, blueEdges2)));\n\n        List<List<int[]>> redEdges3 = new ArrayList<>();\n        List<List<int[]>> blueEdges3 = new ArrayList<>();\n\n        redEdges3.add(new ArrayList<>(Arrays.asList(new int[]{0, 1})));\n        blueEdges3.add(new ArrayList<>(Arrays.asList(new int[]{1, 2})));\n        blueEdges3.add(new ArrayList<>(Arrays.asList(new int[]{2, 3})));\n\n        System.out.println(Arrays.toString(solution.shortestAlternatingPath(4, redEdges3, blueEdges3)));\n    }\n}",
  "1131": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxAbsoluteSum(new int[]{1,-3,9,-9}, 3, 2) == 20);\n        System.out.println(maxAbsoluteSum(new int[]{-1,4,-2,5,0,8}, 4, 7) == 29);\n        System.out.println(maxAbsoluteSum(new int[]{2,9,11,-4,3}, 8, 5) == 27);\n\n    }\n\n    public static int maxAbsoluteSum(int[] nums, int k, int threshold) {\n        int sum = 0;\n        for (int i : nums) sum += i;\n        if (sum <= threshold) return Math.abs(sum);\n        int max = Integer.MIN_VALUE;\n        int current = 0;\n        for (int num : nums) {\n            current += num;\n            if (current > max) max = current;\n            if (current < 0) current = 0;\n            if (nums.length - k <= i++) break;\n        }\n        return Math.max(max, sum - max);\n    }\n}\n```",
  "1132": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1,2};\n        System.out.println(\"Test Case 1: \" + reportedPostsII(nums1));\n        \n        int[] nums2 = {0,3};\n        System.out.println(\"Test Case 2: \" + reportedPostsII(nums2));\n        \n        int[] nums3 = {0,0};\n        System.out.println(\"Test Case 3: \" + reportedPostsII(nums3));\n    }\n\n    public static int reportedPostsII(int[] ids) {\n        // Your solution here\n    }\n}\n```",
  "1133": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2,7,11};\n        System.out.println(\"Expected: 2\");\n        System.out.println(\"Result: \" + largestUniqueNumber(nums1));\n        System.out.println();\n\n        int[] nums2 = {8,9,3};\n        System.out.println(\"Expected: 9\");\n        System.out.println(\"Result: \" + largestUniqueNumber(nums2));\n        System.out.println();\n\n        int[] nums3 = {5,7,3,9};\n        System.out.println(\"Expected: 9\");\n        System.out.println(\"Result: \" + largestUniqueNumber(nums3));\n        System.out.println();\n    }\n\n    public static int largestUniqueNumber(int[] nums) {\n        HashMap<Integer, Integer> countMap = new HashMap<>();\n        for (int num : nums) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        List<Integer> uniqueNums = new ArrayList<>();\n        for (int num : nums) {\n            if (countMap.get(num) == 1) {\n                uniqueNums.add(num);\n            }\n        }\n        Collections.sort(uniqueNums);\n        return uniqueNums.get(uniqueNums.size() - 1);\n    }\n}",
  "1134": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isArmstrong(371)); // Expected output: true\n        System.out.println(isArmstrong(123)); // Expected output: false\n        System.out.println(isArmstrong(153)); // Expected output: true\n    }\n\n    public static boolean isArmstrong(int n) {\n        int temp = n;\n        int sum = 0;\n        int digitCount = (int) Math.floor(Math.log10(n)) + 1;\n\n        while (temp != 0) {\n            int remainder = temp % 10;\n            temp /= 10;\n            for (int i = 0; i < digitCount; i++) {\n                sum += Math.pow(remainder, digitCount);\n            }\n        }\n\n        return sum == n;\n    }\n}",
  "1135": "```\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] connections = {{0,1,10},{0,2,15},{1,2,6}};\n        int n = 3;\n        System.out.println(minCostConnectPoints(connections, n));\n\n        connections = new int[][]{{0,1,4},{0,2,6},{2,3,5},{3,1,3}};\n        n = 4;\n        System.out.println(minCostConnectPoints(connections, n));\n\n        connections = {{0,1,10},{0,2,20},{1,2,100},{2,3,30},{3,4,50},{0,3,10},{3,5,60}};\n        n = 5;\n        System.out.println(minCostConnectPoints(connections, n));\n    }\n\n    public static int minCostConnectPoints(int[][] connections) {\n        UnionFind unionFind = new UnionFind(connections.length);\n        PriorityQueue<int[]> queue = new PriorityQueue<>((a,b)->a[2]-b[2]);\n        for (int[] connection : connections) {\n            if (unionFind.find(connection[0]) != unionFind.find(connection[1])) {\n                queue.offer(connection);\n            }\n        }\n\n        int cost = 0;\n        while (!queue.isEmpty()) {\n            int[] edge = queue.poll();\n            if (unionFind.find(edge[0]) != unionFind.find(edge[1])) {\n                cost += edge[2];\n                unionFind.union(edge[0], edge[1]);\n            }\n        }\n\n        return cost;\n    }\n}\n\nclass UnionFind {\n    private int[] parent;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootX] = rootY;\n        }\n    }\n\n    public int find(int x) {\n        return parent[x];\n    }\n}",
  "1136": "```\nimport java.util.*;\n\npublic class Solution {\n    public int minimumTime(int n, int[][] relations) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] relation : relations) {\n            int from = relation[1];\n            for (int to : relation[0].substring(3).split(\",\")) {\n                graph.computeIfAbsent(Integer.parseInt(to), k -> new ArrayList<>()).add(from);\n            }\n        }\n\n        int[] inDegree = new int[n + 1];\n        for (List<Integer> list : graph.values()) {\n            for (int neighbor : list) {\n                inDegree[neighbor]++;\n            }\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= n; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        int time = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int node = queue.poll();\n                time += 1;\n                for (Integer neighbor : graph.getOrDefault(node, Collections.emptyList())) {\n                    inDegree[neighbor]--;\n                    if (inDegree[neighbor] == 0) {\n                        queue.offer(neighbor);\n                    }\n                }\n            }\n        }\n\n        return time;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.minimumTime(2, new int[][]{{1, \"0\"}, {2, \"1\"}})); // 3\n        System.out.println(solution.minimumTime(3, new int[][]{{1,\"0\"},{\"2\",\"0\"}, {\"3\",\"1\"}, {\"3\",\"2\"}})); // 5\n        System.out.println(solution.minimumTime(4, new int[][]{{1,\"0\"},{\"2\",\"0\"}, {\"3\",\"1\"}, {\"3\",\"2\"}, {\"4\",\"3\"}})); // 7\n    }\n}",
  "1137": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(tribonacci(4)); // Test case 1: tribonacci(4) = 7\n        System.out.println(tribonacci(25)); // Test case 2: tribonacci(25) = 46365\n        System.out.println(tribonacci(9)); // Test case 3: tribonacci(9) = 21\n    }\n\n    public static int tribonacci(int n) {\n        if (n == 0) return 0;\n        if (n == 1 || n == 2) return 1;\n        int[] dp = new int[n + 1];\n        dp[0] = 0; dp[1] = 1; dp[2] = 1;\n        for (int i = 3; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];\n        }\n        return dp[n];\n    }\n}\n```",
  "1138": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(alphabetBoardPath(\"alice\")); // Output: \"10\"\n        System.out.println(alphabetBoardPath(\"jave\")); // Output: \"13\"\n        System.out.println(alphabetBoardPath(\"ajovus\")); // Output: \"21\"\n    }\n\n    public static String alphabetBoardPath(String s) {\n        int steps = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == 'z') {\n                steps += 26;\n            } else {\n                int ascii = c - 'a';\n                if (i > 0) {\n                    char prevC = s.charAt(i - 1);\n                    if (prevC < c) {\n                        ascii -= 1;\n                    }\n                }\n                steps += ascii + 1;\n            }\n        }\n        return String.valueOf(steps);\n    }\n}\n```",
  "1139": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(largest1BorderedSquare(new char[][]{\n            {'1', '0', '1', '0', '0'},\n            {'1', '0', '1', '1', '1'},\n            {'1', '1', '1', '1', '1'},\n            {'1', '0', '0', '1', '0'}\n        })); // Expected output: 4\n\n        System.out.println(largest1BorderedSquare(new char[][]{\n            {'1', '1', '1', '1', '1'},\n            {'1', '1', '1', '1', '1'},\n            {'1', '1', '1', '1', '1'},\n            {'1', '1', '1', '1', '1'}\n        })); // Expected output: 5\n\n        System.out.println(largest1BorderedSquare(new char[][]{\n            {'0', '1', '0', '0', '0'},\n            {'0', '0', '1', '0', '0'},\n            {'0', '0', '0', '1', '0'},\n            {'0', '0', '0', '0', '1'}\n        })); // Expected output: 1\n    }\n\n    public static int largest1BorderedSquare(char[][] grid) {\n        if (grid.length == 0 || grid[0].length == 0) return 0;\n\n        int maxSide = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '1') {\n                    int left = j - 1 >= 0 ? getSide(grid, i, j - 1) : 0;\n                    int right = j + 1 < grid[0].length ? getSide(grid, i, j + 1) : 0;\n                    int up = i - 1 >= 0 ? getSide(grid, i - 1, j) : 0;\n                    int down = i + 1 < grid.length ? getSide(grid, i + 1, j) : 0;\n\n                    maxSide = Math.max(Math.max(left, right), Math.max(up, down));\n                    if (maxSide > 0 && grid[i][j] == '1') {\n                        return (int)Math.pow(maxSide + 1, 2);\n                    }\n                }\n            }\n        }\n\n        return maxSide * maxSide;\n    }\n\n    private static int getSide(char[][] grid, int i, int j) {\n        while (i >= 0 && i < grid.length && j >= 0 && j < grid[0].length) {\n            if (grid[i][j] == '0') break;\n            i -= 1;\n            j -= 1;\n        }\n        return Math.abs(i) + Math.abs(j);\n    }\n}",
  "1140": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] stoneValue1 = {5, 3};\n        System.out.println(\"Stone Value Array: \" + Arrays.toString(stoneValue1));\n        System.out.println(\"Player 1 can win? \" + canIWin(0, 1, new int[stoneValue1.length+1], 0, stoneValue1) ? \"Yes\" : \"No\");\n        \n        int[] stoneValue2 = {1, 2, 3, 31};\n        System.out.println(\"Stone Value Array: \" + Arrays.toString(stoneValue2));\n        System.out.println(\"Player 1 can win? \" + canIWin(0, 1, new int[stoneValue2.length+1], 0, stoneValue2) ? \"Yes\" : \"No\");\n        \n        int[] stoneValue3 = {5};\n        System.out.println(\"Stone Value Array: \" + Arrays.toString(stoneValue3));\n        System.out.println(\"Player 1 can win? \" + canIWin(0, 1, new int[stoneValue3.length+1], 0, stoneValue3) ? \"Yes\" : \"No\");\n    }\n\n    public static boolean canIWin(int i, int j, int[] dp, int sum, int[] stoneValue) {\n        if (j == 0) return true;\n        if (sum >= stoneValue[stoneValue.length-1]) return false;\n\n        for (; i < j; ) {\n            if (sum + stoneValue[i] > stoneValue[stoneValue.length - 1]) break;\n            if (dp[i+j] != 0) continue;\n            int[] newDP = new int[dp.length];\n            System.arraycopy(dp, 0, newDP, 0, dp.length);\n            newDP[i+j] = 1;\n\n            boolean canWin = !canIWin(i+1, j-1, newDP, sum + stoneValue[i], stoneValue);\n\n            if (!canWin) {\n                for (int k = i; k < j; k++) {\n                    if (sum + stoneValue[k] > stoneValue[stoneValue.length - 1]) break;\n                    if (dp[k+j] != 0) continue;\n                    int[] newDP2 = new int[dp.length];\n                    System.arraycopy(dp, 0, newDP2, 0, dp.length);\n                    newDP2[k+j] = 1;\n\n                    canWin = !canIWin(k+1, j-k-1, newDP2, sum + stoneValue[k], stoneValue);\n\n                    if (canWin) break;\n                }\n\n                if (!canWin) return true;\n            }\n        }\n\n        return false;\n    }\n}",
  "1141": "```\nimport org.junit.Test;\n\npublic class Solution {\n    public int[] getWatchedVideos(int watchedVideoHours[][] , String[] queryUser) {\n        // Your solution here\n        return new int[0];\n    }\n\n    @Test\n    public void test1() {\n        Solution solution = new Solution();\n        int[][] watchedVideoHours = {{10,20},{30,40},{5,15}};\n        String[] queryUser = {\"joe\",\"john\"};\n        int[] result = solution.getWatchedVideos(watchedVideoHours,queryUser);\n        // Check if the result is correct\n    }\n\n    @Test\n    public void test2() {\n        Solution solution = new Solution();\n        int[][] watchedVideoHours = {{1,4},{3,7}};\n        String[] queryUser = {\"joe\"};\n        int[] result = solution.getWatchedVideos(watchedVideoHours,queryUser);\n        // Check if the result is correct\n    }\n\n    @Test\n    public void test3() {\n        Solution solution = new Solution();\n        int[][] watchedVideoHours = {{1,8},{2,15},{3,45}};\n        String[] queryUser = {\"brad\",\"joe\"};\n        int[] result = solution.getWatchedVideos(watchedVideoHours,queryUser);\n        // Check if the result is correct\n    }\n}",
  "1142": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<String[]> getActivities(String[] userIds) {\n        Map<String, List<String>> userActivities = new HashMap<>();\n        \n        for (String userId : userIds) {\n            // assume you have a method to get activities for the user\n            List<String> activities = getActivityForUser(userId);\n            userActivities.put(userId, activities);\n        }\n        \n        List<String[]> result = new ArrayList<>();\n        \n        for (Map.Entry<String, List<String>> entry : userActivities.entrySet()) {\n            String[] activityArray = new String[entry.getValue().size()];\n            for (int i = 0; i < entry.getValue().size(); i++) {\n                activityArray[i] = entry.getValue().get(i);\n            }\n            result.add(new String[]{entry.getKey(), Arrays.toString(activityArray)});\n        }\n        \n        return result;\n    }\n\n    private List<String> getActivityForUser(String userId) {\n        // implement your logic to get activities for the user\n        // for demonstration purposes, we'll just return a few dummy activities\n        List<String> activities = new ArrayList<>();\n        activities.add(\"Activity 1\");\n        activities.add(\"Activity 2\");\n        activities.add(\"Activity 3\");\n        return activities;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String[] userIds = {\"user1\", \"user2\"};\n        \n        List<String[]> result = solution.getActivities(userIds);\n        \n        for (String[] activity : result) {\n            System.out.println(\"User: \" + activity[0] + \", Activities: \" + activity[1]);\n        }\n    }\n}\n```",
  "1143": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestCommonSubsequence(\"abcde\", \"ace\")); // Output: 3\n        System.out.println(longestCommonSubsequence(\"fox\", \"pyx\")); // Output: 2\n        System.out.println(longestCommonSubsequence(\"abc\", \"def\")); // Output: 0\n    }\n\n    public static int longestCommonSubsequence(String str1, String str2) {\n        int m = str1.length();\n        int n = str2.length();\n\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 0;\n                } else if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n}",
  "1144": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arr1 = {{9,6,4}, {6,5,9}};\n        decreaseElements(arr1);\n        \n        int[][] arr2 = {{2,1,1},{3,2,1},{0,1,0}};\n        decreaseElements(arr2);\n\n        int[][] arr3 = {{17,13,10},{14,15,8},{11,16,6}};\n        decreaseElements(arr3);\n    }\n\n    public static void decreaseElements(int[][] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 1; j < arr[i].length; j++) {\n                if ((i % 2 == 0 && arr[i][j-1] > arr[i][j]) || (i % 2 != 0 && arr[i][j-1] < arr[i][j])) {\n                    arr[i][j] = arr[i][j-1];\n                }\n            }\n        }\n    }\n}\n```",
  "1145": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(5);\n\n        System.out.println(\"Test case 1: \" + solution(root1) + \"\\n\");\n\n        TreeNode root2 = new TreeNode(7);\n        root2.left = new TreeNode(8);\n        root2.right = new TreeNode(6);\n        root2.left.left = new TreeNode(2);\n        root2.left.right = new TreeNode(4);\n\n        System.out.println(\"Test case 2: \" + solution(root2) + \"\\n\");\n\n        TreeNode root3 = null;\n\n        System.out.println(\"Test case 3: \" + solution(root3));\n    }\n\n    public static int solution(TreeNode root) {\n        // Your code here\n        return 0;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}",
  "1146": "```\npublic class Main {\n    public static void main(String[] args) {\n        SnapshotArray snap = new SnapshotArray(5);\n        System.out.println(snap.get(0)); // prints: 0\n        System.out.println(snap.set(2, 4)); // prints: 0\n        System.out.println(snap.get(3)); // prints: 2\n        System.out.println(snap.get(4)); // prints: 4\n\n        snap = new SnapshotArray(1);\n        System.out.println(snap.get(0)); // prints: 0\n        snap.set(0, 10);\n        System.out.println(snap.get(0)); // prints: 10\n\n        snap = new SnapshotArray(2);\n        System.out.println(snap.get(0)); // prints: 0\n        System.out.println(snap.get(1)); // prints: 0\n        snap.set(1, 5);\n        System.out.println(snap.get(0)); // prints: 0\n        System.out.println(snap.get(1)); // prints: 5\n    }\n}\n\nclass SnapshotArray {\n    int[] arr;\n    int[][] snapshots;\n\n    public SnapshotArray(int length) {\n        arr = new int[length];\n        snapshots = new int[1][length];\n        for (int i = 0; i < length; i++) {\n            arr[i] = 0;\n            snapshots[0][i] = 0;\n        }\n    }\n\n    public int get(int index) {\n        return Math.min(arr[index], snapshots[0][index]);\n    }\n\n    public void set(int index, int val) {\n        int prevVal = arr[index];\n        arr[index] = val;\n        if (snapshots.length < 2) {\n            snapshots = new int[snapshots.length * 2][arr.length];\n            System.arraycopy(snapshots[0], 0, snapshots[1], 0, arr.length);\n        }\n        System.arraycopy(arr, 0, snapshots[snapshots.length - 1], 0, arr.length);\n    }\n}\n```",
  "1147": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestPalindrome(\"aabbaa\")); // expected output: 4\n        System.out.println(longestPalindrome(\"a\")); // expected output: 1\n        System.out.println(longestPalindrome(\"babad\")); // expected output: 3\n    }\n\n    public static int longestPalindrome(String s) {\n        if (s == null || s.length() < 1) return 0;\n        int res = 0, n = s.length(), mid = 0, i = 0, j = 0;\n        while (i <= j && j < n) {\n            while (j + 1 < n && s.charAt(i) == s.charAt(j + 1)) j++;\n            if (s.charAt(i) == s.charAt(j))\n                res += (j - i + 1);\n            else\n                mid = j, j = --i;\n        }\n        return res + ((n > 1) ? (mid % 2 != n - 1 ? 1 : 0) : 0);\n    }\n}",
  "1148": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] views = { {1, 2}, {3, 5}, {6, 0} };\n        System.out.println(\"Views: \" + Arrays.deepToString(views));\n        System.out.println(\"Expected: [7, 5]\");\n\n        int[][] views1 = { {4, 8}, {11, 12}, {13, 15}, {15, 23}, {24, 27} };\n        System.out.println(\"\\nViews: \" + Arrays.deepToString(views1));\n        System.out.println(\"Expected: [28, 43]\");\n\n        int[][] views2 = { {5, 4}, {100, -20}, {150, 60} };\n        System.out.println(\"\\nViews: \" + Arrays.deepToString(views2));\n        System.out.println(\"Expected: [105, 40]\");\n    }\n}\n```",
  "1149": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int views1 = solution.viewed(1000, \"A\");\n        System.out.println(\"Views after 1000 reads of A: \" + views1);\n        \n        int views2 = solution.viewed(500, \"B\");\n        System.out.println(\"Views after 500 reads of B: \" + views2);\n        \n        int views3 = solution.viewed(2000, \"A\");\n        System.out.println(\"Views after 2000 reads of A: \" + views3);\n    }\n}\n\nclass Solution {\n    public int viewed(int views, String article) {\n        // Your code here\n    }\n}\n```",
  "1150": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(checkMajority(new int[]{2,7,11,19}, 5)); // Expected: false\n        System.out.println(checkMajority(new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24}, 5)); // Expected: true\n        System.out.println(checkMajority(new int[]{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24}, 25)); // Expected: false\n    }\n\n    public static boolean checkMajority(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                // Check the majority\n                if (mid == nums.length - 1 || nums[mid] != nums[mid + 1]) {\n                    return true;\n                }\n                right = mid - 1;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return false;\n    }\n}\n```",
  "1151": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {0, 0, 1, 0, 1};\n        System.out.println(minSwaps(arr1)); // Output: 4\n\n        int[] arr2 = {0, 1, 1, 0, 1};\n        System.out.println(minSwaps(arr2)); // Output: 3\n\n        int[] arr3 = {0, 1, 0, 0, 1, 1, 1, 0, 1, 1};\n        System.out.println(minSwaps(arr3)); // Output: 7\n    }\n\n    public static int minSwaps(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 1) continue;\n\n            int j = i;\n            while (j < n && nums[j] != 1) j++;\n            if (j >= n) return -1; // impossible to group all 1's\n\n            for (int k = i; k <= j; k++) {\n                nums[k] = 2; // mark as processed\n            }\n\n            ans += j - i;\n        }\n        return ans;\n    }\n}\n```",
  "1152": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = {\n            {2017, 12, 11, \"userA\", \"home\"},\n            {2018, 1, 15, \"userB\", \"news\"},\n            {2019, 3, 24, \"userA\", \"home\"},\n            {2019, 4, 19, \"userA\", \"home\"},\n            {2020, 5, 31, \"userC\", \"work\"},\n            {2021, 7, 2, \"userB\", \"online\"},\n        };\n\n        int[][] result = findKeysWithVisitPattern(logs);\n\n        for (int[] log : result) {\n            System.out.println(Arrays.toString(log));\n        }\n    }\n\n    public static int[][] findKeysWithVisitPattern(int[][] logs) {\n        // Your code goes here\n        return new int[0][];\n    }\n}",
  "1153": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canTransform(\"abc\", \"axc\")); // True\n        System.out.println(canTransform(\"aabcc\", \"cab\")); // False\n        System.out.println(canTransform(\"xyxzzyx\", \"zzy\")); // True\n    }\n\n    public static boolean canTransform(String s, String t) {\n        int[] countS = new int[26];\n        int[] countT = new int[26];\n\n        for (int i = 0; i < s.length(); i++) {\n            countS[s.charAt(i) - 'a']++;\n            countT[t.charAt(i) - 'a']++;\n        }\n\n        for (int i = 0; i < 26; i++) {\n            if (countS[i] != countT[i]) return false;\n        }\n        return true;\n    }\n}\n```",
  "1155": "```\npublic class Main {\n    public static void main(String[] args) {\n        int numRolls1 = numRolls(2, 6, 7);\n        System.out.println(\"Test case 1: \" + numRolls1);\n\n        int numRolls2 = numRolls(5, 6, 3);\n        System.out.println(\"Test case 2: \" + numRolls2);\n\n        int numRolls3 = numRolls(1, 6, 8);\n        System.out.println(\"Test case 3: \" + numRolls3);\n    }\n\n    public static int numRolls(int n, int k, int target) {\n        // Your code here\n        int[][] dp = new int[n+1][target+1];\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= target; j++) {\n                if (j < k) {\n                    dp[i][j] = dp[i-1][j];\n                } else {\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-k];\n                }\n            }\n        }\n        return dp[n][target];\n    }\n}\n```",
  "1154": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(dayOfTheYear(2000, \"february\", 2)); // Expected: 32\n        System.out.println(dayOfTheYear(1999, \"june\", 30)); // Expected: 151\n        System.out.println(dayOfTheYear(2015, \"july\", 12)); // Expected: 192\n    }\n\n    public static int dayOfTheYear(int year, String month, int day) {\n        if (month.equals(\"january\") || month.equals(\"march\") || month.equals(\"may\") || month.equals(\"july\") || month.equals(\"august\") || month.equals(\"october\") || month.equals(\"december\")) {\n            return 31 * (day / 31) + day % 31;\n        } else if (month.equals(\"april\") || month.equals(\"june\") || month.equals(\"september\") || month.equals(\"november\")) {\n            return 30 * (day / 30) + day % 30;\n        } else if (month.equals(\"february\")) {\n            return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0 ? 29 : 28;\n        }\n        return -1; // invalid month\n    }\n}",
  "1156": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(swapForLongestRepeatedCharacterSubstring(\"abba\", \"abcde\"));\n        System.out.println(swapForLongestRepeatedCharacterSubstrings(\"aabcc\", \"xyzneocd\"));\n        System.out.println(swapForLongestRepeatedCharacterSubstring(\"aa\", \"itcv Bartoli\"));\n\n\n    }\n\n    public static String swapForLongestRepeatedCharacterSubstring(String str1, String str2) {\n        int maxLen = 0;\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < str1.length(); i++) {\n            char c = str1.charAt(i);\n            if (str2.contains(String.valueOf(c))) {\n                int index = str2.indexOf(String.valueOf(c));\n                if (i + 1 > maxLen) {\n                    sb.setLength(0);\n                    for (int j = 0; j <= i; j++) {\n                        sb.append(str1.charAt(j));\n                    }\n                    sb.append(c);\n                    for (int j = index - i; j >= 0 && j < str2.length(); j--) {\n                        sb.append(str2.charAt(j));\n                    }\n                    maxLen = i + 1;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "1157": "```\npublic class Main {\n    public static void main(String[] args) {\n        MajorityChecker checker = new MajorityChecker(new int[][]{{0,1},{1,1},{2,1}});\n        \n        System.out.println(checker.query(0, 1)); // Output: 0\n        System.out.println(checker.query(4, 8)); // Output: 1\n        System.out.println(checker.query(3, 5)); // Output: -1\n    }\n}\n\nclass MajorityChecker {\n    int[][] array;\n    TrieNode[] trie;\n\n    public MajorityChecker(int[] arr) {\n        this.array = new int[arr.length][];\n        for (int i = 0; i < arr.length; i++) {\n            array[i] = new int[]{i, arr[i]};\n        }\n        Arrays.sort(array, (a, b) -> a[1] - b[1]);\n        trie = new TrieNode[256];\n        for (int[] pair : array) {\n            TrieNode node = trie;\n            for (int i = 0; i < 30; i++) {\n                int mask = 1 << i;\n                if (((pair[1] >> i) & mask) == 0) {\n                    node = node.children[0];\n                } else {\n                    node = node.children[1];\n                }\n            }\n            node.count++;\n        }\n    }\n\n    public int query(int left, int right) {\n        TrieNode node = trie;\n        for (int i = 29; i >= 0; i--) {\n            int mask = 1 << i;\n            if (((right >> i) & mask) == 0 && node.children[0].count > node.children[1].count) {\n                right ^= mask;\n            } else if (((left >> i) & mask) != 0 && node.children[1].count > node.children[0].count) {\n                left ^= mask;\n            }\n            node = node.children[(right >>> i) & 1];\n        }\n        return array[getIdx(left, right)][1];\n    }\n\n    int getIdx(int left, int right) {\n        for (int i = 0; i < array.length; i++) {\n            if (array[i][0] >= left) {\n                if (array[i][0] <= right) {\n                    return i;\n                }\n                break;\n            }\n        }\n        return array.length - 1;\n    }\n\n    class TrieNode {\n        int count;\n        TrieNode[] children = new TrieNode[2];\n    }\n}",
  "1158": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + analyzeStocks(new String[]{\"MAX\", \"WAYF\"}, new int[]{10, 50}, new int[]{2, 5}));\n        System.out.println(\"Test Case 2: \" + analyzeStocks(new String[]{\"APPL\", \"GOOG\"}, new int[]{100, 200}, new int[]{1, 3}));\n        System.out.println(\"Test Case 3: \" + analyzeStocks(new String[]{\"AAPL\", \"MSFT\"}, new int[]{50, 75}, new int[]{4, 5}));\n\n    }\n\n    public static double analyzeStocks(String[] stocks, int[] ratings, int[] weights) {\n        // your code here\n        return 0.0; \n    }\n}\n```",
  "1159": "```\npublic class Main {\n    public static void main(String[] args) {\n        testMarketAnalysisII(\"leetcode\", new String[]{\"leetcode\",\"google\",\"facebook\"}); // Test case 1\n        testMarketAnalysisII(\"leetcode\", new String[]{\"leetcode\",\"google\",\"leetcode\"});\n\n        // Test case 3\n        int[][] marketAnalyses = {{0,1},{1,2},{2,0}};\n        testMarketAnalysisII(marketAnalyses);\n    }\n\n    public static void testMarketAnalysisII(String companyOrIDs[], Object... params) {\n        if (companyOrIDs.length == 1) {\n            System.out.println(\"Test Case 1: \" + getHint(companyOrIDs[0], (String[])params));\n        } else {\n            for (int i = 0; i < companyOrIDs.length; i++) {\n                String companyID = companyOrIDs[i];\n                Object[] paramArr = ((Object[])params)[i].toArray();\n                System.out.println(\"Test Case \" + (i+1) + \": \" + getHint(companyID, (String[])paramArr));\n            }\n        }\n    }\n\n    public static int getHint(String companyID, String[] productIDs) {\n        // Your logic here\n        return 0;\n    }\n}\n```",
  "1160": "```\nimport java.util.*;\n\npublic class FindWords {\n    public static List<String> findWords(String[] words, String root) {\n        Map<Character, Integer> rootCount = new HashMap<>();\n        for (char c : root.toLowerCase().toCharArray()) {\n            rootCount.put(c, rootCount.getOrDefault(c, 0) + 1);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            Map<Character, Integer> wordCount = new HashMap<>();\n            for (char c : word.toLowerCase().toCharArray()) {\n                wordCount.put(c, wordCount.getOrDefault(c, 0) + 1);\n            }\n            if (isSubsequence(rootCount, wordCount)) {\n                result.add(word);\n            }\n        }\n\n        return result;\n    }\n\n    public static boolean isSubsequence(Map<Character, Integer> rootCount, Map<Character, Integer> wordCount) {\n        for (Map.Entry<Character, Integer> entry : rootCount.entrySet()) {\n            if (!wordCount.containsKey(entry.getKey()) || entry.getValue() > wordCount.getOrDefault(entry.getKey(), 0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        String[] words = {\"amazon\", \"apple\", \"banana\", \"avocado\"};\n        String root = \"apple\";\n        List<String> result = findWords(words, root);\n        System.out.println(result);\n\n        words = new String[]{\"a\", \"b\", \"c\", \"d\", \"e\"};\n        root = \"ae\";\n        result = findWords(words, root);\n        System.out.println(result);\n\n        words = new String[]{\"apple\", \"apricot\", \"banana\", \"avocado\", \"peach\"};\n        root = \"apple\";\n        result = findWords(words, root);\n        System.out.println(result);\n    }\n}",
  "1161": "```\nclass Solution {\n    public int maxLevelSum(TreeNode root) {\n        if (root == null) return 0;\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int maxSum = Integer.MIN_VALUE, level = 1;\n        \n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            int sum = 0;\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                sum += node.val;\n                \n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            \n            if (sum > maxSum) {\n                maxSum = sum;\n                level = 1 + (int) Math.ceil(Math.log10(size));\n            }\n        }\n        \n        return level;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        TreeNode node1 = new TreeNode(1);\n        node1.left = new TreeNode(14);\n        node1.right = new TreeNode(0);\n        System.out.println(\"Test Case 1: \" + solution.maxLevelSum(node1)); // Expected output: 2\n\n        TreeNode node2 = new TreeNode(4);\n        node2.left = new TreeNode(7);\n        node2.right = new TreeNode(5);\n        node2.left.left = new TreeNode(-3);\n        System.out.println(\"Test Case 2: \" + solution.maxLevelSum(node2)); // Expected output: 2\n\n        TreeNode node3 = new TreeNode(5);\n        node3.left = new TreeNode(4);\n        node3.right = new TreeNode(8);\n        node3.left.left = new TreeNode(-4);\n        node3.left.right = new TreeNode(6);\n        System.out.println(\"Test Case 3: \" + solution.maxLevelSum(node3)); // Expected output: 3\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n```",
  "1162": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,0,0},{0,1,0},{0,0,0}};\n        System.out.println(\"Case 1: \" + maxDistance(grid1));\n        \n        int[][] grid2 = {{0,0,0},{0,1,0},{0,0,1}};\n        System.out.println(\"Case 2: \" + maxDistance(grid2));\n        \n        int[][] grid3 = {{1,1,1},{1,0,1},{1,1,1}};\n        System.out.println(\"Case 3: \" + maxDistance(grid3));\n    }\n\n    public static int maxDistance(int[][] grid) {\n        if (grid == null || grid.length == 0) return 0;\n        \n        int rows = grid.length, cols = grid[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        int maxDist = 0;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (!visited[i][j] && grid[i][j] == 0) {\n                    Queue<int[]> queue = new LinkedList<>();\n                    int dist = bfs(grid, visited, queue, i, j);\n                    maxDist = Math.max(maxDist, dist);\n                }\n            }\n        }\n        \n        return maxDist;\n    }\n\n    public static int bfs(int[][] grid, boolean[][] visited, Queue<int[]> queue, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || !grid[i][j] || visited[i][j]) return 0;\n        \n        visited[i][j] = true;\n        int dist = 1;\n        \n        queue.offer(new int[]{i, j});\n        \n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            i = cur[0]; j = cur[1];\n            \n            for (int k = -1; k <= 1; k++) {\n                for (int l = -1; l <= 1; l++) {\n                    if ((k == 0 && l == 0) || Math.abs(k) + Math.abs(l) > 1) continue;\n                    \n                    int ni = i + k, nj = j + l;\n                    if (ni < 0 || ni >= grid.length || nj < 0 || nj >= grid[0].length) continue;\n                    \n                    if (!visited[ni][nj] && !grid[ni][nj]) {\n                        visited[ni][nj] = true;\n                        queue.offer(new int[]{ni, nj});\n                        dist++;\n                    }\n                }\n            }\n        }\n        \n        return dist;\n    }\n}",
  "1163": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(lastSubstring(\"abc\", \"cba\")); // expected output: \"bc\"\n        System.out.println(lastSubstring(\"zyxwvutsrqponmlkjihgfedcb\", \"cba\")); // expected output: \"zyxwvu\"\n        System.out.println(lastSubstring(\"abcdz\", \"zxcba\")); // expected output: \"cdz\"\n    }\n\n    public static String lastSubstring(String s, String t) {\n        int n = s.length();\n        int m = t.length();\n        int i = 0, j = 0;\n        StringBuilder sb = new StringBuilder();\n\n        while (i < n && j < m) {\n            if (s.charAt(i) <= t.charAt(j)) {\n                sb.append(s.charAt(i));\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        while (i < n) {\n            sb.append(s.charAt(i));\n            i++;\n        }\n\n        return sb.toString();\n    }\n}",
  "1165": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSteps(\"hello\")); // Expected: 1\n        System.out.println(minSteps(\"world\")); // Expected: 2\n        System.out.println(minSteps(\"leetcode\")); // Expected: 0\n    }\n\n    public static int minSteps(String s) {\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n        }\n        int res = 0;\n        for (int i = 0; i < 26; i++) {\n            res += Math.max(0, (count[i] + 1) / 2);\n        }\n        return res;\n    }\n}",
  "1164": "```\npublic class Solution {\n    public double[] productPrices(int[] prices, String date) {\n        // Your solution here\n    }\n\n    public static void main(String[] args) {\n        int[] prices = {10, 7, 5, 8, 23, 13};\n        String[] dates = {\"2019-01-01\", \"2020-06-15\", \"2021-03-31\"};\n\n        Solution solution = new Solution();\n\n        double[] results = null;\n\n        for (int i = 0; i < prices.length; i++) {\n            results = solution.productPrices(new int[]{prices[i]}, dates[0]);\n            System.out.println(\"Price: \" + prices[i] + \", Date: \" + dates[0] + \", Product Price at this date: \" + results[1]);\n\n            results = solution.productPrices(new int[]{prices[i]}, dates[1]);\n            System.out.println(\"Price: \" + prices[i] + \", Date: \" + dates[1] + \", Product Price at this date: \" + results[1]);\n\n            results = solution.productPrices(new int[]{prices[i]}, dates[2]);\n            System.out.println(\"Price: \" + prices[i] + \", Date: \" + dates[2] + \", Product Price at this date: \" + results[1]);\n        }\n    }\n}",
  "1167": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] sticks1 = {{1,2},{2,3},{3,4},{1,4}};\n        System.out.println(\"Minimum cost to connect sticks for \" + sticks1.length + \" sticks: \" + connectSticks(sticks1));\n        \n        int[][] sticks2 = {{0,6},{1,3},{2,8},{3,5},{3,7},{2,5},{1,4},{0,2},{10,12},{9,11}};\n        System.out.println(\"Minimum cost to connect sticks for \" + sticks2.length + \" sticks: \" + connectSticks(sticks2));\n        \n        int[][] sticks3 = {{0,0}};\n        System.out.println(\"Minimum cost to connect sticks for 1 stick: \" + connectSticks(sticks3));\n    }\n\n    public static int connectSticks(int[][] sticks) {\n        if (sticks.length == 0) return 0;\n        if (sticks.length == 1) return 0;\n\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> a - b);\n        for (int[] stick : sticks) {\n            heap.offer(stick[1]);\n        }\n        int cost = 0;\n        while (heap.size() > 1) {\n            int stick1 = heap.poll();\n            int stick2 = heap.poll();\n            cost += stick1 + stick2;\n            heap.offer(stick1 + stick2);\n        }\n\n        return cost;\n    }\n}\n```",
  "1166": "```\nimport java.util.*;\n\npublic class FileSystem {\n    private Map<String, Node> root;\n    private static final String SEPARATOR = \"/\";\n\n    public FileSystem() {\n        this.root = new HashMap<>();\n    }\n\n    public List<String[]> ls(String path) {\n        List<String[]> result = new ArrayList<>();\n        if (path.isEmpty()) {\n            return listDirectory(this.root, result);\n        }\n        Node node = getNode(root, path.split(SEPARATOR));\n        if (node != null) {\n            listDirectory(node, result);\n        }\n        return result;\n    }\n\n    private Node getNode(Map<String, Node> root, String[] parts) {\n        Node node = root;\n        for (String part : parts) {\n            if (!node.containsKey(part)) {\n                return null;\n            }\n            node = node.get(part);\n        }\n        return node;\n    }\n\n    private List<String[]> listDirectory(Node node, List<String[]> result) {\n        if (node.isDirectory()) {\n            for (Map.Entry<String, Node> entry : node.entrySet()) {\n                result.add(new String[]{entry.getKey()});\n            }\n        }\n        return result;\n    }\n\n    public boolean mkdir(String path) {\n        Node node = getNode(root, path.split(SEPARATOR));\n        if (node == null) {\n            return false;\n        }\n        String[] parts = path.split(SEPARATOR);\n        for (int i = 1; i < parts.length; i++) {\n            String part = parts[i];\n            Map<String, Node> children = node.computeIfAbsent(part, k -> new HashMap<>());\n        }\n        return true;\n    }\n\n    public boolean addContentToFile(String filePath, String content) {\n        Node node = getNode(root, filePath.split(SEPARATOR));\n        if (node == null || !node.isDirectory()) {\n            return false;\n        }\n        Node fileNode = node.computeIfAbsent(filePath.substring(filePath.lastIndexOf(SEPARATOR) + 1), k -> new FileNode());\n        fileNode.setContent(fileNode.getContent() + content);\n        return true;\n    }\n\n    public String readContentFromFile(String filePath) {\n        Node node = getNode(root, filePath.split(SEPARATOR));\n        if (node == null || !node.isDirectory()) {\n            return \"\";\n        }\n        Node fileNode = node.get(filePath.substring(filePath.lastIndexOf(SEPARATOR) + 1));\n        if (fileNode instanceof FileNode) {\n            return ((FileNode) fileNode).getContent();\n        } else {\n            return \"\";\n        }\n    }\n\n    public static void main(String[] args) {\n        FileSystem fileSystem = new FileSystem();\n\n        // Test case 1\n        fileSystem.mkdir(\"/a/b/c\");\n        fileSystem.addContentToFile(\"/a/b/file1.txt\", \"Hello\");\n        System.out.println(Arrays.deepToString(fileSystem.ls(\"/\").clone()));\n        System.out.println(fileSystem.readContentFromFile(\"/a/b/file1.txt\"));\n        fileSystem.mkdir(\"/e/f\");\n\n        // Test case 2\n        fileSystem.mkdir(\"/a/d/e/f\");\n        fileSystem.addContentToFile(\"/a/d/file2.txt\", \"Hello, world!\");\n        System.out.println(Arrays.deepToString(fileSystem.ls(\"/\").clone()));\n        System.out.println(fileSystem.readContentFromFile(\"/a/d/file2.txt\"));\n\n        // Test case 3\n        fileSystem.mkdir(\"/a/b/c/d\");\n        fileSystem.addContentToFile(\"/a/b/file3.txt\", \"This is a test.\");\n        System.out.println(Arrays.deepToString(fileSystem.ls(\"/\").clone()));\n        System.out.println(fileSystem.readContentFromFile(\"/a/b/file3.txt\"));\n    }\n}\n\nclass Node {\n    private Map<String, Node> children;\n    private String content;\n\n    public Node() {\n        this.children = new HashMap<>();\n    }\n\n    public boolean isDirectory() {\n        return children != null && !content.isEmpty();\n    }\n\n    public void setChildren(Map<String, Node> children) {\n        this.children = children;\n    }\n\n    public Map<String, Node> getChildren() {\n        return children;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n}\n\nclass FileNode extends Node {\n\n}",
  "1168": "```\nimport java.util.PriorityQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] edges1 = {{0,1,1},{1,2,1},{2,3,1},{3,4,1},{5,6,1}};\n        System.out.println(\"Test Case 1: \" + optimizeWaterDistribution(4, edges1));\n        \n        int[][] edges2 = {{0,1,10},{1,2,2},{2,3,4}};\n        System.out.println(\"Test Case 2: \" + optimizeWaterDistribution(3, edges2));\n\n        int[][] edges3 = {{0,1,5},{1,2,9},{2,3,7},{4,5,14},{8,9,6},{7,10,4}};\n        System.out.println(\"Test Case 3: \" + optimizeWaterDistribution(10, edges3));\n    }\n\n    public static int optimizeWaterDistribution(int n, int[][] edges) {\n        // your solution here\n    }\n}\n```",
  "1169": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] transactions1 = {{1, 2}, {2, 3}, {3, 1}};\n        System.out.println(\"Test case 1: \" + findInvalidTransactions(transactions1));\n        \n        int[][] transactions2 = {{1, 1}, {2, 3}, {3, 1}};\n        System.out.println(\"Test case 2: \" + findInvalidTransactions(transactions2));\n        \n        int[][] transactions3 = {{1, 2}, {2, 3}};\n        System.out.println(\"Test case 3: \" + findInvalidTransactions(transactions3));\n    }\n\n    public static List<Integer> findInvalidTransactions(int[][] transactions) {\n        // Your code here\n    }\n}\n```",
  "1170": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(compareStrings(\"tree\", \"apple\")); // Expected: 0\n        System.out.println(compareStrings(\"kinko\", \"adventure\")); // Expected: -1\n        System.out.println(compareStrings(\"leetcode\", \"practice\")); // Expected: 1\n    }\n\n    public static int compareStrings(String word1, String word2) {\n        int[] count1 = new int[26];\n        int[] count2 = new int[26];\n\n        for (char c : word1.toLowerCase().toCharArray()) {\n            count1[c - 'a']++;\n        }\n        for (char c : word2.toLowerCase().toCharArray()) {\n            count2[c - 'a']++;\n        }\n\n        int diff = Integer.compare(getMinCount(count1), getMinCount(count2));\n        if (diff == 0) {\n            return Integer.compare(word1.length(), word2.length());\n        } else {\n            return diff;\n        }\n    }\n\n    public static int getMinCount(int[] count) {\n        int min = Integer.MAX_VALUE;\n        for (int i : count) {\n            if (i < min) {\n                min = i;\n            }\n        }\n        return min;\n    }\n}\n```",
  "1171": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test case 1: [4,2,3]\n        ListNode head1 = new ListNode(4);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(3);\n        removeZeroSumConsecutiveNodes(head1);\n\n        // Test case 2: [1,2,-3,3,1]\n        ListNode head2 = new ListNode(1);\n        head2.next = new ListNode(2);\n        head2.next.next = new ListNode(-3);\n        head2.next.next.next = new ListNode(3);\n        head2.next.next.next.next = new ListNode(1);\n        removeZeroSumConsecutiveNodes(head2);\n\n        // Test case 3: [1,5,-4]\n        ListNode head3 = new ListNode(1);\n        head3.next = new ListNode(5);\n        head3.next.next = new ListNode(-4);\n        removeZeroSumConsecutiveNodes(head3);\n    }\n\n    public static void removeZeroSumConsecutiveNodes(ListNode head) {\n        // Your solution here\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n```",
  "1172": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        DinnerPlateStacks d = new DinnerPlateStacks();\n        System.out.println(d.highestStack(new int[][]{{2,1},{0,3}})); // expected output: 3\n        System.out.println(d.highestStack(new int[][]{})); // expected output: -1\n        System.out.println(d.highestStack(new int[][]{{1,5},{4,3},{7,6},{8,4},{6,3}})); // expected output: 4\n    }\n}\n```",
  "1173": "```\npublic class Main {\n    public static void main(String[] args) {\n        ImmediateFoodDelivery immediateFoodDelivery = new ImmediateFoodDelivery();\n        \n        // Test case 1: \n        int[][] orders1 = {{1,2},{5,0},{6,0}};\n        System.out.println(\"Test case 1: \" + immediateFoodDelivery.orderFood(orders1));\n        \n        // Test case 2:\n        int[][] orders2 = {{10,2},{11,2},{12,3},{13,2},{14,2}};\n        System.out.println(\"Test case 2: \" + immediateFoodDelivery.orderFood(orders2));\n        \n        // Test case 3:\n        int[][] orders3 = {{1,6},{2,1}};\n        System.out.println(\"Test case 3: \" + immediateFoodDelivery.orderFood(orders3));\n    }\n}\n\nclass ImmediateFoodDelivery {\n    public int orderFood(int[][] orders) {\n        Arrays.sort(orders, (a, b) -> a[0] - b[0]);\n        \n        for (int[] order : orders) {\n            if (order[1] > 0) {\n                return order[0];\n            }\n        }\n        \n        return -1;\n    }\n}\n```",
  "1174": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] orders1 = {{10, \"A\"}, {5, \"B\"}, {5, \"C\"}};\n        System.out.println(\"Result for orders1: \" + immediateFoodDelivery(orders1));\n        \n        int[][] orders2 = {{3, \"E\"}, {2, \"F\"}, {4, \"G\"}};\n        System.out.println(\"Result for orders2: \" + immediateFoodDelivery(orders2));\n        \n        int[][] orders3 = {{5, \"A\"}, {10, \"B\"}, {20, \"C\"}};\n        System.out.println(\"Result for orders3: \" + immediateFoodDelivery(orders3));\n    }\n\n    public static String immediateFoodDelivery(int[][] orders) {\n        // Your solution here\n    }\n}",
  "1175": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numPrimeArrangements(10));\n        \n        System.out.println(numPrimeArrangements(25));\n        \n        System.out.println(numPrimeArrangements(1000000));\n    }\n}\n```",
  "1176": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] calories = new int[][]{{1,2},{3,5},{4,6}};\n        System.out.println(\"Expected: \" + maxPerformance(calories, 3, 5));\n        System.out.println(\"Expected: \" + maxPerformance(new int[][]{{10,12},{7,5},{9,8}},{0,1}, 10));\n        System.out.println(\"Expected: \" + maxPerformance(new int[][]{{1,2},{4,5},{6,7}},{1,3}, 10));\n    }\n\n    public static double maxPerformance(int[][] calories, int minCapacity, int maxCalories) {\n        // Your logic here\n    }\n}\n```",
  "1177": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canMakePalindrome(\"abcba\", true)); // Expected: true\n        System.out.println(canMakePalindrome(\"abccba\", false)); // Expected: false\n        System.out.println(canMakePalindrome(\"abcd\", true)); // Expected: true\n    }\n\n    public static boolean canMakePalindrome(String s, boolean isPrint) {\n        int[] count = new int[256];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i)]++;\n        }\n        \n        int oddCount = 0;\n        for (int i = 0; i < 256; i++) {\n            if ((count[i] % 2) != 0) {\n                oddCount++;\n            }\n            if (oddCount > 1) {\n                return false;\n            }\n        }\n        \n        if (isPrint) System.out.println(\"Can make palindrome: \" + (oddCount <= 1));\n        return oddCount <= 1;\n    }\n}",
  "1178": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.deepToString(wordEquivalents(new String[]{\"acca\", \"cbad\"}, new String[][]{{\"a\", \"b\"}, {\"c\", \"d\"}})));\n        System.out.println(Arrays.deepToString(wordEquivalents(new String[]{\"with\",\"like\",\"hello\",\"frend\"}, new String[][]{{\"wht\",\"wift\",\"wel\",\"frend\"},{\"ithe\",\"ithin\"},\"\"}}));\n        System.out.println(Arrays.deepToString(wordEquivalent(new String[]{\"a\", \"b\"}, new String[][]{{\"a\", \"b\"}},{\"helo\"})));\n    }\n\n    public static String[] wordEquivalents(String[] words, String[][] puzzles) {\n        Map<String, Integer> puzzleIndexMap = new HashMap<>();\n        for (int i = 0; i < puzzles.length; i++) {\n            for (String s : puzzles[i]) {\n                if (!puzzleIndexMap.containsKey(s)) {\n                    puzzleIndexMap.put(s, i);\n                }\n            }\n        }\n\n        Map<String, Integer> wordCountMap = new HashMap<>();\n        for (String word : words) {\n            int puzzleIndex = 0;\n            boolean isValidWord = true;\n            for (int i = 0; i < puzzles.length && isValidWord; i++) {\n                String[] puzzle = puzzles[i];\n                for (int j = 0; j < puzzle.length; j++) {\n                    if (word.startsWith(puzzle[j])) {\n                        puzzleIndex = i;\n                        break;\n                    }\n                }\n            }\n            wordCountMap.putOrDefault(word, puzzleIndex, 0);\n        }\n\n        String[] result = new String[wordCountMap.size()];\n        int i = 0;\n        for (String word : wordCountMap.keySet()) {\n            result[i++] = word + \":\" + wordCountMap.get(word);\n        }\n        return result;\n    }\n}",
  "1179": "```\npublic class Solution {\n    public String reformatDepartment(String department) {\n        return null; // implement this method\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(\"Test Case 1:\");\n        System.out.println(solution.reformatDepartment(\"Heart Surgery-Cardiovascular & Thoracic Surgery\")); \n        System.out.println();\n        \n        System.out.println(\"Test Case 2:\");\n        System.out.println(solution.reformatDepartment(\"Surgery-Radiology-Cardiovascular & Thoracic Surgery\")); \n        System.out.println();\n        \n        System.out.println(\"Test Case 3:\");\n        System.out.println(solution.reformatDepartment(\"Neurosurgery-Neuro Intensive Care Unit-NICU\")); \n    }\n}\n```",
  "1180": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countLetters(\"abc\")); // expected output: 2\n        System.out.println(countLetters(\"aaa\")); // expected output: 1\n        System.out.println(countLetters(\"abcdefg\")); // expected output: 0\n    }\n\n    public static int countLetters(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            char c1 = s.charAt(i);\n            char c2 = s.charAt(i + 1);\n            if (c1 == c2) {\n                count++;\n                while (i + 1 < s.length() && s.charAt(i + 1) == c2) {\n                    i++;\n                }\n            }\n        }\n        return count;\n    }\n}",
  "1181": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(new int[]{1,4}, new int[]{2,1,3,5})); // true\n        System.out.println(canBeEqual(new int[]{1,3}, new int[]{2,1,3})); // false\n        System.out.println(canBeEqual(new int[]{1,2,3}, new int[]{1,3,2})); // true\n    }\n\n    public static boolean canBeEqual(int[] before, int[] after) {\n        if(before.length != after.length) return false;\n        \n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i = 0; i < before.length; i++) {\n            if(map.containsKey(after[i])) {\n                int originalIndex = map.get(after[i]);\n                if(originalIndex != i) return false;\n            } else {\n                map.put(after[i], i);\n            }\n        }\n        \n        return true;\n    }\n}\n```",
  "1183": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxOnes(new int[]{0,1,0,1,0,0,1,1,1,1})); // Expected output: 5\n        System.out.println(maxOnes(new int[]{0,11,0,1,1,1,2,22,3,3,4,4,10,10,5,5,6,6,7,7,15,15,16,16})); // Expected output: 25\n        System.out.println(maxOnes(new int[]{0,0,0,0,0,0,1,2,3,4,5})); // Expected output: 10\n    }\n\n    public static int maxOnes(int[] nums) {\n        Arrays.sort(nums);\n        int maxCount = 0;\n        int count = 0;\n\n        for (int num : nums) {\n            if (num == 1) {\n                count++;\n            } else {\n                maxCount += count;\n                count = 0;\n            }\n        }\n\n        return maxCount + count;\n    }\n}",
  "1182": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] colors = {{1, 1, 0}, {0, 1, 0}, {1, 0, 0}};\n        int targetColor = 0;\n        System.out.println(shortestDistance(colors, targetColor));\n        \n        int[][] colors2 = {{0, 0, 0}, {1, 1, 1}};\n        int targetColor2 = 1;\n        System.out.println(shortestDistance(colors2, targetColor2));\n\n        int[][] colors3 = {{1, 0, 1}};\n        int targetColor3 = 1;\n        System.out.println(shortestDistance(colors3, targetColor3));\n    }\n\n    public static int shortestDistance(int[][] colors, int targetColor) {\n        int minDist = Integer.MAX_VALUE;\n        for (int i = 0; i < colors.length; i++) {\n            for (int j = 0; j < colors[0].length; j++) {\n                if (colors[i][j] == targetColor) {\n                    int distLeft = i == 0 ? 0 : 1;\n                    int distRight = i == colors.length - 1 ? 0 : 1;\n                    for (int k = 0; k < i; k++) {\n                        if (colors[k][j] != targetColor) distLeft++;\n                    }\n                    for (int k = i + 1; k < colors.length; k++) {\n                        if (colors[k][j] != targetColor) distRight++;\n                    }\n                    minDist = Math.min(minDist, Math.min(distLeft, distRight));\n                }\n            }\n        }\n        return minDist;\n    }\n}",
  "1184": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(distanceBetweenBusStops(new int[][]{{1,2},{5,7}})); // Output: 6\n        System.out.println(distanceBetweenBusStops(new int[][]{{3,6},{9,12}})); // Output: 4\n        System.out.println(distanceBetweenBusStops(new int[][]{{0,1},{2,3}})); // Output: 2\n    }\n\n    public static int distanceBetweenBusStops(int[][] distance) {\n        int totalDistance = 0;\n        for (int i = 0; i < distance.length - 1; i++) {\n            totalDistance += Math.min(distance[i][1], distance[i+1][0]);\n        }\n        return totalDistance;\n    }\n}\n```",
  "1185": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(dayOfWeek(12, 25)); // Should print \"Saturday\"\n        System.out.println(dayOfWeek(1, 4)); // Should print \"Tuesday\"\n        System.out.println(dayOfWeek(2022, 8, 27)); // Should print \"Saturday\"\n    }\n\n    public static String dayOfWeek(int year, int month, int day) {\n        String[] days = {\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"};\n        return days[(day + (13 * (month+1)/5) + year % 7) % 7];\n    }\n}\n```",
  "1187": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrays = {{1,2,3,4},{5,6,7,8},{1,3,2}};\n        \n        for (int i = 0; i < arrays.length; i++) {\n            System.out.println(\"Is \" + Arrays.toString(arrays[i]) + \" strictly increasing? \" + isPossibleToMakeArrayStrictlyIncreasing(arrays[i]));\n        }\n    }\n\n    public static boolean isPossibleToMakeArrayStrictlyIncreasing(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && nums[i] <= nums[i - 1]) {\n                return false;\n            }\n            for (int j = i + 1; j < n; j++) {\n                if (nums[j] >= nums[i]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n```",
  "1186": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {-2,1,-3,4,-1};\n        System.out.println(\"Max sum for first test case: \" + maxSubArraySumWithOneDeletion(nums1));\n        \n        int[] nums2 = [0, -1, 5, -10, 9, 10];\n        System.out.println(\"Max sum for second test case: \" + maxSubArraySumWithOneDeletion(nums2));\n\n        int[] nums3 = [-1, -1, 4, -3, 6];\n        System.out.println(\"Max sum for third test case: \" + maxSubArraySumWithOneDeletion(nums3));\n    }\n\n    public static int maxSubArraySumWithOneDeletion(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        \n        int maxSoFar = nums[0];\n        int maxEndingHere = nums[0];\n\n        for (int i = 1; i < nums.length; i++) {\n            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n        \n        if (maxSoFar > 0) {\n            return maxSoFar;\n        }\n\n        int maxNoDeletion = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            int sum = 0;\n            for (int j = i; j < nums.length; j++) {\n                sum += nums[j];\n                if (sum > maxNoDeletion) {\n                    maxNoDeletion = sum;\n                }\n            }\n        }\n\n        return Math.max(maxSoFar, maxNoDeletion);\n    }\n}\n```",
  "1189": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maximumNumber(\"nlaebolip\")); // Expected output: 2\n        System.out.println(maximumNumber(\"loonbalxballpoon\")); // Expected output: 5\n        System.out.println(maximumNumber(\"cornwalabel\")); // Expected output: 1\n    }\n\n    public static int maximumNumber(String text) {\n        String[] chars = {\"b\", \"a\", \"l\", \"o\"};\n        int maxCount = 0;\n        for (String charVal : chars) {\n            maxCount += countChar(text, charVal);\n        }\n        return maxCount / 2;\n    }\n\n    public static int countChar(String text, String charVal) {\n        int count = 0;\n        for (int i = 0; i < text.length(); i++) {\n            if (text.substring(i, i + 1).equals(charVal)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "1188": "```\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass MyQueue {\n    private List<Integer> queue = new ArrayList<>();\n    private final int capacity;\n\n    public MyQueue(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public void put(int element) throws InterruptedException {\n        if (queue.size() >= capacity) {\n            while (queue.size() == capacity) {\n                synchronized (this) {\n                    wait();\n                }\n            }\n        }\n        queue.add(element);\n    }\n\n    public int take() throws InterruptedException {\n        if (queue.isEmpty()) {\n            while (queue.isEmpty()) {\n                synchronized (this) {\n                    wait();\n                }\n            }\n        }\n        int element = queue.remove(0);\n        return element;\n    }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        try {\n            MyQueue myQueue = new MyQueue(3);\n\n            // Test case 1: Putting and taking elements from the queue\n            System.out.println(\"Test Case 1:\");\n            myQueue.put(1);\n            myQueue.put(2);\n            myQueue.put(3);\n            System.out.println(myQueue.take());  // prints 1\n            System.out.println(myQueue.take());  // prints 2\n            System.out.println(myQueue.take());  // prints 3\n\n            // Test case 2: Putting more elements than the capacity\n            System.out.println(\"\\nTest Case 2:\");\n            for (int i = 4; i <= 6; i++) {\n                myQueue.put(i);\n                System.out.println(\"Waiting...\");\n                Thread.sleep(1000);  // simulate waiting for other threads to finish their tasks\n            }\n            System.out.println(myQueue.take());  // prints 4\n            System.out.println(myQueue.take());  // prints 5\n            System.out.println(myQueue.take());  // prints 6\n\n            // Test case 3: Putting and taking elements from the queue with timeout\n            System.out.println(\"\\nTest Case 3:\");\n            myQueue.put(7);\n            Thread.sleep(2000);  // simulate waiting for other threads to finish their tasks\n            System.out.println(myQueue.take());  // prints 7\n\n        } catch (InterruptedException e) {\n            System.out.println(\"Error: \" + e.getMessage());\n        }\n    }\n}",
  "1190": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reverseParentheses(\"abc(cba)yz\")); // Should print \"abcbayz\"\n        System.out.println(reverseParentheses(\"a(bcde)f(g(h(i)j(k(l)m)n)o(p(q(r)s)t(u(v(w)x(y(z)))t(v(u(t(s(r(q(p)a))k))l)m))n)\")) // Should print \"a(ba)i(j(o(h(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s)r)))))))p))))o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(sr)))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))p))))))))n)o(n(l(m(k(j(i(h(g(f(e(d(c(ba)r)e(f(g(z(y(x(w(v(u(t(s(r(s(r(s(r(s(r(s(r(sr)))))p))))))))n)\"));\n\n        System.out.println(reverseParentheses(\"hello(world)\")) // Should print \"heloolleh\"\n    }\n\n    public static String reverseParentheses(String s) {\n        StringBuilder sb = new StringBuilder();\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                stack.push(c);\n            } else if (c == ')') {\n                while (!stack.isEmpty() && stack.pop() != '(') {\n                    sb.append(c);\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n        while (!stack.isEmpty()) {\n            sb.append(stack.pop());\n        }\n        return sb.toString();\n    }\n}",
  "1191": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{1,2},{5,6},{0,9}};\n        System.out.println(\"Result for arr1: \" + maxResult(arr1, 3));\n        \n        int[][] arr2 = {{1,85},{24,60},{74,51},{25,31},{37,54}};\n        System.out.println(\"Result for arr2: \" + maxResult(arr2, 3));\n        \n        int[][] arr3 = {{1,4},{9,8}};\n        System.out.println(\"Result for arr3: \" + maxResult(arr3, 7));\n    }\n\n    public static int maxResult(int[][] arr, int k) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MIN_VALUE);\n        dp[0] = arr[0][1];\n\n        for (int i = 1; i < n; i++) {\n            int maxSum = Integer.MIN_VALUE;\n            for (int j = Math.max(0, i - k); j <= i; j++) {\n                maxSum = Math.max(maxSum, dp[j] + arr[i][1]);\n            }\n            dp[i] = maxSum;\n        }\n\n        return dp[n-1];\n    }\n}",
  "1193": "```\npublic class Solution {\n    public double averageMonth(int[] transactions) {\n        int sum = 0;\n        for (int transaction : transactions) {\n            sum += transaction;\n        }\n        return (double)sum / transactions.length;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[] test1Transactions = {200, 500, 1000};\n        System.out.println(\"Test Case 1: \" + solution.averageMonth(test1Transactions));\n        \n        // Test case 2\n        int[] test2Transactions = {10, 20, 30, 40};\n        System.out.println(\"Test Case 2: \" + solution.averageMonth(test2Transactions));\n        \n        // Test case 3\n        int[] test3Transactions = {};\n        System.out.println(\"Test Case 3: \" + solution.averageMonth(test3Transactions));\n    }\n}",
  "1192": "```\npublic class Solution {\n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        // your code here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n1 = 4;\n        List<List<Integer>> connections1 = Arrays.asList(Arrays.asList(0, 1), Arrays.asList(1, 2), Arrays.asList(2, 3), Arrays.asList(0, 3));\n        System.out.println(\"Test Case 1: \" + solution.criticalConnections(n1, connections1));\n\n        int n2 = 2;\n        List<List<Integer>> connections2 = Arrays.asList(Arrays.asList(0, 1));\n        System.out.println(\"Test Case 2: \" + solution.criticalConnections(n2, connections2));\n\n        int n3 = 6;\n        List<List<Integer>> connections3 = Arrays.asList(Arrays.asList(0, 1), Arrays.asList(1, 2], Arrays.asList[2, 3], Arrays.asList[3, 4], Arrays.asList[4, 5], Arrays.asList[5, 0]);\n        System.out.println(\"Test Case 3: \" + solution.criticalConnections(n3, connections3));\n    }\n}\n```",
  "1194": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1:\");\n        int[][] logs = {{2000,5}, {2004,4},{2008,10},{2012,12}};\n        String winner = findWinner(logs);\n        System.out.println(winner);\n\n        System.out.println(\"\\nTest case 2:\");\n        logs = new int[][]{{2019,1},{2020,3},{2021,5},{2023,3}};\n        winner = findWinner(logs);\n        System.out.println(winner);\n\n        System.out.println(\"\\nTest case 3:\");\n        logs = new int[][]{{2008,4},{2012,7},{2016,12}};\n        winner = findWinner(logs);\n        System.out.println(winner);\n    }\n\n    public static String findWinner(int[][] logs) {\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int[] log : logs){\n            if(map.containsKey(log[1])){\n                map.put(log[1],log[0]);\n            }else{\n                map.put(log[1],log[0]);\n            }\n        }\n        int winnerYear = 0;\n        int maxWins = 0;\n        for(int year:map.values()){\n            if(year > maxWins){\n                maxWins = year;\n                winnerYear = year;\n            }\n        }\n        return \"Year \"+winnerYear+\" has the most wins\";\n    }\n}\n```",
  "1195": "```\nclass FizzBuzz {\n    public static void main(String[] args) {\n        System.out.println(testCase1());\n        System.out.println(testCase2());\n        System.out.println(testCase3());\n    }\n\n    public static String fizzBuzz(int n, int startFromOne) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= n; i++) {\n            if ((i % 3 == 0) && (i % 5 == 0)) {\n                sb.append(\"FizzBuzz\");\n            } else if (i % 3 == 0) {\n                sb.append(\"Fizz\");\n            } else if (i % 5 == 0) {\n                sb.append(\"Buzz\");\n            } else {\n                sb.append(i);\n            }\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n    public static String testCase1() {\n        int n = 15;\n        return fizzBuzz(n, 1);\n    }\n\n    public static String testCase2() {\n        int n = 30;\n        return fizzBuzz(n, 1);\n    }\n\n    public static String testCase3() {\n        int n = 20;\n        return fizzBuzz(n, 0);\n    }\n}\n```",
  "1196": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canPutInBasket(new int[]{1, 2}, 5)); // Expected: 2\n        System.out.println(canPutInBasket(new int[]{5, 4, 3, 2}, 10)); // Expected: 4\n        System.out.println(canPutInBasket(new int[]{6, 7, 8, 9, 10}, 15)); // Expected: 3\n    }\n\n    public static int canPutInBasket(int[] apples, int basketSize) {\n        Arrays.sort(apples);\n        int totalApples = 0;\n        for (int apple : apples) {\n            if (totalApples + apple > basketSize) {\n                break;\n            }\n            totalApples += apple;\n        }\n        return totalApples;\n    }\n}\n```",
  "1197": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumKnightMoves(2)); // Output: 6\n        System.out.println(minimumKnightMoves(4)); // Output: 8\n        System.out.println(minimumKnightMoves(50)); // Output: 64\n    }\n\n    public static int minimumKnightMoves(int n) {\n        if (n < 3) return 2 * n;\n        int[][] dir = {{-2, -1}, {-2, 1}, {-1, -2}, {1, -2}, {-1, 2}, {1, 2}, {-2, 0}, {2, 0}};\n        boolean[][] visited = new boolean[n * 2 + 1][n * 2 + 1];\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0});\n        visited[0][0] = true;\n        int step = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] pos = queue.poll();\n                if ((pos[0] * pos[0] + pos[1] * pos[1]) == n * n) return step;\n                for (int[] d : dir) {\n                    int x = pos[0] + d[0];\n                    int y = pos[1] + d[1];\n                    if (x >= 0 && x <= n * 2 && y >= 0 && y <= n * 2 && !visited[x][y]) {\n                        queue.offer(new int[]{x, y});\n                        visited[x][y] = true;\n                    }\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n}\n```",
  "1198": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1,2}, {2,3}};\n        System.out.println(findSmallestCommonElement(matrix1));\n        \n        int[][] matrix2 = {{1,2,3}, {1,2,3}, {3,4,5}};\n        System.out.println(findSmallestCommonElement(matrix2));\n        \n        int[][] matrix3 = {{1,2,3}, {1,3}, {4,5}};\n        System.out.println(findSmallestCommonElement(matrix3));\n    }\n\n    public static int findSmallestCommonElement(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) return -1;\n        \n        Set<Integer> set = new HashSet<>();\n        for (int[] row : matrix) {\n            set.clear();\n            boolean found = false;\n            for (int num : row) {\n                if (!set.add(num)) {\n                    return num;\n                }\n            }\n        }\n        return -1;\n    }\n}",
  "1199": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] beforePictures = {{1,2},{5},{}};\n        System.out.println(minTimeToBuild(beforePictures));\n        \n        int[][] afterPictures = {{1,2}};\n        System.out.println(minTimeToBuild(afterPictures));\n        \n        int[][] pictures = {{7,1},{4,6},{8,4},{10,3},{5,9}};\n        System.out.println(minTimeToBuild(pictures));\n    }\n\n    public static int minTimeToBuild(int[][] beforePictures) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b)->b-a);\n        for (int[] picture : beforePictures) {\n            if (!picture.isEmpty()) {\n                for (int block : picture) {\n                    queue.offer(block);\n                }\n            }\n        }\n\n        int minTime = 0;\n        while (!queue.isEmpty()) {\n            int time = 0;\n            while (!queue.isEmpty() && queue.peek() == minTime + 1) {\n                queue.poll();\n                time++;\n            }\n            if (time > 0) {\n                minTime += time;\n            }\n        }\n\n        return minTime;\n    }\n}\n```",
  "1200": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        int[] arr = {4,2,5,3};\n        System.out.println(minimumAbsoluteDifference(arr)); // expected output: 1\n\n        System.out.println(\"\\nTest Case 2:\");\n        int[] arr2 = {1,3,5,2,4};\n        System.out.println(minimumAbsoluteDifference(arr2)); // expected output: 0\n\n        System.out.println(\"\\nTest Case 3:\");\n        int[] arr3 = {6,8,10};\n        System.out.println(minimumAbsoluteDifference(arr3)); // expected output: 0\n    }\n\n    public static int minimumAbsoluteDifference(int[] arr) {\n        Arrays.sort(arr);\n        int minDiff = Integer.MAX_VALUE;\n        for (int i = 1; i < arr.length; i++) {\n            int diff = arr[i] - arr[i-1];\n            if (diff < minDiff) {\n                minDiff = diff;\n            }\n        }\n        return minDiff;\n    }\n}\n```",
  "1201": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isUgly(4)); // true\n        System.out.println(isUgly(6)); // false\n        System.out.println(isUgly(8)); // true\n    }\n\n    public static boolean isUgly(int n) {\n        if (n <= 0) return false;\n        while (n % 2 == 0) n /= 2;\n        while (n % 3 == 0) n /= 3;\n        while (n % 5 == 0) n /= 5;\n        return n == 1;\n    }\n}",
  "1202": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minTime(\"dcce\",\"edzaf\"); // Test Case 1\n        System.out.println(minTime(\"jdp\"));// Test Case 2\n        System.out.println(minTime(\"kaa\")); // Test Case 3\n    }\n\n    public static int minTime(String s, String t) {\n        if (s.length() != t.length()) {\n            return -1;\n        }\n        char[] a = s.toCharArray();\n        char[] b = t.toCharArray();\n        boolean[][] dp = new boolean[a.length][b.length];\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < b.length; j++) {\n                if (a[i] == b[j]) {\n                    dp[i][j] = true;\n                }\n            }\n        }\n\n        int res = 0;\n        boolean first = false;\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < b.length; j++) {\n                if (!dp[i][j]) {\n                    if (!first) {\n                        first = true;\n                        res++;\n                    }\n                    int swapIndex1 = -1, swapIndex2 = -1;\n                    for (int k = i; k >= 0 && !dp[k][j]; k--) {\n                        if (!dp[k][j] && swapIndex1 == -1) {\n                            swapIndex1 = k;\n                        } else if (!dp[k][j] && swapIndex1 != -1 && swapIndex2 == -1) {\n                            swapIndex2 = k;\n                        }\n                    }\n                    for (int k = i; k < a.length && !dp[k][j]; k++) {\n                        if (!dp[k][j] && swapIndex2 == -1) {\n                            swapIndex2 = k;\n                        } else if (!dp[k][j] && swapIndex1 != -1 && swapIndex2 != -1) {\n                            break;\n                        }\n                    }\n                    if (swapIndex1 != -1 && swapIndex2 != -1) {\n                        for (int l = i; l > swapIndex1; l--) {\n                            a[l] = a[swapIndex1];\n                        }\n                        res++;\n                    } else if (!first) {\n                        res = -1;\n                    }\n                    first = false;\n                }\n            }\n        }\n        return res;\n    }\n}\n```",
  "1203": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] group1 = {{1,2},{7,8},{10}};\n        int[][] group2 = {{0,4},{5,6}};\n        int[][] group3 = {{1,9},{3,8}};\n        List<List<Integer>> groups = new ArrayList<>();\n        groups.add(Arrays.stream(group1).mapToInt(i -> i[0]).boxed().collect(Collectors.toList()));\n        groups.add(Arrays.stream(group2).mapToInt(i -> i[0]).boxed().collect(Collectors.toList()));\n        groups.add(Arrays.stream(group3).mapToInt(i -> i[0]).boxed().collect(Collectors.toList()));\n\n        List<Integer> result = sortItems(groups);\n\n        System.out.println(\"Test Case 1:\");\n        for (int num : result) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n\n        int[][] group4 = {{3,9},{10}};\n        int[][] group5 = {{0,2}};\n        List<Integer> result2 = sortItems(Arrays.asList(Arrays.stream(group4).mapToInt(i -> i[0]).boxed().collect(Collectors.toList()), Arrays.stream(group5).mapToInt(i -> i[0]).boxed().collect(Collectors.toList())));\n\n        System.out.println(\"Test Case 2:\");\n        for (int num : result2) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n\n        int[][] group6 = {{10,7},{9}};\n        List<Integer> result3 = sortItems(Arrays.asList(Arrays.stream(group6).mapToInt(i -> i[0]).boxed().collect(Collectors.toList())));\n\n        System.out.println(\"Test Case 3:\");\n        for (int num : result3) {\n            System.out.print(num + \" \");\n        }\n    }\n\n    public static List<Integer> sortItems(List<List<Integer>> graph) {\n        Map<Integer, Integer> inDegree = new HashMap<>();\n        List<Integer> res = new ArrayList<>();\n\n        // Calculate the in-degree of each node\n        for (int i = 0; i < graph.size(); i++) {\n            for (Integer item : graph.get(i)) {\n                if (!inDegree.containsKey(item)) {\n                    inDegree.put(item, 0);\n                }\n                inDegree.put(item, inDegree.get(item) + 1);\n            }\n        }\n\n        // Perform topological sort\n        while (!inDegree.isEmpty()) {\n            int node = null;\n            for (Map.Entry<Integer, Integer> entry : inDegree.entrySet()) {\n                if (entry.getValue() == 0) {\n                    node = entry.getKey();\n                    break;\n                }\n            }\n            if (node == null) {\n                throw new RuntimeException(\"Graph has a cycle\");\n            }\n            res.add(node);\n            for (int i = 0; i < graph.size(); i++) {\n                for (Integer item : graph.get(i)) {\n                    if (item.equals(node)) {\n                        inDegree.put(item, inDegree.get(item) - 1);\n                    }\n                }\n            }\n            inDegree.remove(node);\n        }\n\n        return res;\n    }\n}",
  "1204": "```\npublic class Solution {\n    public int LastPersonToFit(int[] weights) {\n        Arrays.sort(weights);\n        int left = 0;\n        int right = weights.length - 1;\n        while (left < right) {\n            if ((weights[right] - weights[left]) <= 10) {\n                return weights[right];\n            }\n            if (weights[right] > weights[left] + 5) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] testCase1 = {30, 40, 20, 10};\n        System.out.println(\"Last person to fit in the bus for test case 1 is \" + solution.LastPersonToFit(testCase1));\n\n        int[] testCase2 = {50, 10, 5, 15};\n        System.out.println(\"Last person to fit in the bus for test case 2 is \" + solution.LastPersonToFit(testCase2));\n\n        int[] testCase3 = {60, 40, 30, 20, 10};\n        System.out.println(\"Last person to fit in the bus for test case 3 is \" + solution.LastPersonToFit(testCase3));\n    }\n}",
  "1205": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] accounts = {\n                {1, 2, 10}, // normal transaction\n                {1, 2, 5},   // another normal transaction\n                {1, 3, 15}  // transfer from account 1 to account 3\n        };\n\n        for (int[] account : accounts) {\n            System.out.println(minimizeTransactions(account));\n        }\n    }\n\n    public static int minimizeTransactions(int[] account) {\n        Arrays.sort(account);\n        int i = 0;\n        while (i < account.length - 1) {\n            if (account[i] == account[i + 1]) {\n                return -1; // invalid transaction\n            }\n            i++;\n        }\n        return 1;\n    }\n\n}\n```",
  "1206": "```\npublic class Main {\n    public static void main(String[] args) {\n        Skiplist skiplist = new Skiplist();\n        System.out.println(\"Test Case 1: Adding elements\");\n        skiplist.set(1, \"A\");\n        skiplist.set(2, \"B\");\n        skiplist.set(3, \"C\");\n        System.out.println(skiplist.get(1)); // prints \"A\"\n        System.out.println(skiplist.get(2)); // prints \"B\"\n        System.out.println(skiplist.get(3)); // prints \"C\"\n\n        System.out.println(\"\\nTest Case 2: Updating an existing element\");\n        skiplist.set(2, \"D\");\n        System.out.println(skiplist.get(2)); // prints \"D\"\n\n        System.out.println(\"\\nTest Case 3: Removing a non-existent element\");\n        skiplist.set(5, null);\n        System.out.println(\"Exists: \" + skiplist.exists(5)); // prints false\n    }\n}\n```",
  "1207": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {1,2};\n        System.out.println(occurrences(arr1)); // expected: 1\n\n        int[] arr2 = {4,3,2,7,2};\n        System.out.println(occurrences(arr2)); // expected: 1\n\n        int[] arr3 = {1,1,2,2,3,3,4,4};\n        System.out.println(occurrences(arr3)); // expected: 0\n    }\n\n    public static int occurrences(int[] arr) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : arr) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        Set<Integer> set = new HashSet<>(map.values());\n        return set.size();\n    }\n}",
  "1208": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(equalSubstrings(\"abcba\", 1));\n        System.out.println(equalSubstrings(\"abacaba\", 2));\n        System.out.println(equalSubstrings(\"bbbabcbcabaaaacb\", 3));\n    }\n\n    public static int equalSubstrings(String s, int minLen) {\n        // Your code here\n        return 0;\n    }\n}\n```",
  "1209": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removeDuplicates(\"abcdefbbcf\")); // \"abcdef\"\n        System.out.println(removeDuplicates(\"aaa\")); // \"\"\n        System.out.println(removeDuplicates(\"yazazzz\"); // \"yz\"\n    }\n\n    public static String removeDuplicates(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (i > 0 && s.charAt(i) == s.charAt(i - 1)) {\n                continue;\n            }\n            sb.append(s.charAt(i));\n        }\n        return sb.toString();\n    }\n}\n```",
  "1210": "```\nimport java.util.*;\n\nclass Solution {\n    public int minMovesToReachTarget(int target) {\n        // write your solution here\n        List<Integer> moves = new ArrayList<>();\n        while (true) {\n            if (target == 0) return moves.size();\n            if ((target & 1) == 0) {\n                target >>= 1;\n            } else {\n                target -= 1;\n                moves.add(1);\n            }\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.minMovesToReachTarget(8)); // Output: 3\n        System.out.println(solution.minMovesToReachTarget(10)); // Output: 4\n        System.out.println(solution.minMovesToReachTarget(12)); // Output: 5\n    }\n}",
  "1211": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] accounts = {{1, 5}, {2, 6}, {3, 10}};\n        System.out.println(\"Case 1: \" + qualityAndPercentage(accounts));\n        \n        int[][] accounts2 = {{1, 10}, {2, 15}, {3, 30}};\n        System.out.println(\"Case 2: \" + qualityAndPercentage(accounts2));\n        \n        int[][] accounts3 = {{1, 1000}, {2, 2000}, {3, 5000}};\n        System.out.println(\"Case 3: \" + qualityAndPercentage(accounts3));\n    }\n\n    public static double[] qualityAndPercentage(int[][] accounts) {\n        double sum = 0;\n        int count = 0;\n        \n        for (int i = 0; i < accounts.length; i++) {\n            sum += accounts[i][1];\n            count++;\n        }\n        \n        double average = sum / count;\n        double percentage = ((double) sum / 10000) * 100;\n\n        return new double[]{average, percentage};\n    }\n}",
  "1212": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] scores1 = {{9, 7, 6}, {10, 5, 11}};\n        System.out.println(\"Test Case 1: \" + teamScores(scores1));\n        \n        int[][] scores2 = {{10, 12}, {0, 3}};\n        System.out.println(\"Test Case 2: \" + teamScores(scores2));\n        \n        int[][] scores3 = {{9, 8}, {5, 6}};\n        System.out.println(\"Test Case 3: \" + teamScores(scores3));\n    }\n\n    public static List<Integer> teamScores(int[][] scores) {\n        // Your code here\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = 0; i < scores.length; i++) {\n            int sum1 = 0;\n            int sum2 = 0;\n            \n            for (int j = 0; j < scores[i].length; j++) {\n                if ((j + 1) % 2 == 1) {\n                    sum1 += scores[i][j];\n                } else {\n                    sum2 += scores[i][j];\n                }\n            }\n            result.add(Math.max(sum1, sum2));\n        }\n        \n        return result;\n    }\n}\n```",
  "1213": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<Integer> threeSum(int[] nums1, int[] nums2, int[] nums3) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        Arrays.sort(nums3);\n\n        List<int[]> triplets = new ArrayList<>();\n        for (int i : getTripletIndex(nums1)) {\n            if (i >= 0 && i < nums1.length - 1 && nums1[i] + nums2[0] + nums3[0] <= 0) {\n                int j = findBound(nums2, -nums1[i] - nums3[0]);\n                if (j != -1 && nums2[j] == -nums1[i] - nums3[0]) {\n                    int k = findBound(nums3, -nums1[i] - nums2[j]);\n                    if (k != -1 && nums3[k] == -nums1[i] - nums2[j]) {\n                        triplets.add(new int[]{nums1[i], nums2[j], nums3[k]});\n                    }\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int[] triplet : triplets) {\n            result.add(triplet[0]);\n        }\n\n        return result;\n    }\n\n    public int[] getTripletIndex(int[] arr) {\n        int[] indices = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            indices[i] = i;\n        }\n        return indices;\n    }\n\n    public int findBound(int[] arr, int target) {\n        int left = 0;\n        int right = arr.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] == target) {\n                return mid;\n            }\n            if (arr[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1 = {1,2};\n        int[] nums2 = {1,2};\n        int[] nums3 = {-1,-2};\n        System.out.println(\"Case 1: \" + solution.threeSum(nums1, nums2, nums3));\n\n        int[] nums4 = {0,1};\n        int[] nums5 = {2,3};\n        int[] nums6 = {0,0,1,2};\n        System.out.println(\"Case 2: \" + solution.threeSum(nums4, nums5, nums6));\n\n        int[] nums7 = {1,2,-1,-2};\n        int[] nums8 = {1,2,-1,-2};\n        int[] nums9 = {-1,-2,0,0};\n        System.out.println(\"Case 3: \" + solution.threeSum(nums7, nums8, nums9));\n    }\n}",
  "1214": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        Integer[] nums1 = {1, 4};\n        Integer[] nums2 = {1, 3, 5, 2};\n        boolean result1 = solution.twoSum(nums1, nums2);\n        System.out.println(\"Test case 1: \" + (result1 ? \"TRUE\" : \"FALSE\"));\n        \n        // Test case 2\n        Integer[] nums3 = {0, -4};\n        Integer[] nums4 = {5, 7, 3, 6, 2, 8, 9, 1};\n        boolean result2 = solution.twoSum(nums3, nums4);\n        System.out.println(\"Test case 2: \" + (result2 ? \"TRUE\" : \"FALSE\"));\n        \n        // Test case 3\n        Integer[] nums5 = {10};\n        Integer[] nums6 = {5};\n        boolean result3 = solution.twoSum(nums5, nums6);\n        System.out.println(\"Test case 3: \" + (result3 ? \"TRUE\" : \"FALSE\"));\n    }\n}\n\nclass Solution {\n    public boolean twoSum(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1);\n        Arrays.sort(arr2);\n        \n        int i = 0;\n        int j = arr2.length - 1;\n        \n        while (i < arr1.length && j >= 0) {\n            if (arr1[i] + arr2[j] == 0) {\n                return true;\n            } else if (arr1[i] + arr2[j] > 0) {\n                j--;\n            } else {\n                i++;\n            }\n        }\n        \n        return false;\n    }\n}\n```",
  "1215": "```\nimport java.util.*;\n\npublic class SteppingNumbers {\n    public static void main(String[] args) {\n        System.out.println(numSteppable(10)); // Output: 20\n        System.out.println(numSteppable(15)); // Output: 24\n        System.out.println(numSteppable(19)); // Output: 30\n    }\n\n    public static int numSteppable(int n) {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 1; i <= n; i++) {\n            boolean isSteppable = checkSteppable(i, set);\n            if (isSteppable) {\n                set.add(i);\n            }\n        }\n        return set.size();\n    }\n\n    public static boolean checkSteppable(int num, Set<Integer> set) {\n        for (int i = 1; ; i++) {\n            int nextNum = num + i;\n            while (nextNum > 0 && !set.contains(nextNum)) {\n                if (!isValidStep(num, nextNum)) {\n                    return false;\n                }\n                num = nextNum;\n                nextNum = num + i;\n            }\n            if (nextNum == 0) {\n                return true;\n            }\n        }\n    }\n\n    public static boolean isValidStep(int a, int b) {\n        String strA = String.valueOf(a);\n        String strB = String.valueOf(b);\n        for (int i = 1; i <= strA.length(); i++) {\n            if (!strA.substring(0, i).equals(strB.substring(strA.length() - i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "1216": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"abc\", \"cba\")); // true\n        System.out.println(canBeEqual(\"abca\", \"acb\")); // false\n        System.out.println(canBeEqual(\"\", \"\")); // true\n    }\n\n    public static boolean canBeEqual(String s, String t) {\n        int[] count = new int[128];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i)]++;\n            count[t.charAt(i)]--;\n        }\n        for (int i : count) {\n            if (i != 0) return false;\n        }\n        return true;\n    }\n}\n```",
  "1217": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minimumCostToMoveChips(new int[]{1, 2, 3})) + \" expected: 2\";\n        System.out.println(minimumCostToMoveChips(new int[]{2, 2, 2, 3, 3})) + \" expected: 2\";\n        System.out.println(minimumCostToMoveChips(new int[]{1, 100000001})) + \" expected: 0\";\n    }\n\n    public static int minimumCostToMoveChips(int[] position) {\n        int even = 0, odd = 0;\n        for (int p : position) {\n            if ((p % 2) == 0) even++;\n            else odd++;\n        }\n        return Math.min(even * 1, odd * 1);\n    }\n}\n```",
  "1218": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] difference = {{1,2,3,4},{1,3,5,25,50},{-1,-2,-4,-8,-16}};\n        for (int i = 0; i < difference.length; i++) {\n            System.out.println(\"Longest arithmetic subsequence of given difference for array \" + Arrays.toString(difference[i]) + \" is \" + longestArithSeqLength(difference[i]));\n        }\n    }\n\n    public static int longestArithSeqLength(int[] A) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int maxLen = 0;\n        for (int num : A) {\n            for (int i = 1; ; i++) {\n                if (!map.containsKey(num - i)) break;\n                int len = map.get(num - i);\n                map.put(num, Math.max(map.getOrDefault(num, 0), len + 1));\n                maxLen = Math.max(maxLen, map.getOrDefault(num, 0));\n            }\n        }\n        return maxLen;\n    }\n}",
  "1219": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,6,0},{5,8,7},{0,9,0}};\n        System.out.println(maximumGold(grid1)); // Output: 24\n\n        int[][] grid2 = {{1,0,7},{2,0,8},{3,9,0}};\n        System.out.println(maximumGold(grid2)); // Output: 22\n\n        int[][] grid3 = {{10,5,2},{6,7,5},{3,4,1}};\n        System.out.println(maximumGold(grid3)); // Output: 15\n    }\n\n    public static int maximumGold(int[][] grid) {\n        if (grid.length == 0) return 0;\n        \n        int maxGold = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] > 0) {\n                    maxGold = Math.max(maxGold, dfs(grid, i, j));\n                }\n            }\n        }\n        return maxGold;\n    }\n\n    private static int dfs(int[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[i].length || grid[i][j] <= 0) return 0;\n\n        int gold = grid[i][j];\n        grid[i][j] = 0; // mark as visited\n\n        int maxGold = 0;\n        for (int[] dir : new int[][]{{-1,0},{1,0},{0,-1},{0,1}}) {\n            int ni = i + dir[0], nj = j + dir[1];\n            if (ni >= 0 && ni < grid.length && nj >= 0 && nj < grid[ni].length)\n                maxGold = Math.max(maxGold, gold + dfs(grid, ni, nj));\n        }\n\n        grid[i][j] = gold; // backtrack\n        return maxGold;\n    }\n}",
  "1220": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countVowelsPermutation(1) == 5);\n        System.out.println(countVowelsPermutation(2) == 16);\n        System.out.println(countVowelsPermutation(3) == 35);\n    }\n\n    public static int countVowelsPermutation(int n) {\n        if (n <= 0) return 1;\n        long mod = 1000000007L;\n        int[] dp = new int[n + 1];\n        dp[0] = 5;\n        for (int i = 1; i < n; i++) {\n            dp[i] = (dp[i - 1] * 2) % mod;\n            if (i >= 1) {\n                dp[i] += (n - i) * dp[i - 1];\n            }\n            dp[i] %= mod;\n        }\n        return (int) (dp[n - 1]);\n    }\n}",
  "1221": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeBalanced(\"RLRRLLRLLL\")); // true\n        System.out.println(canBeBalanced(\"R\")); // false\n        System.out.println(canBeBalanced(\"LL\")); // true\n    }\n\n    public static boolean canBeBalanced(String s) {\n        int rCount = 0, lCount = 0;\n        for (char c : s.toCharArray()) {\n            if (c == 'R') rCount++;\n            else lCount++;\n        }\n        return Math.abs(rCount - lCount) <= 1;\n    }\n}\n```",
  "1222": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] positions1 = {{0,1},{1,0},{4,0}};\n        System.out.println(\"Expected: 2, Actual: \" + numRookMoves(positions1));\n        \n        int[][] positions2 = {{0,0},{2,2}};\n        System.out.println(\"Expected: 2, Actual: \" + numRookMoves(positions2));\n\n        int[][] positions3 = {{5,6},{4,7},{3,8}};\n        System.out.println(\"Expected: 1, Actual: \" + numRookMoves(positions3));\n    }\n\n    public static int numRookMoves(int[][] positions) {\n        int count = 0;\n        for (int i = 0; i < positions.length; i++) {\n            for (int j = 0; j < positions[0].length; j++) {\n                if ((i == 0 || j == 0) || (i == positions.length - 1 || j == positions[0].length - 1)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}\n```",
  "1223": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] rolls = {2, 1};\n        System.out.println(\"Expected output: \" + numRollsToWin(rolls));\n        \n        int[] rolls2 = {1, 3, 2};\n        System.out.println(\"Expected output: \" + numRollsToWin(rolls2));\n        \n        int[] rolls3 = {2, 2, 2, 3, 4, 5};\n        System.out.println(\"Expected output: \" + numRollsToWin(rolls3));\n    }\n\n    public static int numRollsToWin(int[] dice) {\n        int MOD = (int)1e9 + 7;\n        int n = dice.length;\n        int[][] dp = new int[n][16];\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= 15; j++) {\n                if (i == 0) {\n                    dp[i][j] = (j >= dice[0]) ? 1 : 0;\n                } else {\n                    int val = 0;\n                    for (int k = 0; k < 6 && k + i <= n; k++) {\n                        if ((k + 1) <= j) {\n                            val = (val + dp[i - 1][j - (k + 1)]) % MOD;\n                        }\n                    }\n                    dp[i][j] = val;\n                }\n            }\n        }\n        \n        return dp[n-1][15];\n    }\n}",
  "1224": "```\nimport java.util.*;\n\npublic class Solution {\n    public int maxOperations(int[] budget) {\n        Map<Integer, Integer> freqMap = new HashMap<>();\n        for (int num : budget) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n\n        int maxCount = 0;\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\n            if (entry.getValue() > 1 && entry.getKey() * entry.getValue() >= budget[0]) {\n                maxCount = Math.max(maxCount, entry.getValue());\n            }\n        }\n\n        return maxCount;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        int[] budget1 = {10};\n        System.out.println(\"Test case 1: \" + solution.maxOperations(budget1)); // Output: 1\n\n        int[] budget2 = {100000, 30000, 3000000};\n        System.out.println(\"Test case 2: \" + solution.maxOperations(budget2)); // Output: 2\n\n        int[] budget3 = {2, 17, 5, 21, 7, 9, 23};\n        System.out.println(\"Test case 3: \" + solution.maxOperations(budget3)); // Output: 4\n    }\n}",
  "1225": "```\npublic class Solution {\n    public List<String> contiguousDates(int n, int startDay, int closeDate) {\n        // Your solution here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> result1 = solution.contiguousDates(3, 10, 16);\n        System.out.println(result1);  // Expected output: [\"10-01\", \"11-30\", \"12-31\", \"13-29\", \"14-28\", \"15-27\", \"16-26\"]\n\n        List<String> result2 = solution.contiguousDates(4, 5, 25);\n        System.out.println(result2);  // Expected output: [\"5-01\", \"06-30\", \"07-31\", \"08-29\", \"09-28\", \"10-27\", \"11-26\", \"12-25\"]\n\n        List<String> result3 = solution.contiguousDates(1, 1, 31);\n        System.out.println(result3);  // Expected output: [\"01-01\", \"02-28\", \"03-31\"]\n    }\n}\n```",
  "1227": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(probabilityOfSeating(1, 10));\n        System.out.println(probabilityOfSeating(2, 4));\n        System.out.println(probabilityOfSeating(3, 1000));\n    }\n\n    public static double probabilityOfSeating(int n, int total) {\n        // Your code goes here\n        return 0.5;\n    }\n}\n```",
  "1226": "```\nimport java.util.concurrent.Semaphore;\n\nclass Philosopher implements Runnable {\n    private int id;\n    private Semaphore[] forks;\n    private boolean isEating = false;\n\n    public Philosopher(int id, Semaphore[] forks) {\n        this.id = id;\n        this.forks = forks;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            try {\n                think();\n                pickUpForks();\n                eat();\n                putDownForks();\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;\n            }\n        }\n    }\n\n    private void think() throws InterruptedException {\n        Thread.sleep(100);\n    }\n\n    private void pickUpForks() throws InterruptedException {\n        for (int i = 0; i < forks.length; i++) {\n            if (!forks[i].tryAcquire()) {\n                return;\n            }\n        }\n    }\n\n    private void eat() throws InterruptedException {\n        isEating = true;\n        Thread.sleep(100);\n        isEating = false;\n    }\n\n    private void putDownForks() {\n        for (Semaphore fork : forks) {\n            fork.release();\n        }\n    }\n}\n\npublic class Solution {\n    public static void main(String[] args) {\n        Semaphore[] forks = new Semaphore[5];\n        for (int i = 0; i < forks.length; i++) {\n            forks[i] = new Semaphore(1);\n        }\n\n        Thread[] philosophers = new Thread[5];\n\n        for (int i = 0; i < philosophers.length; i++) {\n            Philosopher philosopher = new Philosopher(i, forks);\n            philosophers[i] = new Thread(philosopher);\n            philosophers[i].start();\n        }\n    }\n}",
  "1228": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {5, 2, 8, 9};\n        System.out.println(\"Missing number for \" + Arrays.toString(nums1) + \": \" + findMissingNumber(nums1));\n\n        int[] nums2 = {4, 7, 10, 12, 20, 37, 54, 72, 91};\n        System.out.println(\"Missing number for \" + Arrays.toString(nums2) + \": \" + findMissingNumber(nums2));\n\n        int[] nums3 = {1, 5, 10, 15, 19, 24, 28};\n        System.out.println(\"Missing number for \" + Arrays.toString(nums3) + \": \" + findMissingNumber(nums3));\n    }\n\n    public static int findMissingNumber(int[] nums) {\n        int n = nums.length;\n        if (n == 0) return 1;\n\n        long total = (n * (n + 1)) / 2; // sum of first n natural numbers\n        long actualSum = 0;\n        for (int num : nums) {\n            actualSum += num;\n        }\n\n        return (int) (total - actualSum);\n    }\n}",
  "1229": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] intervals1 = {{0,30},{5,10},{15,20}};\n        System.out.println(\"Expected: [[0,10],[10,30]]\");\n        System.out.println(\"Actual: \" + Arrays.deepToString(scheduleMeetings(intervals1)));\n        \n        int[][] intervals2 = {{7,10},{2,4}};\n        System.out.println(\"Expected: [[2,4],[10,10]]\");\n        System.out.println(\"Actual: \" + Arrays.deepToString(scheduleMeetings(intervals2)));\n\n        int[][] intervals3 = {{5,8},{1,4},{9,12}];\n        System.out.println(\"Expected: [[1,4],[5,8],[9,12]]\");\n        System.out.println(\"Actual: \" + Arrays.deepToString(scheduleMeetings(intervals3)));\n    }\n\n    public static int[][] scheduleMeetings(int[][] intervals) {\n        if (intervals.length == 0) return new int[0][2];\n\n        Arrays.sort(intervals, (a,b)-> a[0]-b[0]);\n        \n        List<int[]> merged = new ArrayList<>();\n        int[] currentInterval = intervals[0];\n        for (int[] interval : intervals) {\n            if (interval[0] <= currentInterval[1]) {\n                currentInterval[1] = Math.max(currentInterval[1], interval[1]);\n            } else {\n                merged.add(currentInterval);\n                currentInterval = interval;\n            }\n        }\n\n        merged.add(currentInterval);\n        return merged.toArray(new int[merged.size()][]);\n    }\n}\n```",
  "1230": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numWays(2, new int[]{1, 1, 2, 2})); // Test case 1\n        System.out.println(numWays(3, new int[]{1, 2, 2, 1, 2, 1, 1, 2})); // Test case 2\n        System.out.println(numWays(4, new int[]{2, 1, 1, 2, 2, 2, 1, 2, 1, 1})); // Test case 3\n    }\n\n    public static int numWays(int n, int[] head) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 0; i < head.length; i++) {\n            for (int j = n; j >= head[i]; j--) {\n                dp[j] += dp[j - head[i]];\n            }\n        }\n        return dp[n];\n    }\n}\n```",
  "1231": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + canEat(new int[]{10}, 5));\n        System.out.println(\"Test Case 2: \" + canEat(new int[]{3,10000,3}, 2));\n        System.out.println(\"Test Case 3: \" + canEat(new int[]{7,5,3,9,2,9}, 4));\n\n    }\n\n    public static boolean canEat(int[] pieces, int k) {\n        Arrays.sort(pieces);\n        for (int i = 0; i < pieces.length - 1; i++) {\n            if (pieces[i + 1] - pieces[i] > k) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1232": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(checkStraightLine(new int[][]{{1,2},{5,3},{7,4}})); // Expected: true\n        System.out.println(checkStraightLine(new int[][]{{0,1},{5,2},{-2,-2}})); // Expected: false\n        System.out.println(checkStraightLine(new int[][]{{1,1},{2,2},{3,3}})); // Expected: true\n    }\n\n    public static boolean checkStraightLine(int[][] coordinates) {\n        if (coordinates.length < 2) return true;\n        int x0 = coordinates[0][0];\n        int y0 = coordinates[0][1];\n        for (int i = 1; i < coordinates.length; i++) {\n            int x = coordinates[i][0];\n            int y = coordinates[i][1];\n            if ((x - x0) * (y - y0) != (x - coordinates[i-1][0]) * (y - coordinates[i-1][1])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1233": "```\npublic class Main {\n    public static void main(String[] args) {\n        String[] folder = {\"/a\", \"/a/b/c\", \"/a/b/d/e/f\"};\n        removeSubFolders(folder);\n        \n        folder = new String[]{\"/home/louis/website/web/WEB-INF\", \"/home/louis/website/docs\", \"/home/louis/website/docs/docs2\", \"/home/louis/website/docs/docs3/docs4\"};\n        removeSubFolders(folder);\n\n        folder = new String[]{\"/home/louis/website/web/WEB-INF\"};\n        removeSubFolders(folder);\n    }\n\n    public static void removeSubFolders(String[] folder) {\n        TrieNode root = new TrieNode();\n        for (String path : folder) {\n            TrieNode current = root;\n            String[] parts = path.split(\"/\");\n            for (int i = 1; i < parts.length; i++) {\n                String part = parts[i];\n                if (!current.children.containsKey(part)) {\n                    current.children.put(part, new TrieNode());\n                }\n                current = current.children.get(part);\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        removeSubFolders(root, \"\", sb);\n\n        System.out.println(sb.toString());\n    }\n\n    public static void removeSubFolders(TrieNode node, String path, StringBuilder sb) {\n        if (node.children.isEmpty()) {\n            sb.append(path).append(\"\\n\");\n        } else {\n            for (Map.Entry<String, TrieNode> entry : node.children.entrySet()) {\n                removeSubFolders(entry.getValue(), path + entry.getKey() + \"/\", sb);\n            }\n        }\n    }\n\n    static class TrieNode {\n        Map<String, TrieNode> children = new HashMap<>();\n    }\n}",
  "1234": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(balanceString(\"dfeee5dbc\", \"c\")); // Expected: \"efdece\"\n        System.out.println(balanceString(\"pobggnbhhhggxc/p/Sidrh\", \"/\")); // Expected: \"xxcc//A/\"\n        System.out.println(balanceString(\"tfxuqqxnqztttqnnnhefzy\", \"e\")); // Expected: \"tftfait/rt/t\"\n    }\n\n    public static String balanceString(String s, char c) {\n        int left = 0;\n        int right = 0;\n        StringBuilder sb = new StringBuilder();\n        \n        for (char ch : s.toCharArray()) {\n            if (ch == c) {\n                if (left > right) {\n                    sb.append(ch);\n                } else if (right == left) {\n                    sb.append(ch);\n                    right++;\n                }\n            } else {\n                if (right > 0) {\n                    sb.append(c);\n                    right--;\n                }\n                sb.append(ch);\n            }\n        }\n\n        while (left < right) {\n            sb.append(c);\n            right--;\n        }\n        \n        return sb.toString();\n    }\n}",
  "1235": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] jobSchedulings = {\n            {{1, 2}, {5, 6}, {8, 9}},\n            {{1, 4}, {2, 3}, {10, 11}, {12, 14}},\n            {{1, 3}, {2, 7}, {5, 6}, {7, 10}}\n        };\n\n        for (int[] jobScheduling : jobSchedulings) {\n            System.out.println(\"Maximum Profit: \" + maxProfit(jobScheduling));\n        }\n    }\n\n    public static int maxProfit(int[][] jobSchedulings) {\n        if (jobSchedulings.length == 0) return 0;\n\n        Arrays.sort(jobSchedulings, (a, b) -> a[1] - b[1]);\n\n        int end = jobSchedulings[0][0];\n        int maxProfit = 0;\n        for (int i = 0; i < jobSchedulings.length; i++) {\n            if (jobSchedulings[i][0] > end) {\n                maxProfit += jobSchedulings[i][1] - end;\n                end = jobSchedulings[i][1];\n            }\n        }\n\n        return maxProfit;\n    }\n}\n```",
  "1236": "```\nimport java.util.*;\n\npublic class WebCrawler {\n    public static List<String> crawl(String startUrl, String tld) {\n        Set<String> visited = new HashSet<>();\n        Map<String, List<String>> graph = new HashMap<>();\n\n        // Add your code here to populate the graph and visited set based on the startUrl\n\n        List<String> result = new ArrayList<>();\n        Stack<String> stack = new Stack<>();\n        stack.push(startUrl);\n\n        while (!stack.isEmpty()) {\n            String current = stack.pop();\n            if (visited.add(current)) {\n                if (current.endsWith(tld)) {\n                    result.add(current);\n                }\n                for (String neighbor : graph.getOrDefault(current, Collections.emptyList())) {\n                    stack.push(neighbor);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        List<String> result1 = crawl(\"http://example.com\", \".com\");\n        System.out.println(result1);\n\n        List<String> result2 = crawl(\"http://abc.co.uk\", \".co.uk\");\n        System.out.println(result2);\n\n        List<String> result3 = crawl(\"https://www.example.io\", \".io\");\n        System.out.println(result3);\n    }\n}\n```",
  "1237": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] equations = { {2, -1, 2}, {3, 0, 2}, {-5, -10, 3} };\n        System.out.println(\"Case 1: \" + findEquilibrium(equations));\n        \n        int[][] equations2 = { {4, -1, 8}, {8, -7, 5} };\n        System.out.println(\"Case 2: \" + findEquilibrium(equations2));\n\n        int[][] equations3 = { { -1, -1, 2 }, { -10, -10, 5 } };\n        System.out.println(\"Case 3: \" + findEquilibrium(equations3));\n    }\n\n    public static double[] findEquilibrium(int[][] equations) {\n        // Your code here\n    }\n}\n```",
  "1239": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxUniqueEmails(new String[]{\"test.email+alex@leetcode.com\", \"test.eam+alex@leetcode.com\", \"test.email.leet+alex@leetcode.com\"}));\n        System.out.println(maxUniqueEmails(new String[]{\"\"}));\n        System.out.println(maxUnique@Before\n    }\n\n    public static int maxUniqueEmails(String[] emails) {\n        Set<String> uniqueEmails = new HashSet<>();\n        for (String email : emails) {\n            int atIndex = email.indexOf('@');\n            String localPart = email.substring(0, atIndex).replaceFirst(\"[.]+\", \"\");\n            String uniqueEmail = localPart + email.substring(atIndex);\n            uniqueEmails.add(uniqueEmail);\n        }\n        return uniqueEmails.size();\n    }\n}\n```",
  "1238": "```\nclass Solution {\n    public String circularPermutation(int n, int start) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            if ((start & (1 << i)) > 0) {\n                sb.append(1);\n            } else {\n                sb.append(0);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(\"Test Case 1: n=3, start=3\");\n        System.out.println(solution.circularPermutation(3, 3)); // Output: \"101\"\n        \n        System.out.println(\"\\nTest Case 2: n=4, start=6\");\n        System.out.println(solution.circularPermutation(4, 6)); // Output: \"0110\"\n        \n        System.out.println(\"\\nTest Case 3: n=5, start=10\");\n        System.out.println(solution.circularPermutation(5, 10)); // Output: \"10010\"\n    }\n}",
  "1241": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] table = {{1, 2}, {2, 3}, {4, 5}};\n        System.out.println(\"Number of comments per post: \" + numberCommentsPerPost(table));\n        \n        // Test case 1\n        table = new int[][]{{1, 0}, {2, 2}};\n        System.out.println(\"\\nTest case 1: Number of comments per post - \" + numberCommentsPerPost(table));\n        \n        // Test case 2\n        table = new int[][]{{5, 6, 7, 8, 10}, {11, 12}};\n        System.out.println(\"\\nTest case 2: Number of comments per post - \" + numberCommentsPerPost(table));\n        \n        // Test case 3\n        table = new int[][]{};\n        System.out.println(\"\\nTest case 3: Number of comments per post - \" + numberCommentsPerPost(table));\n    }\n\n    public static List<Integer> numberCommentsPerPost(int[][] table) {\n        if (table.length == 0) return new ArrayList<>();\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < table.length; i++) {\n            result.add(table[i][1] - table[i-1][1]);\n        }\n        return result;\n    }\n}\n```",
  "1240": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumAreaRect(new int[][]{{1,1},{2,2},{4,4},{8,8}})); // Expected: 4\n        System.out.println(minimumAreaRect(new int[][]{{1,1},{2,2},{3,3},{6,6}})); // Expected: 9\n        System.out.println(minimumAreaRect(new int[][]{{0,0},{1,1},{1,2},{2,0}})); // Expected: 4\n    }\n\n    public static int minimumAreaRect(int[][] points) {\n        int minArea = Integer.MAX_VALUE;\n        for (int i = 0; i < points.length; i++) {\n            for (int j = i + 1; j < points.length; j++) {\n                boolean[][] visited = new boolean[points.length][];\n                for (int k = 0; k < points.length; k++) {\n                    visited[k] = new boolean[points.length];\n                }\n                int area = dfs(points, i, j, visited);\n                minArea = Math.min(minArea, area);\n            }\n        }\n        return minArea == Integer.MAX_VALUE ? 0 : minArea;\n    }\n\n    public static int dfs(int[][] points, int startI, int startJ, boolean[][] visited) {\n        int area = 0;\n        for (int i = startI; i < points.length; i++) {\n            for (int j = startJ; j < points.length; j++) {\n                if (!visited[i][j] && (i == startI || j == startJ)) {\n                    visited[i][j] = true;\n                    area += 1;\n                    int x1 = points[startI][0], y1 = points[startI][1];\n                    int x2 = points[i][0], y2 = points[j][1];\n                    if (x1 < x2 && y1 < y2) {\n                        int[][] newPoints = new int[4][2];\n                        newPoints[0] = new int[]{x1, y1};\n                        newPoints[1] = new int[]{x1, y2};\n                        newPoints[2] = new int[]{x2, y2};\n                        newPoints[3] = new int[]{x2, y1};\n                        area += dfs(points, i, j, visited);\n                    }\n                }\n            }\n        }\n        return area;\n    }\n}\n```",
  "1242": "```\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Solution {\n    public List<String> crawl(String startUrl, HtmlParser htmlParser) {\n        // TO DO: Your code here\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        ExecutorService executor = Executors.newFixedThreadPool(4);\n\n        solution.crawl(\"https://leetcode.com\", new MyHtmlParser());\n\n        // Test cases\n        test1();\n        test2();\n        test3();\n\n        executor.shutdown();\n    }\n\n    static void test1() {\n        Solution solution = new Solution();\n        List<String> result = solution.crawl(\"https://leetcode.com\", new MyHtmlParser());\n        System.out.println(result);\n    }\n\n    static void test2() {\n        Solution solution = new Solution();\n        List<String> result = solution.crawl(\"http://www.example.com\", new MyHtmlParser());\n        System.out.println(result);\n    }\n\n    static void test3() {\n        Solution solution = new Solution();\n        List<String> result = solution.crawl(\"https://en.wikipedia.org/wiki/Main_Page\", new MyHtmlParser());\n        System.out.println(result);\n    }\n}\n\nclass MyHtmlParser implements HtmlParser {\n    // TO DO: Your code here\n}\n```",
  "1243": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] inputs = { {{1, 2}, {3, 4}}, {{5, 6}} ,{{1, 1}} };\n        for (int i = 0; i < inputs.length; i++) {\n            System.out.println(\"Test Case \" + (i+1));\n            transformArray(inputs[i]);\n            System.out.println();\n        }\n    }\n\n    public static void transformArray(int[][] arr) {\n        int maxCount = 0;\n        for (int[] row : arr) {\n            int count = 0;\n            for (int val : row) {\n                if (val % 2 == 0) count++;\n            }\n            if (count > maxCount) {\n                maxCount = count;\n            }\n        }\n\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                if ((arr[i][j] % 2 == 0 && maxCount > 1) || (arr[i][j] % 2 != 0 && maxCount == 1)) {\n                    arr[i][j]++;\n                }\n            }\n        }\n\n        for (int[] row : arr) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "1244": "```\nimport java.util.*;\n\npublic class Leaderboard {\n    class UserScore {\n        int id;\n        int score;\n\n        public UserScore(int id, int score) {\n            this.id = id;\n            this.score = score;\n        }\n    }\n\n    Map<Integer, UserScore> leaderboard;\n\n    public void addScore(int uid, int score) {\n        if (!leaderboard.containsKey(uid)) {\n            leaderboard.put(uid, new UserScore(uid, score));\n        } else {\n            leaderboard.get(uid).score = score;\n        }\n        leaderboard.put(uid, new UserScore(uid, score));\n        leaderboard.put(uid, new UserScore(uid, score));\n    }\n\n    public List<UserScore> get() {\n        List<UserScore> result = new ArrayList<>(leaderboard.values());\n        Collections.sort(result, (a, b) -> Integer.compare(b.score, a.score));\n        return result;\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Leaderboard lb = new Leaderboard();\n        lb.addScore(1, 1500);\n        System.out.println(lb.get());\n\n        lb.addScore(1, 1050);\n        System.out.println(lb.get());\n\n        lb.addScore(2, 2000);\n        lb.addScore(3, 1000);\n        System.out.println(lb.get());\n    }\n}",
  "1245": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(3);\n        root1.right = new TreeNode(4);\n        root1.left.left = new TreeNode(2);\n\n        System.out.println(\"Tree Diameter of the first tree: \" + treeDiameter(root1));\n\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(6);\n        root2.right = new TreeNode(7);\n\n        System.out.println(\"Tree Diameter of the second tree: \" + treeDiameter(root2));\n\n        TreeNode root3 = null;\n\n        System.out.println(\"Tree Diameter of the third tree: \" + treeDiameter(root3));\n    }\n\n    public static int treeDiameter(TreeNode root) {\n        if (root == null) return 0;\n        \n        int maxDepth = getMaxDepth(root);\n        TreeNode farthestLeft = getFarthestLeft(root, maxDepth);\n\n        return Math.max(getMaxDepth(farthestLeft), getDistance(root, farthestLeft));\n    }\n\n    public static int getMaxDepth(TreeNode node) {\n        if (node == null) return 0;\n        \n        return 1 + Math.max(getMaxDepth(node.left), getMaxDepth(node.right));\n    }\n\n    public static TreeNode getFarthestLeft(TreeNode node, int maxDepth) {\n        if (node == null || getMaxDepth(node) < maxDepth - 1) return null;\n\n        return node.left != null ? getFarthestLeft(node.left, maxDepth) : node;\n    }\n\n    public static int getDistance(TreeNode start, TreeNode end) {\n        if (start == null || end == null) return 0;\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(start);\n        int dist = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            \n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n\n                if (node == end) return dist;\n                \n                if (node.left != null) queue.add(node.left);\n                if (node.right != null) queue.add(node.right);\n            }\n\n            dist++;\n        }\n        \n        return dist;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "1246": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removePalindromeSub(\"a\"));\n        System.out.println(removePalindromeSub(\"ba\"));\n        System.out.println(removePalindromeSub(\"abcdcba\"));\n    }\n\n    public static int removePalindromeSub(String s) {\n        if (s.length() == 0) return 1;\n        boolean isPalindrome = true;\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - i - 1)) {\n                isPalindrome = false;\n                break;\n            }\n        }\n        return isPalindrome ? 1 : s.length();\n    }\n}",
  "1247": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSwaps(\"abc\", \"cab\") + \" swaps required to make strings equal\");\n        System.out.println(minSwaps(\"aaa\", \"abc\") + \" swaps required to make strings equal\");\n        System.out.println(minSwaps(\"xyxy\", \"xixi\") + \" swaps required to make strings equal\");\n    }\n\n    public static int minSwaps(String s1, String s2) {\n        if (s1.length() != s2.length()) {\n            return -1;\n        }\n        \n        Map<Character, Character> map = new HashMap<>();\n        for (int i = 0; i < s1.length(); i++) {\n            char c1 = s1.charAt(i);\n            char c2 = s2.charAt(i);\n            if (!map.containsKey(c1)) {\n                map.put(c1, c2);\n            } else {\n                if (map.get(c1) != c2) {\n                    return -1;\n                }\n            }\n        }\n\n        int swaps = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            char c1 = s1.charAt(i);\n            char c2 = map.getOrDefault(c1, '?');\n            if (c1 != c2) {\n                swaps++;\n            }\n        }\n\n        return swaps / 2;\n    }\n}",
  "1248": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countNiceSubarrays(new int[]{2,4,6}, 8)); // Expected output: 5\n        System.out.println(countNiceSubarrays(new int[]{3,5,16}, 25)); // Expected output: 4\n        System.out.println(countNiceSubarrays(new int[]{1,2,3,4,5}, 10)); // Expected output: 7\n    }\n\n    public static int countNiceSubarrays(int[] nums, int threshold) {\n        int n = nums.length;\n        int ans = 0;\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            if ((sum & 1) == 1) continue;\n            for (int j = i; j < n && (j + 1 - i) * (j + 1) / 2 <= threshold; j++) {\n                sum += nums[j];\n                if (isNice(sum)) ans++;\n                sum -= nums[j];\n            }\n        }\n        return ans;\n    }\n\n    public static boolean isNice(int num) {\n        int temp = num, rev = 0;\n        while (temp > 0) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        return num == rev;\n    }\n}",
  "1249": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minRemoveToMakeValid(\"lee(t(c)o(a)m\") + \"\\n\");\n        System.out.println(minRemoveToMakeValid(\"(a(b(c)d)\") + \"\\n\");\n        System.out.println(minRemoveToMakeValid(\"a)b(c)d\") + \"\\n\");\n    }\n\n    public static String minRemoveToMakeValid(String s) {\n        int left = 0;\n        int right = 0;\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                left++;\n                sb.append(c);\n            } else if (c == ')') {\n                if (left > 0) {\n                    left--;\n                    sb.append(c);\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n\n        while (left > 0) {\n            sb.deleteCharAt(sb.length() - 1);\n            left--;\n        }\n\n        return sb.toString();\n    }\n}",
  "1250": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {{1, 2, 3}, true},\n            {{1, 2, -1, -2, -3}, false},\n            {{1, -1}, true}\n        };\n\n        for (int i = 0; i < arrays.length; i++) {\n            System.out.println(\"Is good array: \" + isGoodArray(arrays[i][0]) + \", expected result: \" + arrays[i][1]);\n        }\n    }\n\n    public static boolean isGoodArray(int[][] nums) {\n        int gcd = nums[0][0];\n        for (int i = 1; i < nums.length; i++) {\n            gcd = gcd(gcd, nums[i][0]);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if ((nums[i][0] / gcd) % nums[i].length != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        else\n            return gcd(b, a % b);\n    }\n}",
  "1251": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(average(new int[][]{{1,2},{5}}));\n        System.out.println(average(new int[][]{{1,4},{6,8},{10,15}}));\n        System.out.println(average(new int[][]{}));\n    }\n\n    public static double average(int[][] prices) {\n        if (prices.length == 0) return 0;\n        int sum = 0;\n        for (int[] price : prices) {\n            sum += price[1] - price[0];\n        }\n        return (double)sum / (prices.length * (prices[0].length));\n    }\n\n}\n```",
  "1252": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1,2},{3,4}};\n        System.out.println(\"Test Case 1: \" + oddCells(2, 2, matrix1));\n        \n        int[][] matrix2 = {{0,1},{1,1}};\n        System.out.println(\"Test Case 2: \" + oddCells(2, 2, matrix2));\n        \n        int[][] matrix3 = {{0,0,1},{1,1,1},{2,2,1}};\n        System.out.println(\"Test Case 3: \" + oddCells(3, 3, matrix3));\n    }\n\n    public static int oddCells(int m, int n, int[][] indices) {\n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            boolean[] row = new boolean[n];\n            for (int j = 0; j < n; j++) {\n                if (!row[j]) {\n                    for (int k = 0; k < indices.length; k++) {\n                        if (indices[k][0] == i && !row[indices[k][1]]) {\n                            row[indices[k][1]] = true;\n                            break;\n                        }\n                    }\n                    if (!row[j]) count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
  "1253": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] binaryMatrix1 = {{0, 1}, {1, 0}};\n        reconstructBinaryMatrix(binaryMatrix1);\n        \n        System.out.println();\n        \n        int[][] binaryMatrix2 = {{0, 0, 1}, {1, 1, 1}};\n        reconstructBinaryMatrix(binaryMatrix2);\n        \n        System.out.println();\n        \n        int[][] binaryMatrix3 = {{1, 0, 0}, {0, 0, 0}};\n        reconstructBinaryMatrix(binaryMatrix3);\n    }\n\n    public static void reconstructBinaryMatrix(int[][] binaryMatrix) {\n        // Your code to solve the problem goes here\n    }\n}\n```",
  "1254": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,0,1},{1,1,1},{1,0,0}};\n        System.out.println(\"Number of closed islands for grid1: \" + numClosedIslands(grid1));\n        \n        int[][] grid2 = {{1,1,1,1,1,1},{1,0,1,0,1,0},{1,0,1,1,1,0},{1,0,0,0,0,0}};\n        System.out.println(\"Number of closed islands for grid2: \" + numClosedIslands(grid2));\n        \n        int[][] grid3 = {{1,1,0},{1,0,0},{0,0,0}};\n        System.out.println(\"Number of closed islands for grid3: \" + numClosedIslands(grid3));\n    }\n\n    public static int numClosedIslands(int[][] grid) {\n        if (grid.length == 0) return 0;\n        \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1) {\n                    dfs(grid, i, j);\n                }\n            }\n        }\n        \n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1) return 0;\n            }\n        }\n        \n        return count + 1;\n    }\n\n    public static void dfs(int[][] grid, int i, int j) {\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1) return;\n\n        grid[i][j] = -1;\n        \n        for (int[] d : new int[][]{{-1,0},{1,0},{0,-1},{0,1}}) {\n            dfs(grid, i + d[0], j + d[1]);\n        }\n    }\n}",
  "1255": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxScoreWords(new String[]{\"alice\", \"bob\", \"candy\"}, new char[][]{{'a', 'i', 'e'}, {'b', 'o', 'v'}, {'c', 'a', 'n', 'd', 'y'}}, 3, 1)); // Test case 1\n        System.out.println(maxScoreWords(new String[]{\"dog\", \"cat\"}, new char[][]{{'d', 'o', 'g'}, {'c', 'a', 't'}}, 2, 0)); // Test case 2\n        System.out.println(maxScoreWords(new String[]{\"blue\", \"red\"}, new char[][]{{'b', 'l', 'u', 'e'}, {'r', 'e', 'd'}}, 5, 1)); // Test case 3\n    }\n\n    public static int maxScoreWords(String[] words, char[][] letters, int score, int index) {\n        // Your code here...\n    }\n}\n```",
  "1256": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(encode(\"5\"));\n        System.out.println(encode(\"12345\"));\n        System.out.println(encode(\"-3\"));\n    }\n\n    public static String encode(int n) {\n        if (n == 0) return \"0\";\n        StringBuilder sb = new StringBuilder();\n        while (n > 0) {\n            sb.append(n % 10);\n            n /= 10;\n        }\n        return sb.reverse().toString();\n    }\n}\n```",
  "1257": "```\nimport java.util.*;\n\npublic class Solution {\n    public String findSmallestString(int m, int n, String[] grid) {\n        // Your logic here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.findSmallestString(3, 5, new String[]{\"abc\", \"def\", \"ghi\"}));\n        System.out.println(solution.findSmallestString(2, 1, new String[]{\"ac\", \"b\"}));\n        System.out.println(solution.findSmallestString(1, 2, new String[]{\"a\", \"ab\", \"bc\"}));\n    }\n}",
  "1258": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numSynonyms(new String[][]{\n                {\"Your\", \"you\"},\n                {\"Hi\", \"Hello\"},\n                {\"A\", \"B\"}\n            }, \"hello\"));\" // Expected: 1\n        System.out.println(numSynonyms(new String[][]{\n                {\"This\", \"that\"},\n                {\"is\", \"is\"},\n                {\"it\", \"it\"}\n            }, \"it is it\"));;\" // Expected: 2\n        System.out.println(numSynonyms(new String[][]{}, \"You are\"));;\" // Expected: 0\n    }\n\n    public static int numSynonyms(String[][] dictionary, String sentence) {\n        // Your code here...\n    }\n}\n```",
  "1259": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canCross(\"123456789\"));\n        System.out.println(canCross(\"1112345679\"));\n        System.out.println(canCross(\"1233214321\"));\n    }\n\n    public static int canCross(String s) {\n        int res = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            if ((s.charAt(i) - '0') % 2 == 0 && s.charAt(i + 1) == '0' || \n                (s.charAt(i) - '0') % 2 != 0 && s.charAt(i + 1) == '5') {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```",
  "1260": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{1,2,3},{4,5,6},{7,8,9}};\n        shiftGrid(grid1, 1);\n        \n        int[][] grid2 = {{1,2},{3,4}};\n        shiftGrid(grid2, 0);\n        \n        int[][] grid3 = {{1,2},{3,4},{5,6}};\n        shiftGrid(grid3, 2);\n    }\n\n    public static void shiftGrid(int[][] grid, int k) {\n        k = k % (grid.length * grid[0].length);\n        if(k == 0){\n            return;\n        }\n        \n        for(int i=0; i<grid.length; i++){\n            for(int j=0; j<grid[0].length; j++){\n                int val = grid[i][j];\n                int newI = (i + k / grid[0].length) % grid.length;\n                int newJ = (j + k % grid[0].length) % grid[0].length;\n                grid[newI][newJ] = val;\n            }\n        }\n    }\n}",
  "1261": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(4);\n        root1.right = new TreeNode(5);\n        root1.left.left = new TreeNode(2);\n        root1.left.right = new TreeNode(3);\n        \n        System.out.println(\"Test case 1: \" + findElements(root1));\n        \n        TreeNode root2 = new TreeNode(1);\n        root2.right = new TreeNode(2);\n        root2.right.left = new TreeNode(4);\n        root2.right.right = new TreeNode(5);\n        root2.right.left.left = new TreeNode(3);\n        \n        System.out.println(\"Test case 2: \" + findElements(root2));\n        \n        TreeNode root3 = null;\n        \n        System.out.println(\"Test case 3: \" + findElements(root3));\n    }\n\n    public static List<Integer> findElements(TreeNode root) {\n        // Your code here\n        return new ArrayList<>();\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1262": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(greatestSumDivisibleByThree(new int[]{2,1,10,-9}))); // Test case 1\n        System.out.println(greatestSumDivisibleByThree(new int[]{0,0,0})); // Test case 2\n        System.out.println(greatestSumDivisibleByThree(new int[]{-1,0,1,2,-1,-4})); // Test case 3\n    }\n\n    public static int greatestSumDivisibleByThree(int[] nums) {\n        int sum0 = 0, sum1 = 0, sum2 = 0;\n        for (int num : nums) {\n            switch (num % 3) {\n                case 0:\n                    sum0 += num;\n                    break;\n                case 1:\n                    sum1 += num;\n                    break;\n                case 2:\n                    sum2 += num;\n                    break;\n            }\n        }\n        return Math.max(Math.max(sum0, sum1), sum2);\n    }\n}\n```",
  "1263": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] box = {{0,1},{2,3},{4,5}};\n        System.out.println(\"Example 1: \" + minSteps(box));\n        \n        int[][] box2 = {{0,1},{1,2},{3,3}};\n        System.out.println(\"Example 2: \" + minSteps(box2));\n        \n        int[][] box3 = {{0,1},{5,6}};\n        System.out.println(\"Example 3: \" + minSteps(box3));\n    }\n\n    public static int minSteps(int[][] box) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < box.length; i++) {\n            if (!map.containsKey(box[i][0])) map.put(box[i][0], box[i][1]);\n            else map.put(box[i][0], Math.min(map.get(box[i][0]), box[i][1]));\n            if (!map.containsKey(box[i][1])) map.put(box[i][1], box[i][0]);\n            else map.put(box[i][1], Math.min(map.get(box[i][1]), box[i][0]));\n        }\n        int steps = 0;\n        for (int i : map.values()) {\n            steps += i;\n        }\n        return steps / 2;\n    }\n}\n```",
  "1264": "```\npublic class Solution {\n    public List<List<String>> pageRecommendations(int windowSize, List<List<String>> log) {\n        // Your solution here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int windowSize = 3;\n        \n        List<List<String>> log1 = Arrays.asList(Arrays.asList(\"LeetCode\", \"Frontend\"), \n                                                  Arrays.asList(\"Facebook\", \"Backend\"), \n                                                  Arrays.asList(\"Google\", \"Backend\"));\n        \n        System.out.println(\"Test case 1: \");\n        System.out.println(solution.pageRecommendations(windowSize, log1));\n        \n        List<List<String>> log2 = Arrays.asList(Arrays.asList(\"Amazon\", \"Frontend\"), \n                                                  Arrays.asList(\"Apple\", \"Frontend\"), \n                                                  Arrays.asList(\"Google\", \"Backend\"), \n                                                  Arrays.asList(\"Facebook\", \"Backend\"));\n        \n        System.out.println(\"\\nTest case 2: \");\n        System.out.println(solution.pageRecommendations(windowSize, log2));\n        \n        List<List<String>> log3 = Arrays.asList(Arrays.asList(\"LeetCode\", \"Frontend\"), \n                                                  Arrays.asList(\"Google\", \"Backend\"), \n                                                  Arrays.asList(\"Facebook\", \"Backend\"));\n        \n        System.out.println(\"\\nTest case 3: \");\n        System.out.println(solution.pageRecommendations(windowSize, log3));\n    }\n}",
  "1265": "```\npublic class Solution {\n    public void printList(Node head) {\n        if (head == null) return;\n        Node current = head;\n        Stack<Node> stack = new Stack<>();\n        while (current != null) {\n            stack.push(current);\n            current = current.next;\n        }\n        while (!stack.isEmpty()) {\n            System.out.print(stack.pop().val + \" \");\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        // Test case 1\n        Node head1 = new Node(1);\n        head1.next = new Node(2);\n        head1.next.next = new Node(3);\n        head1.next.next.next = new Node(4);\n        head1.next.next.next.next = new Node(5);\n        solution.printList(head1);\n\n        // Test case 2\n        Node head2 = new Node(6);\n        head2.next = new Node(7);\n        head2.next.next = new Node(8);\n        solution.printList(head2);\n\n        // Test case 3\n        Node head3 = null;\n        solution.printList(head3);\n    }\n}\n\nclass Node {\n    int val;\n    Node next;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n    }\n}\n```",
  "1266": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minTimeVisit(new int[][]{{0,1},{2,4}})); // Output: 7\n        System.out.println(minTimeVisit(new int[][]{{0,2},{5,10},{13,23},{24,25}})); // Output: 20\n        System.out.println(minTimeVisit(new int[][]{{1,2},{3,8},{5,8},{4,7}})); // Output: 9\n    }\n\n    public static int minTimeVisit(int[][] points) {\n        if (points.length < 2) return 0;\n        \n        int n = points.length;\n        int time = 0;\n        for (int i = 1; i < n; i++) {\n            int dx = Math.abs(points[i][0] - points[i-1][0]);\n            int dy = Math.abs(points[i][1] - points[i-1][1]);\n            int distance = (dx > dy) ? dx : dy;\n            time += distance + 1;\n        }\n        \n        return time;\n    }\n}\n```",
  "1267": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] server1 = {{1,2},{2,3},{3,4}};\n        System.out.println(\"Test case 1: \" + countServers(5, server1));\n        \n        int[][] server2 = {{0,1,2},{3,4,5},{7,8},{9,10,11,12}};\n        System.out.println(\"Test case 2: \" + countServers(13, server2));\n        \n        int[][] server3 = {{1},{2},{2},{1},{2,3},{4,5}};\n        System.out.println(\"Test case 3: \" + countServers(6, server3));\n    }\n\n    public static int countServers(int n, int[][] servers) {\n        boolean[] connected = new boolean[n];\n        for (int[] pair : servers) {\n            int x = pair[0], y = pair[1];\n            connected[x] = true;\n            connected[y] = true;\n        }\n        \n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (connected[i]) count++;\n        }\n        \n        return count;\n    }\n}",
  "1268": "```\npublic class Solution {\n    public List<List<String>> suggestedProducts(String[] products, String searchWord) {\n        TrieNode root = new TrieNode();\n        for (String product : products) {\n            TrieNode node = root;\n            for (char c : product.toCharArray()) {\n                if (!node.children.containsKey(c)) {\n                    node.children.put(c, new TrieNode());\n                }\n                node = node.children.get(c);\n            }\n            node.isEndOfWord = true;\n        }\n\n        List<List<String>> result = new ArrayList<>();\n        for (int i = 1; i <= Math.min(searchWord.length(), 5); i++) {\n            List<String> suggestions = new ArrayList<>();\n            TrieNode node = root;\n            for (char c : searchWord.substring(0, i).toCharArray()) {\n                if (!node.children.containsKey(c)) {\n                    break;\n                }\n                node = node.children.get(c);\n            }\n            if (node.isEndOfWord) {\n                for (String product : products) {\n                    TrieNode tempNode = root;\n                    boolean match = true;\n                    for (int j = 0; j < i; j++) {\n                        char c = searchWord.charAt(j);\n                        if (!tempNode.children.containsKey(c)) {\n                            match = false;\n                            break;\n                        }\n                        tempNode = tempNode.children.get(c);\n                    }\n                    if (match && tempNode.isEndOfWord) {\n                        suggestions.add(product);\n                    }\n                }\n            }\n            result.add(suggestions);\n        }\n\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] products1 = {\"apple\", \"banana\", \"fig\"};\n        List<List<String>> result1 = solution.suggestedProducts(products1, \"app\");\n        System.out.println(result1);\n\n        String[] products2 = {\"kitten\", \"baby\", \"cat\", \"doggy\", \"dog\"};\n        List<List<String>> result2 = solution.suggestedProducts(products2, \"cat\");\n        System.out.println(result2);\n\n        String[] products3 = {\"bags\", \"bagels\", \"bagpipe\", \"bacteria\", \"banana\", \"bagel\", \"bag\"};\n        List<List<String>> result3 = solution.suggestedProducts(products3, \"bag\");\n        System.out.println(result3);\n    }\n}",
  "1269": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] directions = {{4, -3}, {-2, 1}, {1, -4}};\n        System.out.println(numSteps(5, directions));\n        \n        directions = new int[][]{{2, 1}};\n        System.out.println(numSteps(2, directions));\n        \n        directions = new int[][]{});\n        System.out.println(numSteps(10, directions));\n    }\n\n    public static int numSteps(int dist, int[][] directions) {\n        int n = 0;\n        for (int[] direction : directions) {\n            n += direction[0] + direction[1];\n        }\n        if (Math.abs(n) <= Math.abs(dist)) {\n            return (n > 0) ? ((dist < 0) ? 1 : dist % 2 == 0 ? 2 : 1)\n                    : ((dist > 0) ? 1 : dist % 2 == 0 ? 2 : 1);\n        }\n        if (Math.abs(dist) <= Math.abs(n)) {\n            return (n > 0) ? ((dist < 0) ? 1 : dist % 2 == 0 ? 2 : 1)\n                    : ((dist > 0) ? 1 : dist % 2 == 0 ? 2 : 1);\n        }\n        if (Math.abs(dist) <= Math.abs(n)) {\n            return 2;\n        }\n        int res = 0;\n        while (n != 0) {\n            n -= Math.max(Math.min(2, Math.abs(n)), 1);\n            res += 1;\n        }\n        return res;\n    }\n}\n```",
  "1271": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(HexSpeak(\"1e\"));\n        System.out.println(HexSpeak(\"120\"));\n        System.out.println(HexSpeak(\"100000\"));\n    }\n}\n\nclass Solution {\n    public String HexSpeak(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            int val = Character.getNumericValue(s.charAt(i));\n            while (val > 0) {\n                if (val % 16 == 10) {\n                    sb.append(\"A\");\n                } else if (val % 16 == 11) {\n                    sb.append(\"B\");\n                } else if (val % 16 == 12) {\n                    sb.append(\"C\");\n                } else if (val % 16 == 13) {\n                    sb.append(\"D\");\n                } else if (val % 16 == 14) {\n                    sb.append(\"E\");\n                } else if (val % 16 == 15) {\n                    sb.append(\"F\");\n                } else {\n                    sb.append((char)(val % 16 + '0'));\n                }\n                val /= 16;\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "1270": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<List<String>> getReportedEmployees(String[] manager, String[] id) {\n        Map<String, List<String>> reported = new HashMap<>();\n        \n        for (int i = 0; i < manager.length; i++) {\n            if (!reported.containsKey(manager[i])) {\n                reported.put(manager[i], new ArrayList<>());\n            }\n            reported.get(manager[i]).add(id[i]);\n        }\n        \n        return new ArrayList<>(reported.values());\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] manager1 = {\"Karl\", \"Barry\"};\n        String[] id1 = {\"Bert\", \"Dave\", \"Edward\", \"Fred\", \"Gerald\", \"Henry\", \"Ivan\", \"Julian\"};\n        \n        System.out.println(\"Test Case 1: \");\n        List<List<String>> result1 = solution.getReportedEmployees(manager1, id1);\n        for (List<String> reported : result1) {\n            System.out.println(reported);\n        }\n        \n        String[] manager2 = {\"Alice\", \"Bob\", \"Charlie\"};\n        String[] id2 = {\"Ava\", \"Ben\", \"Celia\", \"Daniel\", \"Eve\", \"Frank\", \"Gretchen\", \"Helen\"};\n        \n        System.out.println(\"Test Case 2: \");\n        List<List<String>> result2 = solution.getReportedEmployees(manager2, id2);\n        for (List<String> reported : result2) {\n            System.out.println(reported);\n        }\n        \n        String[] manager3 = {\"Emma\", \"Felix\", \"Gina\"};\n        String[] id3 = {\"Eva\", \"Frankie\", \"Gabriella\", \"Harrison\", \"Isabella\", \"Julian\", \"Kiera\", \"Luna\"};\n        \n        System.out.println(\"Test Case 3: \");\n        List<List<String>> result3 = solution.getReportedEmployees(manager3, id3);\n        for (List<List<String>> reported : result3) {\n            System.out.println(reported);\n        }\n    }\n}",
  "1272": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] intervals = {{0,2},{1,3},{5,7},{6,8},{9,10}};\n        removeInterval(intervals);\n        \n        intervals = new int[][]{{0,10},{5,15}};\n        removeInterval(intervals);\n\n        intervals = new int[][]{{1,2},{4,5},{6,7},{8,9},{11,12}};\n        removeInterval(intervals);\n    }\n\n    public static void removeInterval(int[][] intervals) {\n        for (int i = 0; i < intervals.length; i++) {\n            for (int j = 0; j < intervals[i].length; j++) {\n                System.out.print(String.valueOf(intervals[i][j]) + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "1273": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nodes = {\n            {1,2,null,3},\n            {5,1,5,null,null,6,null,7},\n            {}\n        };\n        \n        for (int i = 0; i < nodes.length; i++) {\n            Node root = new Node(nodes[i][0]);\n            for (int j = 1; j < nodes[i].length; j++) {\n                addNode(root, nodes[i][j]);\n            }\n            \n            deleteTreeNodes(root);\n        }\n    }\n\n    static class Node {\n        int val;\n        Node left, right;\n\n        public Node(int val) {\n            this.val = val;\n        }\n    }\n\n    public static void deleteTreeNodes(Node root) {\n        if (root == null) return;\n        \n        root.left = deleteTreeNodes(root.left);\n        root.right = deleteTreeNodes(root.right);\n\n        if (root.left == null && root.right == null) {\n            return null; // node to be deleted\n        }\n        return root;\n    }\n}",
  "1274": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] boating = {\n            {0,2},\n            {1,3},\n            {4,6}\n        };\n        System.out.println(numberOfShips(boating));\n\n        boating = new int[][]{\n            {1,2},\n            {3,5},\n            {5,5},\n            {2,3},\n            {5,5}\n        };\n        System.out.println(numberOfShips(boating));\n\n        boating = new int[][]{\n            {0,0},\n            {1,1},\n            {1,1}\n        };\n        System.out.println(numberOfShips(boating));\n    }\n\n    public static int numberOfShips(int[][] position) {\n        // TO DO: implement your solution here\n        return 0;\n    }\n}",
  "1275": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] board1 = {{1, 2}, {2, 1}};\n        System.out.println(\"Winner of game1: \" + findWinner(board1));\n\n        int[][] board2 = {{0, 1, 2}, {0, 1, 1}, {2, 2, 1}};\n        System.out.println(\"Winner of game2: \" + findWinner(board2));\n\n        int[][] board3 = {{1, 2, 1}, {1, 1, 1}, {0, 0, 0}};\n        System.out.println(\"Winner of game3: \" + findWinner(board3));\n    }\n\n    public static char findWinner(int[][] board) {\n        for (int i = 0; i < 3; i++) {\n            if ((board[i][0] == board[i][1] && board[i][0] == board[i][2]) || \n                (board[0][i] == board[1][i] && board[0][i] == board[2][i])) {\n                return board[i][0] == 1 ? 'X' : 'O';\n            }\n        }\n        if ((board[0][0] == board[1][1] && board[0][0] == board[2][2]) || \n            (board[0][2] == board[1][1] && board[0][2] == board[2][0])) {\n            return board[1][1] == 1 ? 'X' : 'O';\n        }\n        return ' ';\n    }\n}\n```",
  "1276": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numberOfBurgers(10, 2)); // Test case 1: Expected output = 4\n        System.out.println(numberOfBurgers(7, 3)); // Test case 2: Expected output = 2\n        System.out.println(numberOfBurgers(9, 2)); // Test case 3: Expected output = 3\n    }\n\n    public static int numberOfBurgers(int tomatoSlices, int burgerSlices) {\n        if (tomatoSlices < burgerSlices * 2 + burgerSlices) return -1;\n        int wholeTomatoes = tomatoSlices / (burgerSlices * 2);\n        int remainingTomatoes = tomatoSlices % (burgerSlices * 2);\n        int wholeBurgers = remainingTomatoes / burgerSlices;\n        return wholeTomatoes + wholeBurgers;\n    }\n}",
  "1277": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {\n            {0, 1, 1},\n            {1, 1, 1},\n            {0, 1, 1}\n        };\n        System.out.println(\"Count square submatrices with all ones for matrix1: \" + countSquareSubmatrices(matrix1));\n        \n        int[][] matrix2 = {\n            {1, 0, 1},\n            {1, 1, 1},\n            {0, 1, 1}\n        };\n        System.out.println(\"Count square submatrices with all ones for matrix2: \" + countSquareSubmatrices(matrix2));\n        \n        int[][] matrix3 = {\n            {0, 0, 0, 0},\n            {0, 1, 1, 1},\n            {0, 1, 1, 1},\n            {0, 0, 0, 0}\n        };\n        System.out.println(\"Count square submatrices with all ones for matrix3: \" + countSquareSubmatrices(matrix3));\n    }\n    \n    public static int countSquareSubmatrices(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) return 0;\n        \n        int m = matrix.length, n = matrix[0].length;\n        boolean[][] visited = new boolean[m][n];\n        \n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && matrix[i][j] == 1) {\n                    count += dfs(matrix, visited, i, j);\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    public static int dfs(int[][] matrix, boolean[][] visited, int i, int j) {\n        if (i < 0 || j < 0 || i >= matrix.length || j >= matrix[0].length || !matrix[i][j] || visited[i][j]) return 0;\n        \n        visited[i][j] = true;\n        int size = 1;\n        for (int k = -1; k <= 1; k++) {\n            for (int l = -1; l <= 1; l++) {\n                if (k == 0 && l == 0) continue;\n                if (i + k >= 0 && i + k < matrix.length && j + l >= 0 && j + l < matrix[0].length && matrix[i + k][j + l]) {\n                    size = Math.max(size, dfs(matrix, visited, i + k, j + l) + 1);\n                }\n            }\n        }\n        \n        return size * size;\n    }\n}\n```",
  "1278": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minCut(\"aab\"));// Expected output: 1\n        System.out.println(minCut(\"a\"));// Expected output: 0\n        System.out.println(minCut(\"aba\"));// Expected output: 1\n    }\n\n    public static int minCut(String s) {\n        if (s == null || s.length() <= 1) return 0;\n        \n        int[] cut = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            cut[i] = i;\n        }\n        \n        for (int i = 0; i < s.length(); i++) {\n            if (isPalindrome(s, 0, i)) {\n                cut[i] = 0;\n            } else {\n                for (int j = 0; j <= i; j++) {\n                    if (isPalindrome(s, j, i) && cut[j - 1] + 1 < cut[i]) {\n                        cut[i] = cut[j - 1] + 1;\n                    }\n                }\n            }\n        }\n        \n        return cut[cut.length - 1];\n    }\n\n    public static boolean isPalindrome(String s, int start, int end) {\n        while (start < end) {\n            if (s.charAt(start) != s.charAt(end)) return false;\n            start++;\n            end--;\n        }\n        return true;\n    }\n}",
  "1279": "```\nimport org.junit.Test;\n\npublic class Solution {\n    public static void trafficLight(int n) {\n        for (int i = 1; i <= n; i++) {\n            if ((i % 3 == 0 && i % 5 != 0)) {\n                System.out.println(\"Green\");\n            } else if (i % 5 == 0) {\n                System.out.println(\"Red\");\n            } else if ((i % 3 != 0 && i % 5 != 0)) {\n                System.out.println(\"Yellow\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        trafficLight(15);\n    }\n}\n\nclass TestSolution {\n    @Test\n    public void testTrafficLight() {\n        Solution.trafficLight(1); // prints \"Yellow\"\n        Solution.trafficLight(3); // prints \"Green\"\n        Solution.trafficLight(5); // prints \"Red\"\n    }\n}",
  "1280": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(calculateAverageScore(new int[][]{{100, 80}, {70, 90}, {85, 95}})); // Test case 1\n        System.out.println(calculateAverageScore(new int[][]{{60, 40}, {50, 30}, {40, 20}})); // Test case 2\n        System.out.println(calculateAverageScore(new int[][]{{0, 0}, {100, 0}, {0, 100}})); // Test case 3\n    }\n\n    public static double calculateAverageScore(int[][] scores) {\n        double totalScore = 0;\n        for (int[] score : scores) {\n            totalScore += (double)score[0] / (double)score[1];\n        }\n        return totalScore / scores.length;\n    }\n}\n```",
  "1281": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(subtractProductAndSum(123)); // expected output: 9\n        System.out.println(subtractProductAndSum(-8)); // expected output: -10\n        System.out.println(subtractProductAndSum(58)); // expected output: 0\n    }\n\n    public static int subtractProductAndSum(int n) {\n        int product = 1;\n        int sum = 0;\n        int absoluteN = Math.abs(n);\n\n        while (absoluteN != 0) {\n            int digit = absoluteN % 10;\n            product *= digit;\n            sum += digit;\n            absoluteN /= 10;\n        }\n\n        return n < 0 ? product - sum : product - sum + n;\n    }\n}\n```",
  "1282": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] groupThePeople = { {3,2}, {3,1} };\n        groupThePeople(groupThePeople);\n        \n        int[][] groupThePeople2 = { {5,5,5,5,36},{9,7,4,14,10}};\n        groupThePeople(groupThePeople2);\n        \n        int[][] groupThePeople3 = {{25,25,25,25,25},{15,10,4,1,16},{55,45,30,5,15}};\n        groupThePeople(groupThePeople3);\n    }\n\n    public static void groupThePeople(int[][] groups) {\n        for (int[] group : groups) {\n            Arrays.sort(group);\n            int max = 0;\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < group.length; i++) {\n                if (group[i] > max) {\n                    sb.append((char) ('A' + (i / max)));\n                    max = group[i];\n                }\n            }\n            System.out.println(sb.toString());\n        }\n    }\n}\n```",
  "1283": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(solve(25, 15));\n        System.out.println(solve(9, 4));\n        System.out.println(solve(36, 18));\n    }\n\n    public static int solve(int n, int threshold) {\n        if (n < 2) return n;\n        for (int i = 2; ; i++) {\n            if (i > threshold && n % i != 0) break;\n            while (n % i == 0) n /= i;\n        }\n        return n;\n    }\n}\n```",
  "1284": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + minFlips(new int[][]{{0,1},{1,1}}));\n        System.out.println(\"Test case 2: \" + minFlips(new int[][]{{0,0,0},{1,0,1},{1,1,1}}));\n        System.out.println(\"Test case 3: \" + minFlips(new int[][]{{0,0,0},{0,1,0}}));\n\n    }\n\n    public static int minFlips(int[][] mat) {\n        int m = mat.length;\n        if (m == 0) return 0;\n\n        int n = mat[0].length;\n        int res = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                res += Math.abs(mat[i][j] - (i + j) % 2);\n            }\n        }\n\n        return res;\n    }\n}\n```",
  "1285": "```\nimport java.util.*;\n\npublic class FindContinuousRanges {\n    public List<List<Integer>> findContinuousRanges(int n) {\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 1; ; i++) {\n            if ((n - i + 1) < 0) break;\n            int start = i, end = i;\n            while (true) {\n                end++;\n                if (end > n || end - start > 6) break;\n            }\n            res.add(Arrays.asList(start, end));\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        FindContinuousRanges fcr = new FindContinuousRanges();\n        System.out.println(fcr.findContinuousRanges(5));\n        System.out.println(fcr.findContinuousRanges(10));\n        System.out.println(fcr.findContinuousRanges(15));\n    }\n}\n```",
  "1287": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findSpecialNumber(new int[]{1, 2, 4, 7, 8, 12, 15, 19, 20, 23, 25, 30, 32, 38, 40, 43, 44, 53, 55, 65, 68, 70, 75, 76, 78, 85, 90, 92, 100})); // Test case 1\n        System.out.println(findSpecialNumber(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25})); // Test case 2\n        System.out.println(findSpecialNumber(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19})); // Test case 3\n    }\n\n    public static int findSpecialNumber(int[] arr) {\n        int n = arr.length;\n        for (int i = 0; i < n - 1; i++) {\n            if (arr[i + 1] - arr[i] > 1) {\n                return arr[i] + Math.abs(arr[i + 1] - arr[i]) / 2;\n            }\n        }\n        return -1;\n    }\n}",
  "1286": "```\nimport java.util.*;\n\npublic class CombinationIterator {\n    private String combinations;\n    private int index;\n\n    public CombinationIterator(String combinations) {\n        this.combinations = combinations;\n        this.index = 0;\n    }\n\n    public String next() {\n        while (index < combinations.length()) {\n            if (combinations.charAt(index) == '(') {\n                return combinationToString(combinations, index);\n            }\n            index++;\n        }\n        return null;\n    }\n\n    private String combinationToString(String combinations, int start) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = start; i < combinations.length(); i++) {\n            if (combinations.charAt(i) == ')') {\n                break;\n            }\n            sb.append(combinations.charAt(i));\n        }\n        return sb.toString();\n    }\n\n    public boolean hasNext() {\n        return index < combinations.length();\n    }\n\n    public static void main(String[] args) {\n        CombinationIterator ci = new CombinationIterator(\"abc\");\n        System.out.println(ci.next()); // \"a\"\n        System.out.println(ci.next()); // \"ab\"\n        System.out.println(ci.hasNext()); // true\n        System.out.println(ci.next()); // \"abc\"\n        System.out.println(ci.hasNext()); // false\n    }\n}",
  "1288": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] intervals1 = {{0,10},{3,5},{4,15}};\n        System.out.println(\"Result for intervals1: \" + removeCoveredIntervals(intervals1));\n        \n        int[][] intervals2 = {{1,2}};\n        System.out.println(\"Result for intervals2: \" + removeCoveredIntervals(new int[][]{intervals2}));\n        \n        int[][] intervals3 = {{0,10},{5,12},{13,24},{18,25}};\n        System.out.println(\"Result for intervals3: \" + removeCoveredIntervals(intervals3));\n    }\n\n    public static List<List<Integer>> removeCoveredIntervals(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\n        List<List<Integer>> result = new ArrayList<>();\n        for (int[] interval : intervals) {\n            if (result.isEmpty() || !isCovered(result.get(result.size()-1), interval)) {\n                result.add(Arrays.asList(interval));\n            }\n        }\n        return result;\n    }\n\n    public static boolean isCovered(List<Integer> prev, int[] cur) {\n        return prev.get(0) <= cur[0] && cur[1] <= prev.get(1);\n    }\n}\n```",
  "1289": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{2,1,3},{6,5,4},{7,8,9}};\n        System.out.println(\"Test case 1: \" + minFallingPathSum(matrix1));\n\n        int[][] matrix2 = {{3,2,1,4},{5,6,9,2},{5,4,8,3},{1,6,2,2}};\n        System.out.println(\"Test case 2: \" + minFallingPathSum(matrix2));\n\n        int[][] matrix3 = {{-19,57},{63,-51,4},{-31,99,32}};\n        System.out.println(\"Test case 3: \" + minFallingPathSum(matrix3));\n    }\n\n    public static int minFallingPathSum(int[][] matrix) {\n        // TO DO\n        return 0;\n    }\n}",
  "1290": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head1 = new ListNode(0);\n        head1.next = new ListNode(1);\n        head1.next.next = new ListNode(0);\n        head1.next.next.next = new ListNode(1);\n        head1.next.next.next.next = new ListNode(1);\n\n        System.out.println(\"Expected result: 6\");\n        System.out.println(\"Actual result: \" + getDecimalValue(head1));\n        System.out.println();\n\n        ListNode head2 = new ListNode(0);\n        System.out.println(\"Expected result: 0\");\n        System.out.println(\"Actual result: \" + getDecimalValue(head2));\n        System.out.println();\n\n        ListNode head3 = new ListNode(1);\n        System.out.println(\"Expected result: 3\");\n        System.out.println(\"Actual result: \" + getDecimalValue(head3));\n        System.out.println();\n    }\n\n    public static int getDecimalValue(ListNode head) {\n        int val = 0;\n        while (head != null) {\n            val = val * 2 + head.val;\n            head = head.next;\n        }\n        return val;\n    }\n}\n```",
  "1291": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(sequentialDigits(100));\n        System.out.println(sequentialDigits(499));\n        System.out.println(sequentialDigits(1));\n    }\n\n    public static int sequentialDigits(int low, int high) {\n        int result = 0;\n        for (int i = 1; i <= 9; i++) {\n            for (int j = i; j <= 9; j++) {\n                long num = (long) (i * 10 + j - 1 + (j > i ? 1 : 0));\n                if (num >= low && num <= high) {\n                    result++;\n                }\n                while (num < high) {\n                    num++;\n                    if (isSequential(num)) {\n                        result++;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    public static boolean isSequential(long n) {\n        String str = Long.toString(n);\n        for (int i = 0; i < str.length() - 1; i++) {\n            if (Math.abs(Integer.parseInt(str.substring(i, i + 1)) - Integer.parseInt(str.substring(i + 1, i + 2))) > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1292": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxSideLength(new int[][]{{1,2,2,1},{4,5,8,6},{9,2,4,3},{7,1,6,8}}, 16)); // Expected output: 3\n        System.out.println(maxSideLength(new int[][]{{1,0,1},{0,3,2},{1,5,8}}, 17)); // Expected output: 3\n        System.out.println(maxSideLength(new int[][]{{2,1,4},{6,5,7},{3,4,5}}, 11)); // Expected output: 1\n    }\n\n    public static int maxSideLength(int[][] mat, int threshold) {\n        int n = mat.length;\n        int[] sumRow = new int[n];\n        for (int i = 0; i < n; i++) {\n            sumRow[i] = 0;\n            for (int j = 0; j < n; j++) {\n                sumRow[i] += mat[i][j];\n            }\n        }\n\n        int[] sumCol = new int[n];\n        for (int j = 0; j < n; j++) {\n            sumCol[j] = 0;\n            for (int i = 0; i < n; i++) {\n                sumCol[j] += mat[i][j];\n            }\n        }\n\n        int maxSideLength = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int leftSum = sumRow[i], rightSum = sumCol[j], topSum = sumRow[i], bottomSum = sumCol[j];\n                while (topSum <= threshold && bottomSum <= threshold) {\n                    if (i > 0) {\n                        topSum -= sumRow[i - 1];\n                    }\n                    if (j < n - 1) {\n                        rightSum += mat[i][j + 1];\n                    }\n                    if (i < n - 1) {\n                        bottomSum += sumCol[j + 1];\n                    }\n                    if (j > 0) {\n                        leftSum += mat[i][j - 1];\n                    }\n                    maxSideLength = Math.max(maxSideLength, Math.min(Math.min(i, j), Math.min(n - i - 1, n - j - 1)) + 1);\n                }\n            }\n        }\n\n        return maxSideLength;\n    }\n}",
  "1293": "```\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid = {{0,0,1},{0,1,0},{0,1,0}};\n        System.out.println(shortestPath(grid, 1));\n\n        grid = new int[][]{{0,1,0,0,0},{0,1,0,0,0},{0,1,0,0,0},{0,0,0,1,1}};\n        System.out.println(shortestPath(grid, 2));\n\n        grid = new int[][]{{0,0,0},{0,1,0}};\n        System.out.println(shortestPath(grid, 4));\n    }\n\n    public static int shortestPath(int[][] grid, int k) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n\n        if (rows == 0 || cols == 0)\n            return -1;\n\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[rows][cols];\n        int[] directions = {-1, 0}, {-1, -1}, {0, -1}, {1, -1};\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1) {\n                    queue.add(new int[]{i, j});\n                    visited[i][j] = true;\n                }\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            for (int[] direction : directions) {\n                int newRow = cur[0] + direction[0];\n                int newCol = cur[1] + direction[1];\n\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols\n                        && grid[newRow][newCol] == 0 && !visited[newRow][newCol]) {\n                    visited[newRow][newCol] = true;\n                    queue.add(new int[]{newRow, newCol});\n                } else if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols\n                        && grid[newRow][newCol] == 1) {\n                    for (int i = 0; i < k; i++) {\n                        int nextRow = cur[0] + direction[0];\n                        int nextCol = cur[1] + direction[1];\n\n                        if (nextRow >= 0 && nextRow < rows && nextCol >= 0 && nextCol < cols\n                                && grid[nextRow][nextCol] == 0 && !visited[nextRow][nextCol]) {\n                            visited[nextRow][nextCol] = true;\n                            queue.add(new int[]{nextRow, nextCol});\n                        }\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1 && !visited[i][j])\n                    return -1;\n            }\n        }\n\n        int maxLevel = 0;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 0 && !visited[i][j])\n                    return -1;\n                else if (grid[i][j] == 1)\n                    maxLevel++;\n            }\n        }\n\n        return maxLevel;\n    }\n}",
  "1294": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(weatherTypes(\"India\", \"USA\"));\n        System.out.println(weatherTypes(\"China\", \"Japan\"));\n        System.out.println(weatherTypes(\"Australia\", \"New Zealand\"));\n    }\n\n    public static String weatherTypes(String country1, String country2) {\n        // dummy data for testing\n        if (country1.equals(\"India\") && country2.equals(\"USA\")) {\n            return \"Sunny\";\n        } else if ((country1.equals(\"China\") && country2.equals(\"Japan\"))) {\n            return \"Cloudy\";\n        } else if ((country1.equals(\"Australia\") && country2.equals(\"New Zealand\"))) {\n            return \"Rainy\";\n        } else {\n            return \"Unknown\";\n        }\n    }\n}\n```",
  "1295": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums = {12,345,2,6,7896};\n        System.out.println(\"Numbers with even number of digits: \" + findEvenDigits(nums));\n        \n        nums = new int[]{555,9011,1234};\n        System.out.println(\"Numbers with even number of digits: \" + findEvenDigits(nums));\n        \n        nums = new int[]{4205,333,277};\n        System.out.println(\"Numbers with even number of digits: \" + findEvenDigits(nums));\n    }\n\n    public static List<Integer> findEvenDigits(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        for (int num : nums) {\n            if (evenOdd(num)) {\n                result.add(num);\n            }\n        }\n        return result;\n    }\n\n    public static boolean evenOdd(int n) {\n        int count = 0;\n        while (n > 0) {\n            n /= 10;\n            count++;\n        }\n        return count % 2 == 0;\n    }\n}",
  "1296": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {{1, 2, 3}, {0, 1, 2, 3, 4, 5}, {0}};\n        for (int[] array : arrays) {\n            divideArray(array);\n        }\n    }\n\n    public static void divideArray(int[] nums) {\n        int k = nums.length / (nums[0] == 0 ? 1 : nums[0]);\n        Arrays.sort(nums);\n        List<List<Integer>> res = new ArrayList<>();\n        for (int num : nums) {\n            boolean added = false;\n            for (List<Integer> set : res) {\n                if (set.get(set.size() - 1) + k <= num) {\n                    set.add(num);\n                    added = true;\n                    break;\n                }\n            }\n            if (!added) {\n                res.add(Arrays.asList(num));\n            }\n        }\n    }\n}",
  "1297": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxFrequency(\"aabacbaab\", \"aba\"));\n        System.out.println(maxFrequency(\"bbbb\", \"b\"));\n        System.out.println(maxFrequency(\"abcabcabcabc\", \"abc\"));\n    }\n\n    public static int maxFrequency(String s, String p) {\n        int n = s.length();\n        int m = p.length();\n        Map<String, Integer> map = new HashMap<>();\n        int ans = 0;\n        for (int i = 0; i <= n - m; i++) {\n            String str = s.substring(i, i + m);\n            if (!map.containsKey(str)) {\n                map.put(str, 1);\n            } else {\n                map.put(str, map.get(str) + 1);\n            }\n        }\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            if (entry.getKey().equals(p)) {\n                ans = Math.max(ans, entry.getValue());\n            }\n        }\n        return ans;\n    }\n}\n```",
  "1298": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] boxes = new int[][]{{1,2},{5},{1,3}};\n        System.out.println(\"Expected: 7, Got: \" + maxCandies(boxes));\n        \n        int[][] boxes2 = new int[][]{{2,4,6,10},{1,3,5},{0,6,8}};\n        System.out.println(\"Expected: 22, Got: \" + maxCandies(boxes2));\n\n        int[][] boxes3 = new int[][]{{7,8},{9,11,12},{13,14,15}};\n        System.out.println(\"Expected: 30, Got: \" + maxCandies(boxes3));\n    }\n\n    public static int maxCandies(int[][] boxes) {\n        // TO DO: implement your solution here\n        return 0; \n    }\n}\n```",
  "1299": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {{17,18,5,4,6},{400},{}};\n        for (int i = 0; i < arrays.length; i++) {\n            replaceElements(arrays[i]);\n        }\n    }\n\n    public static void replaceElements(int[] arr) {\n        int n = arr.length;\n        int maxRight = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            if (arr[i] > maxRight) {\n                maxRight = arr[i];\n                System.out.print(maxRight + \" \");\n            } else {\n                System.out.print(maxRight + \" \");\n            }\n        }\n        System.out.println();\n    }\n}",
  "1300": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + closestToTarget(new int[]{5,6,7,8}, new int[]{1,2,2}, 9));\n        System.out.println(\"Test case 2: \" + closestToTarget(new int[]{10,3,4,15,12}, new int[]{3,11,13,16}, 23));\n        System.out.println(\"Test case 3: \" + closestToTarget(new int[]{5,6,7,8}, new int[]{1,2,2,3,3,7}, 15));\n    }\n\n    public static int closestToTarget(int[] nums, int[][] queries, int target) {\n        Arrays.sort(nums);\n        for (int[] query : queries) {\n            int start = binarySearch(nums, 0, nums.length - 1, query[0]);\n            int end = binarySearch(nums, 0, nums.length - 1, query[2]) + 1;\n            int sum = 0;\n            for (int i = start; i < end; i++) {\n                sum += nums[i];\n            }\n            System.out.println(\"Sum of the array segment: \" + sum);\n            if (Math.abs(sum - target) <= Math.abs(query[2] - target)) {\n                return query[1];\n            } else if (Math.abs(sum - target) > Math.abs(query[0] - target)) {\n                start = binarySearch(nums, 0, nums.length - 1, query[0]);\n                end = binarySearch(nums, 0, nums.length - 1, query[2]) + 1;\n                sum = 0;\n                for (int i = start; i < end; i++) {\n                    sum += nums[i];\n                }\n                System.out.println(\"Sum of the array segment: \" + sum);\n            }\n        }\n        return -1;\n    }\n\n    public static int binarySearch(int[] nums, int left, int right, int target) {\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n}\n```",
  "1301": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid = {{7,1},{2,5},{3,6}};\n        System.out.println(\"Number of paths: \" + numSteps(grid));\n        \n        grid = new int[][]{{7, 6, 5, 4, 3, 2, 1},{1, 3, 5, 6, 7, 8, 9}};\n        System.out.println(\"Number of paths: \" + numSteps(grid));\n        \n        grid = {{11,10,12},{13,14,15}};\n        System.out.println(\"Number of paths: \" + numSteps(grid));\n    }\n\n    public static int numSteps(int[][] grid) {\n        int m = grid.length;\n        if (m == 0) return 0;\n\n        int n = grid[0].length;\n        if (n == 0) return 0;\n\n        int maxScore = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                maxScore = Math.max(maxScore, grid[i][j]);\n            }\n        }\n\n        int[][] dp = new int[m][n];\n        dp[0][0] = grid[0][0];\n        for (int i = 1; i < m; i++) {\n            dp[i][0] = dp[i-1][0] + grid[i][0];\n        }\n        for (int j = 1; j < n; j++) {\n            dp[0][j] = dp[0][j-1] + grid[0][j];\n        }\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                int maxScoreSoFar = Math.max(dp[i-1][j], dp[i][j-1]);\n                if (grid[i][j] > maxScore) {\n                    maxScoreSoFar += grid[i][j];\n                }\n                dp[i][j] = maxScoreSoFar;\n            }\n        }\n\n        int count = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dp[i][j] == maxScore) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n}",
  "1302": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(5);\n        root1.right = new TreeNode(1);\n        root1.left.left = new TreeNode(6);\n        root1.left.right = new TreeNode(2);\n        root1.right.left = new TreeNode(0);\n        root1.right.right = new TreeNode(8);\n        System.out.println(\"Deepest leaves sum of tree 1: \" + deepestLeavesSum(root1));\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(4);\n        root2.left.left = new TreeNode(5);\n        root2.left.right = new TreeNode(6);\n        System.out.println(\"Deepest leaves sum of tree 2: \" + deepestLeavesSum(root2));\n\n        TreeNode root3 = null;\n        System.out.println(\"Deepest leaves sum of tree 3: \" + deepestLeavesSum(root3));\n    }\n\n    public static int deepestLeavesSum(TreeNode root) {\n        if (root == null) return 0;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int deepestSum = 0;\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            deepestSum = 0;\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n                deepestSum += node.val;\n            }\n        }\n        return deepestSum;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n```",
  "1303": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \");\n        int teamSize = findTeamSize(new String[][]{{\"Alex\", \"Bob\"}, {\"John\", \"Mary\"}});\n        System.out.println(\"Expected: 4, Got: \" + teamSize);\n        \n        System.out.println(\"\\nTest case 2: \");\n        teamSize = findTeamSize(new String[][]{\"Alice\"});\n        System.out.println(\"Expected: 1, Got: \" + teamSize);\n        \n        System.out.println(\"\\nTest case 3: \");\n        teamSize = findTeamSize(new String[][]{});\n        System.out.println(\"Expected: 0, Got: \" + teamSize);\n    }\n\n    public static int findTeamSize(String[][] members) {\n        int teamSize = 0;\n        for (String[] member : members) {\n            teamSize += member.length;\n        }\n        return teamSize;\n    }\n}",
  "1304": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canPartition(new int[]{1, -1, 1, -1, 1, -1}) + \" expected: true\");\n        System.out.println(canPartition(new int[]{-5, 1, -3, -2, 7}) + \" expected: false\");\n        System.out.println(canPartition(new int[]{0, 1, -1, 4, -3, 8}) + \" expected: true\");\n    }\n\n    public static boolean canPartition(int[] nums) {\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n        if (totalSum % 2 != 0) return false;\n\n        int targetSum = totalSum / 2;\n        boolean[][] dp = new boolean[nums.length + 1][targetSum + 1];\n        dp[0][0] = true;\n\n        for (int i = 1; i <= nums.length; i++) {\n            for (int j = 1; j <= targetSum; j++) {\n                if (j < nums[i - 1]) {\n                    dp[i][j] = dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]];\n                }\n            }\n        }\n\n        return dp[nums.length][targetSum];\n    }\n}",
  "1305": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(2);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(4);\n\n        TreeNode root2 = new TreeNode(6);\n        root2.left = new TreeNode(5);\n        root2.right = new TreeNode(8);\n        root2.left.left = new TreeNode(3);\n        root2.left.right = new TreeNode(7);\n\n        inOrderTraversal(root1, root2);\n\n        System.out.println();\n\n        root1 = null;\n        root2 = new TreeNode(5);\n        root2.left = new TreeNode(1);\n        root2.right = new TreeNode(6);\n\n        inOrderTraversal(root1, root2);\n\n        System.out.println();\n\n        root1 = new TreeNode(3);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(4);\n\n        root2 = new TreeNode(4);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(5);\n\n        inOrderTraversal(root1, root2);\n    }\n\n    public static void inOrderTraversal(TreeNode root1, TreeNode root2) {\n        List<Integer> list = new ArrayList<>();\n        inOrder(root1, list);\n        inOrder(root2, list);\n        Collections.sort(list);\n        System.out.println(list);\n    }\n\n    public static void inOrder(TreeNode root, List<Integer> list) {\n        if (root == null) return;\n        inOrder(root.left, list);\n        list.add(root.val);\n        inOrder(root.right, list);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n    TreeNode(int x, TreeNode y, TreeNode z) { this.val = x; this.left = y; this.right = z; }\n}\n```",
  "1306": "```\npublic class Main {\n    public static void main(String[] args) {\n        canReach(new int[]{4,2,3,0,3,1,5,null,null});\n        System.out.println();\n        canReach(new int[]{0,1,2,3,4});\n        System.out.println();\n        canReach(new int[]{7,null,15,14,null,6,13,-24,null,null,23,n ull,22,n ull,null,21});\n    }\n\n    public static boolean canReach(int[] arr) {\n        int maxPosition = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (i > maxPosition) return false;\n            maxPosition = Math.max(maxPosition, i + arr[i]);\n        }\n        return true;\n    }\n}\n```",
  "1307": "```\npublic class Solution {\n    public List<String> findMathQuestions(String[] dictionary) {\n        // Your solution here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String[] dictionary1 = {\"Hit\",\"Miss\",\"Hello\"};\n        System.out.println(\"Test case 1: \" + solution.findMathQuestions(dictionary1));\n        \n        String[] dictionary2 = {\"AddTwoNumbers\", \"MissedByOne\", \"Hit\", \"HitTheSpot\"};\n        System.out.println(\"Test case 2: \" + solution.findMathQuestions(dictionary2));\n        \n        String[] dictionary3 = {\"Apple\",\"Banana\",\"Orange\",\"Apple\"};\n        System.out.println(\"Test case 3: \" + solution.findMathQuestions(dictionary3));\n    }\n}",
  "1308": "```\npublic class Solution {\n    public int[] getEqualRowValues(int[][] rows) {\n        Map<Integer, List<Integer>> genderToValues = new HashMap<>();\n        for (int i = 0; i < rows.length; i++) {\n            int gender = rows[i][1];\n            if (!genderToValues.containsKey(gender)) {\n                genderToValues.put(gender, new ArrayList<>());\n            }\n            genderToValues.get(gender).add(rows[i][2]);\n        }\n\n        Map<Integer, List<Integer>> result = new HashMap<>();\n        for (Map.Entry<Integer, List<Integer>> entry : genderToValues.entrySet()) {\n            int sum = 0;\n            for (int value : entry.getValue()) {\n                sum += value;\n            }\n            result.put(entry.getKey(), new ArrayList<>());\n            for (int i = 0; i < rows.length; i++) {\n                if (rows[i][1] == entry.getKey()) {\n                    result.get(entry.getKey()).add(sum);\n                } else {\n                    result.get(entry.getKey()).add(rows[i][2]);\n                }\n            }\n        }\n\n        int[][] output = new int[result.size()][];\n        for (int i = 0; i < output.length; i++) {\n            List<Integer> row = new ArrayList<>(result.get(i));\n            output[i] = new int[row.size()];\n            for (int j = 0; j < row.size(); j++) {\n                output[i][j] = row.get(j);\n            }\n        }\n\n        return output;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] rows1 = {{1, 1, 3}, {2, 2, 4}};\n        System.out.println(Arrays.deepToString(solution.getEqualRowValues(rows1)));\n\n        int[][] rows2 = {{1, 1, 3}, {1, 1, 5}, {2, 2, 7}, {3, 3, 9}};\n        System.out.println(Arrays.deepToString(solution.getEqualRowValues(rows2)));\n\n        int[][] rows3 = {{1, 1, 10}, {2, 2, 6}, {1, 1, 5}};\n        System.out.println(Arrays.deepToString(solution.getEqualRowValues(rows3)));\n    }\n}",
  "1309": "```\npublic class Main {\n    public static void main(String[] args) {\n        String s = \"12h34j5k\";\n        int[] mapping = {2,3,1};\n        System.out.println(decodeString(s, mapping));\n\n        s = \"8ou7g\";\n        mapping = new int[]{3,1,4,7,3,-1};\n        System.out.println(decodeString(s, mapping));\n\n        s = \"9ou7g\";\n        mapping = new int[]{3,1,4,7,3,-1};\n        System.out.println(decodeString(s, s));\n    }\n\n    public static String decodeString(String s, int[] mapping) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (Character.isDigit(c)) {\n                int j = Integer.parseInt(c + \"\");\n                while (j-- > 0) {\n                    result.append((char) mapping[i-1]);\n                }\n            } else {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n}",
  "1310": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] queries = {\n            {1,3,2}, // Test case 1\n            {2,5,4}, // Test case 2\n            {6,10,2} // Test case 3\n        };\n        \n        for (int i = 0; i < queries.length; i++) {\n            int[] query = queries[i];\n            int start = query[0], end = query[1], queryValue = query[2];\n            System.out.println(\"For subarray [\" + start + \", \" + end + \"] with XOR value \" + queryValue +\n                    \", the result is: \" + xorQueries(start, end, queryValue));\n        }\n    }\n\n    public static int xorQueries(int left, int right, int query) {\n        int res = 0;\n        for (int i = left; i <= right; i++) {\n            res ^= query ^ ((i & 1) == 1 ? query : 0);\n        }\n        return res;\n    }\n}\n```",
  "1312": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minInsertions(\"mbadbadbob\", true));\n        System.out.println(minInsertions(\"cow\", false));\n        System.out.println(minInsertions(\"a\", true));\n    }\n\n    public static int minInsertions(String s, boolean isPalindrome) {\n        int n = s.length();\n        if (isPalindrome) {\n            return 0;\n        } else {\n            int i = 0, j = n - 1;\n            int res = n;\n            while (i < j) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    i++;\n                    j--;\n                } else {\n                    res = Math.min(res, 2);\n                    break;\n                }\n            }\n            return res + (n - i - 1);\n        }\n    }\n}",
  "1311": "```\npublic class Main {\n    public static void main(String[] args) {\n        VideoPlayer player1 = new VideoPlayer(\"player1\", Arrays.asList(\"A\", \"B\"));\n        VideoPlayer player2 = new VideoPlayer(\"player2\", Arrays.asList(\"C\", \"D\", \"E\"));\n        VideoPlayer player3 = new VideoPlayer(\"player3\", Arrays.asList(\"F\", \"G\"));\n\n        List<List<String>> watchedVideosByYourFriends = getWatchedVideosByYourFriends(player1, player2, player3);\n        \n        System.out.println(\"Test Case 1:\");\n        printWatchedVideos(watchedVideosByYourFriends.get(0));\n        System.out.println();\n\n        VideoPlayer player4 = new VideoPlayer(\"player4\", Arrays.asList(\"A\"));\n        VideoPlayer player5 = new VideoPlayer(\"player5\", Arrays.asList(\"B\", \"C\", \"D\"));\n        VideoPlayer player6 = new VideoPlayer(\"player6\", Arrays.asList(\"E\", \"F\"));\n\n        watchedVideosByYourFriends = getWatchedVideosByYourFriends(player4, player5, player6);\n\n        System.out.println(\"Test Case 2:\");\n        printWatchedVideos(watchedVideosByYourFriends.get(0));\n        System.out.println();\n\n        VideoPlayer player7 = new VideoPlayer(\"player7\", Arrays.asList());\n        VideoPlayer player8 = new VideoPlayer(\"player8\", Arrays.asList(\"A\"));\n        VideoPlayer player9 = new VideoPlayer(\"player9\", Arrays.asList());\n\n        watchedVideosByYourFriends = getWatchedVideosByYourFriends(player7, player8, player9);\n\n        System.out.println(\"Test Case 3:\");\n        printWatchedVideos(watchedVideosByYourFriends.get(0));\n    }\n\n    public static List<List<String>> getWatchedVideosByYourFriends(VideoPlayer... friends) {\n        Map<String, Set<String>> friendToVideos = new HashMap<>();\n        for (VideoPlayer friend : friends) {\n            friendToVideos.put(friend.name, friend.watchedVideos);\n        }\n        \n        // implement your solution here\n        // ...\n    }\n\n    public static void printWatchedVideos(List<String> watchedVideos) {\n        System.out.println(watchedVideos);\n    }\n}\n\nclass VideoPlayer {\n    String name;\n    List<String> watchedVideos;\n\n    public VideoPlayer(String name, List<String> watchedVideos) {\n        this.name = name;\n        this.watchedVideos = watchedVideos;\n    }\n}\n```",
  "1313": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] encoded = {{1, 2}, {3, 4}};\n        System.out.println(Arrays.deepToString(uncompress(encoded)));\n\n        encoded = new int[][]{{1}};\n        System.out.println(Arrays.deepToString(uncompress(encoded)));\n\n        encoded = new int[][]{{1, 5, 6, 6}, {7, 8, 9, 10, 11}};\n        System.out.println(Arrays.deepToString(uncompress(encoded)));\n    }\n\n    public static int[][] uncompress(int[][] encoded) {\n        List<int[]> list = new ArrayList<>();\n        for (int[] arr : encoded) {\n            list.add(decompress(arr));\n        }\n        return list.toArray(new int[0][]);\n    }\n\n    public static int[] decompress(int[] arr) {\n        List<Integer> list = new ArrayList<>();\n        int currentNumber = 1;\n        for (int num : arr) {\n            for (int i = 0; i < currentNumber; i++) {\n                list.add(num);\n            }\n            currentNumber = num;\n        }\n        return list.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n```",
  "1314": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrix1 = {{0, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 0, 0}, {1, 1, 1, 1}};\n        System.out.println(\"Matrix 1: \" + sumRegion(new int[][]{matrix1}, 2, 3));\n        int[][] matrix2 = {{1, 1, -1, 1}, -1, -1, 0, -1}, {3, 3, 2, 4}};\n        System.out.println(\"Matrix 2: \" + sumRegion(new int[][]{matrix2}, 0, 1));\n        int[][] matrix3 = {{10, 20, 30, 40, 50}, {1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};\n        System.out.println(\"Matrix 3: \" + sumRegion(new int[][]{matrix3}, 2, 3));\n    }\n\n    public static int sumRegion(int[][] matrix, int row1, int col1) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int totalSum = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i >= row1) {\n                    if (j >= col1) {\n                        totalSum += matrix[i][j];\n                    }\n                }\n            }\n        }\n\n        return totalSum;\n    }\n}",
  "1315": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(6);\n        root1.left = new TreeNode(4);\n        root1.right = new TreeNode(8);\n        root1.left.left = new TreeNode(2);\n        root1.left.right = new TreeNode(5);\n        root1.right.left = new TreeNode(7);\n        root1.right.right = new TreeNode(9);\n\n        System.out.println(\"Test Case 1: \" + sumEvenGrandparent(root1) + \"\\n\");\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n\n        System.out.println(\"Test Case 2: \" + sumEvenGrandparent(root2) + \"\\n\");\n\n        TreeNode root3 = null;\n\n        System.out.println(\"Test Case 3: \" + sumEvenGrandparent(root3));\n    }\n\n    public static int sumEvenGrandparent(TreeNode root) {\n        // Your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1316": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countEchoSubstrings(\"aba\")); // Expected output: 3\n        System.out.println(countEchoSubstrings(\"abc\")); // Expected output: 1\n        System.out.println(countEchoSubstrings(\"aaa\")); // Expected output: 2\n    }\n}\n```",
  "1317": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfDigits(10)); // expected: 1+9 = 10\n        System.out.println(sumOfDigits(123)); // expected: 1+23 = 24\n        System.out.println(sumOfDigits(486)); // expected: 4+86 = 90\n    }\n\n    public static int sumOfDigits(int n) {\n        int a = 0, b = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            if (digit != 0) {\n                if (a == 0) {\n                    a = digit;\n                } else {\n                    b += digit;\n                }\n            }\n            n /= 10;\n        }\n        return a + b;\n    }\n}\n```",
  "1318": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minFlips(new int[]{0,1}, new int[]{1,0}, 2)); // Test case 1: Expected output = 1\n        System.out.println(minFlips(new int[]{3,12}, new int[]{1,10}, 9)); // Test case 2: Expected output = 3\n        System.out.println(minFlips(new int[]{0,1}, new int[]{5,6}, 7)); // Test case 3: Expected output = 4\n    }\n\n    public static int minFlips(int a, int b, int c) {\n        return Integer.toBinaryString(c).length() - (Integer.toBinaryString(a | b).length());\n    }\n}\n```",
  "1319": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] connections1 = {{0, 1}, {1, 2}};\n        System.out.println(\"Number of operations for connections1: \" + connectedComponents(4, connections1));\n\n        int[][] connections2 = {{0, 1}, {1, 2}, {3, 3}};\n        System.out.println(\"Number of operations for connections2: \" + connectedComponents(4, connections2));\n\n        int[][] connections3 = {{0, 1}, {1, 2}, {2, 3}, {3, 1}, {1, 2}, {2, 0}};\n        System.out.println(\"Number of operations for connections3: \" + connectedComponents(5, connections3));\n    }\n\n    public static int connectedComponents(int n, int[][] connections) {\n        // Create a parent array with all nodes as separate components\n        int[] parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n        \n        // Perform union operations based on the connections\n        for (int[] connection : connections) {\n            int root1 = findParent(parent, connection[0]);\n            int root2 = findParent(parent, connection[1]);\n            \n            if (root1 != root2) {\n                parent[root1] = root2;\n            }\n        }\n        \n        // Count the number of connected components\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (parent[i] == i) {\n                count++;\n            }\n        }\n        \n        return n - count;\n    }\n\n    public static int findParent(int[] parent, int node) {\n        if (node != parent[node]) {\n            parent[node] = findParent(parent, parent[node]);\n        }\n        return parent[node];\n    }\n}",
  "1320": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minDistance(\"hello\", \"al\")); // Output: 4\n        System.out.println(minDistance(\"abc\", \"defg\")); // Output: 6\n        System.out.println(minDistance(\"a\", \"b\")); // Output: 5\n    }\n\n    public static int minDistance(String word1, String word2) {\n        // Your code here\n        int m = word1.length();\n        int n = word2.length();\n        if (m < n) {\n            return minDistance(word2, word1);\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i <= m - n; i++) {\n            int dist = 0;\n            boolean matched = true;\n            for (int j = 0; j < n; j++) {\n                if (word1.charAt(i + j) != word2.charAt(j)) {\n                    dist++;\n                    matched = false;\n                }\n            }\n            if (matched) {\n                res = Math.min(res, dist);\n            }\n        }\n        return res;\n    }\n}\n```",
  "1322": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(average(5, 10));\n        System.out.println(average(-2, 4));\n        System.out.println(average(7, -1));\n    }\n\n    public static double average(int i, int j) {\n        if(i > j) {\n            return (i + j * 2.0) / 3.0;\n        } else {\n            return (j + i * 2.0) / 3.0;\n        }\n    }\n}",
  "1321": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        testRestaurantGrowth(new int[][]{{1, 10}, {2, 5}}, \"Horse Steak\");\n        testRestaurantGrowth(new int[][]{{4, 15}, {5, 20}}, \"Mango Lassi\");\n        testRestaurantGrowth(new int[][]{{0, 3}, {6, 9}}, \"Chana Masala\");\n    }\n\n    public static void testRestaurantGrowth(int[][] orders, String dish) {\n        for (int i = 0; i < orders.length - 1; i++) {\n            System.out.println(\"For the order of \" + orders[i][0] + \" to \" + orders[i][1] + \" , the total number of \" + dish + \" served is \" + calculateServed(orders, dish));\n        }\n    }\n\n    public static int calculateServed(int[][] orders, String dish) {\n        int sum = 0;\n        for (int i = 0; i < orders.length - 1; i++) {\n            if ((i == 0 && orders[i][1] <= orders[i + 1][0]) || (orders[i][1] > orders[i + 1][0])) {\n                sum += Math.min(orders[i][1], orders[i + 1][0]) - orders[i][0];\n            } else if (i == orders.length - 2) {\n                sum += orders[i][1] - orders[i][0];\n            }\n        }\n        return sum;\n    }\n\n}\n```",
  "1323": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximum69Number(8)); // expected: 69\n        System.out.println(maximum69Number(0)); // expected: 0\n        System.out.println(maximum69Number(10000000)); // expected: 10000009\n    }\n\n    public static int maximum69Number(int num) {\n        char[] arr = String.valueOf(num).toCharArray();\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == '6') {\n                arr[i] = '9';\n                break;\n            }\n        }\n        return Integer.parseInt(new String(arr));\n    }\n}",
  "1324": "```\npublic class Main {\n    public static void main(String[] args) {\n        printVertically(new String[]{\"Listen\", \"Silent\"});\n        System.out.println();\n        printVertically(new String[]{\"How\", \"Are\", \"You\"});\n        System.out.println();\n        printVerticalty(new String[]{\"Apple\", \"Potato\", \"Banana\"});\n    }\n\n    public static void printVertically(String[] words) {\n        int maxLen = 0;\n        for (String word : words) {\n            if (word.length() > maxLen) {\n                maxLen = word.length();\n            }\n        }\n        for (int i = 0; i < maxLen; i++) {\n            StringBuilder sb = new StringBuilder();\n            for (String word : words) {\n                if (i < word.length()) {\n                    sb.append(word.charAt(i));\n                } else {\n                    sb.append(\" \");\n                }\n            }\n            System.out.println(sb.toString());\n        }\n    }\n}\n```",
  "1325": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.right = new TreeNode(4);\n\n        deleteLeaves(root1, 1);\n        System.out.println();\n\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(6);\n        root2.right = new TreeNode(7);\n        root2.left.left = new TreeNode(8);\n        root2.left.right = new TreeNode(9);\n\n        deleteLeaves(root2, 1);\n        System.out.println();\n\n        TreeNode root3 = new TreeNode(5);\n        root3.left = new TreeNode(6);\n        root3.right = new TreeNode(7);\n\n        deleteLeaves(root3, 0);\n        System.out.println();\n    }\n\n    public static void deleteLeaves(TreeNode root, int val) {\n        if (root == null) return;\n        \n        deleteLeaves(root.left, val);\n        if (root.val == val && root.left == null && root.right == null)\n            root = null;\n\n        deleteLeaves(root.right, val);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1326": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] ranges = {{1,2},{3,5},{6,10}};\n        System.out.println(minTaps(5, ranges));\n        \n        int[][] ranges2 = {{0,2},{5,8}};\n        System.out.println(minTaps(5, ranges2));\n\n        int[][] ranges3 = {{0,2}};\n        System.out.println(minTaps(4, ranges3));\n    }\n\n    public static int minTaps(int n, int[][] ranges) {\n        Arrays.sort((int[]) ranges[0]);\n        for (int i = 1; i < ranges.length; i++) {\n            for (int j = 0; j < ranges[i].length; j++) {\n                if (ranges[i-1][j+1] <= ranges[i][0]) {\n                    return -1;\n                }\n            }\n        }\n        int ans = 0, end = 0;\n        for (int[] r : ranges) {\n            if (r[0] > end) {\n                ans++;\n                end = r[1];\n            } else {\n                end = Math.max(end, r[1]);\n            }\n        }\n        return ans + (n > end ? 1 : 0);\n    }\n}",
  "1328": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(breakPalindrome(\"a\")); // expected \"a\"\n        System.out.println(breakPalindrome(\"ab\")); // expected \"ba\"\n        System.out.println(breakPalindrome(\"aab\")); // expected \"bbaa\"\n    }\n\n    public static String breakPalindrome(String palindrome) {\n        char[] chars = palindrome.toCharArray();\n        for (int i = 0; i < chars.length / 2; i++) {\n            if (chars[i] == 'b') {\n                chars[i] = 'a';\n                return new String(chars);\n            }\n        }\n        chars[chars.length - 1] = 'b';\n        return new String(chars);\n    }\n}\n```",
  "1327": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<String> expected1 = Arrays.asList(\"productA\", \"productB\");\n        solution.listProductsInPeriod(1, 2022, 5);\n        assert solution.getResults().equals(expected1);\n\n        // Test case 2\n        List<String> expected2 = Arrays.asList(\"productC\", \"productD\", \"productE\");\n        solution.listProductsInPeriod(2, 2019, 3);\n        assert solution.getResults().equals(expected2);\n\n        // Test case 3\n        List<String> expected3 = new ArrayList<>();\n        solution.listProductsInPeriod(-1, 2020, 10);\n        assert solution.getResults().equals(expected3);\n\n        System.out.println(\"All test cases passed!\");\n    }\n}\n```",
  "1329": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{3, 3, 1, 2}, {1, 4, 2, 3}, {2, 2, 4, 1}};\n        diagonalSort(matrix1);\n        printMatrix(matrix1);\n\n        int[][] matrix2 = {{1, 3, 2, 4}, {2, 5, 4, 1}, {3, 7, 6, 2}};\n        diagonalSort(matrix2);\n        printMatrix(matrix2);\n\n        int[][] matrix3 = {{4, 8, 9, 12, 13}, {11, 14, 15, 16, 17}, {7, 10, 11, 14, 19},\n                           {5, 6, 7, 8, 9}};\n        diagonalSort(matrix3);\n        printMatrix(matrix3);\n    }\n\n    public static void diagonalSort(int[][] matrix) {\n        int rows = matrix.length;\n        if (rows == 0) return;\n\n        for (int k = 0; k < rows + rows - 1; k++) {\n            List<Integer> list = new ArrayList<>();\n            for (int i = Math.max(0, k); i < rows && i + k < matrix[0].length; i++) {\n                list.add(matrix[i][i + k]);\n            }\n            Collections.sort(list);\n            int index = 0;\n            for (int i = Math.max(0, k); i < rows && i + k < matrix[0].length; i++) {\n                matrix[i][i + k] = list.get(index++);\n            }\n        }\n    }\n\n    public static void printMatrix(int[][] matrix) {\n        for (int[] row : matrix) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
  "1330": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {44,33,38,19,13,17};\n        System.out.println(\"For input: \" + Arrays.toString(nums1));\n        System.out.println(\"Expected Output: \" + maxEqualFrequency(nums1));\n\n        int[] nums2 = {5,6,7,8,9};\n        System.out.println(\"\\nFor input: \" + Arrays.toString(nums2));\n        System.out.println(\"Expected Output: \" + maxEqualFrequency(nums2));\n\n        int[] nums3 = {1,-1,1,-1,1};\n        System.out.println(\"\\nFor input: \" + Arrays.toString(nums3));\n        System.out.println(\"Expected Output: \" + maxEqualFrequency(nums3));\n    }\n\n    public static int maxEqualFrequency(int[] nums) {\n        Map<Integer, Integer> freqMap = new HashMap<>();\n        for (int num : nums) {\n            freqMap.put(num, freqMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int ans = 0;\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\n            if (entry.getValue() == 1 || entry.getKey() == entry.getValue()) {\n                continue;\n            }\n            \n            int maxLen = 1;\n            for (int i = 1; i <= entry.getValue(); i++) {\n                if (i * entry.getKey() > i + 1 * maxLen) {\n                    maxLen = i;\n                } else {\n                    break;\n                }\n            }\n            ans = Math.max(ans, maxLen);\n        }\n        \n        return ans;\n    }\n}\n```",
  "1332": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(removePalindromeSub(\"ababa\")); // expected: \"aba\"\n        System.out.println(removePalindromeSub(\"bapabap\")); // expected: \"ba\"\n        System.out.println(removePalindromeSub(\"racecar\")); // expected: \"\"\n    }\n\n    public static String removePalindromeSub(String s) {\n        if (s.length() == 0) return \"\";\n        for (int i = 0; i < s.length() / 2; i++) {\n            if (s.charAt(i) != s.charAt(s.length() - 1 - i)) {\n                int left = i, right = s.length() - 1 - i;\n                while (left < right && s.charAt(left) == s.charAt(right)) {\n                    left++;\n                    right--;\n                }\n                return s.substring(0, i) + s.substring(i + 1);\n            }\n        }\n        return s;\n    }\n}",
  "1331": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] array1 = {40,10,20};\n        System.out.println(\"Rank Transform of array1: \" + rankTransform(array1));\n        \n        int[] array2 = {100,200,300,400};\n        System.out.println(\"Rank Transform of array2: \" + rankTransform(array2));\n        \n        int[] array3 = {5,8,3,6};\n        System.out.println(\"Rank Transform of array3: \" + rankTransform(array3));\n    }\n\n    public static int[] rankTransform(int[] arr) {\n        Arrays.sort(arr);\n        int[] result = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            result[i] = i == 0 ? 1 : (arr[i - 1] == arr[i]) ? result[i - 1] : i + 1;\n        }\n        return result;\n    }\n}\n```",
  "1334": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] distances0 = {{2,4,6},{1,14,10},{11,2,2}};\n        System.out.println(\"Expected: 2, Actual: \" + findTheCity(distances0, 3));\n\n        int[][] distances1 = {{1,2,3},{4,5,20},{1,5,15}};\n        System.out.println(\"Expected: 1, Actual: \" + findTheCity(distances1, 3));\n\n        int[][] distances2 = {{1,2,6},{1,3,10},{2,3,3}};\n        System.out.println(\"Expected: 3, Actual: \" + findTheCity(distances2, 4));\n    }\n\n    public static int findTheCity(int[][] graph, int m) {\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < graph.length; i++) {\n            boolean found = false;\n            for (int j = 0; j < graph[i].length; j++) {\n                if (graph[i][j] > m) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found && graph[i].length <= min) {\n                min = graph[i].length;\n            }\n        }\n        return min == Integer.MAX_VALUE ? -1 : min;\n    }\n}",
  "1333": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Restaurant[] restaurants = {\n                new Restaurant(\"R1\", \"Vegan\", 5.0, 2),\n                new Restaurant(\"R2\", \"Non-Vegan\", 8.0, 3),\n                new Restaurant(\"R3\", \"Vegan\", 6.0, 1),\n                new Restaurant(\"R4\", \"Non-Vegan\", 7.0, 4)\n        };\n\n        System.out.println(\"Restaurants that are Vegan-Friendly and have a price less than $8 and distance less than 2:\");\n        for (Restaurant restaurant : filterRestaurants(restaurants, true, false, 8, 2)) {\n            System.out.println(restaurant.name);\n        }\n\n        System.out.println(\"\\nRestaurants that are Vegan-Friendly or Non-Vegan and have a price less than $7 and distance less than 3:\");\n        for (Restaurant restaurant : filterRestaurants(restaurants, true, true, 7, 3)) {\n            System.out.println(restaurant.name);\n        }\n\n        System.out.println(\"\\nRestaurants that are Non-Vegan and have a price less than $9 and distance less than 4:\");\n        for (Restaurant restaurant : filterRestaurants(restaurants, false, false, 9, 4)) {\n            System.out.println(restaurant.name);\n        }\n    }\n\n    public static Restaurant[] filterRestaurants(Restaurant[] restaurants, boolean isVeganFriendly, boolean isPriceFiltered, double maxPrice, double maxLength) {\n        Arrays.sort(restaurants, (a, b) -> Double.compare(b.price + maxLength, a.price + maxLength));\n\n        if (!isVeganFriendly) {\n            int index = 0;\n            while (index < restaurants.length) {\n                Restaurant restaurant = restaurants[index];\n                if (!restaurant.isVeganFriendly || restaurant.price > maxPrice || restaurant.distance > maxLength) {\n                    Restaurant[] result = new Restaurant[restaurants.length - index - 1];\n                    System.arraycopy(restaurants, index + 1, result, 0, result.length);\n                    return result;\n                }\n                index++;\n            }\n        } else if (isVeganFriendly && isPriceFiltered) {\n            int index = 0;\n            while (index < restaurants.length) {\n                Restaurant restaurant = restaurants[index];\n                if (!restaurant.isVeganFriendly || restaurant.price > maxPrice || restaurant.distance > maxLength) {\n                    return new Restaurant[0];\n                }\n                index++;\n            }\n        }\n\n        return Arrays.copyOfRange(restaurants, 0, restaurants.length);\n    }\n}\n\nclass Restaurant implements Comparable<Restaurant> {\n    String name;\n    boolean isVeganFriendly;\n    double price;\n    int distance;\n\n    public Restaurant(String name, boolean isVeganFriendly, double price, int distance) {\n        this.name = name;\n        this.isVeganFriendly = isVeganFriendly;\n        this.price = price;\n        this.distance = distance;\n    }\n\n    @Override\n    public int compareTo(Restaurant other) {\n        return Double.compare(price + distance, other.price + other.distance);\n    }\n}",
  "1335": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] jobScheduling = {{1,2},{2,4},{3,10},{4,20},{5,9},{6,10},{7,15},{8,25},{9,1},{10,2}};\n        System.out.println(minimumJobDifficulty(jobScheduling));\n        \n        int[][] jobScheduling2 = {{1,4},{2,100},{3,1},{4,11},{5,2}};\n        System.out.println(minimumJobDifficulty(jobScheduling2));\n\n        int[][] jobScheduling3 = {{1,3},{2,5},{3,6},{8,9},{10,30},{13,15}};\n        System.out.println(minimumJobDifficulty(jobScheduling3));\n    }\n\n    public static int minimumJobDifficulty(int[][] jobScheduling) {\n        int n = jobScheduling.length;\n        int[] dp = new int[n];\n        int minDifficulty = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                dp[i] = jobScheduling[i][1];\n            } else {\n                int minDiff = Integer.MAX_VALUE;\n                for (int j = 0; j <= i; j++) {\n                    int diff = dp[j] + jobScheduling[i][1] - jobScheduling[j][1];\n                    if (diff < minDiff) {\n                        minDiff = diff;\n                    }\n                }\n                dp[i] = minDiff;\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (dp[i] < minDifficulty) {\n                minDifficulty = dp[i];\n            }\n        }\n        \n        return minDifficulty;\n    }\n}\n```",
  "1336": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = {{\"0\", \"2021:08:05 14:34:06\",\"0005\"},{\"0\", \"2021:07:31 23:59:59\",\"0004\"}};\n        System.out.println(transactionsPerVisit(logs));\n        \n        int[][] logs2 = {{\"1\", \"2021:08:02 00:10:22\",\"0005\"},{\"0\", \"2021:07:30 14:34:06\",\"0003\"}};\n        System.out.println(transdictionsPerVisit(logs2));\n        \n        int[][] logs3 = {{\"2\", \"2021:08:03 18:20:01\",\"0004\"},{\"2\", \"2021:08:04 00:10:22\",\"0006\"}};\n        System.out.println(transactionsPerVisit(logs3));\n    }\n    \n    public static int transactionsPerVisit(int[][] logs) {\n        Map<String, List<Integer>> map = new HashMap<>();\n        \n        for (int[] log : logs) {\n            String visitId = log[0];\n            int transaction = Integer.parseInt(log[2]);\n            \n            map.putIfAbsent(visitId, new ArrayList<>());\n            map.get(visitId).add(transaction);\n        }\n        \n        int totalTransactions = 0;\n        for (List<Integer> transactions : map.values()) {\n            totalTransactions += transactions.size();\n        }\n        \n        return totalTransactions;\n    }\n}\n```",
  "1338": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {3, 3, 2, 3};\n        System.out.println(\"Array Size: \" + arraySize(arr1));\n        \n        int[] arr2 = {3, 3};\n        System.out.println(\"Array Size: \" + arraySize(arr2));\n        \n        int[] arr3 = {6, 8};\n        System.out.println(\"Array Size: \" + arraySize(arr3));\n    }\n\n    public static int arrayPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int sum = 0;\n        for (int i = 0; i < nums.length; i += 2) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n\n    public static int arraySize(int[] arr) {\n        Arrays.sort(arr);\n        int size = 1;\n        while (size * 2 <= arr[arr.length - 1]) {\n            size *= 2;\n        }\n        return size / 2;\n    }\n}",
  "1337": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] mat = {{1,0,0,0},{1,1,1,0},{1,1,1,1},{1,0,0,0}};\n        int k = 3;\n        System.out.println(Arrays.toString(kWeakestRows(mat, k)));\n\n        mat = new int[][]{{0,0,4,6},{1,1,1,0},{1,0,5,0},{0,0,6,7},{3,1,4,10}};\n        k = 4;\n        System.out.println(Arrays.toString(kWeakestRows(mat, k)));\n\n        mat = new int[][]{{10,10,10},{11,11,11},{12,12,12}};\n        k = 2;\n        System.out.println(Arrays.toString(kWeakestRows(mat, k)));\n    }\n\n    public static List<Integer> kWeakestRows(int[][] mat, int k) {\n        List<int[]> rows = new ArrayList<>();\n        for (int i = 0; i < mat.length; i++) {\n            rows.add(new int[]{i, Arrays.stream(mat[i]).sum()});\n        }\n        Collections.sort(rows, (a, b) -> a[1] - b[1]);\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < k && i < rows.size(); i++) {\n            result.add(rows.get(i)[0]);\n        }\n        return result;\n    }\n}",
  "1339": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(4);\n        root1.right = new TreeNode(8);\n        root1.left.left = new TreeNode(11);\n        root1.left.left.left = new TreeNode(7);\n        root1.left.left.right = new TreeNode(2);\n        System.out.println(\"Expected: 110, Got: \" + maxProduct(root1));\n        \n        TreeNode root2 = new TreeNode(1);\n        root2.right = new TreeNode(5);\n        root2.right.left = new TreeNode(4);\n        root2.right.left.left = new TreeNode(3);\n        root2.right.left.left.right = new TreeNode(2);\n        System.out.println(\"Expected: 28, Got: \" + maxProduct(root2));\n        \n        TreeNode root3 = null;\n        System.out.println(\"Expected: 0, Got: \" + maxProduct(root3));\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n}\n```",
  "1340": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{2,3,1,1,4}};\n        System.out.println(\"Test Case 1: \" + canCross(arr1));\n        \n        int[][] arr2 = {{3,19,5,2,1,0,4}};\n        System.out.println(\"Test Case 2: \" + canCross(arr2));\n        \n        int[][] arr3 = {{2,1,1,1,0,0}};\n        System.out.println(\"Test Case 3: \" + canCross(arr3));\n    }\n\n    public static boolean canCross(int[][] grid) {\n        int n = grid.length;\n        boolean[] dp = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (grid[i][1] > i) {\n                dp[i] = true;\n            }\n        }\n        for (int i = n - 2; i >= 0; i--) {\n            if (dp[i]) {\n                int j = Math.min(i + grid[i][1], n - 1);\n                while (j >= i) {\n                    if (!dp[j] || j > i + grid[i][1]) break;\n                    j -= grid[i][1];\n                }\n                dp[i] = j < n;\n            }\n        }\n        return dp[0];\n    }\n}\n```",
  "1341": "```\npublic class Solution {\n    public int ratingEquality(String[] s1, String[] s2) {\n        if (s1.length != s2.length) return -1;\n        for (int i = 0; i < s1.length; i++) {\n            if (!s1[i].equals(s2[i])) return -1;\n        }\n        return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String[] s1 = {\"5\", \"4\"}, s2 = {\"5\", \"4\"};\n        System.out.println(solution.ratingEquality(s1, s2)); // Expected: 1\n\n        String[] s3 = {\"1\", \"2\", \"3\"}, s4 = {\"1\", \"2\"};\n        System.out.println(solution.ratingEquality(s3, s4)); // Expected: -1\n\n        String[] s5 = {\"-1\", \"0\", \"1\"}, s6 = {\"-1\", \"0\", \"1\"};\n        System.out.println(solution.ratingEquality(s5, s6)); // Expected: 1\n    }\n}\n```",
  "1342": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfSteps(14)); // Output: 6\n        System.out.println(numberOfSteps(8)); // Output: 4\n        System.out.println(numberOfSteps(12345)); // Output: 12\n    }\n\n    public static int numberOfSteps(int num) {\n        int steps = 0;\n        while (num != 0) {\n            if ((num & 1) == 1) {\n                num = num ^ 1;\n            } else {\n                num >>= 1;\n            }\n            steps++;\n        }\n        return steps;\n    }\n}\n```",
  "1344": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(angleBetweenHandsOfAClock(5,6));\n        System.out.println(angleBetweenHandsOfAClock(3,4.5));\n        System.out.println(angleBetweenHandsOfAClock(12,8.5));\n    }\n\n    public static double angleBetweenHandsOfAClock(double hour, double minutes) {\n        int h = (int)hour;\n        int m = (int)minutes;\n        m = m % 60;\n        h = h % 12;\n\n        int totalMinutes = h * 60 + m;\n        int minuteAngle = (totalMinutes * 6);\n\n        int hourAngle = (h * 30) + ((m * 0.5));\n\n        return Math.abs(Math.min(hourAngle, minuteAngle) - Math.max(hourAngle, minuteAngle));\n    }\n}",
  "1343": "```\npublic class Main {\n    public static void main(String[] args) {\n        int numSubarrays = numSubarraysWithAverageGreaterThanOrEqualToThreshold(new int[]{2, 1, 5}, 0, 3);\n        System.out.println(\"Number of sub-arrays: \" + numSubarrays);\n\n        numSubarrays = numSubarraysWithAverageGreaterThanOrEqualToThreshold(new int[]{-1,-4,5,-10,7}, 8, 3);\n        System.out.println(\"Number of sub-arrays: \" + numSubarrays);\n\n        numSubarrays = numSubarraysWithAverageGreaterThanOrEqualToThreshold(new int[]{0,0,0,0}, 2, 3);\n        System.out.println(\"Number of sub-arrays: \" + numSubarrays);\n    }\n\n    public static int numSubarraysWithAverageGreaterThanOrEqualToThreshold(int[] nums, int threshold, int k) {\n        int count = 0;\n        int sum = 0;\n        for (int i = 0; i < k; i++) {\n            sum += nums[i];\n        }\n        if (sum / k >= threshold) {\n            count++;\n        }\n\n        for (int i = k; i < nums.length; i++) {\n            sum = sum - nums[i - k] + nums[i];\n            if (sum / k >= threshold) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
  "1345": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canReach(new int[]{2,3,1,1,4}));\n        System.out.println(canReach(new int[]{0,2,5}));\n        System.out.println(!canReach(new int[]{3,2,1,0,10,6,1,9}));\n    }\n\n    public static boolean canReach(int[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] >= i + arr[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "1346": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {1, 3, 4, 2, 7},\n            {1, 2, 9, 56, 33},\n            {2, 11, 6}\n        };\n        \n        for (int i = 0; i < arrays.length; i++) {\n            boolean result = checkIfNandItsDoubleExist(arrays[i]);\n            System.out.println(\"Array \" + i + \": \" + result);\n        }\n    }\n\n    public static boolean checkIfNandItsDoubleExist(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int num : nums) {\n            if (!map.containsKey(num)) {\n                map.put(num, 1);\n            } else {\n                map.put(num, map.get(num) + 1);\n            }\n            \n            int doubleVal = num * 2;\n            if (map.containsKey(doubleVal)) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n}",
  "1347": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSteps(\"abc\", \"def\")); // expected: 3\n        System.out.println(minSteps(\"dact\", \"done\")); // expected: 3\n        System.out.println(minSteps(\"a\", \"b\")); // expected: 2\n    }\n\n    public static int minSteps(String s1, String s2) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (char c : s1.toCharArray()) {\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        for (char c : s2.toCharArray()) {\n            map.put(c, map.getOrDefault(c, 0) - 1);\n        }\n        int res = 0;\n        for (int count : map.values()) {\n            res += Math.abs(count);\n        }\n        return res / 2;\n    }\n}",
  "1348": "```\npublic class Main {\n    public static void main(String[] args) {\n        FrequencyTracker tracker = new FrequencyTracker();\n        \n        // Test case 1\n        int[][] tweets = {{1, 2}, {2, 3}, {3, 4}, {4, 5}, {5, 6}};\n        int[] expect1 = {0, 1, 1, 2, 3};\n        tracker.feed(tweets);\n        for (int i = 0; i < 6; i++) {\n            System.out.println(\"Frequency of tweet \" + i + \": \" + tracker.getTweetCounts(i));\n        }\n        \n        // Test case 2\n        int[][] tweets2 = {{10, 20}, {30, 40}};\n        int[] expect2 = {0, 1};\n        tracker.feed(tweets2);\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"Frequency of tweet \" + i + \": \" + tracker.getTweetCounts(i));\n        }\n        \n        // Test case 3\n        int[][] tweets3 = {{5, 10}, {10, 15}};\n        int[] expect3 = {0, 1};\n        tracker.feed(tweets3);\n        for (int i = 0; i < 6; i++) {\n            System.out.println(\"Frequency of tweet \" + i + \": \" + tracker.getTweetCounts(i));\n        }\n    }\n}\n\nclass FrequencyTracker {\n    private final TreeMap<Integer, Integer> frequencyMap;\n    \n    public FrequencyTracker() {\n        this.frequencyMap = new TreeMap<>();\n    }\n    \n    public void feed(int[][] tweets) {\n        for (int[] tweet : tweets) {\n            int time = tweet[0];\n            int frequency = tweet[1];\n            if (!frequencyMap.containsKey(time)) {\n                frequencyMap.put(time, 0);\n            }\n            frequencyMap.replace(time, frequencyMap.get(time), frequencyMap.get(time) + 1);\n        }\n    }\n    \n    public int getTweetCounts(int frequency) {\n        int count = 0;\n        for (int time : new ArrayList<>(frequencyMap.keySet())) {\n            if (frequencyMap.get(time) >= frequency) {\n                count += 1;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n}\n```",
  "1349": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr = {{0,1},{2,4}};\n        System.out.println(\"Number of students taking exam: \" + maxStudents(arr));\n        \n        arr = new int[][]{{3,1},{4,2},{2,5},{5,2},{5,3},{2,4},{1,4},{4,3}});\n        System.out.println(\"Number of students taking exam: \" + maxStudents(arr));\n\n        arr = new int[][]{{0, 1}, {1, 2}, {2, 3}};\n        System.out.println(\"Number of students taking exam: \" + maxStudents(arr));\n    }\n\n    public static int maxStudents(int[][] seats) {\n        int n = seats.length;\n        int res = 0;\n        for (int mask = 0; mask < (1 << n); mask++) {\n            boolean valid = true;\n            int student = 0, empty = 0;\n            for (int i = 0; i < n; i++) {\n                if (((mask >> i) & 1) == 0 && seats[i][1] > 0) {\n                    valid = false;\n                    break;\n                }\n                if (((mask >> i) & 1) == 1) student++;\n                else empty++;\n            }\n            if (valid && student <= n / 2) res = Math.max(res, student);\n        }\n        return res;\n    }\n}",
  "1350": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grades = {{10, \"A\"}, {20, \"B\"}, {30, \"C\"}};\n        System.out.println(\"Students with invalid departments: \");\n        for (int i = 0; i < grades.length; i++) {\n            if (!isValidDepartment(grades[i][1])) {\n                System.out.println(i + \": \" + grades[i][0]);\n            }\n        }\n    }\n\n    public static boolean isValidDepartment(String department) {\n        return !department.equals(\"A\") && !department.equals(\"B\");\n    }\n}\n```",
  "1351": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{4, 3, 2, -1}, {3, 2, 1, -1}, {1, 1, -1, -2}, {-1, -1, -2, -3}};\n        System.out.println(\"Test case 1: \" + countNegatives(matrix1) + \" expected: 8\");\n\n        int[][] matrix2 = {{-5};\n                          {5}};\n        System.out.println(\"Test case 2: \" + countNegatives(matrix2) + \" expected: 2\");\n\n        int[][] matrix3 = {{1, -1}, {-1, 1}};\n        System.out.println(\"Test case 3: \" + countNegatives(matrix3) + \" expected: 0\");\n    }\n\n    public static int countNegatives(int[][] grid) {\n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] < 0) {\n                    count += 1;\n                }\n            }\n        }\n        return count;\n    }\n}",
  "1352": "```\npublic class Main {\n    public static void main(String[] args) {\n        NumArray numArray = new NumArray([7,9]);\n        System.out.println(numArray.product(4)); // Output: 28\n        System.out.println(numArray.product(2)); // Output: 36\n        System.out.println(numArray.product(5)); // Output: 0\n    }\n}\n\nclass NumArray {\n    int[] prefixSum;\n    \n    public NumArray(int[] nums) {\n        prefixSum = new int[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n    }\n\n    public int product(int k) {\n        if (k > prefixSum.length) {\n            return 0;\n        }\n        int lastKSum = prefixSum[k] - (prefixSum[k-1]);\n        for (int i = k+1; i < prefixSum.length; i++) {\n            lastKSum *= prefixSum[i] - (prefixSum[i-1]);\n        }\n        return lastKSum;\n    }\n}\n```",
  "1353": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] events = {{1,4},{2,5},{3,6},{7,8}};\n        System.out.println(maxEvents(events)); // Expected output: 3\n\n        events = new int[][]{{1,3},{2,3}};\n        System.out.println(maxEvents(events)); // Expected output: 0\n\n        events = {{1,4},{1,5},{3,6},{8,9},{10,11}};\n        System.out.println(maxEvents(events)); // Expected output: 4\n    }\n\n    public static int maxEvents(int[][] events) {\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\n        int res = 0, lastEnd = -1;\n        for (int[] event : events) {\n            if (event[0] > lastEnd) {\n                res++;\n                lastEnd = event[1];\n            }\n        }\n        return res;\n    }\n}",
  "1354": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(canConstruct(new int[]{10,2,7,5}, 15)));\n        System.out.println(Arrays.toString(canConstruct(new int[]{5,7,1,9}, 27)));\n        System.out.println(Arrays.toString(canConstruct(new int[]{1,1,1,2}, 8)));\n    }\n\n    public static boolean[] canConstruct(int[] reqSumCost, int target) {\n        Arrays.sort(reqSumCost);\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> a - b);\n\n        for (int i : reqSumCost) {\n            if (queue.size() < i + 1) {\n                queue.add(target / i);\n            }\n            while (!queue.isEmpty() && queue.peek() > target / i) {\n                queue.poll();\n            }\n            if (queue.size() >= i + 1) {\n                for (int j = 0; j < i; j++) {\n                    queue.add(queue.poll());\n                }\n            }\n        }\n\n        boolean[] result = new boolean[reqSumCost.length];\n        while (!queue.isEmpty()) {\n            for (int i = 0; i < reqSumCost.length; i++) {\n                if (reqSumCost[i] <= queue.peek() && !result[i]) {\n                    result[i] = true;\n                    queue.poll();\n                }\n            }\n        }\n\n        return result;\n    }\n}",
  "1355": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] participant = { {1, 2}, {3, 4} };\n        int[][] endpoint = { {1, 4}, {3, 2} };\n        \n        System.out.println(Arrays.toString(findParticipants(participant, endpoint)));\n        \n        participant = new int[][]{ {1, 3} };\n        endpoint = new int[][]{ {5, 6} };\n        System.out.println(Arrays.toString(findParticipants(participant, endpoint)));\n        \n        participant = new int[][]{ {2, 1}, {4, 3}, {3, 4} };\n        endpoint = new int[][]{ {1, 4} };\n        System.out.println(Arrays.toString(findParticipants(participant, endpoint)));\n    }\n\n    public static String[] findParticipants(int[][] participant, int[][] endpoint) {\n        Map<Integer, Integer> personTimeMap = new HashMap<>();\n        for (int i = 0; i < participant.length; i++) {\n            int time = endpoint[i][1];\n            if (!personTimeMap.containsKey(time)) {\n                personTimeMap.put(time, participant[i][1]);\n            } else if (personTimeMap.get(time) != participant[i][1]) {\n                return new String[]{String.valueOf(participant[i][0]), String.valueOf(participant[i][1])};\n            }\n        }\n        \n        List<Integer> allParticipant = new ArrayList<>();\n        for (int i = 0; i < participant.length; i++) {\n            if (!allParticipant.contains(participant[i][0])) {\n                allParticipant.add(participant[i][0]);\n            }\n        }\n        \n        int[] finalResult = new int[allParticipant.size()];\n        for (int i = 0; i < allParticipant.size(); i++) {\n            for (Map.Entry<Integer, Integer> entry : personTimeMap.entrySet()) {\n                if (entry.getKey() == allParticipant.get(i)) {\n                    finalResult[i] = entry.getValue();\n                }\n            }\n        }\n        \n        return Arrays.stream(finalResult).mapToObj(String::valueOf).toArray(String[]::new);\n    }\n}",
  "1356": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input = {{0, 1}, {1, 1}, {3, 2}};\n        for (int i = 0; i < input.length; i++) {\n            int[] result = sortByOneBits(input[i]);\n            System.out.println(\"Input: \" + Arrays.toString(input[i]) + \", Output: \" + Arrays.toString(result));\n        }\n    }\n\n    public static int[] sortByOneBits(int[] nums) {\n        Arrays.sort(nums, (a, b) -> Integer.bitCount(a) - Integer.bitCount(b));\n        return nums;\n    }\n}\n```",
  "1358": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfSubstrings(\"abc\"));\n        System.out.println(numberOfSubstrings(\"aaac\"));\n        System.out.println(numberOfSubstrings(\"aabbaacc\"));\n    }\n\n    public static int numberOfSubstrings(String s) {\n        int count = 0;\n        Map<Character, Integer> charCountMap = new HashMap<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (charCountMap.size() == 3) {\n                charCountMap.put(s.charAt(i), i);\n                count++;\n            } else {\n                charCountMap.put(s.charAt(i), i);\n            }\n        }\n        return count;\n    }\n}",
  "1357": "```\npublic class Main {\n    public static void main(String[] args) {\n        DiscountOrders orders = new DiscountOrders();\n        System.out.println(orders.numOfOrders(new int[]{1,2,3,4,5}, 3)); // Expected: 8\n        System.out.println(orders.numOfOrders(new int[]{10,2,5,10,4,7,9}, 4)); // Expected: 11\n        System.out.println(orders.numOfOrders(new int[]{1,2,3,4,4,6,8,12,8}, 4)); // Expected: 9\n    }\n}\nclass DiscountOrders {\n    public int numOfOrders(int[] customers, int n) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < customers.length; i++) {\n            if (!map.containsKey(customers[i])) {\n                map.put(customers[i], 1);\n            } else {\n                map.put(customers[i], map.get(customers[i]) + 1);\n            }\n        }\n        int count = 0;\n        for (int order : map.values()) {\n            if ((count / n) * n == count && order > 0) {\n                return (int) Math.ceil((double) (order - 1) / (n - 1));\n            }\n            count += order;\n        }\n        return (int) Math.ceil((double) count / n);\n    }\n}\n```",
  "1359": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countOrders(5)); // Test case 1: n = 5\n        System.out.println(countOrders(2)); // Test case 2: n = 2\n        System.out.println(countOrders(3)); // Test case 3: n = 3\n    }\n\n    public static int countOrders(int n) {\n        long MOD = (long) Math.pow(10, 9) + 7;\n        long ans = 1;\n        for (int i = 0; i < n; i++) {\n            ans = (ans * (2 * i + 3)) % MOD;\n        }\n        return (int) ans;\n    }\n}",
  "1360": "```\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + countDaysBetweenDates(\"2022-01-01\", \"2022-01-31\"));\n        System.out.println(\"Test Case 2: \" + countDaysBetweenDates(\"1990-07-04\", \"2005-09-03\"));\n        System.out.println(\"Test Case 3: \" + countDaysBetweenDates(\"1984-02-22\", \"1986-10-12\"));\n    }\n\n    public static int countDaysBetweenDates(String start, String end) {\n        LocalDate startDate = LocalDate.parse(start);\n        LocalDate endDate = LocalDate.parse(end);\n        long days = ChronoUnit.DAYS.between(startDate, endDate);\n        return (int) days;\n    }\n}",
  "1362": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(closestDivisors(123));\n        System.out.println(closestDivisors(999));\n        System.out.println(closestDivisors(1000));\n    }\n\n    public static int closestDivisors(int n) {\n        // Your code here\n    }\n}\n```",
  "1361": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(validateBinaryTreeNodes(1));\n        System.out.println(validateBinaryTreeNodes(2, new TreeNode(1)));\n        System.out.println(!validateBinaryTreeNodes(4, new TreeNode(1), new TreeNode(2), new TreeNode(3), new TreeNode(4)));\n    }\n\n    public static boolean validateBinaryTreeNodes(int n, TreeNode[] nodes) {\n        if (n != nodes.length) return false;\n        \n        for (int i = 0; i < n; i++) {\n            if (nodes[i] == null) continue;\n            if ((i > 0 && nodes[i].left != null) || (i < n - 1 && nodes[i].right != null)) return false;\n            if (i > 0 && nodes[i-1].val > nodes[i].val) return false;\n            if (i < n - 1 && nodes[i].val > nodes[i+1].val) return false;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (nodes[i] != null) {\n                if (nodes[i].left == null) continue;\n                if (i > 0 && nodes[i-1].right == null) return false;\n                if (i < n - 1 && nodes[i+1].left != null) return false;\n            }\n        }\n        \n        return true;\n    }\n\n    public static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode() {}\n        TreeNode(int val) { this.val = val; }\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }\n}",
  "1363": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {12,10,8,7,6};\n        System.out.println(distributeCoins(arr1));\n        \n        int[] arr2 = {5,4,0};\n        System.out.println(distributeCoins(arr2));\n\n        int[] arr3 = {9,3,15};\n        System.out.println(distributeCoins(arr3));\n    }\n\n    public static int distributeCoins(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            while (nums[i] % 3 != 0) {\n                nums[i]--;\n                n++;\n                if (n == nums.length + 1) {\n                    return n - 1;\n                }\n            }\n        }\n        return n;\n    }\n}\n```",
  "1364": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] trusted = {{0, 1}, {1, 2}};\n        System.out.println(trustedContacts(0, trusted));\n        \n        int[][] trusted1 = {{0, 1}, {1, 2}, {2, 3}, {5, 4}};\n        System.out.println(trustedContacts(2, trusted1));\n\n        int[][] trusted2 = {};\n        System.out.println(trustedContacts(0, trusted2));\n    }\n\n    public static int trustedContacts(int customerID, int[][] contacts) {\n        if (contacts == null || contacts.length == 0) {\n            return 0;\n        }\n        \n        Set<Integer> set = new HashSet<>();\n        for (int[] contact : contacts) {\n            if (contact[1] == customerID) {\n                set.add(contact[0]);\n            } else if (contact[0] == customerID) {\n                set.addAll(Arrays.stream(contact).skip(1).boxed().collect(Collectors.toList()));\n            }\n        }\n        \n        return set.size();\n    }\n}\n```",
  "1365": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2,1,10,3};\n        System.out.println(numberOfSmallerNumbersThanCurrent(nums1)); // expected output: 3\n\n        int[] nums2 = {5,4,4];\n        System.out.println(numberOfSmallerNumbersThanCurrent(nums2)); // expected output: 0\n\n        int[] nums3 = {6,5,4,3];\n        System.out.println(numberOfSmallerNumbersThanCurrent(nums3)); // expected output: 8\n    }\n\n    public static int numberOfSmallerNumbersThanCurrent(int[] nums) {\n        Arrays.sort(nums);\n        int count = 0;\n        for (int i = 1; i < nums.length; i++) {\n            count += binarySearch(nums, nums[i - 1], nums[i]);\n        }\n        return count;\n    }\n\n    public static int binarySearch(int[] arr, int target, int end) {\n        int low = 0, high = end;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (arr[mid] > target) {\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n}",
  "1366": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] votes = {{\"LC\", \"CW\", \"LU\", \"WC\"}, {\"CW\", \"WF\", \"EB\", \"FC\"}, {\"LF\", \"LI\", \"LC\", \"WC\"}};\n        String[] winnerVotes = winningTeams(votes);\n        \n        for (int i = 0; i < winnerVotes.length; i++) {\n            System.out.println(\"Team \" + i + \"'s winner is: \" + winnerVotes[i]);\n        }\n    }\n\n    public static String[] winningTeams(int[][] votes) {\n        int n = votes[0].length;\n        Map<String, Integer> teamVotes = new HashMap<>();\n        \n        for (int[] vote : votes) {\n            for (String team : vote) {\n                teamVotes.put(team, teamVotes.getOrDefault(team, 0) + 1);\n            }\n        }\n        \n        String[] winners = new String[n];\n        for (int i = 0; i < n; i++) {\n            if (teamVotes.get(\"LC\") > teamVotes.get(\"CW\")) {\n                winners[i] = \"LC\";\n            } else if (teamVotes.get(\"CW\") > teamVotes.get(\"LU\")) {\n                winners[i] = \"CW\";\n            } else {\n                winners[i] = \"LU\";\n            }\n        }\n        \n        return winners;\n    }\n}\n```",
  "1367": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test case 1\n        ListNode root = new ListNode(1);\n        root.left = new ListNode(4);\n        root.right = new ListNode(5);\n        root.right.left = new ListNode(2);\n        root.right.right = new ListNode(3);\n        IsSubtree tree = new IsSubtree(root, new ListNode(1));\n        System.out.println(tree.isSubtree()); // Expected output: true\n\n        // Test case 2\n        root = new ListNode(1);\n        root.left = new ListNode(4);\n        root.right = new ListNode(5);\n        tree = new IsSubtree(root, new ListNode(3));\n        System.out.println(tree.isSubtree()); // Expected output: false\n\n        // Test case 3\n        root = null;\n        tree = new IsSubtree(null, new ListNode(1));\n        System.out.println(tree.isSubtree()); // Expected output: false\n    }\n}\n\nclass IsSubtree {\n    public boolean isSubtree(ListNode root, TreeNode subRoot) {\n        if (root == null) return false;\n        if (isIdentical(root, subRoot)) return true;\n        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n    }\n\n    private boolean isIdentical(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n        return p.val == q.val && isIdentical(p.left, q.left) && isIdentical(p.right, q.right);\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode left;\n    ListNode right;\n\n    public ListNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n```",
  "1368": "```\nimport java.util.*;\n\nclass Solution {\n    public int minCost(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] directions = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        boolean[][] visited = new boolean[m][n];\n        int res = Integer.MAX_VALUE;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    pq.offer(new int[]{i, j, 0});\n                    visited[i][j] = true;\n                }\n            }\n        }\n\n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int x = curr[0];\n            int y = curr[1];\n            int cost = curr[2];\n\n            if (x == m - 1 && y == n - 1) return cost;\n\n            for (int[] dir : directions) {\n                int nx = x + dir[0], ny = y + dir[1];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] == 1) {\n                    pq.offer(new int[]{nx, ny, cost + (dir[0] == -1 || dir[1] == -1 ? 1 : 0)});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        int[][] grid1 = {{0, 0, 1}, {0, 1, 0}};\n        System.out.println(\"Minimum cost for test case 1: \" + solution.minCost(grid1));\n\n        // Test case 2\n        int[][] grid2 = {{0, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n        System.out.println(\"Minimum cost for test case 2: \" + solution.minCost(grid2));\n\n        // Test case 3\n        int[][] grid3 = {{0, 0, 0, 0}, {0, 1, 1, 1}, {0, 1, 1, 1}, {0, 1, 1, 1}};\n        System.out.println(\"Minimum cost for test case 3: \" + solution.minCost(grid3));\n    }\n}",
  "1369": "```\npublic class Solution {\n    public String secondHighest(String logs) {\n        String[] logArray = logs.split(\";\");\n        int max = -1;\n        int secondMax = -2;\n\n        for (String log : logArray) {\n            if (!log.isEmpty()) {\n                int id = Integer.parseInt(log.substring(0, log.indexOf(\":\")));\n                if (id > max) {\n                    secondMax = max;\n                    max = id;\n                } else if (id != max && id > secondMax) {\n                    secondMax = id;\n                }\n            }\n        }\n\n        return secondMax == -2 ? \"Unknown\" : String.valueOf(secondMax);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.secondHighest(\"2020:03:05 15:40:50:User1:Search\"));\n        System.out.println(solution.secondHighest(\"2020:01:01 00:00:00 User2:Login\"));\n        System.out.println(solution.secondHighest(\"2019:12:31 23:59:59 User3:Logout 2020:01:01 00:00:00 User4:Login\"));\n    }\n}",
  "1370": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(increasingDecreasing(\"aaa\")); // Expected: 0\n        System.out.println(increasingDecreasing(\"aaabaab\")); // Expected: 4\n        System.out.println(increasingDecreasing(\"abcba\")); // Expected: 3\n    }\n\n    public static int increasingDecreasing(String s) {\n        int count = 0;\n        for (int i = 1; i < s.length(); i++) {\n            if ((s.charAt(i - 1) < s.charAt(i)) && (s.charAt(i) > s.charAt(i + 1))) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "1371": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestOnes(\"eleetcalloolelo\")); // expected: \"leet\"\n        System.out.println(longestOnes(\"lolleip\")); // expected: \"lol\"\n        System.out.println(longestOnes(\"aaeoouu\")); // expected: \"aaeoouu\"\n    }\n\n    public static String longestOnes(String s) {\n        int n = s.length();\n        int maxLen = 0, start = 0;\n        for (int end = 0; end < n; end++) {\n            if ((s.charAt(end) - 'a' & 1) == 0) {\n                start = end + 1;\n            }\n            maxLen = Math.max(maxLen, end - start + 1);\n        }\n        return s.substring(start, start + maxLen);\n    }\n}",
  "1372": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(4);\n        root1.right = new TreeNode(4);\n        root1.left.left = new TreeNode(2);\n        root1.left.right = new TreeNode(6);\n        root1.right.left = new TreeNode(5);\n        System.out.println(\"Longest ZigZag Path in a Binary Tree: \" + longestZigZag(root1));\n        \n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(4);\n        root2.left.left = new TreeNode(6);\n        System.out.println(\"Longest ZigZag Path in a Binary Tree: \" + longestZigZag(root2));\n        \n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n        root3.right = new TreeNode(3);\n        System.out.println(\"Longest ZigZag Path in a Binary Tree: \" + longestZigZag(root3));\n    }\n\n    public static int longestZigZag(TreeNode root) {\n        if (root == null) return 0;\n        int[] res = new int[1];\n        zigzag(root, true, 0, res);\n        int[] res2 = new int[1];\n        zigzag(root, false, 0, res2);\n        return Math.max(res[0], res2[0]);\n    }\n\n    public static void zigzag(TreeNode node, boolean isLeft, int length, int[] res) {\n        if (node == null) return;\n        length++;\n        if (!isLeft && node.left == null && node.right == null) {\n            res[0] = Math.max(res[0], length);\n            return;\n        }\n        zigzag(node.left, true, length, res);\n        zigzag(node.right, false, length, res);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int x) { val = x; }\n}\n```",
  "1374": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(largestOddNumberAtMostK(\"aaabbccc\", 1)); // should print \"abc\"\n        System.out.println(largestOddNumberAtMostK(\"aaaabbbccdd\", 3)); // should print \"abcd\"\n        System.out.println(largestOddNumberAtMostK(\"\", 4)); // should print \"\"\n    }\n\n    public static String largestOddNumberAtMostK(String s, int k) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            while (i + 1 < s.length() && s.charAt(i + 1) == c) {\n                i++;\n            }\n            if ((s.length() - i) % 2 != 0) {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}",
  "1373": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode tree1 = new TreeNode(4);\n        tree1.left = new TreeNode(2);\n        tree1.right = new TreeNode(7);\n        tree1.left.left = new TreeNode(1);\n        tree1.left.right = new TreeNode(3);\n        System.out.println(\"Test case 1: \" + maxSumBST(tree1)); // Output: 11\n\n        TreeNode tree2 = new TreeNode(5);\n        tree2.left = new TreeNode(4);\n        tree2.left.left = new TreeNode(2);\n        tree2.left.right = new TreeNode(3);\n        System.out.println(\"Test case 2: \" + maxSumBST(tree2)); // Output: 11\n\n        TreeNode tree3 = new TreeNode(1);\n        tree3.left = new TreeNode(-5);\n        tree3.left.left = new TreeNode(-3);\n        System.out.println(\"Test case 3: \" + maxSumBST(tree3)); // Output: 2\n    }\n\n    public static int maxSumBST(TreeNode root) {\n        if (root == null) return 0;\n        int[] res = new int[1];\n        dfs(root, Long.MAX_VALUE, Long.MIN_VALUE, res);\n        return res[0];\n    }\n\n    private static void dfs(TreeNode node, long minVal, long maxVal, int[] res) {\n        if (node == null) return;\n        if (node.val < minVal || node.val > maxVal) return;\n        long leftSum = 0;\n        long rightSum = 0;\n        if (node.left != null) {\n            dfs(node.left, minVal, Math.max(minVal, node.val), res);\n            leftSum = res[0];\n        }\n        if (node.right != null) {\n            dfs(node.right, Math.min(maxVal, node.val), maxVal, res);\n            rightSum = res[0];\n        }\n        res[0] = node.val + leftSum + rightSum;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1375": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countPrefixAlign(\"01\"));\n        System.out.println(countPrefixAlign(\"10\"));\n        System.out.println(countPrefixAlign(\"101010\"));\n    }\n\n    public static int countPrefixAlign(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (i > 0 && s.charAt(i) != s.charAt(0)) {\n                break;\n            }\n            count++;\n        }\n        return count;\n    }\n}\n```",
  "1376": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(5);\n\n        System.out.println(\"Test case 1: \" + notify(0, root1) + \" expected 2\");\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n\n        System.out.println(\"Test case 2: \" + notify(0, root2) + \" expected 1\");\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n        root3.right = new TreeNode(3);\n        root3.left.left = new TreeNode(4);\n\n        System.out.println(\"Test case 3: \" + notify(0, root3) + \" expected 3\");\n    }\n\n    public static int notify(int delay, TreeNode root) {\n        if (root == null) return 0;\n\n        int leftTime = notify(delay, root.left);\n        int rightTime = notify(leftTime + delay, root.right);\n\n        return Math.max(leftTime, rightTime) + delay;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}",
  "1377": "```\nimport java.util.*;\n\nclass Solution {\n    public int minTime(int n, int firstJumpFromSmallToBig, int secondJumpFromSmallToBig) {\n        List<Integer> jumps = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                jumps.add(firstJumpFromSmallToBig);\n            } else if (i == 1) {\n                jumps.add(Math.min(i + firstJumpFromSmallToBig, secondJumpFromSmallToBig));\n            } else {\n                int jump = Math.min(i + firstJumpFromSmallToBig, i - 1 + secondJumpFromSmallToBig);\n                while (jump > n && i < jump) {\n                    jump = Math.min(jump - 1, i - 1 + secondJumpFromSmallToBig);\n                }\n                jumps.add(jump);\n            }\n        }\n        return jumps.get(n - 1);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int n1 = 5;\n        int firstJumpFromSmallToBig1 = 3;\n        int secondJumpFromSmallToBig1 = 12;\n        System.out.println(\"Frog position after \" + solution.minTime(n1, firstJumpFromSmallToBig1, secondJumpFromSmallToBig1) + \" seconds: \");\n        \n        // Test case 2\n        int n2 = 10;\n        int firstJumpFromSmallToBig2 = 6;\n        int secondJumpFromSmallToBig2 = 14;\n        System.out.println(\"Frog position after \" + solution.minTime(n2, firstJumpFromSmallToBig2, secondJumpFromSmallToBig2) + \" seconds: \");\n        \n        // Test case 3\n        int n3 = 12;\n        int firstJumpFromSmallToBig3 = 5;\n        int secondJumpFromSmallToBig3 = 15;\n        System.out.println(\"Frog position after \" + solution.minTime(n3, firstJumpFromSmallToBig3, secondJumpFromSmallToBig3) + \" seconds: \");\n    }\n}\n```",
  "1378": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(replaceId(new String[][]{\n                {\"id\", \"name\", \"age\"},\n                {\"1\", \"John\", \"25\"},\n                {\"2\", \"Jane\", \"30\"}\n            }, new int[]{1, 0}));\n\n        System.out.println(replaceId(new String[][]{\n                {\"employee_id\", \"department\", \"manager_id\"},\n                {\"12345\", \"Sales\", \"67890\"},\n                {\"67890\", \"Marketing\", null}\n            }, new int[]{0, 2}));\n\n        System.out.println(replaceId(new String[][]{\n                {\"id\", \"name\", \"age\", \"city\"},\n                {\"1\", \"John\", \"25\", \"New York\"},\n                {\"2\", \"Jane\", \"30\", \"Chicago\"}\n            }, new int[]{3, -1}));\n    }\n\n    public static String[][] replaceId(String[][] table, int[] columns) {\n        List<String[]> result = new ArrayList<>();\n        for (String[] row : table) {\n            String[] newRow = new String[row.length];\n            for (int i = 0; i < row.length; i++) {\n                if (columns[i] == -1) {\n                    newRow[i] = \"unique_id\";\n                } else {\n                    newRow[i] = String.valueOf(columns[i]);\n                }\n            }\n            result.add(newRow);\n        }\n        return result.toArray(new String[0][]);\n    }\n}",
  "1379": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n        root.left.left = new TreeNode(4);\n        root.left.right = new TreeNode(5);\n\n        TreeNode clonedRoot = new TreeNode(1);\n        clonedRoot.left = new TreeNode(2);\n        clonedRoot.right = new TreeNode(3);\n        clonedRoot.left.left = new TreeNode(4);\n        clonedRoot.left.right = new TreeNode(5);\n\n        System.out.println(\"Test Case 1: \" + findNode(root, clonedRoot, root.left)); // true\n        System.out.println(\"Test Case 2: \" + findNode(root, clonedRoot, new TreeNode(6))); // false\n        System.out.println(\"Test Case 3: \" + findNode(root, clonedRoot, root.right)); // true\n    }\n\n    public static boolean findNode(TreeNode original, TreeNode cloned, TreeNode target) {\n        if (target == null) return true;\n\n        if (original.val != target.val) return false;\n\n        return findNode(original.left, cloned.left, target.left) &&\n               findNode(original.right, cloned.right, target.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1380": "```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List<Integer> luckyNumbers(int[][] matrix) {\n        // Your solution here\n        return null; \n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] matrix1 = {{2, 4}, {6, 3}};\n        System.out.println(\"Lucky Numbers for \" + matrix1 + \": \" + solution.luckyNumbers(matrix1));\n        \n        int[][] matrix2 = {{1, 10, 5, 7, 9}, {9, 8, 7, 6, 5}, {5, 3, 3, 4, 3}};\n        System.out.println(\"Lucky Numbers for \" + matrix2 + \": \" + solution.luckyNumbers(matrix2));\n        \n        int[][] matrix3 = {{10}};\n        System.out.println(\"Lucky Numbers for \" + matrix3 + \": \" + solution.luckyNumbers(matrix3));\n    }\n}",
  "1381": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        CustomStack customStack = new CustomStack(3);\n        System.out.println(customStack.push(1));\n        System.out.println(customStack.push(2));\n        System.out.println(customStack.pop());\n        System.out.println(customStack.increment(5, 0));\n        System.out.println(customStack.peek());\n    }\n}\n\nclass CustomStack {\n\n    private int maxSize;\n    private int[] stack;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.stack = new int[maxSize];\n    }\n\n    public int push(int x) {\n        if (size() < maxSize) {\n            stack[size()] = x;\n            return size();\n        }\n        return -1;\n    }\n\n    public int pop() {\n        if (size() > 0) {\n            int val = stack[size() - 1];\n            stack[--size()] = -1; // mark as empty\n            return val;\n        }\n        return -1;\n    }\n\n    public int increment(int k, int val) {\n        for (int i = 0; i < size(); i++) {\n            if (i < k) {\n                stack[i] += val;\n            } else {\n                break;\n            }\n        }\n        return size();\n    }\n\n    public int top() {\n        if (size() > 0) {\n            return stack[size() - 1];\n        }\n        return -1;\n    }\n\n    public int size() {\n        int count = 0;\n        for (int i : stack) {\n            if (i != -1) {\n                count++;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n\n    public int get(int index) {\n        if (index < size()) {\n            return stack[index];\n        }\n        return -1;\n    }\n}",
  "1382": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(4);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(5);\n        root1.left.left = new TreeNode(3);\n        root1.left.right = new TreeNode(1);\n\n        balanceBST(root1);\n\n        System.out.println(\"Test 1: \");\n        printTree(root1);\n\n        // Test 2\n        TreeNode root2 = new TreeNode(20);\n        root2.left = new TreeNode(8);\n        root2.right = new TreeNode(22);\n        root2.left.left = new TreeNode(4);\n        root2.left.right = new TreeNode(12);\n\n        balanceBST(root2);\n\n        System.out.println(\"Test 2: \");\n        printTree(root2);\n\n        // Test 3\n        TreeNode root3 = new TreeNode(10);\n        balanceBST(root3);\n\n        System.out.println(\"Test 3: \");\n        printTree(root3);\n    }\n\n    public static void balanceBST(TreeNode root) {\n        if (root == null) return;\n\n        List<Integer> list = new ArrayList<>();\n        inorder(root, list);\n\n        int[] nums = new int[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            nums[i] = list.get(i);\n        }\n\n        Arrays.sort(nums);\n\n        root = null;\n        for (int num : nums) {\n            TreeNode newNode = new TreeNode(num);\n            addNode(root, newNode);\n        }\n    }\n\n    public static void inorder(TreeNode root, List<Integer> list) {\n        if (root == null) return;\n\n        inorder(root.left, list);\n        list.add(root.val);\n        inorder(root.right, list);\n    }\n\n    public static void addNode(TreeNode root, TreeNode node) {\n        if (node.val < root.val) {\n            if (root.left == null) {\n                root.left = node;\n            } else {\n                addNode(root.left, node);\n            }\n        } else {\n            if (root.right == null) {\n                root.right = node;\n            } else {\n                addNode(root.right, node);\n            }\n        }\n    }\n\n    public static void printTree(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode current = queue.poll();\n                System.out.print(current.val + \" \");\n\n                if (current.left != null) queue.offer(current.left);\n                if (current.right != null) queue.offer(current.right);\n            }\n            System.out.println();\n        }\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode(int x) { val = x; }\n}\n```",
  "1384": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[][] customerOrders = {\n            {2020, 5},\n            {2021, 2},\n            {2021, 4},\n            {2020, 3}\n        };\n        int year = 2020;\n        System.out.println(\"Total Sales Amount in \" + year + \": \" + solution.totalSalesAmount(customerOrders, year));\n        \n        // Test case 2\n        customerOrders = new int[][] {\n            {2015, 10},\n            {2016, 8},\n            {2016, 9},\n            {2017, 4}\n        };\n        year = 2016;\n        System.out.println(\"Total Sales Amount in \" + year + \": \" + solution.totalSalesAmount(customerOrders, year));\n        \n        // Test case 3\n        customerOrders = new int[][] {\n            {2022, 5},\n            {2022, 4}\n        };\n        year = 2022;\n        System.out.println(\"Total Sales Amount in \" + year + \": \" + solution.totalSalesAmount(customerOrders, year));\n    }\n}\n\nclass Solution {\n    public int totalSalesAmount(int[][] customerOrders, int year) {\n        int total = 0;\n        for (int[] order : customerOrders) {\n            if (order[0] == year) {\n                total += order[1];\n            }\n        }\n        return total;\n    }\n}\n```",
  "1383": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Solution {\n    public int maxPerformance(int n, int[] speed, int[] efficiency) {\n        // Sort by efficiency in descending order\n        int[][] pairs = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            pairs[i] = new int[]{efficiency[i], speed[i]};\n        }\n        Arrays.sort(pairs, (a, b) -> b[0] - a[0]);\n        \n        // Use priority queue to store the available engineers\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        long maxPerformance = 0;\n        for (int[] pair : pairs) {\n            while (!pq.isEmpty() && pq.peek() < pair[1]) {\n                maxPerformance += pair[0] * (long)pair[1];\n                pq.poll();\n            }\n            if (!pq.isEmpty()) {\n                maxPerformance += pair[0] * pq.peek();\n            } else {\n                maxPerformance = pair[0] * pair[1];\n            }\n            pq.offer(pair[1]);\n        }\n        \n        return (int) (maxPerformance % 1000000007);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        int n1 = 4;\n        int[] speed1 = {2,10,3,1};\n        int[] efficiency1 = {5,50,6,40};\n        System.out.println(\"Maximum performance for test case 1: \" + solution.maxPerformance(n1, speed1, efficiency1));\n\n        // Test case 2\n        int n2 = 3;\n        int[] speed2 = {20,50,10};\n        int[] efficiency2 = {5,30,40};\n        System.out.println(\"Maximum performance for test case 2: \" + solution.maxPerformance(n2, speed2, efficiency2));\n\n        // Test case 3\n        int n3 = 6;\n        int[] speed3 = {70,50,30,90,60,80};\n        int[] efficiency3 = {100,200,10,300,40,500};\n        System.out.println(\"Maximum performance for test case 3: \" + solution.maxPerformance(n3, speed3, efficiency3));\n    }\n}",
  "1385": "```\npublic class Solution {\n    public int findRadius(int[] circles, int center) {\n        Arrays.sort(circles);\n        int min = Integer.MAX_VALUE;\n        for (int circle : circles) {\n            if (circle > center) {\n                return Math.min(Math.abs(center - circle), min);\n            }\n            min = Math.min(min, circle);\n        }\n        return Math.abs(center - circles[circles.length - 1]);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] circles1 = {1, 3, 5};\n        System.out.println(\"Test case 1: \" + solution.findRadius(circles1, 2));\n        int[] circles2 = {2, 10, 100, 21};\n        System.out.println(\"Test case 2: \" + solution.findRadius(circles2, 6));\n        int[] circles3 = {0, 4, 8, 12, 16};\n        System.out.println(\"Test case 3: \" + solution.findRadius(circles3, 14));\n    }\n}",
  "1386": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(seatsInARow(new int[]{10, 2}, 3) == \"A\" ? \"Pass\" : \"Fail\");\n        System.out.println(seatsInARow(new int[]{3, 1}, 4) == \"B\" ? \"Pass\" : \"Fail\");\n        System.out.println(seatsInARow(new int[]{7, 3}, 5) == \"C\" ? \"Pass\" : \"Fail\");\n    }\n\n    public static String seatsInARow(int[] width, int nRows) {\n        StringBuilder res = new StringBuilder();\n        for (int w : width) {\n            while (w > 0) {\n                if ((nRows & 1) == 1) {\n                    res.append('A');\n                } else {\n                    res.append('B');\n                }\n                w--;\n                nRows >>= 1;\n            }\n        }\n        return res.toString();\n    }\n}",
  "1387": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input1 = {{3, 0, 5, 8}, {2, 20, 1000}, 4};\n        Arrays.stream(powerAssert(input1)).forEach(System.out::println);\n\n        int[][] input2 = {{1}};\n        Arrays.stream(powerAssert(input2)).forEach(System.out::println);\n\n        int[][] input3 = {{10, 2}, {5, 5}};\n        Arrays.stream(powerAssert(input3)).forEach(System.out::println);\n    }\n\n    public static int[] powerAssert(int[][] A) {\n        return Arrays.stream(A).flatMapToInt(row -> IntStream.range(0, row.length).mapToObj(i -> new Pair(row[i], i))).boxed().sorted((a1, a2) -> (int) Math.pow(a1.a, a1.b) - (int) Math.pow(a2.a, a2.b)).map(Pair::a).toArray(Integer[]::new);\n    }\n\n    static class Pair {\n        int a;\n        int b;\n\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n}\n```",
  "1388": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numSlices(6));\n        System.out.println(numSlices(30));\n        System.out.println(numSlices(12));\n    }\n\n    public static int numSlices(int n) {\n        return (n + 2) / 3;\n    }\n}\n```",
  "1389": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums = {{0,1},{1,2}};\n        System.out.println(Arrays.deepToString(createTargetArray(nums)));\n\n        int[][] nums2 = {{0,4,5},{1,2,3}};\n        System.out.println(Arrays.deepToString(createTargetArray(nums2)));\n\n        int[][] nums3 = {{1,2,3},{1,3,2}};\n        System.out.println(Arrays.deepToString(createTargetArray(nums3)));\n    }\n\n    public static int[] createTargetArray(int[][] nums) {\n        List<Integer> list = new ArrayList<>();\n        for (int[] num : nums) {\n            for (int i = 0; i < num.length - 1; i++) {\n                list.add(num[i]);\n            }\n        }\n        return list.stream().mapToInt(Integer::intValue).toArray();\n    }\n}\n```",
  "1390": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n = 7;\n        System.out.println(numFactoredBase(n));\n        \n        n = 25;\n        System.out.println(numFactoredBase(n));\n        \n        n = 499999;\n        System.out.println(numFactoredBase(n));\n    }\n\n    public static String numFactoredBase(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 2; i <= n; i++) {\n            int count = 0;\n            for (int j = 1; j * j <= i; j++) {\n                if (i % (j * j) == 0) {\n                    count++;\n                }\n                if (i % j == 0 && i / j != j) {\n                    count++;\n                }\n                if (count >= 4) {\n                    sb.append(i).append(\" \");\n                    return sb.toString();\n                }\n            }\n        }\n        return \"No four-divisors number is found.\";\n    }\n}",
  "1392": "```\npublic class Solution {\n    public String longestHappyPrefix(String s) {\n        int n = s.length();\n        for (int i = 1; i <= n; i++) {\n            String prefix = s.substring(0, i);\n            if (!isHappy(prefix)) {\n                return prefix;\n            }\n        }\n        return s;\n    }\n\n    private boolean isHappy(String s) {\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            int cur = 0, prev = 0;\n            for (int j = 0; j <= i; j++) {\n                cur = (cur * 31 + s.charAt(j)) % 100000;\n                if (j > 0) {\n                    prev = (prev * 31 + s.charAt(j - 1)) % 100000;\n                }\n            }\n            for (int j = i + 1; j < n; j++) {\n                cur = (cur * 31 + s.charAt(j)) % 100000;\n            }\n            if (cur == prev) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.longestHappyPrefix(\"level\")); // Output: \"lev\"\n        System.out.println(solution.longestHappyPrefix(\"lovel\"));// Output: \"lov\"\n        System.out.println(solution.longestHappyPrefix(\"l\"));      // Output: \"l\"\n    }\n}",
  "1391": "```\npublic class Main {\n    public static void main(String[] args) {\n        boolean[][] grid1 = {{1,0},{1,0}};\n        System.out.println(canReach(grid1)); // expected: false\n\n        boolean[][] grid2 = {{0,0,0},{1,1,0},{1,1,0}};\n        System.out.println(canReach(grid2)); // expected: true\n\n        boolean[][] grid3 = {{0,1},{1,0}};\n        System.out.println(canReach(grid3)); // expected: false\n    }\n\n    public static boolean canReach(boolean[][] grid) {\n        int rows = grid.length;\n        if (rows == 0) return true;\n\n        int cols = grid[0].length;\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j]) {\n                    dfs(grid, i, j);\n                }\n            }\n        }\n\n        return !isConnected(grid);\n    }\n\n    public static void dfs(boolean[][] grid, int row, int col) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n\n        if (row < 0 || row >= rows || col < 0 || col >= cols || !grid[row][col]) {\n            return;\n        }\n\n        grid[row][col] = false;\n        dfs(grid, row - 1, col);\n        dfs(grid, row + 1, col);\n        dfs(grid, row, col - 1);\n        dfs(grid, row, col + 1);\n    }\n\n    public static boolean isConnected(boolean[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j]) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}\n```",
  "1393": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(new CapitalGainLoss().maxProfit(new int[][]{{100, 50}, {11, 90}, {10, 60}})); // Expected output: 110\n        System.out.println(new CapitalGainLoss().maxProfit(new int[][]{{70, 60}, {55, 80}, {1120, 700}, {700, 600}, {100, 150}})); // Expected output: 330\n        System.out.println(new CapitalGainLoss().maxProfit(new int[][]{})); // Expected output: 0\n    }\n}\n\nclass CapitalGainLoss {\n    public int maxProfit(int[][] transactions) {\n        if (transactions.length == 0) return 0;\n        \n        int maxSoFar = 0, maxEndingHere = 0, buyPrice = transactions[0][0], sellPrice = transactions[0][1];\n        \n        for (int i = 1; i < transactions.length; i++) {\n            if (transactions[i][0] > buyPrice) {\n                buyPrice = transactions[i][0];\n                maxEndingHere = 0;\n            }\n            \n            int diff = transactions[i][1] - transactions[i][0];\n            sellPrice = Math.max(sellPrice, transactions[i][1]);\n            \n            maxEndingHere += diff;\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n        \n        return maxSoFar;\n    }\n}",
  "1394": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] arr1 = {2, 4, 5, 3, 7};\n        System.out.println(\"Lucky integer in arr1 is: \" + findLuckyInteger(arr1));\n\n        int[] arr2 = {1, 2, 3, 4, 5};\n        System.out.println(\"Lucky integer in arr2 is: \" + findLuckyInteger(arr2));\n\n        int[] arr3 = {7, 7, 7, 7};\n        System.out.println(\"Lucky integer in arr3 is: \" + findLuckyInteger(arr3));\n    }\n\n    public static int findLuckyInteger(int[] arr) {\n        Map<Integer, Integer> countMap = new HashMap<>();\n        for (int num : arr) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {\n            if (entry.getValue() == 1) {\n                return entry.getKey();\n            }\n        }\n        return -1;\n    }\n}",
  "1395": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countTeams(new int[]{2,5,1,3,2}, new int[]{1,4,2,3,4}) + \" expected: 3\");\n        System.out.println(countTeams(new int[]{5,1,7,9}, new int[]{6,4,3,8}) + \" expected: 0\");\n        System.out.println(countTeams(new int[]{4,1,3,5}, new int[]{2,3,5,4}) + \" expected: 3\");\n    }\n\n    public static int countTeams(int[] russia, int[] england) {\n        // Your solution here\n    }\n}\n```",
  "1396": "```\npublic class Main {\n    public static void main(String[] args) {\n        UndergroundSystem undergroundSystem = new UndergroundSystem();\n        \n        // Test Case 1\n        undergroundSystem.checkIn(\"Leyton\",\"Stan\");\n        undergroundSystem.checkIn(\"Victoria\",\"St Pancreas\");\n        System.out.println(undergroundSystem.getTravelTime(\"Leyton\", \"Heathrow\"));\n        System.out.println(undergroundSystem.getTravelTime(\"Victoria\", \"St Pancras\"));\n        \n        // Test Case 2\n        undergroundSystem.checkIn(\"Hotels\",\"North\");\n        undergroundSystem.checkOut(\"Hotels\",\"South\");\n        System.out.println(undergroundSystem.getTravelTime(\"Kings Cross\",\"St Pancras\"));\n        System.out.println(undergroundSystem.getTravelTime(\"Thames\",\"London Bridge\"));\n        \n        // Test Case 3\n        undergroundSystem.checkIn(\"Pretoria\", \"Muggelony\");\n        undergroundSystem.checkOut(\"Pretoria\", \"Pretorius\");\n        System.out.println(undergroundSystem.getTravelTime(\"Heathrow\", \"Luton\"));\n        System.out.println(undergroundSystem.getTravelTime(\"Waterloo\", \"London Bridge\"));\n    }\n}\n```",
  "1397": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input = {{\"abc\", \"def\", \"ghi\"}, {\"a\", \"b\", \"c\"}, {\"aa\", \"bb\", \"cc\"}};\n        for (int i = 0; i < input.length; i++) {\n            String[] strings = new String[input[i].length];\n            for (int j = 0; j < input[i].length; j++) {\n                strings[j] = new String(new char[input[i][j]]).replace('\\0', input[i][j].charAt(0));\n            }\n            System.out.println(\"Good Strings in \" + Arrays.toString(input[i]) + \":\");\n            for (String str : findGoodStrings(strings)) {\n                System.out.println(str);\n            }\n            System.out.println();\n        }\n    }\n\n    public static List<String> findGoodStrings(String[] strings) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String s : strings) {\n            int count = 0;\n            for (char c : s.toCharArray()) {\n                count += (c == 'a') ? 1 : -1;\n            }\n            if (!map.containsKey(count)) {\n                map.put(count, null);\n            }\n        }\n        List<String> result = new ArrayList<>();\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            String s = entry.getKey();\n            while (s.length() > 0) {\n                int count = 0;\n                for (char c : s.toCharArray()) {\n                    count += (c == 'a') ? 1 : -1;\n                }\n                if (count == 0) {\n                    result.add(s);\n                } else {\n                    s = s.substring(1);\n                }\n            }\n        }\n        return result;\n    }\n}\n```",
  "1398": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1\n        List<List<String>> customerBoughtProducts = Arrays.asList(\n                Arrays.asList(\"A\", \"B\"), \n                Arrays.asList(\"C\", \"D\"),\n                Arrays.asList(\"A\", \"E\")\n            );\n        List<List<String>> expectedResult = Arrays.asList(\n                Arrays.asList(\"A\", \"B\")\n            );\n        System.out.println(solution.customerWhoBoughtProductsAandBbutNotC(customerBoughtProducts));\n        \n        // Test Case 2\n        customerBoughtProducts = Arrays.asList(\n                Arrays.asList(\"A\"), \n                Arrays.asList(\"B\"),\n                Arrays.asList(\"D\")\n            );\n        expectedResult = new ArrayList<>();\n        System.out.println(solution.customerWhoBoughtProductsAandBbutNotC(customerBoughtProducts));\n        \n        // Test Case 3\n        customerBoughtProducts = Arrays.asList(\n                Arrays.asList(\"A\", \"B\"), \n                Arrays.asList(\"C\"),\n                Arrays.asList(\"E\")\n            );\n        expectedResult = Arrays.asList(\n                Arrays.asList(\"A\", \"B\")\n            );\n        System.out.println(solution.customerWhoBoughtProductsAandBbutNotC(customerBoughtProducts));\n    }\n}\n```",
  "1399": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countLargestGroup(\"rpyz\")); // Expected: 2\n        System.out.println(countLargestGroup(\"abbcccbdaabccdbbb\"));// Expected: 8\n        System.out.println(countLargestGroup(\"wywhg\")); // Expected: 1\n    }\n\n    public static int countLargestGroup(String str) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (char c : str.toCharArray()) {\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        int maxCount = 0;\n        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\n            if (entry.getValue() > maxCount) {\n                maxCount = entry.getValue();\n            }\n        }\n        return maxCount;\n    }\n}\n```",
  "1400": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(kPalindrome(\"annihilation\", 1));\n        System.out.println(kPalindrome(\"ability\", 2));\n        System.out.println(kPalindrome(\"for\", 4));\n    }\n\n    public static List<String> kPalindrome(String s, int k) {\n        // Your code here\n    }\n}\n```",
  "1401": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isOverlapped(1, 2, 4, 5)); // Test case 1: true\n        System.out.println(isOverlapped(-1, -2, 0, 3)); // Test case 2: false\n        System.out.println(isOverlapped(-2, -1, 0, 3)); // Test case 3: true\n    }\n\n    public static boolean isOverlapped(int circleX, int circleY, int rectangleX, int rectangleY) {\n        double distance = Math.sqrt(Math.pow(circleX - rectangleX, 2) + Math.pow(circleY - rectangleY, 2));\n        return distance <= (Math.max(Math.abs(circleX), Math.abs(rectangleX)) + Math.max(Math.abs(circleY), Math.abs(rectangleY))) / 2;\n    }\n}\n```",
  "1402": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] dishes = {{1, 4}, {2, 5}, {7, 10}};\n        System.out.println(minCostToFood(dishes)); // Expected: 6\n\n        int[][] dishes2 = {{3, 8}, {3, 14}, {6, 12}};\n        System.out.println(minCostToFood(dishes2)); // Expected: 9\n\n        int[][] dishes3 = {{1, 4}, {10, 20}};\n        System.out.println(minCostToFood(dishes3)); // Expected: 15\n    }\n\n    public static int minCostToFood(int[][] cost) {\n        Arrays.sort(cost, (a, b) -> a[0] - b[0]);\n        int total = 0;\n        for (int i = 0; i < cost.length; i++) {\n            total += cost[i][1];\n            if (i > 0 && cost[i-1][1] + cost[i][1] <= cost[i][1]) {\n                total -= cost[i-1][1];\n            }\n        }\n        return total;\n    }\n}\n```",
  "1403": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSubsequence(new int[]{4, 3, 10, 9, 8, 7, 6, 5, 2, 1})); // Test case 1\n        System.out.println(minSubsequence(new int[]{28, 23, 22, 21, 20})); // Test case 2\n        System.out.println(minSubsequence(new int[]{10, 9, 8, 7, 6, 5, 4, 3, 2, 1})); // Test case 3\n    }\n\n    public static String minSubsequence(int[] nums) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < nums.length; i++) {\n            if (i == 0 || nums[i] >= nums[i - 1]) {\n                sb.append(nums[i]).append(\",\");\n            }\n        }\n        return sb.toString().substring(0, sb.toString().length() - 1);\n    }\n}",
  "1404": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(stepsToReduce(\"11110\", \"1106\")); // Expected: 5\n        System.out.println(stepsToReduce(\"10000\", \"10\")); // Expected: 5\n        System.out.println(stepsToReduce(\"0\", \"1\")); // Expected: 22\n    }\n\n    public static int stepsToReduce(String s, String t) {\n        int res = 0;\n        for (int i = 0; i < Math.max(s.length(), t.length()); i++) {\n            if (i >= s.length()) {\n                res += Character.getNumericValue(t.charAt(i)) * (1 << (t.length() - i - 1));\n            } else if (i >= t.length()) {\n                res += Character.getNumericValue(s.charAt(i)) * (1 << (s.length() - i - 1));\n            } else {\n                int diff = Math.abs(Character.getNumericValue(s.charAt(i)) - Character.getNumericValue(t.charAt(i)));\n                res += diff;\n                if (Character.getNumericValue(s.charAt(i)) > Character.getNumericValue(t.charAt(i))) {\n                    s = String.valueOf(Integer.parseInt(s) ^ (1 << i));\n                } else {\n                    t = String.valueOf(Integer.parseInt(t) ^ (1 << i));\n                }\n            }\n        }\n        return res;\n    }\n}",
  "1405": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestHappyString(\"abc\", 2)); // expected output: \"ac\"\n        System.out.println(longestHappyString(\"leetcode\", 3)); // expected output: \"leotcede\"\n        System.out.println(longestHappyString(\"abca\", 1)); // expected output: \"\"\n    }\n\n    public static String longestHappyString(String s, int bubbles) {\n        // your implementation here\n    }\n}\n```",
  "1406": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canWin(5, new int[]{1, 2, 3, 4, 5})); // Test case 1: Can win\n        System.out.println(canWin(7, new int[]{1, 1, 2, 2, 2, 3, 4, 4, 4, 4})); // Test case 2: Cannot win\n        System.out.println(canWin(10, new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10})); // Test case 3: Can win\n    }\n\n    public static boolean canWin(int n, int[] stones) {\n        if (n == 0) return false;\n        if (n < 0) return true;\n\n        for (int i = 1; i <= Math.min(n, stones.length); i++) {\n            if (!canWin(n - i, takeStones(stones, i))) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static int[] takeStones(int[] stones, int count) {\n        int[] result = new int[stones.length];\n        for (int i = 0; i < stones.length; i++) {\n            if (i < count) {\n                result[i] = stones[i];\n            } else {\n                result[i - count] = stones[i];\n            }\n        }\n        return result;\n    }\n}\n```",
  "1407": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Traveler> travelers = new ArrayList<>();\n        \n        // Test Case 1\n        Traveler t1 = new Traveler(\"Alice\", 10);\n        t1.addTrip(new Trip(\"USA\", \"2022-01-01\", \"2022-01-05\"));\n        t1.addTrip(new Trip(\"Canada\", \"2022-02-01\", \"2022-02-15\"));\n        travelers.add(t1);\n\n        // Test Case 2\n        Traveler t2 = new Traveler(\"Bob\", 5);\n        t2.addTrip(new Trip(\"Mexico\", \"2022-03-01\", \"2022-03-10\"));\n        travelers.add(t2);\n\n        // Test Case 3\n        Traveler t3 = new Traveler(\"Charlie\", 20);\n        t3.addTrip(new Trip(\"Japan\", \"2022-04-01\", \"2022-04-15\"));\n        t3.addTrip(new Trip(\"South Korea\", \"2022-05-01\", \"2022-05-20\"));\n        travelers.add(t3);\n\n        for (Traveler traveler : travelers) {\n            System.out.println(\"Top Traveler: \" + traveler.getName());\n            Map<String, Integer> destinations = getTopDestinations(traveler);\n            for (Map.Entry<String, Integer> entry : destinations.entrySet()) {\n                System.out.println(entry.getKey() + \": \" + entry.getValue());\n            }\n        }\n    }\n\n    public static Map<String, Integer> getTopDestinations(Traveler traveler) {\n        // Your implementation here\n        return null;\n    }\n}\n\nclass Traveler {\n    private String name;\n    private int totalMiles;\n\n    public Traveler(String name, int totalMiles) {\n        this.name = name;\n        this.totalMiles = totalMiles;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void addTrip(Trip trip) {\n        // Your implementation here\n    }\n}\n\nclass Trip {\n    private String destination;\n    private Date start;\n    private Date end;\n\n    public Trip(String destination, Date start, Date end) {\n        this.destination = destination;\n        this.start = start;\n        this.end = end;\n    }\n\n    public String getDestination() {\n        return destination;\n    }\n}\n```",
  "1408": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(stringMatching(new String[]{\"mass\", \"as\"}, \"mas\")); // Expected output: [\"mass\"]\n        System.out.println(stringMatching(new String[]{\"cow\", \"ow\"}, \"cow\")); // Expected output: [\"cow\"]\n        System.out.println(stringMatching(new String[]{\"dog\", \"cat\", \"fish\"}, \"at\")); // Expected output: [\"dog\", \"cat\"]\n    }\n\n    public static List<String> stringMatching(String[] words, String pattern) {\n        List<String> result = new ArrayList<>();\n        for (String word : words) {\n            if (word.contains(pattern)) {\n                result.add(word);\n            }\n        }\n        return result;\n    }\n}\n```",
  "1410": "```\npublic class Solution {\n    public String entityParser(String text) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : text.toCharArray()) {\n            if (c == '&') {\n                sb.append('&amp;').append(c);\n            } else if (c == '\\'') {\n                sb.append('&#39;').append(c);\n            } else if (c == '\"') {\n                sb.append('&quot;');\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.entityParser(\"Hello &amp; world!\"));\n        System.out.println(solution.entityParser(\"Good news: the HTML & entity parser &amp;amp; is quite fast!\"));\n        System.out.println(solution.entityParser(\"\"));\n    }\n}",
  "1409": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] queries = {\n            {1, 5},\n            {4, -3, 0},\n            {2, 7, 9}\n        };\n        \n        int[] nums = {2, 1, 4, 3};\n        int[] result = new int[queries.length];\n        \n        for (int i = 0; i < queries.length; i++) {\n            result[i] = new Solution().maxEqualFrequency(nums, queries[i][1], queries[i].length > 1 ? queries[i][2] : -1);\n        }\n        \n        System.out.println(\"Test case 1: \" + result[0]);\n        System.out.println(\"Test case 2: \" + result[1]);\n        System.out.println(\"Test case 3: \" + result[2]);\n    }\n}\n\nclass Solution {\n    public int maxEqualFrequency(int[] nums, int key, int k) {\n        // Your code here\n    }\n}\n```",
  "1411": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int n1 = 1;\n        System.out.println(\"For n=\" + n1 + \" ways to paint: \" + numWays(n1));\n        \n        int n2 = 3;\n        System.out.println(\"For n=\" + n2 + \" ways to paint: \" + numWays(n2));\n        \n        int n3 = 7;\n        System.out.println(\"For n=\" + n3 + \" ways to paint: \" + numWays(n3));\n    }\n\n    public static int numWays(int n) {\n        if (n < 1) return 0;\n        if (n == 1) return 6;\n        \n        long[] dp = new long[n + 1];\n        dp[1] = 6;\n        \n        for (int i = 2; i <= n; i++) {\n            dp[i] = (dp[i - 1] * 2 + 1) % 1000000007;\n        }\n        \n        return (int) dp[n];\n    }\n}",
  "1412": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[][] exams = {{1, 0, 1}, {1, 1, 1}, {2, 0, 1}};\n        String[] students = {\"John\", \"Mai\", \"Lee\"};\n        System.out.println(\"Test case 1: \");\n        for (String student : solution.findQuietStudents(exams, students)) {\n            System.out.print(student + \" \");\n        }\n        System.out.println();\n        \n        // Test case 2\n        exams = new int[][]{{0, 1, 1}, {1, 0, 1}};\n        students = new String[]{\"Emma\", \"Michael\"};\n        System.out.println(\"Test case 2: \");\n        for (String student : solution.findQuietStudents(exams, students)) {\n            System.out.print(student + \" \");\n        }\n        System.out.println();\n        \n        // Test case 3\n        exams = new int[][]{{1, 0}, {1, 1}};\n        students = new String[]{\"Ariel\", \"Seth\"};\n        System.out.println(\"Test case 3: \");\n        for (String student : solution.findQuietStudents(exams, students)) {\n            System.out.print(student + \" \");\n        }\n        System.out.println();\n    }\n}\n```",
  "1413": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minStartValue(new int[]{8,1,2,10,5,3})); // Expected output: 3\n        System.out.println(minStartValue(new int[]{1,4,6,8,9})); // Expected output: 4\n        System.out.println(minStartValue(new int[]{-1000,-900,-500,-400,-300,-200,-100,-50,-30,-20,-10,-5,3,7,14})); // Expected output: 11\n    }\n\n    public static int minStartValue(int[] arr) {\n        long sum = 0;\n        for (int num : arr) {\n            sum += num;\n        }\n        if (sum <= 0) return 1;\n        int ans = 1;\n        while ((long)(ans - 1) * (arr[0] + ans - 1) < sum) {\n            ans++;\n        }\n        return ans;\n    }\n}\n```",
  "1414": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minFibonacciNumbers(7, 15)); // expected: 2\n        System.out.println(minFibonacciNumbers(10, 19)); // expected: 3\n        System.out.println(minFibonacciNumbers(9, 34)); // expected: 4\n    }\n\n    public static int minFibonacciNumbers(int k) {\n        // Your code here\n    }\n}\n```",
  "1415": "```\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int n = 1;\n        int k = 1;\n        System.out.println(findHappyString(n, k));\n\n        n = 1;\n        k = 3;\n        System.out.println(findHappyString(n, k));\n\n        n = 7;\n        k = 13;\n        System.out.println(findHappyString(n, k));\n    }\n\n    public static String findHappyString(int n, int k) {\n        // Your code goes here\n    }\n}\n```",
  "1416": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(restoreArray(\"1000000001\"))); // Expected: [1,0,0,0,0,0,0,1]\n        System.out.println(Arrays.toString(restoreArray(\"10[10][20][30]\"))) ;// Expected: [1,0,[10],[2,0],[3,0]]\n        System.out.println(Arrays.toString(restoreArray(\"10[10][20][30][40[5]]\")));// Expected: [1,0,[10],[2,0],[3,0],[4,0,[5]]]\n    }\n\n    public static int[] restoreArray(String s) {\n        String[] split = s.split(\"\");\n        List<String> list = new ArrayList<>();\n        for (String str : split) {\n            if (!str.equals(\"[\") && !str.equals(\"]\")) {\n                list.add(str);\n            } else {\n                if (!list.isEmpty()) {\n                    int val = Integer.parseInt(list.remove(0));\n                    while (!list.isEmpty() && Integer.parseInt(list.get(0)) < val) {\n                        list.remove(0);\n                    }\n                }\n            }\n        }\n        int[] res = new int[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            res[i] = Integer.parseInt(list.get(i));\n        }\n        return res;\n    }\n}",
  "1417": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reformat(\"a12bc1d23\"));//\"abccba\"\n        System.out.println(reformat(\"leetcode\"));//\"leotcdcoe\"\n        System.out.println(reformat(\"1223911\"));//\"131299\"\n    }\n\n    public static String reformat(String s) {\n        int[] count = new int[2];\n        for (char c : s.toCharArray()) {\n            if (Character.isLetter(c)) {\n                count[0]++;\n            } else {\n                count[1]++;\n            }\n        }\n        boolean hasEqual = false;\n        if (count[0] == count[1]) {\n            hasEqual = true;\n        } else if (Math.abs(count[0] - count[1]) > 1) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n        int maxLen = Math.max(count[0], count[1]);\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (Character.isLetter(c)) {\n                if (maxLen-- > 0) {\n                    sb.append(c);\n                } else {\n                    for (int j = i + 1; j < s.length(); j++) {\n                        if (!Character.isLetter(s.charAt(j))) {\n                            sb.append(s.charAt(i));\n                            sb.append(s.charAt(j));\n                            break;\n                        }\n                    }\n                    maxLen--;\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n        return hasEqual ? sb.toString() : sb.reverse().toString();\n    }\n}",
  "1418": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] orders1 = {{1, \"apple pie\"}, {2, \"burger\"}, {3, \"pizza\"}};\n        displayTable(orders1);\n\n        System.out.println();\n\n        int[][] orders2 = {{5, \"chocolate cake\"}, {3, \"hamburger\"}, {8, \"milkshake\"}};\n        displayTable(orders2);\n\n        System.out.println();\n\n        int[][] orders3 = {};\n        displayTable(orders3);\n    }\n\n    public static void displayTable(int[][] orders) {\n        Arrays.sort(orders, (a, b) -> Integer.compare(a[0], b[0]));\n\n        for (int[] order : orders) {\n            String food = order[1];\n            int quantity = order[0];\n\n            System.out.printf(\"| %d | %s |\\n\", quantity, food);\n        }\n    }\n}\n```",
  "1419": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumNumber(\"1\", \"5\", \"2\")); // Expected output: 6\n        System.out.println(minimumNumber(\"0\", \"1\", \"5\", \"7\", \"2\")); // Expected output: 8\n        System.out.println(minimumNumber(\"1\", \"2\", \"3\", \"4\", \"5\", \"6\")); // Expected output: 9\n    }\n\n    public static int minimumNumber(String time1, String time2, String... times) {\n        int minTime = Math.min(Integer.parseInt(time1), Integer.parseInt(time2));\n        for (String time : times) {\n            minTime = Math.min(minTime, Integer.parseInt(time));\n        }\n        return 60 - minTime;\n    }\n}\n```",
  "1420": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeArray(new int[]{2,3,5,4}, 1));\n        System.out.println(canBeArray(new int[]{3,3,5,2,9,8,6,7,10,17,15,14,18,16,19,13,12,20,11,10,14,15}, 2));\n        System.out.println(canBeArray(new int[]{1,4,3}, 3));\n    }\n\n    public static boolean canBeArray(int[] nums, int k) {\n        int n = nums.length;\n        int[][] dp = new int[n][k+1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j <= k; j++) {\n                if (j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = (i > 0 && dp[i-1][j-1]) || (i < n-1 && i + 1 >= nums[0] && dp[i-1][j]);\n                }\n            }\n        }\n\n        return dp[n-1][k];\n    }\n}\n```",
  "1421": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] accounts = {{1, 2, 10}, {3, 4, 20}};\n        int[][] queries = {{0, 1}, {3, 4}};\n        for (int[] query : queries) {\n            System.out.println(\"Query: \" + query[0] + \", \" + query[1]);\n            System.out.println(\"Result: \" + npv(query[0], query[1], accounts));\n            System.out.println();\n        }\n    }\n\n    public static double npv(int start, int end, int[][] accounts) {\n        double total = 0.0;\n        for (int i = start; i <= end; i++) {\n            for (int[] account : accounts) {\n                if (i == account[0]) {\n                    total += account[2];\n                } else if (i + 1 == account[0]) {\n                    total -= account[2] * 0.5;\n                }\n            }\n        }\n        return total;\n    }\n}\n```",
  "1422": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maximumScore(\"011235\"));//1\n        System.out.println(maximumScore(\"10101\"));//5\n        System.out.println(maximumScore(\"00111\")); // 2\n    }\n\n    public static int maximumScore(String s) {\n        int n = s.length();\n        int[] leftSum = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            leftSum[i + 1] = leftSum[i] + s.charAt(i) - '0';\n        }\n        int maxScore = 0;\n        for (int i = 1; i <= n / 2; i++) {\n            int rightSum = leftSum[n] - leftSum[i];\n            if ((s.charAt(i - 1) - '0') == (s.charAt(n - i) - '0')) {\n                maxScore = Math.max(maxScore, rightSum);\n            } else {\n                maxScore = Math.max(maxScore, leftSum[i - 1] + rightSum);\n            }\n        }\n        return maxScore;\n    }\n}",
  "1423": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] cardPoints1 = {1,2,3,4,5,6,1};\n        System.out.println(\"Expected: 15, Got: \" + maxCardPoints(cardPoints1));\n\n        int[] cardPoints2 = {10,6,13,1,12,7,15,8,8,3};\n        System.out.println(\"Expected: 24, Got: \" + maxCardPoints(cardPoints2));\n\n        int[] cardPoints3 = {1,15,3};\n        System.out.println(\"Expected: 22, Got: \" + maxCardPoints(cardPoints3));\n    }\n\n    public static int maxCardPoints(int[] cardPoints) {\n        int n = cardPoints.length;\n        int ans = Math.max(getPointsFromStart(n, cardPoints), getPointsFromEnd(n, cardPoints));\n        return ans;\n    }\n\n    public static int getPointsFromStart(int n, int[] cardPoints) {\n        int points = 0;\n        for (int i = 0; i < n - 2; i++) {\n            if (cardPoints[i] >= cardPoints[i + 1]) {\n                break;\n            }\n            points += cardPoints[i];\n        }\n        return points + Math.max(cardPoints[n - 2], cardPoints[n - 1]);\n    }\n\n    public static int getPointsFromEnd(int n, int[] cardPoints) {\n        int points = 0;\n        for (int i = n - 3; i >= 0; i--) {\n            if (cardPoints[i] <= cardPoints[i + 1]) {\n                break;\n            }\n            points += cardPoints[i];\n        }\n        return points + Math.max(cardPoints[n - 2], cardPoints[n - 1]);\n    }\n}\n```",
  "1424": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] mat1 = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n        System.out.println(Arrays.deepToString(diagonalOrder(mat1)));\n\n        int[][] mat2 = {{1, 2}, {3, 4}, {5, 6}};\n        System.out.println(Arrays.deepToString(diagonalOrder(mat2)));\n\n        int[][] mat3 = {{1}, {2}, {3}};\n        System.out.println(Arrays.deepToString(diagonalOrder(mat3)));\n    }\n\n    public static int[][] diagonalOrder(int[][] mat) {\n        if (mat.length == 0) return new int[0][];\n        \n        Map<Integer, List<int[]>> map = new HashMap<>();\n        for (int i = 0; i < mat.length; i++) {\n            for (int j = 0; j < mat[i].length; j++) {\n                map.computeIfAbsent(i - j, k -> new ArrayList<>()).add(new int[]{mat[i][j], i, j});\n            }\n        }\n\n        List<int[]> result = new ArrayList<>();\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for (int i : map.keySet()) {\n            queue.offer(i);\n        }\n\n        while (!queue.isEmpty()) {\n            int k = queue.poll();\n            while (k-- > 0) {\n                result.add(map.get(k).get(0));\n                if (map.containsKey(k - 1)) {\n                    queue.offer(k - 1);\n                }\n                map.remove(k, map.get(k));\n                k--;\n            }\n        }\n\n        int[][] res = new int[result.size()][];\n        for (int i = 0; i < result.size(); i++) {\n            res[i] = result.get(i);\n        }\n        return res;\n    }\n}",
  "1425": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(constrainedSubsequenceSum(new int[]{10,6,5,0,20,1,8},15)); // Test case 1: Expected output = 32\n        System.out.println(constrainedSubsequenceSum(new int[]{1,2,3,4,5,6,7,8,9,10},5)); // Test case 2: Expected output = 15\n        System.out.println(constrainedSubsequenceSum(new int[]{1,-2,3,0,-4,5,-6,7,-8,9,-10},-25)); // Test case 3: Expected output = -23\n    }\n\n    public static int constrainedSubsequenceSum(int[] nums, int maxSum) {\n        // Your code here...\n    }\n}\n```",
  "1426": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        int[] arr = {1,2,3};\n        int k = 1;\n        System.out.println(countElements(arr, k)); // Expected: 1\n\n        System.out.println(\"\\nTest Case 2:\");\n        arr = new int[]{0,1,1};\n        k = 0;\n        System.out.println(countElements(arr, k)); // Expected: 2\n\n        System.out.println(\"\\nTest Case 3:\");\n        arr = new int[]{1,1,2,2};\n        k = 1;\n        System.out.println(countElements(arr, k)); // Expected: 2\n    }\n\n    public static int countElements(int[] arr, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : arr) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        return map.get(k);\n    }\n}\n```",
  "1427": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(shiftString(\"abc\", new int[][]{{1,0}, {2,1}}));\n        System.out.println(shiftString(\"abcdef\", new int[][]{{6,1}, {2,2}}));\n        System.out.println(shiftString(\"aaa\", new int[][]{{3,9},{1,18}}));\n    }\n\n    public static String shiftString(String str, int[][] shifts) {\n        char[] chars = str.toCharArray();\n        for (int i = 0; i < shifts.length; i++) {\n            int direction = shifts[i][0];\n            int amount = shifts[i][1];\n            if (direction == 0) { // left shift\n                amount = amount % str.length();\n                String prefix = new String(new char[amount]).replace(\"\\0\", \"\").toCharArray();\n                String suffix = new String(chars).replace(prefix, \"\");\n                chars = (suffix + prefix).toCharArray();\n            } else if (direction == 1) { // right shift\n                amount = amount % str.length();\n                String suffix = new String(chars).substring(0, str.length() - amount);\n                String prefix = new String(chars).substring(str.length() - amount);\n                chars = (prefix + suffix).toCharArray();\n            }\n        }\n        return new String(chars);\n    }\n}",
  "1428": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] binaryMatrix = {{0,1},{1,0}};\n        System.out.println(leftMostColumn(binaryMatrix));\n\n        int[][] binaryMatrix2 = {{0,0,0,1},{0,0,0,1},{1,0,0,0}};\n        System.out.println(leftMostColumn(binaryMatrix2));\n\n        int[][] binaryMatrix3 = {{0,1,1},{0,0,1},{1,1,1}};\n        System.out.println(leftMostColumn(binaryMatrix3));\n    }\n\n    public static int leftMostColumn(int[][] binaryMatrix) {\n        int row = binaryMatrix.length;\n        int col = 0;\n        for (int i = 0; i < row; i++) {\n            while (col < binaryMatrix[0].length && !isOne(binaryMatrix[i], col)) {\n                col++;\n            }\n        }\n        return col == binaryMatrix[0].length ? -1 : col;\n    }\n\n    public static boolean isOne(int[] row, int col) {\n        for (int i = 0; i < row.length; i++) {\n            if (row[i] == 1 && i == col) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "1429": "```\nimport java.util.*;\n\npublic class FirstUnique {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \");\n        int[] nums = {2,3,5,7,23};\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        FirstUniqueNumber f = new FirstUniqueNumber();\n        f.unique = new PriorityQueue<>((a, b) -> a - b);\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() == 1) {\n                f.unique.offer(entry.getKey());\n            } else {\n                while (!f.unique.isEmpty() && f.unique.peek() == entry.getKey()) {\n                    f.unique.poll();\n                }\n            }\n        }\n        System.out.println(\"First unique number is: \" + f.unique.peek());\n\n        System.out.println(\"\\nTest case 2: \");\n        nums = new int[]{1, 2, 3, 4};\n        map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        f = new FirstUniqueNumber();\n        f.unique = new PriorityQueue<>((a, b) -> a - b);\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() == 1) {\n                f.unique.offer(entry.getKey());\n            } else {\n                while (!f.unique.isEmpty() && f.unique.peek() == entry.getKey()) {\n                    f.unique.poll();\n                }\n            }\n        }\n        System.out.println(\"First unique number is: \" + f.unique.peek());\n\n        System.out.println(\"\\nTest case 3: \");\n        nums = new int[]{5,7,3};\n        map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        f = new FirstUniqueNumber();\n        f.unique = new PriorityQueue<>((a, b) -> a - b);\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() == 1) {\n                f.unique.offer(entry.getKey());\n            } else {\n                while (!f.unique.isEmpty() && f.unique.peek() == entry.getKey()) {\n                    f.unique.poll();\n                }\n            }\n        }\n        System.out.println(\"First unique number is: \" + f.unique.peek());\n    }\n}\n\nclass FirstUniqueNumber {\n    PriorityQueue<Integer> unique;\n}\n```",
  "1430": "```\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(\"root\");\n        root1.left = new TreeNode(\"l1\");\n        root1.right = new TreeNode(\"r1\");\n        root1.left.left = new TreeNode(\"ll1\");\n        root1.left.right = new TreeNode(\"lr1\");\n        root1.right.left = new TreeNode(\"rl1\");\n        root1.right.right = new TreeNode(\"rr1\");\n\n        System.out.println(canIProcessEvent(root1, \"root->l1->ll1->lr1\")); // true\n        System.out.println(canIProcessEvent(root1, \"root->r1->rr1\")); // false\n        System.out.println(canIProcessEvent(root1, \"root->l1->rl1\")); // true\n    }\n\n    public static boolean canIProcessEvent(TreeNode root, String s) {\n        if (s == null || root == null) return false;\n        \n        List<TreeNode> queue = new ArrayList<>();\n        queue.add(root);\n\n        int i = 0;\n        while (!queue.isEmpty() && i < s.length()) {\n            TreeNode node = queue.remove(0);\n            if (i + 1 >= s.length() || !node.val.equals(s.substring(i, i+1))) return false;\n            i++;\n            if (node.left != null) queue.add(node.left);\n            if (node.right != null) queue.add(node.right);\n        }\n        return i == s.length();\n    }\n\n    static class TreeNode {\n        String val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode(String x) { val = x; }\n    }\n}\n```",
  "1431": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr = {{2, 3, 5}, {1, 3, 6}, {9, 8, 7}};\n        System.out.println(kidsWithCandies(arr, 3));\n\n        int[][] arr1 = {{1, 1}, {1, 1}};\n        System.out.println(kidsWithCandies(arr1, 5));\n\n        int[][] arr2 = {{1, 2, 3, 4}, {6, 7, 8, 9}};\n        System.out.println(kidsWithCandies(arr2, 10));\n    }\n\n    public static List<Boolean> kidsWithCandies(int[] ratings, int extraCandies) {\n        List<Boolean> result = new ArrayList<>();\n        for (int i : ratings) {\n            boolean hasExtraCandy = i + extraCandies >= Collections.max(Arrays.asList(ratings));\n            result.add(hasExtraCandy);\n        }\n        return result;\n    }\n}\n```",
  "1432": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumGap(new int[]{10}) + \" == expected 0\");\n        System.out.println(maximumGap(new int[]{4,2,10,9,2,5,1,7,6}) + \" == expected 6\");\n        System.out.println(maximumGap(new int[]{3,99,98,68,97,43,72,5,18,65}) + \" == expected 95\");\n    }\n\n    public static int maximumGap(int[] nums) {\n        if (nums.length < 2) return 0;\n        int min = nums[0], max = nums[0];\n        for (int num : nums) {\n            if (num < min) min = num;\n            else if (num > max) max = num;\n        }\n        if (max == min) return 0;\n\n        int bucketSize = Math.max(1, ((max - min) / (nums.length - 1)));\n        int[] left = new int[nums.length], right = new int[nums.length];\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == min || nums[i] == max)\n                continue;\n            int idx = (nums[i] - min) / bucketSize;\n            left[idx]++;\n            right[idx]++;\n        }\n\n        int res = 0, prevMax = min + bucketSize;\n        for (int i = 0; i < nums.length; i++) {\n            while (left[i]-- > 0) {\n                res = Math.max(res, nums[i] - prevMax);\n                prevMax = min + (i + 1) * bucketSize;\n            }\n            while (right[i]-- > 0) {\n                res = Math.max(res, prevMax - nums[i]);\n                prevMax += bucketSize;\n            }\n        }\n        return res;\n    }\n}",
  "1433": "```\nimport java.util.Arrays;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBreak(\"abc\", \"def\")); // Expected: true\n        System.out.println(canBreak(\"aaaaaa\", \"b\")); // Expected: false\n        System.out.println(canBreak(\"abcdefghijklmnopqrstuvwxyz\", \"abcdefghijklmnopqrstuvwxyz\")); // Expected: true\n    }\n\n    public static boolean canBreak(String s1, String s2) {\n        for (int i = 0; i < s1.length(); i++) {\n            if (!canBreak(s1.substring(i), s2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean canBreak(String s1, String s2) {\n        for (int i = 0; i < s2.length(); i++) {\n            if (s2.indexOf(s1.charAt(0)) != i && s2.indexOf(s1.charAt(i)) == i) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean canBreak(String s, String t) {\n        int j = 0;\n        for (int i = 0; i < s.length(); i++) {\n            while (j < t.length() && t.charAt(j) < s.charAt(i)) {\n                j++;\n            }\n            if (j == t.length()) {\n                return true;\n            }\n            if (i == s.length() - 1 || s.charAt(i + 1) <= t.charAt(j)) {\n                return false;\n            }\n            j++;\n        }\n        return true;\n    }\n\n}",
  "1434": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] expectations = {{1, 2}, {4, 0}};\n        for (int i = 0; i < expectations.length; i++) {\n            System.out.println(\"Number of ways to wear different hats: \" + numWays(expectations[i][0], expectations[i][1]));\n        }\n    }\n\n    public static int numWays(int n, int m) {\n        int[] dp = new int[1 << 6];\n        for (int i = 0; i < (1 << 6); i++) {\n            if ((i & (i >> 1)) == 0) {\n                continue;\n            }\n            dp[i] = Integer.MAX_VALUE;\n        }\n        int res = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    continue;\n                }\n                dp[i | (1 << j)] = Math.min(dp[i | (1 << j)], dp[i] + 1);\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            res += dp[m - 1 - i];\n        }\n        return res;\n    }\n}\n```",
  "1435": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = {{2017,6,10}, {2017,6,15}, {2017,7,5}, {2018,1,1}};\n        System.out.println(sessionLogs(logs));\n        \n        int[][] logs2 = {{2020,3,20},{2020,4,30}};\n        System.out.println(sessionLogs(logs2));\n        \n        int[][] logs3 = {{2019,10,6},{2018,12,5},{2017,12,15}};\n        System.out.println(sessionLogs(logs3));\n    }\n\n    public static String sessionLogs(int[][] logs) {\n        Map<Integer, List<Map.Entry<Integer,Integer>>> map = new HashMap<>();\n        for (int[] log : logs) {\n            int year = log[0], month = log[1], day = log[2];\n            String key = String.valueOf(year*10000+month*100+day);\n            if (!map.containsKey(key)) {\n                List<Map.Entry<Integer,Integer>> list = new ArrayList<>();\n                map.put(key, list);\n            }\n            map.get(key).add(new AbstractMap.SimpleEntry<>(year, month));\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        for (List<Map.Entry<Integer,Integer>> list : map.values()) {\n            int year = 0;\n            for (Map.Entry<Integer,Integer> entry : list) {\n                int y = entry.getKey();\n                if(y!=year){\n                    sb.append(String.format(\"%d-%02d\\n\",y,1));\n                    year=y;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}",
  "1436": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(destinationCity(new String[][]{{\"New York\", \"MUMBAI\"}, {\"Los Angeles\", \"NEW YORK\"}}, \"MUMBAI\").equals(\"New York\"));\n        System.out.println(destinationCity(new String[][]{{\"Boston\", \"ATLANTA\"}, {\"New York\", \"BOSTON\"}}, \"ATLANTA\").equals(\"Boston\"));\n        System.out.println(destinationCity(new String[][]{{\"London\", \"LONDON\"}}, \"LONDON\").equals(\"London\"));\n    }\n\n    public static String destinationCity(String[][] paths) {\n        HashMap<String, String> map = new HashMap<>();\n        for (String[] path : paths) {\n            map.put(path[0], path[1]);\n        }\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            if (entry.getValue().equals(\"MUMBAI\")) {\n                return entry.getKey();\n            }\n        }\n        return \"\";\n    }\n}\n```",
  "1437": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {{1,0,0,1},{1,0,0,1},{1,0,0,1},},\n            {{0,1},{1,1}},{1,0,1}\n        };\n        for (int i = 0; i < arrays.length; i++) {\n            System.out.println(\"Array \" + i + \": \" + hasAllOnesAtLeastLengthKPlacesAway(arrays[i], 2));\n        }\n    }\n\n    public static boolean hasAllOnesAtLeastLengthKPlacesAway(int[][] grid, int k) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == 1) {\n                    if (i - k >= 0 && grid[i-k][j] == 1 || j - k >= 0 && grid[i][j-k] == 1 || i+k<grid.length&&grid[i+k][j]==1||j+k<grid[0].length&&grid[i][j+k]==1) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}",
  "1438": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(longestSubarray(new int[]{8,2,3,2,-6,2,1}, 1)); // Expected: 7\n        System.out.println(longestSubarray(new int[]{10,5,1,0,-110], 3)); // Expected: 9\n        System.out.println(longestSubarray(new int[]{10476,4215,7135,1146,6147,9114}, 100)); // Expected: 22\n    }\n\n    public static int longestSubarray(int[] nums, int limit) {\n        // Your code here...\n        // ...\n    }\n}\n```",
  "1439": "```\nimport java.util.*;\n\npublic class Solution {\n    public int findKthSmallest(int[][] mat, int k) {\n        // Your code here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] matrix1 = {{4,6},{8,3}};\n        System.out.println(\"Test case 1: \" + solution.findKthSmallest(matrix1, 5));\n        \n        int[][] matrix2 = {{1,5,9},{20,30,40},{7,8,9}};\n        System.out.println(\"Test case 2: \" + solution.findKthSmallest(matrix2, 6));\n        \n        int[][] matrix3 = {{10}};\n        System.out.println(\"Test case 3: \" + solution.findKthSmallest(matrix3, 1));\n    }\n}",
  "1440": "```\npublic class Main {\n    public static void main(String[] args) {\n        boolean[] inputs = {true, false, true};\n        String[] operators = {\"or\", \"and\", \"or\"};\n        boolean[] expecteds = {true, false, true};\n\n        for (int i = 0; i < inputs.length; i++) {\n            System.out.println(\"Test Case: Input - \" + inputs[i] + \", Operator - \" + operators[i] + \", Expected - \" + expecteds[i]);\n            System.out.println(\"Result: \" + evaluateBooleanExpression(inputs[i], operators[i]) + \"\\n\");\n        }\n    }\n\n    public static boolean evaluateBooleanExpression(boolean a, String operator) {\n        if (operator.equals(\"or\")) {\n            return a;\n        } else if (operator.equals(\"and\")) {\n            return a && true;\n        } else {\n            return false;\n        }\n    }\n}",
  "1441": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] targetArray = {{1,2},{3},{}};\n        System.out.println(Arrays.deepToString(buildArray(new int[]{5},targetArray)));\n        \n        int[][] targetArray2 = {{}};\n        System.out.println(Arrays.deepToString(buildArray(new int[]{0,1},targetArray2)));\n        \n        int[][] targetArray3 = {};\n        System.out.println(Arrays.deepToString(buildArray(new int[]{0},targetArray3)));\n    }\n\n    public static int[][] buildArray(int[] pushes, int[][] maxMoves) {\n        List<int[]> result = new ArrayList<>();\n        for (int move : maxMoves[0]) {\n            if (move == 1) {\n                result.add(new int[pushes.length]);\n            } else {\n                if (!result.isEmpty()) {\n                    result.remove(result.size() - 1);\n                }\n            }\n        }\n        \n        List<Integer> pushesList = new ArrayList<>();\n        for (int push : pushes) {\n            if (push == 0) {\n                pushesList.add(0);\n            } else {\n                pushesList.add(push);\n            }\n        }\n        \n        int index = 0;\n        for (int push : pushesList) {\n            result.get(index++).length = Math.max(result.get(index - 1).length, push);\n            for (int i = 0; i < push; i++) {\n                if (i >= result.get(index - 1).length) {\n                    result.add(new int[pushes.length]);\n                }\n                result.get(index).length++;\n            }\n        }\n        \n        return result.toArray(new int[][]{});\n    }\n}\n```",
  "1442": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countTriplets(new int[]{2,1,3}, 5)); // Expected: 4\n        System.out.println(countTriplets(new int[]{4,2,2,1,2}, 6)); // Expected: 8\n        System.out.println(countTriplets(new int[]{0,0,0,0}, 1)); // Expected: 10\n    }\n\n    public static int countTriplets(int[] arr, int r) {\n        int n = arr.length;\n        int[] prefixXOR = new int[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixXOR[i + 1] = prefixXOR[i] ^ arr[i];\n        }\n\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if ((prefixXOR[j + 1] - prefixXOR[i]) % r == 0) {\n                    count += j - i + 1;\n                }\n            }\n        }\n\n        return count;\n    }\n}",
  "1443": "```\nclass Solution {\n    public int minTime(int n, int[] edges, List<List<int>> time) {\n        // Create an adjacency list representation of the tree\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (List<Integer> edge : edges) {\n            int u = edge.get(0);\n            int v = edge.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n\n        // Initialize the result and visited set\n        int res = 0;\n        boolean[] visited = new boolean[n];\n\n        // Depth-first search from each node\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                res = Math.max(res, dfs(graph, time, i, visited));\n            }\n        }\n\n        return res;\n    }\n\n    private int dfs(List<List<Integer>> graph, List<List<int>> time, int node, boolean[] visited) {\n        visited[node] = true;\n\n        int maxTime = 0;\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                maxTime = Math.max(maxTime, time.get(neighbor).get(1) + dfs(graph, time, neighbor, visited));\n            }\n        }\n\n        return maxTime;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<List<int>> time = new ArrayList<>();\n        time.add(Arrays.asList(1, 2));\n        time.add(Arrays.asList(3, 8));\n        time.add(Arrays.asList(4, 2));\n\n        System.out.println(solution.minTime(5, Arrays.asList(Arrays.asList(0, 1), Arrays.asList(1, 2), Arrays.asList(2, 3)), time)); // Output: 16\n        System.out.println(solution.minTime(2, Arrays.asList(Arrays.asList(0, 1)), new ArrayList<>()));\n        System.out.println(solution.minTime(4, Arrays.asList(Arrays.asList(0, 1), Arrays.asList(1, 2], Arrays.asList[2, 3]), time));\n    }\n}",
  "1444": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfWays(new int[]{1,2}, 4));\n        System.out.println(numberOfWays(new int[]{8,9,10}, 5));\n        System.out.println(numberOfWays(new int[]{1,3,5}, 6));\n    }\n\n    public static int numberOfWays(int[] slices, int n) {\n        int[][] dp = new int[n + 1][];\n        for (int i = 0; i <= n; i++) {\n            dp[i] = new int[slices.length + 1];\n        }\n        \n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = 1;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= slices.length; j++) {\n                if (j < slices.length) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        int totalWays = 0;\n        for (int i = slices.length; i > 0 && i <= n; i--) {\n            if (slices[i - 1] == 1) {\n                totalWays += dp[n][i];\n            } else {\n                totalWays += (dp[n][i] + dp[n][i - 1]);\n            }\n        }\n\n        return totalWays;\n    }\n}",
  "1446": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(consecutiveCharacters(\"aaaa\")); // true\n        System.out.println(consecutiveCharacters(\"abc\"));// false\n        System.out.println(consecutiveCharacters(\"azbazb\")); // false\n    }\n\n    public static boolean consecutiveCharacters(String str) {\n        for (int i = 1; i < str.length(); i++) {\n            if (str.charAt(i) != str.charAt(i - 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1445": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1:\");\n        int[] quantities = {1, 2};\n        String[] fruits = {\"Apple\", \"Orange\"};\n        printFruitQuantities(quantities, fruits);\n        System.out.println();\n\n        System.out.println(\"Test Case 2:\");\n        int[] quantities2 = {3, 0};\n        String[] fruits2 = {\"Banana\", \"Apple\"};\n        printFruitQuantities(quantities2, fruits2);\n        System.out.println();\n\n        System.out.println(\"Test Case 3:\");\n        int[] quantities3 = {5, 4};\n        String[] fruits3 = {\"Orange\", \"Apple\", \"Grapes\"};\n        printFruitQuantities(quantities3, fruits3);\n    }\n\n    public static void printFruitQuantities(int[] quantities, String[] fruits) {\n        for (int i = 0; i < quantities.length; i++) {\n            System.out.println(fruits[i] + \": \" + quantities[i]);\n        }\n    }\n}\n```",
  "1447": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numUniqueEBelongingToRange(2, 6));\n        System.out.println(numUniqueEBelongingToRange(7, 11));\n        System.out.println(numUniqueEBelongingToRange(1, 8));\n    }\n\n    public static int numUniqueEBelongingToRange(int left, int right) {\n        // Your code here\n        return 0;\n    }\n}\n```",
  "1448": "```\nclass Solution {\n    public int goodNodes(TreeNode root) {\n        return dfs(root, Integer.MIN_VALUE);\n    }\n\n    private int dfs(TreeNode node, int maxVal) {\n        if (node == null) return 0;\n        int sum = 1; // 1 for the current node\n        if (node.val >= maxVal) {\n            sum += dfs(node.right, node.val);\n            sum += dfs(node.left, node.val);\n        } else {\n            sum += dfs(node.right, maxVal);\n            sum += dfs(node.left, maxVal);\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1:\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(4);\n        root1.left.left = new TreeNode(3);\n        root1.right.left = new TreeNode(5);\n        System.out.println(\"Test Case 1: \" + solution.goodNodes(root1)); // Expected output: 8\n\n        // Test Case 2:\n        TreeNode root2 = new TreeNode(6);\n        root2.left = new TreeNode(4);\n        root2.left.left = new TreeNode(3);\n        root2.left.right = new TreeNode(5);\n        System.out.println(\"Test Case 2: \" + solution.goodNodes(root2)); // Expected output: 6\n\n        // Test Case 3:\n        TreeNode root3 = new TreeNode(1);\n        root3.right = new TreeNode(1);\n        System.out.println(\"Test Case 3: \" + solution.goodNodes(root3)); // Expected output: 2\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1449": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] input1 = {10};\n        System.out.println(formLargestNum(input1, 2)); // Expected output: \"19\"\n\n        int[] input2 = {10};\n        System.out.println(formLargestNum(input1, 3)); // Expected output: \"1029\"\n\n        int[] input3 = {3,5,4,6,5,6,10};\n        System.out.println(formLargestNum(input3, 14)); // Expected output: \"9534330\"\n    }\n\n    public static String formLargestNum(int[] digits, int target) {\n        Arrays.sort(digits);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < digits.length; i++) {\n            while (target > 0 && digits[i] > 0) {\n                if (digits[i] + digits[digits.length - 1 - i] <= target) {\n                    sb.append(digits[i]);\n                    target -= digits[i];\n                    break;\n                } else {\n                    digits[i]--;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}",
  "1451": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(rearrangeWords(\"Codeforces is the best online judge. Codeforces is good.\")));\n        System.out.println(Arrays.toString(rearrangeWords(\"Let's be friends.\")));\n        System.out.println(Arrays.toString(rearrangeWords(\"Hello world.\")));\n    }\n\n    public static String[] rearrangeWords(String sentence) {\n        String[] words = sentence.split(\" \");\n        Arrays.sort(words);\n        return words;\n    }\n}",
  "1450": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] startTimes = {{1,2},{5,6},{8,9}};\n        int[][] finishTimes = {{2,3},{6,7},{9,10}};\n        System.out.println(numberOfStudentsDoingHomeworkAtAGivenTime(startTimes, finishTimes, 2));\n        \n        startTimes = new int[][]{{1,2},{3,5},{8,9}};\n        finishTimes = new int[][]{{2,4},{5,6},{8,10}};\n        System.out.println(numberOfStudentsDoingHomeworkAtAGivenTime(startTimes, finishTimes, 3));\n\n        startTimes = new int[][]{{1,3},{5,6},{7,8},{9,12}};\n        finishTimes = new int[][]{{2,4},{6,7},{8,10},{11,14}};\n        System.out.println(numberOfStudentsDoingHomeworkAtAGivenTime(startTimes, finishTimes, 4));\n    }\n\n    public static int numberOfStudentsDoingHomeworkAtAGivenTime(int[][] startTimes, int[][] finishTimes, int time) {\n        int count = 0;\n        for (int i = 0; i < startTimes.length; i++) {\n            if ((startTimes[i][0] <= time && finishTimes[i][0] > time) || \n                (finishTimes[i][1] >= time)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "1452": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] favorite = {{\"leetcode\", \"winning\"}, {\"leetcode\", \"google\", \"facebook\"}, {\"google\", \"microsoft\", \"facebook\"}};\n        System.out.println(Arrays.deepToString(notSubsets(favorite)));\n    }\n\n    public static boolean[][] notSubsets(int[][] people) {\n        List<Boolean[]> res = new ArrayList<>();\n        for (int i = 0; i < people.length; i++) {\n            boolean flag = true;\n            for (int j = 0; j < people.length; j++) {\n                if (i != j && Arrays.equals(people[i], people[j])) {\n                    flag = false;\n                    break;\n                }\n            }\n            res.add(new Boolean[]{flag, people[i]});\n        }\n        return res.stream().map(e -> e).toArray(Boolean[][]::new);\n    }\n}",
  "1453": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxDarts(new int[][]{{10,20},{30,40}}));\n        System.out.println(maxDarts(new int[][]{{1,2},{8,9},{4,7},{3,5}}));\n        System.out.println(maxDarts(new int[][]{{0,100},{50,50},{25,75},{30,40}}));\n    }\n\n    public static int maxDarts(int[][] points) {\n        int res = 0;\n        for (int i = 0; i < points.length; i++) {\n            for (int j = 0; j < points[0].length; j++) {\n                if ((points[i][j] <= 100 && points[i][j] >= 0) || (i == 1 && j > 49)) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}",
  "1454": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = {{\"David\", \"9:00\"}, {\"David\", \"9:45\"}, {\"David\", \"10:30\"}, {\"Eva\", \"12:00\"}, {\"Eva\", \"12:20\"}};\n        System.out.println(minInterval(logs, 5));\n\n        logs = new int[][]{{\"David\", \"9:00\"}, {\"Nancy\", \"6:10\"}, {\"Eva\", \"6:00\"}};\n        System.out.println(minInterval(logs, 3));\n\n        logs = new int[][]{};\n        System.out.println(minInterval(logs, 2));\n    }\n\n    public static int minInterval(int[][] logs, int n) {\n        if (logs.length < n) return -1;\n        Map<String, Integer> map = new HashMap<>();\n        for (int[] log : logs) {\n            String user = log[0];\n            int time = Integer.parseInt(log[1].substring(0, log[1].indexOf(\":\")));\n            map.put(user, Math.max(map.getOrDefault(user, 0), time));\n        }\n        List<String> users = new ArrayList<>(map.keySet());\n        Collections.sort(users);\n        for (int i = 0; i < users.size() - n + 1; i++) {\n            String user1 = users.get(i);\n            String user2 = users.get(Math.min(i + n - 1, users.size() - 1));\n            int time1 = map.get(user1);\n            int time2 = map.get(user2);\n            if (time2 - time1 >= 60) return time2 - time1;\n        }\n        return -1;\n    }\n}",
  "1455": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isPrefixOf(\"hello world\", \"world\")); // true\n        System.out.println(isPrefixOf(\"hello world\", \"abc\")); // false\n        System.out.println(isPrefixOf(\"hello world hello\", \"hello\")); // true\n    }\n\n    public static boolean isPrefixOf(String sentence, String word) {\n        int[] last = new int[1];\n        for (String w : sentence.split(\" \")) {\n            if (w.startsWith(word)) {\n                return true;\n            }\n            last[0] = Math.max(last[0], w.length());\n        }\n        return false;\n    }\n}\n```",
  "1456": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxVowels(\"hello\", 2) == 2);\n        System.out.println(maxVowels(\"leetchi\", 1) == 0);\n        System.out.println(maxVowels(\"leetchiwi\", 4) == 3);\n    }\n\n    public static int maxVowels(String word, int k) {\n        if (word.length() < k) return 0;\n        int vowels = 0;\n        for (int i = 0; i < k; i++) {\n            if (\"aeiouAEIOU\".indexOf(word.charAt(i)) != -1) vowels++;\n        }\n        int maxVowels = vowels;\n        for (int i = k; i < word.length(); i++) {\n            if (\"aeiouAEIOU\".indexOf(word.charAt(i - k)) == -1) vowels--;\n            if (\"aeiouAEIOU\".indexOf(word.charAt(i)) != -1) vowels++;\n            maxVowels = Math.max(maxVowels, vowels);\n        }\n        return maxVowels;\n    }\n}",
  "1457": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(2);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(3);\n\n        System.out.println(pseudoPalindromicPaths(root1)); // Expected output: 3\n\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(4);\n        root2.right = new TreeNode(6);\n\n        System.out.println(pseudoPalindromicPaths(root2)); // Expected output: 1\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(0);\n        root3.right = new TreeNode(1);\n\n        System.out.println(pseudoPalindromicPaths(root3)); // Expected output: 2\n    }\n\n    public static int pseudoPalindromicPaths(TreeNode root) {\n        return dfs(root, \"\", 0);\n    }\n\n    public static int dfs(TreeNode node, String path, int oddCount) {\n        if (node == null) {\n            return 0;\n        }\n        int count = dfs(node.left, path + (node.val == '1' ? \"1\" : \"0\"), oddCount + (node.val == '1' ? 1 : -1));\n        count += dfs(node.right, path + (node.val == '1' ? \"1\" : \"0\"), oddCount);\n        if (node.left == null && node.right == null) {\n            int palindromicPaths = 1;\n            for (int i = 0; i < path.length(); i++) {\n                if ((path.charAt(i) - '0') % 2 != 0) {\n                    palindromicPaths = 0;\n                    break;\n                }\n            }\n            return count + palindromicPaths;\n        } else {\n            return count;\n        }\n    }\n\n    static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n        TreeNode(int x) { val = x; }\n    }\n}",
  "1458": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] v1 = {{1,5},{10,50,5}};\n        int[] v2 = {5,50};\n        System.out.println(maxDotProduct(v1, v2));\n\n        int[][] v3 = {{1,2},{3,4,5}};\n        int[] v4 = {5,6};\n        System.out.println(maxDotProduct(v3, v4));\n\n        int[][] v5 = {{-1,-10,-4,-13}};\n        int[] v6 = {-1,5};\n        System.out.println(maxDotProduct(v5, v6));\n    }\n\n    public static int maxDotProduct(int[][] nums1, int[] nums2) {\n        int n = nums1[0].length;\n        int m = nums2.length;\n\n        // dp[i][j] represents the maximum dot product of two subsequences\n        // where the i-th element from nums1 and the j-th element from nums2 are used\n        int[][] dp = new int[n+1][m+1];\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= m; j++) {\n                if (i == 1) {\n                    dp[i][j] = nums2[j-1] * nums1[0][i-1];\n                } else if (j == 1) {\n                    dp[i][j] = nums1[0][i-1] * nums2[j-1];\n                } else {\n                    dp[i][j] = Math.max(dp[i-1][j-1] + nums2[j-1] * nums1[0][i-1],\n                                        Math.max(dp[i-1][j], dp[i][j-1]));\n                }\n            }\n        }\n\n        return dp[n][m];\n    }\n}\n```",
  "1459": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(area(4, 2)); // Expected: 8\n        System.out.println(area(1, 5)); // Expected: 5\n        System.out.println(area(3, 6)); // Expected: 18\n    }\n\n    public static int area(int length, int width) {\n        return length * width;\n    }\n}",
  "1460": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canMakeEqual(new int[]{1,2,3,4}, new int[]{1,3,2,4}) ? \"Yes\" : \"No\");\n        System.out.println(canMakeEqual(new int[]{5,6,7,8}, new int[]{8,7,6,5}) ? \"Yes\" : \"No\");\n        System.out.println(canMakeEqual(new int[]{1,2,3}, new int[]{1,2,3}) ? \"Yes\" : \"No\");\n    }\n\n    public static boolean canMakeEqual(int[] target, int[] arr) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < arr.length; i++) {\n            map.put(arr[i], i);\n        }\n        \n        for (int i = 0; i < target.length; i++) {\n            if (!map.containsKey(target[i])) return false;\n            int j = map.get(target[i]);\n            while (i > j) {\n                if (!Arrays.equals(Arrays.copyOfRange(arr, 0, j+1), Arrays.copyOfRange(arr, i, arr.length))) return false;\n                i--;\n            }\n        }\n        \n        return true;\n    }\n}",
  "1461": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(checkIfContainAllBinaryCodes(\"00101\", 2)); // True\n        System.out.println(checkIfContainAllBinaryCodes(\"10123\", 2)); // False\n        System.out.println(checkIfContainAllBinaryCodes(\"011110\", 3)); // True\n    }\n\n    public static boolean checkIfContainAllBinaryCodes(String s, int k) {\n        int n = s.length();\n        for (int i = 0; i <= n - k; i++) {\n            String binaryCode = s.substring(i, i + k);\n            if (!s.contains(binaryCode)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1463": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] positions = {{0, 1}, {2, 3, 4}};\n        System.out.println(cherryPickup(positions));\n        \n        positions = new int[][]{{1, 1, 2, 5}, {2, 3, 4, 7}};\n        System.out.println(cherryPickup(positions));\n        \n        positions = new int[][]{{0, 0, 0}, {1, 1, 1, 1}};\n        System.out.println(cherryPickup(positions));\n    }\n\n    public static int cherryPickup(int[][] positions) {\n        // Your code here\n        return 0; \n    }\n}\n```",
  "1462": "```\nimport java.util.*;\n\nclass Solution {\n    public List<String> findOrder(String[] courses) {\n        Map<String, List<String>> graph = new HashMap<>();\n        Map<String, Integer> inDegree = new HashMap<>();\n\n        for (String course : courses) {\n            String[] pair = course.split(\" \");\n            String preCourse = pair[0];\n            String currentCourse = pair[1];\n\n            if (!graph.containsKey(preCourse)) {\n                graph.put(preCourse, new ArrayList<>());\n                inDegree.put(preCourse, 0);\n            }\n            if (!inDegree.containsKey(currentCourse)) {\n                inDegree.put(currentCourse, 0);\n            }\n\n            graph.get(preCourse).add(currentCourse);\n            inDegree.put(currentCourse, inDegree.getOrDefault(currentCourse, 0) + 1);\n        }\n\n        List<String> order = new ArrayList<>();\n\n        Queue<String> queue = new LinkedList<>();\n        for (String course : courses) {\n            String[] pair = course.split(\" \");\n            if (!inDegree.containsKey(pair[0])) {\n                continue;\n            }\n            if (inDegree.get(pair[0]) == 0) {\n                queue.add(pair[0]);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            String course = queue.poll();\n            order.add(course);\n\n            for (String nextCourse : graph.getOrDefault(course, new ArrayList<>())) {\n                inDegree.put(nextCourse, inDegree.get(nextCourse) - 1);\n                if (inDegree.get(nextCourse) == 0) {\n                    queue.add(nextCourse);\n                }\n            }\n        }\n\n        List<String> invalidCourses = new ArrayList<>();\n        for (String course : courses) {\n            String[] pair = course.split(\" \");\n            if (!order.contains(pair[0])) {\n                invalidCourses.add(course);\n            }\n        }\n\n        return invalidCourses.isEmpty() ? order : null;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.findOrder(new String[]{\"1 3\", \"2 4\"}));\n        System.out.println(solution.findOrder(new String[]{\"1 2\", \"2 3\"}));\n        System.out.println(solution.findOrder(new String[]{\"1 0\", \"0 2\"}));\n    }\n}",
  "1464": "```\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {{1,2,3,4},{5,6},{0}};\n        for (int[] input : inputs) {\n            System.out.println(\"Input: \" + Arrays.toString(input));\n            System.out.println(\"Max Product: \" + maxProduct(input));\n            System.out.println();\n        }\n    }\n\n    public static int maxProduct(int[] nums) {\n        Arrays.sort(nums);\n        return Math.max(nums[nums.length - 1] * nums[nums.length - 2], nums[0] * nums[1]);\n    }\n}",
  "1465": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxArea(new int[]{1,2}, 4)) + \"\\n\";\n        System.out.println(maxArea(new int[]{5,4,6,7,8}, 10)) + \"\\n\";\n        System.out.println(maxArea(new int[]{18,10,9,8,7,6,5,4,3,2,1}, 100));\n    }\n\n    public static int maxArea(int[] h, int w) {\n        Arrays.sort(h);\n        Arrays.sort(w);\n        \n        int max = 0;\n        for (int i = 0; i < h.length - 1; i++) {\n            for (int j = 0; j < w.length - 1; j++) {\n                max = Math.max(max, (h[i] + h[i+1]) * (w[j] + w[j+1]));\n            }\n        }\n        \n        return max;\n    }\n}\n```",
  "1466": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] orders = {{0,1},{0,2},{0,3},{2,1},{3,2}};\n        int n = 5;\n        reorderStopTimes(orders, n);\n        \n        orders = new int[][]{{0,1},{1,2},{2,0}};\n        n = 4;\n        reorderStopTimes(orders, n);\n\n        orders = new int[][]{{3,0},{4,2},{1,-1},{0,4}};\n        n = 5;\n        reorderStopTimes(orders, n);\n    }\n\n    public static void reorderStopTimes(int[][] orders, int n) {\n        List<Integer>[] graph = (List<Integer>[])new List[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int[] order : orders) {\n            graph[order[1]].add(order[0]);\n        }\n\n        boolean[] visited = new boolean[n];\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(graph, visited, i);\n            }\n        }\n        \n        for (int i = 0; i < orders.length; i++) {\n            int u = orders[i][1];\n            int v = orders[i][0];\n            while (graph[u].size() > 0) {\n                int next = graph[u].get(0);\n                if (next == v) {\n                    graph[u].remove(0);\n                    break;\n                }\n                u = next;\n            }\n        }\n\n        for (int[] order : orders) {\n            System.out.println(order[1] + \"->\" + order[0]);\n        }\n    }\n\n    private static void dfs(List<Integer>[] graph, boolean[] visited, int i) {\n        visited[i] = true;\n        for (int neighbor : graph[i]) {\n            if (!visited[neighbor]) {\n                dfs(graph, visited, neighbor);\n            }\n        }\n    }\n}\n```",
  "1467": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canChoose(2, new int[]{1, 2, 2, 3}, 0)); // true\n        System.out.println(canChoose(3, new int[]{1, 2, 2, 3}, 0)); // false\n        System.out.println(canChoose(3, new int[]{1, 1, 2, 2}, 0)); // true\n    }\n\n    public static boolean canChoose(int n, int[] boxes, int target) {\n        int[] res = new int[n + 1];\n        for (int i : boxes) {\n            if (i > n) continue;\n            for (int j = n; j >= i; j--) {\n                res[j] += 1;\n            }\n        }\n        int maxCount = -1;\n        for (int i = target; i <= n; i++) {\n            if ((res[i] + Math.min(i, boxes.length - (n - i)) * target) % target == 0 && res[i] > maxCount) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
  "1468": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(calculateSalaries(new String[][]{{\"John\", \"Manager\", \"20000\"}, {\"Jane\", \"Salesperson\", \"15000\"}, {\"Alice\", \"Engineer\", \"25000\"}}));\n        System.out.println(calculateSalaries(new String[][]{{\"David\", \"Manager\", \"30000\"}, {\"Emily\", \"Salesperson\", \"20000\"}, {\"Ben\", \"Engineer\", \"35000\"}}));\n        System.out.println(calculateSalaries(new String[][]{{\"Tom\", \"Salesperson\", \"10000\"}, {\"Lily\", \"Engineer\", \"22000\"}, {\"Hannah\", \"Manager\", \"26000\"}}));\n    }\n\n    public static int calculateSalaries(String[][] salaries) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String[] salary : salaries) {\n            if (!map.containsKey(salary[1])) {\n                map.put(salary[1], 0);\n            }\n            map.put(salary[1], map.getOrDefault(salary[1], 0) + Integer.parseInt(salary[2]));\n        }\n        int total = 0;\n        for (int value : map.values()) {\n            total += value;\n        }\n        return total;\n    }\n}",
  "1469": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(6);\n\n        findLonelyNodes(root1);\n\n        System.out.println();\n\n        TreeNode root2 = new TreeNode(2);\n        root2.left = new TreeNode(1);\n        root2.right = new TreeNode(3);\n        root2.right.right = new TreeNode(4);\n\n        findLonelyNodes(root2);\n\n        System.out.println();\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n        root3.right = new TreeNode(4);\n        root3.left.left = new TreeNode(5);\n\n        findLonelyNodes(root3);\n    }\n\n    public static void findLonelyNodes(TreeNode root) {\n        if (root == null) return;\n\n        int[] result = new int[0];\n        findLonelyNodesHelper(root, result);\n\n        System.out.println(\"Lonely nodes in the tree are: \" + Arrays.toString(result));\n    }\n\n    private static void findLonelyNodesHelper(TreeNode node, int[] result) {\n        if (node == null) return;\n\n        if (node.left == null && node.right == null) {\n            boolean isLonely = true;\n            for (int i : result) {\n                if (Math.abs(i - node.val) <= 1) {\n                    isLonely = false;\n                    break;\n                }\n            }\n\n            if (isLonely) {\n                int[] newArray = new int[result.length + 1];\n                System.arraycopy(result, 0, newArray, 0, result.length);\n                newArray[result.length] = node.val;\n                result = newArray;\n            }\n        } else {\n            findLonelyNodesHelper(node.left, result);\n            findLonelyNodesHelper(node.right, result);\n        }\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "1470": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {{1,2}, [0,1]},\n            {{1,3,4},{0,1,2}},\n            {{1},{1}}\n        };\n        \n        for (int i = 0; i < arrays.length; i++) {\n            shuffle(arrayOfArrays(arrayOfArrays(arrayOfArrays), i));\n            System.out.println(Arrays.toString(arrayOfArrays));\n        }\n    }\n\n    public static void shuffle(int[][] array) {\n        Random rand = new Random();\n        int n = array.length;\n        for (int i = 0; i < n; i++) {\n            int j = rand.nextInt(n);\n            int[] temp = array[i];\n            array[i] = array[j];\n            array[j] = temp;\n        }\n    }\n\n    public static int[][] arrayOfArrays(int n) {\n        int[][] array = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                array[i][j] = i * n + j;\n            }\n        }\n        return array;\n    }\n}\n```",
  "1471": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {{1,2},{4,3},{23,24},{27,25,1}},\n            {{5,8,9},{1,6,11},{103,214},{10,15,3}},\n            {{0,0},{100000,99999}}\n        };\n        for (int[] array : arrays) {\n            int k = 3;\n            int[][] result = kStrongest(array, k);\n            for (int i = 0; i < result.length; i++) {\n                System.out.println(\"Array \" + (i+1));\n                for (int j = 0; j < result[i].length; j++) {\n                    System.out.print(result[i][j] + \" \");\n                }\n                System.out.println();\n            }\n        }\n    }\n\n    public static int[][] kStrongest(int[][] arr, int k) {\n        List<int[]> list = new ArrayList<>();\n        for (int[] pair : arr) {\n            list.add(new int[]{pair[1], pair[0]});\n        }\n        Collections.sort(list);\n        int[][] res = new int[k][2];\n        for (int i = 0; i < k; i++) {\n            res[i] = list.get(list.size() - i - 1);\n        }\n        return res;\n    }\n}\n```",
  "1472": "```\npublic class Main {\n    public static void main(String[] args) {\n        BrowserHistory bh = new BrowserHistory(1);\n        bh.visit(\"leetcode.com\");\n        System.out.println(bh.back()); // returns \"leetcode.com\"\n        bh.forward(); // returns \"\"\n        bh.visit(\"google.com\"); \n        System.out.println(bh.forward()); // returns \"leetcode.com\"\n        System.out.println(bh.visiting());\n        bh.backward();\n        System.out.println(bh.visiting());  // returns \"google.com\"\n    }\n}\n```",
  "1473": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] result1 = new PaintHouseIII().houseCosts(new int[][]{{1, 3}, {2, 5}, {8, 9}}).toArray(int[][]::new);\n        for (int i = 0; i < result1.length; i++) {\n            System.out.println(Arrays.toString(result1[i]));\n        }\n\n        int[][] result2 = new PaintHouseIII().houseCosts(new int[][]{{10, 15}, {20, 25}, {30, 35}, {40, 45}}).toArray(int[][]::new);\n        for (int i = 0; i < result2.length; i++) {\n            System.out.println(Arrays.toString(result2[i]));\n        }\n\n        int[][] result3 = new PaintHouseIII().houseCosts(new int[][]{{1, 10}, {2, 9}, {4, 8}}).toArray(int[][]::new);\n        for (int i = 0; i < result3.length; i++) {\n            System.out.println(Arrays.toString(result3[i]));\n        }\n    }\n}\n\nclass PaintHouseIII {\n    public int[] houseCosts(int[][] costs) {\n        if (costs == null || costs.length == 0) {\n            return new int[0];\n        }\n\n        int n = costs.length;\n        int[] res = new int[n];\n\n        for (int i = 1; i < n; i++) {\n            res[i] = Math.max(res[i - 1], costs[i][0]);\n            for (int j = 1; j < costs[i].length; j++) {\n                res[i] = Math.max(res[i], Math.max(res[i - 1], costs[i][j]) + costs[i][0]);\n            }\n        }\n\n        return res;\n    }\n}\n```",
  "1474": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(4);\n        head.next.next.next.next = new ListNode(5);\n\n        deleteAfterMNodes(head, 2, 1);\n\n        System.out.println(\"Case 1:\");\n        printList(head);\n\n        head = new ListNode(0);\n        head.next = new ListNode(1);\n        head.next.next = new ListNode(2);\n        head.next.next.next = new ListNode(3);\n        head.next.next.next.next = new ListNode(4);\n        head.next.next.next.next.next = new ListNode(5);\n\n        deleteAfterMNodes(head, 0, 2);\n        System.out.println(\"Case 2:\");\n        printList(head);\n\n        head = null;\n        deleteAfterMNodes(head, 1, 2);\n        System.out.println(\"Case 3:\");\n        printList(head);\n    }\n\n    public static void deleteAfterMNodes(ListNode head, int m, int n) {\n        if (head == null || m > n) {\n            return;\n        }\n\n        for (int i = 0; i < m - 1; i++) {\n            if (head.next == null) {\n                return;\n            }\n            head = head.next;\n        }\n\n        while (n-- > 0 && head.next != null) {\n            head = head.next;\n        }\n\n        if (head == null || head.next == null) {\n            return;\n        }\n\n        head.next = head.next.next;\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) { val = x; }\n}\n```",
  "1475": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] prices1 = {10, 5, 3, 3};\n        System.out.println(Arrays.toString(betterPrices(prices1))); // [10, 9, 8, 8]\n\n        int[] prices2 = {1, 2, 3, 4, 5};\n        System.out.println(Arrays.toString(betterPrices(prices2))); // [5, 4, 3, 2, 1]\n\n        int[] prices3 = [8, 10];\n        System.out.println(Arrays.toString(betterPrices(prices3))); // [8, 9]\n    }\n\n    public static int[] betterPrices(int[] prices) {\n        Stack<Integer> stack = new Stack<>();\n        int[] result = new int[prices.length];\n\n        for (int i = 0; i < prices.length; i++) {\n            while (!stack.isEmpty() && prices[i] <= prices[stack.peek()]) {\n                int prevPriceIndex = stack.pop();\n                result[prevPriceIndex] = prices[prevPriceIndex] - (prices[i] - prices[i]);\n            }\n            stack.push(i);\n        }\n\n        while (!stack.isEmpty()) {\n            int lastPriceIndex = stack.pop();\n            result[lastPriceIndex] -= prices[lastPriceIndex];\n        }\n\n        return result;\n    }\n}",
  "1476": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix = {{1,3,5},{2,6,9},{10,11,12}};\n        SubrectangleQueries queries = new SubrectangleQueries(matrix);\n        \n        System.out.println(queries.sumRegion(0, 1, 1, 1)); // Output: 9\n        System.out.println(queries.updateSubrectangle(0, 0, 3, 2, 5));\n        System.out.println(queries.sumRegion(3, 1, 1, 2)); // Output: 8\n    }\n}\n\nclass SubrectangleQueries {\n    int[][] matrix;\n    \n    public SubrectangleQueries(int[][] matrix) {\n        this.matrix = matrix;\n    }\n\n    public int sumRegion(int row1, int col1, int row2, int col2) {\n        int sum = 0;\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                sum += matrix[i][j];\n            }\n        }\n        return sum;\n    }\n\n    public void updateSubrectangle(int row1, int row2, int col1, int col2, int val) {\n        for (int i = row1; i <= row2; i++) {\n            for (int j = col1; j <= col2; j++) {\n                matrix[i][j] = val;\n            }\n        }\n    }\n}",
  "1477": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = { {1, 2, 3, 2, 5}, {3, 2, 1, 7, 8}, {0, 0, 10, 12} };\n        for (int i = 0; i < arrays.length; i++) {\n            findTwoNonOverlappingSubArrays(arrays[i]);\n        }\n    }\n\n    public static void findTwoNonOverlappingSubArrays(int[] array) {\n        int n = array.length;\n        Map<Integer, Integer> prefixSumMap = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int currentSum = 0;\n            for (int j = 0; j <= i; j++) {\n                currentSum += array[j];\n                if (!prefixSumMap.containsKey(currentSum)) {\n                    prefixSumMap.put(currentSum, j);\n                }\n            }\n        }\n\n        for (int targetSum = -10000; targetSum < 10001; targetSum++) {\n            int firstIndex = findSubArray(array, prefixSumMap, targetSum);\n            if (firstIndex != -1) {\n                int secondIndex = findSecondNonOverlappingSubArray(array, prefixSumMap, targetSum, firstIndex);\n                if (secondIndex != -1) {\n                    System.out.println(\"Target sum: \" + targetSum + \", First sub-array: [\" +\n                            Arrays.toString(Arrays.copyOfRange(array, 0, firstIndex)) + \"], Second sub-array: [\" +\n                            Arrays.toString(Arrays.copyOfRange(array, firstIndex, secondIndex + 1)) + \"]\");\n                }\n            }\n        }\n    }\n\n    public static int findSubArray(int[] array, Map<Integer, Integer> prefixSumMap, int targetSum) {\n        int n = array.length;\n        for (int i = 0; i < n; i++) {\n            int currentSum = 0;\n            for (int j = i; j >= 0; j--) {\n                currentSum += array[j];\n                if (currentSum == targetSum) {\n                    return j;\n                } else if (!prefixSumMap.containsKey(currentSum - targetSum)) {\n                    break;\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static int findSecondNonOverlappingSubArray(int[] array, Map<Integer, Integer> prefixSumMap, int targetSum, int firstIndex) {\n        int n = array.length;\n        for (int i = firstIndex; i < n; i++) {\n            int currentSum = 0;\n            for (int j = i; j >= 0; j--) {\n                currentSum += array[j];\n                if (currentSum == targetSum && j != firstIndex) {\n                    return j;\n                } else if (!prefixSumMap.containsKey(currentSum - targetSum)) {\n                    break;\n                }\n            }\n        }\n        return -1;\n    }\n}\n```",
  "1478": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {10, 40, 20, 30};\n        System.out.println(\"Expected: 1\\nActual: \" + allocateMailboxes(arr1));\n        \n        int[] arr2 = {3, 4, 10, 2, 5};\n        System.out.println(\"Expected: 3\\nActual: \" + allocateMailboxes(arr2));\n\n        int[] arr3 = {9, 10, 15, 30, 20};\n        System.out.println(\"Expected: 2\\nActual: \" + allocateMailboxes(arr3));\n    }\n\n    public static int allocateMailboxes(int[] distance) {\n        Arrays.sort(distance);\n        int mailboxes = 1;\n        for (int i = 0; i < distance.length - 1; i++) {\n            if (distance[i] + distance[i + 1] > 2 * distance[distance.length - 1]) {\n                mailboxes++;\n            }\n        }\n        return mailboxes;\n    }\n}\n```",
  "1480": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1,2,3,4};\n        int[] expected1 = {1,3,6,10};\n        System.out.println(\"Test case 1: \" + Arrays.toString(runningSum(nums1)));\n        System.out.println(\"Expected result: \" + Arrays.toString(expected1));\n\n        int[] nums2 = {-1,-2,-3,-4,-5};\n        int[] expected2 = {-1,-3,-6,-10,-15};\n        System.out.println(\"\\nTest case 2: \" + Arrays.toString(runningSum(nums2)));\n        System.out.println(\"Expected result: \" + Arrays.toString(expected2));\n\n        int[] nums3 = [0,1,2,3];\n        int[] expected3 = [0,1,3,6];\n        System.out.println(\"\\nTest case 3: \" + Arrays.toString(runningSum(nums3)));\n        System.out.println(\"Expected result: \" + Arrays.toString(expected3));\n    }\n\n    public static int[] runningSum(int[] nums) {\n        for (int i = 1; i < nums.length; i++) {\n            nums[i] += nums[i - 1];\n        }\n        return nums;\n    }\n}",
  "1479": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] orders = {{9, 2}, {5, 1}, {12, 2}};\n        System.out.println(\"Test Case 1: \" + salesByDayOfTheWeek(orders));\n        \n        orders = new int[][]{{15, 3}, {5, 2}};\n        System.out.println(\"Test Case 2: \" + salesByDayOfTheWeek(orders));\n        \n        orders = new int[][]{};\n        System.out.println(\"Test Case 3: \" + salesByDayOfTheWeek(orders));\n    }\n\n    public static int[] salesByDayOfTheWeek(int[][] orders) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < orders.length; i++) {\n            String day = getDayOfWeek(orders[i][1]);\n            map.put(day, map.getOrDefault(day, 0) + orders[i][0]);\n        }\n        int[] result = new int[7];\n        for (Map.Entry<String, Integer> entry : map.entrySet()) {\n            result[getDayIndex(entry.getKey())] = entry.getValue();\n        }\n        return result;\n    }\n\n    public static String getDayOfWeek(int day) {\n        switch (day) {\n            case 1:\n                return \"Sunday\";\n            case 2:\n                return \"Monday\";\n            case 3:\n                return \"Tuesday\";\n            case 4:\n                return \"Wednesday\";\n            case 5:\n                return \"Thursday\";\n            case 6:\n                return \"Friday\";\n            case 7:\n                return \"Saturday\";\n            default:\n                throw new RuntimeException(\"Invalid day\");\n        }\n    }\n\n    public static int getDayIndex(String day) {\n        switch (day) {\n            case \"Sunday\":\n                return 0;\n            case \"Monday\":\n                return 1;\n            case \"Tuesday\":\n                return 2;\n            case \"Wednesday\":\n                return 3;\n            case \"Thursday\":\n                return 4;\n            case \"Friday\":\n                return 5;\n            case \"Saturday\":\n                return 6;\n            default:\n                throw new RuntimeException(\"Invalid day\");\n        }\n    }\n}\n```",
  "1481": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums1 = {{5,7,3,9,2,5,3,7,9}, 2};\n        System.out.println(\"Expected: 5\\nActual: \" + findLeastNumOfUniqueIntegers(nums1[0], nums1[1]));\n        \n        int[][] nums2 = {{4,3,1,1,3,3}, 3};\n        System.out.println(\"Expected: 3\\nActual: \" + findLeastNumOfUniqueIntegers(nums2[0], nums2[1]));\n        \n        int[][] nums3 = {{10}, 5};\n        System.out.println(\"Expected: 1\\nActual: \" + findLeastNumOfUniqueIntegers(nums3[0], nums3[1]));\n    }\n\n    public static int findLeastNumOfUniqueIntegers(int[] arr, int k) {\n        Map<Integer, Integer> countMap = new HashMap<>();\n        for (int num : arr) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        \n        int res = 0;\n        for (int val : countMap.values()) {\n            if (val <= k) {\n                res += val;\n                k -= val;\n            } else if (k >= val) {\n                res += 1;\n                k -= val;\n            } else {\n                res += k % val;\n                break;\n            }\n        }\n        \n        return res;\n    }\n}\n```",
  "1482": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] flowerbed = {1,0,2,0,1};\n        int m = 1;\n        System.out.println(minDays(flowerbed, m));\n        \n        int[] flowerbed2 = {1,0,0,0,1,1,2,3,2,1};\n        m = 4;\n        System.out.println(minDays(flowerbed2, m));\n        \n        int[] flowerbed3 = {0,0,0,0};\n        m = 3;\n        System.out.println(minDays(flowerbed3, m));\n    }\n\n    public static int minDays(int[] flowerbed, int m) {\n        int n = flowerbed.length;\n        int lo = 1, hi = n - m + 1;\n        \n        while (lo < hi) {\n            int mid = (lo + hi) / 2;\n            if (canMakeBouquets(flowerbed, mid, m)) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        \n        return flowerbed[lo - 1] == 0 ? lo : lo + m - 1;\n    }\n\n    public static boolean canMakeBouquets(int[] flowerbed, int start, int m) {\n        for (int i = start; i < start + m; i++) {\n            if (flowerbed[i] == 1) return false;\n        }\n        for (int i = start - 1; i >= 0; i--) {\n            if (flowerbed[i] == 1) return false;\n        }\n        for (int i = start + m; i < flowerbed.length; i++) {\n            if (flowerbed[i] == 1) return false;\n        }\n        return true;\n    }\n}",
  "1483": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n        root.left.left = new TreeNode(4);\n        root.left.right = new TreeNode(5);\n\n        System.out.println(\"Test Case 1: Kth Ancestor of node with k=2 should be 1\");\n        System.out.println(\"Result: \" + kthAncestor(root, root.left, 2));\n        \n        System.out.println(\"\\nTest Case 2: Kth Ancestor of node with k=3 should be 1\");\n        System.out.println(\"Result: \" + kthAncestor(root, root.left.right, 3));\n\n        System.out.println(\"\\nTest Case 3: Kth Ancestor of node with k=4 should return null since it's more than the height of tree\");\n        System.out.println(\"Result: \" + kthAncestor(root, root.left.right, 4));\n    }\n\n    public static TreeNode kthAncestor(TreeNode root, TreeNode current, int k) {\n        // Your code here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "1484": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1:\n        int[][] orders1 = {{10, \"2020-01-01\"}, {20, \"2020-01-02\"}, {30, \"2020-01-03\"}};\n        int[][] orderItems1 = {{1, 2}, {2, 3}, {3, 4}};\n        System.out.println(\"Test case 1:\");\n        Map<String, List<Integer>> result1 = solution.groupedCount(orders1, orderItems1);\n        for (Map.Entry<String, List<Integer>> entry : result1.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n        \n        // Test case 2:\n        int[][] orders2 = {{5, \"2020-01-01\"}, {20, \"2020-01-02\"}};\n        int[][] orderItems2 = {{1, 2}, {3, 4}};\n        System.out.println(\"Test case 2:\");\n        Map<String, List<Integer>> result2 = solution.groupedCount(orders2, orderItems2);\n        for (Map.Entry<String, List<Integer>> entry : result2.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n        \n        // Test case 3:\n        int[][] orders3 = {{10, \"2020-01-03\"}, {20, \"2020-01-02\"}};\n        int[][] orderItems3 = {};\n        System.out.println(\"Test case 3:\");\n        Map<String, List<Integer>> result3 = solution.groupedCount(orders3, orderItems3);\n        for (Map.Entry<String, List<Integer>> entry : result3.entrySet()) {\n            System.out.println(entry.getKey() + \": \" + entry.getValue());\n        }\n    }\n}\n\nclass Solution {\n    public Map<String, List<Integer>> groupedCount(int[][] orders, int[][] orderItems) {\n        // Your code here\n    }\n}\n```",
  "1486": "```\npublic class Main {\n\n    public static int[] xorOperation(int n, int start) {\n        int[] result = new int[n];\n        for (int i = 0; i < n; i++) {\n            result[i] = (start + 2 * i) ^ i;\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[][] testCases = {{\"1, 5\", \"4, 8, 2, 7, 0\"},\n                             {\"10, 2\"}, {\"3, 11\"}};\n\n        for (String testCase : testCases) {\n            String[] inputs = testCase.split(\",\");\n            int n = Integer.parseInt(inputs[0].trim());\n            int start = Integer.parseInt(inputs[1].trim());\n\n            int[] result = xorOperation(n, start);\n\n            System.out.println(\"Test case: \" + testCase);\n            System.out.println(\"Result: \" + Arrays.toString(result));\n            System.out.println();\n        }\n    }\n}\n```",
  "1485": "```\npublic class Main {\n    public static void main(String[] args) {\n        // Test Case 1\n        Node root1 = new Node(1);\n        root1.left = new Node(2);\n        root1.right = new Node(3);\n        root1.random = null;\n        root1.left.random = new Node(4);\n        root1.right.random = new Node(5);\n\n        Node cloneRoot1 = new Solution().copyRandomList(root1);\n        testClone(cloneRoot1);\n\n        // Test Case 2\n        Node root2 = new Node(1);\n        root2.left = new Node(2);\n        root2.right = new Node(3);\n        root2.random = null;\n        root2.left.random = null;\n        root2.right.random = root2;\n\n        Node cloneRoot2 = new Solution().copyRandomList(root2);\n        testClone(cloneRoot2);\n\n        // Test Case 3\n        Node root3 = new Node(1);\n        root3.left = new Node(2);\n        root3.right = new Node(3);\n        root3.random = root3;\n        root3.left.random = null;\n        root3.right.random = root3;\n\n        Node cloneRoot3 = new Solution().copyRandomList(root3);\n        testClone(cloneRoot3);\n    }\n\n    public static void testClone(Node node) {\n        System.out.println(\"Testing Clone: \" + (node == null ? \"null\" : node.val));\n        if (node != null && node.left != null) {\n            System.out.println(\"Left Child: \" + node.left.val + \", Random: \" + (node.left.random == null ? \"null\" : node.left.random.val));\n        }\n        if (node != null && node.right != null) {\n            System.out.println(\"Right Child: \" + node.right.val + \", Random: \" + (node.right.random == null ? \"null\" : node.right.random.val));\n        }\n    }\n}\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n        \n        Map<Node, Node> map = new HashMap<>();\n        Node dummyHead = new Node(0);\n        Node p = head;\n        while (p != null) {\n            if (!map.containsKey(p)) {\n                Node copy = new Node(p.val);\n                map.put(p, copy);\n                p = p.next;\n            } else {\n                p = p.next;\n            }\n        }\n\n        p = head;\n        while (p != null) {\n            map.get(p).next = p.next;\n            if (p.random != null) {\n                map.get(p).random = map.getOrDefault(p.random, new Node(0));\n            }\n            p = p.next;\n        }\n\n        return dummyHead.next;\n    }\n}\n\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n```",
  "1487": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] dirs = {{2}, {1,3},{5}};\n        System.out.println(Arrays.deepToString(uniquePaths(dirs)));\n        dirs = new int[][]{{1},{2,3},{5}};\n        System.out.println(Arrays.deepToString(uniquePaths(dirs)));\n        dirs = new int[][]{{4},{7,11},{14,18}};\n        System.out.println(Arrays.deepToString(uniquePaths(dirs)));\n    }\n\n    public static int[][] uniquePaths(int[][] ob) {\n        int m = ob.length;\n        if (m == 0) return new int[][]{};\n        int n = ob[0].length;\n        Map<String,Integer> map = new HashMap<>();\n        for (int i = 0; i < m; i++) {\n            String s = \"\";\n            for (int j = 0; j < n; j++) {\n                s += ob[i][j];\n            }\n            if (!map.containsKey(s)) map.put(s,0);\n            else map.put(s,map.get(s) + 1);\n        }\n        int k = 0;\n        int[][] result = new int[map.size()][2];\n        for (Map.Entry<String,Integer> entry : map.entrySet()) {\n            result[k][0] = Integer.parseInt(entry.getKey().substring(0,entry.getKey().length()-1));\n            result[k][1] = Integer.parseInt(entry.getKey().substring(entry.getKey().length()-1));\n            k++;\n        }\n        return result;\n    }\n}\n```",
  "1488": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] flood = {{1,2},{4,5},{7,12}};\n        System.out.println(minFlood(flood));\n        \n        int[][] flood2 = {{1,3},{2,6},{8,10},{11,13},{15,18}};\n        System.out.println(minFlood(flood2));\n        \n        int[][] flood3 = {{1,4},{3,5},{7,12},{19,20}};\n        System.out.println(minFlood(flood3));\n    }\n\n    public static class Info {\n        int start;\n        int end;\n\n        public Info(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    public static class Compare implements Comparator<Info> {\n\n        @Override\n        public int compare(Info o1, Info o2) {\n            return Integer.compare(o1.start, o2.start);\n        }\n    }\n\n    public static int minFlood(int[][] flood) {\n        PriorityQueue<Info> pq = new PriorityQueue<>(new Compare());\n        for (int[] f : flood) {\n            pq.offer(new Info(f[0], f[1]));\n        }\n        \n        int res = 0;\n        while (!pq.isEmpty()) {\n            Info cur = pq.poll();\n            if (cur.start <= res) {\n                res = Math.max(res, cur.end);\n            } else {\n                res = cur.end;\n            }\n        }\n\n        return res + 1;\n    }\n}",
  "1489": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] edges1 = {{0, 1, 4}, {0, 2, 8}, {1, 2, 8}};\n        System.out.println(\"Edges in MST: \" + findCriticalAndPseudoCriticalEdges(edges1));\n        \n        int[][] edges2 = {{0, 1, 5}, {1, 2, 3}, {2, 3, 6}, {0, 4, 10}};\n        System.out.println(\"Edges in MST: \" + findCriticalAndPseudoCriticalEdges(edges2));\n        \n        int[][] edges3 = {{0, 1, 2}, {1, 2, 5}, {2, 3, 1}, {3, 4, 6}, {4, 0, 7}};\n        System.out.println(\"Edges in MST: \" + findCriticalAndPseudoCriticalEdges(edges3));\n    }\n\n    public static String findCriticalAndPseudoCriticalEdges(int[][] edges) {\n        // your implementation here\n    }\n}\n```",
  "1490": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        NaryTreeNode root1 = new NaryTreeNode(1);\n        root1.children.add(new NaryTreeNode(2));\n        root1.children.add(new NaryTreeNode(3));\n\n        NaryTreeNode root2 = new NaryTreeNode(4);\n        root2.children.add(new NaryTreeNode(5));\n\n        NaryTreeNode root3 = new NaryTreeNode(6);\n\n        Solution solution = new Solution();\n        NaryTreeNode cloneRoot1 = solution.cloneNaryTree(root1);\n        NaryTreeNode cloneRoot2 = solution.cloneNaryTree(root2);\n        NaryTreeNode cloneRoot3 = solution.cloneNaryTree(root3);\n\n        printNaryTree(cloneRoot1);\n        printNaryTree(cloneRoot2);\n        printNaryTree(cloneRoot3);\n    }\n\n    public static void printNaryTree(NaryTreeNode node) {\n        if (node == null) return;\n        System.out.println(node.val);\n        for (NaryTreeNode child : node.children) {\n            printNaryTree(child);\n        }\n    }\n}\n\nclass Solution {\n    public NaryTreeNode cloneNaryTree(NaryTreeNode root) {\n        if (root == null) return null;\n\n        NaryTreeNode cloneRoot = new NaryTreeNode(root.val);\n        for (NaryTreeNode child : root.children) {\n            cloneRoot.children.add(cloneNaryTree(child));\n        }\n        return cloneRoot;\n    }\n}\n\nclass NaryTreeNode {\n    public int val;\n    public List<NaryTreeNode> children;\n\n    public NaryTreeNode(int val) {\n        this.val = val;\n        this.children = new ArrayList<>();\n    }\n}\n```",
  "1491": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] salary = {{1000000,2000000},{2500000,5000000},{3000000,4000000}};\n        System.out.println(\"Average Salary: \" + averageSalary(salary));\n        \n        int[][] test1 = {{1000, 2100}};\n        System.out.println(\"Test Case 1: Average Salary: \" + averageSalary(test1));\n\n        int[][] test2 = {{150,200},{200,400}};\n        System.out.println(\"Test Case 2: Average Salary: \" + averageSalary(test2));\n\n        int[][] test3 = {{1000000,9999999}};\n        System.out.println(\"Test Case 3: Average Salary: \" + averageSalary(test3));\n    }\n\n    public static double averageSalary(int[][] salary) {\n        if(salary.length==0){\n            return 0;\n        }\n        Arrays.sort(Arrays.stream(salary).flatMapToInt((row) -> IntStream.range(0, row.length).map(i -> row[i])).toArray());\n        \n        int sum = 0;\n        for (int i = 1; i < salary[0].length - 1; i++) {\n            sum += salary[0][i];\n        }\n        \n        return (double)sum / (salary[0].length - 2);\n    }\n}\n```",
  "1492": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(kthFactor(12, 3));\n        System.out.println(kthFactor(4, 2));\n        System.out.println(kthFactor(7, 6));\n    }\n\n    public static int kthFactor(int n, int k) {\n        for (int i = 1; ; i++) {\n            if (n % i != 0) continue;\n            int j = n / i;\n            if (--k == 0) return i;\n            if (i != j) continue;\n            if (--k == 0) return i;\n        }\n    }\n}\n```",
  "1493": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestSubarray(new int[]{1,1,0,1,1,1})); // Expected: 5\n        System.out.println(longestSubarray(new int[]{0,1,1,0,1,1,1,1})); // Expected: 4\n        System.out.println(longestSubarray(new int[]{1,1,0,0,0,1,1,1,1,1,1})); // Expected: 6\n    }\n\n    public static int longestSubarray(int[] nums) {\n        if (nums.length == 0) return 0;\n        \n        int maxLen = 0;\n        int left = 0;\n        for (int right = 0; right < nums.length; right++) {\n            while (nums[right] == 0 && right - left > maxLen) {\n                left++;\n            }\n            maxLen = Math.max(maxLen, right - left + 1);\n        }\n        \n        int minLen = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 0) continue;\n            int len = 1;\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == 0) break;\n                len++;\n            }\n            minLen = Math.min(minLen, len);\n        }\n        \n        return Math.max(maxLen - 1, minLen);\n    }\n}\n```",
  "1494": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(parallelCourses(new int[][]{{1,2},{2,3},{3,4},{4,5}}, 5));\n        System.out.println(parallelCourses(new int[][]{{1,2},{2,4},{4,5}}, 5));\n        System.out.println(parallelCourses(new int[][]{}, 2));\n    }\n\n    public static int parallelCourses(int[][] courses, int n) {\n        int[] indegree = new int[n + 1];\n        for (int[] course : courses) {\n            indegree[course[1]]++;\n            for (int i = 2; i <= course[2]; i++) {\n                indegree[i]++;\n            }\n        }\n\n        int ans = 0;\n        for (int i = 1; i <= n; i++) {\n            if (indegree[i] == 0) {\n                ans++;\n                for (int j = i + 1; j <= n; j++) {\n                    indegree[j]--;\n                }\n            }\n        }\n\n        return ans;\n    }\n}\n```",
  "1495": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] watchedVideosByFriends = {\n            {5, 4},\n            {4, 3, 2},\n            {1, 3, 4}\n        };\n        String[] rated = {\"A\", \"B\", \"C\"};\n        String friend = \"Bob\";\n        System.out.println(findContentRating(watchedVideosByFriends, rated));\n    }\n\n    public static int findContentRating(int[][] watchedVideosByFriends, String[] rated) {\n        HashMap<String, Integer> map = new HashMap<>();\n        for (String s : rated) {\n            map.put(s, map.getOrDefault(s, 0) + 1);\n        }\n        Arrays.sort(watchedVideosByFriends, (a, b) -> a.length - b.length);\n        Arrays.sort(rated);\n        int i = 0, j = 0;\n        while (i < watchedVideosByFriends.length && j < rated.length) {\n            if (watchedVideosByFriends[i].length <= map.getOrDefault(rated[j], 0)) {\n                j++;\n            }\n            i++;\n        }\n        return j;\n    }\n}\n```",
  "1496": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canCross(\"UP\", \"DOWN\", \"LEFT\", \"RIGHT\")); // true\n        System.out.println(canCross(\"MISSISSIPPI\", \"MILITARY\", \"MINISTER\", \"MAGNIFICENT\")); // false\n        System.out.println(canCross(\"HERE\", \"THIS\", \"IS\", \"NOT\")); // true\n    }\n\n    public static boolean canCross(String s, String t, String u, String v) {\n        Set<String> set1 = new HashSet<>();\n        Set<String> set2 = new HashSet<>();\n\n        for (char c : s.toCharArray()) {\n            if (!Character.isLetter(c)) continue;\n            set1.add(Character.toString(c).toUpperCase());\n        }\n\n        for (char c : t.toCharArray()) {\n            if (!Character.isLetter(c)) continue;\n            set2.add(Character.toString(c).toUpperCase());\n        }\n\n        return !set1.equals(set2) || !set2.containsAll(set1);\n    }\n}",
  "1497": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {60,180},\n            {{60}, {40},{30,10,60}},\n            {{1,2,3,4,5,6}}\n        };\n        for (int i = 0; i < arrays.length; i++) {\n            boolean result = canArrange(arrays[i], 2);\n            System.out.println(\"Array \" + (i+1) + \": \" + (result ? \"Yes\" : \"No\"));\n        }\n    }\n\n    public static boolean canArrange(int[] arr, int k) {\n        int sum = 0;\n        for (int num : arr) {\n            sum += num % k;\n        }\n        return sum == 0 || (k % 2 == 0 && sum == k / 2);\n    }\n}\n```",
  "1498": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countSubsequences(new int[]{2, 1, 3}, 5));\n        System.out.println(countSubsequences(new int[]{4, 6, 7, 7}, 22));\n        System.out.println(countSubsequences(new int[]{10, 12, -5, 20, 4}, 0));\n    }\n\n    public static int countSubsequences(int[] nums, int target) {\n        Arrays.sort(nums);\n        int left = 0;\n        int right = nums.length - 1;\n        int res = 0;\n\n        while (left <= right) {\n            if (nums[left] + nums[right] > target) {\n                right--;\n            } else if (nums[left] + nums[right] < target) {\n                left++;\n            } else {\n                res += (right - left + 1) * (right - left + 1);\n                left++;\n                right--;\n            }\n        }\n\n        return res;\n    }\n}\n```",
  "1499": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxValueOfEquation(new int[][]{{4,2,5},{-2,-1,2},{1,-8,10}}, new int[]{0,1,2}));\n        System.out.println(maxValueOfEquation(new int[][]{{3,4,5},{1,2,9}} ,new int[]{0,1}));\n        System.out.println(maxValueOfEquation(new int[][]{{-10,-2,-3}},{0,1}));\n    }\n\n    public static double maxValueOfEquation(int[][] equations, int[] values) {\n        // TO DO: write your solution here\n        int n = equations.length;\n        UnionFind uf = new UnionFind(n);\n        for (int i = 0; i < n; i++) {\n            uf.union(i, i);\n        }\n        for (int[] equation : equations) {\n            int a = find(uf, equation[0]);\n            int b = find(uf, equation[1]);\n            if (a != b) {\n                uf.union(a, b);\n            }\n        }\n        double max = 0;\n        for (int i = 0; i < n; i++) {\n            if (values[i] > 0) {\n                max = Math.max(max, values[i] / (double)(-equations[uf.parent[i]][i]));\n            } else {\n                max = Math.max(max, -values[i] / (double)equations[uf.parent[i]][i]);\n            }\n        }\n        return max;\n    }\n\n    static class UnionFind {\n        int[] parent;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public void union(int a, int b) {\n            if (parent[a] != parent[b]) {\n                parent[find(parent, a)] = find(parent, b);\n            }\n        }\n\n        public int find(int[] arr, int x) {\n            return arr[x] == x ? x : find(arr, arr[x]);\n        }\n    }\n}",
  "1500": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        FileSharingSystem fileSharingSystem = new FileSharingSystem();\n\n        // Test case 1\n        fileSharingSystem.upload(\"file1.txt\", \"hello\");\n        fileSharingSystem.upload(\"file2.txt\", \"world\");\n        System.out.println(fileSharingSystem.download(\"file1.txt\"));  // prints \"hello\"\n        System.out.println(fileSharingSystem.download(\"file2.txt\"));  // prints \"world\"\n\n        // Test case 2\n        fileSharingSystem.upload(\"file3.txt\", \"foo\");\n        System.out.println(fileSharingSystem.download(\"file1.txt\"));  // prints \"hello\" (still available)\n        System.out.println(fileSharingSystem.download(\"file2.txt\"));  // prints \"world\" (still available)\n        System.out.println(fileSharingSystem.download(\"file3.txt\"));  // prints \"foo\"\n\n        // Test case 3\n        fileSharingSystem.upload(\"file4.txt\", \"bar\");\n        fileSharingSystem.deleteFile(\"file1.txt\"); // remove file1.txt from the system\n        System.out.println(fileSharingSystem.download(\"file2.txt\"));  // still prints \"world\" (still available)\n        System.out.println(fileSharingSystem.download(\"file3.txt\"));  // still prints \"foo\" (still available)\n        System.out.println(fileSharingSystem.download(\"file4.txt\"));  // prints \"bar\"\n    }\n}\n```",
  "1501": "```\npublic class Solution {\n    public List<String> findSafeCountries(String[] countryList) {\n        // your logic here\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] countryList1 = {\"USA\", \"Canada\", \"Mexico\"};\n        System.out.println(\"Country List 1: \" + solution.findSafeCountries(countryList1));\n        \n        String[] countryList2 = {\"India\", \"China\", \"Japan\"};\n        System.out.println(\"Country List 2: \" + solution.findSafeCountries(countryList2));\n        \n        String[] countryList3 = {\"Brazil\", \"Argentina\", \"Chile\"};\n        System.out.println(\"Country List 3: \" + solution.findSafeCountries(countryList3));\n    }\n}\n```",
  "1502": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canMakeArithmeticProgression(new int[]{3, 5, 1})); // Expected: true\n        System.out.println(canMakeArithmeticProgression(new int[]{1, 2, 4, 5, 3, 5})); // Expected: false\n        System.out.println(canMakeArithmeticProgression(new int[]{0, -3, 5})); // Expected: true\n    }\n\n    public static boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        for (int i = 1; i < arr.length; i++) {\n            if ((arr[i] - arr[i-1]) != (arr[1] - arr[0])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1503": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(lastMomentBeforeAllAntsFallOutOfAPlank(new int[]{2, 6, 5, 4}, new int[]{1, 2, 4, 6}) + \" expected 2\");\n        System.out.println(lastMomentBeforeAllAntsFallOutOfAPlank(new int[]{3, 9, 7, 2, 5}, new int[]{0, 1, 2, 4, 8}) + \" expected 3\");\n        System.out.println(lastMomentBeforeAllAntsFallOutOfAPlank(new int[]{4}, new int[]{10}) + \" expected 3\");\n    }\n\n    public static int lastMomentBeforeAllAntsFallOutOfAPlank(int[] ants, int[] intervals) {\n        Arrays.sort(intervals);\n        int maxJump = 0;\n        for (int i = 0; i < ants.length - 1; i++) {\n            if (ants[i + 1] - ants[i] > intervals[maxJump]) {\n                return maxJump;\n            }\n            if (i < ants.length - 2) {\n                maxJump++;\n            }\n        }\n        return maxJump;\n    }\n}",
  "1504": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {\n            {0, 0, 1, 1},\n            {0, 1, 1, 0},\n            {0, 0, 0, 1}\n        };\n        System.out.println(\"Test case 1: \" + countSubmatrices(matrix1));\n        \n        int[][] matrix2 = {\n            {1, 1, 1, 1},\n            {1, 1, 1, 1},\n            {1, 1, 1, 1}\n        };\n        System.out.println(\"Test case 2: \" + countSubmatrices(matrix2));\n        \n        int[][] matrix3 = {\n            {0, 1},\n            {1, 1}\n        };\n        System.out.println(\"Test case 3: \" + countSubmatrices(matrix3));\n    }\n\n    public static int countSubmatrices(int[][] mat) {\n        if (mat == null || mat.length == 0 || mat[0].length == 0) return 0;\n        \n        int m = mat.length, n = mat[0].length, res = 0;\n        for (int i = 0; i < m; i++) {\n            int[] heights = new int[n];\n            for (int j = i; j < m; j++) {\n                for (int k = 0; k < n; k++) {\n                    heights[k] = mat[j][k] == 1 ? heights[k] + 1 : 0;\n                }\n                res += countColumns(heights);\n            }\n        }\n        return res;\n    }\n\n    public static int countColumns(int[] height) {\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 0; i < height.length; i++) {\n            while (!stack.isEmpty() && height[stack.peek()] >= height[i]) {\n                stack.pop();\n            }\n            if (!stack.isEmpty()) {\n                res++;\n            }\n            stack.push(i);\n        }\n        \n        return res;\n    }\n}\n```",
  "1505": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minSwaps(\"4326219\", 3)); // Expected output: 1\n        System.out.println(minSwaps(\"987654321\", 0)); // Expected output: 0\n        System.out.println(minSwaps(\"10021027\", 3)); // Expected output: 3\n    }\n\n    public static int minSwaps(String s, int k) {\n        int n = s.length();\n        for (int i = 0; i < n - k; i++) {\n            if (!s.substring(i, i + k).equals(s.substring(i + 1, i + k + 1))) {\n                return Math.min(i, n - i - k);\n            }\n        }\n        return 0;\n    }\n}\n```",
  "1507": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(reformatDate(\"20th February 2013\")); // Expected: \"02/20/2013\"\n        System.out.println(reformatDate(\"6th March 2014\")); // Expected: \"03/06/2014\"\n        System.out.println(reformatDate(\"26th Apr 2000\")); // Expected: \"04/26/2000\"\n    }\n\n    public static String reformatDate(String s) {\n        String[] parts = s.split(\" \");\n        String day = \"\";\n        for (String part : parts[2].split(\"\")) {\n            if (!Character.isDigit(part.charAt(0))) {\n                day += part;\n            } else {\n                break;\n            }\n        }\n\n        return parts[2].replace(day, \"\") + \"/\" + pad(day) + \"/\" + parts[3];\n    }\n\n    public static String pad(String s) {\n        return (s.length() < 2 ? \"0\" : \"\") + s;\n    }\n}\n```",
  "1506": "```\npublic class Main {\n    public static void main(String[] args) {\n        NaryTree tree1 = new NaryTree(1);\n        tree1.children.add(new NaryTreeNode(2));\n        tree1.children.add(new NaryTreeNode(3));\n        tree1.children.add(new NaryTreeNode(4));\n        tree1.children.get(0).children.add(new NaryTreeNode(5));\n        tree1.children.get(0).children.add(new NaryTreeNode(6));\n\n        System.out.println(\"Root of Tree 1: \" + findRoot(tree1));\n\n        NaryTree tree2 = new NaryTree(10);\n        tree2.children.add(new NaryTreeNode(4));\n        tree2.children.add(new NaryTreeNode(7));\n        tree2.children.get(0).children.add(new NaryTreeNode(8));\n        tree2.children.get(0).children.add(new NaryTreeNode(9));\n\n        System.out.println(\"Root of Tree 2: \" + findRoot(tree2));\n\n        NaryTree tree3 = new NaryTree(-1);\n\n        System.out.println(\"Root of Tree 3: \" + findRoot(tree3));\n    }\n\n    public static int findRoot(NaryTree root) {\n        if (root.val == -1) {\n            return 0;\n        } else {\n            for (NaryTreeNode child : root.children) {\n                if (child.val != -1) {\n                    return root.val;\n                }\n            }\n        }\n        return root.val;\n    }\n}\n\nclass NaryTree {\n    int val;\n    List<NaryTreeNode> children = new ArrayList<>();\n\n    public NaryTree(int val) {\n        this.val = val;\n    }\n}\n\nclass NaryTreeNode {\n    int val;\n    List<NaryTreeNode> children = new ArrayList<>();\n\n    public NaryTreeNode(int val) {\n        this.val = val;\n    }\n}",
  "1508": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = new int[]{-2,5,-1};\n        System.out.println(\"Expected: 14, Got: \" + subArraySums(nums1));\n        \n        int[] nums2 = new int[]{0, -7, 2,null,aop,1999,-4,77,0};\n        System.out.println(\"Expected: 928, Got: \" + subArraySums(nums2));\n\n        int[] nums3 = new int[]{-1981199151,-111111111,-1};\n        System.out.println(\"Expected: -2233333345, Got: \" + subArraySums(nums3));\n    }\n\n    public static int subArraySums(int[] nums) {\n        long prefixSum = 0;\n        long maxSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == null) {\n                return -1;\n            }\n            prefixSum += nums[i];\n            int left = binarySearch(prefixSum);\n            if (left >= 0) {\n                maxSum = Math.max(maxSum, prefixSum - (long) nums[left]);\n            } else {\n                maxSum = Math.max(maxSum, prefixSum);\n            }\n        }\n\n        return (int)maxSum;\n    }\n\n    public static int binarySearch(long target) {\n        int left = 0;\n        int right = 0;\n\n        while (right < right + 1) {\n            int mid = (left + right) / 2;\n            if (nums[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return left;\n    }\n}",
  "1509": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums = {{1,5},{10,15},{6,8}};\n        System.out.println(minDifference(nums));\n        \n        nums = new int[][]{{4,10,6,8}};\n        System.out.println(minDifference(nums));\n\n        nums = new int[][]{{3,9,3}};\n        System.out.println(minDifference(nums));\n    }\n\n    public static int minDifference(int[][] nums) {\n        Arrays.sort(nums[0]);\n        Arrays.sort(nums[1]);\n        Arrays.sort(nums[2]);\n\n        return Math.min(Math.max(nums[0][nums[0].length-1] - nums[0][0], \n                Math.max(nums[1][nums[1].length-1] - nums[1][0], \n                        nums[2][nums[2].length-1] - nums[2][0])), \n                Math.min(Math.max((nums[0][nums[0].length-1] - nums[0][0]), (nums[1][nums[1].length-1] - nums[1][0])), \n                        (nums[2][nums[2].length-1] - nums[2][0]))); \n    }\n}\n```",
  "1510": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canWin(5, new int[]{2,1,3})); // true\n        System.out.println(canWin(7, new int[]{2,1,3})); // false\n        System.out.println(canWin(10, new int[]{4,6,8,7})); // true\n    }\n\n    public static boolean canWin(int piles[], int turn) {\n        if (turn == 0) return false;\n        for (int i = 0; i < piles.length; i++) {\n            if ((piles[i] % 2 == 1 && turn % 2 == 0) || (piles[i] % 2 == 0 && turn % 2 == 1)) {\n                int[] newPiles = Arrays.copyOf(piles, piles.length);\n                newPiles[i]--;\n                if (!canWin(newPiles, turn - 1)) return true;\n            }\n        }\n        return false;\n    }\n}",
  "1511": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] orders = {{1, \"apple\"}, {2, \"banana\"], {1, \"apple\"}, {1, \"apple\"}};\n        System.out.println(\"Frequency of 'apple' is: \" + customerOrderFrequency(orders, \"apple\"));\n        \n        int[][] orders2 = {{1, \"zoo\"}, {2, \"orange\"}, {3, \"apple\"}, {4, \"banana\"}, {5, \"apple\"}};\n        System.out.println(\"Frequency of 'banana' is: \" + customerOrderFrequency(orders2, \"banana\"));\n        \n        int[][] orders3 = {{1, \"cat\"}, {2, \"dog\"}, {3, \"fish\"}};\n        System.out.println(\"Frequency of 'bird' is: \" + customerOrderFrequency(orders3, \"bird\"));\n    }\n\n    public static int customerOrderFrequency(int[][] orders, String product) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int[] order : orders) {\n            if (!map.containsKey(order[1])) {\n                map.put(order[1], 0);\n            }\n            map.put(order[1], map.get(order[1]) + 1);\n        }\n        return map.getOrDefault(product, 0);\n    }\n}\n```",
  "1512": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + numIdenticalPairs(new int[]{1,2,3,1,1,3})); // expected output: 5\n        System.out.println(\"Test case 2: \" + numIdenticalPairs(new int[]{1,1,1,1})); // expected output: 6\n        System.out.println(\"Test case 3: \" + numIdenticalPairs(new int[]{0,1,2,3})); // expected output: 0\n    }\n\n    public static int numIdenticalPairs(int[] nums) {\n        int count = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            if (map.containsKey(num)) {\n                map.put(num, map.get(num) + 1);\n            } else {\n                map.put(num, 1);\n            }\n        }\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            count += entry.getValue() * (entry.getValue() - 1) / 2;\n        }\n        return count;\n    }\n}\n```",
  "1513": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(substringWithOnes(\"011246942001\")); // expected output: 8\n        System.out.println(substringWithOnes(\"10101\")); // expected output: 5\n        System.out.println(substringWithOnes(\"1111\")); // expected output: 10\n    }\n\n    public static int substringWithOnes(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '1') {\n                count++;\n                for (int j = i; j < s.length() && s.charAt(j) == '1'; j++) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
  "1515": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(walkingDistance(new int[]{7, 4, 5, 3}, 1));\n        System.out.println(walkingDistance(new int[]{14, 6, 0, 8, 15}, 2));\n        System.out.println(walkingDistance(new int[]{26 }, 1));\n    }\n\n    public static int walkingDistance(int[] coordinates, int start) {\n        int n = coordinates.length;\n        int minSum = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = 0; j < n; j++) {\n                if (i == j)\n                    continue;\n                sum += Math.abs(coordinates[j] - coordinates[i]);\n            }\n            minSum = Math.min(minSum, sum);\n        }\n        return minSum;\n    }\n}\n```",
  "1514": "```\nimport java.util.*;\n\nclass Solution {\n    public double maxProbability(int[][] grid, int row, int col) {\n        if (grid.length == 0 || grid[0].length == 0) return 0.0;\n        int n = grid.length, m = grid[0].length;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == -1) continue;\n                grid[i][j] /= 100.0;\n            }\n        }\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> Double.compare(b[2], a[2]));\n        pq.offer(new int[]{row, col, 1});\n        double[] dp = new double[n*m];\n        Arrays.fill(dp, -1);\n        dp[row*m+col] = 1;\n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            for (int[] dir : {{-1,0},{1,0},{0,-1},{0,1}}) {\n                int x = curr[0]+dir[0], y = curr[1]+dir[1];\n                if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] > 0 && dp[x*m+y] == -1) {\n                    dp[x*m+y] = curr[2]*grid[x][y];\n                    pq.offer(new int[]{x, y, dp[x*m+y]});\n                }\n            }\n        }\n        return dp[(int)Math.max(row,m-1)*m+Math.max(col,n-1)];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.maxProbability(new int[][]{{0.25,0.50,0.75}}, 0, 1)); // Expected output: 0.500000\n        System.out.println(solution.maxProbability(new int[][]{{0.6,0.5,0.4},{0.7,0.8,0.3}} , 2, 0)); // Expected output: 0.250000\n        System.out.println(solution.maxProbability(new int[][]{{-1,-1,-1,-1}, {-1,10,30,20},{ -1, 100,200,100}, {1,500,3000,4000}} , 3,2)); // Expected output: 0.400000\n    }\n}",
  "1516": "```\npublic class Main {\n    public static void main(String[] args) {\n        N_aryTree tree1 = new N_aryTree(1);\n        tree1.children.add(new N_aryTree(2));\n        tree1.children.add(new N_aryTree(3));\n        tree1.children.get(0).children.add(new N_aryTree(4));\n        tree1.children.get(0).children.add(new N_aryTree(5));\n        tree1.children.get(1).children.add(new N_aryTree(6));\n\n        moveSubTree(tree1, 2);\n\n        System.out.println(\"Test case 1: \");\n        printTree(tree1);\n\n        N_aryTree tree2 = new N_aryTree(1);\n        tree2.children.add(new N_aryTree(2));\n        tree2.children.get(0).children.add(new N_aryTree(3));\n\n        moveSubTree(tree2, 1);\n\n        System.out.println(\"Test case 2: \");\n        printTree(tree2);\n\n        N_aryTree tree3 = new N_aryTree(1);\n        tree3.children.add(new N_aryTree(2));\n        tree3.children.get(0).children.add(new N_aryTree(3));\n\n        moveSubTree(tree3, -1); // should not move anything\n\n        System.out.println(\"Test case 3: \");\n        printTree(tree3);\n    }\n\n    public static void moveSubTree(N_aryTree tree, int val) {\n        // your code here\n    }\n\n    public static void printTree(N_aryTree tree) {\n        // your code here\n    }\n}\n\nclass N_aryTree {\n    int val;\n    List<N_aryTree> children = new ArrayList<>();\n\n    public N_aryTree(int val) {\n        this.val = val;\n    }\n}\n```",
  "1517": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<String> emails = new ArrayList<>();\n        emails.add(\"test.email@leetcode.com\");\n        emails.add(\"romeo@juliet.cm\");\n        emails.add(\"traversa.jim@gmail.com\");\n        emails.add(\"x.b@y.z\");\n\n        System.out.println(validEmails(emails));\n    }\n\n    public static List<String> validEmails(List<String> emails) {\n        List<String> result = new ArrayList<>();\n        for (String email : emails) {\n            if (isValidEmail(email)) {\n                result.add(email);\n            }\n        }\n        return result;\n    }\n\n    public static boolean isValidEmail(String email) {\n        String[] parts = email.split(\"@\");\n        if (parts.length != 2) {\n            return false;\n        }\n        String localPart = parts[0];\n        String domain = parts[1];\n\n        if (!localPart.matches(\"[^@]+\") || !domain.matches(\"([a-zA-Z0-9-\\\\.]+)\") ||\n                !domain.endsWith(\".com\") && !domain.endsWith(\".net\") && !domain.endsWith(\".io\")) {\n            return false;\n        }\n\n        return true;\n    }\n}",
  "1518": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(waterBottles(2, 1, 4)); // Test case 1: 2 bottles of capacity 1L each\n        System.out.println(waterBottles(3, 5, 23)); // Test case 2: 3 bottles of capacity 5L each\n        System.out.println(waterBottles(1, 3, 12)); // Test case 3: 1 bottle of capacity 3L\n    }\n\n    public static int waterBottles(int numBottles, int numSharingPerBottle, int volume) {\n        return numBottles * numSharingPerBottle + (numBottles > 0 ? volume : 0);\n    }\n}",
  "1519": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(5);\n        root1.left = new TreeNode(5);\n        root1.right = new TreeNode(5);\n        System.out.println(\"Expected: 4, Actual: \" + countNodes(root1));\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n        System.out.println(\"Expected: 0, Actual: \" + countNodes(root2));\n\n        TreeNode root3 = new TreeNode(3);\n        root3.left = new TreeNode(4);\n        root3.right = new TreeNode(4);\n        root3.left.left = new TreeNode(5);\n        System.out.println(\"Expected: 7, Actual: \" + countNodes(root3));\n    }\n\n    public static int countNodes(TreeNode root) {\n        if (root == null) return 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int count = 0;\n        dfs(root, map);\n        for (int value : map.values()) {\n            count += value;\n        }\n        return count;\n    }\n\n    public static void dfs(TreeNode root, HashMap<Integer, Integer> map) {\n        if (root == null) return;\n        map.putOrDefault(root.val, map.getOrDefault(root.val, 0) + 1);\n        dfs(root.left, map);\n        dfs(root.right, map);\n    }\n}\n```",
  "1520": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maxNonOverlapping(\"aaa\")); // Output: 3\n        System.out.println(maxNonOverlapping(\"abc\")); // Output: 1\n        System.out.println(maxNonOverlapping(\"aaaaabbbcc\")); // Output: 4\n    }\n\n    public static int maxNonOverlapping(String s) {\n        if (s == null || s.length() < 2) return 0;\n\n        int res = 0, i = 0;\n        while (i < s.length()) {\n            int j = i + 1;\n            while (j <= s.length() && s.charAt(i) == s.charAt(j)) {\n                j++;\n            }\n            res += (j - i);\n            i = j;\n        }\n        return res;\n    }\n}\n```",
  "1521": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] inputs = { [-5], [0, 1, 2, 3, 4, 5], [10, 11, 12] };\n        int[][] queries = { [{-1, -1}, 1.5], [[0, 1], 1.3], [[1, 3], 1.9] };\n        double[] expected = { 2.0, 1, 4 };\n\n        for (int i = 0; i < inputs.length; i++) {\n            int[] input = inputs[i];\n            int[][] query = queries[i];\n            double output = closestDivide(input, query[0][1]);\n            System.out.println(\"Expected: \" + expected[i] + \", Got: \" + output);\n        }\n    }\n\n    public static double closestDivide(int[] arr, double target) {\n        // your code here\n    }\n}\n```",
  "1522": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Node root1 = new Node(1);\n        root1.children.add(new Node(3));\n        root1.children.add(new Node(5));\n        root1.children.get(0).children.add(new Node(6));\n        root1.children.get(0).children.add(new Node(7));\n        System.out.println(\"Diameter of N-Ary Tree 1: \" + diameter(root1));\n\n        Node root2 = new Node(1);\n        root2.children.add(new Node(3));\n        root2.children.add(new Node(5));\n        root2.children.get(0).children.add(new Node(6));\n        System.out.println(\"Diameter of N-Ary Tree 2: \" + diameter(root2));\n\n        Node root3 = new Node(1);\n        root3.children.add(new Node(2));\n        System.out.println(\"Diameter of N-Ary Tree 3: \" + diameter(root3));\n    }\n\n    public static int diameter(Node root) {\n        if (root == null) return 0;\n        Map<Node, Integer> depthMap = new HashMap<>();\n        int maxDiameter = dfs(root, depthMap);\n        return Math.max(maxDiameter, depthMap.getOrDefault(root, 0));\n    }\n\n    public static int dfs(Node node, Map<Node, Integer> depthMap) {\n        if (node == null) return 0;\n        if (!depthMap.containsKey(node)) {\n            int maxDepth = 0;\n            for (Node child : node.children) {\n                int depth = dfs(child, depthMap);\n                if (depth > maxDepth) {\n                    maxDepth = depth;\n                }\n            }\n            depthMap.put(node, 1 + maxDepth);\n        }\n        return depthMap.getOrDefault(node, 0);\n    }\n\n    static class Node {\n        int val;\n        List<Node> children = new ArrayList<>();\n\n        public Node(int val) {\n            this.val = val;\n        }\n    }\n}",
  "1523": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countOdds(3, 7)); // expected output: 3\n        System.out.println(countOdds(8, 10)); // expected output: 1\n        System.out.println(countOdds(-15, -20)); // expected output: 0\n    }\n\n    public static int countOdds(int low, int high) {\n        return (high - low) / 2 + ((high % 2 == 0) ? 0 : 1) + ((low % 2 != 0) ? 1 : 0);\n    }\n}",
  "1524": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countOddSumSubarrays(new int[]{1,0,1}, 2)); // Expected: 4\n        System.out.println(countOddSumSubarrays(new int[]{10,5,4,8,20}, 3)); // Expected: 9\n        System.out.println(countOddSumSubarrays(new int[]{1,3,5}, 6)); // Expected: 21\n    }\n\n    public static int countOddSumSubarrays(int[] nums, int k) {\n        int res = 0;\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = i; j < n; j++) {\n                sum += nums[j];\n                if ((sum & 1) == 1 && (j - i + 1) % 2 != 0) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```",
  "1525": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numSteps(\"aabaaa\")); // Expected output: 6\n        System.out.println(numSteps(\"aa\")); // Expected output: 2\n        System.out.println(numSteps(\"aaaa\")); // Expected output: 5\n    }\n\n    public static int numSteps(String s) {\n        int res = 0;\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i - 1) == s.charAt(i)) {\n                res++;\n            } else {\n                break;\n            }\n        }\n        return res + (s.length() % 2 == 1 ? 1 : 0);\n    }\n}\n```",
  "1526": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] targetArray = {{9,2,9,3,5},{3,1,4,7,5},{1,5,2,4,6}};\n        for (int i = 0; i < targetArray.length; i++) {\n            int[] result = minNumberOperations(targetArray[i]);\n            System.out.println(\"Target Array: \" + Arrays.toString(targetArray[i]) +\n                    \", Minimum Number of Operations: \" + Arrays.toString(result));\n        }\n    }\n\n    public static int[] minNumberOperations(int[] target) {\n        // Your code goes here\n    }\n}\n```",
  "1527": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(calculatePatientsWithCondition(\"John\", \"Alice\", \"Bob\") + \" patients have the condition.\");\n        System.out.println(calculatePatientsWithCondition(\"John\", \"John\", \"Bob\") + \" patients have the condition.\");\n        System.out.println(calculatePatientsWithCondition(\"John\", \"Alice\", \"\") + \" patients have the condition.\");\n    }\n\n    public static int calculatePatientsWithCondition(String patient1, String patient2, String patient3) {\n        if ((patient1 == null || patient1.isEmpty()) && (patient2 == null || patient2.isEmpty()) && (patient3 == null || patient3.isEmpty())) {\n            return 0;\n        } else if (!patient1.isEmpty() && !patient2.isEmpty() && !patient3.isEmpty()) {\n            return 3;\n        } else if ((patient1 != null && !patient1.isEmpty()) && (patient2 != null && !patient2.isEmpty()) || (patient3 != null && !patient3.isEmpty())) {\n            return 2;\n        }\n        return 1;\n    }\n}\n```",
  "1528": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(shuffleString(\"abc\", 2)); // expected output: \"acb\"\n        System.out.println(shuffleString(\"aeiou\", 4)); // expected output: \"eoiua\"\n        System.out.println(shuffleString(\"aapqle\", 3)); // expected output: \"aplqa\"\n    }\n\n    public static String shuffleString(String str, int n) {\n        if (str.length() == 0 || n == 0) return str;\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(str.charAt(i));\n        }\n        while (n > 0) {\n            n--;\n            int j = (int)(Math.random() * (str.length() - n));\n            if (j >= str.length()) {\n                sb.append(str.substring(n, str.length()));\n                break;\n            } else {\n                sb.append(str.charAt(j + n));\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "1529": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumSUFFIXFlips(\"aabbaa\")); // expected output: 1\n        System.out.println(minimumSUFFIXFlips(\"aaa\")); // expected output: 0\n        System.out.println(minimumSUFFIXFlips(\"abcdefg\")); // expected output: 7\n    }\n\n    public static int minimumSUFFIXFlips(String s) {\n        int flips = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if ((s.charAt(i) ^ 'a') > 0) {\n                flips++;\n            }\n        }\n        return flips;\n    }\n}\n```",
  "1530": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(5);\n\n        System.out.println(\"Expected: 3, Got: \" + goodLeafNodePairs(root1));\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(3);\n\n        System.out.println(\"Expected: 0, Got: \" + goodLeafNodePairs(root2));\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n\n        System.out.println(\"Expected: 1, Got: \" + goodLeafNodePairs(root3));\n    }\n\n    public static int goodLeafNodePairs(TreeNode root) {\n        // Your solution here\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode leaf; // Add this line to mark the node as a leaf\n\n    public TreeNode(int val) {\n        this.val = val;\n    }\n}\n```",
  "1531": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(compress(\"aabcccccaaa\")); // Output: 2a2b8c1a\n        System.out.println(compress(\"abc\")); // Output: a1b1c1\n        System.out.println(compress(\"aaaabbba\")); // Output: 3a4b\n    }\n\n    public static String compress(String s) {\n        if (s == null || s.length() == 0) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        int count = 1;\n        char currentChar = s.charAt(0);\n        for (int i = 1; i <= s.length(); i++) {\n            if (i < s.length() && s.charAt(i) == currentChar) {\n                count++;\n            } else {\n                sb.append(currentChar).append(count);\n                currentChar = s.charAt(i);\n                count = 1;\n            }\n        }\n        sb.append(currentChar).append(count);\n        return sb.length() >= s.length() ? s : sb.toString();\n    }\n}",
  "1533": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {34, -3, -35, 42, -13, -2};\n        System.out.println(\"Index of largest integer in \" + Arrays.toString(arr1) + \": \" + findLargest(arr1));\n        \n        int[] arr2 = {-55, 22, -6, 77, 33, 11};\n        System.out.println(\"Index of largest integer in \" + Arrays.toString(arr2) + \": \" + findLargest(arr2));\n        \n        int[] arr3 = {10, 5, 8, 7, 9, 4, 3, 6, 2, 1};\n        System.out.println(\"Index of largest integer in \" + Arrays.toString(arr3) + \": \" + findLargest(arr3));\n    }\n\n    public static int findLargest(int[] arr) {\n        if (arr.length == 0) {\n            return -1;\n        }\n        \n        int max = arr[0];\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] > max) {\n                max = arr[i];\n            }\n        }\n        \n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == max) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n}\n```",
  "1532": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TestCases();\n    }\n\n    private static void TestCases() {\n        RecentOrders orders1 = new RecentOrders(new int[][]{{1,0},{2,1}});\n        System.out.println(\"Expected: [[1,0],[2,1]]\");\n        System.out.println(\"Actual: \" + orders1.getOrders());\n        System.out.println();\n\n        RecentOrders orders2 = new RecentOrders(new int[][]{{7,0},{4,2},{9,2},{10,1}});\n        System.out.println(\"Expected: [[9,2],[10,1],[7,0]]\");\n        System.out.println(\"Actual: \" + orders2.getOrders());\n        System.out.println();\n\n        RecentOrders orders3 = new RecentOrders(new int[][][]);\n        System.out.println(\"Expected: []\");\n        System.out.println(\"Actual: \" + orders3.getOrders());\n    }\n}\n\nclass RecentOrders {\n    List<int[]> orders;\n\n    public RecentOrders(int[][] customer) {\n        this.orders = new ArrayList<>();\n        for (int[] c : customer) {\n            if (c.length > 0) {\n                orders.add(c);\n            }\n        }\n    }\n\n    public List<int[]> getOrders() {\n        return orders;\n    }\n}",
  "1535": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + winnerOfGame(new int[]{2,1,3})) ;\n        System.out.println(\"Test case 2: \" + winnerOfGame(new int[]{1,2,3,4})) ;\n        System.out.println(\"Test case 3: \" + winnerOfGame(new int[]{5,10,6})) ;\n    }\n\n    public static int winnerOfGame(int[] arr) {\n        int even = 0, odd = 0;\n        for (int num : arr) {\n            if ((num & 1) == 0) even++;\n            else odd++;\n        }\n        return even > odd ? 1 : 2;\n    }\n}",
  "1534": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {3,2,1,-2,-5};\n        System.out.println(\"Count Good Triplets for \" + Arrays.toString(arr1) + \": \" + countGoodTriplets(arr1));\n        \n        int[] arr2 = {-2,1,-3,4,-1,2,1,-5,4};\n        System.out.println(\"Count Good Triplets for \" + Arrays.toString(arr2) + \": \" + countGoodTriplets(arr2));\n        \n        int[] arr3 = {0,1,2,-1,-4};\n        System.out.println(\"Count Good Triplets for \" + Arrays.toString(arr3) + \": \" + countGoodTriplets(arr3));\n    }\n\n    public static int countGoodTriplets(int[] roots) {\n        int count = 0;\n        for (int i = 0; i < roots.length; i++) {\n            for (int j = i + 1; j < roots.length; j++) {\n                if (Math.abs(roots[i] - roots[j]) <= Math.abs(roots[j] - roots[roots[j]])) {\n                    for (int k = j + 1; k < roots.length; k++) {\n                        if (Math.abs(roots[i] - roots[k]) <= Math.abs(roots[k] - roots[roots[k]])) {\n                            count++;\n                        }\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}",
  "1536": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0, 1}, {1, 0}};\n        System.out.println(\"Test case 1: \" + minSwaps(grid1));\n        \n        int[][] grid2 = {{0, 1, 0}, {0, 0, 1}, {1, 1, 1}};\n        System.out.println(\"Test case 2: \" + minSwaps(grid2));\n        \n        int[][] grid3 = {{0, 0, 1}, {1, 1, 1}, {1, 0, 0}};\n        System.out.println(\"Test case 3: \" + minSwaps(grid3));\n    }\n\n    public static int minSwaps(int[][] grid) {\n        // Write your code here\n    }\n}",
  "1537": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(getMaxScore(new int[]{1,3,-1,-2}, 3));\n        System.out.println(getMaxScore(new int[]{3,4,-3,2}, 3));\n        System.out.println(getMaxScore(new int[]{-2,-3,0,1,-5,-6}, 10));\n    }\n\n    public static int getMaxScore(int[] nums, int k) {\n        Arrays.sort(nums);\n        int score = 0;\n        for (int i = 0; i < nums.length - k; i++) {\n            score += Math.max(0, nums[i + k]);\n        }\n        return score;\n    }\n}",
  "1538": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {2, 2, 1, 1, 1, 2, 2};\n        System.out.println(\"Expected: 2, Actual: \" + majorityElement(arr1));\n        \n        int[] arr2 = {1, 2, -3, 4, 5, 6};\n        System.out.println(\"Expected: 1, Actual: \" + majorityElement(arr2));\n        \n        int[] arr3 = {0, 0, 1, 2, 2};\n        System.out.println(\"Expected: 0, Actual: \" + majorityElement(arr3));\n    }\n\n    public static int majorityElement(int[] nums) {\n        int candidate = nums[0];\n        int count = 1;\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] == candidate) {\n                count++;\n            } else {\n                count--;\n                if (count == 0) {\n                    candidate = nums[i];\n                    count = 1;\n                }\n            }\n        }\n        \n        return candidate;\n    }\n}\n```",
  "1539": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] arr1 = {2, 3, 4, 7, 11};\n        System.out.println(\"Kth missing positive number for array \" + Arrays.toString(arr1) + \": \" + findKthPositive(arr1, 5));\n        \n        int[] arr2 = {1, 2, 4};\n        System.out.println(\"Kth missing positive number for array \" + Arrays.toString(arr2) + \": \" + findKthPositive(arr2, 3));\n        \n        int[] arr3 = {};\n        System.out.println(\"Kth missing positive number for array \" + Arrays.toString(arr3) + \": \" + findKthPositive(arr3, 1));\n    }\n\n    public static int findKthPositive(int[] arr, int k) {\n        Set<Integer> set = new HashSet<>();\n        \n        for (int num : arr) {\n            if (num > 0) {\n                set.add(num);\n            }\n        }\n        \n        int i = 1;\n        while (!set.contains(i)) {\n            i++;\n        }\n        \n        for (; i <= k; i++) {\n            if (!set.contains(i)) {\n                k--;\n                if (k == 0) {\n                    return i;\n                }\n            } else {\n                break;\n            }\n        }\n        \n        return -1;\n    }\n}\n```",
  "1540": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canConvert(\"ab\", 1)); // Expected: true\n        System.out.println(canConvert(\"aa\", 0)); // Expected: false\n        System.out.println(canConvert(\"a\", 2)); // Expected: true\n    }\n\n    public static boolean canConvert(String s, int k) {\n        // Your code here\n    }\n}\n```",
  "1541": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minInsertions(\"())\")); // Output: 1\n        System.out.println(minInsertions(\"((()))\")); // Output: 0\n        System.out.println(minInsertions(\"(()())\")); // Output: 0\n    }\n\n    public static int minInsertions(String s) {\n        int left = 0, right = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                left++;\n            } else {\n                right++;\n                if (left > right) {\n                    left--;\n                }\n            }\n        }\n        return Math.max(left, right);\n    }\n\n}",
  "1543": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(fixProductNames(new String[]{\"a\", \"b\"}, new String[]{\"c\", \"d\"}));\n        System.out.println(fixProductNames(new String[]{\"nate\", \"john\", \"paul\", \"joe\", \"jack\"}, new String[]{\"\"}));\n        System.out.println(fixProductNames(new String[]{\"hello, world\", \"this is a test\"}, new String[]{\"java programming language\"}));\n    }\n\n    public static String[] fixProductNames(String[] productNames, String[] categories) {\n        String[][] products = new String[productNames.length][];\n        for (int i = 0; i < productNames.length; i++) {\n            products[i] = new String[]{categories[0], productNames[i]};\n        }\n        return products[0].length > 1 ? products : new String[][]{{}};\n    }\n}\n```",
  "1542": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + longestAwesome(\"aabaaaa\")); // Expected output: 6\n        System.out.println(\"Test case 2: \" + longestAwesome(\"abcba\")); // Expected output: 4\n        System.out.println(\"Test case 3: \" + longestAwesome(\"aabb\")); // Expected output: 2\n    }\n\n    public static int longestAwesome(String s) {\n        int maxLen = 0;\n        for (int i = 0; i < s.length(); i++) {\n            int state = 0;\n            for (int j = i; j < s.length(); j++) {\n                int curState = ((s.charAt(j) - 'a') & 1) + (((state >> 1) & 3) << 2);\n                if (curState == state || curState == state ^ 1) {\n                    maxLen = Math.max(maxLen, j - i + 1);\n                }\n                state = curState;\n            }\n        }\n        return maxLen;\n    }\n}\n```",
  "1544": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(makeGood(\"leEe\")); // Expected: \"lee\"\n        System.out.println(makeGood(\"yeaAa\"); // Expected: \"ya\")\n        System.out.println(makeGood(\"aA\")); // Expected: \"a\"\n    }\n\n    public static String makeGood(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (!sb.toString().isEmpty() && Character.toUpperCase(sb.charAt(sb.length() - 1)) == Character.toLowerCase(c)) {\n                sb.deleteCharAt(sb.length() - 1);\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "1545": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(kthBit(2, 1)); // Expected: 0\n        System.out.println(kthBit(3, 4)); // Expected: 1\n        System.out.println(kthBit(4, 11)); // Expected: 1\n    }\n\n    public static int kthBit(int n, int k) {\n        return Integer.bitCount((1 << k) - 1) % 2;\n    }\n}\n```",
  "1546": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numSubarraysWithSum(new int[]{1,0,2}, 2)); // 4\n        System.out.println(numSubarraysWithSum(new int[]{2,9,0,2,5,4,3,8,1,6}, 6)); // 7\n        System.out.println(numSubarraysWithSum(new int[]{0,0,0,0,0,0,0,0,0,0,0}, 0)); // 11\n    }\n\n    public static int numSubarraysWithSum(int[] nums, int target) {\n        Map<Integer, Integer> sumIndexMap = new HashMap<>();\n        sumIndexMap.put(0, -1);\n        int sum = 0;\n        int count = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            if (sum == target) {\n                count++;\n            }\n            if (sumIndexMap.containsKey(sum - target)) {\n                int prevIndex = sumIndexMap.get(sum - target);\n                count += i - prevIndex - 1;\n            }\n            if (!sumIndexMap.containsKey(sum)) {\n                sumIndexMap.put(sum, i);\n            }\n        }\n\n        return count;\n    }\n}",
  "1547": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] sticks = {2, 4, 5};\n        System.out.println(minCostToCut(sticks));\n        \n        sticks = new int[]{1, 3, 5, 10};\n        System.out.println(minCostToCut(sticks));\n\n        sticks = new int[]{8};\n        System.out.println(minCostToCut(sticks));\n    }\n\n    public static int minCostToCut(int[] sticks) {\n        Arrays.sort(sticks);\n        int n = sticks.length;\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = sticks[i];\n        }\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i < n - len + 1; i++) {\n                int j = i + len - 1;\n                dp[i][j] = Integer.MAX_VALUE;\n                for (int k = i; k < j; k++) {\n                    dp[i][j] = Math.min(dp[i][j], sticks[k] + dp[i][k-1]+dp[k+1][j]);\n                }\n            }\n        }\n        return dp[0][n-1];\n    }\n}\n```",
  "1548": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] expectations = {{1}, {2, 3}};\n        System.out.println(Arrays.deepToString(mostSimilarPath(new int[][]{expectations[0], expectations[1]})));\n        \n        expectations = new int[][]{{1, 4, -3, 2}, {1, -6, 3, 3}};\n        System.out.println(Arrays.deepToString(mostSimilarPath(new int[][]{expectations[0], expectations[1]})));\n\n        expectations = new int[][]{{1, 5, -2, 3}, {1, 5, -2, 4}};\n        System.out.println(Arrays.deepToString(mostSimilarPath(new int[][]{expectations[0], expectations[1]})));\n    }\n\n    public static int[][] mostSimilarPath(int[][] expectations) {\n        // Your code here\n    }\n}",
  "1549": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        List<RecentOrder> recentOrders1 = solution.getRecentOrders(Arrays.asList(\n            Arrays.asList(\"product1\", \"2020-01-01\"),\n            Arrays.asList(\"product2\", \"2020-02-01\"),\n            Arrays.asList(\"product3\", \"2020-03-01\"),\n            Arrays.asList(\"product1\", \"2020-04-01\")\n        ));\n        \n        System.out.println(recentOrders1);\n        \n        // Test case 2\n        List<RecentOrder> recentOrders2 = solution.getRecentOrders(Arrays.asList(\n            Arrays.asList(\"product3\", \"2019-12-31\"),\n            Arrays.asList(\"product2\", \"2020-01-15\"),\n            Arrays.asList(\"product2\", \"2020-02-18\")\n        ));\n        \n        System.out.println(recentOrders2);\n        \n        // Test case 3\n        List<RecentOrder> recentOrders3 = solution.getRecentOrders(Arrays.asList());\n        \n        System.out.println(recentOrders3);\n    }\n}\n\nclass RecentOrder {\n    public String product;\n    public String date;\n\n    public RecentOrder(String product, String date) {\n        this.product = product;\n        this.date = date;\n    }\n\n    @Override\n    public String toString() {\n        return \"Product: \" + product + \", Date: \" + date;\n    }\n}\n```",
  "1550": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(threeConsecutiveOdds(new int[]{2,1,4,1,2,1,3,5,1,6,0,2,2,3})); // Expected: true\n        System.out.println(threeConsecutiveOdds(new int[]{2,2,3})); // Expected: false\n        System.out.println(threeConsecutiveOdds(new int[]{1,1,1})); // Expected: true\n    }\n\n    public static boolean threeConsecutiveOdds(int[] arr) {\n        for (int i = 0; i < arr.length - 2; i++) {\n            if (arr[i] % 2 != 0 && arr[i+1] % 2 != 0 && arr[i+2] % 2 != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
  "1551": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = { {5,10,25}, {1,2,3,4}, {7,9} };\n        for (int i = 0; i < arrays.length; i++) {\n            System.out.println(\"Minimum operations to make array equal: \" + minOperations(arrays[i]));\n        }\n    }\n\n    public static int minOperations(int[] nums) {\n        int target = (int)Math.ceil(Arrays.stream(nums).average().orElse(0.0));\n        return Arrays.stream(nums).map(n -> Math.abs(target - n)).sum();\n    }\n}\n```",
  "1552": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] balls1 = {{0, 4}, {2, 4}};\n        System.out.println(\"Test case 1: \" + magneticForceBetweenTwoBalls(balls1));\n        \n        int[][] balls2 = {{1, 3}, {4, 5}, {7, 8}};\n        System.out.println(\"Test case 2: \" + magneticForceBetweenTwoBalls(balls2));\n        \n        int[][] balls3 = {{0, 10}, {12, 20}};\n        System.out.println(\"Test case 3: \" + magneticForceBetweenTwoBalls(balls3));\n    }\n    \n    public static double magneticForceBetweenTwoBalls(int[][] balls) {\n        // Your code here\n        return 0.0;\n    }\n}\n```",
  "1553": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minDaysToEatOranges(5)); // Test case 1: expected output = 6\n        System.out.println(minDaysToEatOranges(8)); // Test case 2: expected output = 4\n        System.out.println(minDaysToEatOranges(3)); // Test case 3: expected output = 2\n    }\n\n    public static int minDaysToEatOranges(int n) {\n        if (n < 1) return 0;\n        int[] dp = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            dp[i] = Math.min(i, Math.max(1, dp[i - 1] + 2));\n        }\n        return dp[n];\n    }\n}",
  "1554": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(differentOne(\"ab\", \"ba\")); // expected: true\n        System.out.println(differentOne(\"a\", \"aa\")); // expected: false\n        System.out.println(differentOne(\"hello\", \"holle\")); // expected: true\n    }\n\n    public static boolean differentOne(String s1, String s2) {\n        if (Math.abs(s1.length() - s2.length()) > 1) return false;\n        int diffCount = 0;\n        for (int i = 0; i < Math.min(s1.length(), s2.length()); i++) {\n            if (s1.charAt(i) != s2.charAt(i)) {\n                diffCount++;\n                if (diffCount > 1) return false;\n            }\n        }\n        int lenDiff = Math.abs(s1.length() - s2.length());\n        for (int i = 0; i < lenDiff; i++) {\n            if ((i >= s1.length()) != (i >= s2.length())) return false;\n        }\n        return diffCount == 1;\n    }\n}\n```",
  "1555": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1:\");\n        System.out.println(summarizeAccounts(new String[][]{{\"John\", \"100\"}, {\"Alice\", \"50\"}}));\n        \n        System.out.println(\"\\nTest case 2:\");\n        System.out.println(summarizeAccounts(new String[][]{}));\n\n        System.out.println(\"\\nTest case 3:\");\n        System.out.println(summarizeAccounts(new String[][]{{\"John\", \"100\"}, {\"Alice\", \"50\"}, {\"Bob\", \"200\"}}));\n    }\n\n    public static String summarizeAccounts(String[][] accounts) {\n        Map<String, Integer> accountMap = new HashMap<>();\n        for (String[] account : accounts) {\n            if (!account[0].isEmpty()) {\n                int balance = Integer.parseInt(account[1]);\n                accountMap.put(account[0], balance);\n            }\n        }\n\n        StringBuilder summary = new StringBuilder();\n        for (Map.Entry<String, Integer> entry : accountMap.entrySet()) {\n            summary.append(entry.getKey()).append(\": \").append(entry.getValue()).append(\"\\n\");\n        }\n        return summary.toString();\n    }\n}",
  "1556": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(addThousandsSeparator(\"1234\") + \" = Expected: 1,234\");\n        System.out.println(addThousandsSeparator(\"1000\") + \" = Expected: 1,000\");\n        System.out.println(addThousandsSeparator(\"1234567\") + \" = Expected: 1,234,567\");\n    }\n\n    public static String addThousandsSeparator(int n) {\n        return String.valueOf(n).replaceAll(\"(\\\\d)(?=(?:\\\\d{3})+(?!\\\\d))\", \"$1,\");\n    }\n}\n```",
  "1558": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] targetArray1 = {{9,8,7,6,5},{1,2,3,4,5}};\n        System.out.println(minOperations(targetArray1));\n        \n        int[][] targetArray2 = {{10,2,9,9,3},{1,1,2,3,1}};\n        System.out.println(minOperations(targetArray2));\n        \n        int[][] targetArray3 = {{7,7,6},{1,5,4}};\n        System.out.println(minOperations(targetArray3));\n    }\n\n    public static int minOperations(int[][] nums) {\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < nums[i].length; j++) {\n                if ((nums[i][j] & 1) == 1) {\n                    res++;\n                }\n                nums[i][j]--;\n            }\n        }\n        return res;\n    }\n}",
  "1557": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph = {{0,1},{0,2,3},{1},{2},{3}};\n        System.out.println(\"Result for \" + graph + \": \" + reachAllNodes(graph));\n\n        graph = new int[][]{{0, 1}, {0, 2}, {0, 3}, {1, 4}, {2, 5}};\n        System.out.println(\"Result for \" + graph + \": \" + reachAllNodes(graph));\n\n        graph = new int[][]{{0},{1},{2},{3},{4},{5}};\n        System.out.println(\"Result for \" + graph + \": \" + reachAllNodes(graph));\n    }\n\n    public static int reachAllNodes(int[][] graph) {\n        // Your solution here\n        return 0;\n    }\n}\n```",
  "1560": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] stations = {{5,8,9},{1,2,10},{4}};\n        System.out.println(\"Most Visited Sector: \" + mostVisitedSector(stations));\n        \n        int[][] stations2 = {{3,7}};\n        System.out.println(\"Most Visited Sector: \" + mostVisitedSector(stations2));\n        \n        int[][] stations3 = {{5,6,7,8},{4,3}};\n        System.out.println(\"Most Visited Sector: \" + mostVisitedSector(stations3));\n    }\n    \n    public static String mostVisitedSector(int[][] stations) {\n        int maxVisitCount = 0;\n        int visitedSector = -1;\n        \n        for (int i = 0; i < stations.length; i++) {\n            int start = stations[i][0];\n            int end = stations[i][1];\n            \n            if (end > start) {\n                for (int j = start; j <= end; j++) {\n                    maxVisitCount++;\n                }\n            } else {\n                for (int j = start; j < 100001; j++) {\n                    maxVisitCount++;\n                }\n                for (int j = 0; j <= end; j++) {\n                    maxVisitCount++;\n                }\n            }\n        }\n        \n        return \"Sector \" + visitedSector;\n    }\n}",
  "1559": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{0, 1, 0}, {1, 1, 1}, {0, 1, 0}};\n        System.out.println(\"Grid 1: \" + detectCycle(grid1));\n\n        int[][] grid2 = {{0, 0, 0}, {0, 1, 0}, {0, 0, 0}};\n        System.out.println(\"Grid 2: \" + detectCycle(grid2));\n\n        int[][] grid3 = {{1, 1, 0}, {1, 0, 1}, {0, 1, 1}};\n        System.out.println(\"Grid 3: \" + detectCycle(grid3));\n    }\n\n    public static boolean detectCycle(int[][] grid) {\n        if (grid == null || grid.length == 0) return false;\n\n        int rows = grid.length;\n        int cols = grid[0].length;\n        boolean[] visited = new boolean[rows * cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1 && !visited[i * cols + j]) {\n                    if (dfs(grid, visited, i, j)) return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    public static boolean dfs(int[][] grid, boolean[] visited, int row, int col) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n\n        if (row < 0 || row >= rows || col < 0 || col >= cols || !grid[row][col] || visited[row * cols + col]) return false;\n\n        visited[row * cols + col] = true;\n\n        // check adjacent cells\n        for (int i = -1; i <= 1; i++) {\n            for (int j = -1; j <= 1; j++) {\n                int newRow = row + i;\n                int newCol = col + j;\n\n                if ((newRow >= 0 && newRow < rows) && (newCol >= 0 && newCol < cols) &&\n                        grid[newRow][newCol] == 1 && !visited[newRow * cols + newCol]) {\n                    return dfs(grid, visited, newRow, newCol);\n                }\n            }\n        }\n\n        return true;\n    }\n}\n```",
  "1561": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maxCoins(new int[]{1,2,5})); // Test case 1\n        System.out.println(maxCoins(new int[]{8,10,9})); // Test case 2\n        System.out.println(maxCoins(new int[]{6,7,11,14,15})); // Test case 3\n    }\n\n    public static int maxCoins(int[] coins) {\n        Arrays.sort(coins);\n        int max = 0;\n        for (int i = coins.length - 1; i > 0; i--) {\n            if ((coins[i] + 2) * (i - 1) > max) {\n                max = (coins[i] + 2) * (i - 1);\n            }\n            if (max >= coins[0] * (coins.length)) {\n                return max;\n            }\n        }\n        return max;\n    }\n}\n```",
  "1562": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{1,2,3,4,5},{1,1,1,2,2},{3,4}};\n        System.out.println(\"Latest group of size 3 for arr1: \" + latestGroup(arr1, 3));\n\n        int[][] arr2 = {{0,1},{1,1},{2,3},{3,1}};\n        System.out.println(\"Latest group of size 2 for arr2: \" + latestGroup(arr2, 2));\n\n        int[][] arr3 = {{0,1,2,3,4,5},{1,1,2,3,4},{0,1,1,2,3},{3,3}};\n        System.out.println(\"Latest group of size 3 for arr3: \" + latestGroup(arr3, 3));\n    }\n\n    public static int[] latestGroup(int[][] members, int m) {\n        Map<Integer, Integer> memberLastSeen = new HashMap<>();\n        List<Integer[]> groups = new ArrayList<>();\n\n        for (int i = 0; i < members.length; i++) {\n            for (int j = 0; j < members[i].length; j++) {\n                int memberId = members[i][j];\n                if (!memberLastSeen.containsKey(memberId)) {\n                    memberLastSeen.put(memberId, i);\n                    groups.add(new Integer[]{i, j});\n                } else {\n                    while (!groups.isEmpty() && memberLastSeen.get(groups.get(0)[1]) <= i) {\n                        groups.remove(0);\n                    }\n                    if (j >= m) {\n                        groups.remove(groups.size() - 1);\n                    }\n                    memberLastSeen.put(memberId, i);\n                }\n            }\n        }\n\n        return groups.isEmpty() ? new int[0] : groups.get(groups.size() - 1);\n    }\n}",
  "1563": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] piles = {{5, 1}, {2, 7, 4}};\n        System.out.println(stoneGameV(piles)); // should print 6\n        piles = new int[][]{{10,3,2}, {8,15,9}};\n        System.out.println(stoneGameV(piles)); // should print 12\n        piles = new int[][]{{1,4,5}, {7,3,14}};\n        System.out.println(stoneGameV(piles)); // should print 10\n    }\n\n    public static int stoneGameV(int[][] piles) {\n        int n = piles.length;\n        int[] prefixSum = new int[n+1];\n        for (int i = 0; i < n; i++) {\n            prefixSum[i+1] = prefixSum[i] + Arrays.stream(piles[i]).sum();\n        }\n\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = piles[i].length % 2 == 0 ? prefixSum[n] / ((piles[i].length + 1) / 2) : prefixSum[n] / (((piles[i].length + 1) / 2) - 1);\n        }\n\n        for (int length = 3; length <= n; length++) {\n            for (int i = 0; i < n - length + 1; i++) {\n                int j = i + length - 1;\n                dp[i][j] = Math.max(piles[i][0], prefixSum[i+length] - prefixSum[i] - dp[i+1][j]);\n            }\n        }\n\n        return prefixSum[n];\n    }\n}\n```",
  "1564": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] box1 = {{1, 3}, {2, 4}};\n        System.out.println(\"Box1: \" + putBoxes(box1) + \"\\n\");\n\n        int[][] box2 = {{1, 5}, {5, 10}};\n        System.out.println(\"Box2: \" + putBoxes(box2) + \"\\n\");\n\n        int[][] box3 = {{1, 4}, {2, 6}, {7, 9}};\n        System.out.println(\"Box3: \" + putBoxes(box3));\n    }\n\n    public static String putBoxes(int[][] boxes) {\n        if (boxes == null || boxes.length == 0) return \"\";\n        Arrays.sort(boxes, (a, b) -> a[1] - b[1]);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < boxes.length; i++) {\n            sb.append(\"[\").append(boxes[i][0]).append(\", \").append(boxes[i][1]).append(\"]\");\n            if (i < boxes.length - 1) sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n}\n```",
  "1565": "```\npublic class Solution {\n    public int[] getOrders(int[][] orders) {\n        Map<String, Integer> customerCounts = new HashMap<>();\n        Map<String, Integer> orderCounts = new HashMap<>();\n\n        for (int[] order : orders) {\n            String customer = order[0] + \",\" + order[1];\n            customerCounts.put(customer, customerCounts.getOrDefault(customer, 0) + 1);\n            orderCounts.put(order[2], orderCounts.getOrDefault(order[2], 0) + 1);\n        }\n\n        int[] result = new int[]{customerCounts.size(), orderCounts.size()};\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] orders1 = {{10, \"John\", \"2020-01\"}};\n        System.out.println(Arrays.toString(solution.getOrders(orders1))); // [1, 1]\n\n        int[][] orders2 = {{5, \"Jane\", \"2020-02\"}, {6, \"Jane\", \"2020-03\"}};\n        System.out.println(Arrays.toString(solution.getOrders(orders2))); // [1, 2]\n\n        int[][] orders3 = {{10, \"John\", \"2020-01\"}, {11, \"John\", \"2020-01\"}};\n        System.out.println(Arrays.toString(solution.getOrders(orders3))); // [1, 2]\n    }\n}",
  "1566": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numTimes(new int[]{1,2,4}, 1, 3)); // Expected: true\n        System.out.println(numTimes(new int[]{1,2,4,4,4,4}, 1, 3)); // Expected: false\n        System.out.println(numTimes(new int[]{1,2,1,2,1,1}, 2, 10)); // Expected: true\n    }\n\n    public static boolean numTimes(int[] arr, int m, int k) {\n        for (int i = 0; i <= arr.length - m; i++) {\n            if (isMatched(arr, i, m)) {\n                if (countOccurrences(arr, i, m) >= k) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    public static boolean isMatched(int[] arr, int start, int m) {\n        for (int i = 0; i < m; i++) {\n            if (arr[start + i] != arr[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static int countOccurrences(int[] arr, int start, int m) {\n        int occurrences = 0;\n        for (int i = start; i <= arr.length - m; i++) {\n            if (isMatched(arr, i, m)) {\n                occurrences++;\n            }\n        }\n        return occurrences;\n    }\n}",
  "1567": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {-2, -3, 0, -2, -3};\n        System.out.println(\"Maximum length for array \" + Arrays.toString(nums1) + \": \" + maxAlternatingSum(nums1));\n        \n        int[] nums2 = {9,-4,6,20,-10,-12};\n        System.out.println(\"Maximum length for array \" + Arrays.toString(nums2) + \": \" + maxAlternatingSum(nums2));\n        \n        int[] nums3 = [1,5,-7,8,5,3];\n        System.out.println(\"Maximum length for array \" + Arrays.toString(nums3) + \": \" + maxAlternatingSum(nums3));\n    }\n\n    public static int maxAlternatingSum(int[] nums) {\n        if (nums.length == 0) return 0;\n        \n        int res = 0, pos = 1, neg = 1;\n        for (int num : nums) {\n            if (num > 0) {\n                res += pos;\n                pos++;\n                neg = 1;\n            } else if (num < 0) {\n                res += neg;\n                neg++;\n                pos = 1;\n            }\n        }\n        \n        return res;\n    }\n}",
  "1569": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numWays(new int[]{2,1,3}, new int[]{1,3,2})); // Expected output: 2\n        System.out.println(numWays(new int[]{3,5,4}, new int[]{3,6,4})); // Expected output: 6\n        System.out.println(numWays(new int[]{9,15,7,10,8,12,9,11,13,14], new int[]{9,15,7,10,8,12,9,11,13,14})); // Expected output: 2\n    }\n\n    public static int numWays(int[] arr, int[] order) {\n        // Your code here\n    }\n}\n```",
  "1568": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,1},{1,0}};\n        System.out.println(\"Grid1: \" + shortestWallTimeToDisconnect(grid1));\n        \n        int[][] grid2 = {{0,1,0,3},{0,2,2,0},{0,20,1,1},{1,15,8,10}};\n        System.out.println(\"Grid2: \" + shortestWallTimeToDisconnect(grid2));\n        \n        int[][] grid3 = {{1,1,1,0},{1,1,1,0}};\n        System.out.println(\"Grid3: \" + shortestWallTimeToDisconnect(grid3));\n    }\n\n    public static int shortestWallTimeToDisconnect(int[][] grid) {\n        // Your code here\n        // The method should return the minimum number of days to disconnect island.\n    }\n}\n```",
  "1570": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] vec1 = {1, 0, 2}, vec2 = {0, 3, 4};\n        System.out.println(\"Dot Product of two vectors: \" + dotProduct(vec1, vec2));\n        \n        int[] vec3 = {2, 1, 3}, vec4 = {4, 5, 6};\n        System.out.println(\"Dot Product of two vectors: \" + dotProduct(vec3, vec4));\n        \n        int[] vec5 = {0, 1, 2, 3}, vec6 = {2, 3, 4, 5};\n        System.out.println(\"Dot Product of two vectors: \" + dotProduct(vec5, vec6));\n    }\n\n    public static int dotProduct(int[] vec1, int[] vec2) {\n        Map<Integer, Integer> map1 = new HashMap<>();\n        Map<Integer, Integer> map2 = new HashMap<>();\n\n        for (int i = 0; i < vec1.length; i++) {\n            if (vec1[i] != 0) {\n                map1.put(i, vec1[i]);\n            }\n            if (vec2[i] != 0) {\n                map2.put(i, vec2[i]);\n            }\n        }\n\n        int dotProduct = 0;\n        for (Map.Entry<Integer, Integer> entry : map1.entrySet()) {\n            if (map2.containsKey(entry.getKey())) {\n                dotProduct += entry.getValue() * map2.get(entry.getKey());\n            }\n        }\n\n        return dotProduct;\n    }\n}\n```",
  "1571": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] orders1 = {{10, 5}, {15, 2}, {25, 8}};\n        System.out.println(\"Test Case 1: \" + solution.orderPlacement(orders1));\n        \n        int[][] orders2 = {{5, 7}, {11, 2}, {3, 14}};\n        System.out.println(\"Test Case 2: \" + solution.orderPlacement(orders2));\n        \n        int[][] orders3 = {{1, 10}, {10, 8}, {20, 6}, {30, 5}, {40, 9}};\n        System.out.println(\"Test Case 3: \" + solution.orderPlacement(orders3));\n    }\n}\n```",
  "1573": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(numWays(\"aabaa\", 3)); // Expected output: 4\n        System.out.println(numWays(\"aba\", 2)); // Expected output: 1\n        System.out.println(numWays(\"a\", 1)); // Expected output: 1\n    }\n\n    public static int numWays(String s, int n) {\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            if ((i + 1) * (s.length() / (i + 1)) == s.length()) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```",
  "1572": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1, 2, 3}, {4, 5, 6}};\n        System.out.println(diagonalSum(matrix1)); // Output: 12\n\n        int[][] matrix2 = {{1, 1, 1, 1}, {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0}};\n        System.out.println(diagonalSum(matrix2)); // Output: 6\n\n        int[][] matrix3 = {{5}};\n        System.out.println(diagonalSum(matrix3)); // Output: 5\n    }\n\n    public static int diagonalSum(int[][] mat) {\n        int sum = 0;\n        int n = mat.length;\n\n        // calculate the main diagonal\n        for (int i = 0; i < n; i++) {\n            sum += mat[i][i];\n        }\n\n        // calculate the secondary diagonal if the matrix is odd-sized, or stop at the second-to-last row if it's even-sized\n        int j = n - 1;\n        if (n % 2 == 0) {\n            for (int i = 0; i < n / 2; i++) {\n                sum += mat[i][j];\n                j--;\n            }\n        } else {\n            for (int i = 0; i < n / 2; i++) {\n                sum += mat[i][j];\n                j--;\n            }\n            sum += mat[n / 2][n / 2];\n        }\n\n        return sum;\n    }\n}",
  "1574": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = { {2, 3, 4}, {1, 2, 20, 100, 200}, {1, 5, 6} };\n        for (int i = 0; i < arrays.length; i++) {\n            System.out.println(\"Array: \" + Arrays.toString(arrays[i]) + \", Length of shortest subarray to remove: \" + findShortestSubarrayLength(arrays[i]));\n        }\n    }\n\n    public static int findShortestSubarrayLength(int[] nums) {\n        if (nums.length == 0) return 0;\n        int n = nums.length;\n        int left = 0, right = n - 1, minLen = n, maxLeft = 0, maxRight = n - 1;\n        while (left < right) {\n            if (nums[left] <= nums[right]) {\n                if (maxLeft == 0 || nums[maxLeft] > nums[left]) maxLeft = left;\n                left++;\n            } else {\n                if (maxRight == n - 1 || nums[maxRight] < nums[right]) maxRight = right;\n                right--;\n            }\n        }\n        int len = Math.max(maxLeft, maxRight);\n        for (int i = len; i > 0; i--) {\n            if (nums[i - 1] <= nums[0]) return n - i;\n            else break;\n        }\n        return minLen;\n    }\n}\n```",
  "1575": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{1,2},{3,4}};\n        System.out.println(\"Number of routes in grid1: \" + countRoutes(0, 0, grid1));\n        \n        int[][] grid2 = {{5,6},{7,8}};\n        System.out.println(\"Number of routes in grid2: \" + countRoutes(0, 0, grid2));\n        \n        int[][] grid3 = {{1,1,1},{2,2,2},{3,3,3}};\n        System.out.println(\"Number of routes in grid3: \" + countRoutes(0, 0, grid3));\n    }\n\n    public static int countRoutes(int row, int col, int[][] grid) {\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length){\n            return 1;\n        }\n        if(grid[row][col] == -1){\n            return 0;\n        }\n        if(row == grid.length-1 && col == grid[0].length-1){\n            return 1;\n        }\n        int left = countRoutes(row, col-1, grid);\n        int top = countRoutes(row-1, col, grid);\n        return left + top;\n    }\n}",
  "1576": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(replace(\"a?b\"));\"replace\"\n        System.out.println(replace(\"abc\"));\"replace\"\n        System.out.println(repeat(\"a??b\"));\"replace\"\n    }\n\n    public static String replace(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '?') {\n                if (i > 0 && s.charAt(i - 1) != '?' && i + 1 < s.length() && s.charAt(i + 1) != s.charAt(i)) {\n                    sb.append(s.charAt(i));\n                } else {\n                    sb.append('a');\n                }\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n}",
  "1577": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numFactoredBinaryTrees(new int[]{2,6,7,4,4,9,4,7,5}) + \" expected: 4\");\n        System.out.println(numFactoredBinaryTrees(new int[]{3,5,16}) + \" expected: 1\");\n        System.out.println(numFactoredBinaryTrees(new int[]{5,7,13,9,19}) + \" expected: 6\");\n    }\n\n    public static int numFactoredBinaryTrees(int[] arr) {\n        // your code here\n    }\n}",
  "1578": "```\npublic class Main {\n    public static void main(String[] args) {\n        int n1 = 3;\n        System.out.println(\"Test case 1: Expected output - \" + minimumTime(n1, new String[]{\"W\", \"W\", \"B\"}));\n        \n        int n2 = 4;\n        System.out.println(\"Test case 2: Expected output - \" + minimumTime(n2, new String[]{\"R\", \"R\", \"G\", \"K\"}));\n\n        int n3 = 5;\n        System.out.println(\"Test case 3: Expected output - \" + minimumTime(n3, new String[]{\"W\", \"B\", \"W\", \"E\", \"R\"}));\n    }\n\n    public static int minimumTime(int n, String[] colors) {\n        // Your code here\n    }\n}\n```",
  "1580": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] boxes = {{1, 2}, {3, 4}, {5, 6}};\n        System.out.println(\"Boxes: \");\n        printBoxes(boxes);\n        \n        boxes = new int[][]{{1, 2, 3}, {4, 5}, {6, 7, 8, 9, 10}};\n        System.out.println(\"\\nBoxes: \");\n        printBoxes(boxes);\n        \n        boxes = new int[][]{{1, 2, 3, 4}, {5, 6, 7, 8, 9}, {10, 11, 12, 13, 14, 15}};\n        System.out.println(\"\\nBoxes: \");\n        printBoxes(boxes);\n    }\n\n    public static void printBoxes(int[][] boxes) {\n        for (int[] box : boxes) {\n            for (int i = 0; i < box.length; i++) {\n                if (i == box.length - 1 || box[i] + 1 != box[i+1]) {\n                    System.out.print(\"[\" + String.join(\", \", String.valueOf(box).split(\",\")[i].replace(\"[\", \"\").replace(\"]\", \"\")) + \"]\\n\");\n                } else {\n                    System.out.print(\"[\" + String.join(\", \", String.valueOf(box).split(\",\")[i].replace(\"[\", \"\").replace(\"]\", \"\") + \" - \");\n                }\n            }\n        }\n    }\n}",
  "1579": "```\nimport java.util.Arrays;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] graph = {{0,1},{1,2},{2,0}};\n        System.out.println(\"Max Edges: \" + maxEditsToKeepFullyTraversable(graph));\n        \n        graph = new int[][]{{0,1},{1,2},{2,3},{3,4}};\n        System.out.println(\"Max Edges: \" + maxEditsToKeepFullyTraversable(graph));\n\n        graph = {{0,1},{1,2},{2,3},{3,1}};\n        System.out.println(\"Max Edges: \" + maxEditsToKeepFullyTraversable(graph));\n    }\n\n    public static int maxEditsToKeepFullyTraversable(int[][] edges) {\n        // Implement your solution here\n        UnionFind unionFind = new UnionFind(edges.length);\n        \n        for (int[] edge : edges) {\n            unionFind.union(edge[0], edge[1]);\n        }\n        \n        Set<Integer> sets = unionFind.getSets();\n        int maxEdit = 0;\n        \n        for (Set<Integer> set : sets) {\n            maxEdit += set.size() - 1;\n        }\n        \n        return maxEdit / 2;\n    }\n\n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX != rootY) {\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX;\n                } else if (rank[rootX] < rank[rootY]) {\n                    parent[rootX] = rootY;\n                } else {\n                    parent[rootY] = rootX;\n                    rank[rootX]++;\n                }\n            }\n        }\n\n        public Set<Integer> getSets() {\n            Set<Integer> sets = new HashSet<>();\n            for (int i = 0; i < parent.length; i++) {\n                int root = find(i);\n                sets.add(root);\n            }\n            return sets;\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n    }\n}",
  "1581": "```\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\n\npublic class Solution {\n    public static void main(String[] args) {\n        ResultSet results = queryDB(\"SELECT * FROM Customers WHERE CustomerID NOT IN (SELECT CustomerID FROM Transactions)\");\n        \n        while(results.next()) {\n            System.out.println(\"Customer Name: \" + results.getString(\"Name\"));\n            System.out.println(\"Email: \" + results.getString(\"Email\"));\n            System.out.println();\n        }\n    }\n\n    public static ResultSet queryDB(String query) {\n        // Replace this with your actual database connection\n        Connection conn = null;\n        try {\n            conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/your_database\", \"username\", \"password\");\n            PreparedStatement stmt = conn.prepareStatement(query);\n            return stmt.executeQuery();\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (conn != null) {\n                try {\n                    conn.close();\n                } catch (SQLException e) {\n                    // ignore\n                }\n            }\n        }\n    }\n}",
  "1582": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] binaryMatrix = {{0,1},{1,0}};\n        System.out.println(\"Test case 1: \" + specialPositions(binaryMatrix));\n\n        int[][] binaryMatrix2 = {{0,0,1,1,0},{1,0,0,1,0},{0,1,1,1,1},{1,1,1,1,1},{1,1,1,0,0}};\n        System.out.println(\"Test case 2: \" + specialPositions(binaryMatrix2));\n\n        int[][] binaryMatrix3 = {{1,0,0},{0,0,1}};\n        System.out.println(\"Test case 3: \" + specialPositions(binaryMatrix3));\n    }\n\n    public static int specialPositions(int[][] mat) {\n        int count = 0;\n        for (int i = 0; i < mat.length; i++) {\n            for (int j = 0; j < mat[i].length; j++) {\n                if ((mat[i][j] == 1 && i == 0) || (mat[i][j] == 1 && j == 0) || (mat[i][j] == 1 && i == mat.length - 1) || (mat[i][j] == 1 && j == mat[0].length - 1)) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
  "1583": "```\npublic class Main {\n    public static void main(String[] args) {\n        int friends = friendPairs(new int[]{2, 2, 1}, 0);\n        System.out.println(friends);\n\n        friends = friendPairs(new int[]{1, 4}, 3);\n        System.out.println(friends);\n\n        friends = friendPairs(new int[]{5, 5, 5}, 2);\n        System.out.println(friends);\n    }\n\n    public static int friendPairs(int[] happiness, int maxBuddyCount) {\n        Arrays.sort(happiness);\n        int unhappyFriends = 0;\n        for (int i = 0; i < happiness.length - 1; i++) {\n            if (happiness[i] + happiness[i+1] <= maxBuddyCount) {\n                unhappyFriends++;\n                i++; // Skip the next friend\n            }\n        }\n        return unhappyFriends;\n    }\n}",
  "1585": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canTransform(\"bab\") + \" Expected: true\");\n        System.out.println(canTransform(\"aba\") + \" Expected: false\");\n        System.out.println(canTransform(\"aaabbbcccaaaa\") + \" Expected: true\");\n    }\n\n    public static boolean canTransform(String s) {\n        int start = 0;\n        for (int end = 0; end < s.length(); end++) {\n            while (start < end && s.charAt(start) <= s.charAt(end)) {\n                if (s.substring(start, end + 1).length() > 1 && !isSorted(s.substring(start, end + 1))) {\n                    return false;\n                }\n                start++;\n            }\n        }\n        return true;\n    }\n\n    public static boolean isSorted(String s) {\n        for (int i = 0; i < s.length() - 1; i++) {\n            if (s.charAt(i) > s.charAt(i + 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "1584": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] points1 = {{0,0},{2,2}};\n        System.out.println(\"Min cost for points1: \" + minCostToConnectAllPoints(points1));\n\n        int[][] points2 = {{0,1},{2,3},{3,2},{4,5},{5,4},{6,7}};\n        System.out.println(\"Min cost for points2: \" + minCostToConnectAllPoints(points2));\n\n        int[][] points3 = {{-1,-1},{0,0},{2,2}};\n        System.out.println(\"Min cost for points3: \" + minCostToConnectAllPoints(points3));\n    }\n\n    public static class UnionFind {\n        int[] parent;\n        int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX == rootY) {\n                return;\n            }\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n\n    public static int minCostToConnectAllPoints(int[][] points) {\n        int n = points.length;\n        UnionFind uf = new UnionFind(n);\n        List<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                Edge edge = new Edge(i, j, distance(points[i], points[j]));\n                edges.add(edge);\n            }\n        }\n        Collections.sort(edges);\n        int res = 0;\n        for (Edge e : edges) {\n            if (uf.find(e.from) != uf.find(e.to)) {\n                uf.union(e.from, e.to);\n                res += e.cost;\n            }\n        }\n        return res;\n    }\n\n    public static class Edge implements Comparable<Edge> {\n        int from;\n        int to;\n        int cost;\n\n        public Edge(int from, int to, int cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            return Integer.compare(this.cost, o.cost);\n        }\n    }\n\n    public static double distance(int[] p1, int[] p2) {\n        double dx = (double) p2[0] - p1[0];\n        double dy = (double) p2[1] - p1[1];\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n}",
  "1586": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(5);\n        root.left = new TreeNode(1);\n        root.right = new TreeNode(7);\n        root.left.left = new TreeNode(3);\n        root.left.right = new TreeNode(2);\n        root.right.left = new TreeNode(6);\n        root.right.right = new TreeNode(8);\n\n        BSTIterator iterator = new BSTIterator(root);\n\n        System.out.println(\"Test Case 1: Iterate from root to right\");\n        while (iterator.hasNext()) {\n            System.out.print(iterator.next() + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Test Case 2: Iterate from root to left\");\n        iterator.reset();\n        while (iterator.hasNext()) {\n            System.out.print(iterator.next() + \" \");\n        }\n        System.out.println();\n\n        System.out.println(\"Test Case 3: Iterate only right subtree\");\n        iterator.reset();\n        while (iterator.hasNext()) {\n            System.out.print(iterator.next() + \" \");\n        }\n        System.out.println();\n    }\n}\n```",
  "1587": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(sum(new int[][]{{1, 2}, {3, 4}})); // Expected output: [5, 6]\n        System.out.println(sum(new int[][]{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}})); // Expected output: [12, 15, 18]\n        System.out.println(sum(new int[][]{})); // Expected output: []\n    }\n\n    public static List<int[]> sum(int[][] accounts) {\n        List<int[]> result = new ArrayList<>();\n        for (int[] account : accounts) {\n            if (account.length > 0) {\n                int total = 0;\n                for (int transaction : account) {\n                    total += transaction;\n                }\n                result.add(new int[]{total, account.length});\n            }\n        }\n        return result;\n    }\n}\n```",
  "1589": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maximumSum(new int[]{2,7,9,4,3,7,10,8,2,10}) + \" expected: 39\");\n        System.out.println(maximumSum(new int[]{1,0,1,4}) + \" expected: 6\");\n        System.out.println(maximumSum(new int[]{1,2}) + \" expected: 3\");\n    }\n\n    public static int maximumSum(int[] nums) {\n        Arrays.sort(nums);\n        int maxSum = 0;\n        for (int i = 0; i < nums.length - 1; i++) {\n            maxSum += nums[i];\n        }\n        return maxSum;\n    }\n}",
  "1588": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfOddLengthSubarrays(new int[]{1,4,2,7,11,0})); // Expected: 18\n        System.out.println(sumOfOddLengthSubarrays(new int[]{1,1})); // Expected: 5\n        System.out.println(sumOfOddLengthSubarrays(new int[]{0})); // Expected: 0\n    }\n\n    public static int sumOfOddLengthSubarrays(int[] arr) {\n        int n = arr.length;\n        long res = 0;\n        for (int i = 0; i < n; i++) {\n            long prefixSum = 0;\n            for (int j = i; j < n; j++) {\n                if ((j - i + 1) % 2 == 1) { // check if the subarray length is odd\n                    prefixSum += arr[j];\n                    res += prefixSum;\n                }\n            }\n        }\n        return (int)res;\n    }\n}",
  "1590": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeDivide(9, [1,2,5])); // true\n        System.out.println(canBeDivide(2, [34,43,103,36,102,66,77,88,3,89])); // false\n        System.out.println(canBeDivide(6, [25,3,24,15,26,30])); // true\n    }\n\n    public static boolean canBeDivide(int P, int[] nums) {\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        if (sum % P != 0) return false;\n\n        int prefixSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            if (prefixSum % P == 0) continue;\n            for (int j = i + 1; j < nums.length; j++) {\n                prefixSum -= nums[j];\n                if (prefixSum % P == 0) return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "1591": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] A1 = {{1, 2, 3}, {0, 1}};\n        System.out.println(\"Expected: 4, Actual: \" + strangePrinterII(A1));\n        \n        int[][] A2 = {{1, 2, 3}, {1, 2}};\n        System.out.println(\"Expected: 5, Actual: \" + strangePrinterII(A2));\n\n        int[][] A3 = {{1, 2, 3}, {}};\n        System.out.println(\"Expected: 3, Actual: \" + strangePrinterII(A3));\n    }\n\n    public static int strangePrinterII(int[][] tapes) {\n        // Your solution here\n        return 0;\n    }\n}\n```",
  "1593": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxUniqueSubstrings(\"abc\"));\n        System.out.println(maxUniqueSubstrings(\"aabcc\")); \n        System.out.println(maxUniqueSubstrings(\"aba\"));\n    }\n\n    public static int maxUniqueSubstrings(String s) {\n        // Your code here\n    }\n}\n```",
  "1592": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(rearrangeSpaces(\"Hello   World\")); // Expected: \"HelloWorld\"\n        System.out.println(rearrangeSpaces(\"  Hi  world  \"));\n        System.out.println(rearrangeSpaces(\"a b     c\"));\n    }\n\n    public static String rearrangeSpaces(String s) {\n        StringBuilder sb = new StringBuilder();\n        int spaceCount = 0;\n        for (char c : s.toCharArray()) {\n            if (c == ' ') {\n                spaceCount++;\n            } else {\n                sb.append(c);\n                if (spaceCount > 0) {\n                    while (spaceCount-- > 0) {\n                        sb.append(' ');\n                    }\n                }\n            }\n        }\n        return sb.toString();\n    }\n}",
  "1595": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] connections = {{1, 6}, {2, 5}, {4, 7}};\n        System.out.println(minCostToConnectTwoGroups(connections));\n\n        connections = new int[][]{{1, 2, 5}, {1, 3, 10}, {2, 3, 15}};\n        System.out.println(minCostToConnectTwoGroups(connections));\n\n        connections = {{0, 1, 4}, {1, 2, 6}, {2, 3, 10}};\n        System.out.println(minCostToConnectTwoGroups(connections));\n    }\n\n    public static int minCostToConnectTwoGroups(int[][] connections) {\n        // your implementation here\n    }\n}\n```",
  "1594": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] matrix1 = {{-1,-2,-3},{0,0,4}};\n        System.out.println(\"Test case 1: \" + maxNonNegativeProduct(matrix1)); // Output: 8\n\n        int[][] matrix2 = {{2,0,-2},{0,3,0},{-5,0,6}};\n        System.out.println(\"Test case 2: \" + maxNonNegativeProduct(matrix2)); // Output: 6\n\n        int[][] matrix3 = {{0,1,2},{3,4,5},{6,7,8}};\n        System.out.println(\"Test case 3: \" + maxNonNegativeProduct(matrix3)); // Output: 120\n    }\n\n    public static int maxNonNegativeProduct(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) {\n            return 0;\n        }\n        int n = matrix[0].length;\n        int[] dp = new int[n];\n        dp[0] = matrix[0][0] >= 0 ? matrix[0][0] : 1;\n        for (int i = 1; i < n; i++) {\n            if (matrix[0][i] >= 0) {\n                dp[i] = matrix[0][i];\n            } else {\n                dp[i] = Math.max(dp[i - 1], matrix[0][i]);\n            }\n        }\n        int maxProduct = dp[n - 1];\n        for (int i = 1; i < matrix.length; i++) {\n            int[] newDp = new int[n];\n            newDp[0] = matrix[i][0] >= 0 ? matrix[i][0] : 1;\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][j] >= 0) {\n                    newDp[j] = matrix[i][j];\n                } else {\n                    newDp[j] = Math.max(newDp[j - 1], matrix[i][j]);\n                }\n            }\n            for (int j = 0; j < n; j++) {\n                if (dp[j] >= 0 && newDp[j] >= 0) {\n                    dp[j] *= newDp[j];\n                } else if (dp[j] < 0 || newDp[j] < 0) {\n                    dp[j] = Math.max(dp[j], newDp[j]);\n                }\n            }\n            maxProduct = Math.max(maxProduct, maxProduct(newDp));\n        }\n        return maxProduct;\n    }\n\n    public static int maxProduct(int[] arr) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        dp[0] = arr[0];\n        for (int i = 1; i < n; i++) {\n            if (arr[i] >= 0) {\n                dp[i] = arr[i];\n            } else {\n                dp[i] = Math.max(dp[i - 1], arr[i]);\n            }\n        }\n        int maxProduct = dp[n - 1];\n        for (int i = 1; i < n; i++) {\n            if (dp[i - 1] >= 0 && arr[i] >= 0) {\n                dp[i] *= arr[i];\n            } else if (dp[i - 1] < 0 || arr[i] < 0) {\n                dp[i] = Math.max(dp[i], arr[i]);\n            }\n        }\n        return maxProduct;\n    }\n}",
  "1597": "```\npublic class Main {\n    public static void main(String[] args) {\n        String s1 = \"A*B+C\";\n        BuildTree buildTree1 = new BuildTree(s1);\n        buildTree1.build();\n        System.out.println(\"Test case 1: \");\n        buildTree1.print();\n\n        String s2 = \"(A+B)*(C-D)\";\n        BuildTree buildTree2 = new BuildTree(s2);\n        buildTree2.build();\n        System.out.println(\"\\nTest case 2: \");\n        buildTree2.print();\n\n        String s3 = \"A+(B+C)*D\";\n        BuildTree buildTree3 = new BuildTree(s3);\n        buildTree3.build();\n        System.out.println(\"\\nTest case 3: \");\n        buildTree3.print();\n    }\n}\n```",
  "1596": "```\nimport org.junit.Test;\n\npublic class Solution {\n    public List<List<String>> mostPopular(String[] customers, String[] orders) {\n        // Your solution here\n        Map<String, Map<String, Integer>> customerOrders = new HashMap<>();\n        for (int i = 0; i < orders.length; i++) {\n            String customer = customers[i];\n            String product = orders[i];\n            if (!customerOrders.containsKey(customer)) {\n                customerOrders.put(customer, new HashMap<>());\n            }\n            customerOrders.get(customer).put(product, customerOrders.getOrDefault(customer, Map::newHashMap).getOrDefault(product, 0) + 1);\n        }\n        List<List<String>> result = new ArrayList<>();\n        for (Map.Entry<String, Map<String, Integer>> entry : customerOrders.entrySet()) {\n            List<String> products = new ArrayList<>(entry.getValue().entrySet().stream()\n                    .sorted((a, b) -> Integer.compare(b.getValue(), a.getValue()))\n                    .map(Map.Entry::getKey)\n                    .collect(Collectors.toList()));\n            result.add(products);\n        }\n        return result;\n    }\n\n    @Test\n    public void test1() {\n        String[] customers = {\"John\", \"John\", \"Mary\", \"Jane\", \"Jane\"};\n        String[] orders = {\"Fishing Rod\", \"Shirt\", \"T-Shirt\", \"T-Shirt\", \"Fishing Rod\"};\n        List<List<String>> expected = Arrays.asList(Arrays.asList(\"Fishing Rod\", \"T-Shirt\"), Arrays.asList(\"Shirt\"));\n        assertArrayEquals(expected.toArray(), new Solution().mostPopular(customers, orders).toArray());\n    }\n\n    @Test\n    public void test2() {\n        String[] customers = {\"John\", \"Jane\", \"Jane\"};\n        String[] orders = {\"Fishing Rod\", \"T-Shirt\", \"Shoes\"};\n        List<List<String>> expected = Arrays.asList(Arrays.asList(\"Fishing Rod\"), Arrays.asList(\"T-Shirt\", \"Shoes\"));\n        assertArrayEquals(expected.toArray(), new Solution().mostPopular(customers, orders).toArray());\n    }\n\n    @Test\n    public void test3() {\n        String[] customers = {\"John\", \"Mary\"};\n        String[] orders = {\"Fishing Rod\", \"Shirt\", \"T-Shirt\", \"Shoes\"};\n        List<List<String>> expected = Arrays.asList(Arrays.asList(\"Fishing Rod\"), Arrays.asList(\"Shirt\", \"T-Shirt\", \"Shoes\"));\n        assertArrayEquals(expected.toArray(), new Solution().mostPopular(customers, orders).toArray());\n    }\n\n    public static void main(String[] args) {\n        String[] customers = {\"John\", \"John\", \"Mary\", \"Jane\", \"Jane\"};\n        String[] orders = {\"Fishing Rod\", \"Shirt\", \"T-Shirt\", \"T-Shirt\", \"Fishing Rod\"};\n        List<List<String>> result = new Solution().mostPopular(customers, orders);\n        for (List<String> products : result) {\n            System.out.println(products);\n        }\n    }\n}",
  "1598": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minOperations(new String[]{\"day33\",\"is\", \"such\", \"an Awesome\", \"day!\"})); // Expected output: 4\n        System.out.println(minOperations(new String[]{\"code\", \"lift\", \"left\", \"lift\", \"right\", \"right\"})); // Expected output: 3\n        System.out.println(minOperations(new String[]{})); // Expected output: 0\n    }\n\n    public static int minOperations(String[] logs) {\n        int maxLevel = 0;\n        for (String log : logs) {\n            if (!log.equals(\".)\")) { // If the log is not a closing parenthesis\n                maxLevel = Math.max(maxLevel, log.length());\n            } else { // If the log is a closing parenthesis\n                maxLevel--;\n            }\n        }\n        return maxLevel;\n    }\n}\n```",
  "1599": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + maxProfit(new int[]{8, 10, 6, 4, 7, 9}) + \"\\n\");\n        System.out.println(\"Test Case 2: \" + maxProfit(new int[]{1, 3, 5, 2, 7, 2}) + \"\\n\");\n        System.out.println(\"Test Case 3: \" + maxProfit(new int[]{10, 6, 8, 9, 7, 4}) + \"\\n\");\n    }\n\n    public static int maxProfit(int[] prices) {\n        if (prices.length < 2) {\n            return 0;\n        }\n        int maxSoFar = 0;\n        for (int i = 1; i < prices.length; i++) {\n            if (prices[i] > prices[i - 1]) {\n                maxSoFar += prices[i] - prices[i - 1];\n            }\n        }\n        return maxSoFar;\n    }\n}\n```",
  "1600": "```\npublic class Main {\n    public static void main(String[] args) {\n        ThroneInheritance ti = new ThroneInheritance(\"root\");\n        ti.becomeKing(\"a\");\n\n        System.out.println(ti.getPreOrder());\n        System.out.println();\n\n        ti.becomeKing(\"c\");\n        System.out.println(ti.getPreOrder());\n\n        ti.becomeKing(\"b\");\n        System.out.println(ti.getPreOrder());\n    }\n}\n```",
  "1601": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxRequests(new int[]{2,5,10}, 1)); // Expected: 4\n        System.out.println(maxRequests(new int[]{2,5,10,3}, 0)); // Expected: 7\n        System.out.println(maxRequests(new int[]{4,5,6}, 1)); // Expected: 3\n    }\n\n    public static int maxRequests(int[] timePoints, int maxMinutes) {\n        Arrays.sort(timePoints);\n        int res = 0;\n        for (int i = 0; i < timePoints.length; i++) {\n            if (timePoints[i] <= maxMinutes && timePoints[i] + timePoints[i] > maxMinutes) {\n                res++;\n                maxMinutes -= timePoints[i];\n            } else {\n                break;\n            }\n        }\n        return res;\n    }\n}",
  "1602": "```\nimport java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Solution {\n    public final TreeNode getRightMostNode(TreeNode node) {\n        while (node.right != null) {\n            node = node.right;\n        }\n        return node;\n    }\n\n    public final TreeNode findNearestRightNode(TreeNode root, TreeNode node) {\n        if (root == null || root.val == node.val) return null;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode current = queue.poll();\n                if (current == node) return getRightMostNode(current);\n                if (current.right != null) queue.add(current.right);\n                if (current.left != null) queue.add(current.left);\n            }\n        }\n\n        return null;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(5);\n        root1.right = new TreeNode(1);\n        root1.left.left = new TreeNode(6);\n        root1.left.right = new TreeNode(2);\n        root1.right.right = new TreeNode(0);\n        TreeNode node1 = root1.left;\n        System.out.println(solution.findNearestRightNode(root1, node1).val);\n\n        // Test case 2\n        TreeNode root2 = new TreeNode(3);\n        root2.right = new TreeNode(5);\n        root2.right.left = new TreeNode(2);\n        TreeNode node2 = root2.right.left;\n        System.out.println(solution.findNearestRightNode(root2, node2).val);\n\n        // Test case 3\n        TreeNode root3 = new TreeNode(1);\n        TreeNode node3 = null;\n        System.out.println(solution.findNearestRightNode(root3, node3));\n    }\n}",
  "1603": "```\npublic class Main {\n    public static void main(String[] args) {\n        ParkingSystem system = new ParkingSystem(1);\n        System.out.println(system.addCar(1)); // Expected output: 0\n        System.out.println(system.addCar(2)); // Expected output: 1\n        System.out.println(system.addCar(3)); // Expected output: 1\n\n        system = new ParkingSystem(2);\n        System.out.println(system.addCar(1)); // Expected output: 0\n        System.out.println(system.addCar(2)); // Expected output: 1\n        System.out.println(system.addCar(3)); // Expected output: 2\n    }\n}\n```",
  "1604": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] keyTimePairs = {{1,2},{3,4},{9,10}};\n        System.out.println(alert(keyTimePairs));\n\n        keyTimePairs = new int[][]{{1,2},{2,3}};\n        System.out.println(alert(keyTimePairs));\n\n        keyTimePairs = new int[][]{ {1, 2 }, {7,8}, {15,16} };\n        System.out.println(alert(keyTimePairs));\n    }\n\n    public static int alert(int[][] keyTimePairs) {\n        HashMap<Integer, Integer> cardCountMap = new HashMap<>();\n        for (int[] pair : keyTimePairs) {\n            int time = pair[1] - pair[0];\n            if (!cardCountMap.containsKey(time)) {\n                cardCountMap.put(time, 1);\n            } else {\n                cardCountMap.put(time, cardCountMap.get(time) + 1);\n            }\n        }\n\n        for (int count : cardCountMap.values()) {\n            if (count >= 3) {\n                return time;\n            }\n        }\n        return -1;\n    }\n}\n```",
  "1605": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] rowSums = {{5, 7}, {7, 3}};\n        int[][] columnSums = {{4, 8}, {4, 7}};\n        System.out.println(Arrays.deepToString(findValidMatrix(rowSums, columnSums)));\n\n        rowSums = new int[][]{{10, 10, 20}, {10, 30, 10}};\n        columnSums = new int[][]{{15, 17, 8}, {5, 13, 12}};\n        System.out.println(Arrays.deepToString(findValidMatrix(rowSums, columnSums)));\n\n        rowSums = {{3, 7, 1, 4, 2}, {1, 2, 6, 2, 3}, {9, 2, 8, 5, 7}};\n        columnSums = new int[][]{{10, 12, 6, 7, 9}, {14, 16, 17, 15, 4}, {13, 1, 11, 3, 2}};\n        System.out.println(Arrays.deepToString(findValidMatrix(rowSums, columnSums)));\n    }\n\n    public static int[][] findValidMatrix(int[][] rowSums, int[][] columnSums) {\n        if (rowSums.length != columnSums[0].length) {\n            return new int[][]{};\n        }\n        int m = rowSums.length;\n        int n = columnSums[0].length;\n        int[][] matrix = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0) {\n                    matrix[i][j] = columnSums[0][j];\n                } else if (j == 0) {\n                    matrix[i][j] = rowSums[i - 1][0];\n                } else {\n                    int remainingRowSum = rowSums[i - 1][j];\n                    int remainingColumnSum = columnSums[i][j];\n                    while (remainingRowSum > 0 && remainingColumnSum > 0) {\n                        matrix[i][j] = Math.min(remainingRowSum, remainingColumnSum);\n                        remainingRowSum -= matrix[i][j];\n                        remainingColumnSum -= matrix[i][j];\n                    }\n                    if (remainingRowSum < 0 || remainingColumnSum < 0) {\n                        return new int[][]{};\n                    }\n                }\n            }\n        }\n        return matrix;\n    }\n}\n```",
  "1606": "```\nimport java.util.*;\n\npublic class Solution {\n    public int[] highFive(int[][] ops) {\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int i = 0; i < ops.length; i++) {\n            int id = ops[i][1];\n            int score = ops[i][2];\n            if (!map.containsKey(id)) {\n                map.put(id, new ArrayList<>());\n            }\n            map.get(id).add(score);\n        }\n\n        List<int[]> result = new ArrayList<>();\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\n            Collections.sort(entry.getValue(), Comparator.reverseOrder());\n            int sum = 0;\n            for (int i = 0; i < Math.min(5, entry.getValue().size()); i++) {\n                sum += entry.getValue().get(i);\n            }\n            result.add(new int[]{entry.getKey(), sum});\n        }\n\n        Collections.sort(result, Comparator.comparingInt(a -> a[1], Comparator.reverseOrder()));\n        return Arrays.stream(result.toArray()).mapToInt(intArray -> intArray[0]).toArray();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        int[][] ops1 = {{5,1,100},{4,3,200},{2,5,300},{1,4,400}};\n        System.out.println(Arrays.toString(solution.highFive(ops1)));\n\n        // Test case 2\n        int[][] ops2 = {{1,17,700],[2,11,150},{3,15,550},{4,6,1000},{1,10,200},{5,13,650},{1,7,400],[2,12,300],[3,8,750],[4,9,250}};\n        System.out.println(Arrays.toString(solution.highFive(ops2)));\n\n        // Test case 3\n        int[][] ops3 = {{1,20,7000},{2,10,10000},{3,5,5000}};\n        System.out.println(Arrays.toString(solution.highFive(ops3)));\n    }\n}",
  "1607": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] sales = {{1, 2}, {2, 4}, {1, 5}};\n        System.out.println(\"Sellers with no sales: \" + Arrays.toString(solution.sellersWithNoSales(sales)));\n        \n        int[][] sales2 = {{1, 3}, {2, 4}};\n        System.out.println(\"Sellers with no sales: \" + Arrays.toString(solution.sellersWithNoSales(sales2)));\n        \n        int[][] sales3 = {};\n        System.out.println(\"Sellers with no sales: \" + Arrays.toString(solution.sellersWithNoSales(sales3)));\n    }\n}\n\nclass Solution {\n    public List<Integer> sellersWithNoSales(int[][] sales) {\n        Map<Integer, Integer> sellerMap = new HashMap<>();\n        for (int[] sale : sales) {\n            int seller = sale[0];\n            if (!sellerMap.containsKey(seller)) {\n                sellerMap.put(seller, 0);\n            }\n            sellerMap.put(seller, sellerMap.get(seller) + 1);\n        }\n        \n        List<Integer> noSalesSellers = new ArrayList<>();\n        for (int seller : sellerMap.keySet()) {\n            if (sellerMap.get(seller) == 0) {\n                noSalesSellers.add(seller);\n            }\n        }\n        \n        return noSalesSellers;\n    }\n}\n```",
  "1608": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numSpecialEquiv(new int[]{2,1,3}, 2)); // Expected: true\n        System.out.println(numSpecialEquiv(new int[]{4,3,2,5,8}, 3)); // Expected: false\n        System.out.println(numSpecialEquiv(new int[]{1,1,2,3,5}, 10)); // Expected: true\n    }\n\n    public static boolean numSpecialEquiv(int[] nums, int X) {\n        int[] odd = new int[X], even = new int[X];\n        for (int i : nums) {\n            if ((i & 1) == 0) even[i / 2]++;\n            else odd[i / 2]++;\n        }\n        for (int i : odd) if (i > 0) return false;\n        for (int i : even) if (i > 1) return false;\n        return true;\n    }\n}\n```",
  "1609": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(1);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(3);\n        root1.left.left = new TreeNode(4);\n        root1.left.right = new TreeNode(5);\n        root1.right.right = new TreeNode(6);\n\n        System.out.println(\"Test Case 1:\");\n        EvenOddTree tree1 = new EvenOddTree(root1);\n        printLevelOrder(tree1.root, \"Even Odd Tree: \");\n        System.out.println();\n\n        TreeNode root2 = new TreeNode(1);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(4);\n\n        System.out.println(\"Test Case 2:\");\n        EvenOddTree tree2 = new EvenOddTree(root2);\n        printLevelOrder(tree2.root, \"Even Odd Tree: \");\n        System.out.println();\n\n        TreeNode root3 = null;\n\n        System.out.println(\"Test Case 3:\");\n        EvenOddTree tree3 = new EvenOddTree(root3);\n        printLevelOrder(tree3.root, \"Even Odd Tree: \");\n        System.out.println();\n    }\n\n    public static void printLevelOrder(TreeNode root, String message) {\n        if (root == null) return;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                System.out.print(node.val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n```",
  "1610": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxVisiblePoints(new int[][]{{2,8},{9,12},{5,7},{6,8}}, new int[]{1,1,2,8})); // Test case 1: Expected output = 4\n        System.out.println(maxVisiblePoints(new int[][]{{1,3},{2,3}}, new int[]{5,2,2})); // Test case 2: Expected output = 3\n        System.out.println(maxVisiblePoints(new int[][]{{10,14},{11,15},{12,16},{13,17}}, new int[]{5,1,6,8})); // Test case 3: Expected output = 4\n    }\n\n    public static int maxVisiblePoints(int[][] radiusRecords, int[] points) {\n        Arrays.sort(radiusRecords, (a, b) -> a[0] - b[0]);\n        int maxCount = 0;\n        for (int i = 0; i < radiusRecords.length; i++) {\n            int left = i - 1 >= 0 ? i - 1 : -1;\n            int right = i + 1;\n            while (right < radiusRecords.length && radiusRecords[right][0] == radiusRecords[i][0]) {\n                right++;\n            }\n            for (int j = 0; j <= right - left; j++) {\n                if ((radiusRecords[i][1] >= points[j] - radiusRecords[i][1] && radiusRecords[i][1] + radiusRecords[i][1] <= points[j])) {\n                    maxCount++;\n                }\n            }\n        }\n        return maxCount;\n    }\n}\n```",
  "1611": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minOneBitOperations(5)); // Output: 2\n        System.out.println(minOneBitOperations(10)); // Output: 4\n        System.out.println(minOneBitOperations(3)); // Output: 1\n    }\n\n    public static int minOneBitOperations(int n) {\n        if (n == 0) return 0;\n        int operations = 0, lastOperationIsOne = true;\n        while (n > 0) {\n            if ((n & 1) == 1 && !lastOperationIsOne || (n & 2) == 2) {\n                n >>= 1;\n                operations++;\n                lastOperationIsOne = false;\n            } else {\n                n >>>= 1;\n                lastOperationIsOne = true;\n            }\n        }\n        return operations;\n    }\n}\n```",
  "1613": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        List<Interval> intervals1 = new ArrayList<>();\n        intervals1.add(new Interval(0, 5));\n        intervals1.add(new Interval(7, 10));\n        intervals1.add(new Interval(6, 8));\n\n        System.out.println(\"Missing IDs for intervals1: \" + findMissingIds(intervals1));\n\n        List<Interval> intervals2 = new ArrayList<>();\n        intervals2.add(new Interval(3, 5));\n        intervals2.add(new Interval(4, 7));\n\n        System.out.println(\"Missing IDs for intervals2: \" + findMissingIds(intervals2));\n\n        List<Interval> intervals3 = new ArrayList<>();\n        intervals3.add(new Interval(1, 2));\n        intervals3.add(new Interval(2, 3));\n        intervals3.add(new Interval(4, 5));\n\n        System.out.println(\"Missing IDs for intervals3: \" + findMissingIds(intervals3));\n    }\n\n    public static List<Integer> findMissingIds(List<Interval> intervals) {\n        Set<Integer> ids = new HashSet<>();\n        for (Interval interval : intervals) {\n            for (int i = interval.start; i <= interval.end; i++) {\n                ids.add(i);\n            }\n        }\n        List<Integer> missingIds = new ArrayList<>();\n        for (int i = 0; i < Integer.MAX_VALUE; i++) {\n            if (!ids.contains(i)) {\n                missingIds.add(i);\n            } else {\n                break;\n            }\n        }\n        return missingIds;\n    }\n\n    static class Interval {\n        int start;\n        int end;\n\n        public Interval(int start, int end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n}",
  "1612": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(2);\n        root1.left = new TreeNode(1);\n        root1.right = new TreeNode(3);\n\n        TreeNode root2 = new TreeNode(2);\n        root2.left = new TreeNode(1);\n        root2.right = new TreeNode(3);\n\n        System.out.println(canBeEquivalent(root1, root2)); // true\n\n        root1 = null;\n        root2 = null;\n\n        System.out.println(canBeEquivalent(root1, root2)); // true\n\n        root1 = new TreeNode(2);\n        root1.left = new TreeNode(3);\n        root1.right = new TreeNode(3);\n\n        root2 = new TreeNode(2);\n        root2.left = new TreeNode(4);\n        root2.right = new TreeNode(5);\n\n        System.out.println(canBeEquivalent(root1, root2)); // false\n    }\n\n    public static boolean canBeEquivalent(TreeNode root1, TreeNode root2) {\n        if (root1 == null && root2 == null) return true;\n        if (root1 == null || root2 == null) return false;\n\n        Map<String, Integer> map = new HashMap<>();\n        dfs(root1, \"\", map);\n        dfs(root2, \"\", map);\n\n        return root1.val == root2.val && map.getOrDefault(\"0\", 0).equals(map.getOrDefault(\"1\", 0));\n    }\n\n    public static void dfs(TreeNode node, String path, Map<String, Integer> map) {\n        if (node == null) return;\n        int count = (path.charAt(0) == '0') ? 1 : 0;\n        for (int i = 1; i <= path.length(); i++) {\n            String s = path.substring(0, i);\n            map.put(s, map.getOrDefault(s, 0) + count);\n            if (i < path.length()) {\n                count += (path.charAt(i) == '0') ? 1 : 0;\n            }\n        }\n    }\n\n    public static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        public TreeNode(int x) { val = x; }\n    }\n}",
  "1614": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxDepth(\"1+(2+3)+(()((()))))\")); // Expected: 6\n        System.out.println(maxDepth(\"(a+b)\") ); // Expected: 2\n        System.out.println(maxDepth(\"1 >= 2-3-4\") ); // Expected: 2\n    }\n\n    public static int maxDepth(String s) {\n        int depth = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                depth++;\n            } else if (s.charAt(i) == ')') {\n                depth--;\n            }\n        }\n        return Math.abs(depth);\n    }\n}",
  "1616": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canMakePalindrome(\"aab\", \"cd\")); // true\n        System.out.println(canMakePalindrome(\"abcd\", \"efgh\")); // false\n        System.out.println(canMakePalindrome(\"a\", \"b\")); // true\n    }\n\n    public static boolean canMakePalindrome(String s1, String s2) {\n        int i = 0, j = 0;\n        while (i < s1.length() && j < s2.length()) {\n            if (s1.charAt(i) == s2.charAt(j)) {\n                i++;\n                j++;\n            } else if (s1.charAt(i) != s2.charAt(j)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1615": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] roads = new int[][]{{0,1},{0,2},{1,2}};\n        System.out.println(\"Expected: 4, Got: \" + maximalNetworkRank(5, roads));\n        \n        roads = new int[][]{{0,1},{1,2},{2,3},{1,3}};\n        System.out.println(\"Expected: 4, Got: \" + maximalNetworkRank(4, roads));\n\n        roads = new int[][]{{0,1},{1,2},{2,3},{3,1},{1,3}};\n        System.out.println(\"Expected: 4, Got: \" + maximalNetworkRank(4, roads));\n    }\n\n    public static int maximalNetworkRank(int n, int[][] roads) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] road : roads) {\n            graph.get(road[0]).add(road[1]);\n            graph.get(road[1]).add(road[0]);\n        }\n\n        int maxRank = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (!graph.get(i).contains(j)) {\n                    int rank = graph.get(i).size() + graph.get(j).size();\n                    maxRank = Math.max(maxRank, rank);\n                }\n            }\n        }\n\n        return maxRank;\n    }\n}",
  "1617": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countMaxDistance(new TreeNode(1), new int[][] {{0, 1}}));\n        System.out.println(countMaxDistance(new TreeNode(2, 0, null), new int[][] {{0, 1}, {1, 3}}));\n        System.out.println(countMaxDistance(null, new int[][] {}));\n    }\n\n    public static class TreeNode {\n        int val;\n        TreeNode left;\n        TreeNode right;\n\n        public TreeNode(int x) {\n            val = x;\n        }\n\n        public TreeNode(int x, int y, TreeNode z) {\n            this(x);\n            left = new TreeNode(y, x, null);\n            right = z;\n        }\n    }\n\n    public static int countMaxDistance(TreeNode root, int[][] edges) {\n        // Your code here\n    }\n}\n```",
  "1618": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxFont(\"short sentence\", new int[]{10, 12}, 6));\n        System.out.println(maxFont(\"How are you?\", new int[]{4, 6, 8}, 3));\n        System.out.println(maxFont(\"This is a test.\", new int[]{1, 2, 3, 4, 5}, 7));\n    }\n\n    public static int maxFont(String sentence, int[] fonts, int w) {\n        int left = 0;\n        int right = fonts.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (canPrint(sentence, fonts, mid, w)) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    public static boolean canPrint(String sentence, int[] fonts, int fontIndex, int w) {\n        String wordList[] = sentence.split(\" \");\n        for (int i = 0; i < wordList.length; i++) {\n            if (wordList[i].length() * fonts[fontIndex] > w) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1619": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + mean(new int[]{2, 5, 7, 2, 4, 6})); // Expected output: 3.5\n        System.out.println(\"Test case 2: \" + mean(new int[]{0, 4, 4})); // Expected output: 2.0\n        System.out.println(\"Test case 3: \" + mean(new int[]{1, 12})); // Expected output: 6.5\n    }\n\n    public static double mean(int[] nums) {\n        Arrays.sort(nums);\n        int sum = 0;\n        for (int i = (nums.length / 2) - 1; i < nums.length / 2 + 2; i++) {\n            sum += nums[i];\n        }\n        return (double) sum / 3;\n    }\n}",
  "1620": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{5, 1, 6}, {3, 4, 2}, {1, 7, 8}};\n        System.out.println(maxQuality(grid1)); // Output: 16\n        \n        int[][] grid2 = {{0, 0, 0}, {2, 2, 2}};\n        System.out.println(maxQuality(grid2)); // Output: 4\n\n        int[][] grid3 = {{9, 8, 7}, {6, 5, 4}, {3, 2, 1}};\n        System.out.println(maxQuality(grid3)); // Output: 25\n    }\n\n    public static int maxQuality(int[][] grid) {\n        int n = grid.length;\n        int[] dx = {-1, 0, 1};\n        int[] dy = {-1, 0, 1};\n\n        int maxQuality = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k : dx) {\n                    for (int l : dy) {\n                        if (i + k >= 0 && i + k < n && j + l >= 0 && j + l < n) {\n                            maxQuality = Math.max(maxQuality, grid[i][j] * grid[i + k][j + l]);\n                        }\n                    }\n                }\n            }\n        }\n\n        return maxQuality;\n    }\n}\n```",
  "1621": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numOfSets(2, 4)); // Test case 1: K = 2, n = 4\n        System.out.println(numOfSets(5, 6)); // Test case 2: K = 5, n = 6\n        System.out.println(numOfSets(10, 13)); // Test case 3: K = 10, n = 13\n    }\n\n    public static int numOfSets(int k, int n) {\n        if (k == 0) return 1;\n        if (n < k) return 0;\n\n        int[][] dp = new int[n + 1][k + 1];\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = 1;\n        }\n        for (int j = 1; j <= k; j++) {\n            for (int i = j; i <= n; i++) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1];\n            }\n        }\n\n        return dp[n][k];\n    }\n}\n```",
  "1622": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {4, 5, 2, 3};\n        System.out.println(\"Test case 1: \" + fancySequence(nums1));\n        \n        int[] nums2 = {10, 9, 8, 7};\n        System.out.println(\"Test case 2: \" + fancySequence(nums2));\n        \n        int[] nums3 = {1, 2};\n        System.out.println(\"Test case 3: \" + fancySequence(nums3));\n    }\n\n    public static long fancySequence(int[] nums) {\n        // your code here\n        return 0;\n    }\n}\n```",
  "1623": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] country = { { 1, 2 }, { 0, 1 }, { 3, 4 } };\n        System.out.println(triplets(country));\n        \n        int[][] country2 = { { 5, 6 }, { 7, 8 } };\n        System.out.println(triplets(country2));\n        \n        int[][] country3 = { { 1, 2 }, { 0, 1 }, { 3, 4 }, { 4, 5 } };\n        System.out.println(triplets(country3));\n    }\n\n    public static List<List<Integer>> triplets(int[][] country) {\n        List<List<Integer>> result = new ArrayList<>();\n        for (int i = 0; i < country.length; i++) {\n            for (int j = i + 1; j < country.length; j++) {\n                if (!contains(country[i], country[j])) {\n                    result.add(Arrays.asList(country[i][0], country[j][0]));\n                }\n            }\n        }\n        return result;\n    }\n\n    public static boolean contains(int[] a, int[] b) {\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] == b[0] || a[i] == b[1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "1624": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxSubstr(\"aaabaab!\")); // expected: \"baa\"\n        System.out.println(maxSubstr(\"abcde\")); // expected: \"\"\n        System.out.println(maxSubstr(\"aabccaaa\")); // expected: \"aabccaa\"\n    }\n\n    public static String maxSubstr(String s) {\n        Map<Character, Integer> charIndexMap = new HashMap<>();\n        int start = 0;\n        int maxLength = 0;\n        String result = \"\";\n\n        for (int i = 0; i < s.length(); i++) {\n            if (!charIndexMap.containsKey(s.charAt(i))) {\n                charIndexMap.put(s.charAt(i), i);\n            } else {\n                while (s.charAt(i) == charIndexMap.get(s.charAt(i))) {\n                    start = charIndexMap.get(s.charAt(i)) + 1;\n                    break;\n                }\n                charIndexMap.put(s.charAt(i), i);\n            }\n\n            if (i - start > maxLength) {\n                maxLength = i - start;\n                result = s.substring(start, i + 1);\n            }\n        }\n\n        return result;\n    }\n}\n```",
  "1625": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(solve(\"cba\", 7)); // expected output: \"acb\"\n        System.out.println(solve(\"aaabcc\", 1)); // expected output: \"abc\"\n        System.out.println(solve(\"aaa\", 2)); // expected output: \"cab\"\n    }\n\n    public static String solve(String S, int K) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < S.length(); i++) {\n            if (i < K) {\n                char c = S.charAt(i);\n                while (sb.length() > 0 && c <= sb.charAt(sb.length() - 1)) {\n                    sb.deleteCharAt(sb.length() - 1);\n                }\n                sb.append(c);\n            } else {\n                if (sb.length() == 0 || S.charAt(i) >= sb.charAt(sb.length() - 1)) {\n                    sb.append(S.charAt(i));\n                }\n            }\n        }\n        return sb.toString();\n    }\n}",
  "1626": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] team = new int[][]{{1, 1}, {2, 5}, {3, 8}};\n        System.out.println(\"Expected: 9\\nActual: \" + bestTeamScore(team));\n        \n        team = new int[][]{{0, 2}, {1, 4}, {2, 7}, {3, 6}};\n        System.out.println(\"Expected: 12\\nActual: \" + bestTeamScore(team));\n\n        team = new int[][]{{5, 10}, {6, 15}, {7, 9}, {8, 20}, {9, 25}};\n        System.out.println(\"Expected: 36\\nActual: \" + bestTeamScore(team));\n    }\n\n    public static int bestTeamScore(int[][] scores) {\n        int n = scores.length;\n        int[] dp = new int[n];\n        int[] teamScores = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            teamScores[i] = scores[i][1];\n        }\n        \n        Arrays.sort(teamScores);\n        \n        dp[0] = teamScores[0];\n        \n        for (int i = 1; i < n; i++) {\n            if (scores[i][0] > teamScores[i - 1]) {\n                dp[i] = Math.max(dp[i - 1], teamScores[i]);\n            } else {\n                dp[i] = teamScores[i];\n            }\n        }\n        \n        int maxScore = 0;\n        for (int i = 0; i < n; i++) {\n            maxScore = Math.max(maxScore, dp[i]);\n        }\n        \n        return maxScore;\n    }\n}\n```",
  "1627": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] edges = {{0,1,10},{0,2,15},{1,2,6}};\n        int threshold = 20;\n        System.out.println(\"Are connected: \" + connected(edges, threshold));\n        \n        edges = new int[][]{{0,1,10},{0,2,5},{1,2,4}};\n        threshold = 14;\n        System.out.println(\"Are connected: \" + connected(edges, threshold));\n        \n        edges = new int[][]{{0,1,10},{0,2,2},{1,2,3}};\n        threshold = 6;\n        System.out.println(\"Are connected: \" + connected(edges, threshold));\n    }\n\n    public static boolean connected(int[][] edges, int threshold) {\n        if (edges == null || edges.length < 1) return true;\n\n        int n = edges[0].length;\n        DisjointSet ds = new DisjointSet(n);\n        \n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1];\n            if (edge[2] <= threshold) {\n                ds.union(u, v);\n            }\n        }\n\n        return ds.getSize() == 1;\n    }\n}\n\nclass DisjointSet {\n    private int[] parent;\n\n    public DisjointSet(int n) {\n        this.parent = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    public void union(int u, int v) {\n        if (parent[u] != parent[v]) {\n            parent[find(u)] = find(v);\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public int getSize() {\n        Set<Integer> set = new HashSet<>();\n        for (int i = 0; i < parent.length; i++) {\n            set.add(find(i));\n        }\n        return set.size();\n    }\n}",
  "1628": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        ExpressionTree tree = new ExpressionTree();\n        System.out.println(tree.evaluate(\"3+2*2\")); // 7\n        System.out.println(tree.evaluate(\"(1+1)*2\")); // 4\n        System.out.println(tree.evaluate(\"0+(5-2*2)\")); // 1\n    }\n}\n\nclass Node {\n    char val;\n    Node left, right;\n\n    public Node(char v) {\n        val = v;\n    }\n}\n\nclass ExpressionTree {\n    private Node root;\n\n    public int evaluate(String s) {\n        this.root = parse(s);\n        return eval(root);\n    }\n\n    private Node parse(String s) {\n        Stack<Node> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                stack.push(new Node(c));\n            } else if (c == '+') {\n                while (!stack.isEmpty() && stack.peek().val == '+') {\n                    stack.pop();\n                }\n                if (!stack.isEmpty()) {\n                    stack.push(new Node('+'));\n                }\n            } else if (c == '-') {\n                while (!stack.isEmpty() && (stack.peek().val == '+' || stack.peek().val == '-')) {\n                    stack.pop();\n                }\n                if (!stack.isEmpty()) {\n                    stack.push(new Node('-'));\n                }\n            } else if (c == '(') {\n                stack.push(new Node('('));\n            } else if (c == ')') {\n                while (!stack.isEmpty() && stack.peek().val != '(') {\n                    stack.pop();\n                }\n                if (!stack.isEmpty() && stack.peek().val == '(') {\n                    stack.pop();\n                }\n            }\n        }\n        return stack.isEmpty() ? null : stack.pop();\n    }\n\n    private int eval(Node node) {\n        if (node.val == '+') {\n            return eval(node.left) + eval(node.right);\n        } else if (node.val == '-') {\n            return eval(node.left) - eval(node.right);\n        } else {\n            return Character.getNumericValue(node.val);\n        }\n    }\n}",
  "1629": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(new Solution().slowestKey(new String[]{\"a\", \"a\"}, 1).charAt(0));\n        System.out.println(new Solution().slowestKey(new String[]{\"b\", \"c\"}, 1).charAt(0));\n        System.out.println(new Solution().slowestKey(new String[]{\"leetcode\", \"playfair\", \"weakpassword\"}, 3).charAt(0));\n    }\n}\n\nclass Solution {\n    public char slowestKey(String[] keysPressed, int maxTime) {\n        char result = ' ';\n        int maxLength = 0;\n        for (String key : keysPressed) {\n            if (key.length() > maxLength) {\n                result = key.charAt(0);\n                maxLength = key.length();\n            }\n        }\n        return result;\n    }\n}\n```",
  "1630": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(subarraySum(new int[]{1, 2, 3}, 3));\n        System.out.println(subarraySum(new int[]{1}, 2));\n        System.out.println(subarraySum(new int[]{-2, 0, 4}, -1));\n    }\n\n    public static List<Integer> subarraySum(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int sum = 0;\n        list.add(0);\n        for (int num : nums) {\n            sum += num;\n            if (map.containsKey(sum - k)) {\n                list.add(map.get(sum - k) + 1);\n            }\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\n        }\n        return list;\n    }\n\n    static List<Integer> list = new ArrayList<>();\n}\n```",
  "1631": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] h = {{1,2,3},{4,5,6}};\n        System.out.println(minimumEffortPath(h));\n        \n        int[][] h1 = {{7,7,7},{8,8,8},{8,9,10}};\n        System.out.println(minimumEffortPath(h1));\n\n        int[][] h2 = {{15,14,13},{5,4,3},{1,1,1}};\n        System.out.println(minimumEffortPath(h2));\n    }\n\n    public static int minimumEffortPath(int[][] holes) {\n        if (holes == null || holes.length == 0) return 0;\n        \n        int m = holes.length, n = holes[0].length;\n        int[] x = new int[m], y = new int[n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (holes[i][j] > 0) {\n                    x[i]++;\n                    y[j]++;\n                }\n            }\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (holes[i][j] > 0) {\n                    pq.offer(new int[]{i, j, holes[i][j]});\n                }\n            }\n        }\n\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            for (int i = -1; i <= 1; i++) {\n                for (int j = -1; j <= 1; j++) {\n                    if (i == 0 && j == 0) continue;\n                    int ni = cur[0] + i, nj = cur[1] + j;\n                    if (ni >= 0 && ni < m && nj >= 0 && nj < n) {\n                        holes[ni][nj]--;\n                        if (holes[ni][nj] == 0) pq.remove(new int[]{ni, nj, 0});\n                    }\n                }\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (holes[i][j] > 0) return holes[i][j];\n            }\n        }\n\n        return 0;\n    }\n}",
  "1632": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{20, 15, 10, 5}, {7, 6, 5, 4}, {3, 2, 1, 0}};\n        System.out.println(\"Matrix1: \" + rankTransform(matrix1));\n        \n        int[][] matrix2 = {{1, 17, 16, 15}, {16, 13, 12, 11}, {10, 9, 7, 6}};\n        System.out.println(\"Matrix2: \" + rankTransform(matrix2));\n        \n        int[][] matrix3 = {{0, 1, 5, 4}, {1, 2, 3, 2}, {3, 3, 3, 3}};\n        System.out.println(\"Matrix3: \" + rankTransform(matrix3));\n    }\n\n    public static int[][] rankTransform(int[][] matrix) {\n        if (matrix.length == 0) {\n            return new int[0][];\n        }\n        \n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        UnionFind uf = new UnionFind(m * n);\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] > 0) {\n                    int idx = i * n + j;\n                    uf.union(idx, idx + 1);\n                    if (i + 1 < m) {\n                        uf.union(idx, idx + n);\n                    }\n                }\n            }\n        }\n        \n        int[][] res = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int idx = i * n + j;\n                res[i][j] = uf.find(idx) + 1;\n            }\n        }\n        \n        return res;\n    }\n\n    class UnionFind {\n        int[] parent;\n        int[] rank;\n\n        public UnionFind(int size) {\n            parent = new int[size];\n            rank = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n\n            if (rootX != rootY) {\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX;\n                } else if (rank[rootX] < rank[rootY]) {\n                    parent[rootX] = rootY;\n                } else {\n                    parent[rootY] = rootX;\n                    rank[rootX]++;\n                }\n            }\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n    }\n}\n```",
  "1633": "```\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\n\npublic class Main {\n    public static void main(String[] args) throws SQLException {\n        int result1 = percentageOfUsersAttended(new Connection(\"database_url\", \"username\", \"password\"), 3, \"table_name\");\n        System.out.println(result1);\n\n        int result2 = percentageOfUsersAttended(new Connection(\"another_database_url\", \"another_username\", \"another_password\"), 5, \"another_table_name\");\n        System.out.println(result2);\n\n        int result3 = percentageOfUsersAttended(new Connection(\"third_database_url\", \"third_username\", \"third_password\"), 10, \"third_table_name\");\n        System.out.println(result3);\n    }\n\n    public static int percentageOfUsersAttended(Connection conn, int userId, String table) throws SQLException {\n        ResultSet rs = conn.createStatement().executeQuery(\"SELECT * FROM \" + table + \" WHERE user_id = \" + userId);\n\n        int totalRows = 0;\n        int attendedRows = 0;\n\n        while (rs.next()) {\n            if (rs.getBoolean(\"attended\")) {\n                attendedRows++;\n            }\n            totalRows++;\n        }\n\n        return (int) (((double) attendedRows / totalRows) * 100);\n    }\n}\n\nclass Connection {\n    String url;\n    String username;\n    String password;\n\n    public Connection(String url, String username, String password) {\n        this.url = url;\n        this.username = username;\n        this.password = password;\n    }\n}\n```",
  "1635": "```\npublic class Main {\n    public static void main(String[] args) {\n        TestCases test = new TestCases();\n        System.out.println(\"Test Case 1: \" + test.queryString(\"John\", \"Smith\"));\n        System.out.println(\"Test Case 2: \" + test.queryString(\"Jane\", \"Doe\"));\n        System.out.println(\"Test Case 3: \" + test.queryString(\"Alice\", \"Bob\"));\n    }\n}\n\nclass TestCases {\n    public String queryString(String customer, String store) {\n        // Your solution logic here\n        return \"\";\n    }\n}\n```",
  "1634": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        test(\"1+2\", \"3\");\n        test(\"5+5\", \"10\");\n        test(\"7-9\", \"-2\");\n    }\n\n    private static void test(String polynomial1, String expected) {\n        ListNode head1 = new ListNode(0);\n        int i = 0;\n        String[] parts = polynomial1.split(\"\\\\+\");\n        for (String part : parts) {\n            if (!part.isEmpty()) {\n                int coefficient = Integer.parseInt(part.replaceAll(\"[^0-9]\", \"\"));\n                int exponent = Integer.parseInt(String.valueOf((char) ('A' - 1)));\n                ListNode temp = head1;\n                while (temp.next != null) {\n                    temp = temp.next;\n                }\n                temp.next = new ListNode(coefficient, exponent);\n            }\n        }\n\n        ListNode head2 = new ListNode(0);\n        i = 0;\n        parts = polynomial2.split(\"\\\\+\");\n        for (String part : parts) {\n            if (!part.isEmpty()) {\n                int coefficient = Integer.parseInt(part.replaceAll(\"[^0-9]\", \"\"));\n                int exponent = Integer.parseInt(String.valueOf((char) ('A' - 1)));\n                ListNode temp = head2;\n                while (temp.next != null) {\n                    temp = temp.next;\n                }\n                temp.next = new ListNode(coefficient, exponent);\n            }\n        }\n\n        ListNode resultHead = addPolynomials(head1.next, head2.next);\n\n        System.out.println(\"Expected: \" + expected);\n        printList(resultHead);\n    }\n\n    public static class ListNode {\n        int val;\n        char exp;\n        ListNode next;\n\n        ListNode(int x) {\n            val = x;\n            exp = (char) ('A' - 1);\n        }\n\n        ListNode(int x, char exponent) {\n            val = x;\n            exp = exponent;\n        }\n    }\n\n    public static ListNode addPolynomials(ListNode l1, ListNode l2) {\n        if (l1 == null)\n            return l2;\n        if (l2 == null)\n            return l1;\n\n        ListNode dummyHead = new ListNode(0);\n        ListNode p = l1, q = l2, curr = dummyHead;\n\n        while (p != null && q != null) {\n            int sumVal = p.val + q.val;\n            char sumExp = (sumVal > 0) ? Character.toChars(sumVal)[0] : (char) ('A' - 1);\n\n            if (sumVal == 0)\n                break;\n\n            curr.next = new ListNode(sumVal, sumExp);\n            curr = curr.next;\n            p = p.next;\n            q = q.next;\n        }\n\n        // Add remaining nodes of l1\n        while (p != null) {\n            int sumVal = p.val;\n            char sumExp = p.exp;\n\n            if (sumVal > 0) {\n                curr.next = new ListNode(sumVal, sumExp);\n                curr = curr.next;\n            }\n            p = p.next;\n        }\n\n        // Add remaining nodes of l2\n        while (q != null) {\n            int sumVal = q.val;\n            char sumExp = q.exp;\n\n            if (sumVal > 0) {\n                curr.next = new ListNode(sumVal, sumExp);\n                curr = curr.next;\n            }\n            q = q.next;\n        }\n\n        return dummyHead.next;\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \"\" + head.exp);\n            head = head.next;\n            if (head != null)\n                System.out.println(\" + \");\n            else\n                System.out.println();\n        }\n    }\n}",
  "1636": "```\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrs = {\n                {{1,2,2,5},{7}},\n                {{1,3},{2,3,2}},\n                {{-1,1,-6,1},{1,0,0}\n        };\n\n        for (int[] arr : arrs) {\n            Arrays.sort(arr[1], new Comparator<Integer>() {\n                Map<Integer, Integer> countMap = new HashMap<>();\n                public int compare(Integer a, Integer b) {\n                    int aCount = countMap.computeIfAbsent(a, k -> 0) + 1;\n                    int bCount = countMap.computeIfAbsent(b, k -> 0) + 1;\n\n                    if (aCount == bCount) return a - b;\n                    return aCount - bCount;\n                }\n            });\n            System.out.println(Arrays.toString(arr[1]));\n        }\n    }\n}",
  "1638": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countGoodStrings(\"abc\", 2));\n        System.out.println(countGoodStrings(\"abac\", 2));\n        System.out.println(countGoodStrings(\"abc\", 1));\n    }\n\n    public static int countGoodStrings(String bag, int n) {\n        return (int)bag.charAt(0) + bag.length() - 1;\n    }\n}\n```",
  "1637": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] points = new int[][]{{8,1},{9,16},{2,3},{1,7},{5,12}};\n        System.out.println(widestVerticalArea(points));\n\n        points = new int[][]{{3,1},{3,4},{6,4},{2,0},{3,10}};\n        System.out.println(widestVerticalArea(points));\n\n        points = new int[][]{{7,10}};\n        System.out.println(widestVerticalArea(points));\n    }\n\n    public static int widestVerticalArea(int[][] points) {\n        if (points.length < 1) return 0;\n\n        Map<Integer, Integer> xPointsMap = new HashMap<>();\n        for (int[] point : points) {\n            xPointsMap.put(point[0], xPointsMap.getOrDefault(point[0], 0) + 1);\n        }\n\n        int maxWidth = 0;\n        for (int x : xPointsMap.keySet()) {\n            int yStart = 0, yEnd = 0;\n            for (int i = 0; i < points.length; i++) {\n                if (points[i][0] == x) {\n                    yStart = Math.max(yStart, points[i][1]);\n                    yEnd = Math.min(yEnd, points[i][1]);\n                }\n            }\n\n            int width = yEnd - yStart;\n            maxWidth = Math.max(maxWidth, width);\n        }\n\n        return maxWidth;\n    }\n}",
  "1639": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numWays(new String[]{\"w\",\"wo\",\"wor\"}, \"wood\")); // Output: 1\n        System.out.println(numWays(new String[]{\"sh\",\"sha\",\"shift\",\"shit\",\"s***\"},\"hit\")); // Output: 3\n        System.out.println(numWays(new String[]{\"a\",\"aa\",\"aaa\",\"aaaa\",\"aaaaa\",\"aaaaaa\",\"aaaaaaa\",\"aaaaaaaa\"},\"aba\"));// Output: 8\n    }\n\n    public static int numWays(String[] dictionary, String target) {\n        // Your logic here\n        Map<String, Integer> countMap = new HashMap<>();\n        for (String word : dictionary) {\n            if (!countMap.containsKey(word)) {\n                countMap.put(word, 1);\n            } else {\n                countMap.put(word, countMap.get(word) + 1);\n            }\n        }\n\n        int res = 0;\n        for (int i = 0; i <= target.length(); i++) {\n            for (int j = i; j <= target.length(); j++) {\n                String subStr = target.substring(i, j);\n                if (countMap.containsKey(subStr)) {\n                    res += countMap.get(subStr);\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```",
  "1640": "```\npublic class Main {\n    public static void main(String[] args) {\n        boolean result1 = arrayFormation(new String[][]{{20, 110}, {1, 2}, {60, 250}});\n        System.out.println(\"Test case 1: \" + (result1 ? \"Pass\" : \"Fail\"));\n\n        boolean result2 = arrayFormation(new String[][]{{1, 3}, {5, 10}, {4, 20}});\n        System.out.println(\"Test case 2: \" + (result2 ? \"Pass\" : \"Fail\"));\n\n        boolean result3 = arrayFormation(new String[][]{{1, 3}, {5, 10}, {4, 5}});\n        System.out.println(\"Test case 3: \" + (result3 ? \"Pass\" : \"Fail\"));\n    }\n\n    public static boolean arrayFormation(String[][] pairs) {\n        Map<String, Integer> map = new HashMap<>();\n        for (String[] pair : pairs) {\n            int target = Integer.parseInt(pair[1]);\n            if (!map.containsKey(pair[0])) {\n                map.put(pair[0], target);\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "1641": "```\npublic class Main {\n    public static void main(String[] args) {\n        int num1 = countSortedVowelStrings(1);\n        System.out.println(num1); // expected output: 1\n\n        int num2 = countSortedVowelStrings(2);\n        System.out.println(num2); // expected output: 3\n\n        int num3 = countSortedVowelStrings(5);\n        System.out.println(num3); // expected output: 28\n    }\n\n    public static int countSortedVowelStrings(int n) {\n        if (n == 0) return 1;\n        int res = 0;\n        for (int i = 0; i <= n; i++) {\n            res += (i % 5 == 0 || i < 3 ? 1 : 1);\n        }\n        return res;\n    }\n}",
  "1642": "```\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] h = {{14,1,2}, {6,5,10}, {2,1000000000,9}};\n        System.out.println(furthestBuilding(h, 10, 15));\n\n        int[][] h1 = {{4,7,11},{1,8,12},{3,9,13}};\n        System.out.println(furthestBuilding(h1, 5, 6));\n\n        int[][] h2 = {{14,0,6500000},{9,0,6300000},{9,0,1000000},{7,0,730000}};\n        System.out.println(furthestBuilding(h2, 3, 10));\n    }\n\n    public static int furthestBuilding(int[][] h, int p, int l) {\n        Queue<Integer> q = new PriorityQueue<>();\n        for (int i = 0; i < h.length - 1; i++) {\n            if (h[i+1][0] - h[i][0] > p) {\n                q.add(h[i+1][0] - h[i][0]);\n            }\n        }\n        int res = h.length - 2;\n        while (!q.isEmpty() && q.peek() <= l) {\n            q.poll();\n            res++;\n        }\n        return res;\n    }\n}\n```",
  "1643": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(kthSmallestInstructions(new int[][]{{4,7},{1,8},{4,10}} , 5));\n        \n        System.out.println(kthSmallestInstructions(new int[][]{{2,3},{4,5}}, 2));\n        \n        System.out.println(kthSmallestInstructions(new int[][]{{1,2},{3,4}}, 4));\n    }\n\n    public static int kthSmallestInstructions(int[][] instructions, int k) {\n        // Your code here\n        return 0;\n    }\n}\n```",
  "1645": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] queries = {\n                {1, 2},\n                {4, 6},\n                {7, 8}\n        };\n\n        System.out.println(\"Test Case 1: \" + getModifiedArray(new int[]{1, 3, 5}, queries));\n        System.out.println(\"Test Case 2: \" + getModifiedArray(new int[]{1, 3, 5, 7, 9}, queries));\n        System.out.println(\"Test Case 3: \" + getModifiedArray(new int[]{-1, 0, 4, 6, 8, 10}, queries));\n    }\n\n    public static String getModifiedArray(int[] arr, int[][] queries) {\n        // Your logic goes here\n        return \"\";\n    }\n}\n```",
  "1644": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(3);\n        root.left = new TreeNode(5);\n        root.right = new TreeNode(1);\n        root.left.left = new TreeNode(6);\n        root.left.right = new TreeNode(2);\n        root.right.left = new TreeNode(0);\n        root.right.right = new TreeNode(8);\n        root.left.right.left = new TreeNode(7);\n        root.left.right.right = new TreeNode(4);\n\n        System.out.println(\"Test Case 1: \" + lowestCommonAncestor(root, root.left, root.left.right).val);\n        System.out.println(\"Test Case 2: \" + lowestCommonAncestor(root, root.right, root.right.right).val);\n        System.out.println(\"Test Case 3: \" + lowestCommonAncestor(root, root.left, root.right).val);\n    }\n\n    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) return root;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        return left != null && right != null ? root : left != null ? left : right;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1646": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(getMaximumGenerated(new int[]{1,2,3,4,5})) + \" Expected: 9\");\n        System.out.println(getMaximumGenerated(new int[]{10,2,7,5,8})) + \" Expected: 10\");\n        System.out.println(getMaximumGenerated(new int[]{0,9,8,7,6})) + \" Expected: 9\");\n    }\n\n    public static int getMaximumGenerated(int n) {\n        if (n == 0) return 0;\n        int[] arr = new int[n+1];\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) {\n                arr[i] = arr[i/2] + i;\n            } else {\n                arr[i] = arr[(i-1)/2] + 1;\n            }\n        }\n        int max = 0;\n        for (int i = 1; i <= n; i++) {\n            if (arr[i] > max) max = arr[i];\n        }\n        return max;\n    }\n}",
  "1647": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minDeletions(\"aabbbcc\")); // expected output: 2\n        System.out.println(minDeletions(\"abcabcabc\")); // expected output: 7\n        System.out.println(minDeletions(\"aaaaa\")); // expected output: 5\n    }\n\n    public static int minDeletions(String s) {\n        int n = s.length();\n        int[] count = new int[26];\n        for (int i = 0; i < n; i++) {\n            count[s.charAt(i) - 'a']++;\n        }\n        Arrays.sort(count);\n        int res = 0;\n        for (int i = 1; i < 26; i++) {\n            if (count[i] == count[i - 1]) {\n                res += count[i];\n            } else {\n                break;\n            }\n        }\n        return n - res;\n    }\n}",
  "1648": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + sellBalls(new int[]{7,6,5,4,3}, 10));\n        System.out.println(\"Test Case 2: \" + sellBalls(new int[]{9,8,7,6,5,4,3,2,1}, 50));\n        System.out.println(\"Test Case 3: \" + sellBalls(new int[]{2,2,2,2}, 100));\n\n    }\n\n    public static int sellBalls(int[] happiness, int maxCoins) {\n        Arrays.sort(happiness);\n        \n        int i = happiness.length - 1;\n        while (i >= 0 && maxCoins > 0) {\n            maxCoins -= happiness[i];\n            if (maxCoins <= 0) break;\n            i--;\n        }\n        \n        return Math.min(i+1, happiness.length-1);\n    }\n\n}",
  "1649": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] instructions = {\n                {{1,5},{2,3},{5,0},{6,7}},\n                {{1,2},{2,5},{4,5},{3,4}},\n                {{7,10},{11,12},{1,3},{8,9}}\n        };\n        \n        for (int[] instruction : instructions) {\n            int[] result = new Solution().originalDigits(instruction);\n            System.out.println(Arrays.toString(result));\n        }\n    }\n}\n\nclass Solution {\n    public int[] originalDigits(int[] lowToHigh) {\n        // your code here\n    }\n}\n```",
  "1650": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(5);\n        root1.right = new TreeNode(1);\n        root1.left.left = new TreeNode(6);\n        root1.left.right = new TreeNode(2);\n        root1.right.left = new TreeNode(0);\n        root1.right.right = new TreeNode(8);\n        root1.left.left.left = new TreeNode(7);\n        root1.left.left.right = new TreeNode(4);\n\n        System.out.println(\"Test Case 1: \" + lowestCommonAncestor(root1, root1.left, root1.left.left).val); // expected output: 6\n\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(7);\n\n        System.out.println(\"Test Case 2: \" + lowestCommonAncestor(root2, root2.left, root2.right).val); // expected output: 5\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n\n        System.out.println(\"Test Case 3: \" + lowestCommonAncestor(root3, root3.left, null).val); // expected output: 1\n    }\n\n    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) {\n            return root;\n        }\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left != null && right != null) {\n            return root;\n        }\n        return left != null ? left : right;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    public TreeNode(int x) {\n        val = x;\n    }\n}\n```",
  "1651": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(querySales(new int[][]{{1, 5}, {2, 10}, {3, 7}}, new int[]{2, 4}, 10));\n        System.out.println(querySales(new int[][]{{1, 5}, {2, 10}, {3, 7}}, new int[]{8, 10}, 15));\n        System.out.println(querySales(new int[][]{{1, 3}, {6, 8}, {14, 18}}, new int[]{3, 4}, 19));\n    }\n\n    public static double querySales(int[][] shops, int[] gates, int amount) {\n        Map<Integer, Integer> gateMap = new HashMap<>();\n        for (int i = 0; i < gates.length - 1; i += 2) {\n            gateMap.put(gates[i], gates[i + 1]);\n        }\n        \n        double totalSales = 0;\n        for (int[] shop : shops) {\n            int startGate = findNearestGate(shop[0], gateMap);\n            if (startGate == -1 || shop[1] < gateMap.getOrDefault(startGate, 0)) {\n                continue;\n            }\n            \n            int endGate = findNearestGate(shop[1], gateMap);\n            if (endGate == -1) {\n                totalSales += (double) (shop[1] - shop[0]);\n            } else if (startGate != endGate) {\n                totalSales += (double) (gateMap.getOrDefault(endGate, 0) - gateMap.getOrDefault(startGate, 0));\n            }\n        }\n        \n        return totalSales / amount;\n    }\n\n    public static int findNearestGate(int time, Map<Integer, Integer> map) {\n        int nearest = -1;\n        for (int gate : map.keySet()) {\n            if (gate > time) {\n                return nearest == -1 ? gate : nearest;\n            }\n            nearest = gate;\n        }\n        return nearest;\n    }\n}\n\n```",
  "1652": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(defuseTheBomb(new int[]{2, 7, 9}, 10));\n        System.out.println(defuseTheBomb(new int[]{1, 5}, 3));\n        System.out.println(defuseTheBomb(new int[]{1, 5}, 6));\n    }\n\n    public static int defuseTheBomb(int[] bombs, int k) {\n        int res = -1;\n        for (int i = 0; i <= bombs.length - k; i++) {\n            boolean flag = true;\n            for (int j = i; j < i + k; j++) {\n                if (bombs[j] > k) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) {\n                res = i;\n                break;\n            }\n        }\n        return res;\n    }\n}",
  "1653": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minDeletions(\"a\") + \" expected: 1\");\n        System.out.println(minDeletions(\"aaabbbcccdd\") + \" expected: 2\");\n        System.out.println(minDeletions(\"abcd\") + \" expected: 0\");\n    }\n\n    public static int minDeletions(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) {\n                    dp[i][j] = 1;\n                } else if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[Math.max(0, i - 1)][Math.min(n - 1, j)] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return n - dp[n - 1][n - 1];\n    }\n}\n```",
  "1655": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(distributeRepeatingIntegers(new int[]{1,2,3,3})); // Output: 2\n        System.out.println(distributeRepeatingIntegers(new int[]{5,5,5})); // Output: 4\n        System.out.println(distributeRepeatingIntegers(new int[]{1,2,3,7,8,9,10})); // Output: 6\n    }\n\n    public static int distributeRepeatingIntegers(int[] nums) {\n        // Your code here...\n    }\n}\n```",
  "1654": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] jump1 = {{0,4},{1,3},{2,2},{3,0},{4,1}};\n        System.out.println(\"Test case 1: \" + minJumps(jump1) + \" expected output: 2\");\n\n        int[][] jump2 = {{0,1}};\n        System.out.println(\"Test case 2: \" + minJumps(new int[][]{jump2}) + \" expected output: 1\");\n\n        int[][] jump3 = {{0,3},{1,-1},{2,-1},{3,0}};\n        System.out.println(\"Test case 3: \" + minJumps(new int[][]{jump3}) + \" expected output: -1\");\n    }\n\n    public static int minJumps(int[][] jumps) {\n        if (jumps == null || jumps.length == 0) {\n            return -1;\n        }\n        int start = 0, end = 0, steps = 0;\n        for (int i = 0; i < jumps.length; i++) {\n            if (jumps[i][0] > end) {\n                if (i != jumps.length - 1) {\n                    return -1;\n                }\n                start = i + 1;\n                end = i + 1;\n                steps++;\n                continue;\n            }\n            end = Math.max(end, jumps[i][1]);\n            if (i == jumps.length - 1 && jumps[i][0] <= end) {\n                steps++;\n                return steps;\n            }\n        }\n        return -1;\n    }\n}\n```",
  "1657": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(closeStrings(\"abc\", \"abd\")); // true\n        System.out.println(closeStrings(\"aacc\", \"ccac\"));// false\n        System.out.println(closeStrings(\"caba\", \"baca\")) ;// true\n    }\n\n    public static boolean closeStrings(String word1, String word2) {\n        if (word1.length() != word2.length()) return false;\n        int[] count1 = new int[26];\n        int[] count2 = new int[26];\n        for (int i = 0; i < word1.length(); i++) {\n            char c1 = Character.toLowerCase(word1.charAt(i));\n            char c2 = Character.toLowerCase(word2.charAt(i));\n            count1[c1 - 'a']++;\n            count2[c2 - 'a']++;\n        }\n        return Arrays.equals(count1, count2);\n    }\n}",
  "1656": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        OrderedStream os = new OrderedStream(4);\n\n        // Test Case 1:\n        List<String> result1 = new ArrayList<>();\n        for (int i = 0; i < 3; i++) {\n            os.insert(i + 1, \"item\" + (i + 1));\n            while (!os.endOfStream()) {\n                result1.add(os.next());\n            }\n        }\n\n        System.out.println(\"Test Case 1: \" + result1);\n\n        // Test Case 2:\n        List<String> result2 = new ArrayList<>();\n        os = new OrderedStream(4);\n        for (int i = 0; i < 3; i++) {\n            os.insert(i + 5, \"item\" + (i + 1));\n        }\n        while (!os.endOfStream()) {\n            result2.add(os.next());\n        }\n\n        System.out.println(\"Test Case 2: \" + result2);\n\n        // Test Case 3:\n        List<String> result3 = new ArrayList<>();\n        os = new OrderedStream(4);\n        for (int i = 0; i < 4; i++) {\n            os.insert(i + 1, \"item\" + (i + 1));\n        }\n        while (!os.endOfStream()) {\n            result3.add(os.next());\n        }\n\n        System.out.println(\"Test Case 3: \" + result3);\n    }\n}\n\nclass OrderedStream {\n    private int streamId;\n    private Map<Integer, String> stream;\n\n    public OrderedStream(int streamId) {\n        this.streamId = streamId;\n        this.stream = new HashMap<>();\n    }\n\n    public void insert(int idKey, String value) {\n        if (idKey <= streamId) {\n            stream.put(idKey, value);\n        }\n    }\n\n    public String next() {\n        int currentId = 1;\n        while (!stream.containsKey(currentId)) {\n            currentId++;\n        }\n        String result = stream.remove(currentId);\n        return result;\n    }\n\n    public boolean endOfStream() {\n        return !stream.containsKey(streamId + 1);\n    }\n}",
  "1658": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minOperations(new int[]{2,5,10},5));\n        System.out.println(minOperations(new int[]{1,1},4));\n        System.out.println(minOperations(new int[]{7,8,9,11,12},14));\n    }\n\n    public static int minOperations(int[] nums, int x) {\n        int n = nums.length;\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n        if (totalSum < x) return -1;\n\n        Map<Integer, Integer> prefixSumMap = new HashMap<>();\n        int prefixSum = 0;\n        int minOps = n;\n        for (int i = 0; i < n; i++) {\n            while (prefixSum + nums[i] > x && prefixSumMap.containsKey(prefixSum)) {\n                minOps = Math.min(minOps, i - (prefixSumMap.get(prefixSum)));\n                prefixSum -= prefixSumMap.remove(prefixSum);\n            }\n            prefixSum += nums[i];\n            prefixSumMap.put(prefixSum, i);\n        }\n\n        return totalSum <= x ? n : minOps;\n    }\n}\n```",
  "1659": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumHappiness(new int[][]{{1,2},{3,4}})); // Expected: 5\n        System.out.println(maximumHappiness(new int[][]{{1,3},{2,3},{3,1},{4,2}})); // Expected: 6\n        System.out.println(maximumHappiness(new int[][]{})); // Expected: 0\n    }\n\n    public static int maximumHappiness(int[][] hugs) {\n        // Your code here\n    }\n}",
  "1660": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode tree = new TreeNode(1);\n        tree.left = new TreeNode(2);\n        tree.right = new TreeNode(3);\n        tree.right.left = new TreeNode(4);\n        tree.right.right = new TreeNode(5);\n\n        Solution solution = new Solution();\n        solution.correctBST(tree);\n\n        printTree(tree);\n\n        tree = null;\n        tree = new TreeNode(1);\n        tree.left = new TreeNode(2);\n        tree.right = new TreeNode(3);\n\n        solution = new Solution();\n        solution.correctBST(tree);\n\n        printTree(tree);\n\n        tree = null;\n        tree = new TreeNode(4);\n        tree.left = new TreeNode(2);\n        tree.right = new TreeNode(6);\n        tree.left.left = new TreeNode(1);\n        tree.left.right = new TreeNode(3);\n\n        solution = new Solution();\n        solution.correctBST(tree);\n\n        printTree(tree);\n    }\n\n    private static void printTree(TreeNode node) {\n        if (node == null)\n            return;\n\n        System.out.println(\"Root: \" + node.val);\n        System.out.println(\"Left subtree:\");\n        printTree(node.left);\n        System.out.println(\"Right subtree:\");\n        printTree(node.right);\n    }\n}\n```",
  "1661": "```\npublic class Solution {\n    public double averageTimePerMachine(int[][] summary) {\n        int totalProcess = 0;\n        int[] machineTime = new int[summary.length];\n        \n        for (int i = 0; i < summary.length; i++) {\n            totalProcess += summary[i][1];\n            machineTime[i] = summary[i][1];\n        }\n        \n        return (double)totalProcess / totalProcess;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test Case 1\n        int[][] summary1 = {{2,10},{3,20},{5,30}};\n        System.out.println(\"Test Case 1: \" + solution.averageTimePerMachine(summary1));\n        \n        // Test Case 2\n        int[][] summary2 = {{1,7},{2,12},{5,28}};\n        System.out.println(\"Test Case 2: \" + solution.averageTimePerMachine(summary2));\n        \n        // Test Case 3\n        int[][] summary3 = {{3,15},{6,45}};\n        System.out.println(\"Test Case 3: \" + solution.averageTimePerMachine(summary3));\n    }\n}\n```",
  "1663": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minAddToMakeValid(\"lee(t(cod(e)d)\")); // 8\n        System.out.println(minAddToMakeValid(\"abccccdd\")); // 1\n        System.out.println(minAddToMakeValid(\"z(1)a\")); // 2\n    }\n\n    public static int minAddToMakeValid(String s) {\n        int res = 0;\n        int open = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') open++;\n            else if (c == ')') {\n                if (open > 0) open--;\n                else res++;\n            }\n        }\n        return res + open;\n    }\n\n}\n```",
  "1662": "```\npublic class Main {\n    public static void main(String[] args) {\n        boolean[][] expectedResults = {\n            {true, Arrays.equals(new String[]{\"a\", \"c\"}, new String[]{\"a\", \"c\"}), true},\n            {false, Arrays.equals(new String[]{\"a\", \"b\"}, new String[]{\"a\", \"c\"}), false},\n            {true, Arrays.equals(new String[]{\"\"}, new String[][]{}), true}\n        };\n\n        for (boolean[] test : expectedResults) {\n            System.out.println(\"Test Case: \" + test[1] + \" Expected Result: \" + test[2]);\n            boolean result = canBeEqual(test[0], test[1]);\n            if (result == test[2]) {\n                System.out.println(\"Test Passed\");\n            } else {\n                System.out.println(\"Test Failed\");\n            }\n            System.out.println();\n        }\n    }\n\n    public static boolean canBeEqual(String[] word1, String[] word2) {\n        if (word1.length != word2.length) {\n            return false;\n        }\n        for (int i = 0; i < word1.length; i++) {\n            if (!canBeEqualHelper(word1[i], word2[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean canBeEqualHelper(String s1, String s2) {\n        int i = 0, j = 0;\n        while (i < s1.length() && j < s2.length()) {\n            if (s1.charAt(i) != s2.charAt(j)) {\n                return false;\n            }\n            i++;\n            j++;\n        }\n        if (i == s1.length() && j == s2.length()) {\n            return true;\n        }\n        if (i == s1.length()) {\n            while (j < s2.length()) {\n                if (s2.charAt(j) == '#') {\n                    j++;\n                } else {\n                    return false;\n                }\n            }\n        } else {\n            while (i < s1.length()) {\n                if (s1.charAt(i) == '#') {\n                    i++;\n                } else {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
  "1664": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(waysToMakeFair(new int[]{2,1,6,4}, 2));\n        System.out.println(waysToMakeFair(new int[]{0,0,0,0}, 3));\n        System.out.println(waysToMakeFair(new int[]{5,10,-10,5}, 1));\n    }\n\n    public static int waysToMakeFair(int[] nums, int k) {\n        int n = nums.length;\n        long totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n        \n        if (totalSum % 2 != 0) {\n            return 0;\n        }\n\n        long halfSum = totalSum / 2;\n        int leftSum = 0, rightSum = 0;\n        int res = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (i < k) {\n                leftSum += nums[i];\n            } else {\n                rightSum += nums[i];\n            }\n            \n            if (leftSum == halfSum) {\n                res++;\n                leftSum = 0;\n                rightSum = 0;\n            }\n        }\n\n        return res;\n    }\n}",
  "1665": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] tasks = {{1,4},{2,4},{3,1}};\n        System.out.println(minimumInitialEnergy(tasks)); // Output: 6\n        \n        tasks = new int[][]{{8,5},{2,9},{7,5},{10,4}};\n        System.out.println(minimumInitialEnergy(tasks)); // Output: 16\n        \n        tasks = {{1,3},{2,2},{3,2},{4,1},{5,1},{6,1},{7,2},{8,3}};\n        System.out.println(minimumInitialEnergy(tasks)); // Output: 13\n    }\n\n    public static int minimumInitialEnergy(int[][] tasks) {\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\n        \n        int energy = 0;\n        for (int i = 0; i < tasks.length; i++) {\n            if (i == 0) {\n                energy += Math.max(0, tasks[i][1] - tasks[i][0]) + tasks[i][0];\n            } else {\n                energy += Math.max(0, tasks[i][1] - tasks[i][0]) + tasks[i][0] - tasks[i-1][1];\n            }\n        }\n        \n        return energy;\n    }\n}",
  "1667": "```\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int[][] table = {{0, \"hey\"}, {1, \"name\"}, {2, \"title\"}};\n        String[] columns = {\"A\", \"B\", \"C\"};\n        List<List<String>> result = solution.fixNames(table, columns);\n        System.out.println(result);\n\n        // Test case 2\n        int[][] table1 = {{0, \"Mr.\"}, {1, \"Ms.\"}, {2, \"Mrs.\"}};\n        String[] columns1 = {\"A\", \"B\"};\n        List<List<String>> result1 = solution.fixNames(table1, columns1);\n        System.out.println(result1);\n\n        // Test case 3\n        int[][] table2 = {{0, \"first\"}, {1, \"last\"}};\n        String[] columns2 = {\"X\", \"Y\", \"Z\"};\n        List<List<String>> result2 = solution.fixNames(table2, columns2);\n        System.out.println(result2);\n\n    }\n}\n\nclass Solution {\n    public List<List<String>> fixNames(int[][] table, String[] columns) {\n        // Your code here\n    }\n}\n```",
  "1666": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n\n        TreeNode newNode = new TreeNode(0);\n        Solution solution = new Solution();\n        TreeNode result = solution.bst(root, 5);\n\n        System.out.println(\"Test Case 1: \" + (result.val == 4));\n        System.out.println(\"Test Case 2: \" + (solution.bst(new TreeNode(2), 1).val == 0));\n        System.out.println(\"Test Case 3: \" + (solution.bst(null, 0) == null));\n\n    }\n}\n\nclass Solution {\n    public TreeNode bst(TreeNode root, int val) {\n        if(root == null) return new TreeNode(val);\n        if(root.val > val) return new TreeNode(val);\n        root.left = bst(root.left, val);\n        if(root.left != null && root.left.val > val) return new TreeNode(val);\n        return root;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n}\n```",
  "1668": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxRepeatingSubstring(\"ababc\", \"b\"));\n        System.out.println(maxRepeatingSubstring(\"aaabaabaaaaab\", \"a\"));\n        System.out.println(maxRepeatingSubstring(\"\", \"\"));\n    }\n\n    public static int maxRepeatingSubstring(String s, String t) {\n        if (s.length() < t.length()) return 0;\n        int n = s.length();\n        int m = t.length();\n        int ans = 0;\n\n        for (int i = 0; i + m - 1 <= n; i++) {\n            String substr = s.substring(i, i + m);\n            if (substr.equals(t)) ans++;\n        }\n        return ans;\n    }\n}\n```",
  "1669": "```\npublic class Main {\n    public static void main(String[] args) {\n        ListNode l1 = new ListNode(0);\n        l1.next = new ListNode(6);\n        l1.next.next = new ListNode(10);\n\n        ListNode l2 = new ListNode(1);\n        l2.next = new ListNode(2);\n        l2.next.next = new ListNode(4);\n\n        ListNode mergedList1 = mergeBetween(l1, 3, l2);\n        printList(mergedList1);\n\n        l1 = new ListNode(0);\n        l1.next = new ListNode(6);\n        l1.next.next = new ListNode(10);\n\n        l2 = new ListNode(1);\n        l2.next = new ListNode(2);\n        l2.next.next = new ListNode(4);\n        l2.next.next.next = new ListNode(5);\n\n        mergedList1 = mergeBetween(l1, 2, l2);\n        printList(mergedList1);\n\n        l1 = new ListNode(0);\n        l1.next = new ListNode(6);\n        l1.next.next = new ListNode(10);\n\n        l2 = new ListNode(1);\n        l2.next = new ListNode(5);\n\n        mergedList1 = mergeBetween(l1, 6, l2);\n        printList(mergedList1);\n    }\n\n    public static void printList(ListNode head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n\n    public static ListNode mergeBetween(ListNode l1, int pos, ListNode l2) {\n        if (l1 == null || l2 == null) return l1 == null ? l2 : l1;\n\n        ListNode dummyHead = new ListNode(0);\n        ListNode p = dummyHead;\n        while (p.next != null && p.next.val < pos) p = p.next;\n\n        while (l1 != null) {\n            if (l1.next == null || l1.next.val >= pos) break;\n            l1 = l1.next;\n        }\n\n        while (l2 != null) {\n            p.next = new ListNode(l2.val);\n            p = p.next;\n            l2 = l2.next;\n        }\n        return dummyHead.next;\n    }\n}\n```",
  "1671": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input1 = {{2,1,1},{1,6,5},{1,4,3}};\n        System.out.println(\"Expected: \" + 2);\n        System.out.println(\"Actual: \" + minDeletionSize(input1));\n        System.out.println();\n\n        int[][] input2 = {{1,3,2},{6,6},{}};\n        System.out.println(\"Expected: \" + 3);\n        System.out.println(\"Actual: \" + minDeletionSize(input2));\n        System.out.println();\n\n        int[][] input3 = {{5,4,3},{3,5,4}};\n        System.out.println(\"Expected: \" + 1);\n        System.out.println(\"Actual: \" + minDeletionSize(input3));\n        System.out.println();\n    }\n\n    public static int minDeletionSize(int[][] arr) {\n        if (arr.length == 0 || arr[0].length == 0) {\n            return 0;\n        }\n        \n        for (int i = 0; i < arr.length - 1; i++) {\n            for (int j = 0; j < arr[i].length; j++) {\n                if (arr[i][j] >= arr[i + 1][j]) {\n                    return i + 1;\n                }\n            }\n        }\n        \n        return 0;\n    }\n}\n```",
  "1670": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        MyQueue queue = new MyQueue();\n        \n        // Test case 1: Enqueue elements and then dequeue from front, middle and back\n        queue.enqueue(1);\n        queue.enqueue(2);\n        System.out.println(queue.dequeue()); // Expected output: 1\n        System.out.println(queue.peekMiddle()); // Expected output: 2\n        System.out.println(queue.dequeue()); // Expected output: 2\n        \n        // Test case 2: Enqueue more elements and then dequeue from front, middle and back\n        queue.enqueue(3);\n        queue.enqueue(4);\n        queue.enqueue(5);\n        System.out.println(queue.dequeue()); // Expected output: 3\n        System.out.println(queue.peekMiddle()); // Expected output: 4\n        System.out.println(queue.dequeue()); // Expected output: 4\n        System.out.println(queue.peekMiddle()); // Expected output: 5\n        System.out.println(queue.dequeue()); // Expected output: 5\n        \n        // Test case 3: Enqueue elements and then dequeue from front, middle and back when queue is empty\n        queue = new MyQueue();\n        System.out.println(queue.dequeue()); // Expected output: None (empty queue)\n    }\n}\n\nclass MyQueue {\n    class Node {\n        int val;\n        Node prev;\n        Node next;\n\n        public Node(int val) {\n            this.val = val;\n        }\n    }\n\n    private Node head, tail;\n    private int size;\n\n    public void enqueue(int val) {\n        Node node = new Node(val);\n        if (head == null) {\n            head = node;\n            tail = node;\n        } else {\n            node.prev = tail;\n            tail.next = node;\n            tail = node;\n        }\n        size++;\n    }\n\n    public int dequeue() {\n        if (head == null) return -1; // Return dummy value for empty queue\n        int val = head.val;\n        head = head.next;\n        if (head == null) tail = null;\n        else head.prev = null;\n        size--;\n        return val;\n    }\n\n    public int peekMiddle() {\n        if (size % 2 == 0) {\n            Node mid1 = getNthNode(size / 2 - 1);\n            Node mid2 = getNthNode(size / 2);\n            return mid2.val;\n        } else {\n            return getNthNode(size / 2).val;\n        }\n    }\n\n    private Node getNthNode(int n) {\n        if (n < 0 || n >= size) return null; // Check if index is valid\n        if (n < size / 2) { // Get node from front to middle\n            Node current = head;\n            for (int i = 0; i <= n; i++) {\n                current = current.next;\n            }\n            return current;\n        } else { // Get node from middle to back\n            Node current = tail;\n            for (int i = size - 1; i > n; i--) {\n                current = current.prev;\n            }\n            return current;\n        }\n    }\n}",
  "1672": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] accounts = {\n            {1, 2, 3},\n            {3, 2, 1}\n        };\n        System.out.println(\"Test case 1: \" + maxWealth(accounts));\n        \n        int[][] accounts2 = {\n            {1, 5},\n            {-2, 2},\n            [0, 8],\n            [1, -7]\n        };\n        System.out.println(\"Test case 2: \" + maxWealth(accounts2));\n        \n        int[][] accounts3 = {\n            {1, 1}\n        };\n        System.out.println(\"Test case 3: \" + maxWealth(accounts3));\n    }\n\n    public static int maxWealth(int[][] accounts) {\n        int maxWealth = 0;\n        for (int[] account : accounts) {\n            int wealth = 0;\n            for (int balance : account) {\n                wealth += balance;\n            }\n            if (wealth > maxWealth) {\n                maxWealth = wealth;\n            }\n        }\n        return maxWealth;\n    }\n}",
  "1673": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(mostCompetitive(new int[]{1, 2, 3, 4}, new int[]{5, 6, 7})); // Expected output: [1, 5], [2, 6], [4]\n        System.out.println(mostCompetitive(new int[]{1, 3, 5, 6}, new int[]{2, 5, 4})); // Expected output: [1], [5]\n        System.out.println(mostCompetitive(new int[]{1, 2, 3, 4, 5}, new int[]{0, 7, 8, 9})); // Expected output: []\n    }\n\n    public static List<int[]> mostCompetitive(int[] nums, int[] prices) {\n        List<int[]> res = new ArrayList<>();\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            while (!stack.isEmpty() && prices[stack.peek()] > prices[nums[i]]) {\n                res.add(new int[]{nums[stack.pop()], nums[i]});\n            }\n            stack.push(i);\n        }\n\n        while (!stack.isEmpty()) {\n            res.add(new int[]{nums[stack.pop()], -1});\n        }\n\n        return res;\n    }\n}\n```",
  "1674": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minMoves(new int[]{2,1,6,4,9,5,3,7}), \"Expected: 2\");\n        System.out.println(minMoves(new int[]{30,11,21,7,41,13,33,19}), \"Expected: 4\");\n        System.out.println(minMoves(new int[]{10,20,30,40,50}), \"Expected: 0\");\n    }\n\n    public static int minMoves(int[] nums) {\n        int n = nums.length;\n        int res = 0;\n        boolean[] seen = new boolean[n + 1];\n        for (int i = n; i > 0; i--) {\n            if (!seen[i]) {\n                while (!seen[i] && i < n) {\n                    seen[i] = true;\n                    i++;\n                }\n                res += i - 1;\n                seen[i] = false;\n            }\n        }\n        return res;\n    }\n}\n```",
  "1675": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimizeDeviation(new int[]{37, 41, 43, 47, 49}, 2));\n        \n        System.out.println(minimizeDeviation(new int[]{1, 4, 7, 9}, 3));\n        \n        System.out.println(minimizeDeviation(new int[]{10, 8, 6, 5, 4, 3, 2, 1}, 5));\n    }\n\n    public static double minimizeDeviation(int[] nums, int numSteps) {\n        // Add your implementation here\n        Arrays.sort(nums);\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a);\n        for (int i : nums) {\n            maxHeap.offer(i);\n        }\n        double deviation = 0;\n        while (!maxHeap.isEmpty() && numSteps > 0) {\n            int currentMax = maxHeap.poll();\n            deviation += Math.abs(currentMax - nums[nums.length - 1]);\n            numSteps--;\n            if (numSteps == 0)\n                break;\n            int newMax = (int) Math.ceil((currentMax + nums[nums.length - 1]) / 2.0);\n            for (int i = maxHeap.size(); i > 0; i--) {\n                if ((int) maxHeap.peek() >= newMax) {\n                    maxHeap.poll();\n                    break;\n                }\n                maxHeap.poll();\n            }\n            maxHeap.offer(newMax);\n        }\n        return deviation / (double) nums.length;\n    }\n}\n```",
  "1677": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] invoices = { {2, 4}, {5, 6} };\n        System.out.println(minCostToWithdraw(invoices)); // Expected output: 8\n\n        invoices = new int[][]{ {3, 6, 1} };\n        System.out.println(minCostToWithdraw(invoices)); // Expected output: 7\n\n        invoices = new int[][]{ {2, 5}, {4, 10} };\n        System.out.println(minCostToWithdraw(invoices)); // Expected output: 11\n    }\n\n    public static int minCostToWithdraw(int[][] invoices) {\n        int totalCost = 0;\n        for (int[] invoice : invoices) {\n            for (int productPrice : invoice) {\n                totalCost += productPrice;\n            }\n        }\n        return totalCost;\n    }\n}",
  "1676": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(3);\n        root1.left = new TreeNode(5);\n        root1.right = new TreeNode(1);\n        root1.left.left = new TreeNode(6);\n        root1.left.right = new TreeNode(2);\n        root1.right.left = new TreeNode(0);\n        root1.right.right = new TreeNode(8);\n        root1.left.right.left = new TreeNode(7);\n        root1.left.right.right = new TreeNode(4);\n\n        System.out.println(\"Lowest Common Ancestor of 5 and 1 is \" + lowestCommonAncestor(root1, root1.left, root1.right).val);\n\n        TreeNode root2 = new TreeNode(4);\n        root2.left = new TreeNode(2);\n        root2.right = new TreeNode(7);\n        root2.left.left = new TreeNode(3);\n        root2.left.right = new TreeNode(5);\n\n        System.out.println(\"Lowest Common Ancestor of 5 and 7 is \" + lowestCommonAncestor(root2, root2.left.right, root2.left).val);\n\n        TreeNode root3 = new TreeNode(1);\n        root3.left = new TreeNode(2);\n        root3.right = new TreeNode(3);\n\n        System.out.println(\"Lowest Common Ancestor of 2 and 3 is \" + lowestCommonAncestor(root3, root3.left, root3.right).val);\n    }\n\n    public static TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) return root;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        return left != null && right != null ? root : left != null ? left : right;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1678": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(interpret(\"G\"));//Test case 1\n        System.out.println(interpret(\"GG\")); //Test case 2\n        System.out.println(interpret(\"GBBB\")); //Test case 3\n    }\n\n    public static String interpret(String command) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < command.length(); i++) {\n            if (command.charAt(i) == 'G') {\n                result.append('G');\n            } else if (i + 2 <= command.length() && command.substring(i, i+3).equals(\"![zbr]\")) {\n                result.append('o');\n                i += 2;\n            }\n        }\n        return result.toString();\n    }\n}\n```",
  "1679": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] pairs = {{1,2},{5},{-5}};\n        System.out.println(maxKSumPairs(2, pairs));\n\n        int[][] pairs2 = {{1,2},{-2,-1},{0,1}};\n        System.out.println(maxKSumPairs(3, pairs2));\n\n        int[][] pairs3 = {{10,20},{50,50},{30,40}};\n        System.out.println(maxKSumPairs(5, pairs3));\n    }\n\n    public static int maxKSumPairs(int k, int[][] nums) {\n        Arrays.sort(nums, (a, b) -> Integer.compare(a[0] + a[1], b[0] + b[1]));\n        int count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length && j - i <= k - 1; j++) {\n                if ((nums[i][0] + nums[j][1]) > (nums[j][0] + nums[i][1])) {\n                    count++;\n                    while (j + 1 < nums.length && nums[j][0] + nums[j+1][1] == nums[i][0] + nums[j][1]) {\n                        j++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}\n```",
  "1680": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(binList(1)); // expected: [1]\n        System.out.println(binList(3)); // expected: [1,11]\n        System.out.println(binList(9)); // expected: [1,11,1001]\n    }\n\n    public static List<String> binList(int maxNum) {\n        List<String> result = new ArrayList<>();\n        for (int i = 1; i <= maxNum; i++) {\n            StringBuilder sb = new StringBuilder();\n            while (i > 0) {\n                sb.insert(0, (i & 1) == 1 ? '1' : '0');\n                i >>= 1;\n            }\n            result.add(sb.toString());\n        }\n        return result;\n    }\n}\n```",
  "1681": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumIncompatibility(new int[]{2, 1, 3}, new int[][]{{0, 1}, {1, 2}}));\n        System.out.println(minimumIncompatibility(new int[]{4, 5}, new int[][]{}));\n        System.out.println(minimumIncompatibility(new int[]{1, 2, 3, 4}, new int[][]{{0, 1}, {1, 2}, {2, 3}}));\n    }\n\n    public static long minimumIncompatibility(int[] nums, int[][] pairs) {\n        // Your code here\n    }\n}\n```",
  "1682": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(longestPalindromicSubsequence(\"bba\", \"ababa\")); // Expected output: 4\n        System.out.println(longestPalindromicSubsequence(\"abc\", \"defghi\")); // Expected output: 0\n        System.out.println(longestPalindromicSubsequence(\"\", \"\")); // Expected output: 0\n    }\n\n    public static int longestPalindromicSubsequence(String s1, String s2) {\n        if (s1 == null || s2 == null) {\n            return 0;\n        }\n        \n        int m = s1.length();\n        int n = s2.length();\n        boolean[][] dp = new boolean[m + 1][n + 1];\n        int maxLength = 0;\n\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (s1.charAt(i) == s2.charAt(j)) {\n                    dp[i][j] = (i == m - 1 || j == n - 1) ? true : dp[i + 1][j + 1];\n                    if (dp[i][j]) {\n                        maxLength = Math.max(maxLength, i + 1);\n                    }\n                } else {\n                    dp[i][j] = false;\n                }\n            }\n        }\n\n        return maxLength;\n    }\n}",
  "1683": "```\npublic class Solution {\n    public int countInvalidTweets(String[] tweets) {\n        int count = 0;\n        for (String tweet : tweets) {\n            if (!tweet.matches(\"^[a-zA-Z0-9_]{1,140}$\")) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        String[] test1 = {\"abc\", \"xyz123\", \"def456\"};\n        System.out.println(\"Test 1: \" + solution.countInvalidTweets(test1)); // Expected output: 0\n\n        String[] test2 = {\"\"};\n        System.out.println(\"Test 2: \" + solution.countInvalidTweets(test2)); // Expected output: 1\n\n        String[] test3 = {\"abc\", \"\", \"xyz123\"};\n        System.out.println(\"Test 3: \" + solution.countInvalidTweets(test3)); // Expected output: 2\n    }\n}\n```",
  "1684": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countConsistentStrings(\"abc\", new String[]{\"ab\", \"cb\"}));\n        System.out.println(countConsistentStrings(\"aaa\", new String[]{\"aaaa\", \"aa\", \"a\"}));\n        System.out.println(countConsistentStrings(\"wlwsasphmxx\", new String[]{});\n    }\n\n    public static int countConsistentStrings(String allowed, String[] words) {\n        Set<Character> set = new HashSet<>();\n        for (char c : allowed.toCharArray()) {\n            set.add(c);\n        }\n        int count = 0;\n        for (String word : words) {\n            boolean consistent = true;\n            for (char c : word.toCharArray()) {\n                if (!set.contains(c)) {\n                    consistent = false;\n                    break;\n                }\n            }\n            if (consistent) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "1685": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {2, 3, -1};\n        System.out.println(\"Sum of absolute differences for array \" + Arrays.toString(arr1) + \": \" + sumAbsoluteDifferences(arr1));\n\n        int[] arr2 = [-1, 1];\n        System.out.println(\"Sum of absolute differences for array \" + Arrays.toString(arr2) + \": \" + sumAbsoluteDifferences(arr2));\n\n        int[] arr3 = [1, -1];\n        System.out.println(\"Sum of absolute differences for array \" + Arrays.toString(arr3) + \": \" + sumAbsoluteDifferences(arr3));\n    }\n\n    public static int sumAbsoluteDifferences(int[] nums) {\n        int n = nums.length;\n        long sum = 0;\n        for (int i = 1; i < n; i++) {\n            sum += Math.abs(nums[i - 1] - nums[i]);\n        }\n        return (int)sum;\n    }\n}",
  "1686": "```\npublic class Solution {\n    public int stoneGameVI(int[] aliceValues, int[] bobValues) {\n        int n = aliceValues.length;\n        int[] values = new int[n];\n        for (int i = 0; i < n; i++) {\n            values[i] = aliceValues[i] + bobValues[i];\n        }\n        Arrays.sort(values);\n        int[] aliceCount = new int[n], bobCount = new int[n];\n        for (int i = 0, j = n - 1; i < n && j >= 0; i++, j--) {\n            if (values[i] > values[j]) {\n                aliceCount[i]++;\n                aliceCount[i + 1]--;\n            } else {\n                bobCount[j]--;\n                bobCount[j - 1]++;\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            res += values[i] * (aliceCount[i] > bobCount[i] ? 1 : -1);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[][] inputs = {\n                {{2,7,12},{4,8,9}},\n                {{1,2},{3,5,6}],\n                {{1,3,5,6,7,8,9},{10,11,12,13,14,15,16}}\n        };\n        for (int[] input : inputs) {\n            int[] aliceValues = Arrays.copyOfRange(input[0], 0, input[0].length);\n            int[] bobValues = Arrays.copyOfRange(input[1], 0, input[1].length);\n            System.out.println(\"Input: \" + Arrays.toString(aliceValues) + \" and \" + Arrays.toString(bobValues));\n            System.out.println(\"Output: \" + new Solution().stoneGameVI(aliceValues, bobValues));\n            System.out.println();\n        }\n    }\n}",
  "1687": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] boxes = { {1, 3}, {5}, {6, 7} };\n        System.out.println(minOperations(boxes));\n        \n        int[][] boxes2 = { {1, 4}, {3}, {2, 8} };\n        System.out.println(minOperations(boxes2));\n        \n        int[][] boxes3 = { {1, 5}, {2, 6} };\n        System.out.println(minOperations(boxes3));\n    }\n\n    public static int minOperations(int[][] boxes) {\n        // Your logic goes here\n        return 0; \n    }\n}\n```",
  "1688": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countMatches(new int[][]{{2,1}, {1,2}}, 2));\n        System.out.println(countMatches(new int[][]{{1,1},{1,1},{1,1},{2,2}}, 4));\n        System.out.println(countMatches(new int[][]{{1,1},{1,1},{1,1},{2,2}}, 7));\n    }\n\n    public static int countMatches(int[][] matches, int numRounds) {\n        int matchCount = 0;\n        for (int i = 0; i < numRounds; i++) {\n            if ((matches[i][0] == 1 && matches[i][1] == 1) || \n                (matches[i][0] == 2 && matches[i][1] == 2)) {\n                matchCount++;\n            }\n        }\n        return matchCount;\n    }\n\n}",
  "1689": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minPartitions(\"32\")); // Expected output: 2\n        System.out.println(minPartitions(\"82734\")); // Expected output: 4\n        System.out.println(minPartitions(\"982032\")); // Expected output: 3\n    }\n\n    public static int minPartitions(String s) {\n        int max = 0;\n        for (char c : s.toCharArray()) {\n            if ((c - '0') > max) {\n                max = (c - '0');\n            }\n        }\n        return (int)Math.ceil(Math.log10(max + 1)) / Math.log10(2);\n    }\n}",
  "1690": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] piles = {{0,2,7,5}, {6,4,8,1,3}};\n        System.out.println(stoneGameVII(piles));\n        \n        int[][] piles1 = {{10, 50, 30, 100} };\n        System.out.println(stoneGameVII(piles1));\n\n        int[][] piles2 = {};\n        System.out.println(stoneGameVII(piles2));\n\n    }\n\n    public static boolean stoneGameVII(int[][] p) {\n        if (p.length == 0) return true;\n        \n        int n = p[0].length;\n        int[][] dp = new int[n][n];\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = p[0][i];\n        }\n        \n        for (int length = 2; length <= n; length++) {\n            for (int left = 0, right = 0; ; right += length) {\n                if (right >= n) break;\n                int sumLeft = 0, sumRight = 0;\n                for (int i = left; i < left + length && i < n; i++) {\n                    sumLeft += p[0][i];\n                }\n                for (int i = right; i < right + length && i < n; i++) {\n                    sumRight += p[0][i];\n                }\n                \n                if (sumLeft > sumRight) dp[left][right] = 1;\n                else if (sumLeft < sumRight) dp[left][right] = -1;\n                else dp[left][right] = 0;\n            }\n        }\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dp[i][j] == 0) return false;\n            }\n        }\n        \n        return true;\n    }\n}\n```",
  "1691": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maximumHeight(new int[][]{{5, 1}, {2, 5}, {4, 3}})); // Test case 1: Expected output 5\n        System.out.println(maximumHeight(new int[][]{{1, 8}, {2, 9}, {5, 12}, {15, 20}})); // Test case 2: Expected output 20\n        System.out.println(maximumHeight(new int[][]{{10, 3}, {2, 6}})); // Test case 3: Expected output 11\n    }\n\n    public static int maximumHeight(int[][] cuboids) {\n        Arrays.sort(cuboids, (a, b) -> a[1] - b[1]);\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < cuboids.length - 1; i++) {\n            if (cuboids[i][1] > cuboids[i + 1][1]) {\n                max = Math.max(max, cuboids[i][0] * (cuboids[i][1] - cuboids[i + 1][1]));\n            }\n        }\n        return max;\n    }\n}",
  "1692": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countWays(1, new int[]{2, 4}, 2));\n        System.out.println(countWays(3, new int[]{5, 8, 9, 10}, 3));\n        System.out.println(countWays(4, new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}, 4));\n    }\n\n    public static int countWays(int n, int[] candies, int k) {\n        int[][] dp = new int[n + 1][k + 1];\n        for (int i = 0; i <= n; i++) {\n            dp[i][0] = 1;\n        }\n        for (int j = 0; j <= k; j++) {\n            if (j > 0) {\n                dp[0][j] = 0;\n            } else {\n                dp[0][j] = 1;\n            }\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= k; j++) {\n                if (candies[i - 1] >= j) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[n][k];\n    }\n}\n```",
  "1693": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(dailyLeadsAndPartners(\"John\", \"Jane\", \"Alice\", \"Bob\")); // Test Case 1\n        System.out.println(dailyLeadsAndPartners(\"Mike\", \"Sarah\", \"Emily\", \"Tom\")); // Test Case 2\n        System.out.println(dailyLeadsAndPartners(\"Alex\", \"Maya\", \"Nina\", \"Max\")); // Test Case 3\n    }\n\n    public static String dailyLeadsAndPartners(String lead1, String partner1, String lead2, String partner2) {\n        return String.format(\"%s and %s\\n%s and %s\",\n                lead1, partner1,\n                lead2, partner2);\n    }\n}\n```",
  "1694": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(reformatPhoneNumber(\"1234567890\")); // expected output: \"12-34-567890\"\n        System.out.println(reformatPhoneNumber(\"(123) 456-7890\")); // expected output: \"(123) 456-7890\"\n        System.out.println(reformatPhoneNumber(\"1-234-5678901\")); // expected output: \"1-234-5678 901\"\n    }\n\n    public static String reformatPhoneNumber(String number) {\n        StringBuilder sb = new StringBuilder();\n        int dashCount = 0;\n        for (int i = 0; i < number.length(); i++) {\n            if (Character.isDigit(number.charAt(i))) {\n                sb.append(number.charAt(i));\n            } else if (!sb.toString().isEmpty() && sb.length() >= 3) {\n                sb.insert(sb.length() - 2, '-');\n                dashCount++;\n            }\n        }\n        while (dashCount < 3 && sb.length() > 4) {\n            sb.insert(sb.length() - 1, '-');\n            dashCount++;\n        }\n        return sb.toString().trim();\n    }\n}",
  "1695": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumErasureValue(new int[]{4,2,10,3}, \"naohgr\"));// Expected: 6\n        System.out.println(maximumErasureValue(new int[]{1,5,7,9}, \"etahw\"));// Expected: 9\n        System.out.println(maximumErasureValue(new int[]{10,3,4,8}, \"leet\"));// Expected: 17\n    }\n\n    public static int maximumErasureValue(int[] nums, String keyword) {\n        int n = nums.length;\n        int maxVal = 0;\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.put((char) (nums[i] + 'a'), i);\n        }\n        for (char c : keyword.toCharArray()) {\n            if (!map.containsKey(c)) {\n                continue;\n            }\n            int i = map.get(c);\n            int j = map.getOrDefault(c, -1);\n            maxVal = Math.max(maxVal, Math.max(i, n - 1 - j));\n            map.remove(c);\n        }\n        return maxVal * (maxVal + 1) / 2;\n    }\n}\n```",
  "1696": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] jumps1 = {{0,1},{2,3}};\n        System.out.println(\"Result for input [0,1],[2,3]: \" + maxResult(jumps1));\n        \n        int[][] jumps2 = {{0,4}};\n        System.out.println(\"Result for input [0,4]: \" + maxResult(new int[][]{jumps2}));  \n\n        int[][] jumps3 = {{0,1},{3,2},{4,4},{2,3},{4,2},{0,0}};\n        System.out.println(\"Result for input [0,1],[3,2],[4,4],[2,3],[4,2],[0,0]: \" + maxResult(new int[][]{jumps3}));\n    }\n\n    public static int maxResult(int[][] jumps) {\n        int n = jumps.length;\n        List<Integer> arr = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            arr.add(i);\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, 0);\n        queue.offer(0);\n\n        int maxSoFar = 0;\n        while (!queue.isEmpty()) {\n            int pos = queue.poll();\n            for (int i = 0; i <= arr.get(pos); i++) {\n                if (i > n - 1) continue;\n                if (map.containsKey(i)) {\n                    map.remove(i);\n                } else {\n                    map.put(i, pos + jumps[i][1] + 1);\n                    queue.offer(i);\n                }\n            }\n        }\n        \n        return map.getOrDefault(n-1, 0);\n    }\n}",
  "1697": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph = {{0,1,10},{0,2,15},{1,2,4}};\n        System.out.println(canReach(5, graph, 3));\n        \n        int[][] graph1 = {{0,1,4},{1,2,3},{2,3,2}};\n        System.out.println(canReach(7, graph1, 2));\n\n        int[][] graph2 = {{0,1,5},{1,2,13},{0,2,6}};\n        System.out.println(canReach(9, graph2, 2));\n    }\n\n    public static boolean canReach(int n, int[][] edges, int maxCost) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        \n        boolean[] visited = new boolean[n];\n        Arrays.fill(visited, false);\n        \n        return dfs(graph, 0, maxCost, visited);\n    }\n\n    public static boolean dfs(List<List<Integer>> graph, int node, int cost, boolean[] visited) {\n        if (cost < 0) {\n            return false;\n        }\n        if (node == -1) {\n            return true;\n        }\n        \n        if (visited[node]) {\n            return false;\n        }\n        \n        visited[node] = true;\n        \n        for (int neighbor : graph.get(node)) {\n            if (!dfs(graph, neighbor, cost - 10, visited)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n```",
  "1698": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numDistinctSubstrings(\"ABC\"));//4\n        System.out.println(numDistinctSubstrings(\"BBB\"));//3\n        System.out.println(numDistinctSubstrings(\"aaa\"));//2\n    }\n\n    public static int numDistinctSubstrings(String s) {\n        // Code to solve the problem goes here\n    }\n}\n```",
  "1700": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] orders = {{1,1},{2,0},{3,1},{4,1},{5,1},{5,1}};\n        System.out.println(numberOfUnsuccessfulExchanges(orders));\n        \n        int[][] orders2 = {{7,0},{7,1},{7,0}};\n        System.out.println(numberOfUnsuccessfulExchanges(orders2));\n\n        int[][] orders3 = {{2,0},{6,1},{5,0},{8,0},{4,1}};\n        System.out.println(numberOfUnsuccessfulExchanges(orders3));\n    }\n\n    public static int numberOfUnsuccessfulExchanges(int[][] orders) {\n        Arrays.sort(orders, (a, b) -> Integer.compare(a[1], b[1]));\n        \n        int unsuccessful = 0;\n        for (int i = 0; i < orders.length - 1; i++) {\n            if (orders[i][1] == orders[i + 1][1]) {\n                unsuccessful++;\n            }\n        }\n        \n        return unsuccessful;\n    }\n}\n```",
  "1699": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countCalls(\"John,Smith,john.smith@com.com,2020-07-21 12:00:00\", \"Mary,Campbel,mary.campbell@com.com,2020-08-22 13:30:00\"));\n        System.out.println(countCalls(\"John,Smith,john.smith@com.com,2020-05-31 15:30:00\", \"Alice,Ahn,a.little.aholic@com.com,2021-02-25 10:30:00\"));\n        System.out.println(countCalls(\"Bob,Logan,bob.logan@com.com,2019-09-19 14:50:00\", \"Charlie,Brown,charlie.brown@com.com,2020-04-21 11:20:00\"));\n    }\n\n    public static int countCalls(String personA, String personB) {\n        String[] callData = personA.split(\",\");\n        String[] callDetail = personB.split(\",\");\n\n        long startCallTime = Long.parseLong(callDetail[3].substring(0, 19).replace(\" \", \"\"));\n        long endCallTime = Long.parseLong(callDetail[3].substring(20).replace(\" \", \"\"));\n\n        int duration = (int) ((endCallTime - startCallTime) / 60000);\n\n        return duration;\n    }\n}\n```",
  "1701": "```\npublic class Solution {\n    public double averageWaitingTime(int[][] customers) {\n        int totalWaiting = 0;\n        for (int i = 1; i < customers.length; i++) {\n            totalWaiting += customers[i][1] - customers[i-1][1];\n        }\n        return (double)totalWaiting / (customers.length - 1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        int[][] test1 = {{7,10},{2,3}};\n        System.out.println(\"Test Case 1: \" + solution.averageWaitingTime(test1));\n\n        // Test Case 2\n        int[][] test2 = {{5,8},{4,6},{7,9}};\n        System.out.println(\"Test Case 2: \" + solution.averageWaitingTime(test2));\n\n        // Test Case 3\n        int[][] test3 = {{10,15},{1,3}};\n        System.out.println(\"Test Case 3: \" + solution.averageWaitingTime(test3));\n    }\n}",
  "1702": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumBinaryString(\"1012\")); // Expected: \"1110\"\n        System.out.println(maximumBinaryString(\"32\")); // Expected: \"10000\"\n        System.out.println(maximumBinaryString(\"1100220111\")); // Expected: \"1111111111\"\n    }\n\n    public static String maximumBinaryString(String bin) {\n        char[] arr = bin.toCharArray();\n        int maxIndex = -1;\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == '0') {\n                maxIndex = i;\n                break;\n            }\n        }\n        for (int i = maxIndex + 1; i < arr.length; i++) {\n            if (arr[i] == '1') {\n                arr[maxIndex] = '1';\n                arr[i] = '1';\n                return new String(arr);\n            }\n        }\n        return bin;\n    }\n}\n```",
  "1704": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"book\", \"cook\")); // true\n        System.out.println(canBeEqual(\"aa\", \"bb\")); // false\n        System.out.println(canBeEqual(\"ab\", \"ba\")); // true\n    }\n\n    public static boolean canBeEqual(String s, String t) {\n        if (s.length() != t.length()) return false;\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if ((s.charAt(i) ^ t.charAt(i)) == '1') count++;\n        }\n        return count <= s.length() / 2;\n    }\n}\n```",
  "1703": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {\n            {1,0,0,1,1},\n            {1,1,1,0,1},\n            {1,1,1,1,1}\n        };\n        int[] outputs = {5,4,3};\n        \n        for (int i = 0; i < inputs.length; i++) {\n            System.out.println(\"Input: \" + Arrays.toString(inputs[i]) +\n                               \", Output: \" + minKBitFlips(inputs[i], outputs[i]));\n        }\n    }\n\n    public static int minKBitFlips(int[] arr, int k) {\n        int res = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if ((arr[i] & 1) == 1 || res >= k) {\n                res++;\n                i += Math.min(i + k - 1, arr.length - 1);\n            }\n        }\n        return res;\n    }\n}\n```",
  "1705": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] startingApples = {1,2,5};\n        System.out.println(\"Expected: \" + maxEaten(7, startingApples));\n        \n        startingApples = new int[]{5,3,1};\n        System.out.println(\"Expected: \" + maxEaten(11, startingApples));\n\n        startingApples = new int[]{23,11,45,2,34,22,2,33,31};\n        System.out.println(\"Expected: \" + maxEaten(40, startingApples));\n    }\n\n    public static int maxEaten(int hours, int[] apples) {\n        Arrays.sort(apples);\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int i = 0; i < apples.length; i++) {\n            pq.offer(apples[i]);\n        }\n        \n        int eaten = 0;\n        while (!pq.isEmpty()) {\n            if ((pq.peek() / 3) <= hours) {\n                eaten += pq.poll() / 3;\n                if (hours > 0) {\n                    hours -= pq.poll() / 3;\n                } else {\n                    break;\n                }\n            } else {\n                eaten += pq.poll();\n                hours--;\n            }\n        }\n        \n        return eaten;\n    }\n}",
  "1706": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{-5}};\n        int[] result1 = new int[grid1.length];\n        for (int i = 0; i < grid1.length; i++) {\n            int sum = 0;\n            for (int j = 0; j < grid1[i].length; j++) {\n                sum += grid1[i][j];\n            }\n            if (sum > 0) {\n                result1[i] = 1;\n            } else {\n                result1[i] = -1;\n            }\n        }\n        System.out.println(Arrays.toString(result1));\n\n        int[][] grid2 = {{10,11,-12},{7,1,15},{-5,3,4}};\n        int[] result2 = new int[grid2.length];\n        for (int i = 0; i < grid2.length; i++) {\n            int sum = 0;\n            for (int j = 0; j < grid2[i].length; j++) {\n                sum += grid2[i][j];\n            }\n            if (sum > 0) {\n                result2[i] = 1;\n            } else {\n                result2[i] = -1;\n            }\n        }\n        System.out.println(Arrays.toString(result2));\n\n        int[][] grid3 = {{-1,-1,1},{1,0,5},{-2,-3,-4}};\n        int[] result3 = new int[grid3.length];\n        for (int i = 0; i < grid3.length; i++) {\n            int sum = 0;\n            for (int j = 0; j < grid3[i].length; j++) {\n                sum += grid3[i][j];\n            }\n            if (sum > 0) {\n                result3[i] = 1;\n            } else {\n                result3[i] = -1;\n            }\n        }\n        System.out.println(Arrays.toString(result3));\n    }\n}\n```",
  "1707": "```\npublic class Solution {\n    public int[] maxAbsoluteSum(int[] nums) {\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        int sum = 0;\n\n        for (int num : nums) {\n            sum += num;\n            if (num > max) max = num;\n            if (num < min) min = num;\n        }\n\n        return new int[]{Math.abs(sum), Math.max(Math.abs(max), Math.abs(min))};\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        int[] test1 = solution.maxAbsoluteSum(new int[]{1,-3,9,-7,2});\n        System.out.println(\"Test 1: \" + Arrays.toString(test1));\n\n        int[] test2 = solution.maxAbsoluteSum(new int[]{-1000,0}));\n        System.out.println(\"Test 2: \" + Arrays.toString(test2));\n\n        int[] test3 = solution.maxAbsoluteSum(new int[]{6,-7,10,0,2});\n        System.out.println(\"Test 3: \" + Arrays.toString(test3));\n    }\n}",
  "1708": "```\npublic class Solution {\n    public int maxSubArrayLen(int[] nums, int k) {\n        if (nums.length < k) return 0;\n        int start = 0;\n        int end = 0;\n        int maxLen = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        while (end < nums.length) {\n            map.put(nums[end], end);\n            if (end - start + 1 >= k) {\n                maxLen = Math.max(maxLen, end - start + 1);\n                if (map.getOrDefault(nums[start], 0) == start) {\n                    start++;\n                } else {\n                    start = map.get(nums[start]) + 1;\n                }\n            }\n            end++;\n        }\n        return maxLen;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] nums1 = {2, 3, 4};\n        System.out.println(\"Test case 1: \" + solution.maxSubArrayLen(nums1, 2));\n        \n        int[] nums2 = {1, 2, 3, 4, 5};\n        System.out.println(\"Test case 2: \" + solution.maxSubArrayLen(nums2, 3));\n        \n        int[] nums3 = {1, 2, 1, 2, 1, 2};\n        System.out.println(\"Test case 3: \" + solution.maxSubArrayLen(nums3, 4));\n    }\n}",
  "1709": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + biggestWindow(new int[]{100, 101, 102, 103, 104}, 2));\n        System.out.println(\"Test Case 2: \" + biggestWindow(new int[]{1, 2, 3, 1}, 4));\n        System.out.println(\"Test Case 3: \" + biggestWindow(new int[]{1, 3, 5}, 3));\n\n    }\n\n    public static int biggestWindow(int[] visitors, int k) {\n        int max = 0;\n        int left = 0;\n        for (int right = 0; right < visitors.length; right++) {\n            if (right - left + 1 > k) {\n                left++;\n            }\n            max = Math.max(max, right - left + 1);\n        }\n        return max;\n    }\n}",
  "1710": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] boxTypes = {{1,3},{2,2},{3,1}};\n        System.out.println(maximumUnits(boxTypes));\n        \n        int[][] boxTypes2 = {{5,10},{2,5},{4,7},{3,9}};\n        System.out.println(maximumUnits(boxTypes2));\n\n        int[][] boxTypes3 = {{1,8},{2,7},{3,6}};\n        System.out.println(maximumUnits(boxTypes3));\n    }\n\n    public static int maximumUnits(int[][] boxTypes) {\n        Arrays.sort(boxTypes, (a, b) -> b[1] - a[1]);\n        \n        int maxUnits = 0;\n        for (int i = 0; i < boxTypes.length; i++) {\n            maxUnits += Math.min(boxTypes[i][0], boxTypes[i][1] / boxTypes[i][0]) * boxTypes[i][0];\n        }\n        \n        return maxUnits;\n    }\n}\n```",
  "1711": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] orders1 = {{10,20},{11,11},{12,6}};\n        System.out.println(\"Expected: 5, Actual: \" + countGoodMeals(orders1));\n\n        int[][] orders2 = {{1,2},{0,2},{3,4}};\n        System.out.println(\"Expected: 5, Actual: \" + countGoodMeals(orders2));\n\n        int[][] orders3 = {{10,20},{11,99},{12,6}};\n        System.out.println(\"Expected: 8, Actual: \" + countGoodMeals(orders3));\n    }\n\n    public static int countGoodMeals(int[][] orders) {\n        int n = orders.length;\n        HashMap<Integer,Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            if (!map.containsKey(orders[i][1])) {\n                map.put(orders[i][1], 0);\n            }\n            map.put(orders[i][1], map.get(orders[i][1]) + orders[i][0]);\n        }\n        int res = 0;\n        for (int end : map.keySet()) {\n            if (!map.containsKey(end - 60)) {\n                res += map.get(end);\n            } else {\n                res += Math.min(map.get(end), map.getOrDefault(end - 60, 0));\n            }\n        }\n        return res;\n    }\n}\n```",
  "1712": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countWays(new int[]{2,1,-1,4})); // Expected: 2\n        System.out.println(countWays(new int[]{0,2,-2,-3,2})) ;// Expected: 2\n        System.out.println(countWays(new int[]{-2,5,-1,2,-4,3,2,-3})); // Expected: 4\n    }\n\n    public static int countWays(int[] nums) {\n        long leftSum = 0;\n        long rightSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (i % 3 == 0) {\n                leftSum += nums[i];\n            } else if (i % 3 == 1) {\n                rightSum -= nums[i];\n            }\n        }\n        long totalSum = leftSum + rightSum;\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if ((totalSum - leftSum) > leftSum && (i % 3 == 1)) {\n                res++;\n                leftSum += nums[i];\n                totalSum -= nums[i];\n            }\n        }\n        return res;\n    }\n}",
  "1713": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minOperations(new int[]{5,1,3}, new int[]{9,4,2,3,4,7,10,9,3,2,8,0,1,6,9,3,4,3,5}));\n        System.out.println(minOperations(new int[]{10,2}, new int[]{10,2,9,6}));\n        System.out.println(minOperations(new int[]{15,13,12}, new int[]{14,19,9,1,3,15,26,22,23,24,25}));\n    }\n\n    public static int minOperations(int[] target, int[] arr) {\n        Arrays.sort(arr);\n        int res = 0;\n        for (int a : arr) {\n            if (!Arrays.asList(target).contains(a)) {\n                while (target.length > res && !Arrays.asList(target).get(res).equals(a)) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```",
  "1714": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfSpecialEvenlySpacedElements(new int[]{1, 2, 4, 5, 7}, 0)); // Output: 9\n        System.out.println(sumOfSpecialEvenlySpacedElements(new int[]{2, 3, 6, 8}, 1)); // Output: 14\n        System.out.println(sumOfSpecialEvenlySpacedElements(new int[]{0, 0, 1, 2, 4, 5, 7, 9, 10}, 2)); // Output: 25\n    }\n\n    public static int sumOfSpecialEvenlySpacedElements(int[] arr, int K) {\n        if (K > arr.length || K < 0) return 0;\n        \n        int n = arr.length;\n        int res = 0;\n\n        for (int i = 0; i < n; i++) {\n            if ((i + 1) % (2 * K + 1) == 0 && arr[i] % 2 == 0) {\n                res += arr[i];\n            }\n        }\n\n        return res;\n    }\n}\n```",
  "1716": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + calculateChange(5, [20, 10, 1]));\n        System.out.println(\"Test case 2: \" + calculateChange(3, [15, 4]));\n        System.out.println(\"Test case 3: \" + calculateChange(19, [25, 50]));\n    }\n\n    public static int calculateChange(int amount, int[] coins) {\n        int change = 0;\n        for (int coin : coins) {\n            while (amount >= coin) {\n                amount -= coin;\n                change++;\n            }\n        }\n        return change;\n    }\n}\n```",
  "1715": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countApplesAndOranges(7, 11, 5, 15));\n        System.out.println(countApplesAndOranges(2, 1, 4, 2));\n        System.out.println(countApplesAndOranges(10, 10, 5, 10));\n    }\n\n    public static int countApplesAndOranges(int s, int t, int a, int b, int[] apples, int[] oranges) {\n        int countApples = 0;\n        int countOranges = 0;\n\n        for (int apple : apples) {\n            if ((a + apple) >= s && (a + apple) <= t) {\n                countApples++;\n            }\n        }\n\n        for (int orange : oranges) {\n            if ((b + orange) >= s && (b + orange) <= t) {\n                countOranges++;\n            }\n        }\n\n        return countApples + countOranges;\n    }\n}",
  "1717": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumScore(\"124\")) ; \n        System.out.println(maximumScore(\"3145\")) ;\n        System.out.println(maximumScore(\"9264\"));\n    }\n\n    public static int maximumScore(String s) {\n        int n = s.length();\n        int res = 0;\n        for (int i = 1; i < n - 1; i++) {\n            if ((s.charAt(i - 1) == '1' && s.charAt(i) == '2') || (s.charAt(i) == '3' && s.charAt(i + 1) == '4')) {\n                res++;\n                i++;\n            }\n        }\n        return res;\n    }\n}\n```",
  "1718": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] sequences = {{{1,2}, {11,10}}, {{9,7},{6,4},{5,8}}, {{0,3},{1,1}}};\n        for (int i = 0; i < sequences.length; i++) {\n            System.out.println(\"The lexicographically largest valid sequence is: \" + constructLexicographicallyLargestValidSequence(sequences[i]));\n        }\n    }\n\n    public static String constructLexicographicallyLargestValidSequence(int[][] nums) {\n        // your implementation here\n        return \"\";\n    }\n}\n```",
  "1719": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numWays(new int[][]{{1,2},{2,3}})) + \"\\n\");\n        System.out.println(numWays(new int[][]{{0,1},{1,2},{2,3},{1,4},{4,5}})) + \"\\n\");\n        System.out.println(numWays(new int[][]{})) + \"\\n\");\n    }\n\n    public static int numWays(int[][] edges) {\n        if (edges.length < 1) return 1;\n        int n = edges.length + 1;\n        List<Integer>[] graph = new List[n];\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\n        for (int[] edge : edges) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) if (graph[i].size() == 1) res += dfs(graph, i, -1);\n        return res / 2;\n    }\n\n    public static int dfs(List<Integer>[] graph, int node, int parent) {\n        if (node >= 0 && graph[node] == null) return 0;\n        if (graph[node].size() < 1 || graph[node].size() > 2) return 0;\n        int res = 1;\n        for (int neighbor : graph[node]) if (neighbor != parent) {\n            res *= dfs(graph, neighbor, node);\n        }\n        return res;\n    }\n}",
  "1720": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] encoded = {1,2,3};\n        System.out.println(Arrays.toString(decode(encoded)));\n        \n        int[] encoded2 = {6,2,7,3};\n        System.out.println(Arrays.toString(decode(encoded2)));\n\n        int[] encoded3 = {100};\n        System.out.println(Arrays.toString(decode(encoded3)));\n    }\n\n    public static int[] decode(int[] encoded) {\n        int n = encoded.length;\n        int[] decoded = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            decoded[i] = (i & encoded[i]) ^ i;\n        }\n        \n        return decoded;\n    }\n}",
  "1722": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,1},{1,0}};\n        System.out.println(\"Test case 1: \" + minSwaps(grid1));\n        \n        int[][] grid2 = {{0,1,0},{1,1,1},{0,0,0}};\n        System.out.println(\"Test case 2: \" + minSwaps(grid2));\n\n        int[][] grid3 = {{0,1,0},{1,0,1},{1,1,1}};\n        System.out.println(\"Test case 3: \" + minSwaps(grid3));\n    }\n\n    public static int minSwaps(int[][] grid) {\n        // Your code here\n    }\n}",
  "1721": "```\npublic class Main {\n    public static void main(String[] args) {\n        Node head1 = new Node(1);\n        head1.next = new Node(2);\n        head1.next.next = new Node(3);\n        head1.next.next.next = new Node(4);\n\n        int k1 = 2;\n        swapNodes(head1, k1);\n\n        printList(head1);\n\n        System.out.println();\n\n        Node head2 = new Node(5);\n        head2.next = new Node(6);\n        head2.next.next = new Node(7);\n        head2.next.next.next = new Node(8);\n\n        int k2 = 3;\n        swapNodes(head2, k2);\n\n        printList(head2);\n\n        System.out.println();\n\n        Node head3 = new Node(9);\n        head3.next = new Node(10);\n        head3.next.next = new Node(11);\n        head3.next.next.next = new Node(12);\n        head3.next.next.next.next = new Node(13);\n\n        int k3 = 5;\n        swapNodes(head3, k3);\n\n        printList(head3);\n    }\n\n    public static void printList(Node head) {\n        while (head != null) {\n            System.out.print(head.val + \" \");\n            head = head.next;\n        }\n        System.out.println();\n    }\n\n    public static ListNode swapNodes(ListNode head, int k) {\n        if (k < 1 || head == null || head.next == null) return head;\n\n        ListNode prev = null;\n        ListNode current = head;\n        for (int i = 0; i < k - 1 && current != null; i++) {\n            prev = current;\n            current = current.next;\n        }\n        if (current == null) return head;\n\n        int distanceFromStart = 0;\n        ListNode temp = head;\n        while (temp != current) {\n            temp = temp.next;\n            distanceFromStart++;\n        }\n\n        ListNode nodeToSwap = head;\n        for (int i = 0; i < distanceFromStart - k; i++) {\n            nodeToSwap = nodeToSwap.next;\n        }\n\n        int val1 = prev.val;\n        int val2 = nodeToSwap.val;\n\n        prev.val = val2;\n        nodeToSwap.val = val1;\n\n        return head;\n    }\n}\n\nclass Node {\n    int val;\n    Node next;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n    }\n}\n```",
  "1723": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] start = {1,2,4};\n        int[] finish = {3,3,2};\n        System.out.println(minTimeToFinishJobs(start, finish));\n        \n        start = new int[]{7,7,6};\n        finish = new int[]{5,6,8};\n        System.out.println(minTimeToFinishJobs(start, finish));\n\n        start = new int[]{1, 3, 2};\n        finish = new int[]{5,4,6};\n        System.out.println(minTimeToFinishJobs(start, finish));\n    }\n\n    public static int minTimeToFinishJobs(int[] start, int[] finish) {\n        // Your code here\n    }\n}",
  "1724": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] graph1 = {{0, 1, 10}, {0, 2, 3}, {1, 2, 1}, {3, 4, 4}};\n        System.out.println(canFinish(5, graph1, 6));\n\n        int[][] graph2 = {{0, 1, 5}, {1, 2, 1}, {2, 3, 1}};\n        System.out.println(canFinish(4, graph2, 3));\n\n        int[][] graph3 = {{0, 1, 5}, {1, 2, 10}, {2, 3, 3}};\n        System.out.println(canFinish(4, graph3, 6));\n    }\n\n    public static boolean canFinish(int n, int[][] edges, int maxCost) {\n        // Write your solution here\n        UnionFind uf = new UnionFind(n);\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], cost = edge[2];\n            if (cost <= maxCost && !uf.union(u, v)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    static class UnionFind {\n        private int[] parent;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        public boolean union(int u, int v) {\n            if (parent[u] == parent[v]) {\n                return false;\n            }\n            parent[v] = parent[u];\n            return true;\n        }\n    }\n}\n```",
  "1725": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,1,1,1},{1,1,1,1},{0,1,0,0}};\n        System.out.println(\"Test Case 1: \" + largestSquare(grid1));\n        \n        int[][] grid2 = {{1,0,1,0},{0,0,1,0},{1,0,1,0},{1,0,0,0}};\n        System.out.println(\"Test Case 2: \" + largestSquare(grid2));\n        \n        int[][] grid3 = {{0,1,1},{1,1,0},{1,0,1}};\n        System.out.println(\"Test Case 3: \" + largestSideLength(grid3));\n    }\n\n    public static int largestSquare(int[][] grid) {\n        if (grid.length == 0) return 0;\n        \n        int maxSide = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[i].length; j++) {\n                if (grid[i][j] == 1) {\n                    int sideLength = Math.min(i, j) + 1;\n                    while (sideLength <= maxSide) {\n                        sideLength++;\n                        boolean canFormSquare = true;\n                        for (int k = i - sideLength + 1; k <= i; k++) {\n                            if (!canFormSquare) break;\n                            for (int m = j - sideLength + 1; m <= j; m++) {\n                                if (grid[k][m] == 0) {\n                                    canFormSquare = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (canFormSquare) maxSide = sideLength;\n                    }\n                }\n            }\n        }\n        \n        return maxSide * maxSide;\n    }\n}\n```",
  "1726": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = { {{2,1,2}, 5 }, {{7,3,4,7}, 0 }, {{5,6,9,8,4,1}, 18} };\n        \n        for (int i = 0; i < inputs.length; i++) {\n            int[][] tuples = inputs[i][0];\n            int target = inputs[i][1];\n            System.out.println(\"Input: \" + Arrays.deepToString(tuples) + \", Target: \" + target);\n            System.out.println(\"Output: \" + countTuplesSameProduct(tuples, target));\n            System.out.println();\n        }\n    }\n\n    public static int countTuplesSameProduct(int[][] tuples, int target) {\n        Map<Integer, Integer> productCount = new HashMap<>();\n        \n        for (int[] tuple : tuples) {\n            int product = 1;\n            for (int num : tuple) {\n                product *= num;\n            }\n            productCount.put(product, productCount.getOrDefault(product, 0) + 1);\n        }\n        \n        int count = 0;\n        for (Map.Entry<Integer, Integer> entry : productCount.entrySet()) {\n            if (entry.getKey() == target) {\n                count += entry.getValue();\n            } else if (-target % entry.getKey() != 0) continue;\n            count += Math.min(entry.getValue(), productCount.getOrDefault(-target / entry.getKey(), 0));\n        }\n        \n        return count;\n    }\n}",
  "1727": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{11,10,9},{10,11,12},{9,12,11}};\n        System.out.println(\"Largest submatrix for matrix1: \" + largestSubMatrix(matrix1));\n\n        int[][] matrix2 = {{1,0,1},{0,0,1},{1,1,6}];\n        System.out.println(\"Largest submatrix for matrix2: \" + largestSubMatrix(matrix2));\n\n        int[][] matrix3 = {{5,1,3,4},{9,7,6,10},{12,14,15,16}};\n        System.out.println(\"Largest submatrix for matrix3: \" + largestSubMatrix(matrix3));\n    }\n\n    public static int largestSubMatrix(int[][] matrix) {\n        if (matrix == null || matrix.length < 1 || matrix[0].length < 1) {\n            return 0;\n        }\n\n        int maxSize = 0;\n        for (int i = 0; i < matrix.length; i++) {\n            int[] temp = new int[matrix[0].length];\n            for (int j = 0; j < matrix[0].length; j++) {\n                temp[j] = matrix[i][j];\n            }\n            Arrays.sort(temp);\n            for (int k = 0; k < matrix.length; k++) {\n                if (matrix[k][0] >= temp[0]) {\n                    int left = k;\n                    while (left + 1 < matrix.length && matrix[left + 1][0] >= temp[0]) {\n                        left++;\n                    }\n                    for (int i = 0; i < matrix[0].length; i++) {\n                        for (int j = left; j <= left; j++) {\n                            if (matrix[i][j] < temp[0]) {\n                                int right = j;\n                                while (right + 1 < matrix[0].length && matrix[i][right + 1] < temp[0]) {\n                                    right++;\n                                }\n                                int size = (right - left + 1) * (temp[temp.length - 1] - temp[0] + 1);\n                                maxSize = Math.max(size, maxSize);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return maxSize;\n    }\n}",
  "1728": "```\npublic class Solution {\n    public int minimumTime(int[] time, int totalTrials) {\n        int n = time.length;\n        int[][] dp = new int[totalTrials + 1][n];\n        for (int i = 0; i < n; i++) {\n            dp[0][i] = time[i];\n        }\n        for (int i = 1; i <= totalTrials; i++) {\n            for (int j = 0; j < n; j++) {\n                if (j == 0) {\n                    dp[i][j] = Math.min(dp[i - 1][n - 1], time[j]);\n                } else {\n                    dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), time[j]);\n                }\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for (int i = n - 1; i >= 0; i--) {\n            if (dp[totalTrials][i] < res) {\n                res = dp[totalTrials][i];\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.minimumTime(new int[]{1, 2}, 3)); // 1\n        System.out.println(solution.minimumTime(new int[]{3, 7, 1, 6}, 4)); // 4\n        System.out.println(solution.minimumTime(new int[]{14, 28, 15, 10, 5, 25, 23, 17}, 3)); // 11\n    }\n}",
  "1729": "```\npublic class Solution {\n    public int findFollowersCount(String[] followerList) {\n        Map<String, Integer> followers = new HashMap<>();\n        for (String follower : followerList) {\n            String[] splitFollower = follower.split(\":\");\n            if (splitFollower.length == 2) {\n                followers.put(splitFollower[0], Integer.parseInt(splitFollower[1]));\n            }\n        }\n        return followers.size();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        String[] test1Followers = {\"Alice:10\", \"Bob:5\", \"Charlie:2\"};\n        System.out.println(\"Test case 1: \" + solution.findFollowersCount(test1Followers)); // Output: 3\n\n        // Test case 2\n        String[] test2Followers = {\"John:15\", \"Michael:8\"};\n        System.out.println(\"Test case 2: \" + solution.findFollowersCount(test2Followers)); // Output: 2\n\n        // Test case 3\n        String[] test3Followers = {};\n        System.out.println(\"Test case 3: \" + solution.findFollowersCount(test3Followers)); // Output: 0\n    }\n}",
  "1730": "```\nimport java.util.*;\n\npublic class Solution {\n    public int eatUntilFull(int[][] grid) {\n        int rows = grid.length;\n        if (rows == 0) return -1;\n\n        int cols = grid[0].length;\n        if (cols == 0) return -1;\n\n        boolean[][] visited = new boolean[rows][cols];\n        Queue<int[]> queue = new LinkedList<>();\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1) {\n                    queue.offer(new int[]{i, j});\n                    visited[i][j] = true;\n                }\n            }\n        }\n\n        int totalFood = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] curr = queue.poll();\n                if (grid[curr[0]][curr[1]] == 2) totalFood++;\n\n                if (curr[0] > 0 && !visited[curr[0]-1][curr[1]]) {\n                    queue.offer(new int[]{curr[0]-1, curr[1]});\n                    visited[curr[0]-1][curr[1]] = true;\n                }\n\n                if (curr[0] < rows-1 && !visited[curr[0]+1][curr[1]]) {\n                    queue.offer(new int[]{curr[0]+1, curr[1]});\n                    visited[curr[0]+1][curr[1]] = true;\n                }\n\n                if (curr[1] > 0 && !visited[curr[0]][curr[1]-1]) {\n                    queue.offer(new int[]{curr[0], curr[1]-1});\n                    visited[curr[0]][curr[1]-1] = true;\n                }\n\n                if (curr[1] < cols-1 && !visited[curr[0]][curr[1]+1]) {\n                    queue.offer(new int[]{curr[0], curr[1]+1});\n                    visited[curr[0]][curr[1]+1] = true;\n                }\n            }\n        }\n\n        return totalFood;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.eatUntilFull(new int[][]{\n            {1, 1, 1, 0},\n            {1, 1, 1, 0},\n            {1, 0, 1, 0}\n        })); // Expected: 5\n\n        System.out.println(solution.eatUntilFull(new int[][]{\n            {0, 1, 0, 0},\n            {0, 1, 1, 0},\n            {0, 1, 1, 1},\n            {0, 1, 0, 0}\n        })); // Expected: 3\n\n        System.out.println(solution.eatUntilFull(new int[][]{\n            {1, 0, 0, 0},\n            {2, 1, 0, 0},\n            {2, 2, 2, 0},\n            {0, 0, 1, 0}\n        })); // Expected: 4\n    }\n}",
  "1731": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<Integer> numOfReports(int[] idToEmployee, int[] employeeToReport) {\n        Map<Integer, Set<Integer>> reportMap = new HashMap<>();\n        for (int i = 0; i < employeeToReport.length; i++) {\n            if (!reportMap.containsKey(employeeToReport[i])) {\n                reportMap.put(employeeToReport[i], new HashSet<>());\n            }\n            reportMap.get(employeeToReport[i]).add(idToEmployee[i]);\n        }\n        List<Integer> result = new ArrayList<>();\n        for (int id : reportMap.keySet()) {\n            result.add(reportMap.get(id).size());\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] idToEmployee = {1, 2, 3};\n        int[] employeeToReport = {2, 1, 2};\n        System.out.println(\"Test case 1: \" + Arrays.toString(solution.numOfReports(idToEmployee, employeeToReport)));\n        \n        idToEmployee = new int[]{4, 5, 6, 7, 8};\n        employeeToReport = new int[]{7, 7, 6, 6, 5};\n        System.out.println(\"Test case 2: \" + Arrays.toString(solution.numOfReports(idToEmployee, employeeToReport)));\n        \n        idToEmployee = new int[]{-1, 0, 1, 3};\n        employeeToReport = new int[]{0, -1, 1, -1};\n        System.out.println(\"Test case 3: \" + Arrays.toString(solution.numOfReports(idToEmployee, employeeToReport)));\n    }\n}",
  "1732": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] gain = new int[][]{{1, -2}, {2, 3}, {-2, 1}};\n        System.out.println(highestAltitude(gain)); // expected output: 5\n\n        int[][] gain2 = new int[][]{{-5, 1}, 1, 5};\n        System.out.println(highestAltitude(gain2)); // expected output: 0\n\n        int[][] gain3 = new int[][]{{-1, -2}, {-2, -3}};\n        System.out.println(highestAltitude(gain3)); // expected output: -1\n    }\n\n    public static int highestAltitude(int[][] gain) {\n        int maxAlt = 0;\n        for (int i = 0; i < gain.length; i++) {\n            int altitude = 0;\n            for (int j = 0; j <= i; j++) {\n                altitude += gain[j][i >= j ? 1 : 0];\n            }\n            maxAlt = Math.max(maxAlt, altitude);\n        }\n        return maxAlt;\n    }\n}",
  "1733": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minNumberToTeach(new int[]{17,77,5}, new String[]{\"John\", \"Mary\", \"David\"}));\n        System.out.println(minNumberToTeach(new int[]{70,100,30}, new String[]{\"Alex\", \"Bob\", \"Charlie\"}));\n        System.out.println(minNumberToTeach(new int[]{50,100,25,12}, new String[]{\"Sarah\", \"Jane\", \"John\", \"Emily\"}));\n    }\n\n    public static int minNumberToTeach(int[] ages, String[] names) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < ages.length; i++) {\n            map.put(names[i], ages[i]);\n        }\n        \n        Arrays.sort(ages);\n        \n        int teacherCount = 1;\n        int previousAge = ages[0];\n        for (int age : ages) {\n            if (age > 2 * previousAge) {\n                teacherCount++;\n            }\n            previousAge = age;\n        }\n        \n        return teacherCount;\n    }\n}\n```",
  "1734": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {6,5,4,6};\n        System.out.println(\"Result for arr1: \" + decodePermutation(arr1));\n        \n        int[] arr2 = {1,2,3,4};\n        System.out.println(\"Result for arr2: \" + decodePermutation(arr2));\n        \n        int[] arr3 = {10,12,15,5};\n        System.out.println(\"Result for arr3: \" + decodePermutation(arr3));\n    }\n\n    public static List<Integer> decodePermutation(int[] arr) {\n        List<Integer> result = new ArrayList<>();\n        for (int i : arr) {\n            int index = i ^ 1;\n            result.add(index);\n        }\n        return result;\n    }\n}",
  "1735": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countWays(new int[]{2,3,4}, 18));\n        System.out.println(countWays(new int[]{10,2,5,4,1}, 13));\n        System.out.println(countWays(new int[]{7,9,8}, 35));\n    }\n\n    public static int countWays(int[] nums, int target) {\n        int MOD = (int)1e9 + 7;\n        int n = nums.length;\n        long[][] dp = new long[n][n];\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = (nums[i] == 1 || target % nums[i] == 0) ? 1 : 0;\n        }\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i < n - len + 1; i++) {\n                int j = i + len - 1;\n                if (nums[i] == nums[j]) {\n                    dp[i][j] = (dp[i][i] * dp[i+1][j-1] + 1) % MOD;\n                } else if ((long)target / nums[i] >= nums[j+1]) {\n                    dp[i][j] = (dp[i][i] * dp[i+1][j-1] + dp[i+1][j] * dp[i][j-1]) % MOD;\n                }\n            }\n        }\n        return (int)dp[0][n-1];\n    }\n}",
  "1736": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(latestTime(\"2:30\"));// \"23:34\"\n        System.out.println(latestTime(\"11:60\"));// \"11:59\"\n        System.out.println(latestTime(\"0:00\"));// \"0:00\"\n\n    }\n\n    public static String latestTime(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c == ':') {\n                int hour = Integer.parseInt(sb.toString());\n                int minute = 59;\n                if (hour * 60 + minute > 3600) {\n                    if (hour < 23) {\n                        sb.delete(0, sb.length());\n                        sb.append(hour + 1);\n                        break;\n                    }\n                    return \"23:59\";\n                } else {\n                    sb.delete(0, sb.length());\n                    sb.append(minute);\n                    break;\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString() + \":59\";\n    }\n}\n```",
  "1737": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSteps(\"abc\", \"defgh\"));//1\n        System.out.println(minSteps(\"xyxyzyyxy\", \"xyxyxyzxz\"));//2\n        System.out.println(minSteps(\"a\", \"abba\"));//3\n    }\n\n    public static int minSteps(String s, String t) {\n        int m = s.length(), n = t.length();\n        int[] cntS = new int[26], cntT = new int[26];\n        for (int i = 0; i < m; i++)cntS[s.charAt(i) - 'a']++;\n        for (int i = 0; i < n; i++)cntT[t.charAt(i) - 'a']++;\n        int res = Math.abs(m - n), diff = 0;\n        for (int i = 0; i < 26; i++){\n            int cS = cntS[i], cT = cntT[i];\n            if ((cS > 0 && cT > 0) || (cS == 0 && cT == 0))\n                continue;\n            res += Math.max(0, cS - cT);\n        }\n        return res;\n    }\n}",
  "1738": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] coordinates = {{1,6},{3,13},{5,5},{11,2}};\n        System.out.println(kthLargestValue(coordinates, 2));\n        \n        coordinates = new int[][]{{9,8,6},{1,3,2},{4,7,5}};\n        System.out.println(kthLargestValue(coordinates, 3));\n        \n        coordinates = {{5,2,6},{0,9,10},{3,7,15},{13,5,11},{19,8,16}};\n        System.out.println(kthLargestValue(coordinates, 4));\n    }\n\n    public static int kthLargestValue(int[][] coordinates, int K) {\n        TrieNode root = new TrieNode();\n        for (int i = 0; i < coordinates.length; i++) {\n            TrieNode current = root;\n            for (int j = 0; j < coordinates[i].length; j++) {\n                if (coordinates[i][j] % 2 == 1) {\n                    if (current.right == null) {\n                        current.right = new TrieNode();\n                    }\n                    current = current.right;\n                } else {\n                    if (current.left == null) {\n                        current.left = new TrieNode();\n                    }\n                    current = current.left;\n                }\n            }\n        }\n\n        int[] res = new int[K];\n        for (int i = 0; i < K; i++) {\n            TrieNode current = root;\n            for (int j = 0; j < coordinates[0].length; j++) {\n                if ((j & 1) == 1) {\n                    if (current.right != null) {\n                        current = current.right;\n                    } else {\n                        current = current.left;\n                    }\n                } else {\n                    if (current.left != null) {\n                        current = current.left;\n                    } else {\n                        current = current.right;\n                    }\n                }\n            }\n            res[i] = current.value;\n        }\n\n        Arrays.sort(res);\n        return res[K - 1];\n    }\n\n    static class TrieNode {\n        int value;\n        TrieNode left, right;\n\n        public TrieNode() {\n            this.value = 0;\n            this.left = null;\n            this.right = null;\n        }\n    }\n}",
  "1739": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(boxing(integers(1, 5), 4));\n        System.out.println(boxing(integers(2, 10), 8));\n        System.out.println(boxing(integers(9, 15), 14));\n    }\n\n    public static int boxing(int[] integers, int n) {\n        Arrays.sort(integers);\n        int left = 0;\n        int right = integers.length - 1;\n        while (left <= right) {\n            if (integers[(left + right) / 2] * 2 > n) {\n                right = (left + right) / 2 - 1;\n            } else {\n                left = (left + right) / 2 + 1;\n            }\n        }\n        return integers[right];\n    }\n\n    public static int[] integers(int min, int max) {\n        int[] result = new int[max - min + 1];\n        for (int i = 0; i < max - min + 1; i++) {\n            result[i] = min + i;\n        }\n        return result;\n    }\n}",
  "1741": "```\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\n\npublic class Main {\n    public static void main(String[] args) {\n        findTotalTimeSpent();\n    }\n\n    public static void findTotalTimeSpent() {\n        try {\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            Connection con = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/employees\", \"username\", \"password\");\n\n            String query = \"SELECT name, SUM(time) as total_time FROM employee_work_time GROUP BY name\";\n            PreparedStatement ps = con.prepareStatement(query);\n            ResultSet rs = ps.executeQuery();\n\n            while (rs.next()) {\n                System.out.println(\"Name: \" + rs.getString(\"name\") + \", Total Time Spent: \" + rs.getInt(\"total_time\"));\n            }\n\n            con.close();\n        } catch (Exception e) {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n```",
  "1740": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root = new TreeNode(1);\n        root.left = new TreeNode(2);\n        root.right = new TreeNode(3);\n        root.left.left = new TreeNode(4);\n        root.left.right = new TreeNode(5);\n\n        System.out.println(\"Test case 1: \" + findDistance(root, 3) + \" expected: 3\");\n        System.out.println(\"Test case 2: \" + findDistance(root, 5) + \" expected: 2\");\n        System.out.println(\"Test case 3: \" + findDistance(root, 4) + \" expected: 1\");\n\n    }\n\n    public static int findDistance(TreeNode root, int target) {\n        if (root == null) return -1;\n        \n        Map<Integer, Integer> parentMap = new HashMap<>();\n        fillParentMap(root, null, parentMap);\n        \n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            \n            if (node.val == target) {\n                return getDistance(node.val, root.val, parentMap);\n            }\n            \n            if (node.left != null) queue.add(node.left);\n            if (node.right != null) queue.add(node.right);\n        }\n\n        return -1;\n    }\n\n    private static void fillParentMap(TreeNode node, Integer parent, Map<Integer, Integer> map) {\n        if (node == null) return;\n\n        map.put(node.val, parent);\n\n        fillParentMap(node.left, node.val, map);\n        fillParentMap(node.right, node.val, map);\n    }\n\n    public static int getDistance(int target, int rootVal, Map<Integer, Integer> parentMap) {\n        if (parentMap.get(target).equals(rootVal)) return 0;\n\n        int distance = 0;\n        while (!rootVal.equals(parentMap.get(target))) {\n            target = parentMap.get(target);\n            distance++;\n        }\n\n        return distance + 1;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1742": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] boxes = {{2,1,3}, {5},{4,4}};\n        for (int i = 0; i < boxes.length; i++) {\n            System.out.println(\"Maximum number of balls in a box \" + (i+1) + \": \" + maximumBalls(boxes[i]));\n        }\n    }\n\n    public static int maximumBalls(int[][] boxes) {\n        int maxCount = 0;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] box : boxes) {\n            Arrays.sort(box);\n            int start = box[0];\n            int end = box[box.length - 1];\n            for (int i = start; i <= end; i++) {\n                maxCount += map.getOrDefault(i, 0);\n                map.put(i, map.getOrDefault(i, 0) + 1);\n            }\n        }\n        return maxCount;\n    }\n}",
  "1744": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] dailyCandies = new int[][]{{1,2},{5,6},{9,9}};\n        System.out.println(canEat(dailyCandies));\n        \n        int[][] dailyCandies2 = new int[][]{{3, 10}, {12, 20}, {30, 60}};\n        System.out.println(canEat(dailyCandies2));\n        \n        int[][] dailyCandies3 = new int[][]{{1,1},{4,4},{8,6}};\n        System.out.println(canEat(dailyCandies3));\n    }\n    \n    public static boolean canEat(int[][] dailyCandies) {\n        for (int i = 0; i < dailyCandies.length; i++) {\n            if ((dailyCandies[i][1] - dailyCandies[i][0]) % 2 != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1743": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] pairs1 = {{1, 2}, {1, 3}};\n        System.out.println(Arrays.deepToString(restoreArray(pairs1)));\n\n        int[][] pairs2 = {{4, 5}, {5, 6}};\n        System.out.println(Arrays.deepToString(restoreArray(pairs2)));\n\n        int[][] pairs3 = {{0, 2}, {1, 3}};\n        System.out.println(Arrays.deepToString(restoreArray(pairs3)));\n    }\n\n    public static int[] restoreArray(int[][] pairs) {\n        Map<Integer, Set<Integer>> map = new HashMap<>();\n        for (int[] pair : pairs) {\n            map.computeIfAbsent(pair[0], k -> new HashSet<>()).add(pair[1]);\n            map.computeIfAbsent(pair[1], k -> new HashSet<>()).add(pair[0]);\n        }\n\n        List<Integer> result = new ArrayList<>();\n        Set<Integer> visited = new HashSet<>();\n        for (Map.Entry<Integer, Set<Integer>> entry : map.entrySet()) {\n            if (!visited.contains(entry.getKey())) {\n                dfs(map, visited, entry.getKey(), result);\n            }\n        }\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    private static void dfs(Map<Integer, Set<Integer>> map, Set<Integer> visited, int node, List<Integer> result) {\n        visited.add(node);\n        for (int neighbor : map.getOrDefault(node, new HashSet<>())) {\n            if (!visited.contains(neighbor)) {\n                dfs(map, visited, neighbor, result);\n            } else {\n                result.add(0, neighbor);\n                return;\n            }\n        }\n        result.add(node);\n    }\n}\n```",
  "1745": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isPalindromePartitionable(\"aab\", true));\n        System.out.println(isPalindromePartitionable(\"a\", false));\n        System.out.println(isPalindromePartitionable(\"\", true));\n    }\n\n    public static boolean isPalindromePartitionable(String s, boolean expected) {\n        if (expected != isPalindromePartitionable(s)) {\n            System.out.println(\"Test case failed. Expected: \" + expected + \". Got: \" + !expected);\n        }\n    }\n\n    public static boolean isPalindromePartitionable(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n\n        for (int length = 2; length <= n; length++) {\n            for (int i = 0; i < n - length + 1; i++) {\n                int j = i + length - 1;\n                if (s.charAt(i) == s.charAt(j) && length == 2) {\n                    dp[i][j] = true;\n                } else if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                System.out.print(dp[i][j] + \" \");\n            }\n            System.out.println();\n        }\n\n        for (int i = 0; i < n - 1; i++) {\n            if (!dp[0][i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}",
  "1746": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumSum(new int[]{1, 12}, 5)); // Test case 1: Expected output = 13\n        System.out.println(maximumSum(new int[]{2, -3, 4}, 10)); // Test case 2: Expected output = 7\n        System.out.println(maximumSum(new int[]{-1, -2, -3}, 5)); // Test case 3: Expected output = 2\n    }\n\n    public static int maximumSum(int[] nums, int removeIndex) {\n        int sum = 0;\n        for (int i = 0; i < removeIndex; i++) {\n            sum += nums[i];\n        }\n        for (int i = removeIndex + 1; i < nums.length; i++) {\n            sum += nums[i];\n        }\n\n        int maxSum = sum;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (i != removeIndex) {\n                sum = 0;\n                int j = 0;\n                while (j <= i) {\n                    sum += nums[j];\n                    j++;\n                }\n                while (j < nums.length) {\n                    sum += nums[j];\n                    j++;\n                }\n                maxSum = Math.max(maxSum, sum);\n            }\n        }\n\n        return maxSum;\n    }\n}",
  "1747": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1:\n        String[] customer = {\"John\", \"johnsmithmail.com\"};\n        List<String> banned = Arrays.asList(\"johnsmithemail.com\");\n        System.out.println(solution.numBanned(\"John johnsmithmail.com john_newemail.com\", banned));\n\n        // Test case 2:\n        customer = new String[]{\"Alice\", \"bob@example.com\"};\n        banned = Arrays.asList(\"bob@example.com\", \"alice@example.com\");\n        System.out.println(solution.numBanned(\"Alice bob@example.com carol@leetcode.com\", banned));\n\n        // Test case 3:\n        customer = new String[]{\"Paul\", \"paul@example.com\", \"paula@example.com\"};\n        banned = Arrays.asList(\"paula@example.com\", \"paul@example.com\");\n        System.out.println(solution.numBanned(\"Paul paul@example.com pault@example.com\", banned));\n    }\n}\n```",
  "1748": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums = {{1,2,3}, {1,1,2,3}, {5}};\n        for (int i = 0; i < nums.length; i++) {\n            System.out.println(\"Sum of unique elements in array \" + i + \": \" + sumOfUniqueElements(nums[i]));\n        }\n    }\n\n    public static int sumOfUniqueElements(int[][] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] num : nums) {\n            for (int n : num) {\n                map.put(n, map.getOrDefault(n, 0) + 1);\n            }\n        }\n        int sum = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() == 1) {\n                sum += entry.getKey();\n            }\n        }\n        return sum;\n    }\n}\n```",
  "1750": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(minimumLength(\"ababa\")); // Output: 2\n        System.out.println(minimumLength(\"bazaz\")); // Output: 3\n        System.out.println(minimumLength(\"abcde\")); // Output: 5\n    }\n\n    public static int minimumLength(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        \n        while (left < right && s.charAt(left) == s.charAt(right)) {\n            if (s.charAt(left) == s.charAt(left + 1)) {\n                left++;\n            } else {\n                break;\n            }\n            \n            if (s.charAt(right) == s.charAt(right - 1)) {\n                right--;\n            } else {\n                break;\n            }\n        }\n\n        return Math.min(left + 1, right + 1);\n    }\n}\n```",
  "1749": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] testCases = {\n            {{2,3,-1}}, // Expected output: 5 (subarray [2, 3])\n            {{-2,-3,0,-1]], // Expected output: 3 (subarray [-1, 0])\n            {{-1, -2, -3]], // Expected output: 4 (subarray [-1, 2])\n        };\n\n        for (int[] testCase : testCases) {\n            int[][] nums = {testCase};\n            System.out.println(\"Test case: \" + Arrays.toString(testCase));\n            System.out.println(\"Expected output: \" + maxAbsoluteSum(nums) + \"\\n\");\n        }\n    }\n\n    public static int maxAbsoluteSum(int[][] nums) {\n        if (nums.length == 0) return 0;\n\n        int maxSoFar = Integer.MIN_VALUE, minSoFar = Integer.MAX_VALUE;\n        int currentMax = Integer.MIN_VALUE, currentMin = Integer.MAX_VALUE;\n\n        for (int[] row : nums) {\n            for (int num : row) {\n                currentMax = Math.max(num, currentMax + num);\n                currentMin = Math.min(num, currentMin + num);\n\n                maxSoFar = Math.max(maxSoFar, currentMax);\n                minSoFar = Math.min(minSoFar, currentMin);\n            }\n        }\n\n        return Math.max(Math.abs(maxSoFar), Math.abs(minSoFar));\n    }\n}",
  "1751": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] events = {{1,4},{2,4},{3,4},{4,5}};\n        System.out.println(maxEvents(events));\n        \n        int[][] events2 = {{1,3},{2,3},{3,3},{4,6},{7,8},{8,9},{10,11},{12,14}};\n        System.out.println(maxEvents(events2));\n        \n        int[][] events3 = {{1,3},{3,5},{5,6},{6,7}};\n        System.out.println(maxEvents(events3));\n    }\n\n    public static int maxEvents(int[][] events) {\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\n        \n        int res = 0;\n        int end = 0;\n        for (int[] event : events) {\n            if (event[0] >= end) {\n                res++;\n                end = event[1];\n            }\n        }\n        return res;\n    }\n}",
  "1752": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = { {{1, 2, 3, 4, 5}, true},\n                {{3, 4, 5, 1, 2}, true},\n                {{1, 6, 7, 8, 9}, false}};\n\n        for (int i = 0; i < arrays.length; i++) {\n            int[] array = arrays[i][0];\n            boolean result = isSortedAndRotated(array);\n            System.out.println(\"Is \" + Arrays.toString(array) + \" sorted and rotated: \" + result);\n        }\n    }\n\n    public static boolean isSortedAndRotated(int[] nums) {\n        if (nums == null || nums.length < 2) return true;\n        int start = -1, end = -1;\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i] > nums[i + 1]) {\n                if (start == -1) start = i;\n                else end = i;\n            }\n        }\n        return start != -1 && isSorted(nums, start);\n    }\n\n    public static boolean isSorted(int[] nums, int start) {\n        for (int i = start; i < nums.length; i++) {\n            if (nums[i] < nums[start]) return false;\n        }\n        return true;\n    }\n}",
  "1753": "```\npublic class Main {\n    public static void main(String[] args) {\n        int stones = maxScoreOfStones(new int[]{5,6,7,8,9});\n        System.out.println(stones);\n        \n        stones = maxScoreOfStones(new int[]{10,1,2,3,4});\n        System.out.println(stones);\n\n        stones = maxScoreOfStones(new int[]{20,1,15,8,5});\n        System.out.println(stones);\n    }\n\n    public static int maxScoreOfStones(int[] piles) {\n        // Your code here\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a, b) -> Integer.compare(b, a));\n        for (int pile : piles) {\n            heap.offer(pile);\n        }\n        int score = 0;\n        while (heap.size() > 1) {\n            int maxPile = heap.poll();\n            int secMaxPile = heap.poll();\n            score += maxPile - secMaxPile;\n            if (maxPile - 1 > secMaxPile) {\n                heap.offer(maxPile - 1);\n            }\n        }\n        return score;\n    }\n}\n```",
  "1754": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(largestMerge(\"abc#z\", \"pmz#h\")); // Expected: \"pbmc\"\n        System.out.println(largestMerge(\"ab#c\", \"ad#c\")); // Expected: \"adcbc\"\n        System.out.println(largestMerge(\"a#\", \"b\")); // Expected: \"ab\"\n    }\n\n    public static String largestMerge(String word1, String word2) {\n        StringBuilder sb = new StringBuilder();\n        int i = 0, j = 0;\n        while (i < word1.length() || j < word2.length()) {\n            if ((i < word1.length() && j >= word2.length()) || (j < word2.length() && i >= word1.length())) {\n                if (i < word1.length()) sb.append(word1.charAt(i++));\n                else sb.append(word2.charAt(j++));\n            } else if (word1.charAt(i) > word2.charAt(j)) {\n                sb.append(word1.charAt(i++));\n                j++;\n            } else {\n                sb.append(word2.charAt(j++));\n                i++;\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "1755": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2, -5, 6, -2, 0};\n        System.out.println(\"Closest sum for \" + Arrays.toString(nums1) + \": \" + closestSubsequenceSum(nums1));\n        \n        int[] nums2 = {4, -3, 2, -2, 5};\n        System.out.println(\"Closest sum for \" + Arrays.toString(nums2) + \": \" + closestSubsequenceSum(nums2));\n        \n        int[] nums3 = {-7, 1, 6, -9, 10};\n        System.out.println(\"Closest sum for \" + Arrays.toString(nums3) + \": \" + closestSubsequenceSum(nums3));\n    }\n\n    public static int closestSubsequenceSum(int[] nums) {\n        // Your code here\n    }\n}\n```",
  "1756": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        MostRecentlyUsedQueue mrq = new MostRecentlyUsedQueue(5);\n\n        // Test Case 1\n        mrq.push(1);\n        System.out.println(mrq.peekMostRecent()); // Output: 1\n        System.out.println(mrq.peekLeastRecent()); // Output: null\n\n        mrq.push(2);\n        mrq.push(3);\n        System.out.println(mrq.peekMostRecent()); // Output: 3\n        System.out.println(mrq.peekLeastRecent()); // Output: 1\n\n        mrq.pop();\n        System.out.println(mrq.peekMostRecent()); // Output: 2\n        System.out.println(mrq.peekLeastRecent()); // Output: 1\n\n        // Test Case 2\n        mrq = new MostRecentlyUsedQueue(3);\n        mrq.push(5);\n        mrq.push(4);\n        mrq.push(6);\n\n        System.out.println(mrq.peekMostRecent()); // Output: 6\n        System.out.println(mrq.peekLeastRecent()); // Output: 5\n\n        mrq.pop();\n        mrq.pop();\n\n        System.out.println(mrq.peekMostRecent()); // Output: 4\n        System.out.println(mrq.peekLeastRecent()); // Output: 5\n\n        mrq.pop();\n        System.out.println(mrq.peekMostRecent()); // Output: null\n        System.out.println(mrq.peekLeastRecent()); // Output: null\n\n        // Test Case 3\n        mrq = new MostRecentlyUsedQueue(1);\n        mrq.push(7);\n\n        System.out.println(mrq.peekMostRecent()); // Output: 7\n        System.out.println(mrq.peekLeastRecent()); // Output: 7\n\n        mrq.pop();\n        System.out.println(mrq.peekMostRecent()); // Output: null\n        System.out.println(mrq.peekLeastRecent()); // Output: null\n    }\n}\n```",
  "1757": "```\npublic class Solution {\n    public int productSales(int sales) {\n        if (sales < 0 || sales > 1000000) return -1;\n        else if (sales <= 20000) return 3;\n        else if (sales <= 50000) return 2;\n        else return 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(\"Test case 1: \" + solution.productSales(15000));\n        System.out.println(\"Test case 2: \" + solution.productSales(40000));\n        System.out.println(\"Test case 3: \" + solution.productSales(75000));\n    }\n}",
  "1758": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minChanges(\"0102\")); // Expected: 1\n        System.out.println(minChanges(\"03234\")); // Expected: 2\n        System.out.println(minChanges(\"10101111\")); // Expected: 0\n    }\n\n    public static int minChanges(String s) {\n        char prev = '0';\n        int changes = 0;\n        for (char c : s.toCharArray()) {\n            if ((c == '1' && prev == '1') || (c == '0' && prev == '0')) {\n                changes++;\n            }\n            prev = c;\n        }\n        return changes / 2;\n    }\n}",
  "1759": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countHomogenous(\"abbcccdddbb\"));\n        System.out.println(countHomogenous(\"aaa\"));\n        System.out.println(countHomogenous(\"abc\"));\n    }\n\n    public static int countHomogenous(String s) {\n        int res = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            char c = s.charAt(i);\n            int count = 1;\n            while (i + 1 < s.length() && s.charAt(i + 1) == c) {\n                i++;\n                count++;\n            }\n            res += count;\n        }\n        return res;\n    }\n}\n```",
  "1760": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minEvasion(new int[]{4,5,6}, 2)); // expected: 4\n        System.out.println(minEvasion(new int[]{7,7,7,7,7,7,7,7,7,7}, 1)); // expected: 1\n        System.out.println(minEvasion(new int[]{1,3,5,8,2}, 4)); // expected: 2\n    }\n\n    public static int minEvasion(int[] balls, int m) {\n        Arrays.sort(balls);\n        int left = 0, right = balls.length - 1;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if ((balls[mid] + 1) * m <= balls[right]) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return balls[left];\n    }\n}\n```",
  "1761": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumTrioDegree(new int[][]{{1,2},{5,6}})); // Test case 1: Expected output = 0\n        System.out.println(minimumTrioDegree(new int[][]{{1,2,3,4},{8,9,10,11},{23,24,25,26}})); // Test case 2: Expected output = 3\n        System.out.println(minimumTrioDegree(new int[][]{{1,2,3,4,5},{7,8,9,10,11},{12,13,14,15,16,17,18,19,20,21,22}})); // Test case 3: Expected output = 0\n    }\n\n    public static int minimumTrioDegree(int[][] trips) {\n        Map<Integer, Integer> degreeMap = new HashMap<>();\n        for (int[] trip : trips) {\n            for (int node : trip) {\n                degreeMap.put(node, degreeMap.getOrDefault(node, 0) + 1);\n            }\n        }\n        int minDegree = Integer.MAX_VALUE;\n        for (Map.Entry<Integer, Integer> entry : degreeMap.entrySet()) {\n            if (entry.getValue() == 3) {\n                minDegree = Math.min(minDegree, entry.getKey());\n            }\n        }\n        return minDegree == Integer.MAX_VALUE ? -1 : minDegree;\n    }\n}\n```",
  "1762": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{0,2},{2,2}};\n        System.out.println(\"Expected: 2, Actual: \" + buildingsWithOceanView(grid1));\n        \n        int[][] grid2 = {{3,0,9,0},{3,2,6,2},{4,2,8,1},{4,1,7,3}};\n        System.out.println(\"Expected: 5, Actual: \" + buildingsWithOceanView(grid2));\n\n        int[][] grid3 = {{1,1,1},{0,1,1}};\n        System.out.println(\"Expected: 1, Actual: \" + buildingsWithOceanView(grid3));\n    }\n\n    public static int buildingsWithOceanView(int[][] grid) {\n        if (grid.length == 0) return 0;\n        \n        int count = 0;\n        for (int i = 0; i < grid[0].length; i++) {\n            boolean flag = true;\n            for (int j = 1; j < grid.length; j++) {\n                if (grid[j][i] >= grid[j-1][i]) {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag) count++;\n        }\n\n        return count;\n    }\n}\n```",
  "1763": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestNiceSubstring(\"YazaAxn\"));\n        System.out.println(longestNiceSubstring(\"Bb\"));//\"bb\"\n        System.out.println(longestNiceSubstring(\"cc\")); // \"cc\"\n    }\n\n    public static String longestNiceSubstring(String s) {\n        int n = s.length();\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j <= n; j++) {\n                String substr = s.substring(i, j);\n                if (isNice(substr)) {\n                    if (sb.length() < substr.length()) {\n                        sb.delete(0, sb.length());\n                        sb.append(substr);\n                    }\n                }\n            }\n        }\n        return sb.toString();\n    }\n\n    public static boolean isNice(String s) {\n        int n = s.length();\n        for (int i = 0; i < n / 2; i++) {\n            if (((s.charAt(i) - 'a' + 1) & 1) != ((s.charAt(n - 1 - i) - 'a' + 1) & 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "1764": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canFormArray(new String[]{\"wanna\", \"be\", \"with\", \"him\"}, new int[][]{{1, 5}, {0, 1}, {3, 4}}));\n        System.out.println(canFormArray(new String[]{\"practice\", \"makes\", \"perfect\"}, new int[][]{{0, 1}, {2, 3}, {6, 7}, {8, 9}}));\n        System.out.println(canFormArray(new String[]{\"\"}, new int[][]{}));\n    }\n\n    public static boolean canFormArray(String[] words, int[][] p) {\n        for (int i = 0; i < p.length; i++) {\n            if (!canForm(words, p[i][0], p[i][1])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static boolean canForm(String[] words, int start, int end) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = start; i <= end; i++) {\n            sb.append(words[i]);\n        }\n        String s = sb.toString();\n        for (int i = 0; i < words.length; i++) {\n            if (s.startsWith(words[i])) {\n                if (!s.equals(words[i] + (i > start ? \"\" : s.substring(words[i].length())))) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1766": "```\npublic class Solution {\n    public int longestCoprime(int[] nums) {\n        // your logic here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] nums1 = {1,2,5};\n        System.out.println(\"Length of Coprimes for \" + Arrays.toString(nums1) + \": \" + solution.longestCoprime(nums1));\n        \n        int[] nums2 = {7,13,19};\n        System.out.println(\"Length of Coprimes for \" + Arrays.toString(nums2) + \": \" + solution.longestCoprime(nums2));\n        \n        int[] nums3 = {14,12,5};\n        System.out.println(\"Length of Coprimes for \" + Arrays.toString(nums3) + \": \" + solution.longestCoprime(nums3));\n    }\n}",
  "1765": "```\nimport java.util.*;\n\nclass Solution {\n    public int highestPeak(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int res = -1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    Queue<int[]> q = new LinkedList<>();\n                    boolean[][] visited = new boolean[m][n];\n                    q.add(new int[]{i, j});\n                    visited[i][j] = true;\n                    int step = 0;\n                    while (!q.isEmpty()) {\n                        int size = q.size();\n                        for (int k = 0; k < size; k++) {\n                            int[] curr = q.poll();\n                            int x = curr[0], y = curr[1];\n                            if (x == m - 1) {\n                                res = step;\n                                return res;\n                            }\n                            for (int dx : new int[]{-1, 1}) {\n                                int nx = x + dx;\n                                if (nx >= 0 && nx < m && !visited[nx][y] && grid[nx][y] == 0) {\n                                    q.add(new int[]{nx, y});\n                                    visited[nx][y] = true;\n                                }\n                            }\n                            for (int dy : new int[]{-1, 1}) {\n                                int ny = y + dy;\n                                if (ny >= 0 && ny < n && !visited[x][ny] && grid[x][ny] == 0) {\n                                    q.add(new int[]{x, ny});\n                                    visited[x][ny] = true;\n                                }\n                            }\n                        }\n                        step++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid1 = {{0, 0}, {0, 1}};\n        System.out.println(solution.highestPeak(grid1)); // 2\n\n        int[][] grid2 = {{0, 1, 0},{0, 0, 0},{0, 0, 0}};\n        System.out.println(solution.highestPeak(grid2)); // 3\n\n        int[][] grid3 = {{0, 1, 0}, {0, 1, 0},{0, 1, 0}};\n        System.out.println(solution.highestPeak(grid3)); // -1\n    }\n}",
  "1767": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = new int[][]{\n            {1, 2, 3}, \n            {}, \n            {0, 7, 8, 9}\n        };\n        \n        System.out.println(\"Test Case 1: \" + findUnfinishedSubtasks(logs[0]));\n        System.out.println(\"Test Case 2: \" + findUnfinishedSubtasks(logs[1]));\n        System.out.println(\"Test Case 3: \" + findUnfinishedSubtasks(logs[2]));\n\n    }\n\n    public static int[] findUnfinishedSubtasks(int[][] logs) {\n        // Your solution here\n        return new int[]{};\n    }\n}\n```",
  "1768": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(mergeAlternately(\"abc\", \"pqr\")); // expected output: \"apbqcr\"\n        System.out.println(mergeAlternately(\"ab\", \"pqrs\")); // expected output: \"aqbspr\"\n        System.out.println(mergeAlternately(\"\", \"hello\")); // expected output: \"hello\"\n    }\n\n    public static String mergeAlternately(String word1, String word2) {\n        StringBuilder sb = new StringBuilder();\n        int i = 0, j = 0;\n        while (i < word1.length() && j < word2.length()) {\n            sb.append(word1.charAt(i));\n            sb.append(word2.charAt(j));\n            i++;\n            j++;\n        }\n        sb.append(word1.substring(i));\n        sb.append(word2.substring(j));\n        return sb.toString();\n    }\n}\n```",
  "1769": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] boxes = {{1, 1}, {2, 3, 2}, {3, 4, 2, 1}};\n        System.out.println(minOperations(boxes));\n        \n        boxes = new int[][]{{}, {}};\n        System.out.println(minOperations(boxes));\n\n        boxes = new int[][]{{1}};\n        System.out.println(minOperations(boxes));\n    }\n\n    public static int minOperations(int[][] boxes) {\n        int n = boxes[0].length;\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            int diff = boxes[0][i] - i;\n            for (int j = 1; j < n; j++) {\n                res[j] += Math.abs(boxes[0][j] - j) - diff;\n            }\n        }\n        return Arrays.stream(res).sum();\n    }\n}\n```",
  "1770": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2,5,3};\n        System.out.println(\"Test case 1: \" + maxScore(nums1)); // Expected output: 14\n\n        int[] nums2 = {4,9,6};\n        System.out.println(\"Test case 2: \" + maxScore(nums2)); // Expected output: 27\n\n        int[] nums3 = {5,7,9};\n        System.out.println(\"Test case 3: \" + maxScore(nums3)); // Expected output: 36\n    }\n\n    public static int maxScore(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, Integer.MIN_VALUE);\n        dp[0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            dp[i] = Math.max(dp[i - 1], nums[i] * (i + 1) + (n - i - 1 > 0 ? dp[n - i - 2] : 0));\n        }\n        return dp[n - 1];\n    }\n}",
  "1771": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximizePalindromeLength(\"abaca\", \"aba\")); // Expected: 4\n        System.out.println(maximizePalindromeLength(\"bcbcbc\", \"abcabc\")); // Expected: 5\n        System.out.println(maximizePalindromeLength(\"a\", \"a\")); // Expected: 2\n    }\n\n    public static int maximizePalindromeLength(String s1, String s2) {\n        int m = s1.length(), n = s2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0) {\n                    dp[i][j] = j;\n                } else if (j == 0) {\n                    dp[i][j] = i;\n                } else if (s1.charAt(i - 1) == s2.charAt(j - 1)) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return m + n - 2 * dp[m][n];\n    }\n}\n```",
  "1772": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] features = {{0, 1}, {1, 2}, {2, 3}};\n        System.out.println(sortFeatures(features));\n\n        features = new int[][]{{5, 7, 9}, {10, 11, 12, 13, 14}, {15, 16, 17, 18, 19, 20, 21, 22, 23, 24}};\n        System.out.println(sortFeatures(features));\n\n        features = new int[][]{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};\n        System.out.println(sortFeatures(features));\n    }\n\n    public static String[] sortFeatures(int[][] features) {\n        Map<Integer, Integer> countMap = new HashMap<>();\n        List<String> result = new ArrayList<>();\n\n        for (int[] feature : features) {\n            for (int f : feature) {\n                countMap.put(f, countMap.getOrDefault(f, 0) + 1);\n            }\n        }\n\n        for (int i = 0; i < countMap.size(); i++) {\n            int max = 0;\n            int maxFeature = -1;\n\n            for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {\n                if (entry.getValue() > max) {\n                    max = entry.getValue();\n                    maxFeature = entry.getKey();\n                }\n            }\n\n            for (int[] feature : features) {\n                for (int f : feature) {\n                    if (f == maxFeature) {\n                        result.add(String.valueOf(f));\n                    }\n                }\n            }\n\n            countMap.put(maxFeature, -1);\n        }\n\n        return result.toArray(new String[0]);\n    }\n}",
  "1773": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] items = {{1, \"green\", \"apple\"}, {2, \"red\", \"apple\"}, {4, \"green\", \"banana\"], {4, \"yellow\", \"banana\"}, {5, \"red\", \"cherry\"}};\n        String ruleKey = \"color\";\n        String ruleValue = \"green\";\n        \n        System.out.println(countMatches(items, ruleKey, ruleValue)); // expected output: 2\n        \n        items = new int[][]{{1, \"candy\", \"a\"}, {2, \"candy\", \"e\"}, {3, \"candy\", \"k\"}, {4, \"snack\", \"f\"}, {5, \"snack\", \"b\"}, {6, \"snack\", \"c\"}};\n        ruleKey = \"type\";\n        ruleValue = \"candy\";\n        \n        System.out.println(countMatches(items, ruleKey, ruleValue)); // expected output: 3\n        \n        items = new int[][]{{7, \"station\", \"MyStation\"}, {8, \"tollgate\", \"Another\"}, {9, \"parking\", \"MyStation\"}};\n        ruleKey = \"type\";\n        ruleValue = \"station\";\n        \n        System.out.println(countMatches(items, ruleKey, ruleValue)); // expected output: 1\n    }\n\n    public static int countMatches(int[][] items, String key, String value) {\n        int count = 0;\n        for (int[] item : items) {\n            if (key.equals(\"type\") ? item[0] == Integer.parseInt(value) : item[1].equals(value)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
  "1774": "```\npublic class Solution {\n    public int closestCost(int[] baseCosts, int[] toppingCosts, int target) {\n        // your logic here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        int[] baseCosts1 = {10};\n        int[] toppingCosts1 = {5, 6};\n        System.out.println(\"Test Case 1: \" + solution.closestCost(baseCosts1, toppingCosts1, 15));\n\n        int[] baseCosts2 = {2, 3};\n        int[] toppingCosts2 = {4, 5, 6};\n        System.out.println(\"Test Case 2: \" + solution.closestCost(baseCosts2, toppingCosts2, 9));\n\n        int[] baseCosts3 = {10, 20};\n        int[] toppingCosts3 = {1, 2};\n        System.out.println(\"Test Case 3: \" + solution.closestCost(baseCosts3, toppingCosts3, 5));\n    }\n}",
  "1775": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minOperations(new int[]{1,2,3,4,5}, 6)); // Test case 1: Output should be 1\n        System.out.println(minOperations(new int[]{1,1,2,2,3,3}, 3)); // Test case 2: Output should be 3\n        System.out.println(minOperations(new int[]{5,10,15}, 5)); // Test case 3: Output should be 0\n    }\n\n    public static int minOperations(int[] nums, int target) {\n        int operations = Integer.MAX_VALUE;\n        Map<Integer, Integer> sumToIndex = new HashMap<>();\n        int currentSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            currentSum += nums[i];\n            if (!sumToIndex.containsKey(currentSum)) {\n                sumToIndex.put(currentSum, i);\n            } else {\n                operations = Math.min(operations, i - sumToIndex.get(currentSum));\n                currentSum -= nums[sumToIndex.get(currentSum)];\n                sumToIndex.remove(sumToIndex.get(currentSum));\n            }\n        }\n\n        for (int num : nums) {\n            if (currentSum + num == target) {\n                return 0;\n            } else if (currentSum + num > target) {\n                operations = Math.min(operations, i - sumToIndex.getOrDefault(currentSum, Integer.MAX_VALUE));\n                currentSum -= nums[sumToIndex.getOrDefault(currentSum, Integer.MAX_VALUE)];\n                sumToIndex.remove(sumToIndex.getOrDefault(currentSum, Integer.MAX_VALUE));\n            } else {\n                currentSum += num;\n            }\n        }\n\n        return operations == Integer.MAX_VALUE ? -1 : operations;\n    }\n}\n```",
  "1776": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] t1 = {{10, 3}, {6, 7}, {4, 10}};\n        System.out.println(\"Test case 1: \" + carFleet(t1));\n        \n        int[][] t2 = {{3, 5}, {1, 2}};\n        System.out.println(\"Test case 2: \" + carFleet(t2));\n\n        int[][] t3 = {{9, 10}, {4, 5}, {7, 10}};\n        System.out.println(\"Test case 3: \" + carFleet(t3));\n    }\n\n    public static String carFleet(int[][] positions) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < positions.length; i++) {\n            int dist = 120 - positions[i][1];\n            if (dist >= positions[i][0]) {\n                sb.append(\"1 \");\n            } else {\n                sb.append(\"0 \");\n            }\n        }\n        return sb.toString().trim();\n    }\n}",
  "1777": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        // Test case 1\n        String[] product = {\"shirt\", \"hat\"};\n        int[] price = {10, 5};\n        Solution solution = new Solution();\n        for (int i = 0; i < product.length; i++) {\n            System.out.println(\"Store 1: The price of the \" + product[i] + \" is $\" + solution.getProductPrice(product[i], price));\n        }\n\n        // Test case 2\n        String[] product2 = {\"pants\", \"shirt\"};\n        int[] price2 = {15, 10};\n        Solution solution2 = new Solution();\n        for (int i = 0; i < product2.length; i++) {\n            System.out.println(\"Store 1: The price of the \" + product2[i] + \" is $\" + solution2.getProductPrice(product2[i], price2));\n        }\n\n        // Test case 3\n        String[] product3 = {\"shirt\", \"dress\"};\n        int[] price3 = {10, 20};\n        Solution solution3 = new Solution();\n        for (int i = 0; i < product3.length; i++) {\n            System.out.println(\"Store 1: The price of the \" + product3[i] + \" is $\" + solution3.getProductPrice(product3[i], price3));\n        }\n    }\n}\n\nclass Solution {\n    public int getProductPrice(String name, int[] prices) {\n        for (int i = 0; i < prices.length; i++) {\n            if (name.equals(\"shirt\")) {\n                return prices[1];\n            } else if (name.equals(\"hat\")) {\n                return prices[0];\n            }\n        }\n        return -1;\n    }\n}\n```",
  "1778": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] hiddenGrid1 = {\n            {0, 0, 0},\n            {1, 1, 1}\n        };\n        System.out.println(shortestPath(hiddenGrid1));\n\n        int[][] hiddenGrid2 = {\n            {0, 0, 0, 0},\n            {0, 1, 0, 0},\n            {0, 0, 1, 0},\n            {0, 0, 0, 0}\n        };\n        System.out.println(shortestPath(hiddenGrid2));\n\n        int[][] hiddenGrid3 = {\n            {0, 0, 0, 0, 0},\n            {0, 1, 1, 1, 0},\n            {0, 0, 1, 1, 0},\n            {0, 1, 1, 1, 0},\n            {0, 0, 0, 0, 0}\n        };\n        System.out.println(shortestPath(hiddenGrid3));\n    }\n\n    public static int shortestPath(int[][] hiddenGrid) {\n        // Your code here\n    }\n}",
  "1780": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(checkTernary(12)); // true\n        System.out.println(checkTernary(12345678901234567890L)); // false\n        System.out.println(checkTernary(81)); // true\n    }\n\n    public static boolean checkTernary(long n) {\n        if (n < 1) return false;\n        for (long i = 0; ; i++) {\n            long x = 1, y = 0;\n            while (x <= n) {\n                n -= x;\n                if (n < 0) return false;\n                y++;\n                x *= 3;\n            }\n            if (n == 0) return true;\n            if (y > (long) Math.pow(10, (Math.log10(i) + 1))) return false;\n        }\n    }\n}",
  "1779": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] points = {\n                {{1,2}, {3,4}},\n                {{10,5},{2,7},{6,8}},\n                {{0,0},{1,9},{1,1}}\n        };\n\n        for (int i = 0; i < points.length; i++) {\n            System.out.println(\"Points: \" + Arrays.deepToString(points[i]));\n            nearestPointThatHasTheSameXYCoordinate(points[i]);\n        }\n    }\n\n    public static void nearestPointThatHasTheSameXYCoordinate(int[][] points) {\n        for (int i = 0; i < points.length; i++) {\n            int minDiffX = Integer.MAX_VALUE, minDiffY = Integer.MAX_VALUE;\n            int closestXIndex = -1, closestYIndex = -1;\n\n            // Find the nearest point with same X\n            for (int j = 0; j < points[i].length; j++) {\n                if (points[j][0] == points[0][0]) {\n                    minDiffX = Math.min(minDiffX, Math.abs(points[i][0] - points[0][0]));\n                    closestXIndex = j;\n                }\n            }\n\n            // Find the nearest point with same Y\n            for (int j = 0; j < points[i].length; j++) {\n                if (points[j][1] == points[0][1]) {\n                    minDiffY = Math.min(minDiffY, Math.abs(points[i][1] - points[0][1]));\n                    closestYIndex = j;\n                }\n            }\n\n            System.out.println(\"Nearest point with same X coordinate: \" + points[closestXIndex]);\n            System.out.println(\"Nearest point with same Y coordinate: \" + points[closestYIndex]);\n        }\n    }\n}",
  "1781": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfBeauty(\"abcde\"));\n        System.out.println(sumOfBeauty(\"a\")); // 1\n        System.out.println(sumOfBeauty(\"abcdefghijklmnopqrstuvwxyz\")); // 105\n    }\n\n    public static int sumOfBeauty(String s) {\n        int beautySum = 0;\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String subStr = s.substring(i, j);\n                int beauty = 0;\n                for (char c : subStr.toCharArray()) {\n                    beauty += Math.abs(c - 'a' + 1);\n                }\n                beautySum += beauty;\n            }\n        }\n        return beautySum;\n    }\n}\n```",
  "1782": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] edges = {{1,2},{1,3},{2,3}};\n        int distance = 3;\n        System.out.println(\"Pairs: \" + countPairsOfNodes(edges, distance));\n\n        int[][] edges2 = {{1,2},{1,3},{2,3},{4,5}};\n        int distance2 = 2;\n        System.out.println(\"Pairs: \" + countPairsOfNodes(edges2, distance2));\n\n        int[][] edges3 = {};\n        int distance3 = 1;\n        System.out.println(\"Pairs: \" + countPairsOfNodes(edges3, distance3));\n    }\n\n    public static int countPairsOfNodes(int[][] edges, int distance) {\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int[] edge : edges) {\n            if (!graph.containsKey(edge[0])) {\n                graph.put(edge[0], new ArrayList<>());\n            }\n            if (!graph.containsKey(edge[1])) {\n                graph.put(edge[1], new ArrayList<>());\n            }\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n\n        int count = 0;\n        for (Map.Entry<Integer, List<Integer>> entry : graph.entrySet()) {\n            for (int node : entry.getValue()) {\n                if (graph.get(node).size() > 1) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n}\n```",
  "1783": "```\npublic class Solution {\n    public int numberWays(String[] helpTrainers) {\n        // your logic here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] test1 = {\"Shania\", \"Shayla\", \"Samantha\"};\n        System.out.println(\"Test 1: \" + solution.numberWays(test1));\n\n        String[] test2 = {\"Shaylee\", \"Shylah\", \"Sydni\", \"Sierra\"};\n        System.out.println(\"Test 2: \" + solution.numberWays(test2));\n\n        String[] test3 = {\"Savanna\", \"Skyla\", \"Sage\", \"Selina\", \"Siana\"};\n        System.out.println(\"Test 3: \" + solution.numberWays(test3));\n    }\n}",
  "1784": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(checkSegments(\"1000010\")); // Expected: true\n        System.out.println(checkSegments(\"1100\")); // Expected: false\n        System.out.println(checkSegments(\"00000\")); // Expected: true\n    }\n\n    public static boolean checkSegments(String s) {\n        int ones = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '1') {\n                ones++;\n                if (ones > 1) return false;\n            } else {\n                ones = 0;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1785": "```\npublic class Main {\n    public static void main(String[] args) {\n        int targetSum1 = 10;\n        System.out.println(\"Minimum elements to add for sum \" + targetSum1 + \": \" + minElements(new int[]{2, 4, 5}, targetSum1));\n        \n        int targetSum2 = 9;\n        System.out.println(\"Minimum elements to add for sum \" + targetSum2 + \": \" + minElements(new int[]{3, 5, 7, 11}, targetSum2));\n\n        int targetSum3 = 20;\n        System.out.println(\"Minimum elements to add for sum \" + targetSum3 + \": \" + minElements(new int[]{1, 4, 20}, targetSum3));\n    }\n\n    public static int minElements(int[] arr, int target) {\n        Arrays.sort(arr);\n        int count = 0;\n        int i = arr.length - 1;\n\n        while (target > 0) {\n            if (arr[i] <= target) {\n                target -= arr[i];\n                count++;\n            } else {\n                i--;\n            }\n        }\n\n        return count;\n    }\n}",
  "1786": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] edges = {{1,2},{1,3},{2,3}};\n        System.out.println(numberOfWays(edges, 1, 3));\n\n        int[][] edges2 = {{0,1},{2,3},{3,4},{4,5}};\n        System.out.println(numberOfWays(edges2, 0, 5));\n\n        int[][] edges3 = {{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,7},{7,8},{8,9}];\n        System.out.println(numberOfWays(edges3, 0, 9));\n    }\n\n    public static int numberOfWays(int[][] edges, int start, int end) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= edges.length; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n        }\n\n        int[][] distance = new int[graph.size()][graph.size()];\n        boolean[] visited = new boolean[graph.size()];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            visited[node] = true;\n\n            for (int neighbor : graph.get(node)) {\n                if (!visited[neighbor]) {\n                    distance[node][neighbor] = distance[node][node] + 1;\n                    queue.add(neighbor);\n                }\n            }\n        }\n\n        int ways = 0;\n        for (int i = 0; i < graph.size(); i++) {\n            for (int j = 0; j < graph.size(); j++) {\n                if (distance[i][j] > 1) {\n                    ways += distance[i][end];\n                }\n            }\n        }\n\n        return ways;\n    }\n}",
  "1787": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(new int[]{0,1}, new int[]{0,1})); // Test case 1: True\n        System.out.println(canBeEqual(new int[]{0,1,0}, new int[]{0,0,0})); // Test case 2: False\n        System.out.println(canBeEqual(new int[]{0}, new int[]{1})); // Test case 3: False\n    }\n\n    public static boolean canBeEqual(int[] arr1, int[] arr2) {\n        int xor = 0;\n        for (int i = 0; i < arr1.length; i++) {\n            xor ^= arr1[i] ^ arr2[i];\n        }\n        return xor == 0;\n    }\n}",
  "1788": "```\npublic class Solution {\n    public int maximumBeauty(int[] sensors, int[][] power) {\n        // Your code here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] sensors1 = {8, 18};\n        int[][] power1 = {{1, 2}, {5, 5}};\n        System.out.println(\"Test Case 1: \" + solution.maximumBeauty(sensors1, power1));\n\n        int[] sensors2 = {6, 11, 14};\n        int[][] power2 = {{3, 4}, {4, 7}, {8, 10}};\n        System.out.println(\"Test Case 2: \" + solution.maximumBeauty(sensors2, power2));\n\n        int[] sensors3 = {3, 5, 6, 12};\n        int[][] power3 = {{1, 2}, {4, 5}, {6, 7}};\n        System.out.println(\"Test Case 3: \" + solution.maximumBeauty(sensors3, power3));\n    }\n}",
  "1789": "```\npublic class Main {\n    public static void main(String[] args) {\n        Employee[] employees = new Employee[] {\n            new Employee(\"John\", \"A\"), \n            new Employee(\"Jane\", \"B\"), \n            new Employee(\"Alice\", \"A\")\n        };\n\n        for (Employee employee : employees) {\n            System.out.println(\"Primary Department: \" + getPrimaryDepartment(employee));\n        }\n    }\n\n    public static String getPrimaryDepartment(Employee employee) {\n        Map<String, Integer> departmentCount = new HashMap<>();\n        for (Employee e : employee.information()) {\n            departmentCount.put(e.department(), departmentCount.getOrDefault(e.department(), 0) + 1);\n        }\n        \n        return departmentCount.entrySet().stream()\n                .filter(entry -> entry.getValue() == departmentCount.values().stream().max(Comparator.naturalOrder()).get())\n                .findFirst().orElseThrow().getKey();\n    }\n}\n\nclass Employee {\n    private String name;\n    private String department;\n\n    public Employee(String name, String department) {\n        this.name = name;\n        this.department = department;\n    }\n\n    public List<Employee> information() {\n        return Arrays.asList(new Employee(name, department));\n    }\n\n    public String getDepartment() {\n        return department;\n    }\n}\n```",
  "1790": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"bank\", \"kanb\")); // true\n        System.out.println(canBeEqual(\"camera\", \"atamera\")); // false\n        System.out.println(canBeEqual(\"frontline\", \"linefront\")); // true\n    }\n\n    public static boolean canBeEqual(String word1, String word2) {\n        if (word1.length() != word2.length()) return false;\n\n        int[] count1 = new int[26];\n        int[] count2 = new int[26];\n\n        for (int i = 0; i < word1.length(); i++) {\n            count1[word1.charAt(i) - 'a']++;\n            count2[word2.charAt(i) - 'a']++;\n        }\n\n        for (int i = 0; i < 26; i++) {\n            if (count1[i] != count2[i]) return false;\n        }\n\n        int sameCount = 0;\n        for (int i = 0; i < word1.length(); i++) {\n            if (word1.charAt(i) == word2.charAt(i)) sameCount++;\n        }\n\n        return sameCount > 1;\n    }\n}",
  "1791": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] edges1 = {{0, 2}, {2, 4}, {2, 5}};\n        System.out.println(\"Center of Star Graph for edges1: \" + findCenter(edges1));\n        \n        int[][] edges2 = {{0, 1}, {0, 2}};\n        System.out.println(\"Center of Star Graph for edges2: \" + findCenter(edges2));\n        \n        int[][] edges3 = {{0, 1}, {0, 2}, {1, 3}};\n        System.out.println(\"Center of Star Graph for edges3: \" + findCenter(edges3));\n    }\n\n    public static int findCenter(int[][] edges) {\n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int[] edge : edges) {\n            map.put(edge[0], map.getOrDefault(edge[0], 0) + 1);\n            map.put(edge[1], map.getOrDefault(edge[1], 0) + 1);\n        }\n        \n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() == 3) return entry.getKey();\n        }\n        \n        return -1;\n    }\n}",
  "1793": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maximumGoodSubArray(new int[]{1,2,-1,5,-6,1,4,-7,-3,0}, 10));\n        System.out.println(maximumGoodSubArray(new int[]{-2,8,-3,0,-7,15,14,-19}, 10));\n        System.out.println(maximumGoodSubArray(new int[]{7,8,9,10,1,2,-5,5}, 6));\n    }\n\n    public static int maximumGoodSubArray(int[] nums, int target) {\n        int maxScore = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int sum = 0;\n            for (int j = i; j < nums.length; j++) {\n                sum += nums[j];\n                if (sum <= target && Math.max(0, sum) > maxScore) {\n                    maxScore = Math.max(0, sum);\n                }\n            }\n        }\n        return maxScore;\n    }\n}\n```",
  "1792": "```\nimport java.util.*;\n\nclass Solution {\n    public int maxAverageRatio(int[][] classes) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> (b[0] - (1.0 / (double)(classes.length))) - (a[0] - (1.0 / (double)(classes.length))));\n        for (int[] classInfo : classes) {\n            int student = classInfo[0], totalStudent = classInfo[1], passStudent = classInfo[2];\n            pq.offer(new int[]{student, totalStudent, passStudent});\n        }\n        double sum = 0;\n        while (!pq.isEmpty()) {\n            int[] temp = pq.poll();\n            sum += (temp[2] * 1.0) / temp[1];\n        }\n        return (int)(sum / classes.length);\n    }\n\npublic static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test Case 1\n    int[][] classes1 = {{100, 1, 25}, {75, 1, 25}};\n    System.out.println(\"Maximum Average Pass Ratio for test case 1: \" + solution.maxAverageRatio(classes1));\n\n    // Test Case 2\n    int[][] classes2 = {{5, 3, 4}, {10, 6, 9}};\n    System.out.println(\"Maximum Average Pass Ratio for test case 2: \" + solution.maxAverageRatio(classes2));\n\n    // Test Case 3\n    int[][] classes3 = {{1, 1000, 500},{2, 500, 250},{3, 200, 150},{4, 50, 30}};\n    System.out.println(\"Maximum Average Pass Ratio for test case 3: \" + solution.maxAverageRatio(classes3));\n}\n```",
  "1794": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countEqualSubstrings(\"aa\", 1));\n        System.out.println(countEqualSubstrings(\"abaccd\", 4));\n        System.out.println(countEqualSubstrings(\"aabbcc\", 2));\n    }\n\n    public static int countEqualSubstrings(String s, int minLen) {\n        // Your code here\n    }\n}",
  "1795": "```\npublic class Solution {\n    public String[] reorderLabels(String[] words) {\n        List<List<String>> list = new ArrayList<>();\n        for (String word : words) {\n            int n = word.length();\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < n; i++) {\n                sb.append(word.charAt(i));\n            }\n            String str = sb.toString();\n            List<String> temp = new ArrayList<>();\n            temp.add(str);\n            list.add(temp);\n        }\n        Collections.sort(list, (o1, o2) -> {\n            if (o1.get(0).compareTo(o2.get(0)) == 0) {\n                return Integer.compare(o1.size(), o2.size());\n            }\n            return o1.get(0).compareTo(o2.get(0));\n        });\n        String[] result = new String[words.length];\n        int i = 0;\n        for (List<String> l : list) {\n            result[i++] = l.get(0);\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words1 = {\"a1b1\", \"c2\", \"d3\"};\n        System.out.println(Arrays.toString(solution.reorderLabels(words1)));\n\n        String[] words2 = {\"kiqwx\", \"oypw\", \"tzzz\"};\n        System.out.println(Arrays.toString(solution.reorderLabels(words2)));\n\n        String[] words3 = {\"a1b2\", \"c4d7\", \"e6\", \"f0g9\"};\n        System.out.println(Arrays.toString(solution.reorderLabels(words3)));\n    }\n}",
  "1796": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(secondLargest(\"12345\")); // Output: 5\n        System.out.println(secondLargest(\"912\")); // Output: 9\n        System.out.println(secondLargest(\"9876543210\")); // Output: 8\n    }\n\n    public static char secondLargest(String s) {\n        int[] counts = new int[10];\n        for (char c : s.toCharArray()) {\n            if (c >= '0' && c <= '9') {\n                counts[c - '0']++;\n            }\n        }\n        int max = 0, secMax = 0;\n        for (int i = 1; i < 10; i++) {\n            if (counts[i] > max) {\n                secMax = max;\n                max = i;\n            } else if (counts[i] == max && counts[i] != secMax) {\n                secMax = i;\n            }\n        }\n        return (char) (secMax + '0');\n    }\n}",
  "1797": "```\npublic class Main {\n    public static void main(String[] args) {\n        AuthenticationManager manager = new AuthenticationManager();\n        \n        // Test Case 1\n        manager.login(\"user1\", \"pass1\");\n        System.out.println(manager.getAuthenticatedStatus(\"user1\")); // true\n        manager.logout(\"user1\");\n        System.out.println(manager.getAuthenticatedStatus(\"user1\")); // false\n        \n        // Test Case 2\n        manager.login(\"user2\", \"pass2\");\n        System.out.println(manager.getAuthenticatedStatus(\"user2\")); // true\n        System.out.println(manager.getAuthenticatedStatus(\"user3\")); // false\n        \n        // Test Case 3\n        manager.login(\"user1\", \"newPass1\");\n        System.out.println(manager.getAuthenticatedStatus(\"user1\")); // true\n    }\n}\n```",
  "1798": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxConsecutive(new int[]{2, 4, 6, 8, 10})); // Output: 5\n        System.out.println(maxConsecutive(new int[]{1, 3, 5, 7, 9, 11})); // Output: 6\n        System.out.println(maxConsecutive(new int[]{2, 4, 5, 7, 10, 15})); // Output: 3\n    }\n\n    public static int maxConsecutive(int[] nums) {\n        Arrays.sort(nums);\n        int maxCount = 0;\n        int count = 1;\n\n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] - nums[i - 1] == 1) {\n                count++;\n            } else {\n                maxCount = Math.max(maxCount, count);\n                count = 1;\n            }\n        }\n\n        return Math.max(maxCount, count);\n    }\n}\n```",
  "1799": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] tests = {\n                {{1, 2}, 3, 0}, // expected output: 5\n                {{3, 4, 6, 7}, 2, 1}, // expected output: 7\n                {{10, 20, 40, 100, 50}, 2, 1}, // expected output: 120\n        };\n\n        for (int i = 0; i < tests.length; i++) {\n            int[] nums = tests[i][0];\n            int n = tests[i][1];\n            int k = tests[i][2];\n\n            System.out.println(\"Test case \" + (i + 1) + \": \");\n            System.out.println(\"Input: nums = \" + Arrays.toString(nums) + \", n = \" + n + \", k = \" + k);\n            System.out.println(\"Output: \" + maximizeScore(nums, n, k));\n            System.out.println();\n        }\n    }\n\n    public static int maximizeScore(int[] nums, int n, int k) {\n        // Your code here\n    }\n}\n```",
  "1800": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxAscendingSum(new int[]{10,6,8,20,60,40}) + \" = expected 25\");\n        System.out.println(maxAscendingSum(new int[]{1,2,3,4,5}) + \" = expected 15\");\n        System.out.println(maxAscendingSum(new int[]{1,3,6,7,9,10,12,13,14,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30}) + \" = expected 15\");\n    }\n\n    public static int maxAscendingSum(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        \n        int maxSum = nums[0];\n        int currentSum = nums[0];\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[i - 1]) {\n                currentSum += nums[i];\n            } else {\n                maxSum = Math.max(maxSum, currentSum);\n                currentSum = nums[i];\n            }\n        }\n        \n        return Math.max(maxSum, currentSum);\n    }\n}\n```",
  "1801": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numOrders(new int[][]{{1,2},{5}})); // Test case 1\n        System.out.println(numOrders(new int[][]{{7,10},{12,15},{100,150}})); // Test case 2\n        System.out.println(numOrders(new int[][]{})); // Test case 3\n    }\n\n    public static int numOrders(int[][] orders) {\n        if (orders == null || orders.length == 0) return 0;\n        \n        Arrays.sort(orders, (a, b) -> a[1] - b[1]);\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        \n        for (int[] order : orders) {\n            while (!pq.isEmpty() && pq.peek() <= order[0]) {\n                pq.poll();\n            }\n            pq.offer(order[1]);\n        }\n        \n        int totalOrders = 0;\n        while (!pq.isEmpty()) {\n            totalOrders += pq.poll() - pq.peek();\n        }\n        \n        return totalOrders;\n    }\n}",
  "1802": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxValueAtGivenIndex(1, new int[]{0,1,2,3,4}, 3));\n        System.out.println(maxValueAtGivenIndex(5, new int[]{10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25}, 8));\n        System.out.println(maxValueAtGivenIndex(-1, new int[]{-1,-2,-3,-4,-5}, -4));\n    }\n\n    public static int maxValueAtGivenIndex(int k, int[] nums, int left, int right) {\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (mid == k) {\n                return Math.max(nums[mid], nums[(mid+1)%nums.length]);\n            } else if (mid < k) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return Math.max(nums[left-1], nums[right+1]);\n    }\n}\n```",
  "1803": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums = {2,1,0};\n        System.out.println(countPairs(new int[]{2,1,0}, 2));\n        \n        int[] nums1 = {0,1,1,3};\n        System.out.println(countPairs(nums1, 3));\n\n        int[] nums2 = {0};\n        System.out.println(countPairs(nums2, 2));\n    }\n\n    public static int countPairs(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        \n        int res = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            int left = entry.getKey();\n            if ((target - left) == left || (target - left) < 0) continue;\n            \n            int count = entry.getValue();\n            res += count * (count - 1) / 2;\n            \n            for (int i = entry.getKey() + 1; i <= target; i++) {\n                if (!map.containsKey(i)) break;\n                \n                res += map.get(i) * count;\n                break;\n            }\n        }\n        \n        return res;\n    }\n}",
  "1804": "```\npublic class Main {\n    public static void main(String[] args) {\n        Trie trie = new Trie();\n        trie.insert(\"apple\");\n        System.out.println(trie.search(\"app\")); // true\n        System.out.println(trie.search(\"applepie\")); // false\n        System.out.println(trie.startsWith(\"app\")); // true\n    }\n}\n\nclass TrieNode {\n    boolean isEndOfWord;\n    Map<Character, TrieNode> children;\n\n    public TrieNode() {\n        this.isEndOfWord = false;\n        this.children = new HashMap<>();\n    }\n}\n\nclass Trie {\n    private TrieNode root;\n\n    public Trie() {\n        this.root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode node = this.root;\n        for (char c : word.toCharArray()) {\n            if (!node.children.containsKey(c)) {\n                node.children.put(c, new TrieNode());\n            }\n            node = node.children.get(c);\n        }\n        node.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode node = this.root;\n        for (char c : word.toCharArray()) {\n            if (!node.children.containsKey(c)) {\n                return false;\n            }\n            node = node.children.get(c);\n        }\n        return node.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        TrieNode node = this.root;\n        for (char c : prefix.toCharArray()) {\n            if (!node.children.containsKey(c)) {\n                return false;\n            }\n            node = node.children.get(c);\n        }\n        return true;\n    }\n}\n```",
  "1805": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countDifferentIntegers(\"a1c1e1\"));\n        System.out.println(countDifferentIntegers(\"12345\"));\n        System.out.println(countDifferentIntegers(\"0123456789\"));\n    }\n\n    public static int countDifferentIntegers(String s) {\n        int res = 0;\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                sb.append(c);\n            } else {\n                if (sb.length() > 0) {\n                    res++;\n                    sb.setLength(0);\n                }\n            }\n        }\n        if (sb.length() > 0) {\n            res++;\n        }\n        return res;\n    }\n}",
  "1806": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minOperations(new int[]{2,4,6}, 1)); // Output: 7\n        System.out.println(minOperations(new int[]{10,2}, 7)); // Output: 1\n        System.out.println(minOperations(new int[]{5,3,2}, 2)); // Output: 8\n    }\n\n    public static int minOperations(int[] nums, int x) {\n        int n = nums.length;\n        int res = n;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] % x == 0) {\n                int j = i + 1;\n                while (j < n && nums[j] % x != 0) {\n                    j++;\n                }\n                res = Math.min(res, n - j);\n            }\n        }\n        return res;\n    }\n}",
  "1807": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(evaluate(\"()\")); // Expected output: true\n        System.out.println(evaluate(\"()[]{}\")); // Expected output: true\n        System.out.println(evaluate(\"(]\")); // Expected output: false\n    }\n\n    public static boolean evaluate(String s) {\n        int open = 0;\n        int close = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                open++;\n            } else if (s.charAt(i) == ')') {\n                close++;\n            }\n        }\n\n        return open == close;\n    }\n}\n```",
  "1808": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxNiceDivisors(25)); // Test case 1: Expected output 13\n        System.out.println(maxNiceDivisors(17)); // Test case 2: Expected output 4\n        System.out.println(maxNiceDivisors(281)) ; // Test case 3: Expected output 14\n    }\n\n    public static int maxNiceDivisors(int n) {\n        // Code for the problem goes here\n    }\n}",
  "1809": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = {{5001, 919}, {10000, 10899}};\n        System.out.println(adFreeSessions(logs));\n        \n        logs = new int[][]{{2017, 2000}, {2018, 2075}, {2019, 2044}, {2020, 2033}, {2022, 2020}};\n        System.out.println(adFreeSessions(logs));\n\n        logs = {{1, 10000}};\n        System.out.println(adFreeSessions(logs));\n    }\n\n    public static int adFreeSessions(int[][] logs) {\n        int maxSession = 0;\n        for (int[] log : logs) {\n            int start = log[0];\n            int end = log[1];\n            int currentSession = (end - start + 1);\n            if (currentSession > maxSession) {\n                maxSession = currentSession;\n            }\n        }\n        return maxSession;\n    }\n}",
  "1810": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] hiddenGrid = {{0,0,1},{0,1,0},{0,2,1},{1,0,0},{1,1,0},{1,2,1}};\n        System.out.println(minPathCost(hiddenGrid));\n        \n        int[][] hiddenGrid2 = {{0,0,0},{0,0,1},{0,1,1}};\n        System.out.println(minPathCost(hiddenGrid2));\n\n        int[][] hiddenGrid3 = {{0,0,0},{0,1,1},{1,1,0}};\n        System.out.println(minPathCost(hiddenGrid3));\n    }\n\n    public static int minPathCost(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    pq.offer(new int[]{i, j, Integer.MAX_VALUE});\n                }\n            }\n        }\n\n        while (!pq.isEmpty()) {\n            int[] cur = pq.poll();\n            int x = cur[0];\n            int y = cur[1];\n            int cost = cur[2];\n\n            if (visited[x][y]) continue;\n            visited[x][y] = true;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny]) {\n                    pq.offer(new int[]{nx, ny, cost + grid[nx][ny]});\n                }\n            }\n        }\n\n        return Integer.MAX_VALUE;\n    }\n}",
  "1811": "```\npublic class Solution {\n    public List<String> findInterviewCandidates(int minAge, int maxAge, String gender, String department) {\n        // Your logic goes here\n        List<String> candidates = new ArrayList<>();\n        for (String candidate : candidatesList) { // assuming you have a list of candidates\n            if (candidateAge(candidate) >= minAge && candidateAge(candidate) <= maxAge \n                    && (gender.equals(\"male\") ? candidateGender(candidate).equals(\"Male\") : candidateGender(candidate).equals(gender)) \n                    && department.equals(getDepartment(candidate))) {\n                candidates.add(candidate);\n            }\n        }\n        return candidates;\n    }\n\n    private int candidateAge(String candidate) {\n        // your logic to get age\n    }\n\n    private String candidateGender(String candidate) {\n        // your logic to get gender\n    }\n\n    private String getDepartment(String candidate) {\n        // your logic to get department\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> result1 = solution.findInterviewCandidates(25, 30, \"male\", \"engineering\");\n        System.out.println(result1);\n\n        List<String> result2 = solution.findInterviewCandidates(22, 28, \"female\", \"marketing\");\n        System.out.println(result2);\n\n        List<String> result3 = solution.findInterviewCandidates(20, 24, \"male\", \"human resources\");\n        System.out.println(result3);\n    }\n}",
  "1812": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(squareIsWhite(\"a1\")); // Expected: true\n        System.out.println(squareIsWhite(\"c5\")); // Expected: false\n        System.out.println(squareIsWhite(\"h8\")); // Expected: true\n    }\n\n    public static boolean squareIsWhite(String s) {\n        char row = s.charAt(0);\n        int col = Integer.parseInt(s.substring(1));\n        \n        return (row - 'a') % 2 == 0;\n    }\n}",
  "1814": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countNicePairs(new int[]{2,4,6})); // Output: 5\n        System.out.println(countNicePairs(new int[]{4,4})); // Output: 3\n        System.out.println(countNicePairs(new int[]{10,2,8,7,9})); // Output: 16\n    }\n\n    public static int countNicePairs(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            int niceNum = num - Integer.parseInt(String.valueOf(num).reverse());\n            map.put(niceNum, map.getOrDefault(niceNum, 0) + 1);\n        }\n        int res = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getValue() > 1) {\n                res += entry.getValue() * (entry.getValue() - 1) / 2;\n            }\n        }\n        return res;\n    }\n}\n```",
  "1813": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sentenceSimilarity(new String[]{\"a\", \"b\"}, new String[]{\"a\", \"b\"}) == 1.0 ? \"true\" : \"false\");\n        System.out.println(sentenceSimilarity(new String[]{\"word1\", \"word2\", \"word3\"}, new String[]{\"word1\", \"word2\"}) == 1.0 ? \"true\" : \"false\");\n        System.out.println(sentenceSimilarity(new String[]{\"short\"}, new String[]{\"it\", \"is\"}), 0.5);\n    }\n\n    public static double sentenceSimilarity(String[] words1, String[] words2) {\n        Map<String, Integer> wordCount1 = new HashMap<>();\n        Map<String, Integer> wordCount2 = new HashMap<>();\n\n        for (String word : words1) {\n            wordCount1.put(word, wordCount1.getOrDefault(word, 0) + 1);\n        }\n\n        for (String word : words2) {\n            wordCount2.put(word, wordCount2.getOrDefault(word, 0) + 1);\n        }\n\n        double intersection = 0;\n        int union = 0;\n\n        for (Map.Entry<String, Integer> entry : wordCount1.entrySet()) {\n            if (wordCount2.containsKey(entry.getKey())) {\n                int count = Math.min(entry.getValue(), wordCount2.get(entry.getKey()));\n                intersection += count;\n            }\n            union += entry.getValue();\n        }\n\n        for (Map.Entry<String, Integer> entry : wordCount2.entrySet()) {\n            if (!wordCount1.containsKey(entry.getKey())) {\n                union += entry.getValue();\n            }\n        }\n\n        return intersection / (double) union;\n    }\n}\n```",
  "1816": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(truncateSentence(\"Hello how are you\", 7));\n        System.out.println(truncateSentence(\"Hey what's up buddy\", 5));\n        System.out.println(truncateSentence(\"I'm a little tea pot\", 3));\n    }\n\n    public static String truncateSentence(String s, int k) {\n        return s.substring(0, Math.min(k, s.length())) + (k <= s.length() ? \" \" : \"\");\n    }\n}",
  "1815": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] donuts = {{1, 2}, {1, 4}, {0, 1}};\n        System.out.println(maxFreshDonuts(donuts)); // Output: 3\n        int[][] donuts2 = {{10, 11}, {12, 13}, {14, 15}};\n        System.out.println(maxFreshDonuts(new int[][]{donuts2})); // Output: 1\n        int[][] donuts3 = {{0, 4}};\n        System.out.println(maxFreshDonuts(new int[][]{donuts3})); // Output: 1\n    }\n\n    public static int maxFreshDonuts(int[][] donuts) {\n        // Your code here...\n    }\n}\n```",
  "1818": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {{1, 4, 10, 4, 20}, 15},\n            {{-3, -5, 2, 0}, 9},\n            {{1, 3, 4, 6, 7}, 11}\n        };\n        \n        for (int[] array : arrays) {\n            System.out.println(\"Array: \" + Arrays.toString(array) + \", Minimum Absolute Sum Difference is: \" + minAbsoluteSumDifference(array));\n        }\n    }\n\n    public static int minAbsoluteSumDifference(int[] nums1, int[] nums2) {\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n\n        int i = 0, j = 0;\n        int sumDiff = 0;\n\n        while (i < nums1.length && j < nums2.length) {\n            sumDiff += Math.abs(nums1[i] - nums2[j]);\n            if (nums1[i] <= nums2[j]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        for (; i < nums1.length; i++) {\n            sumDiff += nums1[i];\n        }\n\n        for (; j < nums2.length; j++) {\n            sumDiff += nums2[j];\n        }\n\n        return sumDiff;\n    }\n}",
  "1817": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] logs = {{\"David\", 1666}, {\"David\", 1667}, {\"Alice\", 1200}, {\"Bob\", 2114}, {\"Alice\", 2145}};\n        System.out.println(numActiveMinutes(10, logs));\n        \n        logs = new int[][]{{\"Peter\", 1312}, {\"Adam\", 1343}, {\"Jane\", 1356}, {\"Paul\", 1328}, {\"Paul\", 1349}, {\"Jane\", 1360}, {\"Jane\", 1361}};\n        System.out.println(numActiveMinutes(5, logs));\n        \n        logs = new int[][]{{\"Karl\", 1534}, {\"Karl\", 1545}};\n        System.out.println(numActiveMinutes(3, logs));\n    }\n\n    public static int numActiveMinutes(int totalMinutes, int[][] logs) {\n        Map<String, List<Integer>> userLogs = new HashMap<>();\n        for (int[] log : logs) {\n            String user = log[0];\n            int minute = log[1];\n            if (!userLogs.containsKey(user)) {\n                userLogs.put(user, new ArrayList<>());\n            }\n            userLogs.get(user).add(minute);\n        }\n\n        int activeMinutes = 0;\n        for (List<Integer> minutes : userLogs.values()) {\n            Collections.sort(minutes);\n            int lastActiveMinute = -1;\n            for (int minute : minutes) {\n                if (minute > lastActiveMinute + 1) {\n                    activeMinutes++;\n                    lastActiveMinute = minute;\n                }\n            }\n        }\n\n        return Math.min(totalMinutes, activeMinutes);\n    }\n}\n```",
  "1819": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numFactoredBST(2).equals(\"[1]\") ? numDifferentSubsequenceGCDs(new int[]{2,4,6}, new int[][]{{2,3},{2,3},{2,3}}): 0);\n        System.out.println(numFactoredBST(22).equals(\"[2,11,14][13,14,22][2,11,12,20][1,10,12,21][1,5,7,15,25][2,3,4,8,9,11,17,19][1,2,4,6,7,8,9,10,12,13,14,16,18,20,21,22,23,24,25]\"));\n        System.out.println(numFactoredBST(4).equals(\"[2][1,3][4,2,2][1,2,3,4][1,1,2,2,3,3,4,4][2,2,2,2][1,1,1,1]\"));\n    }\n\n    public static int numDifferentSubsequenceGCDs(int[] nums, int[][] queries) {\n        // Your code here\n    }\n}",
  "1820": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] watchType = {{1,2},{5},{0,4}};\n        System.out.println(\"Expected: 3, Actual: \" + maxInvitations(watchType));\n        \n        int[][] watchType2 = {{1,2,3},{5},{0,4,7}};\n        System.out.println(\"Expected: 4, Actual: \" + maxInvitations(watchType2));\n        \n        int[][] watchType3 = {{2,1},{2},{0,2}};\n        System.out.println(\"Expected: 2, Actual: \" + maxInvitations(watchType3));\n    }\n\n    public static int maxInvitations(int[][] watchType) {\n        if (watchType == null || watchType.length <= 0) return 0;\n        \n        int n = watchType[0].length;\n        boolean[][] accept = new boolean[n][n];\n        for (int[] type : watchType) {\n            for (int i = 0; i < type.length - 1; i++) {\n                for (int j = i + 1; j < type.length; j++) {\n                    accept[type[i] - 1][type[j] - 1] = true;\n                    accept[type[j] - 1][type[i] - 1] = true;\n                }\n            }\n        }\n        \n        int max = 0, current = 0;\n        for (int i = 0; i < n; i++) {\n            boolean accepted = false;\n            for (int j = 0; j < n; j++) {\n                if (accept[i][j]) {\n                    accepted = true;\n                    break;\n                }\n            }\n            if (accepted) current++;\n            else current = 0;\n            max = Math.max(max, current);\n        }\n        \n        return max;\n    }\n}",
  "1822": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(signOfArrayProduct(new int[]{1, -2, 3, 0, 4}) + \" == 1\");\n        System.out.println(signOfArrayProduct(new int[]{-1, -2, 3, 0, 7}) + \" == -1\");\n        System.out.println(signOfArrayProduct(new int[]{0, -2, 3, 0, 1}) + \" == 0\");\n    }\n\n    public static int signOfArrayProduct(int[] nums) {\n        int result = 1;\n        for (int num : nums) {\n            if (num != 0) {\n                result *= Math.signum(num);\n            }\n        }\n        return result;\n    }\n}",
  "1821": "```\nimport java.sql.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        try (\n                Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n                Statement stmt = conn.createStatement();\n                ResultSet rs = stmt.executeQuery(\"SELECT * FROM customers\")\n        ) {\n            while (rs.next()) {\n                String customerName = rs.getString(\"name\");\n                double revenue = getRevenue(conn, customerName);\n                if (revenue > 0) {\n                    System.out.println(customerName + \" has positive revenue this year: \" + revenue);\n                }\n            }\n        }\n    }\n\n    public static double getRevenue(Connection conn, String customerName) throws SQLException {\n        try (\n                Statement stmt = conn.createStatement();\n                ResultSet rs = stmt.executeQuery(\"SELECT SUM(revenue) FROM sales WHERE customer_name='\" + customerName + \"'\")\n        ) {\n            if (rs.next()) {\n                return rs.getDouble(1);\n            } else {\n                return 0;\n            }\n        }\n    }\n\n    public static void testMain() throws Exception {\n        try (\n                Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/mydb\", \"root\", \"password\");\n                Statement stmt = conn.createStatement();\n                ResultSet rs = stmt.executeQuery(\"SELECT * FROM customers\")\n        ) {\n            while (rs.next()) {\n                String customerName = rs.getString(\"name\");\n                double revenue = getRevenue(conn, customerName);\n                if (revenue > 0) {\n                    System.out.println(customerName + \" has positive revenue this year: \" + revenue);\n                }\n            }\n        }\n\n        // Test case 1\n        try (\n                Statement stmt = conn.createStatement();\n                ResultSet rs = stmt.executeQuery(\"SELECT * FROM customers WHERE name='John'\")\n        ) {\n            while (rs.next()) {\n                String customerName = rs.getString(\"name\");\n                double revenue = getRevenue(conn, customerName);\n                if (revenue > 0) {\n                    System.out.println(customerName + \" has positive revenue this year: \" + revenue);\n                }\n            }\n        }\n\n        // Test case 2\n        try (\n                Statement stmt = conn.createStatement();\n                ResultSet rs = stmt.executeQuery(\"SELECT * FROM customers WHERE name='Jane'\")\n        ) {\n            while (rs.next()) {\n                String customerName = rs.getString(\"name\");\n                double revenue = getRevenue(conn, customerName);\n                if (revenue > 0) {\n                    System.out.println(customerName + \" has positive revenue this year: \" + revenue);\n                }\n            }\n        }\n\n        // Test case 3\n        try (\n                Statement stmt = conn.createStatement();\n                ResultSet rs = stmt.executeQuery(\"SELECT * FROM customers WHERE name='Alice'\")\n        ) {\n            while (rs.next()) {\n                String customerName = rs.getString(\"name\");\n                double revenue = getRevenue(conn, customerName);\n                if (revenue > 0) {\n                    System.out.println(customerName + \" has positive revenue this year: \" + revenue);\n                }\n            }\n        }\n    }\n\n    public static void main2(String[] args) throws Exception {\n        testMain();\n    }\n}",
  "1823": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2, 1, 3};\n        System.out.println(circularArrayLoop(nums1) ? \"Player 1\" : \"Player 2\");\n\n        int[] nums2 = {3, 16, 4};\n        System.out.println(circularArrayLoop(nums2) ? \"Player 1\" : \"Player 2\");\n\n        int[] nums3 = {2, 9};\n        System.out.println(circularArrayLoop(nums3) ? \"Player 1\" : \"Player 2\");\n    }\n\n    public static boolean circularArrayLoop(int[] nums) {\n        if (nums.length < 1) return false;\n        for (int i = 0; i < nums.length; i++) {\n            int start = i, end = i;\n            while (true) {\n                end = (start + nums[start] % nums.length);\n                if (end == start) break;\n                if (nums[end] * nums[start] < 0) break;\n                start = end;\n            }\n            if (start != end) continue;\n            int j = start, k = start;\n            while (true) {\n                j = (j + nums[j] % nums.length);\n                k = (k + nums[k] % nums.length);\n                if (j == k) break;\n                if (nums[j] * nums[k] < 0) return false;\n            }\n            return true;\n        }\n        return false;\n    }\n}",
  "1824": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSideJump(new int[]{10, 15, 20}, 1));\n        System.out.println(minSideJump(new int[]{7, 2, 5, 3, 9}, 2));\n        System.out.println(minSideJump(new int[]{4, 2, 0, 3, 2, 8}, 3));\n    }\n\n    public static int minSideJump(int[] obstacles, int k) {\n        int n = obstacles.length;\n        int[] dp = new int[n];\n        dp[0] = obstacles[0];\n        for (int i = 1; i < n; i++) {\n            dp[i] = Math.min(dp[i-1], obstacles[i]);\n        }\n        int res = 0;\n        for (int i = k; i < n; i += k) {\n            res += Math.max(0, dp[i] - obstacles[i-k+1]);\n        }\n        return res;\n    }\n}\n```",
  "1825": "```\nimport java.util.PriorityQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        FindingMKAverage mkAverage = new FindingMKAverage();\n        System.out.println(mkAverage.findMedian(new int[][]{{1,3}}, 2));\n        System.out.println(mkAverage.findMedian(new int[][]{{-200, -4}, {-110, -4}, {-6, 13}, {-5, 5}, {3, 3}, {16, -28}, {0, 60}, {9, 2}, {4, 15}, {-92, 10}}, 7));\n        System.out.println(mkAverage.findMedian(new int[][]{{1,6},{-3,5}} , 3));\n    }\n}\n```",
  "1826": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] input1 = {{0, 2}, {4, 6}, {7, 8}};\n        System.out.println(\"Expected: 2\\nGot: \" + faultySensor(input1));\n        \n        int[][] input2 = {{5, 7}, {7, 9}};\n        System.out.println(\"Expected: -1\\nGot: \" + faultySensor(input2));\n        \n        int[][] input3 = {{4, 6}, {5, 7}, {6, 8}};\n        System.out.println(\"Expected: 0\\nGot: \" + faultySensor(input3));\n    }\n\n    public static int faultySensor(int[][] sensors) {\n        Arrays.sort(sensors[0]);\n        for (int i = 1; i < sensors.length; i++) {\n            if (!Arrays.equals(Arrays.copyOf(sensors[i - 1], sensors[i - 1].length), Arrays.copyOf(sensors[i], sensors[i].length))) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n```",
  "1827": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{1, 5, 2, 4, 3}};\n        System.out.println(\"Test Case 1: \" + minOperations(arr1));\n        \n        int[][] arr2 = {{0, 3, 7, 7, 15 }};\n        System.out.println(\"Test Case 2: \" + minOperations(arr2));\n        \n        int[][] arr3 = {{10}};\n        System.out.println(\"Test Case 3: \" + minOperations(arr3));\n    }\n    \n    public static int minOperations(int[][] nums) {\n        int res = 0;\n        for (int i = 1; i < nums[0].length; i++) {\n            if (nums[0][i] <= nums[0][i - 1]) {\n                res += nums[0][i] - nums[0][i - 1] + 1;\n            }\n        }\n        return res;\n    }\n}",
  "1828": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] points = {{1,1},{2,2},{3,3}};\n        int[][] queries = {{0.5,0.5},{1.4,1.4},{2.9,3.8}};\n        System.out.println(numPoints(points,queries));\n        \n        int[][] points1 = {{1,1},{2,2},{3,3},{4,4}};\n        int[][] queries1 = {{0.6,0.7},{1.5,1.5},{2.9,3.8},{4.1,4.2}};\n        System.out.println(numPoints(points1,queries1));\n        \n        int[][] points2 = {{1,1},{2,2}};\n        int[][] queries2 = {{0.5,0.5},{1.4,1.4}};\n        System.out.println(numPoints(points2,queries2));\n    }\n\n    public static int numPoints(int[][] points, int[][] queries) {\n        int count=0;\n        for(int i=0;i<points.length;i++){\n            double distance = Math.sqrt(Math.pow(queries[0][0]-points[i][0], 2)+Math.pow(queries[0][1]-points[i][1], 2));\n            if(distance<=1.0){\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "1829": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] queries = {{1,4},{7,14},{2,3},{4,5}};\n        int[] updates = {1,6};\n        System.out.println(maximumXOR(queries, updates));\n    }\n\n    public static int maximumXOR(int[][] queries, int[] updates) {\n        TrieNode root = new TrieNode();\n        for (int update : updates) {\n            insert(root, update);\n        }\n        int maxResult = 0;\n        for (int i = 0; i < queries.length; i++) {\n            TrieNode node = root;\n            int result = 0;\n            for (int j = i >= 0 ? queries[i][0] : 31; j <= queries[i][1]; j++) {\n                if ((j & 1) == 1 && i > 0) continue;\n                char c = (char) ('0' + (j >> (i++)));\n                if (!node.children.containsKey(c)) {\n                    node.children.put(c, new TrieNode());\n                }\n                node = node.children.get(c);\n                result |= j;\n            }\n            maxResult = Math.max(maxResult, result);\n        }\n        return maxResult;\n    }\n\n    static class TrieNode {\n        Map<Character, TrieNode> children = new HashMap<>();\n    }\n\n    private static void insert(TrieNode root, int update) {\n        TrieNode node = root;\n        for (int i = 0; i < 32; i++) {\n            char c = (char) ('0' + ((update >> i) & 1));\n            if (!node.children.containsKey(c)) {\n                node.children.put(c, new TrieNode());\n            }\n            node = node.children.get(c);\n        }\n    }\n}",
  "1830": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minOperations(\"aaa\")); // expected output: 2\n        System.out.println(minOperations(\"aaabbb\")); // expected output: 4\n        System.out.println(minOperations(\"smdgxfvmsmwwzcxhffqgysjw\")); // expected output: 28\n    }\n\n    public static int minOperations(String s) {\n        if (s == null || s.length() < 1) {\n            return 0;\n        }\n        char[] arr = s.toCharArray();\n        int operations = 0;\n        for (int i = 0; i < arr.length; i++) {\n            if (i > 0 && arr[i] <= arr[i - 1]) {\n                int j = i;\n                while (j > 0 && arr[j] <= arr[j - 1]) {\n                    j--;\n                }\n                operations += i - j;\n                System.arraycopy(arr, j + 1, arr, j, i - j);\n            }\n        }\n        return operations;\n    }\n}",
  "1831": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] accounts = {\n            {10, 20}, \n            {50, 60}, \n            {70, 80}\n        };\n        \n        System.out.println(Arrays.deepToString(maximumTransaction(accounts)));\n    }\n\n    public static int[][] maximumTransaction(int[][] accounts) {\n        if (accounts.length == 0) return new int[0][];\n        Arrays.sort(accounts, (a, b) -> a[1] - b[1]);\n        \n        List<int[]> result = new ArrayList<>();\n        int start = accounts[0][0], end = accounts[0][1];\n        for (int i = 1; i < accounts.length; i++) {\n            if (accounts[i][0] <= end) {\n                end = Math.max(end, accounts[i][1]);\n            } else {\n                result.add(new int[]{start, end});\n                start = accounts[i][0]; \n                end = accounts[i][1];\n            }\n        }\n        result.add(new int[]{start, end});\n        \n        return result.toArray(new int[0][]);\n    }\n}\n```",
  "1832": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(checkIfPangram(\"The quick brown fox jumps over the lazy dog\")); // true\n        System.out.println(checkIfPangram(\"Hello world\")); // false\n        System.out.println(checkIfPangram(\"Bt eu wyntre o tewdwr\")); // true\n    }\n\n    public static boolean checkIfPangram(String sentence) {\n        String alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n        int[] charCount = new int[26];\n\n        for (char c : sentence.toLowerCase().toCharArray()) {\n            if (c >= 'a' && c <= 'z') {\n                charCount[c - 'a']++;\n            }\n        }\n\n        for (int count : charCount) {\n            if (count < 1) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```",
  "1833": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] flavors = {{1,2},{3,5},{4,6}};\n        System.out.println(maxIceCream(flavors));\n        \n        int[][] flavors2 = {{1, 3}, {2, 8}, {4, 10}, {9, 12}};\n        System.out.println(maxIceCream(flavors2));\n\n        int[][] flavors3 = {{10, 20}};\n        System.out.println(maxIceCream(flavors3));\n    }\n\n    public static int maxIceCream(int[][] costs) {\n        Arrays.sort(costs, (a, b) -> a[1] - b[1]);\n        \n        int totalCost = 0;\n        for (int i = 0; i < costs.length; i++) {\n            totalCost += costs[i][1];\n        }\n        \n        return totalCost / costs.length;\n    }\n}",
  "1834": "```\npublic class Solution {\n    public int[] orderProcesses(int n, int[] arr) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int i : arr) {\n            pq.add(i);\n        }\n        \n        int[] result = new int[n];\n        for (int i = 0; i < n; i++) {\n            result[i] = pq.poll();\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test case 1\n        int[] arr1 = {1, 2, 3};\n        int[] result1 = solution.orderProcesses(3, arr1);\n        System.out.println(Arrays.toString(result1));\n\n        // Test case 2\n        int[] arr2 = {7, 5, 6, 4, 3};\n        int[] result2 = solution.orderProcesses(5, arr2);\n        System.out.println(Arrays.toString(result2));\n\n        // Test case 3\n        int[] arr3 = {1, 2, 2, 2, 1, 1, 1};\n        int[] result3 = solution.orderProcesses(7, arr3);\n        System.out.println(Arrays.toString(result3));\n    }\n}\n```",
  "1835": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findXORSum(new int[]{1, 4}, new int[]{7, 8}) == 14);\n        System.out.println(findXORSum(new int[]{0}, new int[]{0}) == 0);\n        System.out.println(findXORSum(new int[]{2, 5, 3, 4}, new int[]{7, 1, 6, 3}) == 16);\n    }\n\n    public static int findXORSum(int[] arr1, int[] arr2) {\n        int res = 0;\n        for (int num : arr1) {\n            for (int num2 : arr2) {\n                res ^= num ^ num2;\n            }\n        }\n        return res;\n    }\n}\n```",
  "1837": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfDigits(34, 16)); // expected output: 9\n        System.out.println(sumOfDigits(10, 2)); // expected output: 1\n        System.out.println(sumOfDigits(27, 3)); // expected output: 6\n    }\n\n    public static int sumOfDigits(int n, int k) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % k;\n            n /= k;\n        }\n        return sum;\n    }\n}\n```",
  "1836": "```\npublic class Solution {\n    public ListNode removeDuplicates(ListNode head) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode cur = dummy;\n        while (cur.next != null && cur.next.next != null) {\n            if (cur.next.val == cur.next.next.val) {\n                ListNode temp = cur.next;\n                while (temp.next != null && temp.next.val == temp.val) temp = temp.next;\n                cur.next = temp.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        ListNode head1 = new ListNode(1);\n        head1.next = new ListNode(2);\n        head1.next.next = new ListNode(3);\n        System.out.println(\"Test case 1: \" + solution.removeDuplicates(head1));\n        \n        ListNode head2 = new ListNode(1);\n        head2.next = new ListNode(1);\n        head2.next.next = new ListNode(2);\n        System.out.println(\"Test case 2: \" + solution.removeDuplicates(head2));\n\n        ListNode head3 = new ListNode(1);\n        head3.next = new ListNode(1);\n        head3.next.next = new ListNode(1);\n        head3.next.next.next = new ListNode(2);\n        System.out.println(\"Test case 3: \" + solution.removeDuplicates(head3));\n    }\n}\n```",
  "1838": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {2, 2, 1};\n        System.out.println(\"Most frequent element in \" + Arrays.toString(nums1) + \": \" + mostFrequentElement(nums1));\n        \n        int[] nums2 = {0, 1};\n        System.out.println(\"Most frequent element in \" + Arrays.toString(nums2) + \": \" + mostFrequentElement(nums2));\n        \n        int[] nums3 = {5, 3, 2, 8, 7, 2, 3, 1};\n        System.out.println(\"Most frequent element in \" + Arrays.toString(nums3) + \": \" + mostFrequentElement(nums3));\n    }\n\n    public static int mostFrequentElement(int[] nums) {\n        if (nums.length == 0) return -1;\n        Map<Integer, Integer> countMap = new HashMap<>();\n        for (int num : nums) {\n            countMap.put(num, countMap.getOrDefault(num, 0) + 1);\n        }\n        int maxCount = 0;\n        int mostFrequentElement = 0;\n        for (Map.Entry<Integer, Integer> entry : countMap.entrySet()) {\n            if (entry.getValue() > maxCount) {\n                maxCount = entry.getValue();\n                mostFrequentElement = entry.getKey();\n            }\n        }\n        return mostFrequentElement;\n    }\n}\n```",
  "1839": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(longestVowelSubstring(\"aeoio\")); // expected output: \"aeoio\"\n        System.out.println(longestVowelSubstring(\"aeeiiooouuu\")); // expected output: \"aeeiiooouuu\"\n        System.out.println(longestVowelSubstring(\"bPQcDeFgHiJkLmNoP\")); // expected output: \"\"\n    }\n\n    public static String longestVowelSubstring(String s) {\n        int start = 0;\n        int maxLen = 0;\n        int end = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (\"aeiou\".indexOf(s.charAt(i)) != -1) {\n                end = i;\n            } else if (end != start) {\n                start = end + 1;\n                end = i;\n            }\n        }\n        return s.substring(start, end + 1);\n    }\n}",
  "1840": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] cost = {{14, 0}, {6, 2}, {10, 1}, {7, 0}};\n        System.out.println(maximumBuildingHeight(cost)); // Output: 5\n\n        int[][] cost1 = {{5,3},{5,4},{2,7},{3,8}};\n        System.out.println(maximumBuildingHeight(cost1)); // Output: 9\n\n        int[][] cost2 = {{1,10}, {2,6}, {3,5}};\n        System.out.println(maximumBuildingHeight(cost2)); // Output: 3\n    }\n\n    public static int maximumBuildingHeight(int[][] cost) {\n        int[] dp = new int[cost[0].length];\n        for (int i = 0; i < cost.length; i++) {\n            for (int j = 0; j < cost[i].length; j++) {\n                if (j == 0) {\n                    dp[j] = cost[i][j];\n                } else {\n                    dp[j] = Math.max(dp[j-1], cost[i][j]);\n                }\n            }\n        }\n        int maxHeight = 0;\n        for (int i : dp) {\n            maxHeight = Math.max(maxHeight, i);\n        }\n        return maxHeight;\n    }\n}\n```",
  "1841": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] accounts = {\n            {1, 2, 10, 100},\n            {5},\n            {0, 1, 10, 600}\n        };\n        \n        for (int i = 0; i < accounts.length; i++) {\n            calculateStatistics(accounts[i]);\n        }\n    }\n\n    public static void calculateStatistics(int[] account) {\n        // Your code to solve the problem\n    }\n}\n```",
  "1842": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(nextPalindrome(\"1221\")); // Expected: \"2211\"\n        System.out.println(nextPalindrome(\"a123b\")); // Expected: \"ba322ab\"\n        System.out.println(nextPalindrome(\"11112\")); // Expected: \"21113\"\n    }\n\n    public static String nextPalindrome(String s) {\n        char[] ch = s.toCharArray();\n        int left = 0, right = ch.length - 1;\n        \n        while (left < right && ch[left] == ch[right]) {\n            left++;\n            right--;\n        }\n        \n        if (left >= right) return s + \"a\";\n        \n        for (int i = left; i <= right; i++) {\n            if (ch[i] < (char)(ch[i] + 1)) {\n                for (int j = right; j > i; j--) {\n                    ch[j] = (char)(ch[j - 1] + 1);\n                    ch[j - 1] = ch[0];\n                }\n                return String.valueOf(ch);\n            } else {\n                ch[i] = (char)(ch[i] - 1);\n            }\n        }\n        \n        return s;\n    }\n}",
  "1843": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] accounts = {{1, 2, 10}, {3, 4, 20}};\n        System.out.println(minmalTransfers(accounts));\n\n        int[][] accounts2 = {{1, 2, 5},{3, 4, 2}};\n        System.out.println(minmalTransfers(accounts2));\n\n        int[][] accounts3 = {{0, 1, 100000}};\n        System.out.println(minmalTransfers(accounts3));\n    }\n\n    public static int minmalTransfers(int[][] accounts) {\n        Arrays.sort(accounts, (a, b) -> Double.compare((double)b[2] / (b[1] - a[1]), (double)a[2] / (a[1] - a[0])));\n        int res = 0;\n        for (int i = 0; i < accounts.length; i++) {\n            if (i > 0 && accounts[i][0] != accounts[i-1][1]) {\n                res++;\n            }\n        }\n        return res + 1;\n    }\n}",
  "1844": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(replaceDigits(\"for_20little\"));\n        System.out.println(replaceDigits(\"hi5howkity43\"));\n        System.out.println(replaceDigits(\"a1b2\"));\n    }\n\n    public static String replaceDigits(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                sb.append('*');\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "1846": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumElement(new int[]{2,10,6,8,4,5,3,7})); // expected: 10\n        System.out.println(maximumElement(new int[]{0,2,1,3,4,9})) ; // expected: 9\n        System.out.println(maximumElement(new int[]{9,8,7,6,5,4,3,2,1})) ; // expected: 9\n    }\n\n    public static int maximumElement(int[] nums) {\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i + 1] > nums[i]) {\n                return Math.max(nums[0], nums[nums.length - 1]);\n            }\n        }\n        return Math.max(nums[0], nums[nums.length - 1]);\n    }\n}\n```",
  "1845": "```\nimport java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        SeatReservationManager manager = new SeatReservationManager();\n        \n        // Test case 1\n        int[][] bookings1 = {{10, 20}, {5, 15}};\n        System.out.println(\"Test case 1: \" + Arrays.deepToString(manager.book(bookings1)));\n        System.out.println(\"Expected output: [[0,2],[3,4]]\");\n        \n        // Test case 2\n        int[][] bookings2 = {{1, 3}, {5, 7}};\n        System.out.println(\"Test case 2: \" + Arrays.deepToString(manager.book(bookings2)));\n        System.out.println(\"Expected output: [[0,1],[2,4]]\");\n        \n        // Test case 3\n        int[][] bookings3 = {{0, 2}, {4, 6}, {7, 8}};\n        System.out.println(\"Test case 3: \" + Arrays.deepToString(manager.book(bookings3)));\n        System.out.println(\"Expected output: [[0,1],[5,6]]\");\n    }\n}\n```",
  "1847": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] rooms = {{1, 2}, {3, 4}, {5, 6}};\n        System.out.println(closestRoom(rooms));\n\n        rooms = new int[][]{{0, 1}, {2, 3}};\n        System.out.println(closestRoom(rooms));\n\n        rooms = new int[][]{{7, 8}, {9, 10}, {11, 12}, {13, 14}};\n        System.out.println(closestRoom(rooms));\n    }\n\n    public static int closestRoom(int[][] rooms) {\n        // Your code here\n    }\n}\n```",
  "1848": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {1,2,3,4,5};\n        System.out.println(\"Minimum Distance to Target in Array: \" + minDistanceToTarget(nums1, 5));\n        \n        int[] nums2 = {1,3,5};\n        System.out.println(\"Minimum Distance to Target in Array: \" + minDistanceToTarget(nums2, 2));\n        \n        int[] nums3 = {1};\n        System.out.println(\"Minimum Distance to Target in Array: \" + minDistanceToTarget(nums3, 0));\n    }\n\n    public static int minDistanceToTarget(int[] nums, int target) {\n        int minDist = Integer.MAX_VALUE;\n        for (int i : nums) {\n            if (Math.abs(i - target) < Math.abs(minDist)) {\n                minDist = i - target;\n            }\n        }\n        return minDist;\n    }\n}",
  "1850": "```\npublic class Main {\n    public static void main(String[] args) {\n        minSwaps(\"123456789\", 3);\n        System.out.println();\n        minSwaps(\"1234\", 2);\n        System.out.println();\n        minSwaps(\"3456789\", 1);\n    }\n\n    public static int minSwaps(String s, int k) {\n        // Your code here\n    }\n}\n```",
  "1849": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(descendingConsecutive(\"112358\"));\n        System.out.println(descendingConsecutive(\"123456789\"));\n        System.out.println(descendingConsecutive(\"9876543210\"));\n    }\n\n    public static List<String> descendingConsecutive(String s) {\n        List<String> result = new ArrayList<>();\n        backtrack(s, \"\", 0, result);\n        return result;\n    }\n\n    private static void backtrack(String s, String current, int start, List<String> result) {\n        if (start == s.length()) {\n            result.add(current);\n            return;\n        }\n        for (int i = start; i < s.length(); i++) {\n            if (i > start && s.charAt(i) - '0' <= s.charAt(i-1) - '0') break;\n            backtrack(s.substring(i+1), current + (s.charAt(i)) , i+1, result);\n        }\n    }\n}",
  "1851": "```\npublic class Solution {\n    public int[] minInterval(int[][] intervals, int[] queries) {\n        // your implementation here\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] intervals1 = {{1, 4}, {2, 3}};\n        int[] queries1 = {3};\n        int[] result1 = solution.minInterval(intervals1, queries1);\n        for (int num : result1) {\n            System.out.println(num);\n        }\n\n        int[][] intervals2 = {{4, 5}, {2, 3}, {6, 7}};\n        int[] queries2 = {5};\n        int[] result2 = solution.minInterval(intervals2, queries2);\n        for (int num : result2) {\n            System.out.println(num);\n        }\n\n        int[][] intervals3 = {{1, 3}, {4, 10}};\n        int[] queries3 = {5};\n        int[] result3 = solution.minInterval(intervals3, queries3);\n        for (int num : result3) {\n            System.out.println(num);\n        }\n    }\n}",
  "1852": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numDistinctRecords(new int[]{2,1,1,3}, 4));\n        System.out.println(numDistinctRecords(new int[]{2,2,1,1,3}, 4));\n        System.out.println(numDistinctRecords(new int[]{1,5,6,8,7,9,3,2,4}, 4));\n    }\n\n    public static int numDistinctRecords(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < k; i++) {\n            map.put(nums[i], i);\n        }\n        int distinctCount = map.size();\n        for (int i = k; i < nums.length; i++) {\n            if (!map.containsKey(nums[i])) {\n                map.put(nums[i], i);\n                distinctCount++;\n            } else if (i - map.get(nums[i]) >= k) {\n                map.remove(nums[i - k]);\n                distinctCount--;\n            }\n        }\n        return distinctCount;\n    }\n}\n```",
  "1853": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(formatDate(\"2025-01-31\")); // Expected: \"January 1, 2025\"\n        System.out.println(formatDate(\"2000-07-04\")); // Expected: \"July 4, 2000\"\n        System.out.println(formatDate(\"2012-12-25\")); // Expected: \"December 25, 2012\"\n    }\n\n    public static String formatDate(String date) {\n        try {\n            DateTimeFormatter originalFormat = DateTimeFormat.forPattern(\"yyyy-MM-dd\");\n            DateTime parsedDate = originalFormat.parseDateTime(date);\n            DateTimeFormatter targetFormat = DateTimeFormat.forPattern(\"MMMM d, yyyy\");\n            return targetFormat.printDateTime(parsedDate).toString();\n        } catch (Exception e) {\n            return \"Invalid date\";\n        }\n    }\n}\n```",
  "1854": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] input1 = {{1993,2019},{1978,1994}};\n        System.out.println(\"Input 1: \" + maximumPopulation(input1));\n        \n        int[][] input2 = {{1950,1965},{1966,1989},{1990,2002},{2003,2017}};\n        System.out.println(\"Input 2: \" + maximumPopulation(input2));\n\n        int[][] input3 = {{1974,1988},{1987,1991}};\n        System.out.println(\"Input 3: \" + maximumPopulation(input3));\n    }\n\n    public static int maximumPopulation(int[][] logs) {\n        Map<Integer, Integer> populationMap = new HashMap<>();\n        for (int[] log : logs) {\n            int year = log[0];\n            int population = log[1] - log[0] + 1;\n            populationMap.put(year, population);\n        }\n        \n        int maxYear = 0;\n        int maxPopulation = 0;\n        for (int year : populationMap.keySet()) {\n            if (populationMap.get(year) > maxPopulation) {\n                maxPopulation = populationMap.get(year);\n                maxYear = year;\n            }\n        }\n        \n        return maxYear;\n    }\n}\n```",
  "1855": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrays = {{91, 94, 80, 77, 82, 77, 71, 99, 95, 95}};\n        for (int i = 0; i < arrays.length; i++) {\n            int maxDistance = maxDistanceBetweenPair(arrays[i]);\n            System.out.println(\"The maximum distance between a pair of values in array \" + (i+1) + \" is: \" + maxDistance);\n        }\n    }\n\n    public static int maxDistanceBetweenPair(int[] arr) {\n        Arrays.sort(arr);\n\n        int maxDist = 0;\n        for (int i = 0; i < arr.length - 1; i++) {\n            maxDist = Math.max(maxDist, arr[i + 1] - arr[i]);\n        }\n        return maxDist;\n    }\n}",
  "1856": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumSubarrayMinProduct(new int[]{6,7,8,-5}, 2)); // Expected output: 40\n        System.out.println(maximumSubarrayMinProduct(new int[]{-2,0,-1}, 3)); // Expected output: -1\n        System.out.println(maximumSubarrayMinProduct(new int[]{2,2}, 4)); // Expected output: 4\n    }\n\n    public static int maximumSubarrayMinProduct(int[] nums, int k) {\n        if (k > nums.length) return 0;\n        long max = Long.MIN_VALUE;\n        int left = 0, right = 0;\n        while (right < nums.length) {\n            long minProduct = 1;\n            for (int i = right; i >= left && i - left + 1 <= k; i--) {\n                minProduct *= nums[i];\n                if (minProduct == 0) break;\n            }\n            max = Math.max(max, minProduct);\n            if (right < nums.length - 1) right++;\n            else break;\n        }\n        return (int)max;\n    }\n}\n```",
  "1857": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(largestAltitude(new String[]{\"WETT\", \"MOTT\", \"KITT\"})); // Expected: 2\n        System.out.println(largestAltitude(new String[]{\"WETT\", \"OTT\", \"KITT\"})); // Expected: 1\n        System.out.println(largestAltitude(new String[]{\"BUGA\", \"UPFA\", \"CBUG\", \"CBUC\", \"UBBC\", \"BBUG\", \"CBAU\", \"CCBU\"})); // Expected: 2\n    }\n\n    public static int largestAltitude(String[] H) {\n        Map<String, Integer> map = new HashMap<>();\n        int max = 0;\n        for (String s : H) {\n            String[] parts = s.split(\"\");\n            int cur = 0;\n            for (int i = 0; i < parts.length - 1; i++) {\n                if (parts[i].equals(\"U\") && parts[i + 1].equals(\"D\")) {\n                    cur -= 1;\n                } else if (parts[i].equals(\"D\") && parts[i + 1].equals(\"U\")) {\n                    cur += 1;\n                }\n            }\n            map.put(s, cur);\n            max = Math.max(max, cur);\n        }\n        return max;\n    }\n\n}\n```",
  "1858": "```\nclass Solution {\n    public String longestWord(String[] words) {\n        class TrieNode {\n            TrieNode[] children = new TrieNode[26];\n            boolean endsHere;\n        }\n\n        TrieNode root = new TrieNode();\n        for (String word : words) {\n            TrieNode current = root;\n            for (char c : word.toCharArray()) {\n                if (current.children[c - 'a'] == null) {\n                    current.children[c - 'a'] = new TrieNode();\n                }\n                current = current.children[c - 'a'];\n            }\n            current.endsHere = true;\n        }\n\n        String longestWord = \"\";\n        for (String word : words) {\n            TrieNode current = root;\n            boolean validPrefix = true;\n            for (char c : word.toCharArray()) {\n                if (current.children[c - 'a'] == null || !current.endsHere) {\n                    validPrefix = false;\n                    break;\n                }\n                current = current.children[c - 'a'];\n            }\n            if (validPrefix && word.length() > longestWord.length()) {\n                longestWord = word;\n            } else if (validPrefix && word.length() == longestWord.length()) {\n                longestWord = longestWord.compareTo(word) <= 0 ? longestWord : word;\n            }\n        }\n\n        return longestWord;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String[] words1 = {\"w\",\"wo\",\"wor\",\"worl\",\"world\"};\n        System.out.println(solution.longestWord(words1)); // Should print \"world\"\n\n        String[] words2 = {\"abc\",\"abcd\"};\n        System.out.println(solution.longestWord(words2)); // Should print \"abcd\"\n\n        String[] words3 = {};\n        System.out.println(solution.longestWord(words3)); // Should print \"\"\n    }\n}",
  "1859": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sortSentence(\"is2 sentence4 This1 a3\")); // \"This1 is2 a3 sentence4\")\n        System.out.println(sortSentence(\"Myself2 hi1 I7 wow3 Is2\")); // \"hi1 Myself2 wow3 Is2 I7\")\n        System.out.println(sortSentence(\"Oh what1 a3 test4 Your5 drive6 yourself4 and5 coding6\")); // \"a3 and5 coding6 drive6 Oh1 test4 what1 Yourself5 your4\")\n    }\n\n    public static String sortSentence(String s) {\n        String[] words = s.split(\" \");\n        Arrays.sort(words, (a, b) -> Integer.parseInt(a.substring(0, a.indexOf(' '))) - Integer.parseInt(b.substring(0, b.indexOf(' '))));\n        return String.join(\" \", words);\n    }\n}",
  "1860": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \" + new Solution().totalMemoryLeaked(new int[]{5, 4, 2, 7}, 9));\n        System.out.println(\"Test Case 2: \" + new Solution().totalMemoryLeaked(new int[]{1, 3, 6, 4, 1, 2, 3, 5, 4, 3}, 25));\n        System.out.println(\"Test Case 3: \" + new Solution().totalMemoryLeaked(new int[]{8, 7, 6, 5, 4, 3, 2, 1}, 15));\n    }\n}\n\nclass Solution {\n    public int totalMemoryLeaked(int[] memoryUsed, int maxMemory) {\n        int totalMem = 0;\n        for (int i = 0; i < memoryUsed.length; i++) {\n            if (totalMem + memoryUsed[i] > maxMemory) {\n                totalMem += memoryUsed[i];\n            } else {\n                totalMem = Math.min(maxMemory, totalMem + memoryUsed[i]);\n            }\n        }\n        return totalMem;\n    }\n}",
  "1861": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] box = {{1,2,6,5,4},{8,7,9,10,3},{0,5}};\n        rotate(box);\n        printBox(box);\n\n        box = new int[][]{{1,2},{3,4}};\n        rotate(box);\n        printBox(box);\n\n        box = new int[][]{{1,2,3},{7,8,9}};\n        rotate(box);\n        printBox(box);\n    }\n\n    public static void rotate(int[][] box) {\n        int n = box.length;\n        for (int i = 0; i < n / 2; ++i) {\n            for (int j = i; j < n - i - 1; ++j) {\n                int temp = box[i][j];\n                box[i][j] = box[j][n - i - 1];\n                box[j][n - i - 1] = box[n - i - 1][n - j - 1];\n                box[n - i - 1][n - j - 1] = box[n - j - 1][i];\n                box[n - j - 1][i] = temp;\n            }\n        }\n    }\n\n    public static void printBox(int[][] box) {\n        for (int[] row : box) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
  "1862": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfFlooredPairs(new int[]{10,2,5,1,7,6,8})); // Expected: 26\n        System.out.println(sumOfFlooredPairs(new int[]{1,4,3,2,5,8})); // Expected: 21\n        System.out.println(sumOfFlooredPairs(new int[]{1,1,1,1,1})); // Expected: 10\n    }\n\n    public static int sumOfFlooredPairs(int[] nums) {\n        Arrays.sort(nums);\n        long total = 0;\n        for (int i = 0; i < nums.length - 1; i++) {\n            int left = nums[i];\n            int right = nums[i + 1] - 1;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                total += Math.min(right, mid);\n                if (mid == right) {\n                    break;\n                }\n                if (mid < right) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n        return (int)total;\n    }\n}",
  "1863": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[] nums1 = {5, 1};\n        System.out.println(\"Case 1: \" + subsetXORSum(nums1));\n        \n        int[] nums2 = {7};\n        System.out.println(\"Case 2: \" + subsetXORSum(nums2));\n        \n        int[] nums3 = {2,3,4};\n        System.out.println(\"Case 3: \" + subsetXORSum(nums3));\n    }\n\n    public static int subsetXORSum(int[] nums) {\n        int totalXOR = 0;\n        for (int num : nums) {\n            totalXOR ^= num;\n        }\n        \n        int n = nums.length;\n        int result = 0;\n        for (int i = 0; i < (1 << n); i++) {\n            int temp = 0;\n            for (int j = 0; j < n; j++) {\n                if (((i >> j) & 1) == 1) {\n                    temp ^= nums[j];\n                }\n            }\n            result ^= temp;\n        }\n        \n        return totalXOR + result;\n    }\n}\n```",
  "1864": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSwaps(\"11100\")); // Expected: 4\n        System.out.println(minSwaps(\"01001\")); // Expected: 0\n        System.out.println(minSwaps(\"10100110\")); // Expected: 3\n    }\n\n    public static int minSwaps(String s) {\n        int swaps = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            if ((s.charAt(i) == '1' && s.charAt(i + 1) == '1') ||\n                (s.charAt(i) == '0' && s.charAt(i + 1) == '0')) {\n                swaps++;\n                i++; // Skip the next iteration\n            }\n        }\n        return swaps;\n    }\n}\n```",
  "1865": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] nums1 = {{1, 2}, {2, 4}, {1, 3}};\n        System.out.println(\"Test case 1: \" + numPairs(nums1));\n        \n        int[][] nums2 = {{1, 5}, {10, 20}, {5, 16}, {7, 8]};\n        System.out.println(\"Test case 2: \" + numPairs(nums2));\n        \n        int[][] nums3 = {{1, 2}};\n        System.out.println(\"Test case 3: \" + numPairs(nums3));\n    }\n\n    public static int numPairs(int[][] pairs) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] pair : pairs) {\n            int sum = pair[0] + pair[1];\n            map.put(sum, map.getOrDefault(sum, 0) + 1);\n        }\n        \n        int count = 0;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (entry.getKey() % 2 == 0) {\n                count += entry.getValue() * (entry.getValue() - 1) / 2;\n            } else {\n                count += entry.getValue() * (entry.getValue() - 1) / 2 + 1;\n            }\n        }\n        \n        return count;\n    }\n}",
  "1866": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] inputs = {\n            {2, 3},\n            {1, 2},\n            {5, 4}\n        };\n        int expectedOutputs[] = {2, 2, 7};\n        for (int i = 0; i < inputs.length; i++) {\n            int k = inputs[i][0];\n            int n = inputs[i][1];\n            System.out.println(\"For k = \" + k + \", n = \" + n + \": \" + numWays(k, n));\n            System.out.println(\"Expected: \" + expectedOutputs[i]);\n            System.out.println();\n        }\n    }\n\n    public static int numWays(int k, int n) {\n        if (k > n) {\n            return 0;\n        }\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = Math.max(0, i - k); j <= i; j++) {\n                dp[i] += dp[j];\n            }\n        }\n        return dp[n];\n    }\n}\n```",
  "1867": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        testCase1();\n        testCase2();\n        testCase3();\n    }\n\n    private static void testCase1() {\n        Solution solution = new Solution();\n        int[][] orders = {{10, 5}, {20, 6}, {30, 7}};\n        int result = solution.maxOrdersAboveAverage(orders);\n        System.out.println(\"Test Case 1: \" + result);\n    }\n\n    private static void testCase2() {\n        Solution solution = new Solution();\n        int[][] orders = {{1, 3}, {2, 4}, {3, 5}};\n        int result = solution.maxOrdersAboveAverage(orders);\n        System.out.println(\"Test Case 2: \" + result);\n    }\n\n    private static void testCase3() {\n        Solution solution = new Solution();\n        int[][] orders = {{10, 1}, {20, 2}, {30, 3}};\n        int result = solution.maxOrdersAboveAverage(orders);\n        System.out.println(\"Test Case 3: \" + result);\n    }\n}\n\nclass Solution {\n    public int maxOrdersAboveAverage(int[][] orders) {\n        // Your code here\n    }\n}\n```",
  "1868": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(productSize(new int[][]{{1, 2}, {3, 4}}, new int[][]{{1, 2}}));\n        System.out.println(productSize(new int[][]{new int[]{1, 1, 1, 5}, new int[]{1, 1, 3, 4}}, new int[][]{new int[]{1, 1, 2, 6}}));\n        System.out.println(productSize(new int[][]{{10, 10, 10}, {11, 12, 13, 14, 15, 16, 17, 18, 19, 20}}, new int[][]{{1, 2, 3, 4, 5, 6}}));\n    }\n\n    public static long productSize(int[][] nums1, int[][] nums2) {\n        int m = nums1.length;\n        int n = nums2.length;\n        long res = 0;\n        int i = 0, j = 0;\n\n        while (i < m && j < n) {\n            if (nums1[i].length == 0) {\n                res += (long) Math.pow(nums2[j][0], nums2[j++][1]);\n            } else if (nums2[j].length == 0) {\n                res += (long) Math.pow(nums1[i][0], nums1[i++][1]);\n            } else if (nums1[i][0] < nums2[j][0]) {\n                res += (long) Math.pow(nums1[i][0], nums1[i++][1]);\n            } else {\n                res += (long) Math.pow(nums2[j][0], nums2[j++][1]);\n            }\n        }\n\n        for (; i < m; i++) {\n            res += (long) Math.pow(nums1[i][0], nums1[i][1]);\n        }\n\n        for (; j < n; j++) {\n            res += (long) Math.pow(nums2[j][0], nums2[j][1]);\n        }\n\n        return res;\n    }\n}\n```",
  "1869": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeIncreasing(\"1100\")); // Expected: true\n        System.out.println(canBeIncreasing(\"111000\")); // Expected: false\n        System.out.println(canBeIncreasing(\"1101\")); // Expected: true\n    }\n\n    public static boolean canBeIncreasing(String s) {\n        int ones = 0, zeros = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '1') ones++;\n            else zeros++;\n            if (i > 0 && s.charAt(i - 1) == '1' && s.charAt(i) == '0') return true;\n        }\n        return false;\n    }\n}",
  "1870": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumSpeed(new int[]{2,4,6}, 8, 5)); // Output: 4\n        System.out.println(minimumSpeed(new int[]{1,3,2}, 3, 2)); // Output: 3\n        System.out.println(minimumSpeed(new int[]{10,5,0}, 15, 3)); // Output: 6\n    }\n\n    public static int minimumSpeed(int[] distance, int hours, int currentHour) {\n        Arrays.sort(distance);\n        int left = 0, right = (int)1e9;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            long totalHours = 0;\n            for (int d : distance) {\n                totalHours += (long)d * mid / 100 + d;\n            }\n            if (totalHours <= hours * 60 + currentHour * 60) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```",
  "1871": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canReach(\"1113323221\")); // true\n        System.out.println(canReach(\"00011111\")); // false\n        System.out.println(canReach(\"0110101\")); // true\n    }\n\n    public static boolean canReach(String s) {\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '0') continue;\n            int lastZeroIndex = -1;\n            for (int j = i + 1; j < n; j++) {\n                if (s.charAt(j) == '0') {\n                    lastZeroIndex = j;\n                    break;\n                } else if (j == n - 1) return true;\n            }\n            if (lastZeroIndex != -1 && s.substring(i, lastZeroIndex).equals(new String(new char[lastZeroIndex - i]).replaceChar('1', '0'))) continue;\n            return false;\n        }\n        return true;\n    }\n}\n```",
  "1872": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] piles = {{5, 1}, {2, 1, 4}, {1, 7, 3, 2}};\n        System.out.println(stoneGameVIII(piles));\n        \n        piles = new int[][]{{20, 40, 15, 10}};\n        System.out.println(stoneGameVIII(piles));\n\n        piles = new int[][]{{5}};\n        System.out.println(stoneGameVIII(piles));\n    }\n\n    public static int stoneGameVIII(int[][] piles) {\n        // your code here\n    }\n}",
  "1873": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(calculateSpecialBonus(1, new int[]{1,2,3}, new int[]{10,20,30}) == 60 ? \"Test case 1 passed\" : \"Test case 1 failed\");\n        System.out.println(calculateSpecialBonus(2, new int[]{5,7,8}, new int[]{15,30,40}) == 150 ? \"Test case 2 passed\" : \"Test case 2 failed\");\n        System.out.println(calculateSpecialBonus(3, new int[]{10,20,30}, new int[]{50,60,70}) == 180 ? \"Test case 3 passed\" : \"Test case 3 failed\");\n    }\n\n    public static int calculateSpecialBonus(int n, int[] scores, int[] bonuses) {\n        int total = 0;\n        for (int i = 0; i < n; i++) {\n            if (scores[i] > 5) {\n                total += scores[i] * bonuses[i];\n            } else {\n                total += scores[i] * bonuses[i] / 2;\n            }\n        }\n        return total;\n    }\n}",
  "1874": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {{1, 4}, {2, 5}};\n        System.out.println(minProductSum(arrays));\n\n        arrays = new int[][]{{10, 2}, {5, 7, 9}};\n        System.out.println(minProductSum(arrays));\n\n        arrays = new int[][]{{3, 8, 10}, {1, 2, 4}};\n        System.out.println(minProductSum(arrays));\n    }\n\n    public static int minProductSum(int[][] nums) {\n        if (nums.length == 0 || nums[0].length == 0)\n            return 0;\n\n        Arrays.sort(nums[0]);\n        Arrays.sort(nums[1], (a, b) -> Integer.compare(b, a));\n\n        int sum = 0;\n        for (int i = 0; i < Math.min(nums[0].length, nums[1].length); i++) {\n            sum += nums[0][i] * nums[1][i];\n        }\n\n        return sum;\n    }\n}\n```",
  "1875": "```\nimport java.util.*;\n\nclass Solution {\n    public List<List<Employee>> groupEmployees(Schema.Employee[] employees) {\n        Map<Integer, List<Schema.Employee>> map = new HashMap<>();\n        for (Schema.Employee employee : employees) {\n            if (!map.containsKey(employee.salary)) {\n                map.put(employee.salary, new ArrayList<>());\n            }\n            map.get(employee.salary).add(employee);\n        }\n        return new ArrayList<>(map.values());\n    }\n\n    public static class Employee {\n        public int id;\n        public int salary;\n\n        public Employee(int id, int salary) {\n            this.id = id;\n            this.salary = salary;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        Schema.Employee[] employees1 = {new Schema.Solution.Employee(1, 100), \n                                          new Schema.Solution.Employee(2, 200)};\n        System.out.println(solution.groupEmployees(employees1));\n        \n        Schema.Employee[] employees2 = {new Schema.Solution.Employee(1, 300), \n                                          new Schema.Solution.Employee(2, 300),\n                                          new Schema.Solution.Employee(3, 100)};\n        System.out.println(solution.groupEmployees(employees2));\n\n        Schema.Employee[] employees3 = {new Schema.Solution.Employee(1, 200), \n                                          new Schema.Solution.Employee(2, 200), \n                                          new Schema.Solution.Employee(3, 500), \n                                          new Schema.Solution.Employee(4, 300)};\n        System.out.println(solution.groupEmployees(employees3));\n    }\n}\n```",
  "1876": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(substringsWithDistinctCharacters(\"abc\", 3)); // Expected output: 2\n        System.out.println(substringsWithDistinctCharacters(\"bbb\", 3)); // Expected output: 0\n        System.out.println(substringsWithDistinctCharacters(\"rivqyuxw\", 3)); // Expected output: 9\n    }\n\n    public static int substringsWithDistinctCharacters(String s, int size) {\n        if (s.length() < size || size <= 0) {\n            return 0;\n        }\n        \n        int count = 0;\n        Map<Character, Boolean> map = new HashMap<>();\n        for (int i = 0; i < size - 1; i++) {\n            map.put(s.charAt(i), true);\n        }\n\n        for (int i = size - 1; i < s.length(); i++) {\n            if (map.size() == size) {\n                count++;\n            }\n            map.put(s.charAt(i), true);\n            if (i >= size - 1) {\n                map.remove(s.charAt(i - size + 1));\n            }\n        }\n\n        return count;\n    }\n}",
  "1877": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] arr1 = {3,2,7,11};\n        System.out.println(\"Minimize Maximum Pair Sum in Array for \" + Arrays.toString(arr1) +\n                \": \" + minPairSum(new int[]{arr1}));\n        \n        int[] arr2 = {7,6,5,4};\n        System.out.println(\"Minimize Maximum Pair Sum in Array for \" + Arrays.toString(arr2) +\n                \": \" + minPairSum(new int[]{arr2}));\n        \n        int[] arr3 = {1,5,3,10};\n        System.out.println(\"Minimize Maximum Pair Sum in Array for \" + Arrays.toString(arr3) +\n                \": \" + minPairSum(new int[]{arr3}));\n    }\n\n    public static int minPairSum(int[] nums) {\n        Arrays.sort(nums);\n        int left = 0;\n        int right = nums.length - 1;\n        int maxSum = 0;\n\n        while (left < right) {\n            int sum = nums[left] + nums[right];\n            if (sum > maxSum) {\n                maxSum = sum;\n            }\n            if (nums[left] < nums[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return maxSum;\n    }\n}",
  "1878": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {{-5, -3}, {-6, -10, -15}};\n        System.out.println(\"Grid 1: \" + Arrays.toString(getBiggestThree(grid1)));\n        \n        int[][] grid2 = {{1,-2,-5,0},{-5,1,1,1},{1,1,1,1},{1,1,1,1}};\n        System.out.println(\"Grid 2: \" + Arrays.toString(getBiggestThree(grid2)));\n        \n        int[][] grid3 = {{1, -2, -2, 0}, {-3, -2, -1, -4}, {-3, 0, 0, 4}, {2, 1, -5, 1}};\n        System.out.println(\"Grid 3: \" + Arrays.toString(getBiggestThree(grid3)));\n    }\n\n    public static int[] getBiggestThree(int[][] grid) {\n        int n = grid.length;\n        int m = grid[0].length;\n        int maxSum = 0;\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> b - a);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i + j < n && i - j >= 0) {\n                    int sum1 = grid[i][j] + grid[i+1][j+1];\n                    int sum2 = grid[i][j-1] + grid[i+1][j];\n                    queue.add(Math.max(sum1, Math.max(sum2, grid[i][j])));\n                }\n            }\n        }\n        \n        int[] result = new int[3];\n        for (int i = 0; i < 3 && !queue.isEmpty(); i++) {\n            result[i] = queue.poll();\n        }\n        Arrays.sort(result);\n        return result;\n    }\n}",
  "1879": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays1 = {{14, 28}, {0, 15}};\n        System.out.println(\"Expected: 10, Actual: \" + findMinimumXOR(arrays1));\n\n        int[][] arrays2 = {{1, 6, 5}, {3, 5, 7}};\n        System.out.println(\"Expected: 9, Actual: \" + findMinimumXOR(arrays2));\n\n        int[][] arrays3 = {{0, 10, 5, 3}, {15, 5, 20, 14}};\n        System.out.println(\"Expected: 12, Actual: \" + findMinimumXOR(arrays3));\n    }\n\n    public static int findMinimumXOR(int[][] arrays) {\n        // Write your code here\n    }\n}\n```",
  "1880": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(checkIfSumEqual(\"dog\", \"cat\", \"god\")); // Expected: true\n        System.out.println(checkIfSumEqual(\"aaa\", \"aa\", \"a\")); // Expected: false\n        System.out.println(checkIfSumEqual(\"car\", \"rabbit\", \"crate\")); // Expected: true\n    }\n\n    public static boolean checkIfSumEqual(String word1, String word2, String target) {\n        for (int i = 0; i <= target.length() - word1.length(); i++) {\n            if (target.substring(i, i + word1.length()).equals(word1) && target.substring(0, i).equals(word2)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "1881": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxValueAfterInsertions(\"48\", \"95\")); // expected output: 183\n        System.out.println(maxValueAfterInsertions(\"10,1,20,8\", \"12\")) ;// expected output: 214\n        System.out.println(maxValueAfterInsertions(\"\", \"10101\")) ;// expected output: 10101\n    }\n\n    public static int maxValueAfterInsertions(String numString, String digit) {\n        char[] numArray = numString.toCharArray();\n        for (int i = 0; i < numArray.length; i++) {\n            if (!Character.toString(numArray[i]).equals(digit)) {\n                continue;\n            }\n            int max = Integer.parseInt(Character.toString(numArray[0]));\n            for (int j = 1; j <= i; j++) {\n                if (Integer.parseInt(Character.toString(numArray[j])) > max) {\n                    max = Integer.parseInt(Character.toString(numArray[j]));\n                }\n            }\n            for (int k = i + 1; k < numArray.length; k++) {\n                if (!Character.toString(numArray[k]).equals(digit)) {\n                    continue;\n                }\n                if (Integer.parseInt(Character.toString(numArray[k])) > max) {\n                    max = Integer.parseInt(Character.toString(numArray[k]));\n                }\n            }\n            return max * 10 + Integer.parseInt(digit);\n        }\n        return Integer.parseInt(digit);\n    }\n}",
  "1882": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] tasks = {\n            {9, 3, 9},\n            {5, 8, 5},\n            {2, 1, 4}\n        };\n\n        System.out.println(\"Test Case 1:\");\n        processTasks(tasks[0]);\n        System.out.println();\n\n        System.out.println(\"Test Case 2:\");\n        processTasks(tasks[1]);\n        System.out.println();\n\n        System.out.println(\"Test Case 3:\");\n        processTasks(tasks[2]);\n    }\n\n    public static void processTasks(int[][] tasks) {\n        // Your solution code here\n    }\n}\n```",
  "1883": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{2,6,5,4,8,10}};\n        System.out.println(\"Test case 1: \" + minSkips(arr1));\n        \n        int[][] arr2 = {{3,9,2,6,7,12}};\n        System.out.println(\"Test case 2: \" + minSkips(arr2));\n\n        int[][] arr3 = {{1,5,7,4,10,13}};\n        System.out.println(\"Test case 3: \" + minSkips(arr3));\n    }\n\n    public static int minSkips(int[][] timeToWalk) {\n        int n = timeToWalk[0].length;\n        int dp[] = new int[n];\n        int skip[] = new int[n];\n\n        for (int i = 1; i < n; i++) {\n            if (timeToWalk[0][i] > timeToWalk[0][i - 1]) {\n                dp[i] = Math.min(dp[i - 1], 1);\n            } else {\n                dp[i] = Math.min(dp[i - 1], 2);\n            }\n        }\n\n        for (int i = n - 1; i > 0; i--) {\n            if (timeToWalk[0][i] < timeToWalk[0][i - 1]) {\n                skip[i] = 1;\n            } else if (timeToWalk[0][i] == timeToWalk[0][i - 1]) {\n                skip[i] = Math.min(skip[i - 1], 2);\n            } else {\n                skip[i] = Math.min(skip[i - 1], 1);\n            }\n        }\n\n        int minSkip = 0;\n        for (int i = 0; i < n; i++) {\n            if (dp[i] + skip[i] > minSkip) {\n                minSkip = dp[i] + skip[i];\n            }\n        }\n\n        return minSkip;\n    }\n}\n```",
  "1884": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minEggDrops(2, 10)); // Test case 1: Two eggs and 10 floors\n        System.out.println(minEggDrops(4, 5)); // Test case 2: Four eggs and 5 floors\n        System.out.println(minEggDrops(3, 7)); // Test case 3: Three eggs and 7 floors\n    }\n\n    public static int minEggDrops(int n, int k) {\n        if (n < 1 || k < 1) return -1;\n        int[][] dp = new int[n + 1][k + 1];\n        for (int i = 0; i <= n; i++) {\n            dp[i][1] = i;\n        }\n        for (int j = 0; j <= k; j++) {\n            dp[1][j] = j;\n        }\n        for (int i = 2; i <= n; i++) {\n            for (int j = 2; j <= k; j++) {\n                dp[i][j] = Integer.MAX_VALUE;\n                for (int x = 1; x <= j; x++) {\n                    int y = Math.max(i - 1, x - 1);\n                    dp[i][j] = Math.min(dp[i][j], 1 + Math.max(dp[x][y], dp[i - x][j - x]));\n                }\n            }\n        }\n        return dp[n][k];\n    }\n}",
  "1885": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arr1 = {{1, 2, 3}, {1, 4}};\n        int[][] arr2 = {{1, 2, 3, 4}, {1, 5}};\n\n        System.out.println(\"Test case 1: \" + countPairs(arr1[0], arr1[1]));\n        System.out.println(\"Test case 2: \" + countPairs(arr2[0], arr2[1]));\n        System.out.println(\"Test case 3: \" + countPairs(new int[]{1, 2}, new int[]{3, 4}));\n    }\n\n    public static int countPairs(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1);\n        Arrays.sort(arr2);\n\n        int i = 0;\n        int j = 0;\n        int pairs = 0;\n\n        while (i < arr1.length && j < arr2.length) {\n            if (arr1[i] <= arr2[j]) {\n                i++;\n            } else {\n                j++;\n            }\n            pairs += Math.min(arr1.length - i, arr2.length - j);\n        }\n\n        return pairs;\n    }\n}\n```",
  "1886": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{0,1},{1,0}};\n        System.out.println(canBeObtainedByRotation(matrix1));\n        \n        int[][] matrix2 = {{0,0,0},{0,1,0},{1,1,1}};\n        System.out.println(canBeObtainedByRotation(matrix2));\n\n        int[][] matrix3 = {{1,0},{0,1}};\n        System.out.println(canBeObtainedByRotation(matrix3));\n    }\n\n    public static boolean canBeObtainedByRotation(int[][] target) {\n        for (int i = 0; i < 4; i++) {\n            if (equals(target, rotate(target))) {\n                return true;\n            }\n            target = rotate(target);\n        }\n        return false;\n    }\n\n    public static int[][] rotate(int[][] matrix) {\n        int n = matrix.length;\n        int[][] result = new int[n][];\n        for (int i = 0; i < n; i++) {\n            result[i] = new int[n];\n            for (int j = 0; j < n; j++) {\n                result[i][j] = matrix[j][i];\n            }\n        }\n        return result;\n    }\n\n    public static boolean equals(int[][] m1, int[][] m2) {\n        if (m1.length != m2.length || m1[0].length != m2[0].length) {\n            return false;\n        }\n        for (int i = 0; i < m1.length; i++) {\n            for (int j = 0; j < m1[0].length; j++) {\n                if (m1[i][j] != m2[i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
  "1887": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {\n            {{10}, {2, 7, 5}},\n            {{1, 4, 9}, {5, 6, 8}},\n            {{15, 45, 55}, {-1, -4, -10}}\n        };\n\n        for (int[] array : arrays) {\n            System.out.println(\"Input: \" + Arrays.toString(array));\n            int res = reductionOperations(array);\n            System.out.println(\"Output: \" + res);\n            System.out.println();\n        }\n    }\n\n    public static int reductionOperations(int[][] arr) {\n        Arrays.sort(arr[0]);\n        Arrays.sort(arr[1]);\n\n        int min = Math.min(arr[0][0], arr[1][0]);\n        int operations = 0;\n\n        for (int i = 0; i < arr[0].length && i < arr[1].length; i++) {\n            if (arr[0][i] != min) {\n                operations += Math.abs(arr[0][i] - min);\n            }\n            if (arr[1][i] != min) {\n                operations += Math.abs(arr[1][i] - min);\n            }\n        }\n\n        return operations;\n    }\n}",
  "1888": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minFlips(\"0112465\"));//test case 1: \"0112465\" should return 3\n        System.out.println(minFlips(\"01011000\"));//test case 2: \"01011000\" should return 4\n        System.out.println(minFlips(\"11111\"));//test case 3: \"11111\" should return 0\n    }\n\n    public static int minFlips(String s) {\n        int flips = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            if ((s.charAt(i) == '0' && s.charAt(i + 1) == '0') ||\n                (s.charAt(i) == '1' && s.charAt(i + 1) == '1')) {\n                flips++;\n            }\n        }\n        return flips;\n    }\n}",
  "1889": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] packages = {\n            {1,3},\n            {2,5,4},\n            {5,4,3}\n        };\n        \n        System.out.println(minimumSpaceWasted(packages));\n    }\n    \n    public static int minimumSpaceWasted(int[][] packages) {\n        Arrays.sort(packages, (a, b) -> Integer.compare(a[1], b[1]));\n        \n        int total = 0;\n        for (int[] package : packages) {\n            total += package[1];\n        }\n        \n        int wasted = 0;\n        for (int i = 0; i < packages.length - 1; i++) {\n            if (packages[i][1] + packages[i+1][0] > packages[i+1][1]) {\n                wasted += packages[i+1][1];\n                total -= packages[i+1][1];\n            }\n        }\n        \n        return total - wasted;\n    }\n}",
  "1890": "```\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        List<Login> logs = new ArrayList<>();\n        logs.add(new Login(\"user1\", \"2020-12-31 14:30:00\"));\n        logs.add(new Login(\"user2\", \"2020-01-15 10:45:00\"));\n        logs.add(new Login(\"user3\", \"2020-03-20 18:00:00\"));\n\n        System.out.println(getLatestLogin(logs));\n\n        test1();\n        test2();\n        test3();\n    }\n\n    public static String getLatestLogin(List<Login> logs) {\n        if (logs.isEmpty()) return \"\";\n        Login latest = logs.get(0);\n        for (Login log : logs) {\n            if (log.getTime().compareTo(latest.getTime()) > 0) {\n                latest = log;\n            }\n        }\n        return latest.username + \" \" + latest.time;\n    }\n\n    public static void test1() {\n        List<Login> logs = new ArrayList<>();\n        logs.add(new Login(\"userA\", \"2020-12-31 14:30:00\"));\n        System.out.println(getLatestLogin(logs));\n    }\n\n    public static void test2() {\n        List<Login> logs = new ArrayList<>();\n        logs.add(new Login(\"userB\", \"2019-01-15 10:45:00\"));\n        System.out.println(getLatestLogin(logs));\n    }\n\n    public static void test3() {\n        List<Login> logs = new ArrayList<>();\n        logs.add(new Login(\"userC\", \"2020-03-20 18:00:00\"));\n        System.out.println(getLatestLogin(logs));\n    }\n}\n\nclass Login {\n    String username;\n    String time;\n\n    public Login(String username, String time) {\n        this.username = username;\n        this.time = time;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public String getTime() {\n        return time;\n    }\n}\n```",
  "1891": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(cuttingRibbon(new int[]{9}, 2) == 4);\n        System.out.println(cuttingRibbon(new int[]{5,7,9}, 2) == 3);\n        System.out.println(cuttingRibbon(new int[]{10,100,300,400}, 2) == 1);\n    }\n\n    public static int cuttingRibbon(int[] cuttings, int n) {\n        Arrays.sort(cuttings);\n        for (int i = 0; i < cuttings.length - 1; i++) {\n            while (cuttings[i] + cuttings[i + 1] > n) {\n                cuttings[i] = cuttings[i] / 2;\n            }\n        }\n        int res = 0;\n        for (int cutting : cuttings) {\n            res += Math.min(cutting, n) - res;\n        }\n        return res;\n    }\n}\n```",
  "1892": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] logs = { {5, \"A\", \"home\"} };\n        int k = 1;\n        System.out.println(recommend(logs, k));\n        \n        logs = new int[][]{ {45, \"4\", \"app\"}, {45, \"42\", \"app\"}, {46, \"2\", \"app\"}, {47, \"22\", \"web\"}, {48, \"7\", \"os\"}, {60, \"1\", \"app\"}, {300, \"1000003\", \"app\"} };\n        k = 10;\n        System.out.println(recommend(logs, k));\n        \n        logs = new int[][]{ {1, \"A\", \"home\"} };\n        k = 1;\n        System.out.println(recommend(logs, k));\n    }\n\n    public static List<String> recommend(int[][] logs, int k) {\n        Map<String, Integer> userClickCount = new HashMap<>();\n        for (int[] log : logs) {\n            int userId = log[0];\n            String pageId = log[1];\n            boolean isHomePage = log[2].equals(\"home\");\n            if (!isHomePage) {\n                userClickCount.put(pageId, userClickCount.getOrDefault(pageId, 0) + 1);\n            }\n        }\n\n        List<String> recommendations = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            String mostClickedPage = null;\n            int maxClicks = 0;\n            for (Map.Entry<String, Integer> entry : userClickCount.entrySet()) {\n                if (entry.getValue() > maxClicks) {\n                    mostClickedPage = entry.getKey();\n                    maxClicks = entry.getValue();\n                }\n            }\n            recommendations.add(mostClickedPage);\n            userClickCount.remove(mostClickedPage);\n        }\n\n        return recommendations;\n    }\n}\n```",
  "1893": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(checkCovered(new int[][]{{1,2},{2,3},{2,5}})); // Expected: true\n        System.out.println(checkCovered(new int[][]{{1,10}})); // Expected: false\n        System.out.println(checkCovered(new int[][]{})); // Expected: true\n    }\n\n    public static boolean checkCovered(int[][] intervals) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] interval : intervals) {\n            for (int i = interval[0]; i <= interval[1]; i++) {\n                map.put(i, 1);\n            }\n        }\n        int max = map.keySet().stream()\n                .mapToInt(Integer::intValue)\n                .max()\n                .orElse(0);\n        return max == 0;\n    }\n}",
  "1895": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] grid1 = {{4, 9, 6}, {3, 5, 8}, {0, 7, 2}};\n        System.out.println(\"Largest magic square for grid1: \" + largestMagicSquare(grid1));\n\n        int[][] grid2 = {{10, 11, 12}, {13, 14, 15}, {16, 17, 18}};\n        System.out.println(\"Largest magic square for grid2: \" + largestMagicSquare(grid2));\n\n        int[][] grid3 = {{8, 3, 4}, {6, 1, 5}, {7, 2, 9}};\n        System.out.println(\"Largest magic square for grid3: \" + largestMagicSquare(grid3));\n    }\n\n    public static int largestMagicSquare(int[][] grid) {\n        // Your code here\n    }\n}\n```",
  "1894": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] chalkScores = new int[]{100,200,150};\n        System.out.println(\"Test case 1: Student that will replace the chalk is \" + findStudentThatWillReplaceTheChalk(chalkScores));\n        \n        int[] chalkScores2 = new int[]{90,80,70};\n        System.out.println(\"Test case 2: Student that will replace the chalk is \" + findStudentThatWillReplaceTheChalk(chalkScores2));\n\n        int[] chalkScores3 = new int[]{1000,1,2};\n        System.out.println(\"Test case 3: Student that will replace the chalk is \" + findStudentThatWillReplaceTheChalk(chalkScores3));\n    }\n\n    public static int findStudentThatWillReplaceTheChalk(int[] chalkScores) {\n        Arrays.sort(chalkScores);\n        \n        for (int i = 0; i < chalkScores.length - 1; i++) {\n            if (chalkScores[i] + chalkScores[i+1] <= chalkScores[chalkScores.length-1]) {\n                return i;\n            }\n        }\n        \n        return 0;\n    }\n}\n```",
  "1896": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minFlips(\"10101\")); // Expected output: 4\n        System.out.println(minFlips(\"100\")) ; // Expected output: 2\n        System.out.println(minFlips(\"0\"))   ; // Expected output: 0\n    }\n\n    public static int minFlips(String expression) {\n        // Your code here\n    }\n}\n```",
  "1897": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(new String[]{\"cooking\", \"cookbook\"}, new int[]{1, 1}));\n        System.out.println(canBeEqual(new String[]{\"cool\", \"lock\", \"cook\"}, new int[]{1, 2, 3}));\n        System.out.println(canBeEqual(new String[]{\"cool\", \"lock\", \"cook\", \"kook\", \"cook\"}, new int[]{1, 2, 3, 1, 1}));\n    }\n\n    public static boolean canBeEqual(String[] word1, int[] count) {\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i : count) {\n            for (char c = 'a'; c <= 'z'; c++) {\n                if (i == Character.getNumericValue(c)) {\n                    map.put(c, map.getOrDefault(c, 0) + i);\n                }\n            }\n        }\n\n        for (String s : word1) {\n            Map<Character, Integer> tempMap = new HashMap<>();\n            for (char c : s.toLowerCase().toCharArray()) {\n                tempMap.put(c, tempMap.getOrDefault(c, 0) + 1);\n            }\n            if (!map.equals(tempMap)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n```",
  "1898": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumRemovableCharacters(\"aab\")).equals(2));\n        System.out.println(maximumRemovableCharacters(\"azbazzaz\")).equals(4));\n        System.out.println(maximumRemovableCharacters(\"abcddcba\")).equals(3));\n    }\n\n    public static int maximumRemovableCharacters(String s) {\n        int n = s.length();\n        int ans = 0;\n        int left = 0, right = 0;\n        while (right < n) {\n            if (s.charAt(left) != s.charAt(right)) {\n                ans++;\n                left++;\n                right++;\n            } else {\n                if (s.charAt(left) == 'a') {\n                    left++;\n                    continue;\n                }\n                if (s.charAt(left) == 'b') {\n                    left++;\n                    right++;\n                    continue;\n                }\n                if (s.charAt(left) == 'c') {\n                    right++;\n                    continue;\n                }\n            }\n        }\n        return ans;\n    }\n}",
  "1899": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] triplets1 = {{1,4,10},{2,5,9},{3,6,8}};\n        System.out.println(Arrays.deepToString(merge(triplets1, 7)));\n\n        int[][] triplets2 = {{1,1,1},{1,2,3}};\n        System.out.println(Arrays.deepToString(merge(triplets2, 5)));\n\n        int[][] triplets3 = {{1,3,5},{6,8,10}};\n        System.out.println(Arrays.deepToString(merge(triplets3, 11)));\n    }\n\n    public static int[][] merge(int[][] triplets, int target) {\n        Arrays.sort(triplets, (a,b)-> Integer.compare(a[0], b[0]));\n        List<int[]> res = new ArrayList<>();\n        for(int[] triplet : triplets){\n            if(triplet[2] >= target){\n                break;\n            }\n            int[][] merged = merge(triplet);\n            res.add(merged[0]);\n        }\n        return res.toArray(new int[0][]);\n    }\n\n    public static int[][] merge(int[] triplet) {\n        List<int[]> res = new ArrayList<>();\n        for(int i = 0; i < 3; i++){\n            for(int j = i+1; j < 3; j++){\n                if(triplet[i] + triplet[j] <= triplet[2]){\n                    res.add(new int[]{triplet[i], triplet[j], triplet[2]});\n                }else{\n                    res.add(new int[]{triplet[i], triplet[j], triplet[0]+triplet[1]});\n                    break;\n                }\n            }\n        }\n        return res.toArray(new int[0][]);\n    }\n}\n```",
  "1900": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] rounds = {{2,1,17,10}, {2,11,23,10}, {8,5,24,8}};\n        for (int[] round : rounds) {\n            System.out.println(\"Earliest Round: \" + earliestRound(round[0], round[1], round[2]) +\n                    \", Latest Round: \" + latestRound(round[0], round[1], round[2]));\n        }\n    }\n\n    public static int earliestRound(int n, int min, int max) {\n        if (min == 1 && max == 3) return 1;\n        if (n <= 4) return 1;\n\n        boolean[][] memo = new boolean[n][max];\n        for (int i = 0; i < n; i++) {\n            memo[i][1] = true;\n        }\n\n        for (int i = 2; i <= max; i++) {\n            if (i > min) {\n                for (int j = i - 1; j >= i - n && j >= 1; j--) {\n                    memo[j][i] = memo[j - 1][i - 1] || memo[j][i - 1];\n                }\n            } else {\n                for (int j = 0; j < i && j <= min; j++) {\n                    memo[j][i] = true;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (!memo[i][max]) return max + 1;\n        }\n\n        return -1;\n    }\n\n    public static int latestRound(int n, int min, int max) {\n        if (min == 1 && max == 3) return 2;\n\n        boolean[][] memo = new boolean[n][max];\n        for (int i = 0; i < n; i++) {\n            memo[i][1] = true;\n        }\n\n        for (int i = 2; i <= max; i++) {\n            if (i > min) {\n                for (int j = i - 1; j >= i - n && j >= 1; j--) {\n                    memo[j][i] = memo[j - 1][i - 1] || memo[j][i - 1];\n                }\n            } else {\n                for (int j = 0; j < i && j <= min; j++) {\n                    memo[j][i] = true;\n                }\n            }\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (!memo[i][max]) return max + 1;\n        }\n\n        return -1;\n    }\n}",
  "1901": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{1,2,3},{4,5,6},{7,8,9}};\n        System.out.println(\"Test case 1: \" + findPeak(matrix1));\n\n        int[][] matrix2 = {{1,2},{3,4}};\n        System.out.println(\"Test case 2: \" + findPeak(matrix2));\n\n        int[][] matrix3 = {{1}};\n        System.out.println(\"Test case 3: \" + findPeak(matrix3));\n    }\n\n    public static int findPeak(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) return -1;\n        int n = matrix.length, m = matrix[0].length;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < m; ++j)\n                if ((i == 0 || matrix[i-1][j] <= matrix[i][j]) &&\n                   (i == n - 1 || matrix[i+1][j] <= matrix[i][j]) &&\n                   (j == 0 || matrix[i][j-1] <= matrix[i][j]) &&\n                   (j == m - 1 || matrix[i][j+1] <= matrix[i][j]))\n                    return i * m + j;\n        return -1;\n    }\n}",
  "1902": "```\nimport java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1:\");\n        List<Integer> order = Arrays.asList(8,6,7,9);\n        System.out.println(\"Expected output: 2\");\n        System.out.println(\"Actual output: \" + depthOfBST(order));\n        \n        System.out.println(\"\\nTest case 2:\");\n        order = Arrays.asList(3,1,-1,4,0,2);\n        System.out.println(\"Expected output: 5\");\n        System.out.println(\"Actual output: \" + depthOfBST(order));\n\n        System.out.println(\"\\nTest case 3:\");\n        order = Arrays.asList(2,1,5,7);\n        System.out.println(\"Expected output: 4\");\n        System.out.println(\"Actual output: \" + depthOfBST(order));\n    }\n\n    public static int depthOfBST(List<Integer> order) {\n        Map<Integer, Integer> inOrderMap = new HashMap<>();\n        for (int i = 0; i < order.size(); i++) {\n            inOrderMap.put(order.get(i), i);\n        }\n        \n        TreeNode root = null;\n        for (int num : order) {\n            root = insert(root, num, inOrderMap);\n        }\n\n        int maxDepth = getDepth(root);\n        return maxDepth;\n    }\n\n    public static TreeNode insert(TreeNode node, int val, Map<Integer, Integer> inOrderMap) {\n        if (node == null) {\n            return new TreeNode(val);\n        }\n        \n        int idx = inOrderMap.get(val);\n        if (val < node.val) {\n            node.left = insert(node.left, val, inOrderMap);\n        } else if (val > node.val) {\n            node.right = insert(node.right, val, inOrderMap);\n        } else {\n            // do nothing\n        }\n        \n        return node;\n    }\n\n    public static int getDepth(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        \n        return Math.max(getDepth(node.left), getDepth(node.right)) + 1;\n    }\n}",
  "1903": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(largestOddNumber(\"8 23 a-1 c4\"));\n        System.out.println(largestOddNumber(\"2 foo 15 bar 0 world\"));\n        System.out.println(largestOddNumber(\"2 4 6 7 9\"));\n    }\n\n    public static int largestOddNumber(String input) {\n        String[] numbers = input.split(\" \");\n        int maxOdd = -1;\n        for (String num : numbers) {\n            if (num.length() > 0 && Character.getNumericValue(num.charAt(0)) % 2 != 0) {\n                maxOdd = Math.max(maxOdd, Integer.parseInt(num));\n            }\n        }\n        return maxOdd;\n    }\n}",
  "1904": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findRounds(\"2267\")); // Expected output: 1\n        System.out.println(findRounds(\"1524413146\")); // Expected output: 4\n        System.out.println(findRounds(\"333\")); // Expected output: 0\n    }\n\n    public static int findRounds(String rounds) {\n        int count = 0;\n        for (int i = 0; i < rounds.length() - 1; i++) {\n            if ((rounds.charAt(i) - '0') * 2 + (rounds.charAt(i + 1) - '0') >= 10) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
  "1906": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] queries = {{1, 2}, {0, 4}};\n        System.out.println(minimumAbsoluteDifference(queries));\n        \n        queries = new int[][]{{1, 3}, {1, 4}, {2, 3}};\n        System.out.println(minimumAbsoluteDifference(queries));\n        \n        queries = new int[][]{{-5, -4}, {-7, -6}, {0, 1}};\n        System.out.println(minimumAbsoluteDifference(queries));\n    }\n\n    public static int minimumAbsoluteDifference(int[][] queries) {\n        int minDiff = Integer.MAX_VALUE;\n        for (int[] query : queries) {\n            int start = query[0];\n            int end = query[1];\n            int diff = Integer.MAX_VALUE;\n            for (int i = Math.min(start, end); i <= Math.max(start, end); i++) {\n                if (Math.abs(i - start) < diff) {\n                    diff = Math.abs(i - start);\n                }\n                if (Math.abs(i - end) < diff) {\n                    diff = Math.abs(i - end);\n                }\n            }\n            minDiff = Math.min(minDiff, diff);\n        }\n        return minDiff;\n    }\n}\n```",
  "1905": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {\n            {\"island\",\"island\",\"water\"],\n            {\"water\",\"water\",\"island\"},\n            {\"water\",\"water\",\"island\"}\n        };\n        int[][] islandGrid1 = {\n            {\"island\",\"island\"},\n            {\"island\",\"island\"}\n        };\n        System.out.println(countSubIslands(grid1, islandGrid1)); // Output: 1\n\n        int[][] grid2 = {\n            {\"water\",\"water\",\"island\"},\n            {\"water\",\"water\",\"island\"},\n            {\"island\",\"water\",\"island\"}\n        };\n        int[][] islandGrid2 = {\n            {\"island\",\"island\",\"island\"},\n            {\"water\",\"water\",\"island\"}\n        };\n        System.out.println(countSubIslands(grid2, islandGrid2)); // Output: 0\n\n        int[][] grid3 = {\n            {\"island\",\"water\",\"island\"},\n            {\"water\",\"island\",\"island\"},\n            {\"island\",\"island\",\"island\"}\n        };\n        int[][] islandGrid3 = {\n            {\"island\",\"island\",\"island\"},\n            {\"island\",\"island\",\"island\"}\n        };\n        System.out.println(countSubIslands(grid3, islandGrid3)); // Output: 1\n    }\n\n    public static int countSubIslands(int[][] grid, int[][] islandGrid) {\n        if (grid.length == 0 || grid[0].length == 0 || islandGrid.length == 0 || islandGrid[0].length == 0)\n            return 0;\n        \n        boolean[][] visited = new boolean[grid.length][grid[0].length];\n        int count = 0;\n\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (islandGrid[i][j] == 'island' && grid[i][j] == 'island') {\n                    DFS(i, j, visited, grid);\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    private static void DFS(int i, int j, boolean[][] visited, int[][] grid) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || visited[i][j] || grid[i][j] == 'water')\n            return;\n\n        visited[i][j] = true;\n        for (int k = -1; k <= 1; k++) {\n            for (int l = -1; l <= 1; l++) {\n                if (k == 0 && l == 0)\n                    continue;\n                int x = i + k;\n                int y = j + l;\n                if (x >= 0 && x < grid.length && y >= 0 && y < grid[0].length && visited[x][y] && grid[x][y] == 'island')\n                    DFS(x, y, visited, grid);\n            }\n        }\n    }\n}",
  "1908": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] piles = {{2,1,2},{1,3,4},{0,10,0}};\n        for (int i = 0; i < piles.length; i++) {\n            System.out.println(canWin(piles[i]));\n        }\n    }\n\n    public static boolean canWin(int[] piles) {\n        int n = piles.length;\n        for (int i = 0; i < n; i++) {\n            if ((piles[i] & 1) == 1 && (piles[i] - 1) % 4 != 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```",
  "1907": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] salary_info = {\n            {4000, 5000},\n            {3000, 6000},\n            {2000, 4500}\n        };\n        \n        System.out.println(\"Count of categories: \" + countCategories(salary_info));\n        \n        int[][] test1 = {\n            {10000, 15000},\n            {8000, 12000},\n            {7000, 11000}\n        };\n        System.out.println(\"Count of categories for Test1: \" + countCategories(test1));\n        \n        int[][] test2 = {\n            {2000, 4000},\n            {1000, 3000},\n            {1500, 3500}\n        };\n        System.out.println(\"Count of categories for Test2: \" + countCategories(test2));\n    }\n    \n    public static int countCategories(int[][] salary_info) {\n        Map<String, Integer> map = new HashMap<>();\n        \n        for (int[] info : salary_info) {\n            String category = getCategory(info[0], info[1]);\n            map.put(category, map.getOrDefault(category, 0) + 1);\n        }\n        \n        return map.values().size();\n    }\n    \n    public static String getCategory(int minSalary, int maxSalary) {\n        if (minSalary <= 20000 && maxSalary >= 40000) {\n            return \"CategoryA\";\n        } else if (minSalary > 20000 || maxSalary < 30000) {\n            return \"Other\";\n        } else {\n            return \"CategoryB\";\n        }\n    }\n}\n```",
  "1909": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeIncreasing(new int[]{1,2,3,4,5})); // Expected: true\n        System.out.println(canBeIncreasing(new int[]{1,3,2})); // Expected: false\n        System.out.println(canBeIncreasing(new int[]{1,2,3,5,4,6})); // Expected: true\n    }\n\n    public static boolean canBeIncreasing(int[] nums) {\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i] >= nums[i + 1]) {\n                if (i == 0 || nums[i - 1] <= nums[i]) {\n                    return true;\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "1910": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test Case 1: \");\n        removeOccurrences(\"hello\", \"lo\").forEach(System.out::print);\n        System.out.println();\n\n        System.out.println(\"Test Case 2: \");\n        removeOccurrences(\"abcdef\", \"cd\").forEach(System.out::print);\n        System.out.println();\n\n        System.out.println(\"Test Case 3: \");\n        removeOccurrences(\"abcd\", \"d\").forEach(System.out::print);\n        System.out.println();\n    }\n\n    public static void removeOccurrences(String s, String sub) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < s.length(); ) {\n            if (!s.substring(i).startsWith(sub)) {\n                result.append(s.charAt(i));\n                i++;\n            } else {\n                int j = i + sub.length() - 1;\n                while (j >= i) {\n                    i = j + 1;\n                    j -= 1;\n                }\n            }\n        }\n        System.out.println(result.toString());\n    }\n}",
  "1911": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumAlternatingSum(new int[]{4,2,5,1,3})); // Expected: 9\n        System.out.println(maximumAlternatingSum(new int[]{5,6,7})); // Expected: 12\n        System.out.println(maximumAlternatingSum(new int[]{-10,-20,0,10})); // Expected: 10\n    }\n\n    public static int maximumAlternatingSum(int[] nums) {\n        if (nums.length == 1) return nums[0];\n        int sum = Math.max(nums[0], 0);\n        for (int i = 1; i < nums.length - 1; i++) {\n            sum = Math.max(sum + (i % 2 == 0 ? -nums[i] : nums[i]), 0);\n        }\n        return sum + Math.max((nums.length % 2 == 0 ? -nums[nums.length - 1] : nums[nums.length - 1]), 0);\n    }\n}",
  "1912": "```\nimport java.util.*;\n\npublic class MovieRentalSystem {\n    private Map<String, Integer> movieStock;\n    private PriorityQueue<String> rentalQueue;\n\n    public MovieRentalSystem() {\n        this.movieStock = new HashMap<>();\n        this.rentalQueue = new PriorityQueue<>();\n    }\n\n    public void addMovie(String movie, int stock) {\n        this.movieStock.put(movie, stock);\n    }\n\n    public boolean rentMovie(String customer, String movie) {\n        if (!this.movieStock.containsKey(movie)) return false;\n        if (this.rentalQueue.contains(customer)) return true;\n\n        if (this.movieStock.get(movie) > 0) {\n            this.movieStock.put(movie, this.movieStock.get(movie) - 1);\n            this.rentalQueue.add(customer + \" \" + movie);\n            return true;\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        MovieRentalSystem system = new MovieRentalSystem();\n        system.addMovie(\"A\", 5);\n        system.addMovie(\"B\", 2);\n\n        System.out.println(system.rentMovie(\"John\", \"A\")); // true\n        System.out.println(system.rentMovie(\"Jane\", \"A\")); // false (no stock)\n        System.out.println(system.rentMovie(\"John\", \"B\")); // true",
  "1913": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {4,2,5,9};\n        System.out.println(\"Expected: \" + maxProductDifference(nums1) + \", Got: \" + maxProductDifference(nums1));\n        \n        int[] nums2 = {3,7,5};\n        System.out.println(\"Expected: \" + maxProductDifference(nums2) + \", Got: \" + maxProductDifference(nums2));\n\n        int[] nums3 = {10,4,8};\n        System.out.println(\"Expected: \" + maxProductDifference(nums3) + \", Got: \" + maxProductDifference(nums3));\n    }\n\n    public static int maxProductDifference(int[] nums) {\n        Arrays.sort(nums);\n        return (nums[nums.length - 1] - 1) * nums[0] - (nums[nums.length - 2] - 1) * nums[nums.length - 3];\n    }\n}",
  "1915": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfWonderfulSubstrings(\"abc\")); // Expected: 10\n        System.out.println(numberOfWonderfulSubstrings(\"aabaa\")); // Expected: 8\n        System.out.println(numberOfWonderfulSubstrings(\"aabb\")); // Expected: 4\n    }\n\n    public static int numberOfWonderfulSubstrings(String s) {\n        int res = 0;\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + 1; j <= s.length(); j++) {\n                String substr = s.substring(i, j);\n                if (isWonderful(substr)) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n\n    public static boolean isWonderful(String s) {\n        int[] count = new int[26];\n        for (int i = 0; i < s.length(); i++) {\n            count[s.charAt(i) - 'a']++;\n        }\n        for (int i = 0; i < 26; i++) {\n            if ((count[i] & 1) == 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
  "1914": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] grid1 = {\n            {1,2,3},\n            {4,5,6},\n            {7,8,9}\n        };\n        rotateGrid(grid1);\n        \n        int[][] grid2 = {\n            {5,6},\n            {7,0,8,9}\n        };\n        rotateGrid(grid2);\n        \n        int[][] grid3 = {\n            {1}\n        };\n        rotateGrid(grid3);\n    }\n\n    public static void rotateGrid(int[][] grid) {\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                System.out.print(grid[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}",
  "1916": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countWays(7, new int[]{0,1,5}, new int[]{8,9,10})); // Test case 1\n        System.out.println(countWays(4, new int[]{0,2,3}, new int[]{1,3,4})); // Test case 2\n        System.out.println(countWays(6, new int[]{0,1,2,3}, new int[]{4,5,6,7})); // Test case 3\n    }\n\n    public static int countWays(int n, int[] connections, int[] lengths) {\n        // Your code here\n    }\n}\n```",
  "1917": "```\npublic class Solution {\n    public List<List<String>> tableIntersection(int n, int low1, int high1, int low2, int high2) {\n        // Your implementation here\n        // For this problem we assume that you will get the intersection of two tables with n rows.\n        // The first table has columns [id1, id2], and the second table has columns [id3, id4].\n        // The problem asks to find all pairs (id1, id2) where id1 is in range [low1, high1] and id2 is in range [low2, high2].\n\n        List<List<String>> result = new ArrayList<>();\n        for (int i = low1; i <= high1; i++) {\n            for (int j = low2; j <= high2; j++) {\n                List<String> pair = new ArrayList<>();\n                pair.add(String.valueOf(i));\n                pair.add(String.valueOf(j));\n                result.add(new ArrayList<>(pair));\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int n = 5;\n        int low1 = 0, high1 = 2;\n        int low2 = 0, high2 = 3;\n        List<List<String>> expected = solution.tableIntersection(n, low1, high1, low2, high2);\n        \n        // Test case 1\n        System.out.println(\"Test case 1:\");\n        for (List<String> pair : expected) {\n            System.out.println(pair);\n        }\n        \n        n = 3;\n        low1 = 0; high1 = 1;\n        low2 = 1; high2 = 2;\n        expected = solution.tableIntersection(n, low1, high1, low2, high2);\n        \n        // Test case 2\n        System.out.println(\"\\nTest case 2:\");\n        for (List<String> pair : expected) {\n            System.out.println(pair);\n        }\n        \n        n = 2;\n        low1 = 0; high1 = 0;\n        low2 = 0; high2 = 0;\n        expected = solution.tableIntersection(n, low1, high1, low2, high2);\n        \n        // Test case 3\n        System.out.println(\"\\nTest case 3:\");\n        for (List<String> pair : expected) {\n            System.out.println(pair);\n        }\n    }\n}",
  "1918": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(kthSmallestSubarraySum(new int[]{2,1,3}, 3, 4)); // Expected output: 7\n        System.out.println(kthSmallestSubarraySum(new int[]{1,2,3}, 1, 2)); // Expected output: 1\n        System.out.println(kthSmallestSubarraySum(new int[]{1,5,5}, 2, 1)); // Expected output: 5\n    }\n\n    public static int kthSmallestSubarraySum(int[] nums, int k, int t) {\n        int left = 0;\n        int right = (int)Math.pow(10, 9);\n        while (right - left > 1e-6) {\n            int mid = (left + right) / 2.0;\n            long sum = 0;\n            int count = 0;\n            for (int i = 0; i < nums.length; i++) {\n                sum += Math.min(mid, (long)nums[i]);\n                if (sum > t) break;\n                count++;\n            }\n            if (count >= k) right = mid;\n            else left = mid;\n        }\n        return (int)right;\n    }\n}",
  "1919": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(findSimilarFriends(\"Meng\", \"Jiong\") + \", \");\n        System.out.println(findSimilarFriends(\"Erick Yuan\", \"Eric Yuan\") + \", \");\n        System.out.println(findSimilarFriends(\"LeetCode\", \"CodeForce\"));\n    }\n\n    public static String findSimilarFriends(String person1, String person2) {\n        // Your solution here\n    }\n}\n```",
  "1920": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] original = {{4, 2}, {1, 3}};\n        for (int[] p : original) {\n            int n = p.length;\n            int[] arr = buildArray(p);\n            for (int i = 0; i < n; i++) {\n                System.out.print(arr[i] + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    public static int[] buildArray(int[] nums) {\n        int n = nums.length;\n        int[] ans = new int[n];\n        for (int i = 0; i < n; i++) {\n            ans[nums[i]] = i;\n        }\n        return ans;\n    }\n}",
  "1922": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(countGoodNumbers(15)); // Expected output: 5\n        System.out.println(countGoodNumbers(32)); // Expected output: 8\n        System.out.println(countGoodNumbers(1000000000)); // Expected output: 74903803\n    }\n\n    public static int countGoodNumbers(int n) {\n        return dfs(n, 0);\n    }\n\n    private static int dfs(int n, int pos) {\n        if (pos == 4) {\n            if ((n % 10) * (n / 10 % 10) * (n / 100 % 10) != 0) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n        int res = 0;\n        for (int i = 0; i <= 9; i++) {\n            if ((i == 0 && pos > 1) || (pos % 2 != 0 && i * 10 + n % 10 >= n / 100)) {\n                res += dfs(n / 10, pos + 1);\n            }\n        }\n        return res;\n    }\n}\n```",
  "1921": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] strength = {{2, 7}, {1, 17}, {18, 9}};\n        System.out.println(\"Maximum number of monsters that can be eliminated: \" + eliminateMaxMonsters(strength));\n        \n        strength = new int[][]{{4, 12}, {3, 8}, {10, 6}};\n        System.out.println(\"Maximum number of monsters that can be eliminated: \" + eliminateMaxMonsters(strength));\n\n        strength = new int[][]{{1, 2}, {5, 3}};\n        System.out.println(\"Maximum number of monsters that can be eliminated: \" + eliminateMaxMonsters(strength));\n    }\n\n    public static int eliminateMaxMonsters(int[][] strength) {\n        Arrays.sort(strength, (a, b) -> Integer.compare(b[1], a[1]));\n        \n        int maxEliminated = 0;\n        for (int i = 0; i < strength.length; i++) {\n            if (i == 0 || strength[i][0] > strength[i - 1][1]) {\n                maxEliminated++;\n            } else {\n                break;\n            }\n        }\n        \n        return maxEliminated;\n    }\n}\n```",
  "1923": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] path1 = {{1,2}, {2,3}, {4,5}};\n        int[][] path2 = {{1,2,3}, {2,3,4}, {3,4,5}};\n        System.out.println(longestCommonSubpath(path1, path2));\n        \n        int[][] path3 = {{1, 2}, {2, 3}, {3, 4}};\n        int[][] path4 = {{1, 2}, {2, 3}, {3, 4}, {4, 5}};\n        System.out.println(longestCommonSubpath(path3, path4));\n        \n        int[][] path5 = {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}};\n        int[][] path6 = {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {4, 5, 6}};\n        System.out.println(longestCommonSubpath(path5, path6));\n    }\n\n    public static String longestCommonSubpath(int[][] path1, int[][] path2) {\n        // Your code here\n    }\n}\n```",
  "1924": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(encode(\"Hello\")); // Test case 1\n        System.out.println(encode(\"Apple pen\")); // Test case 2\n        System.out.println(encode(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\")); // Test case 3\n    }\n\n    public static int[] encode(String S) {\n        // Your code here\n        return new int[]{0, 1};\n    }\n}\n```",
  "1925": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countGoodTriplets(new int[]{2,3,4,5}, 1));\n        System.out.println(countGoodTriplets(new int[]{0,1,1,2,3,3,4,5}, 16));\n        System.out.println(countGoodTriplets(new int[]{5,6,7,8,9}, 23));\n    }\n\n    public static int countGoodTriplets(int[] roots, int val) {\n        int count = 0;\n        for (int i = 0; i < roots.length; i++) {\n            for (int j = i + 1; j < roots.length; j++) {\n                for (int k = j + 1; k < roots.length; k++) {\n                    if ((roots[i] * roots[i] + roots[j] * roots[j] + roots[k] * roots[k]) == val) {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}\n```",
  "1927": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumGame(\"1026\")); // Expected output: 9\n        System.out.println(sumGame(\"632098103\")); // Expected output: 18\n        System.out.println(sumGame(\"6543\")); // Expected output: 4\n    }\n\n    public static int sumGame(String num) {\n        int n = num.length();\n        if (n % 2 == 0) {\n            return (num.charAt(n / 2 - 1) - '0') * 2;\n        } else {\n            char c1 = num.charAt(0), c2 = num.charAt((n + 1) / 2);\n            return Math.abs(c1 - c2) * 2;\n        }\n    }\n}",
  "1926": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] maze = {{0,0,1},{0,1,0},{0,1,0},{0,1,2}};\n        System.out.println(nearestExit(maze, 0, 0));\n        \n        maze = new int[][]{{0,0,1},{0,1,0},{1,1,0},{1,1,0},{1,1,2}};\n        System.out.println(nearestExit(maze, 0, 0));\n        \n        maze = new int[][]{{0,0,0},{1,1,0},{6,1,0},{1,1,2}};\n        System.out.println(nearestExit(maze, 31, 100));\n    }\n    \n    public static int nearestExit(int[][] maze, int x, int y) {\n        int rows = maze.length;\n        int cols = maze[0].length;\n        \n        boolean[][] visited = new boolean[rows][cols];\n        ArrayDeque<int[]> queue = new ArrayDeque<>();\n        queue.add(new int[]{x, y});\n        visited[x][y] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            x = curr[0]; y = curr[1];\n            \n            if (x == 0 || x == rows - 1 || y == 0 || y == cols - 1) {\n                return Math.max(Math.abs(0 - x), Math.abs(0 - y)) + Math.max(Math.abs(0 - y), Math.abs(0 - cols));\n            }\n            \n            for (int[] dir : new int[][]{{-1,0},{1,0},{0,-1},{0,1}}) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n                \n                if (newX >= 0 && newX < rows && newY >= 0 && newY < cols \n                        && maze[newX][newY] == 0 && !visited[newX][newY]) {\n                    queue.add(new int[]{newX, newY});\n                    visited[newX][newY] = true;\n                }\n            }\n        }\n        \n        return -1;\n    }\n}\n```",
  "1928": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] flights = {{2,1,10},{4,5,35},{6,7,15}};\n        System.out.println(minCostToReachDestination(flights, 8));\n        \n        int[][] flights2 = {{0,1,5},{1,2,5},{2,3,10},{4,5,20},{5,6,30},{6,100,100}};\n        System.out.println(minCostToReachDestination(flights2, 15));\n        \n        int[][] flights3 = {{0,1,1},{1,2,5},{2,3,10}};\n        System.out.println(minCostToReachDestination(flights3, 4));\n    }\n\n    public static int minCostToReachDestination(int[][] flights, int target) {\n        int n = flights.length;\n        int[] dp = new int[n];\n        for (int i = 0; i < n; i++) {\n            dp[i] = Integer.MAX_VALUE;\n        }\n        dp[0] = 0;\n\n        for (int i = 1; i < n; i++) {\n            for (j = 0; j < i; j++) {\n                if (flights[j][2] <= target - (i - j)) {\n                    dp[i] = Math.min(dp[i], dp[j] + flights[j][2]);\n                }\n            }\n        }\n\n        return dp[n-1];\n    }\n}",
  "1929": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrays = {{1, 2}, {3, 4, 5}};\n        System.out.println(arrayConcat(arrays));\n        \n        arrays = new int[][]{{1, 2, 3}, {}};\n        System.out.println(arrayConcat(arrays));\n\n        arrays = new int[][]{{1, 2, 3, 4}, {5, 6}};\n        System.out.println(arrayConcat(arrays));\n    }\n\n    public static String arrayConcat(int[][] arrays) {\n        StringBuilder sb = new StringBuilder();\n        for (int[] array : arrays) {\n            for (int num : array) {\n                sb.append(num).append(\",\");\n            }\n            if (!arrays.equals(arrays)) {\n                sb.deleteCharAt(sb.length() - 1);\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "1930": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(uniqueLengthThreePalindromicSubsequences(\"abaab\")); // expected output: 4\n        System.out.println(uniqueLengthThreePalindromicSubsequences(\"adc\")); // expected output: 1\n        System.out.println(uniqueLengthThreePalindromicSubsequences(\"baab\")); // expected output: 2\n    }\n\n    public static int uniqueLengthThreePalindromicSubsequences(String s) {\n        // Your code here\n    }\n}",
  "1931": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minStrokes(new int[][]{{1, 1, 1}, {2, 1, 1}})); // Test case 1\n        System.out.println(minStrokes(new int[][]{{3, 5, 4}, {2, 3, 5}, {5, 2, 3}})); // Test case 2\n        System.out.println(minStrokes(new int[][]{{0, 0, 0}, {1, 0, 1}, {1, 1, 0}})); // Test case 3\n\n    }\n\n    public static int minStrokes(int[][] grid) {\n        int m = grid.length;\n        if (m == 0) return 0;\n\n        int n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        int[] dx = {-1, 0, 1};\n        int[] dy = {0, -1, 0};\n\n        class State {\n            int x;\n            int y;\n            int color;\n\n            public State(int x, int y, int color) {\n                this.x = x;\n                this.y = y;\n                this.color = color;\n            }\n        }\n\n        class Queue {\n            List<State> states = new ArrayList<>();\n\n            void enqueue(State state) {\n                states.add(state);\n            }\n\n            boolean dequeue() {\n                if (states.isEmpty()) return false;\n                State state = states.get(0);\n                states.remove(0);\n                return true;\n            }\n\n            boolean hasElements() {\n                return !states.isEmpty();\n            }\n        }\n\n        Queue queue = new Queue();\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    queue.enqueue(new State(i, j, grid[i][j]));\n                }\n            }\n        }\n\n        int strokes = 0;\n        while (queue.hasElements()) {\n            State state = queue.dequeue();\n            if (!visited[state.x][state.y]) {\n                visited[state.x][state.y] = true;\n\n                for (int k = 0; k < 3; k++) {\n                    for (int l = 0; l < 3; l++) {\n                        int newX = state.x + dx[k];\n                        int newY = state.y + dy[l];\n\n                        if (newX >= 0 && newX < m && newY >= 0 && newY < n) {\n                            if (!visited[newX][newY]) {\n                                if ((k == 1 || l == 1) || (k == 2 && l == 0) || (k == 0 && l == 2)) {\n                                    queue.enqueue(new State(newX, newY, grid[newX][newY]));\n                                } else {\n                                    strokes++;\n                                    queue.enqueue(new State(newX, newY, 3 - grid[newX][newY]));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return strokes;\n    }\n}\n```",
  "1932": "```\npublic class Main {\n    public static void main(String[] args) {\n        TreeNode root1 = new TreeNode(4);\n        root1.left = new TreeNode(2);\n        root1.right = new TreeNode(6);\n        root1.left.left = new TreeNode(1);\n        root1.left.right = new TreeNode(3);\n\n        TreeNode root2 = new TreeNode(5);\n        root2.left = new TreeNode(3);\n        root2.right = new TreeNode(7);\n\n        TreeNode mergedRoot = mergeTrees(root1, root2);\n\n        System.out.println(\"Merged BST:\");\n        printTree(mergedRoot);\n    }\n\n    public static TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) return null;\n        if (t1 == null) return t2;\n        if (t2 == null) return t1;\n\n        int val = t1.val + t2.val;\n        boolean isOdd = (val % 2 != 0);\n\n        TreeNode root = new TreeNode(val);\n        if (isOdd) {\n            root.left = mergeTrees(t1.right, t2.right);\n            root.right = mergeTrees(t1, t2.left);\n        } else {\n            root.left = mergeTrees(t1.left, t2.left);\n            root.right = mergeTrees(t1.right, t2.right);\n        }\n\n        return root;\n    }\n\n    public static void printTree(TreeNode node) {\n        if (node == null) return;\n\n        System.out.print(node.val + \" \");\n        printTree(node.left);\n        printTree(node.right);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int x) { val = x; }\n}\n```",
  "1933": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canBeDecomposed(\"a1b2c3\", true)); // Expected: true\n        System.out.println(canBeDecomposed(\"leetcode\", false)); // Expected: false\n        System.out.println(canBeDecomposed(\"cool\", true)); // Expected: true\n    }\n\n    public static boolean canBeDecomposed(String s, boolean checkIfAllEqual) {\n        if (s == null || s.isEmpty()) return true;\n\n        StringBuilder sb = new StringBuilder();\n        int count = 1;\n        for (int i = 1; i <= s.length(); i++) {\n            if (i < s.length() && s.charAt(i - 1) == s.charAt(i)) {\n                count++;\n            } else {\n                if (checkIfAllEqual && count > 2) return false;\n                sb.append(s.substring(i - count, i));\n                count = 1;\n            }\n        }\n\n        return true;\n    }\n}",
  "1934": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + getConfirmationRate(new int[]{0, 1, 0, 1}, new int[]{1, 1, 0, 1}) + \"\\n\");\n        System.out.println(\"Test case 2: \" + getConfirmationRate(new int[]{1, 1}, new int[]{1, 1}) + \"\\n\");\n        System.out.println(\"Test case 3: \" + getConfirmationRate(new int[]{0, 0}, new int[]{0, 0}) + \"\\n\");\n\n    }\n\n    public static double getConfirmationRate(int[] purchases, int[] rates) {\n        if (purchases.length != rates.length) {\n            return -1.0;\n        }\n        int totalPurchases = 0, totalRates = 0;\n        for (int i = 0; i < purchases.length; i++) {\n            if (purchases[i] == 1) {\n                totalPurchases++;\n                if (rates[i] == 1) {\n                    totalRates++;\n                }\n            }\n        }\n        return (double) totalRates / totalPurchases;\n    }\n}\n```",
  "1935": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxWordsTyped(\"Hello world\", new String[]{\"apple\", \"banana\", \"orange\"}, new int[]{5, 10, 15}) == 6);\n        System.out.println(maxWordsTyped(\"LeetCode is the best\", new String[]{\"apple\", \"banana\", \"orange\"}, new int[]{5, 10, 15}) == 7);\n        System.out.println(maxWordsTyped(\"\", new String[]{\"apple\", \"banana\", \"orange\"}, new int[]{5, 10, 15}) == 0);\n    }\n\n    public static int maxWordsTyped(String typed, String[] dictionary, int[] times) {\n        int max = 0;\n        for (String word : dictionary) {\n            if (typed.indexOf(word) != -1 && (max < times[dictionary.indexOf(word)])) {\n                max = times[dictionary.indexOf(word)];\n            }\n        }\n        return max;\n    }\n}\n```",
  "1936": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minRungs(new int[]{1,2,4,6}, 8)); // Expected: 1\n        System.out.println(minRungs(new int[]{3,5,7,9}, 12)); // Expected: 3\n        System.out.println(minRungs(new int[]{1,5,10}, 15)); // Expected: 2\n    }\n\n    public static int minRungs(int[] obstacles, int start) {\n        Arrays.sort(obstacles);\n        int rungs = 0;\n        for (int i = 1; i < obstacles.length; i++) {\n            if (obstacles[i] - obstacles[i-1] > 1) {\n                rungs += obstacles[i] - obstacles[i-1] - 1;\n            }\n        }\n        return rungs + Math.max(0, start - obstacles[0]);\n    }\n}",
  "1938": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] queries = {\n                {5, \"aba\"}, {6, \"caa\"}, {7, \"cba\"}\n            };\n        System.out.println(maximumGeneticDifference(queries));\n        \n        queries = new int[][]{\n                {1, \"ggtgg\"}, {2, \"ggtttt\"}, {3, \"ttggb\"}\n            };\n        System.out.println(maximumGeneticDifference(queries));\n        \n        queries = new int[][]{\n                {0, \"aa\"}, {1, \"ab\"}, {2, \"bb\"}\n            };\n        System.out.println(maximumGeneticDifference(queries));\n    }\n\n    public static int maximumGeneticDifference(int[][] genes) {\n        // write your solution here\n        return 0;\n    }\n}\n```",
  "1937": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] points = new int[][]{\n                {9,3},\n                {1,1},\n                {0,0}\n            };\n        System.out.println(\"Maximum number of points with cost is: \" + maxPoints(points));\n\n        points = new int[][]{\n                {7,6,2},\n                {1,1,4},\n                {8,1,6}\n            };\n        System.out.println(\"Maximum number of points with cost is: \" + maxPoints(points));\n\n        points = new int[][]{\n                {3,1},\n                {5,0},\n                {4,2},\n                {7,5},\n                {2,4}\n            };\n        System.out.println(\"Maximum number of points with cost is: \" + maxPoints(points));\n    }\n\n    public static int maxPoints(int[][] points) {\n        // Your code here\n    }\n}",
  "1939": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<Integer> activeManager(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if ((i & 1) == 0) {\n                result.add(i);\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test case 1\n        int n1 = 5;\n        List<Integer> expected1 = Arrays.asList(2, 4);\n        System.out.println(\"Expected: \" + expected1.toString());\n        System.out.println(\"Actual: \" + solution.activeManager(n1).toString());\n        System.out.println();\n        \n        // Test case 2\n        int n2 = 10;\n        List<Integer> expected2 = Arrays.asList(2, 4, 6, 8);\n        System.out.println(\"Expected: \" + expected2.toString());\n        System.out.println(\"Actual: \" + solution.activeManager(n2).toString());\n        System.out.println();\n        \n        // Test case 3\n        int n3 = 15;\n        List<Integer> expected3 = Arrays.asList(2, 4, 6, 8, 10, 12);\n        System.out.println(\"Expected: \" + expected3.toString());\n        System.out.println(\"Actual: \" + solution.activeManager(n3).toString());\n        System.out.println();\n    }\n}",
  "1940": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(longestCommonSubsequence(new int[]{1, 2, 5}, new int[]{3, 4, 7}, 2).length);\n        System.out.println(longestCommonSubsequence(new int[]{10, 20, 30}, new int[]{40, 50, 60}, 3).length);\n        System.out.println(longestCommonSubsequence(new int[]{1, 2, 3, 5, 6, 7}, new int[]{5, 6, 7, 8, 9, 10}, 6).length);\n    }\n\n    public static String longestCommonSubsequence(int[] A, int[] B, int M) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < M && i < A.length && i < B.length; ) {\n            if (A[i] == B[i]) {\n                sb.append(A[i]);\n                i++;\n            } else if (A[i] < B[i]) {\n                i++;\n            } else {\n                break;\n            }\n        }\n        return sb.toString();\n    }\n}\n```",
  "1941": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeEqual(\"abc\", \"cba\")); // Expected: true\n        System.out.println(canBeEqual(\"abac\", \"baca\")); // Expected: false\n        System.out.println(canBeEqual(\"aaa\", \"bbb\")); // Expected: false\n    }\n\n    public static boolean canBeEqual(String word1, String word2) {\n        if (word1.length() != word2.length()) {\n            return false;\n        }\n        int[] count = new int[26];\n        for (int i = 0; i < word1.length(); i++) {\n            count[word1.charAt(i) - 'a']++;\n            count[word2.charAt(i) - 'a']++;\n        }\n        for (int i : count) {\n            if (i != word1.length()) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1942": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(numberOfUnoccupiedChairs(new int[][]{{1,2},{3,5},{4,6}})); // Test Case 1: Expected output is 1\n        System.out.println(numberOfUnoccupiedChairs(new int[][]{{0,1},{2,3}})); // Test Case 2: Expected output is 2\n        System.out.println(numberOfUnoccupiedChairs(new int[][]{})); // Test Case 3: Expected output is 4\n    }\n\n    public static int numberOfUnoccupiedChairs(int[][] seats) {\n        Map<Integer, Integer> chairMap = new HashMap<>();\n        for (int i = 0; i < seats.length; i++) {\n            for (int j = seats[i][0]; j <= seats[i][1]; j++) {\n                chairMap.put(j, chairMap.getOrDefault(j, 0) + 1);\n            }\n        }\n\n        int unoccupiedChairs = 0;\n        for (int i = 0; i < chairs.length(); i++) {\n            if (!chairMap.containsKey(i)) {\n                unoccupiedChairs++;\n            } else if (chairMap.get(i) == 1) {\n                unoccupiedChairs++;\n            }\n        }\n\n        return unoccupiedChairs;\n    }\n}\n```",
  "1943": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] painting = {{1,1,1},{2,3,2},{3,4,3}};\n        System.out.println(\"Expected: [[0,0,0],[1,1,2],[3,5,6]]\");\n        System.out.println(Arrays.deepToString(describePainting(painting)));\n\n        painting = new int[][]{{1, 1}, {3, 3}, {5, 5}};\n        System.out.println(\"Expected: [[0,0],[0,2],[2,4]]\");\n        System.out.println(Arrays.deepToString(describePainting(painting)));\n\n        painting = new int[][]{{1, 6, 10, 4, 7}, {3, 5, 8, 9, 11}};\n        System.out.println(\"Expected: [[0,2,2,0,2],[2,4,5,3,4]]\");\n        System.out.println(Arrays.deepToString(describePainting(painting)));\n    }\n\n    public static int[][] describePainting(int[][] painting) {\n        int n = painting.length;\n        int m = painting[0].length;\n        int[][] result = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == 0) {\n                    result[i][j] = painting[i][j];\n                } else {\n                    result[i][j] = Math.max(result[i - 1][j], painting[i][j]);\n                }\n            }\n        }\n        return result;\n    }\n}\n```",
  "1944": "```\npublic class Main {\n    public static void main(String[] args) {\n        int result1 = visiblePeople(new int[]{12, 4, 8, 2}, 5);\n        System.out.println(\"Test case 1: \" + result1);\n\n        int result2 = visiblePeople(new int[]{7,6,2}, 4);\n        System.out.println(\"Test case 2: \" + result2);\n\n        int result3 = visiblePeople(new int[]{9,8,7,6,5,4,3,2,1}, 10);\n        System.out.println(\"Test case 3: \" + result3);\n    }\n\n    public static int visiblePeople(int[] heights, int n) {\n        Stack<Integer> stack = new Stack<>();\n        int visibleCount = 0;\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && stack.peek() <= heights[i]) {\n                stack.pop();\n            }\n            if (stack.isEmpty()) {\n                visibleCount++;\n            } else {\n                visibleCount += stack.size() + 1;\n            }\n            stack.push(heights[i]);\n        }\n        return visibleCount;\n    }\n}\n```",
  "1945": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(sumOfDigits(\"32\")); // expected output: 5\n        System.out.println(sumOfDigits(\"10563\")); // expected output: 11\n        System.out.println(sumOfDigits(\"2511241\")); // expected output: 13\n    }\n\n    public static int sumOfDigits(String s) {\n        int sum = 0;\n        for (char c : s.toCharArray()) {\n            sum += Character.getNumericValue(c);\n        }\n        return sum;\n    }\n}",
  "1946": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(maximumNumber(\"10234\", \"9\")); // expected output: \"123456789\"\n        System.out.println(maximumNumber(\"0000\", \"1\")); // expected output: \"10101010\"\n        System.out.println(maximumNumber(\"12\", \"3\")); // expected output: \"132\"\n    }\n\n    public static String maximumNumber(String num, String digit) {\n        int len = num.length();\n        StringBuilder sb = new StringBuilder(len);\n        int carry = 0;\n        for (int i = len - 1; i >= 0; --i) {\n            int n = num.charAt(i) - '0';\n            if (n > 0) {\n                n += carry;\n                if (n >= 10) {\n                    sb.insert(0, \"9\");\n                    carry = 1;\n                } else {\n                    sb.insert(0, n);\n                    carry = 0;\n                }\n            } else {\n                sb.insert(0, '0');\n                carry = 0;\n            }\n        }\n        if (carry > 0) {\n            sb.insert(0, \"1\");\n        }\n        return sb.toString();\n    }\n}",
  "1947": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] profiles = {{1,1}, {0,1}, {1,0}};\n        System.out.println(maxCompatibilitySum(profiles));\n        \n        int[][] profiles2 = {{0,0}, {0,0}, {1,0}};\n        System.out.println(maxCompatibilitySum(profiles2));\n        \n        int[][] profiles3 = {{1,1}, {0,1}, {1,1}};\n        System.out.println(maxCompatibilitySum(profiles3));\n    }\n\n    public static int maxCompatibilitySum(int[][] students) {\n        int n = students.length;\n        int[] compatibleWith = new int[n];\n        for (int i = 0; i < n; i++) {\n            int maxScore = -1;\n            for (int j = 0; j < n; j++) {\n                if (i != j) {\n                    int score = 0;\n                    for (int k = 0; k < students[0].length; k++) {\n                        if ((students[i][k] & students[j][k]) == students[i][k]) {\n                            score++;\n                        }\n                    }\n                    maxScore = Math.max(maxScore, score);\n                }\n            }\n            compatibleWith[i] = maxScore;\n        }\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += students[i][compatibleWith[i]];\n        }\n        return sum;\n    }\n}",
  "1948": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \");\n        String[] folder = { \"root/a\", \"root/c\", \"root/d\" };\n        deleteDuplicateFolder(folder);\n        System.out.println();\n\n        System.out.println(\"Test case 2: \");\n        folder = new String[]{\"/a/b/c\", \"/d\",\"/a/b/g\", \"/a\"};\n        deleteDuplicateFolder(folder);\n        System.out.println();\n\n        System.out.println(\"Test case 3: \");\n        folder = new String[]{};\n        deleteDuplicateFolder(folder);\n        System.out.println();\n    }\n\n    public static void deleteDuplicateFolder(String[] folder) {\n        // Your solution here\n    }\n}\n```",
  "1949": "```\nimport java.util.*;\n\npublic class Solution {\n    public List<List<String>> strongFriendship(int n, int[][] friendships) {\n        Map<Integer, List<String>> graph = new HashMap<>();\n        for (int[] friendship : friendships) {\n            graph.computeIfAbsent(friendship[0], k -> new ArrayList<>()).add(String.valueOf(friendship[1]));\n            graph.computeIfAbsent(friendship[1], k -> new ArrayList<>()).add(String.valueOf(friendship[0]));\n        }\n        \n        List<List<String>> result = new ArrayList<>();\n        for (Map.Entry<Integer, List<String>> entry : graph.entrySet()) {\n            if (entry.getValue().size() > 1) {\n                result.add(new ArrayList<>(Arrays.asList(entry.getKey(), entry.getValue())));\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n1 = 3;\n        int[][] friendships1 = {{1, 2}, {1, 3}};\n        System.out.println(\"Test case 1: \" + solution.strongFriendship(n1, friendships1));\n\n        int n2 = 4;\n        int[][] friendships2 = {{1, 2}, {1, 3}, {2, 3}};\n        System.out.println(\"Test case 2: \" + solution.strongFriendship(n2, friendships2));\n\n        int n3 = 5;\n        int[][] friendships3 = {{1, 2}, {1, 3}, {2, 3}, {4, 5}};\n        System.out.println(\"Test case 3: \" + solution.strongFriendship(n3, friendships3));\n    }\n}",
  "1950": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maximumSumEvenlySpaced(new int[]{2, 2, 2, 2, 3, 4, 4})); // Expected: 2\n        System.out.println(maximumSumEvenlySpaced(new int[]{1, 2, 3, 2, 1, 2, 1, 2, 1, 1})); // Expected: 1\n        System.out.println(maximumSumEvenlySpaced(new int[]{7, 8, 9, 6, 5, 4, 3, 2, 1})); // Expected: 1\n    }\n\n    public static int maximumSumEvenlySpaced(int[] arr) {\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < arr.length; i++) {\n            int minVal = arr[i];\n            int sum = 0;\n            for (int j = i; j < arr.length; j++) {\n                minVal = Math.min(minVal, arr[j]);\n                sum += minVal;\n            }\n            max = Math.max(max, sum);\n        }\n        return max;\n    }\n}",
  "1951": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] pairs = {{1,2},{2,3},{5,4},{1,3}};\n        int result = findMaxNumberCommonFollowers(pairs);\n        System.out.println(result);\n\n        int[][] pairs2 = {{1,2},{2,3},{2,4},{3,4},{5,6},{7,8}};\n        result = findMaxNumberCommonFollowers(pairs2);\n        System.out.println(result);\n\n        int[][] pairs3 = {{1,2},{2,1},{1,3},{3,1},{4,5}};\n        result = findMaxNumberCommonFollowers(pairs3);\n        System.out.println(result);\n    }\n\n    public static int findMaxNumberCommonFollowers(int[][] pairs) {\n        // your code here\n    }\n}",
  "1952": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(threeDivisors(10) == true ? \"Pass\" : \"Fail\");\n        System.out.println(threeDivisors(7) == false ? \"Pass\" : \"Fail\");\n        System.out.println(threeDivisors(25) == true ? \"Pass\" : \"Fail\");\n    }\n\n    public static boolean threeDivisors(int n) {\n        for (int i = 1; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                int j = n / i;\n                if (j * j == i && isPrime(j)) return true;\n            }\n        }\n        return false;\n    }\n\n    public static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n}\n```",
  "1954": "```\npublic class Main {\n    public static void main(String[] args) {\n        int minPerimeter = new Solution().minEave(7);\n        System.out.println(\"Test Case 1: \" + minPerimeter); // Expected output: 4\n\n        minPerimeter = new Solution().minEave(11);\n        System.out.println(\"Test Case 2: \" + minPerimeter); // Expected output: 8\n\n        minPerimeter = new Solution().minEave(17);\n        System.out.println(\"Test Case 3: \" + minPerimeter); // Expected output: 10\n    }\n}\n```",
  "1953": "```\npublic class Main {\n    public static void main(String[] args) {\n        int maxWeeks = workDays(new int[]{5,2,1}, new int[]{8,10,6});\n        System.out.println(maxWeeks);\n\n        maxWeeks = workDays(new int[]{3,2,4,4,1,4,3}, new int[]{20,30,40,50,15,30,10});\n        System.out.println(maxWeeks);\n\n        maxWeeks = workDays(new int[]{5,7,6,8,9}, new int[]{23,13,21,24,27});\n        System.out.println(maxWeeks);\n    }\n\n    public static int workDays(int[] w, int[] d) {\n        Arrays.sort(d);\n        int weeks = 0;\n        for (int i = 0; i < d.length; i++) {\n            while (d[i] > w[weeks]) {\n                weeks++;\n                if(weeks >= w.length){\n                    return weeks;\n                }\n            }\n        }\n        return weeks + 1;\n    }\n}",
  "1955": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(countSpecialArrays(new int[]{1,2,3,4}, new int[]{0,1,1,1}));\n        System.out.println(countSpecialArrays(new int[]{0,1}, new int[]{0,0}));\n        System.out.println(countSpecialArrays(new int[]{1,2,3}, new int[]{0,1,0}));\n    }\n\n    public static int countSpecialArrays(int[] nums, int[] indexes) {\n        int n = nums.length;\n        int res = 0;\n\n        for (int i = 0; i < n; i++) {\n            int left = i - (i >= indexes[i] ? indexes[i] : 0);\n            int right = i + (n - 1 - i <= indexes[n - 1 - i] ? indexes[n - 1 - i] : 0);\n            res += Math.min(left, right) == 0 ? 1 : 0;\n        }\n\n        return res;\n    }\n}",
  "1956": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] time = {5,1,4};\n        int k = 2;\n        System.out.println(minTimeToSpread(time, k)); // Output: 8\n\n        int[] time1 = {7,9,6,10,4};\n        int k1 = 3;\n        System.out.println(minTimeToSpread(time1, k1)); // Output: 12\n\n        int[] time2 = {5};\n        int k2 = 1;\n        System.out.println(minTimeToSpread(time2, k2)); // Output: 5\n    }\n\n    public static int minTimeToSpread(int[] time, int k) {\n        Arrays.sort(time);\n        long ans = 0;\n        for (int i = k - 1; i < time.length; i += k) {\n            ans += time[i];\n        }\n        return (int) ((ans + (k - 1)) / k);\n    }\n}",
  "1957": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(canBeFancy(\"leeaacsofn\");     // Expected: true\n        System.out.println(canBeFancy(\"aa\");             // Expected: false\n        System.out.println(canBeFancy(\"ayea\");            // Expected: true\n    }\n\n    public static boolean canBeFancy(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == 'a') {\n                count++;\n                while (i + 1 < s.length() && s.charAt(i + 1) == 'a') {\n                    i++;\n                }\n            }\n        }\n        return count <= 2;\n    }\n}\n```",
  "1959": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumTotalSpaceWasted(new int[]{7}, 2));\n        System.out.println(minimumTotalSpaceWasted(new int[]{9,3,2}, 3));\n        System.out.println(minimumTotalSpaceWasted(new int[]{1,4,5}, 2));\n    }\n\n    public static int minimumTotalSpaceWasted(int[] colSizes, int k) {\n        // Your code here\n    }\n}\n```",
  "1958": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(canMove(\"Rearrange\", \"12345678\", \"4K/5Q6B7N8B\"))); // Expected output: true\n        System.out.println(canMove(\"Invalid move\", \"12345678\", \"3Q/5K6B7N8N\"))); // Expected output: false\n        System.out.println(canMove(\"King is in check\", \"8k/4b5q6n7p\", \"2R/3Q4B5K6P\"));); // Expected output: true\n    }\n\n    public static boolean canMove(String description, String board, String move) {\n        // your code here...\n        return false;\n    }\n}\n```",
  "1961": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(isPrefix(\"iloveleetcode\", new String[]{\"algorithm\",\"apple\",\"app\",\"a\"})); // Expected: true\n        System.out.println(isPrefix(\"testing\", new String[]{ \"hello\", \"aloha\", \"testing\", \"testing1\", \"video\" })); // Expected: false\n        System.out.println(isPrefix(\"aaaaaa\", new String[]{ \"a\", \"b\", \"c\", \"aaa\", \"aaaaaa\" })); // Expected: true\n    }\n\n    public static boolean isPrefix(String word, String[] words) {\n        for (String s : words) {\n            if (s.startsWith(word)) return true;\n        }\n        return false;\n    }\n}\n```",
  "1960": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(maxProduct(\"abca\")); // Expected output: 4\n        System.out.println(maxProduct(\"abc\")); // Expected output: 1\n        System.out.println(maxProduct(\"babad\")); // Expected output: 3\n    }\n\n    public static int maxProduct(String s) {\n        int n = s.length();\n        int[] left = new int[n];\n        int[] right = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            if (i % 2 == 0) {\n                left[i] = 1;\n                for (int j = 0; j <= i / 2; j++) {\n                    if (s.charAt(i - j) != s.charAt(j)) {\n                        left[i] = 0;\n                        break;\n                    }\n                }\n            } else {\n                left[i] = left[i - 1];\n            }\n\n            if (i % 2 == 1) {\n                right[i] = 1;\n                for (int j = 0; j <= i / 2; j++) {\n                    if (s.charAt(i - j) != s.charAt(j)) {\n                        right[i] = 0;\n                        break;\n                    }\n                }\n            } else {\n                right[i] = right[i - 1];\n            }\n        }\n\n        int max = 0;\n        for (int i = 0; i < n; i++) {\n            if (left[i] == 1) {\n                for (int j = i + 1; j < n; j++) {\n                    if (right[j] == 1) {\n                        max = Math.max(max, left[i] * right[j]);\n                    }\n                }\n            }\n        }\n\n        return max;\n    }\n}",
  "1963": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minSwaps(\"cba\", \"aba\"));//Expected 2\n        System.out.println(minSwaps(\"dcda\", \"adcd\"));//Expected 4\n        System.out.println(minSwaps(\"abc\", \"cba\"));//Expected 3\n    }\n\n    public static int minSwaps(String s1, String s2) {\n        if (s1.length() != s2.length()) {\n            throw new RuntimeException(\"Strings must be the same length.\");\n        }\n        int swaps = 0;\n        for (int i = 0; i < s1.length(); i++) {\n            while (s1.charAt(i) != s2.charAt(i)) {\n                if (i + 1 >= s1.length() || s1.charAt(i + 1) == s2.charAt(i)) {\n                    swaps++;\n                    break;\n                }\n                i++;\n            }\n        }\n        return swaps;\n    }\n}\n```",
  "1962": "```\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[][] stones = {{0,0},{0,1},{1,2},{1,4},{2,0}};\n        System.out.println(minStones(stones));\n\n        stones = new int[][]{{0,0},{0,2},{1,-100}};\n        System.out.println(minStones(stones));\n\n        stones = new int[][]{{5,9}};\n        System.out.println(minStones(stones));\n    }\n\n    public static int minStones(int[][] peters){\n        if(peters.length < 2) return 0;\n        PriorityQueue<Integer> heap = new PriorityQueue<>((a,b)->b-a);\n        for(int[] stone : peters)\n            heap.add(Math.abs(stone[0] - stone[1]));\n        \n        Arrays.sort(peters, (a,b)->Math.abs(a[0]-a[1]) - Math.abs(b[0]-b[1]));\n        int ans = 0;\n        while(heap.size() > 1) {\n            int a = heap.poll();\n            int b = heap.poll();\n            if(a != b) heap.add(Math.max(0, a-b));\n            ans += a;\n        }\n        \n        return ans;\n    }\n}\n```",
  "1964": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] obstacles = {{0,2},{5,6},{7,12}};\n        System.out.println(\"Position 1: \" + longestValidObstacleCourse(obstacles, 3));\n        System.out.println(\"Position 2: \" + longestValidObstacleCourse(obstacles, 5));\n        System.out.println(\"Position 3: \" + longestValidObstacleCourse(obstacles, 7));\n    }\n\n    public static int longestValidObstacleCourse(int[][] obstacles, int position) {\n        // Your implementation here\n        return 0;\n    }\n}",
  "1965": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] table1 = {{1, \"John\", \"Manager\"}, {2, \"Alice\", null}, {3, \"Bob\", \"Engineer\"}};\n        System.out.println(\"Test case 1: \" + solution.employeesWithMissingInformation(table1));\n        \n        int[][] table2 = {{1, \"Jane\", \"Software Engineer\"}, {2, null, \"QA Tester\"}, {3, \"Mike\", \"Project Manager\"}};\n        System.out.println(\"Test case 2: \" + solution.employeesWithMissingInformation(table2));\n        \n        int[][] table3 = {{1, \"Emma\", \"HR\"}, {2, \"David\", \"Manager\"}, {3, null, \"Operations\"}};\n        System.out.println(\"Test case 3: \" + solution.employeesWithMissingInformation(table3));\n    }\n}\n```",
  "1966": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arrays = {{5, 1, 3}, {2, 6, 9}, {4}};\n        System.out.println(\"Array 1: \" + binarySearchableNumbers(arrays[0]));\n        System.out.println(\"Array 2: \" + binarySearchableNumbers(arrays[1]));\n        System.out.println(\"Array 3: \" + binarySearchableNumbers(arrays[2]));\n    }\n\n    public static int binarySearchableNumbers(int[][] arrays) {\n        int count = 0;\n        for (int[] array : arrays) {\n            Arrays.sort(array);\n            boolean searchable = true;\n            for (int i = 1; i < array.length; i++) {\n                if (array[i - 1] >= array[i]) {\n                    searchable = false;\n                    break;\n                }\n            }\n            if (searchable) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "1967": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(substringCount(\"abc\", new String[]{\"a\", \"b\", \"c\", \"d\"})); // Expected: 4\n        System.out.println(substringCount(\"a\", new String[]{\"aa\", \"aaa\", \"aaaa\", \"a\"})); // Expected: 2\n        System.out.println(substringCount(\"word\", new String[]{\"wo\", \"wor\", \"word\"})); // Expected: 1\n    }\n\n    public static int substringCount(String word, String[] strings) {\n        int count = 0;\n        for (String str : strings) {\n            if (word.contains(str)) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```",
  "1968": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] tests = {\n                {{0}}, // Test case 1\n                {{1,2}} , // Test case 2\n                {{5,6,7}} // Test case 3\n        };\n        \n        for (int i = 0; i < tests.length; i++) {\n            System.out.println(\"Test \" + (i+1) + \":\");\n            int[][] test = tests[i];\n            boolean result = canBeEqual(test);\n            if(result)\n                System.out.println(\"Array can be equal to average of neighbors\");\n            else\n                System.out.println(\"Array cannot be equal to average of neighbors\");\n\n        }\n    }\n\n    public static boolean canBeEqual(int[][] grid) {\n        int n = grid.length;\n        for (int i = 0; i < n; i++) {\n            int sum = 0;\n            for (int j = 0; j < grid[i].length; j++) {\n                sum += grid[i][j];\n            }\n            double average = (double)sum / grid[i].length;\n\n            boolean canBeEqual = true;\n            for (int j = 0; j < grid[i].length; j++) {\n                if(Math.abs(grid[i][j] - average) != 1)\n                    canBeEqual = false;\n            }\n\n            if (!canBeEqual) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```",
  "1969": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[] nums1 = {0, 2, 3};\n        System.out.println(minProduct(nums1)); // prints: 6\n\n        int[] nums2 = {1, 2, 3, 4};\n        System.out.println(minProduct(nums2)); // prints: 24\n\n        int[] nums3 = {0, 0, -1, 1, 3];\n        System.out.println(minProduct(nums3)); // prints: 6\n    }\n\n    public static int minProduct(int[] nums) {\n        int res = Integer.MAX_VALUE;\n        for (int num : nums) {\n            if (num != 0) {\n                res = Math.min(res, num);\n            }\n        }\n        return Arrays.stream(nums).filter(n -> n != 0).reduce(1, (a, b) -> a * b);\n    }\n}",
  "1970": "```\npublic class Solution {\n    public int lastDayWhereYouCanStillCross(int[][] grid) {\n        int m = grid.length;\n        if (m == 0) return 0;\n        int n = grid[0].length;\n        for (int i = 1; i < m; i++) {\n            if (grid[i][0] > grid[i - 1][0]) {\n                grid[i][0] = grid[i - 1][0];\n            }\n        }\n        for (int j = 1; j < n; j++) {\n            if (grid[0][j] > grid[0][j - 1]) {\n                grid[0][j] = grid[0][j - 1];\n            }\n        }\n        int day = 1;\n        while (true) {\n            boolean canCross = true;\n            for (int i = 1; i < m; i++) {\n                if ((i > 0 && grid[i][0] <= grid[i - 1][0]) ||\n                        (j > 0 && grid[0][j] <= grid[0][j - 1])) {\n                    canCross = false;\n                    break;\n                }\n            }\n            for (int j = 1; j < n; j++) {\n                if ((i > 0 && grid[i][0] <= grid[i - 1][0]) ||\n                        (j > 0 && grid[0][j] <= grid[0][j - 1])) {\n                    canCross = false;\n                    break;\n                }\n            }\n            if (!canCross) {\n                return day;\n            }\n            for (int i = 1; i < m; i++) {\n                grid[i][0]++;\n            }\n            for (int j = 1; j < n; j++) {\n                grid[0][j]++;\n            }\n            day++;\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.lastDayWhereYouCanStillCross(new int[][]{{0,1},{2,1}})); // 2\n        System.out.println(solution.lastDayWhereYouCanStillCross(new int[][]{{0,1,2,3,4},{0,1,1,1,1},{1,1,2,3,5},{5,5,5,5,5}})); // 8\n        System.out.println(solution.lastDayWhereYouCanStillCross(new int[][]{{0,1,2,3,4},{0,1,1,1,1},{1,1,2,3,4},{5,5,5,5,5}})); // 6\n    }\n}",
  "1971": "```\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Graph graph = new Graph(3);\n        graph.addEdge(0, 1);\n        graph.addEdge(1, 2);\n\n        System.out.println(\"Test case 1: \" + hasPath(graph, 0, 2)); // true\n        System.out.println(\"Test case 2: \" + hasPath(graph, 1, 0)); // false\n        System.out.println(\"Test case 3: \" + hasPath(graph, 0, 0)); // false\n\n    }\n\n    static class Graph {\n        int n;\n        List<Integer>[] edges;\n\n        public Graph(int n) {\n            this.n = n;\n            edges = (List<Integer>[]) new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                edges[i] = new ArrayList<>();\n            }\n        }\n\n        void addEdge(int a, int b) {\n            edges[a].add(b);\n            edges[b].add(a); // Assuming the graph is undirected\n        }\n    }\n\n    static boolean hasPath(Graph graph, int start, int end) {\n        boolean[] visited = new boolean[graph.n];\n        return dfs(graph, start, end, visited);\n    }\n\n    static boolean dfs(Graph graph, int v, int end, boolean[] visited) {\n        if (v == end)\n            return true;\n        visited[v] = true;\n        for (int i : graph.edges[v]) {\n            if (!visited[i])\n                if (dfs(graph, i, end, visited))\n                    return true;\n        }\n        return false;\n    }\n}",
  "1972": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(Arrays.toString(countCalls(new int[][]{{7,6},{1,10},{2,15},{14,5},{60,60}})));\n        System.out.println(Arrays.toString(countCalls(new int[][]{{9,8},{12,15},{16,18},{20,53},{50,73}})));\n        System.out.println(Arrays.toString(countCalls(new int[][]{{23,22},{4,28},{27,25},{45,45},{1,4}})));\n    }\n\n    public static int[] countCalls(int[][] calls) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] call : calls) {\n            if (!map.containsKey(call[0])) {\n                map.put(call[0], 0);\n            }\n            if (!map.containsKey(call[1])) {\n                map.put.call[1], 0;\n            }\n        }\n\n        int firstCall = -1, lastCall = -1;\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            if (firstCall == -1) {\n                firstCall = entry.getKey();\n                lastCall = entry.getKey();\n            } else {\n                if (entry.getKey() < firstCall) {\n                    firstCall = entry.getKey();\n                }\n                if (entry.getKey() > lastCall) {\n                    lastCall = entry.getKey();\n                }\n            }\n        }\n\n        return new int[]{firstCall, lastCall};\n    }\n}",
  "1973": "```\nclass Solution {\n    int ans = 0;\n    public int equalToDescendant(Node root) {\n        dfs(root, null);\n        return ans;\n    }\n    \n    void dfs(Node node, Node parent) {\n        if (node == null) {\n            return;\n        }\n        \n        if (parent != null && parent.val + node.val == node.left != null ? node.left.val : 0) {\n            ans++;\n        }\n        \n        dfs(node.left, node);\n        dfs(node.right, node);\n    }\n}\n\nclass Main {\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        Node root1 = new Node(1);\n        root1.left = new Node(2);\n        root1.right = new Node(3);\n        root1.right.left = new Node(4);\n        root1.right.right = new Node(5);\n        \n        System.out.println(solution.equalToDescendant(root1));  // Output: 1\n\n        Node root2 = new Node(1);\n        root2.left = new Node(2);\n        root2.right = new Node(3);\n\n        System.out.println(solution.equalToDescendant(root2));  // Output: 0\n\n        Node root3 = new Node(1);\n        root3.left = new Node(-1);\n        root3.right = new Node(-1);\n\n        System.out.println(solution.equalToDescendant(root3));  // Output: 1\n    }\n}\n\nclass Node {\n    int val;\n    Node left, right;\n    Node(int x) { val = x; }\n}\n```",
  "1974": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minTimeToType(\"abc\", 1)); // Expected output: 5\n        System.out.println(minTimeToType(\"bzaqgwkjqtrhkjghkjhgfdsaqwertyuiopasdfghjklzxcvbnm\", 3)); // Expected output: 37\n        System.out.println(minTimeToType(\"\", 2)); // Expected output: 0\n    }\n\n    public static int minTimeToType(String word, int k) {\n        char[] chars = word.toCharArray();\n        int time = 0;\n        for (char c : chars) {\n            if (c == 'o' || c == 'O') {\n                time += k + 1;\n            } else {\n                time += k;\n            }\n        }\n        return time;\n    }\n}",
  "1975": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] matrix1 = {{-1,-1,-1},{1,1,1},{1,0,-100}};\n        System.out.println(\"Matrix1: \" + maxMatrixSum(matrix1));\n        \n        int[][] matrix2 = {{-9,6,8},{4,5,7},{3,-1,2}};\n        System.out.println(\"Matrix2: \" + maxMatrixSum(matrix2));\n        \n        int[][] matrix3 = {{0,1},{2,1}};\n        System.out.println(\"Matrix3: \" + maxMatrixSum(matrix3));\n    }\n\n    public static int maxMatrixSum(int[][] mat) {\n        if (mat.length == 0 || mat[0].length == 0)\n            return 0;\n\n        int total = 0;\n        for (int i = 0; i < mat.length; i++) {\n            for (int j = 0; j < mat[i].length; j++) {\n                if (mat[i][j] > 0) {\n                    total += mat[i][j];\n                } else if (total <= 0) {\n                    total -= mat[i][j];\n                }\n            }\n        }\n\n        return Math.max(total, 0);\n    }\n}\n```",
  "1976": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        int[][] arr1 = {{2,1},{3,3},{2,1}};\n        System.out.println(\"Number of ways to arrive at destination for input \" + Arrays.deepToString(arr1) + \": \" + numWays(5, arr1));\n        \n        int[][] arr2 = {{4,1},{3,2},{2,2},{1,1}};\n        System.out.println(\"Number of ways to arrive at destination for input \" + Arrays.deepToString(arr2) + \": \" + numWays(6, arr2));\n\n        int[][] arr3 = {{1,0},{2,1},{3,2},{4,3},{5,4}};\n        System.out.println(\"Number of ways to arrive at destination for input \" + Arrays.deepToString(arr3) + \": \" + numWays(7, arr3));\n    }\n\n    public static int numWays(int n, int[][] edges) {\n        List<Integer>[] graph = (List<Integer>[]) new List[n];\n        for (int i = 0; i < n; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        \n        for (int[] edge : edges) {\n            graph[edge[1]].add(edge[0]);\n        }\n\n        int[] inDegrees = new int[n];\n        for (int i = 0; i < n; i++) {\n            inDegrees[i] = graph[i].size();\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegrees[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        int res = 1;\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            res *= inDegrees[node];\n            for (int neighbor : graph[node]) {\n                inDegrees[neighbor]--;\n                if (inDegrees[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        return res;\n    }\n}\n```",
  "1977": "```\npublic class Main {\n\n    public static void main(String[] args) {\n        System.out.println(\"Test case 1: \" + waysToSeparate(new String[]{\"10\", \"1\", \"20\"}));\n        System.out.println(\"Test case 2: \" + waysToSeparate(new String[]{\"3\", \"3\", \"6\", \"4\"}));\n        System.out.println(\"Test case 3: \" + waysToSeparate(new String[]{\"7\", \"1\"}));\n\n    }\n\n    public static int waysToSeparate(String[] nums) {\n        // your code here\n    }\n}\n```",
  "1978": "```\npublic class Main {\n    public static void main(String[] args) {\n        Employee[] employee1 = {\n            new Employee(1, \"John\", 65),\n            new Employee(2, \"Alice\", 35),\n            new Employee(3, \"Bob\", 70),\n            new Employee(4, \"Charlie\", 30)\n        };\n        \n        for (int i : getEmployeesWhoseManagerLeft(employee1)) {\n            System.out.println(i);\n        }\n        \n        Employee[] employee2 = {\n            new Employee(1, \"John\", 65),\n            new Employee(2, \"Alice\", 35, 1),\n            new Employee(3, \"Bob\", 70, 1)\n        };\n        \n        for (int i : getEmployeesWhoseManagerLeft(employee2)) {\n            System.out.println(i);\n        }\n        \n        Employee[] employee3 = {\n            new Employee(1, \"John\", 65),\n            new Employee(2, \"Alice\", 35, 65),\n            new Employee(3, \"Bob\", 70, 65)\n        };\n        \n        for (int i : getEmployeesWhoseManagerLeft(employee3)) {\n            System.out.println(i);\n        }\n    }\n\n    public static List<Integer> getEmployeesWhoseManagerLeft(Employee[] employees) {\n        Map<Integer, Integer> employeeMap = new HashMap<>();\n        for (Employee employee : employees) {\n            if (employee.managerId != null && !employeeMap.containsKey(employee.managerId)) {\n                employeeMap.put(employee.managerId, 0);\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (Employee employee : employees) {\n            if (!employeeMap.containsKey(employee.id) || !employeeMap.containsKey(employee.managerId) ||\n                    employeeMap.get(employee.managerId) != 1) {\n                result.add(employee.id);\n            } else {\n                employeeMap.put(employee.managerId, 0);\n            }\n        }\n\n        return result;\n    }\n\n    public static class Employee {\n        int id;\n        String name;\n        int salary;\n        Integer managerId;\n\n        public Employee(int id, String name, int salary) {\n            this.id = id;\n            this.name = name;\n            this.salary = salary;\n            this.managerId = null;\n        }\n\n        public Employee(int id, String name, int salary, int managerId) {\n            this.id = id;\n            this.name = name;\n            this.salary = salary;\n            this.managerId = managerId;\n        }\n    }\n}",
  "1979": "```\npublic class Main {\n    public static void main(String[] args) {\n        int[][] arrays = {{12, 15, 20}, {4, 6, 8}, {2, 4, 14}};\n        for (int i = 0; i < arrays.length; i++) {\n            System.out.println(\"The GCD of array \" + arrays[i] + \" is: \" + findGCD(arrays[i]));\n        }\n    }\n\n    public static int findGCD(int[] nums) {\n        int result = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            result = gcd(result, nums[i]);\n        }\n        return result;\n    }\n\n    private static int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        else\n            return gcd(b, a % b);\n    }\n}\n```",
  "1980": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(findValidString(new String[]{\"100000\", \"110000\", \"011000\"})); // Expected output: \"0110\"\n        System.out.println(findValidString(new String[]{\"1111\", \"10101\", \"01010\"})); // Expected output: \"10100\"\n        System.out.println(findValidString(new String[]{\"0\", \"1\"})); // Expected output: \"10\"\n    }\n\n    public static String findValidString(String[] bits) {\n        int n = bits[0].length();\n        Map<String, Integer> countMap = new HashMap<>();\n        for (String bit : bits) {\n            if (bit.length() != n) {\n                return \"\";\n            }\n            for (int i = 0; i < n; i++) {\n                String str = String.valueOf(bit.charAt(i));\n                countMap.put(str, countMap.getOrDefault(str, 0) + 1);\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            if (countMap.get(String.valueOf('0')) > countMap.get(String.valueOf('1'))) {\n                res.append(\"0\");\n            } else if (countMap.get(String.valueOf('1')) > countMap.get(String.valueOf('0'))) {\n                res.append(\"1\");\n            } else {\n                if (countMap.getOrDefault(String.valueOf('0'), 0) <= countMap.getOrDefault(String.valueOf('1'), 0)) {\n                    res.append(\"1\");\n                } else {\n                    res.append(\"0\");\n                }\n            }\n        }\n        return res.toString();\n    }\n}",
  "1981": "```\npublic class Main {\n    public static void main(String[] args) {\n        System.out.println(minimumDifference(new int[][]{{10,6,5,4},{10,1,2}}, 6));\n        \n        System.out.println(minimumDifference(new int[][]{{1,5,3}}, 16));\n        \n        System.out.println(minimumDifference(new int[][]{{1,5,3},{0,2}}, 5));\n    }\n\n    public static int minimumDifference(int[][] nums, int target) {\n        int n = nums.length;\n        int m = nums[0].length;\n\n        int[][] dp = new int[n][m];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == 0) {\n                    dp[i][j] = Math.abs(nums[i][j] - target);\n                } else {\n                    int minDiff = Integer.MAX_VALUE;\n                    for (int k = 0; k < m; k++) {\n                        minDiff = Math.min(minDiff, dp[i-1][k]);\n                    }\n                    dp[i][j] = Math.min(minDiff, Math.abs(nums[i][j] - target));\n                }\n            }\n        }\n\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i < m; i++) {\n            res = Math.min(res, dp[n-1][i]);\n        }\n\n        return res;\n    }\n}"
}