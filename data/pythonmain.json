{
  "1": "```\ndef twoSum(nums, target):\n    num_dict = {}\n    for i in range(len(nums)):\n        if nums[i] in num_dict:\n            return [num_dict[nums[i]], i]\n        else:\n            num_dict[target - nums[i]] = i\n    return []\n\ndef main():\n    print(\"Test Case 1:\")\n    print(twoSum([2,7,11,15], 9))\n    print()\n\n    print(\"Test Case 2:\")\n    print(twoSum([3,2,4], 6))\n    print()\n\n    print(\"Test Case 3:\")\n    print(twoSum([3,3], 6))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "2": "```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode:\n    dummyHead = ListNode(0)\n    current = dummyHead\n    carry = 0\n    while l1 or l2 or carry:\n        x = l1.val if l1 else 0\n        y = l2.val if l2 else 0\n        sum = carry + x + y\n        carry = sum // 10\n        current.next = ListNode(sum % 10)\n        current = current.next\n        l1 = l1.next if l1 else None\n        l2 = l2.next if l2 else None\n    return dummyHead.next\n\ndef printList(head: ListNode):\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n    print()\n\ndef main():\n    # Test case 1\n    l1 = ListNode(2, ListNode(4, ListNode(3)))\n    l2 = ListNode(5, ListNode(6, ListNode(4)))\n    result = addTwoNumbers(l1, l2)\n    print(\"Test case 1:\")\n    printList(result)\n\n    # Test case 2\n    l1 = ListNode(9, ListNode(9))\n    l2 = ListNode(1)\n    result = addTwoNumbers(l1, l2)\n    print(\"\\nTest case 2:\")\n    printList(result)\n\n    # Test case 3\n    l1 = ListNode(0)\n    l2 = ListNode(0)\n    result = addTwoNumbers(l1, l2)\n    print(\"\\nTest case 3:\")\n    printList(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "3": "```\ndef lengthOfLongestSubstring(s):\n    if not s:\n        return 0\n    \n    start = 0\n    end = 0\n    max_length = 0\n    char_index = {}\n    \n    while end < len(s):\n        if s[end] in char_index and char_index[s[end]] >= start:\n            start = char_index[s[end]] + 1\n        char_index[s[end]] = end\n        end += 1\n        \n        max_length = max(max_length, end - start)\n        \n    return max_length\n\n\ndef main():\n    print(lengthOfLongestSubstring(\"abcabcbb\") == 3)\n    print(lengthOfLongestSubstring(\"bbbbb\") == 1)\n    print(lengthOfLongestSubstring(\"abcdefg\") == 7)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "4": "```\ndef findMedianSortedArrays(nums1, nums2):\n    if len(nums1) > len(nums2):\n        return findMedianSortedArrays(nums2, nums1)\n    \n    x, y = len(nums1), len(nums2)\n    low, high = 0, x\n    \n    while low <= high:\n        partitionX, partitionY = (low + high)//2, ((x + y) // 2) - ((x % 2) and 1 or 0)\n        \n        maxLeftX, minRightX = nums1[partitionX-1] if partitionX != 0 else float('-inf'), nums1[partitionX] if partitionX != x else float('inf')\n        maxLeftY, minRightY = nums2[partitionY-1] if partitionY != 0 else float('-inf'), nums2[partitionY] if partitionY != y else float('inf')\n\n        if maxLeftX <= minRightY and maxLeftY <= minRightX:\n            if (x + y) % 2 == 0:\n                return (max(maxLeftX, maxLeftY), min(minRightX, minRightY)) \n            else: \n                return max(maxLeftX, maxLeftY)\n        \n        elif maxLeftX > minRightY:\n            high = partitionX - 1\n        \n        else:\n            low = partitionX + 1\n\ndef main():\n    print(\"Test Case 1:\")\n    nums1 = [1, 3]\n    nums2 = [2]\n    result = findMedianSortedArrays(nums1, nums2)\n    print(f\"Expected: 2.0, Actual: {result}\")\n\n    print(\"\\nTest Case 2:\")\n    nums1 = [1, 2]\n    nums2 = []\n    result = findMedianSortedArrays(nums1, nums2)\n    print(f\"Expected: 1.5, Actual: {result}\")\n\n    print(\"\\nTest Case 3:\")\n    nums1 = [0, 0]\n    nums2 = [0, 0]\n    result = findMedianSortedArrays(nums1, nums2)\n    print(f\"Expected: 0.0, Actual: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "5": "```\ndef longest_palindromic_substring(s):\n    if not s:\n        return \"\"\n\n    n = len(s)\n    low = 0\n    high = 0\n\n    for i in range(n):\n        len1 = expand_around_center(s, i, i)\n        len2 = expand_around_center(s, i, i+1)\n        max_len = max(len1, len2)\n\n        if max_len > high:\n            low = i - (max_len-1) // 2\n            high = i + max_len // 2\n\n    return s[low:high+1]\n\ndef expand_around_center(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n    return right - left - 1\n\ndef main():\n    print(longest_palindromic_substring(\"babad\") == \"bab\")\n    print(longest_palindromic_substring(\"cbbd\") == \"bb\")\n    print(longest_palindromic_substring(\"a\") == \"a\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "6": "```\ndef convert(s: str, numRows: int) -> str:\n    if numRows == 1 or numRows >= len(s):\n        return s\n\n    result = [\"\"] * numRows\n    index, step = 0, 1\n\n    for char in s:\n        result[index] += char\n\n        if index == 0:\n            step = 1\n        elif index == numRows - 1:\n            step = -1\n\n        index += step\n\n    return \"\".join(result)\n\ndef main():\n    print(convert(\"PAYPALISHISING\", 3))\n    print(convert(\"a\", 1))\n    print(convert(\"abcdefg\", 2))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "7": "```\ndef reverse(x: int) -> int:\n    res = 0\n    neg = False\n    if x < 0:\n        neg = True\n        x *= -1\n    while x != 0:\n        res = res * 10 + x % 10\n        x //= 10\n    if neg:\n        return -res\n    else:\n        return res\n\ndef main():\n    print(\"Test case 1: \")\n    print(reverse(123)) # expected output: 321\n\n    print(\"\\nTest case 2: \")\n    print(reverse(-123)) # expected output: -321\n\n    print(\"\\nTest case 3: \")\n    print(reverse(1000000013)) # expected output: 3000000031\n\nif __name__ == \"__main__\":\n    main()\n```",
  "8": "```\ndef myAtoi(str):\n    str = str.strip()\n    if not str:\n        return 0\n\n    sign = 1\n    num_str = ''\n    for char in str:\n        if char == ' ':\n            continue\n        elif char in ['+', '-']:\n            if num_str:\n                break\n            sign = -1 if char == '-' else 1\n        elif char.isdigit():\n            num_str += char\n        else:\n            break\n\n    num = int(num_str) * sign\n    return max(-2**31, min(2**31-1, num))\n\n\ndef main():\n    print(myAtoi(\"42\")) # 42\n    print(myAtoi(\"   -2147483648\")) # -2147483648\n    print(myAtoi(\"3.14159\")) # 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "9": "```\ndef is_palindrome(x):\n    if x < 0:\n        return False\n    rev = int(str(x)[::-1])\n    return x == rev\n\n\ndef main():\n    print(is_palindrome(121)) # True\n    print(is_palindrome(-121)) # False\n    print(is_palindrome(12321)) # True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "10": "```\ndef isMatch(s, p):\n    if not p:\n        return not s\n\n    first_match = bool(s) and p[0] in {s[0], '.'}\n    if len(p) >= 2 and p[1] == '*':\n        return (isMatch(s, p[2:]) or\n                first_match and isMatch(s[1:], p))\n    return first_match and isMatch(s[1:], p[1:])\n\ndef main():\n    print(isMatch(\"aa\", \"a\")) # false\n    print(isMatch(\"aa\", \"a*\")) # true\n    print(isMatch(\"aab\", \"c*a*b\")) # true\n\nif __name__ == \"__main__\":\n    main()\n```",
  "11": "```\ndef maxArea(height):\n    if not height:\n        return 0\n\n    left = 0\n    right = len(height) - 1\n    max_area = 0\n\n    while left < right:\n        area = min(height[left], height[right]) * (right - left)\n        max_area = max(max_area, area)\n\n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return max_area\n\n\ndef main():\n    print(maxArea([1,8,6,2,5,3,4])) # Expected: 49\n    print(maxArea([1,1])) # Expected: 1\n    print(maxArea([])) # Expected: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "12": "```\ndef intToRoman(num):\n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n        ]\n    syb = [\n        \"M\", \"CM\", \"D\", \"CD\",\n        \"C\", \"XC\", \"L\", \"XL\",\n        \"X\", \"IX\", \"V\", \"IV\",\n        \"I\"\n        ]\n    roman_num = ''\n    i = 0\n    while num > 0:\n        for _ in range(num // val[i]):\n            roman_num += syb[i]\n            num -= val[i]\n        i += 1\n    return roman_num\n\ndef main():\n    print(\"Test Case 1:\")\n    print(intToRoman(3)) # Should be \"III\"\n\n    print(\"\\nTest Case 2:\")\n    print(intToRoman(4)) # Should be \"IV\"\n\n    print(\"\\nTest Case 3:\")\n    print(intToRoman(1999)) # Should be \"MCMXCIX\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "13": "```\ndef romanToInt(s):\n    roman_map = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n    result = 0\n    for i in range(len(s)):\n        if i > 0 and roman_map[s[i]] > roman_map[s[i - 1]]:\n            result += roman_map[s[i]] - 2 * roman_map[s[i - 1]]\n        else:\n            result += roman_map[s[i]]\n    return result\n\ndef main():\n    print(romanToInt(\"III\")) # Test case 1\n    print(romanToInt(\"IV\"))   # Test case 2\n    print(romanToInt(\"MCMXCIV\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "14": "```\ndef longestCommonPrefix(strs):\n    if not strs:\n        return \"\"\n    min_len = len(min(strs, key=len))\n    for i in range(min_len):\n        char = strs[0][i]\n        for s in strs:\n            if s[i] != char:\n                return strs[0][:i]\n    return strs[0][:min_len]\n\ndef main():\n    print(longestCommonPrefix([\"flower\",\"flow\",\"flight\"])) # output: \"fl\"\n    print(longestCommonPrefix([\"dog\",\"racecar\",\"bar\"])) # output: \"\"\n    print(longestCommonPrefix([\"a\"])) # output: \"a\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "15": "```\ndef threeSum(nums):\n    nums.sort()\n    result = []\n    for i in range(len(nums)-2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        l, r = i+1, len(nums)-1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            if s < 0:\n                l +=1 \n            elif s > 0:\n                r -= 1\n            else:\n                result.append([nums[i], nums[l], nums[r]])\n                while l < r and nums[l] == nums[l+1]:\n                    l +=1\n                while l < r and nums[r] == nums[r-1]:\n                    r -= 1\n                l +=1; r -= 1\n    return result\n\ndef main():\n    print(threeSum([-1,0,1,2,-1,-4])) # [[-1,-1,2],[-1,0,1]]\n    print(threeSum([0,1,1])) # []\n    print(threeSum([0,0,0])) # [[0,0,0]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "16": "```\ndef threeSumClosest(nums, target):\n    nums.sort()\n    closest = float('inf')\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if abs(total - target) < abs(closest - target):\n                closest = total\n            if total < target:\n                left += 1\n            elif total > target:\n                right -= 1\n            else:\n                return target\n    return closest\n\n\ndef main():\n    print(threeSumClosest([-1, 2, 1, -4], 1)) \n    print(threeSumClosest([0, 0, 0], 1))\n    print(threeSumClosest([1, 2, -5, 0, -3, 3, 0, 8, -2, 12], 6))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "17": "```\ndef letterCombinations(digits):\n    if not digits:\n        return []\n\n    phone = {'2': ['a', 'b', 'c'],\n             '3': ['d', 'e', 'f'],\n             '4': ['g', 'h', 'i'],\n             '5': ['j', 'k', 'l'],\n             '6': ['m', 'n', 'o'],\n             '7': ['p', 'q', 'r', 's'],\n             '8': ['t', 'u', 'v'],\n             '9': ['w', 'x', 'y', 'z']}\n\n    def backtrack(combination, next_digits):\n        if len(next_digits) == 0:\n            output.append(combination)\n        else:\n            for letter in phone[next_digits[0]]:\n                backtrack(combination + letter, next_digits[1:])\n\n    output = []\n    backtrack(\"\", digits)\n    return output\n\ndef main():\n    print(letterCombinations(\"23\")) # Expected output: [\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]\n    print(letterCombinations(\"412\")) # Expected output: [\"gp\", \"go\", \"gpj\", \"gpk\", \"gpl\", \"gpq\", \"gr\", \"gs\", \"gt\"]\n    print(letterCombinations(\"\")) # Expected output: []\n\nmain()\n```",
  "18": "```\ndef fourSum(nums, target):\n    nums.sort()\n    result = []\n    for i in range(len(nums) - 3):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        for j in range(i+1, len(nums) - 2):\n            if j > i + 1 and nums[j] == nums[j-1]:\n                continue\n            left, right = j+1, len(nums)-1\n            while left < right:\n                total = nums[i] + nums[j] + nums[left] + nums[right]\n                if total < target:\n                    left += 1\n                elif total > target:\n                    right -= 1\n                else:\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    while left < right and nums[left] == nums[left+1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right-1]:\n                        right -= 1\n                    left += 1; right -= 1\n    return result\n\ndef main():\n    print(fourSum([1,0,-1,0,-2,2],10))\n    print(fourSum([-5,-4,-3,-2,-1,0,0,1,2,3],-1))\n    print(fourSum([0,0,0,0,0,0],0))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "19": "```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef removeNthFromEnd(head: ListNode, n: int) -> ListNode:\n    dummy = ListNode(0)\n    dummy.next = head\n    first = dummy\n    second = dummy\n    \n    for _ in range(n + 1):\n        second = second.next\n\n    while second:\n        first = first.next\n        second = second.next\n    \n    first.next = first.next.next\n    return dummy.next\n\ndef main():\n    # Test case 1\n    head1 = ListNode(1)\n    head1.next = ListNode(2)\n    head1.next.next = ListNode(3)\n    head1.next.next.next = ListNode(4)\n    head1.next.next.next.next = ListNode(5)\n    print(\"Test case 1: \")\n    print(\"Input:\", head1.val, \"->\", head1.next.val, \"->\", head1.next.next.val)\n    print(\"Output:\", removeNthFromEnd(head1, 2).val, \"->\", removeNthFromEnd(head1, 2).next.val)\n\n    # Test case 2\n    head2 = ListNode(1)\n    head2.next = ListNode(2)\n    print(\"Test case 2: \")\n    print(\"Input:\", head2.val, \"->\", head2.next.val)\n    print(\"Output:\", removeNthFromEnd(head2, 1).val)\n\n    # Test case 3\n    head3 = ListNode(1)\n    print(\"Test case 3: \")\n    print(\"Input:\", head3.val)\n    print(\"Output:\", removeNthFromEnd(head3, 1).val)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "20": "```\ndef isValid(s):\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping.values():\n            stack.append(char)\n        elif char in mapping:\n            if not stack or mapping[char] != stack.pop():\n                return False\n    return not stack\n\ndef main():\n    print(isValid(\"()\"))  # True\n    print(isValid(\"()[]{}\"))  # True\n    print(isValid(\"(]\"))  # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "22": "```\ndef generateParenthesis(n):\n    if n == 0:\n        return [\"\"]\n    \n    result = []\n    for c in generateParenthesis(n-1):\n        result.append(\"(\" + c + \")\")\n        if n > 1:\n            result.append(\"()\" + c)\n            if len(c) < n - 1:\n                result.append(\"(\" + c + \")\")\n\n    return list(set(result))\n\ndef main():\n    test_cases = [2, 3, 4]\n    \n    for n in test_cases:\n        print(f\"Generate parentheses for {n} pairs: {generateParenthesis(n)}\")\n        \nif __name__ == \"__main__\":\n    main()\n```",
  "21": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef mergeTwoLists(l1, l2):\n    if not l1:\n        return l2\n    elif not l2:\n        return l1\n    elif l1.val < l2.val:\n        l1.next = mergeTwoLists(l1.next, l2)\n        return l1\n    else:\n        l2.next = mergeTwoLists(l1, l2.next)\n        return l2\n\ndef printList(head):\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n    print()\n\ndef main():\n    # Test Case 1\n    l1_1 = ListNode(1)\n    l1_2 = ListNode(3)\n    l1_1.next = l1_2\n    l2_1 = ListNode(2)\n    l2_2 = ListNode(4)\n    l2_1.next = l2_2\n    result = mergeTwoLists(l1_1, l2_1)\n    print(\"Test Case 1:\")\n    printList(result)\n\n    # Test Case 2\n    l1_3 = ListNode(0)\n    l1_4 = ListNode(5)\n    l1_3.next = l1_4\n    l2_3 = ListNode(1)\n    l2_4 = ListNode(9)\n    l2_3.next = l2_4\n    result = mergeTwoLists(l1_3, l2_3)\n    print(\"Test Case 2:\")\n    printList(result)\n\n    # Test Case 3\n    l1_5 = ListNode(1)\n    l1_6 = ListNode(3)\n    l1_7 = ListNode(4)\n    l1_5.next = l1_6\n    l1_6.next = l1_7\n    l2_5 = ListNode(2)\n    l2_6 = ListNode(3)\n    l2_5.next = l2_6\n    result = mergeTwoLists(l1_5, l2_5)\n    print(\"Test Case 3:\")\n    printList(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "23": "```\nimport heapq\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeKLists(lists):\n    dummy = ListNode()\n    curr = dummy\n    min_heap = []\n    \n    for i in range(len(lists)):\n        if lists[i]:\n            heapq.heappush(min_heap, (lists[i].val, i))\n            lists[i] = lists[i].next\n    \n    while min_heap:\n        val, index = heapq.heappop(min_heap)\n        curr.next = ListNode(val)\n        curr = curr.next\n        \n        if lists[index]:\n            lists[index] = lists[index].next\n            heapq.heappush(min_heap, (lists[index].val, index))\n    \n    return dummy.next\n\ndef printList(head):\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\ndef main():\n    # Test case 1\n    list1 = ListNode(1, ListNode(4, ListNode(5)))\n    list2 = ListNode(1, ListNode(3, ListNode(4)))\n    list3 = ListNode(2, ListNode(6))\n    result = mergeKLists([list1, list2, list3])\n    print(\"Test case 1: \")\n    printList(result)\n\n    # Test case 2\n    list1 = ListNode(0, ListNode(3))\n    list2 = ListNode(4)\n    list3 = None\n    result = mergeKLists([list1, list2, list3])\n    print(\"Test case 2: \")\n    printList(result)\n\n    # Test case 3\n    list1 = ListNode(5)\n    list2 = ListNode(10, ListNode(15))\n    list3 = None\n    result = mergeKLists([list1, list2, list3])\n    print(\"Test case 3: \")\n    printList(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "24": "```\ndef swapPairs(head):\n    if not head or not head.next:\n        return head\n    \n    new_head = head.next\n    head.next = swapPairs(new_head.next)\n    new_head.next = head\n    return new_head\n\n\ndef print_list(head):\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n    print()\n\n\ndef main():\n    # Test case 1: A simple linked list with 3 nodes\n    node4 = ListNode(4)\n    node2 = ListNode(2)\n    node1 = ListNode(1)\n    node1.next = node2\n    node2.next = node4\n    head = node1\n    new_head = swapPairs(head)\n    print(\"Test case 1:\")\n    print_list(new_head)\n\n    # Test case 2: A linked list with 5 nodes\n    node6 = ListNode(6)\n    node5 = ListNode(5)\n    node3 = ListNode(3)\n    node2_1 = ListNode(2)\n    node1_1 = ListNode(1)\n    node1_1.next = node2_1\n    node2_1.next = node3\n    node3.next = node5\n    node5.next = node6\n    head = node1_1\n    new_head = swapPairs(head)\n    print(\"Test case 2:\")\n    print_list(new_head)\n\n    # Test case 3: An empty linked list (no nodes)\n    head = None\n    new_head = swapPairs(head)\n    print(\"Test case 3:\")\n    print_list(new_head)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "26": "```\ndef removeDuplicates(nums):\n    if len(nums) == 0:\n        return 0\n\n    i = 1\n    for j in range(1, len(nums)):\n        if nums[j] != nums[i - 1]:\n            i += 1\n            nums[i-1] = nums[j]\n\n    return i\n\n\ndef main():\n    print(\"Test case 1: [1,1,2]\")\n    arr = [1,1,2]\n    n = removeDuplicates(arr)\n    print(f\"Result: {arr[:n]}\")\n    print()\n\n    print(\"Test case 2: [0,0,1,1,1,2,3]\")\n    arr = [0,0,1,1,1,2,3]\n    n = removeDuplicates(arr)\n    print(f\"Result: {arr[:n]}\")\n    print()\n\n    print(\"Test case 3: []\")\n    arr = []\n    n = removeDuplicates(arr)\n    print(f\"Result: {arr[:n]}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "25": "```\nclass Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        if not head or k == 1:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head\n        pre = dummy\n        while head and head.next:\n            cnt = 0\n            temp = head\n            while temp and cnt < k:\n                temp = temp.next\n                cnt += 1\n            if cnt == k:\n                pre.next = self.reverse(temp, k)\n                head = pre.next\n                pre = dummy\n            else:\n                break\n        return dummy.next\n\n    def reverse(self, head: ListNode, k: int) -> ListNode:\n        prev, curr = None, head\n        while k > 0:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n            k -= 1\n        return prev\n\ndef main():\n    s = Solution()\n    \n    # Test case 1\n    l1_1 = ListNode(1)\n    l1_2 = ListNode(2)\n    l1_3 = ListNode(3)\n    head1 = l1_1\n    l1_1.next = l1_2\n    l1_2.next = l1_3\n    result1 = s.reverseKGroup(head1, 3)\n    \n    # Test case 2\n    l2_1 = ListNode(1)\n    l2_2 = ListNode(2)\n    head2 = l2_1\n    l2_1.next = l2_2\n    result2 = s.reverseKGroup(head2, 2)\n    \n    # Test case 3\n    l3_1 = ListNode(1)\n    l3_2 = ListNode(2)\n    l3_3 = ListNode(3)\n    l3_4 = ListNode(4)\n    l3_5 = ListNode(5)\n    head3 = l3_1\n    l3_1.next = l3_2\n    l3_2.next = l3_3\n    l3_3.next = l3_4\n    l3_4.next = l3_5\n    result3 = s.reverseKGroup(head3, 4)\n    \n    print(\"Test case 1:\")\n    while result1:\n        print(result1.val, end=\" \")\n        result1 = result1.next\n    print()\n    \n    print(\"Test case 2:\")\n    while result2:\n        print(result2.val, end=\" \")\n        result2 = result2.next\n    print()\n    \n    print(\"Test case 3:\")\n    while result3:\n        print(result3.val, end=\" \")\n        result3 = result3.next\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "27": "```\ndef removeElement(nums, val):\n    if not nums:\n        return 0\n\n    i = 0\n    for j in range(len(nums)):\n        if nums[j] != val:\n            nums[i] = nums[j]\n            i += 1\n    return i\n\n\ndef main():\n    print(\"Test Case 1:\")\n    nums = [3, 2, 2, 3]\n    val = 3\n    expected = 2\n    result = removeElement(nums.copy(), val)\n    if result == expected:\n        print(\"Pass\")\n    else:\n        print(f\"Fail: Expected {expected}, got {result}\")\n    print()\n\n    print(\"Test Case 2:\")\n    nums = [0, 1, 2, 2, 3, 4]\n    val = 2\n    expected = 5\n    result = removeElement(nums.copy(), val)\n    if result == expected:\n        print(\"Pass\")\n    else:\n        print(f\"Fail: Expected {expected}, got {result}\")\n    print()\n\n    print(\"Test Case 3:\")\n    nums = [1, 2]\n    val = 2\n    expected = 2\n    result = removeElement(nums.copy(), val)\n    if result == expected:\n        print(\"Pass\")\n    else:\n        print(f\"Fail: Expected {expected}, got {result}\")\n    print()\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "28": "```\ndef strStr(s, p):\n    if not p:\n        return 0\n    for i in range(len(s) - len(p) + 1):\n        if s[i:i+len(p)] == p:\n            return i\n    return -1\n\n\ndef main():\n    print(strStr(\"hello\", \"ll\") == 2)\n    print(strStr(\"aaaaa\", \"bcp\") == -1)\n    print(strStr(\"\", \"abc\") == -1)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "29": "```\ndef divide(dividend: int, divisor: int) -> int:\n    if dividend == -2**31 and divisor == -1:\n        return 2**31\n    sign = -1 if ((dividend < 0) ^ (divisor < 0)) else 1\n    dividend, divisor = abs(dividend), abs(divisor)\n    res = 0\n    while dividend >= divisor:\n        temp = divisor\n        i = 1\n        while dividend >= (temp << 1):\n            temp <<= 1\n            i <<= 1\n        dividend -= temp\n        res += i\n    return sign * res\n\ndef main():\n    print(divide(-2147483648, -1)) # Test case 1\n    print(divide(7, -3))          # Test case 2\n    print(divide(10, 5))           # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "30": "```\ndef findSubstring(s, words):\n    if not s or not words:\n        return []\n\n    word_len = len(words[0])\n    total_words = len(words)\n    total_chars = total_words * word_len\n    char_index = {}\n    for word in words:\n        if word not in char_index:\n            char_index[word] = 0\n        else:\n            char_index[word] += 1\n\n    res = []\n    for i in range(len(s) - total_chars + 1):\n        char_map = {}\n        j = 0\n        while j < total_words:\n            idx = i + j * word_len\n            substr = s[idx:idx + word_len]\n            if substr not in char_index or char_index[substr] == 0:\n                break\n            if substr not in char_map:\n                char_map[substr] = 0\n            char_map[substr] += 1\n            j += 1\n        if j == total_words:\n            res.append(i)\n\n    return [i // word_len for i in res]\n\n\ndef main():\n    s = \"barfoofoobartharfoo\"\n    words = [\"fooo\", \"bar\"]\n    print(findSubstring(s, words))  # Output: [0, 9]\n\n    s = \"wordgoodgoodgoodbestword\"\n    words = [\"word\",\"good\",\"best\",\"good\"]\n    print(findSubstring(s, words))  # Output: [8]\n\n    s = \"aa\"\n    words = [\"aa\", \"aa\"]\n    print(findSubstring(s, words))  # Output: [0]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "31": "```\ndef nextPermutation(self, nums):\n    n = len(nums)\n    i = n - 2\n    \n    while i >= 0 and nums[i + 1] <= nums[i]:\n        i -= 1\n    if i < 0:\n        return [1] * n\n    \n    j = n - 1\n    while j > i and nums[j] <= nums[i]:\n        j -= 1\n    nums[i], nums[j] = nums[j], nums[i]\n    \n    left, right = i + 1, n - 1\n    while left < right:\n        nums[left], nums[right] = nums[right], nums[left]\n        left += 1\n        right -= 1\n\ndef main():\n    solution = Solution()\n    print(solution.nextPermutation([3,2,3])) # [1,3,2]\n    print(solution.nextPermutation([1,1])) # [1,2]\n    print(solution.nextPermutation([1,5,3])) # [1,3,5]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "32": "```\ndef longestValidParentheses(s):\n    n = len(s)\n    dp = [0] * (n + 1)\n    max_len = 0\n    for i in range(1, n):\n        if s[i-1] == '(':\n            dp[i] = 0\n        elif s[i-1] == ')':\n            if i - 2 >= 0 and s[i-2] == '(':\n                dp[i] = dp[i-2] + 2\n            elif i - 2 >= 0 and s[i-2] == ')' and i-dp[i-1]-1 >= 0 and s[i-dp[i-1]-1] == '(':\n                dp[i] = dp[i-1] + 2\n            else:\n                dp[i] = 0\n        max_len = max(max_len, dp[i])\n    return max_len\n\ndef main():\n    print(longestValidParentheses(\"(()\"))  # Output: 2\n    print(longestValidParentheses(\")()())\"))  # Output: 4\n    print(longestValidParentheses(\"(()())\"))  # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "33": "```\ndef search(nums, target):\n    if not nums:\n        return -1\n    \n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        \n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        else:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n    \n    return -1\n\n\ndef main():\n    test_case_1()\n    test_case_2()\n    test_case_3()\n\n\ndef test_case_1():\n    nums = [4, 5, 6, 7, 0, 1, 2]\n    target = 0\n    print(f\"Test case 1: {search(nums, target)}\")\n\n\ndef test_case_2():\n    nums = [1]\n    target = 0\n    print(f\"Test case 2: {search(nums, target)}\")\n\n\ndef test_case_3():\n    nums = [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0]\n    target = 5\n    print(f\"Test case 3: {search(nums, target)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "34": "```\ndef search_range(nums, target):\n    left = binary_search(nums, target)\n    \n    if left == -1:\n        return [-1, -1]\n    \n    right = binary_search(nums, target) - 1\n    while nums[right] != target:\n        right -= 1\n    \n    return [left, right]\n\ndef binary_search(nums, target):\n    left, right = 0, len(nums)\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    \n    return left if left < len(nums) and nums[left] == target else -1\n\ndef main():\n    test_cases = [\n        ([5,7,7,8,8,10], 8, [3,4]),\n        ([5,7,7,8,8,10], 6, [-1,-1]),\n        ([1,2], 2, [0,0])\n    ]\n\n    for nums, target, expected in test_cases:\n        result = search_range(nums, target)\n        print(f\"Test case: {nums} {target}, Expected: {expected}, Got: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "35": "```\ndef searchInsert(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\ndef main():\n    print(\"Test Case 1:\")\n    print(searchInsert([1,3,5,6], 5)) # Expected output: 2\n    print(\"\\nTest Case 2:\")\n    print(searchInsert([1,3,5,6], 2)) # Expected output: 1\n    print(\"\\nTest Case 3:\")\n    print(searchInsert([1,3,5,6], 7)) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "36": "```\ndef isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]\n\n    for i in range(9):\n        for j in range(9):\n            val = board[i][j]\n            if val == '.':\n                continue\n            k = (i // 3) * 3 + j // 3\n            if val in rows[i] or val in cols[j] or val in boxes[k]:\n                return False\n            rows[i].add(val)\n            cols[j].add(val)\n            boxes[k].add(val)\n\n    return True\n\ndef main():\n    print(isValidSudoku([[\"5\",\"6\",\".\",\".\",\"9\",\"8\",\".\",\".\",\".\"],\n                        [\"4\",\".\",\"8\",\"1\",\".\",\".\",\".\",\"6\",\"3\"],\n                        [\"7\",\".\",\".\",\".\",\"2\",\"5\",\"9\",\".\",\".\"],\n                        [\".\",\"9\",\"7\",\".\",\".\",\".\",\".\",\"1\",\".\"],\n                        [\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\".\"],\n                        [\".\",\".\",\".\",\".\",\"4\",\".\",\"8\",\".\",\".\"],\n                        [\".\",\".\",\"6\",\".\",\"7\",\".\",\".\",\".\",\"1\"],\n                        [\".\",\"7\",\".\",\"5\",\".\",\".\",\".\",\"9\",\".\"],\n                        [\".\",\".\",\".\",\"1\",\".\",\".\",\".\",\"7\",\".\"]]))\n\n    print(isValidSudoku([[\".\",\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"4\"],\n                         [\".\",\"3\",\".\",\".\",\".\",\".\",\".\",\"8\",\".\"],\n                         [\".\",\".\",\"9\",\"7\",\"5\",\".\",\".\",\".\",\".\"],\n                         [\".\",\"4\",\".\",\"2\",\"6\",\".\",\"3\",\".\",\".\"],\n                         [\"1\",\".\",\".\",\"5\",\"3\",\".\",\".\",\".\",\".\"],\n                         [\".\",\".\",\"6\",\"4\",\"2\",\".\",\"5\",\".\",\"8\"],\n                         [\"9\",\"8\",\".\",\"1\",\"6\",\".\",\"7\",\".\",\"3\"],\n                         [\".\",\"6\",\".\",\"7\",\"5\",\".\",\"4\",\".\",\".\"],\n                         [\".\",\"5\",\"4\",\"3\",\".\",\".\",\"8\",\".\",\".\"]]))\n\n    print(isValidSudoku([[\".\",\".\",\".\",\"2\",\"6\",\".\",\".\",\".\",\".\"],\n                         [\".\",\".\",\".\",\"1\",\"9\",\"8\",\".\",\"7\",\".\"],\n                         [\".\",\".\",\"8\",\".\",\".\",\".\",\".\",\"9\",\".\"],\n                         [\".\",\"5\",\".\",\"7\",\"2\",\".\",\"4\",\".\",\".\"],\n                         [\".\",\"7\",\".\",\"3\",\"1\",\".\",\"6\",\".\",\".\"],\n                         [\"1\",\"4\",\".\",\"5\",\"8\",\".\",\"2\",\".\",\".\"],\n                         [\".\",\"9\",\"7\",\".\",\".\",\".\",\".\",\"8\",\".\"],\n                         [\".\",\".\",\".\",\"4\",\"6\",\".\",\"3\",\".\",\".\"],\n                         [\".\",\"8\",\".\",\"1\",\"3\",\".\",\"5\",\".\",\".\"]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "37": "```\ndef solveSudoku(board):\n    def is_valid(board, row, col, num):\n        for x in range(9):\n            if board[row][x] == num:\n                return False\n        for x in range(9):\n            if board[x][col] == num:\n                return False\n        start_row = row - row % 3\n        start_col = col - col % 3\n        for i in range(3):\n            for j in range(3):\n                if board[i + start_row][j + start_col] == num:\n                    return False\n        return True\n\n    def solve(board):\n        for i in range(9):\n            for j in range(9):\n                if board[i][j] == 0:\n                    for num in range(1, 10):\n                        if is_valid(board, i, j, num):\n                            board[i][j] = num\n                            if solve(board):\n                                return True\n                            else:\n                                board[i][j] = 0\n                    return False\n        return True\n\n    def print_board(board):\n        for i in range(9):\n            if i % 3 == 0 and i != 0:\n                print(\"- - - - - - - - - - -\")\n            for j in range(9):\n                if j % 3 == 0 and j != 0:\n                    print(\" | \", end=\"\")\n                if j == 8:\n                    print(board[i][j])\n                else:\n                    print(str(board[i][j]) + \" \", end=\"\")\n\n    def main():\n        board1 = [\n            [5, 3, 4, 6, 7, 8, 9, 1, 2],\n            [6, 7, 2, 1, 9, 5, 3, 4, 8],\n            [1, 9, 8, 3, 4, 2, 5, 6, 7],\n            [8, 5, 9, 7, 6, 1, 4, 2, 3],\n            [4, 2, 6, 8, 5, 3, 7, 9, 1],\n            [7, 1, 3, 9, 2, 4, 8, 5, 6],\n            [9, 6, 1, 5, 3, 7, 2, 8, 4],\n            [2, 8, 4, 4, 1, 9, 6, 3, 5],\n            [3, 4, 5, 2, 8, 6, 1, 7, 9]\n        ]\n\n        board2 = [\n            [0, 0, 0, 0, 0, 0, 0, 0, 0],\n            [0, 3, 0, 0, 8, 5, 4, 0, 0],\n            [0, 0, 9, 7, 0, 0, 0, 0, 0],\n            [0, 2, 0, 0, 1, 0, 0, 0, 0],\n            [4, 0, 0, 0, 0, 3, 0, 9, 0],\n            [0, 5, 0, 6, 7, 0, 0, 0, 0],\n            [0, 9, 8, 0, 0, 0, 0, 4, 0],\n            [0, 0, 0, 3, 0, 2, 0, 0, 0],\n            [0, 1, 0, 0, 9, 0, 7, 0, 0]\n        ]\n\n        board3 = [\n            [8, 0, 0, 0, 3, 0, 0, 2, 0],\n            [0, 6, 0, 0, 0, 0, 0, 8, 1],\n            [0, 0, 7, 0, 9, 2, 0, 0, 0],\n            [4, 0, 0, 5, 0, 0, 3, 0, 0],\n            [0, 9, 8, 7, 0, 0, 1, 0, 2],\n            [0, 0, 3, 9, 0, 6, 0, 0, 0],\n            [2, 0, 0, 0, 1, 8, 5, 0, 0],\n            [0, 0, 0, 4, 0, 3, 0, 9, 6],\n            [0, 7, 0, 2, 0, 0, 9, 1, 8]\n        ]\n\n        print_board(solveSudoku(board1))\n        print()\n        print_board(solveSudoku(board2))\n        print()\n        print_board(solveSudoku(board3))\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "38": "```\ndef count_and_say(n):\n    if n == 1:\n        return '1'\n    prev = count_and_say(int(n - 1))\n    result = ''\n    i = 0\n    while i < len(prev):\n        count = 1\n        while i + 1 < len(prev) and prev[i] == prev[i + 1]:\n            i += 1\n            count += 1\n        result += str(count) + prev[i]\n        i += 1\n    return result\n\ndef main():\n    print(count_and_say(1))  # '1'\n    print(count_and_say(4))  # '1211'\n    print(count_and_say(6))  # '211213'\n\nif __name__ == '__main__':\n    main()\n```",
  "39": "```\ndef combinationSum(candidates, target):\n    def backtrack(remain, comb, start):\n        if remain == 0:\n            result.append(list(comb))\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] > remain:\n                break\n            comb.append(candidates[i])\n            backtrack(remain - candidates[i], comb, i)\n            comb.pop()\n\n    result = []\n    backtrack(target, [], 0)\n    return result\n\n\ndef main():\n    print(combinationSum([2,3,5], 8)) \n    print(combinationSum([2], 3))\n    print(combinationSum([1,2,7], 9))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "40": "```\ndef combinationSum2(candidates, target):\n    def dfs(start, path, remain):\n        if remain < 0:\n            return\n        if remain == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            if candidates[i] > remain:\n                break\n            dfs(i + 1, path + [candidates[i]], remain - candidates[i])\n\n    res = []\n    candidates.sort()\n    dfs(0, [], target)\n    return res\n\n\ndef main():\n    print(combinationSum2([10, 9], 20))  # [[10, 10], [9, 10, 1]]\n    print(combinationSum2([5, 3, 4], 8))  # [[4, 4], [3, 4, 1]]\n    print(combinationSum2([1, 2, 2, 7, 23, 23, 23], 6)  # [[2, 2, 2], [7]]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "41": "```\ndef firstMissingPositive(nums):\n    if not nums:\n        return 1\n\n    seen = set()\n    for num in nums:\n        if 1 <= num <= len(nums):\n            seen.add(num)\n\n    for i in range(1, len(nums) + 2):\n        if i not in seen:\n            return i\n\n    return len(nums) + 1\n\n\ndef main():\n    print(firstMissingPositive([3,4,7,8])) # Expected output: 1\n    print(firstMissingPositive([1,2,0])) # Expected output: 3\n    print(firstMissingPositive([1,5,6,4,7,8,3,2])) # Expected output: 9\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "42": "```\ndef trap(height):\n    if not height:\n        return 0\n\n    n = len(height)\n    left_max = [0] * n\n    right_max = [0] * n\n    res = 0\n\n    left_max[0] = height[0]\n    for i in range(1, n):\n        left_max[i] = max(left_max[i-1], height[i])\n    \n    right_max[n-1] = height[n-1]\n    for i in range(n-2, -1, -1):\n        right_max[i] = max(right_max[i+1], height[i])\n\n    for i in range(n):\n        res += max(0, min(left_max[i], right_max[i]) - height[i])\n    \n    return res\n\ndef main():\n    print(trap([0,1,0,2,1,0,1,3,2,1,2,1,0,2])) # 6\n    print(trap([4,2,0,2,4,1,2,0])) # 12\n    print(trap([])) # 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "43": "```\ndef multiply(num1, num2):\n    if '0' in num1 or '0' in num2:\n        return '0'\n    \n    result = [0] * (len(num1) + len(num2))\n    \n    for i in range(len(num1)):\n        for j in range(len(num2)):\n            result[i+j] += int(num1[i]) * int(num2[j])\n    \n    carry = 0\n    output = ''\n    for i in reversed(range(len(result))):\n        total = result[i] + carry\n        output = str(total % 10) + output\n        carry = total // 10\n        \n        if not output and carry:\n            output = '0' + output\n            \n    return '0' if carry else output\n\ndef main():\n    print(multiply(\"2\", \"3\")) # expected output: \"6\"\n    print(multiply(\"123\", \"456\")) # expected output: \"56088\"\n    print(multiply(\"99\", \"9\")) # expected output: \"891\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "44": "```\ndef isMatch(s: str, p: str) -> bool:\n    if not p:\n        return not s\n\n    first_match = bool(s) and p[0] in {s[0], '.'}\n    if len(p) >= 2 and p[1] == '*':\n        return (isMatch(s, p[2:]) or\n                first_match and isMatch(s[1:], p))\n    return first_match and isMatch(s[1:], p[1:])\n\ndef main():\n    print(isMatch(\"aa\", \"a\")) # False\n    print(isMatch(\"aa\", \"a*\")) # True\n    print(isMatch(\"abc\", \"c.*\")) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "45": "```\ndef jump(nums):\n    if not nums:\n        return 0\n\n    n = len(nums)\n    max_reach = 0\n    last_position = 0\n    jumps = 0\n\n    for i in range(n):\n        if i > last_position:\n            last_position = max_reach\n            jumps += 1\n        max_reach = max(max_reach, i + nums[i])\n\n    return jumps\n\n\ndef main():\n    print(\"Test case 1:\")\n    print(jump([2,3,1,1,4]))  # Expected output: 2\n\n    print(\"\\nTest case 2:\")\n    print(jump([2,1,1,1,0]))  # Expected output: 2\n\n    print(\"\\nTest case 3:\")\n    print(jump([0]))  # Expected output: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "46": "```\ndef permute(nums):\n    result = []\n    def backtrack(start, path):\n        if len(path) == len(nums):\n            result.append(path)\n            return\n        for i in range(start, len(nums)):\n            nums[i], nums[start] = nums[start], nums[i]\n            backtrack(start + 1, path + [nums[start]])\n            nums[i], nums[start] = nums[start], nums[i]\n\n    backtrack(0, [])\n    return result\n\n\ndef main():\n    print(permute([1, 2, 3]))\n    print(permute([0, 1]))\n    print(permute([1]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "47": "```\ndef permuteUnique(nums):\n    if not nums:\n        return []\n\n    res = []\n    nums.sort()\n\n    def backtrack(start, path):\n        if len(path) == len(nums):\n            res.append(path)\n            return\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i-1]:\n                continue\n            if nums[i] not in path:\n                backtrack(i+1, path + [nums[i]])\n\n    backtrack(0, [])\n    return res\n\ndef main():\n    test_cases = [\n        ([1, 1, 2], [[1, 1, 2], [1, 2, 1], [2, 1, 1]]),\n        (['A', 'B', 'C'], [['A', 'B', 'C'], ['A', 'C', 'B'], ['B', 'A', 'C'], ['B', 'C', 'A'],\n                             ['C', 'A', 'B'], ['C', 'B', 'A']]),\n        ([-1, 0], [[-1, 0], [0, -1]])\n    ]\n\n    for i, test_case in enumerate(test_cases):\n        print(f\"Test case {i+1}:\")\n        result = permuteUnique(test_case[0])\n        expected_result = test_case[1]\n        if result == expected_result:\n            print(\"Pass\")\n        else:\n            print(f\"Fail: Expected {expected_result}, got {result}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "48": "```\ndef rotate(matrix):\n    return [list(x) for x in zip(*matrix)][::-1]\n\ndef main():\n    print(\"Test case 1:\")\n    matrix = [[1, 2], [3, 4]]\n    expected_result = [[3, 1], [4, 2]]\n    result = rotate(matrix)\n    if result == expected_result:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n    print(\"\\nTest case 2:\")\n    matrix = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]\n    expected_result = [[0, 0, 0], [0, 0, 0], [1, 0, 0]]\n    result = rotate(matrix)\n    if result == expected_result:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n    print(\"\\nTest case 3:\")\n    matrix = [[5, 0, 8, 2], [9, 6, 4, 7], [3, 1, 2, 10], [1, 3, 5, 7]]\n    expected_result = [[3, 1, 2, 10], [1, 3, 5, 7], [9, 6, 4, 7], [5, 0, 8, 2]]\n    result = rotate(matrix)\n    if result == expected_result:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "49": "```\ndef groupAnagrams(strs):\n    anagrams = {}\n    for s in strs:\n        sorted_str = \"\".join(sorted(s))\n        if sorted_str in anagrams:\n            anagrams[sorted_str].append(s)\n        else:\n            anagrams[sorted_str] = [s]\n    return list(anagrams.values())\n\ndef main():\n    print(groupAnagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]))\n    print(groupAnagrams([\"\"]))\n    print(groupAnagrams([\"a\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "50": "```\ndef myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    elif n < 0:\n        return 1 / myPow(x, -n)\n    elif n % 2 == 0:\n        half_pow = myPow(x, n // 2)\n        return half_pow * half_pow\n    else:\n        return x * myPow(x, n - 1)\n\n\ndef main():\n    print(\"Test Case 1: \")\n    print(myPow(2.0, 10) == 1024.0)\n\n    print(\"\\nTest Case 2: \")\n    print(myPow(-3.0, 2) == 9.0)\n\n    print(\"\\nTest Case 3: \")\n    print(myPow(1.00000, 4) == 1.0)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "51": "```\ndef solveNQueens(n):\n    def place_queens(board, row):\n        if row == n:\n            result.append(board[:])\n            return\n        for col in range(n):\n            valid = True\n            for i in range(row):\n                if board[i] == col or \\\n                   abs(i - row) == abs(col - n):\n                    valid = False\n                    break\n            if valid:\n                board[row] = col\n                place_queens(board, row + 1)\n\n    result = []\n    place_queens([-1]*n, 0)\n    return [[\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] \n            for sol in result]\n\ndef main():\n    print(solveNQueens(4))\n\nmain()\n\n# Test cases\nprint(solveNQueens(1))\nprint(solveNQueens(2))\nprint(solveNQueens(3))\n```",
  "52": "```\ndef totalNQueens(n):\n    def is_valid(board, row, col):\n        for i in range(row):\n            if board[i] == col or \\\n               board[i] - i == col - row or \\\n               board[i] + i == col + row:\n                return False\n        return True\n\n    def place_queens(board, row):\n        if row == n:\n            result.append(board[:])\n            return\n\n        for col in range(n):\n            if is_valid(board, row, col):\n                board[row] = col\n                place_queens(board, row + 1)\n\n    result = []\n    place_queens([-1]*n, 0)\n    return len(result)\n\ndef main():\n    print(totalNQueens(4)) # Expected output: 2\n    print(totalNQueens(3)) # Expected output: 2\n    print(totalNQueens(8)) # Expected output: 92\n\nif __name__ == \"__main__\":\n    main()\n```",
  "53": "```\ndef maxSubArray(nums):\n    if not nums:\n        return 0\n    \n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for num in nums:\n        current_sum = max(num, current_sum + num)\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\ndef main():\n    print(\"Test case 1:\")\n    print(maxSubArray([-2,1,-3,4,-1,2,1,-5,4])) # Expected output: 6\n    print(\"\\n\")\n\n    print(\"Test case 2:\")\n    print(maxSubArray([1])) # Expected output: 1\n    print(\"\\n\")\n\n    print(\"Test case 3:\")\n    print(maxSubArray([-1])) # Expected output: -1\n    print(\"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "54": "```\ndef spiralMatrix(matrix):\n    if not matrix:\n        return []\n\n    R, C = len(matrix), len(matrix[0])\n    seen = [[False] * C for _ in range(R)]\n    answer = []\n    \n    top, bottom, left, right = 0, R - 1, 0, C - 1\n    while True:\n        if left > right or top > bottom:\n            break\n        \n        for i in range(left, right + 1):\n            answer.append(matrix[top][i])\n            seen[top][i] = True\n            \n        top += 1\n\n        if left > right or top > bottom:\n            break\n        \n        for i in range(top, bottom + 1):\n            answer.append(matrix[i][right])\n            seen[i][right] = True\n            \n        right -= 1\n\n        if left > right or top > bottom:\n            break\n        \n        for i in range(right, left - 1, -1):\n            answer.append(matrix[bottom][i])\n            seen[bottom][i] = True\n            \n        bottom -= 1\n\n        if left > right or top > bottom:\n            break\n        \n        for i in range(bottom, top - 1, -1):\n            answer.append(matrix[i][left])\n            seen[i][left] = True\n            \n        left += 1\n    \n    return answer\n\n\ndef main():\n    print(spiralMatrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]))\n    print(spiralMatrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]))\n    print(spiralMatrix([[1]]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "55": "```\ndef canJump(nums):\n    maxReach = 0\n    for i, num in enumerate(nums):\n        if i > maxReach:\n            return False\n        maxReach = max(maxReach, i + num)\n    return True\n\ndef main():\n    print(canJump([2,3,1,1,4])) # Expected: True\n    print(canJump([3,2,1,0,4])) # Expected: False\n    print(canJump([2,5,3,9])) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "56": "```\ndef merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort(key=lambda x: x[0])\n\n    merged = [intervals[0]]\n    for interval in intervals[1:]:\n        if merged[-1][1] >= interval[0]:\n            merged[-1] = (merged[-1][0], max(merged[-1][1], interval[1]))\n        else:\n            merged.append(interval)\n\n    return merged\n\ndef main():\n    print(merge([[1,3],[2,6],[8,10],[15,18]])) # Expected output: [[1,6],[8,10],[15,18]]\n    print(merge([[1,4],[4,5]])) # Expected output: [[1,5]]\n    print(merge([]))) # Expected output: []\n    print(merge([[1,2]])) # Expected output: [[1,2]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "57": "```\ndef insert(intervals, newInterval):\n    result = []\n    i = 0\n\n    for interval in intervals:\n        if interval[1] < newInterval[0]:\n            result.append(interval)\n        elif interval[0] <= newInterval[1]:\n            newInterval[0] = min(newInterval[0], interval[0])\n            newInterval[1] = max(newInterval[1], interval[1])\n        else:\n            if i == 0:\n                newInterval[0] = min(newInterval[0], interval[0])\n                newInterval[1] = max(newInterval[1], interval[1])\n            result.append(interval)\n            i += 1\n\n    result.append(newInterval)\n\n    for interval in intervals[i:]:\n        if result[-1][1] < interval[0]:\n            result.append(interval)\n        else:\n            result[-1][1] = max(result[-1][1], interval[1])\n\n    return result\n\n\ndef main():\n    test_cases = [\n        ([1, 3, 5, 6], [2, 7], [[1, 2], [3, 5], [6, 7]]),\n        ([-2147483648, 2147483647], [-1000, -1000], [[-1000, -1000], [-2147483648, 2147483647]]),\n        (([-10, 20], [5, 30], [[-10, 30]])),\n    ]\n\n    for test_case in test_cases:\n        intervals = test_case[0]\n        new_interval = test_case[1]\n        expected_result = test_case[2]\n\n        result = insert(intervals, new_interval)\n        print(f\"Test Case: {intervals}, {new_interval} -> {result}\")\n        if result == expected_result:\n            print(\"PASS\")\n        else:\n            print(\"FAIL\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "58": "```\ndef lengthOfLastWord(s):\n    return len(s.split(\" \")[-1])\n\ndef main():\n    print(lengthOfLastWord(\"Hello World\")) \n    print(lengthOfLastWord(\"   fly me   to   the moon  \")) \n    print(lengthOfLastWord(\"zero\"))\n\nmain()\n```",
  "60": "```\ndef getPermutation(n, k):\n    factors = [1]\n    for i in range(2, n+1):\n        factors.append(factors[-1] * i)\n    ans = \"\"\n    nums = list(range(1, n+1))\n    k -= 1\n    while n > 0:\n        idx = k // factors[n-1]\n        k %= factors[n-1]\n        ans += str(nums[idx])\n        del nums[idx]\n        n -= 1\n    return \"0\" if not ans else ans\n\ndef main():\n    print(getPermutation(3, 5)) # Expected: \"251\"\n    print(getPermutation(4, 24)) # Expected: \"9432\"\n    print(getPermutation(6, 5000)) # Expected: \"254329\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "59": "```\ndef generateMatrix(n):\n    result = [[0 for _ in range(n)] for _ in range(n)]\n    left, right, up, down = 0, n-1, 0, n-1\n    direction = [(0,1),(1,0),(0,-1),(-1,0)]\n\n    for _ in range(n*n):\n        if (left <= right and \n            all(result[i][left] != 1 for i in range(up,down+1))):\n            for i in range(up,down+1):\n                result[i][left] = 1\n            left += 1\n\n        elif (up <= down and \n             all(result[j][right] != 1 for j in range(left,right+1))):\n            for j in range(left,right+1):\n                result[down][j] = 1\n            down -= 1\n\n        elif (left <= right and \n              all(result[i][right] != 1 for i in range(down,up-1,-1))):\n            for i in range(down, up-1, -1):\n                result[i][right] = 1\n            right -= 1\n\n        else:\n            for j in range(left, right+1):\n                result[up][j] = 1\n            up += 1\n\n    return result\n\ndef main():\n    test_cases = [\n        {\"n\": 3},\n        {\"n\": 5},\n        {\"n\": 10}\n    ]\n\n    for test_case in test_cases:\n        n = test_case[\"n\"]\n        print(f\"Spiral Matrix II with n={n}:\")\n        print(generateMatrix(n))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "61": "```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef rotateRight(head: ListNode, k: int) -> ListNode:\n    if not head:\n        return None\n\n    old_tail = head\n    n = 1\n    while old_tail.next:\n        old_tail = old_tail.next\n        n += 1\n    old_tail.next = head\n\n    new_tail = head\n    for i in range(n - k % n - 1):\n        new_tail = new_tail.next\n    new_head = new_tail.next\n\n    new_tail.next = None\n\n    return new_head\n\n\ndef main():\n    # Test case 1\n    head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))\n    print(\"Test case 1: \")\n    print(\"Input: \", end=\"\")\n    rotateRight(head1, 2).printList()\n    print()\n\n    # Test case 2\n    head2 = ListNode(0, ListNode(1, ListNode(2)))\n    print(\"Test case 2: \")\n    print(\"Input: \", end=\"\")\n    rotateRight(head2, 4).printList()\n    print()\n\n    # Test case 3\n    head3 = ListNode(1)\n    print(\"Test case 3: \")\n    print(\"Input: \", end=\"\")\n    rotateRight(head3, 7).printList()\n    print()\n\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n    def printList(self):\n        node = self\n        while node:\n            print(node.val, end=\" \")\n            node = node.next\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "62": "```\ndef uniquePaths(m, n):\n    dp = [[1] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                \n    return dp[m][n]\n\n\ndef main():\n    print(uniquePaths(3, 7))\n    print(uniquePaths(5, 10))\n    print(uniquePaths(2, 2))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "63": "```\ndef uniquePathsWithObstacles(obstacleGrid):\n    if not obstacleGrid or len(obstacleGrid[0]) == 0:\n        return []\n\n    m, n = len(obstacleGrid), len(obstacleGrid[0])\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n        if obstacleGrid[i][0]:\n            break\n        dp[i][0] = 1\n\n    for j in range(1, n):\n        if obstacleGrid[0][j]:\n            break\n        dp[0][j] = 1\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if not obstacleGrid[i][j]:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return [sum(1 for x in row if x) for row in dp]\n\n\ndef main():\n    print(uniquePathsWithObstacles([[0,0],[0,1],[0,0]]))  # Output: 2\n    print(uniquePathsWithObstacles([[0,1],[0,0]]))  # Output: 1\n    print(uniquePathsWithObstacles([[0,0,0],[0,1,0],[0,0,0]]))  # Output: 6\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "64": "```\ndef minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n    for i in range(1, n):\n        grid[0][i] += grid[0][i-1]\n    for i in range(1, m):\n        grid[i][0] += grid[i-1][0]\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    return grid[-1][-1]\n\ndef main():\n    test_cases = [\n        {\"grid\": [[1,3,1],[1,5,1],[4,2,1]], \"expected_output\": 7},\n        {\"grid\": [[2]], \"expected_output\": 2},\n        {\"grid\": [[1,3,1],[6,5,4],[2,1,1]], \"expected_output\": 12}\n    ]\n\n    for test_case in test_cases:\n        output = minPathSum(test_case[\"grid\"])\n        if output == test_case[\"expected_output\"]:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected {test_case['expected_output']}, but got {output}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "65": "```\ndef isNumber(s):\n    if s == '':\n        return False\n    s = s.strip()\n    if s[0] in ['-', '+']:\n        s = s[1:]\n    if not s:\n        return False\n    i = 0\n    while i < len(s) and s[i].isdigit():\n        i += 1\n    if s[:i] == '':\n        return False\n    if i < len(s) and (s[i] in ['.', 'e', 'E']):\n        if i == len(s) - 1:\n            return False\n        i += 1\n        while i < len(s):\n            if not (s[i].isdigit() or s[i] in ['.', 'e', 'E']):\n                return False\n            i += 1\n    else:\n        return False\n\ndef main():\n    print(isNumber(\"0\") == True)\n    print(isNumber(\"0123\") == True)\n    print(isNumber(\".1234\") == True)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "66": "```\ndef plusOne(digits):\n    for i in range(len(digits) - 1, -1, -1):\n        if digits[i] < 9:\n            return [x + 1 for x in digits]\n        else:\n            digits[i] = 0\n    return [1] + digits\n\ndef main():\n    print(\"Test Case 1:\")\n    print(plusOne([1,2,3])) # Expected output: [1,2,4]\n\n    print(\"\\nTest Case 2:\")\n    print(plusOne([4,3,2,9])) # Expected output: [4,3,3,0]\n\n    print(\"\\nTest Case 3:\")\n    print(plusOne([0])) # Expected output: [1]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "67": "```\ndef addBinary(a, b):\n    return bin(int(a, 2) + int(b, 2))[2:]\n\ndef main():\n    print(addBinary(\"11\", \"1\") == \"100\")\n    print(addBinary(\"1010\", \"1011\") == \"10101\")\n    print(addBinary(\"1111\", \"10\") == \"10001\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "68": "```\ndef full_justify(text: str, width: int) -> str:\n    lines = text.split('\\n')\n    res = []\n    i = 0\n    while i < len(lines):\n        line = ''\n        length = 0\n        while i < len(lines) and length + len(lines[i]) + 1 <= width:\n            line += lines[i] + ' '\n            length += len(lines[i]) + 1\n            i += 1\n        if i < len(lines):\n            line += lines[i]\n        res.append(line.strip())\n    for i in range(1, len(res) - 1):\n        words = res[i].split()\n        left_spaces = width - len(' '.join(words)) - len(words)\n        right_spaces = (width - len(' '.join(words))) // (len(words) - 1)\n        left_spaces += ((width - len(' '.join(words))) % (len(words) - 1))\n        res[i] = words[0] + ' ' * left_spaces\n        for j in range(1, len(words)):\n            res[i] += words[j]\n            if j < len(words) - 1:\n                res[i] += ' ' * right_spaces\n    return '\\n'.join(res)\n\ndef main():\n    print(full_justify(\"This is an example sentence. It has several words. The words are separated by spaces.\", 16))\n    print(full_justify(\"Lorem ipsum dolor sit amet. Consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\", 30))\n    print(full_justify(\"One two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty\", 20))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "69": "```\ndef mySqrt(x):\n    if x < 2:\n        return x\n    left, right = 1, x\n    while left <= right:\n        mid = (left + right) // 2\n        if mid * mid == x:\n            return mid\n        elif mid * mid < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n\ndef main():\n    print(mySqrt(9)) # Expected output: 3\n    print(mySqrt(8)) # Expected output: 2\n    print(mySqrt(16)) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "70": "```\ndef climbStairs(n):\n    if n <= 2:\n        return n\n    dp = [0] * (n + 1)\n    dp[1], dp[2] = 1, 2\n    for i in range(3, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n    return dp[n]\n\ndef main():\n    print(\"Test case 1:\", climbStairs(2))\n    print(\"Test case 2:\", climbStairs(3))\n    print(\"Test case 3:\", climbStairs(4))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "71": "```\ndef simplifyPath(path):\n    stack = []\n    for p in path.split(\"/\"):\n        if p == \"\" or p == \".\":\n            continue\n        elif p == \"..\":\n            if stack:\n                stack.pop()\n        else:\n            stack.append(p)\n    return \"/\" + \"/\".join(stack)\n\ndef main():\n    print(simplifyPath(\"/home/\"))  # Output: /home\n    print(simplifyPath(\"/a/./b/../../c/\"))  # Output: /c\n    print(simplifyPath(\"/home//foo/\"))  # Output: /home/foo\n\nif __name__ == \"__main__\":\n    main()\n```",
  "72": "```\ndef minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            cost = 0 if word1[i - 1] == word2[j - 1] else 1\n            dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost)\n\n    return dp[m][n]\n\ndef main():\n    print(minDistance(\"horse\", \"ros\")) # Expected output: 3\n    print(minDistance(\"\", \"apple\")) # Expected output: 5\n    print(minDistance(\"a\", \"b\")) # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "73": "```\ndef setZeroes(matrix):\n    m, n = len(matrix), len(matrix[0])\n    rows, cols = set(), set()\n    \n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                rows.add(i)\n                cols.add(j)\n\n    for i in range(m):\n        for j in range(n):\n            if i in rows or j in cols:\n                matrix[i][j] = 0\n\ndef main():\n    test_cases = [\n        {\n            \"matrix\": [[1,1,1],[1,0,1],[1,1,1]],\n            \"expected_output\": [[1,0,1],[0,0,0],[1,0,1]]\n        },\n        {\n            \"matrix\": [[0,1,2,0],[3,4,5,2],[1,3,1,5]],\n            \"expected_output\": [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n        },\n        {\n            \"matrix\": [[1,2,3],[4,0,5],[6,7,8]],\n            \"expected_output\": [[1,0,3],[0,0,0],[0,7,0]]\n        }\n    ]\n\n    for test_case in test_cases:\n        matrix = [row[:] for row in test_case[\"matrix\"]]\n        setZeroes(matrix)\n        print(\"Input Matrix: \")\n        for row in matrix:\n            print(row)\n        print(\"\\nExpected Output:\")\n        for row in test_case[\"expected_output\"]:\n            print(row)\n        print(\"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "74": "```\ndef searchMatrix(matrix, target):\n    if not matrix or not matrix[0]:\n        return False\n    \n    row = 0\n    col = len(matrix[0]) - 1\n    \n    while row < len(matrix) and col >= 0:\n        if matrix[row][col] == target:\n            return True\n        \n        if matrix[row][col] > target:\n            col -= 1\n        else:\n            row += 1\n    \n    return False\n\n\ndef main():\n    test_cases = [\n        {\"matrix\": [[1,3,5,7],[10,11,16,20],[23,30,34,50]], \"target\": 3},\n        {\"matrix\": [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]], \"target\": 14},\n        {\"matrix\": [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]], \"target\": 20}\n    ]\n    \n    for test_case in test_cases:\n        matrix = test_case[\"matrix\"]\n        target = test_case[\"target\"]\n        print(f\"Matrix: {matrix}, Target: {target}, Result: {searchMatrix(matrix, target)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "75": "```\ndef sort_colors(nums):\n    low = 0\n    high = len(nums) - 1\n    curr = 0\n    \n    while curr <= high:\n        if nums[curr] == 0:\n            nums[low], nums[curr] = nums[curr], nums[low]\n            low += 1\n            curr += 1\n        elif nums[curr] == 2:\n            nums[curr], nums[high] = nums[high], nums[curr]\n            high -= 1\n        else:\n            curr += 1\n\ndef main():\n    test_cases = [\n        [0, 1, 2],\n        [2, 0, 1],\n        [1, 0, 2],\n    ]\n\n    for test_case in test_cases:\n        print(f\"Input: {test_case}\")\n        sort_colors(test_case)\n        print(f\"Output: {test_case}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "76": "```\ndef minWindow(s, t):\n    if not s or not t:\n        return \"\"\n\n    dict_t = {}\n    for char in t:\n        if char in dict_t:\n            dict_t[char] += 1\n        else:\n            dict_t[char] = 1]\n\n    required_chars = len(dict_t)\n\n    left, right = 0, 0\n\n    formed_chars = 0\n\n    window_counts = {}\n\n    ans = float(\"inf\"), None, None\n\n    while right < len(s):\n        character = s[right]\n        window_counts[character] = window_counts.get(character, 0) + 1\n        if character in dict_t and window_counts[character] == dict_t[character]:\n            formed_chars += 1\n\n        while left <= right and formed_chars == required_chars:\n            character = s[left]\n\n            if right - left + 1 < ans[0]:\n                ans = (right - left + 1, left, right)\n\n            window_counts[character] -= 1\n            if character in dict_t and window_counts[character] < dict_t[character]:\n                formed_chars -= 1\n\n            left += 1\n\n        right += 1\n\n    return \"\" if ans[0] == float(\"inf\") else s[ans[1]:ans[2]+1]\n\ndef main():\n    print(minWindow(\"ADOBECODEBANC\", \"ABC\")) \n    print(minWindow(\"a\", \"a\"))  \n    print(minWindow(\"aa\", \"aa\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "77": "```\ndef combine(n, k):\n    def backtrack(start, path):\n        if len(path) == k:\n            result.append(path)\n            return\n        for i in range(start, n+1):\n            backtrack(i + 1, path + [i])\n\n    result = []\n    backtrack(1, [])\n    return result\n\ndef main():\n    print(combine(4, 2)) # [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\n    print(combine(7, 3)) # [[1,2,3],[1,2,4],[1,2,5],[1,2,6],[1,2,7],[1,3,4],[1,3,5],[1,3,6],[1,3,7],[1,4,5],[1,4,6],[1,4,7],[1,5,6],[1,5,7],[1,6,7],[2,3,4],[2,3,5],[2,3,6],[2,3,7],[2,4,5],[2,4,6],[2,4,7],[2,5,6],[2,5,7],[2,6,7],[3,4,5],[3,4,6],[3,4,7],[3,5,6],[3,5,7],[3,6,7],[4,5,6],[4,5,7],[4,6,7],[5,6,7]]\n    print(combine(9, 5)) # [[1,2,3,4,5],[1,2,3,6,7],[1,2,3,8,9],[1,2,4,5,6],[1,2,4,7,8],[1,2,4,9,9],[1,3,4,5,6],[1,3,4,7,8],[1,3,5,6,7],[1,3,5,8,9],[1,4,5,6,7],[1,4,5,8,9],[1,6,7,8,9],[2,3,4,5,6],[2,3,4,7,8],[2,3,5,6,7],[2,3,5,8,9],[2,4,5,6,7],[2,4,5,8,9],[2,6,7,8,9],[3,4,5,6,7],[3,4,5,8,9],[3,6,7,8,9],[4,5,6,7,8],[4,5,6,9,9],[4,7,8,9,9],[5,6,7,8,9]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "78": "```\ndef subsets(nums):\n    res = [[]]\n    for num in nums:\n        res += [curr + [num] for curr in res]\n    return res\n\n\ndef main():\n    print(subsets([1,2,3]))\n    print(subsets([0]))\n    print(subsets([1, 2, 3, 4]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "79": "```\ndef exist(board, word):\n    rows, cols = len(board), len(board[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(r, c, i):\n        if i == len(word):\n            return True\n        if r < 0 or r >= rows or c < 0 or c >= cols or word[i] != board[r][c]:\n            return False\n        temp = board[r][c]\n        board[r][c] = '#'\n        for dr, dc in directions:\n            if dfs(r + dr, c + dc, i + 1):\n                return True\n        board[r][c] = temp\n        return False\n\n    for r in range(rows):\n        for c in range(cols):\n            if dfs(r, c, 0):\n                return True\n    return False\n\n\ndef main():\n    test_cases = [\n        {\"board\": [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"word\": \"ABCCED\", \"expected\": True},\n        {\"board\": [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"word\": \"SEE\", \"expected\": True},\n        {\"board\": [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], \"word\": \"ECSE\", \"expected\": False}\n    ]\n\n    for test_case in test_cases:\n        board = test_case[\"board\"]\n        word = test_case[\"word\"]\n        expected = test_case[\"expected\"]\n        result = exist(board, word)\n        if result == expected:\n            print(f\"Test case {test_case} passed!\")\n        else:\n            print(f\"Test case {test_case} failed!\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "80": "```\ndef removeDuplicates(nums):\n    if not nums:\n        return 0\n    i = 1\n    for j in range(1, len(nums)):\n        if nums[j] != nums[j-1]:\n            nums[i] = nums[j]\n            i += 1\n    return i\n\ndef main():\n    print(\"Test case 1:\")\n    nums = [1,1,2]\n    expected = 2\n    result = removeDuplicates(nums)\n    if result == expected:\n        print(\"PASS\")\n    else:\n        print(\"FAIL\")\n\n    print(\"\\nTest case 2:\")\n    nums = [1,1,1,2,3]\n    expected = 4\n    result = removeDuplicates(nums)\n    if result == expected:\n        print(\"PASS\")\n    else:\n        print(\"FAIL\")\n\n    print(\"\\nTest case 3:\")\n    nums = [0,0,1,1,1,2,3,3]\n    expected = 6\n    result = removeDuplicates(nums)\n    if result == expected:\n        print(\"PASS\")\n    else:\n        print(\"FAIL\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "81": "```\ndef search(nums, target):\n    if not nums:\n        return -1\n\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n\n        # The array is rotated at the left edge\n        if nums[left] <= nums[mid]:\n            if nums[left] <= target < nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        # The array is rotated at the right edge\n        elif nums[mid] <= nums[right]:\n            if nums[mid] < target <= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        # The target must be on the unrotated part of the array\n        else:\n            if target < nums[left]:\n                right = mid - 1\n            elif target > nums[right]:\n                left = mid + 1\n            else:\n                return mid\n\n    return -1\n\n\ndef main():\n    print(search([2,5,6], 5))  # Expected: 1\n    print(search([2,5,6], 0))  # Expected: -1\n    print(search([2,5,6], 7))  # Expected: -1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "82": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef deleteDuplicates(head):\n    dummy = ListNode(0)\n    current = dummy\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            head = head.next\n        else:\n            current.next = head\n            current = current.next\n        head = head.next if head.next else None\n    return dummy.next\n\ndef main():\n    test_case1()\n    test_case2()\n    test_case3()\n\ndef test_case1():\n    # Test case 1: Single element list with no duplicates\n    node1 = ListNode(1)\n    print(\"Test case 1:\", deleteDuplicates(node1))\n\ndef test_case2():\n    # Test case 2: List with some duplicates\n    node1 = ListNode(1)\n    node2 = ListNode(1)\n    node3 = ListNode(2)\n    node4 = ListNode(3)\n    node5 = ListNode(3)\n    node6 = ListNode(3)\n    node7 = ListNode(4)\n    node8 = ListNode(5)\n    head = node1\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    node5.next = node6\n    node6.next = node7\n    node7.next = node8\n    print(\"Test case 2:\", deleteDuplicates(head))\n\ndef test_case3():\n    # Test case 3: Empty list\n    print(\"Test case 3:\", deleteDuplicates(None))\n    \nif __name__ == \"__main__\":\n    main()\n```",
  "83": "```\ndef deleteDuplicates(head):\n    dummy = ListNode(0)\n    curr = dummy\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            curr.next = head.next\n        else:\n            curr.next = head\n        head = head.next\n    return dummy.next\n\ndef printList(head):\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\ndef main():\n    test1()\n    test2()\n    test3()\n\ndef test1():\n    head = ListNode(1)\n    head.next = ListNode(1)\n    head.next.next = ListNode(2)\n    printList(deleteDuplicates(head))\n\ndef test2():\n    head = ListNode(1)\n    head.next = ListNode(1)\n    head.next.next = ListNode(1)\n    head.next.next.next = ListNode(2)\n    printList(deleteDuplicates(head))\n\ndef test3():\n    head = ListNode(1)\n    head.next = ListNode(2)\n    head.next.next = ListNode(3)\n    printList(deleteDuplicates(head))\n```",
  "84": "```\ndef largestRectangleArea(heights):\n    stack = []\n    max_area = 0\n    i = 0\n    \n    while i < len(heights):\n        if not stack or heights[i] >= heights[stack[-1]]:\n            stack.append(i)\n            i += 1\n        else:\n            top = stack.pop()\n            width = i if not stack else i - stack[-1] - 1\n            max_area = max(max_area, widths[top] * width)\n    \n    while stack:\n        top = stack.pop()\n        width = i if not stack else len(heights) - stack[-1] - 1\n        max_area = max(max_area, heights[top] * width)\n    \n    return max_area\n\ndef main():\n    print(\"Test case 1:\")\n    print(largestRectangleArea([2,1,5,6,2,3])) # Should print 10\n    \n    print(\"\\nTest case 2:\")\n    print(largestRectangleArea([2,4])) # Should print 4\n    \n    print(\"\\nTest case 3:\")\n    print(largestRectangleArea([1,3,5,7,9])) # Should print 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "85": "```\ndef maximalRectangle(s):\n    if not s:\n        return 0\n\n    m = [[0] for _ in range(len(s[0]))]\n    max_area = 0\n    for row in zip(*s):\n        for i, c in enumerate(row):\n            if c == '1':\n                m[i].append(m[i][-1]+1)\n            else:\n                m[i].append(0)\n        stack = []\n        for j in range(len(m[0])):\n            while stack and m[stack[-1]][j] < m[~0][j]:\n                h = m[stack.pop()][j]\n                w = j if not stack else j - 1 - stack[-1]\n                max_area = max(max_area, h*w)\n            stack.append(j)\n        while stack:\n            h = m[stack.pop()][j]\n            w = j+1 if not stack else len(m[0]) - 1 - stack[-1]\n            max_area = max(max_area, h*w)\n\n    return max_area\n\ndef main():\n    print(maximalRectangle([[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"0\",\"0\"]]))  # Output: 6\n    print(maximalRectangle([[\"1\"]]))  # Output: 1\n    print(maximalRectangle([])))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "86": "```\ndef partition(head, x):\n    before = before_head = ListNode(0)\n    after = after_head = ListNode(0)\n    while head:\n        if head.val < x:\n            before_head = before_head.next = ListNode(head.val)\n            before = before\n        else:\n            after_head = after_head.next = ListNode(head.val)\n            after = after\n        head = head.next\n    return before_head, after\n\ndef printList(head):\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\ndef main():\n    # Test case 1\n    head1 = ListNode(1)\n    head1.next = ListNode(4)\n    head1.next.next = ListNode(3)\n    head1.next.next.next = ListNode(2)\n    head1.next.next.next.next = ListNode(5)\n    head1, _ = partition(head1, 3)\n    print(\"Test case 1: \")\n    printList(head1)\n\n    # Test case 2\n    head2 = ListNode(1)\n    head2.next = ListNode(2)\n    head2.next.next = ListNode(2)\n    head2.next.next.next = ListNode(1)\n    _, head2 = partition(head2, 2)\n    print(\"Test case 2: \")\n    printList(head2)\n\n    # Test case 3\n    head3 = ListNode(0)\n    head3 = ListNode(1)\n    head3.next = ListNode(3)\n    head3.next.next = ListNode(4)\n    head3.next.next.next = ListNode(2)\n    head3, _ = partition(head3, 1)\n    print(\"Test case 3: \")\n    printList(head3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "87": "```\ndef scrambleString(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    \n    n = len(s1)\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(n + 1):\n        dp[i][i] = True\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length\n            if s1[i] == s2[0]:\n                if s1[i:j] == s2[:length]:\n                    dp[i][j] = True\n                else:\n                    dp[i][j] = False\n            elif dp[i+1][j-1]:\n                dp[i][j] = True\n    \n    return dp[0][n - 1]\n\n\ndef main():\n    print(scrambleString(\"rkqlefbjanccocaslosidlefpoo\", \"polpoolefnis\"))\n    print(scrambleString(\"abcwxyz\", \"zxywwabc\"))\n    print(scrambleString(\"hello\", \"hholloe\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "88": "```\ndef mergeSortedArray(arr1, arr2):\n    result = []\n    i = j = 0\n    \n    while i < len(arr1) and j < len(arr2):\n        if arr1[i] <= arr2[j]:\n            result.append(arr1[i])\n            i += 1\n        else:\n            result.append(arr2[j])\n            j += 1\n            \n    result.extend(arr1[i:])\n    result.extend(arr2[j:])\n    \n    return result\n\ndef main():\n    print(mergeSortedArray([1, 2], [3]))  # Expected: [1, 2, 3]\n    print(mergeSortedArray([0, 1, 2, 3], []))  # Expected: [0, 1, 2, 3]\n    print(mergeSortedArray([1], [2, 3, 4]))  # Expected: [1, 2, 3, 4]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "89": "```\ndef grayCode(n):\n    res = []\n    for i in range(2**n):\n        res.append((i>>1)^i)\n    return ['0' if j < (2**n)//2 else '1' + c for j, c in enumerate(bin(res)[2:])]\n\ndef main():\n    print(grayCode(2)) # Test case 1\n    print(grayCode(3)) # Test case 2\n    print(grayCode(4)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "90": "```\ndef subsetsWithDup(nums):\n    def backtrack(start, path):\n        res.append(path)\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            (path + [nums[i]]).sort()\n            backtrack(i + 1, path + [nums[i]])\n\n    res = []\n    backtrack(0, [])\n    return res\n\ndef main():\n    print(subsetsWithDup([4,4,4])) # [[], [4], [4, 4], [4, 4, 4]]\n    print(subsetsWithDup([1,2,2])) # [[], [1], [1, 2], [1, 2, 2], [1, 2, 2]]\n    print(subsetsWithDup([])) # []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "91": "```\ndef numDecodings(s):\n    if not s or s[0] == '0':\n        return 0\n    \n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        if s[i-1] != '0':\n            dp[i] += dp[i-1]\n        if i >= 2 and '10' <= s[i-2:i] <= '26':\n            dp[i] += dp[i-2]\n\ndef main():\n    print(numDecodings(\"12\")) # Output: 2\n    print(numDecodings(\"226\")) # Output: 3\n    print(numDecodings(\"0\"))   # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "93": "```\ndef restoreIpAddresses(s):\n    def backtrack(start, path):\n        if len(path) == 4:\n            if start == len(s):\n                res.append('.'.join(path))\n            return\n        \n        for i in range(min(3, len(s)-start)):\n            if s[start:start+i+1].startswith('0') and i != 0:\n                break\n            cur = s[start:start+i+1]\n            if int(cur) <= 255:\n                backtrack(start+i+1, path + [cur])\n\n    res = []\n    backtrack(0, [])\n    return res\n\ndef main():\n    print\trestoreIpAddresses(\"25525511135\") # [[\"255.255.11.135\"]]\n    print.restoreIpAddresses(\"101023\") # [\"1.0.10.23\",\"1.0.1023\"]\n    print.restoreIpAddresses(\"2000000131\") # [\"2.0.0.131\",\"20.0.0.13\",\"200.0.1.31\"]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "92": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef reverseBetween(head, left, right):\n    if not head or left > right or not head.next:\n        return head\n    \n    dummy = ListNode(0)\n    dummy.next = head\n    pre = dummy\n    for _ in range(left - 1):\n        pre = pre.next\n    curr = pre.next\n    for _ in range(right - left):\n        temp, curr.next = curr.next, curr\n        curr = temp\n    return dummy.next\n\ndef printList(head):\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\ndef main():\n    # Test case 1\n    node1 = ListNode(1)\n    node2 = ListNode(2)\n    node3 = ListNode(3)\n    node4 = ListNode(4)\n    node5 = ListNode(5)\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    head = node1\n    print(\"Original List:\")\n    printList(head)\n    result = reverseBetween(head, 1, 5)\n    print(\"Reversed List:\")\n    printList(result)\n\n    # Test case 2\n    node6 = ListNode(1)\n    node7 = ListNode(2)\n    node8 = ListNode(3)\n    node9 = ListNode(4)\n    node10 = ListNode(5)\n    node11 = ListNode(6)\n    node12 = ListNode(7)\n    node13 = ListNode(8)\n    node14 = ListNode(9)\n    node15 = ListNode(10)\n    node6.next = node7\n    node7.next = node8\n    node8.next = node9\n    node9.next = node10\n    node10.next = node11\n    node11.next = node12\n    node12.next = node13\n    node13.next = node14\n    node14.next = node15\n    head = node6\n    print(\"Original List:\")\n    printList(head)\n    result = reverseBetween(head, 3, 8)\n    print(\"Reversed List:\")\n    printList(result)\n\n    # Test case 3\n    node16 = ListNode(1)\n    node17 = ListNode(2)\n    node18 = ListNode(3)\n    node19 = ListNode(4)\n    node20 = ListNode(5)\n    node21 = ListNode(6)\n    node22 = ListNode(7)\n    node23 = ListNode(8)\n    node24 = ListNode(9)\n    node25 = ListNode(10)\n    node16.next = node17\n    node17.next = node18\n    node18.next = node19\n    node19.next = node20\n    node20.next = node21\n    node21.next = node22\n    node22.next = node23\n    node23.next = node24\n    node24.next = node25\n    head = node16\n    print(\"Original List:\")\n    printList(head)\n    result = reverseBetween(head, 1, 10)\n    print(\"Reversed List:\")\n    printList(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "94": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef inorderTraversal(root):\n    result = []\n    if root is not None:\n        result += inorderTraversal(root.left)\n        result.append(root.val)\n        result += inorderTraversal(root.right)\n    return result\n\ndef main():\n    # Test case 1\n    root1 = TreeNode(1)\n    root1.left = TreeNode(3)\n    root1.right = TreeNode(2)\n    print(inorderTraversal(root1))  # [1, 3, 2]\n\n    # Test case 2\n    root2 = TreeNode(5)\n    root2.left = TreeNode(4)\n    root2.right = TreeNode(6)\n    print(inorderTraversal(root2))  # [4, 5, 6]\n\n    # Test case 3\n    root3 = TreeNode(1)\n    root3.left = TreeNode(0)\n    root3.right = TreeNode(3)\n    print(inorderTraversal(root3))  # [0, 1, 3]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "95": "```\nclass Solution:\n    def numUniqueBST(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0], dp[1] = 1, 1\n        for i in range(2, n + 1):\n            for j in range(1, i + 1):\n                if j == 1 or dp[j - 1]:\n                    dp[i] += dp[i - j]\n        return dp[n]\n\ndef main():\n    solution = Solution()\n    \n    print(\"Test Case 1:\")\n    print(solution.numUniqueBST(3))  # Output: 5\n    \n    print(\"\\nTest Case 2:\")\n    print(solution.numUniqueBST(4))  # Output: 15\n    \n    print(\"\\nTest Case 3:\")\n    print(solution.numUniqueBST(5))  # Output: 42\n\nif __name__ == \"__main__\":\n    main()\n```",
  "96": "```\nclass Solution:\n    def numTrees(self, n):\n        if n == 0 or n == 1:\n            return 1\n        G = [0]*(2*n+1)\n        for i in range(2*n+1):\n            G[i] = sum(G[j-1]*G[2*n-j] for j in range(i+1))\n        return G[n]\n\ndef main():\n    s = Solution()\n    \n    print(s.numTrees(3))  # Output: 5\n    print(s.numTrees(4))  # Output: 14\n    print(s.numTrees(10))  # Output: 44\n\nif __name__ == \"__main__\":\n    main()\n```",
  "97": "```\ndef isInterleave(s1, s2, s3):\n    if len(s1) + len(s2) != len(s3):\n        return False\n    \n    dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n    \n    dp[0][0] = True\n    for i in range(1, len(s1) + 1):\n        dp[i][0] = dp[i-1][0] and s1[i-1] == s3[:i]\n    for j in range(1, len(s2) + 1):\n        dp[0][j] = dp[0][j-1] and s2[j-1] == s3[:j]\n    \n    for i in range(1, len(s1) + 1):\n        for j in range(1, len(s2) + 1):\n            if s1[i-1] == s3[i+j-1]:\n                dp[i][j] = dp[i-1][j]\n            elif s2[j-1] == s3[i+j-1]:\n                dp[i][j] = dp[i][j-1]\n            else:\n                dp[i][j] = dp[i-1][j] or dp[i][j-1]\n    \n    return dp[-1][-1]\n\ndef main():\n    test_case1 = (\"aabcc\", \"dbbdc\", \"aadbbcbc\")\n    print(isInterleave(*test_case1))\n\n    test_case2 = (\"aab\", \"cb\", \"aabc\")\n    print(isInterleave(*test_case2))\n\n    test_case3 = (\"lea\", \"ear\", \"leetcodeea\")\n    print(isInterleave(*test_case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "98": "```\nclass Solution:\n    def isValidBST(self, root):\n        def check(node, low=float('-inf'), high=float('inf')):\n            if not node:\n                return True\n            if node.val <= low or node.val >= high:\n                return False\n            return (check(node.right, high=high) and \n                    check(node.left, low=low))\n\n    def main():\n        solution = Solution()\n        \n        # Test case 1: Valid Binary Search Tree\n        root = TreeNode(2)\n        root.left = TreeNode(1)\n        root.right = TreeNode(3)\n        print(solution.isValidBST(root))  # Output: True\n\n        # Test case 2: Invalid Binary Search Tree (contains duplicates)\n        root = TreeNode(5)\n        root.left = TreeNode(4)\n        root.right = TreeNode(6)\n        root.left.left = TreeNode(3)\n        root.left.right = TreeNode(5)\n        print(solution.isValidBST(root))  # Output: False\n\n        # Test case 3: Invalid Binary Search Tree (not a binary search tree)\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(4)\n        root.left.left = TreeNode(6)\n        root.right.right = TreeNode(-5)\n        print(solution.isValidBST(root))  # Output: False\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "100": "```\ndef isSameTree(p, q):\n    if p is None and q is None:\n        return True\n    if p is None or q is None:\n        return False\n    if p.val != q.val:\n        return False\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\ndef main():\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n\n    print(isSameTree(root1, root2))  # Expected: True\n\n    root3 = TreeNode(1)\n    root3.left = TreeNode(2)\n\n    root4 = TreeNode(1)\n    root4.right = TreeNode(2)\n\n    print(isSameTree(root3, root4))  # Expected: False (because left subtree of p is different from right subtree of q)\n\n    root5 = None\n\n    root6 = None\n\n    print(isSameTree(root5, root6))  # Expected: True",
  "99": "```\nclass Solution:\n    def inorder(self, root):\n        if not root:\n            return []\n        return self.inorder(root.left) + [root.val] + self.inorder(root.right)\n\n    def recoverTree(self, root):\n        prev = None\n        first = None\n        second = None\n        self.inorder_traversal(root)\n        if first and second:\n            temp1 = first.left\n            first.left = second\n            second.left = temp1\n\n    def inorder_traversal(self, node):\n        if not node:\n            return\n        self.inorder_traversal(node.left)\n        nonlocal prev\n        if prev and prev.val > node.val:\n            if first is None:\n                first = prev\n            second = node\n        prev = node\n        self.inorder_traversal(node.right)\n\n    def main(self):\n        solution = Solution()\n        root1 = TreeNode(2, TreeNode(1), TreeNode(3))\n        solution.recoverTree(root1)\n        print(solution.inorder(root1.root))  # Expected output: [1, 2, 3]\n\n        root2 = TreeNode(4, TreeNode(3, TreeNode(1), TreeNode(2)), TreeNode(5))\n        solution.recoverTree(root2)\n        print(solution.inorder(root2.root))  # Expected output: [1, 2, 3, 4, 5]\n\n        root3 = TreeNode(5, TreeNode(1), TreeNode(3, TreeNode(4), TreeNode(2)))\n        solution.recoverTree(root3)\n        print(solution.inorder(root3.root))  # Expected output: [1, 2, 3, 4, 5]\n```",
  "101": "```\ndef is_symmetric(root):\n    return is_mirror(root, root)\n\ndef is_mirror(t1, t2):\n    if t1 is None and t2 is None: \n        return True\n    if t1 is None or t2 is None: \n        return False\n    return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right)\n\ndef main():\n    # Test Case 1\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    print(is_symmetric(root))  # Expected Output: True\n\n    # Test Case 2\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n\n    print(is_symmetric(root))  # Expected Output: False\n\n    # Test Case 3\n    root = None\n\n    print(is_symmetric(root))  # Expected Output: True\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "102": "```\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef levelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(level)\n\n    return result\n\ndef main():\n    # Test Case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(9)\n    root1.right = TreeNode(20)\n    root1.right.left = TreeNode(15)\n    root1.right.right = TreeNode(7)\n    print(levelOrder(root1))\n\n    # Test Case 2\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n    root2.left.left = TreeNode(4)\n    root2.left.right = TreeNode(5)\n    print(levelOrder(root2))\n\n    # Test Case 3\n    root3 = None\n    print(levelOrder(root3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "103": "```\nfrom collections import deque\n\nclass Solution:\n    def zigzagLevelOrder(self, root):\n        if not root:\n            return []\n        \n        result = []\n        leftToRight = True\n        \n        queue = deque([(root, 0)])\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node, levelNum = queue.popleft()\n                \n                if leftToRight:\n                    level.append(node.val)\n                else:\n                    level.insert(0, node.val)\n                    \n                if node.left:\n                    queue.append((node.left, levelNum + 1))\n                if node.right:\n                    queue.append((node.right, levelNum + 1))\n            \n            result.append(level)\n            leftToRight = not leftToRight\n        \n        return result\n\ndef main():\n    s = Solution()\n    \n    # Test case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(9)\n    root1.right = TreeNode(20)\n    root1.right.left = TreeNode(15)\n    root1.right.right = TreeNode(7)\n    print(s.zigzagLevelOrder(root1))\n    \n    # Test case 2\n    root2 = TreeNode(3)\n    root2.right = TreeNode(9)\n    root2.right.left = TreeNode(20)\n    root2.right.right = TreeNode(15)\n    root2.right.left.right = TreeNode(7)\n    print(s.zigzagLevelOrder(root2))\n    \n    # Test case 3\n    root3 = TreeNode(1)\n    root3.left = TreeNode(2)\n    root3.right = TreeNode(3)\n    root3.left.left = TreeNode(4)\n    root3.left.right = TreeNode(5)\n    print(s.zigzagLevelOrder(root3))\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "104": "```\ndef maxDepth(root):\n    if not root:\n        return 0\n    left_depth = maxDepth(root.left)\n    right_depth = maxDepth(root.right)\n    return 1 + max(left_depth, right_depth)\n\ndef main():\n    class TreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.left = None\n            self.right = None\n\n    root1 = TreeNode(3)\n    root1.left = TreeNode(9)\n    root1.right = TreeNode(20)\n    root1.right.left = TreeNode(15)\n    root1.right.right = TreeNode(7)\n\n    print(\"Test case 1:\")\n    print(maxDepth(root1))  # Output: 3\n\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n\n    print(\"\\nTest case 2:\")\n    print(maxDepth(root2))  # Output: 2\n\n    root3 = TreeNode(0)\n\n    print(\"\\nTest case 3:\")\n    print(maxDepth(root3))  # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "105": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef buildTree(preorder, inorder):\n    if not preorder:\n        return None\n    root = TreeNode(preorder[0])\n    idx = inorder.index(root.val)\n    root.left = buildTree(preorder[1:idx+1], inorder[:idx])\n    root.right = buildTree(preorder[idx+1:], inorder[idx+1:])\n    return root\n\ndef printInOrder(node):\n    if node:\n        printInOrder(node.left)\n        print(str(node.val) + \" \", end=\"\")\n        printInOrder(node.right)\n\ndef main():\n    preorder1 = [3, 9, 20, 15, 7]\n    inorder1 = [9, 3, 15, 20, 7]\n    root1 = buildTree(preorder1, inorder1)\n    print(\"Test Case 1:\")\n    printInOrder(root1)\n    print()\n\n    preorder2 = [1, 2, 4, 5, 3, 6, 7]\n    inorder2 = [4, 2, 5, 1, 6, 3, 7]\n    root2 = buildTree(preorder2, inorder2)\n    print(\"Test Case 2:\")\n    printInOrder(root2)\n    print()\n\n    preorder3 = [1]\n    inorder3 = [1]\n    root3 = buildTree(preorder3, inorder3)\n    print(\"Test Case 3:\")\n    printInOrder(root3)\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "106": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef buildTree(inorder, postorder):\n    if not inorder:\n        return None\n    \n    root_val = postorder.pop()\n    root_node = TreeNode(root_val)\n    \n    idx = inorder.index(root_val)\n    left_inorder = inorder[:idx]\n    right_inorder = inorder[idx+1:]\n    \n    root_node.left = buildTree(left_inorder, postorder)\n    root_node.right = buildTree(right_inorder, postorder)\n    \n    return root_node\n\ndef print_tree(node):\n    if node:\n        print(node.val)\n        print_tree(node.left)\n        print_tree(node.right)\n\ndef main():\n    test_case1 = [9,3,15,20,7], [9,15,7,20,3]\n    test_case2 = [1,2,4,5,3,6,7], [1,3,7,6,5,4,2]\n    test_case3 = [1], [1]\n\n    for test_case in test_case1 + test_case2 + test_case3:\n        inorder, postorder = test_case\n        root_node = buildTree(inorder, postorder)\n        print_tree(root_node)\n        print(\"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "108": "```\nclass Solution:\n    def sortedArrayToBST(self, nums):\n        if not nums:\n            return None\n        \n        mid = len(nums) // 2\n        \n        root = TreeNode(nums[mid])\n        root.left = self.sortedArrayToBST(nums[:mid])\n        root.right = self.sortedArrayToBST(nums[mid+1:])\n        \n        return root\n\n    def printTree(self, t):\n        if not t:\n            return\n        \n        self.printTree(t.left)\n        print(str(t.val) + \" \")\n        self.printTree(t.right)\n\ndef main():\n    s = Solution()\n    \n    # Test case 1\n    nums = [-10, -3, 0, 5, 9]\n    root = s.sortedArrayToBST(nums)\n    s.printTree(root)\n    print()\n\n    # Test case 2\n    nums = [1, 2, 4, 6, 8]\n    root = s.sortedArrayToBST(nums)\n    s.printTree(root)\n    print()\n\n    # Test case 3\n    nums = [-10, -5, 0, 5, 10]\n    root = s.sortedArrayToBST(nums)\n    s.printTree(root)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "107": "```\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef levelOrderBottom(root):\n    if not root:\n        return []\n\n    result = []\n    queue = deque([root])\n\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level.append(node.val)\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        result.append(list(reversed(level)))\n\n    return result\n\ndef main():\n    # Test case 1\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(7)\n\n    print(levelOrderBottom(root))  # Output: [[20,15,7], [9], [3]]\n\n    # Test case 2\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n\n    print(levelOrderBottom(root))  # Output: [[1], [2,3]]\n\n    # Test case 3\n    root = None\n\n    print(levelOrderBottom(root))  # Output: []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "109": "```\nclass Solution:\n    def sortedListToBST(self, head):\n        if not head:\n            return None\n        slow = fast = head\n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        mid = slow\n        new_head = head\n        while new_head != mid:\n            new_head = new_head.next\n        left = self.sortedListToBST(new_head)\n        new_head.next = None\n        root = TreeNode(mid.val)\n        root.left = left\n        root.right = self.sortedListToBST(mid.next)\n        return root\n\n    def print_tree(self, node):\n        if node:\n            print(node.val)\n            self.print_tree(node.left)\n            self.print_tree(node.right)\n\ndef main():\n    s = Solution()\n    \n    # Test case 1: [1]\n    head1 = TreeNode(1)\n    print(\"Test case 1:\")\n    root1 = s.sortedListToBST(head1)\n    s.print_tree(root1)\n    print()\n\n    # Test case 2: [-3, -1, 5, 8, 23, null, 56]\n    head2 = TreeNode(-3)\n    head2.next = TreeNode(-1)\n    head2.next.next = TreeNode(5)\n    head2.next.next.next = TreeNode(8)\n    head2.next.next.next.next = TreeNode(23)\n    head2.next.next.next.next.next = None\n    head2.next.next.next.next.next.next = TreeNode(56)\n    print(\"Test case 2:\")\n    root2 = s.sortedListToBST(head2)\n    s.print_tree(root2)\n    print()\n\n    # Test case 3: []\n    head3 = None\n    print(\"Test case 3:\")\n    root3 = s.sortedListToBST(head3)\n    if root3:\n        s.print_tree(root3)\n    else:\n        print(\"Empty tree\")\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "110": "```\ndef isBalanced(root):\n    if not root:\n        return True\n\n    def check(node):\n        if not node:\n            return 0, True\n\n        left_height, left_balanced = check(node.left)\n        if not left_balanced:\n            return -1, False\n\n        right_height, right_balanced = check(node.right)\n        if not right_balanced:\n            return -1, False\n\n        if abs(left_height - right_height) > 1:\n            return -1, False\n        return max(left_height, right_height) + 1, True\n\n    height, balanced = check(root)\n\n    return height >= 0 and balanced\n\ndef main():\n    # Test Case 1: Unbalanced Binary Tree\n    root1 = TreeNode(3)\n    root1.left = TreeNode(9)\n    root1.right = TreeNode(20)\n    root1.right.left = TreeNode(15)\n    root1.right.right = TreeNode(7)\n\n    print(isBalanced(root1)) # Expected output: False\n\n    # Test Case 2: Balanced Binary Tree\n    root2 = TreeNode(3)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n\n    print(isBalanced(root2)) # Expected output: True\n\n    # Test Case 3: Empty Binary Tree\n    root3 = None\n\n    print(isBalanced(root3)) # Expected output: True\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "111": "```\ndef minDepth(root):\n    if not root:\n        return 0\n    \n    queue = [(root, 1)]\n    \n    while queue:\n        node, depth = queue.pop(0)\n        \n        if not node.left and not node.right:\n            return depth\n        \n        if node.left:\n            queue.append((node.left, depth + 1))\n        if node.right:\n            queue.append((node.right, depth + 1))\n\ndef main():\n    # Test case 1\n    root = TreeNode(3)\n    root.left = TreeNode(9)\n    print(minDepth(root))  # Expected output: 2\n\n    # Test case 2\n    root = None\n    print(minDepth(root))  # Expected output: 0\n\n    # Test case 3\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    print(minDepth(root))  # Expected output: 2\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "112": "```\ndef hasPathSum(root, targetSum):\n    if not root:\n        return False\n    \n    queue = [(root, root.val)]\n    \n    while queue:\n        node, sum_val = queue.pop(0)\n        \n        if node.left:\n            queue.append((node.left, sum_val + node.left.val))\n        if node.right:\n            queue.append((node.right, sum_val + node.right.val))\n        \n        if not node.left and not node.right and sum_val == targetSum:\n            return True\n    \n    return False\n\n\ndef main():\n    # Test Case 1\n    root = TreeNode(5)\n    root.left = TreeNode(4)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(11)\n    root.left.right = TreeNode(7)\n    root.right.left = TreeNode(13)\n    root.right.right = TreeNode(4)\n    root.left.left.left = TreeNode(2)\n    print(hasPathSum(root, 22))  # Expected: True\n\n    # Test Case 2\n    root = TreeNode(1)\n    root.left = TreeNode(3)\n    print(hasPathSum(root, 5))  # Expected: False\n\n    # Test Case 3\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    print(hasPathSum(root, 3))  # Expected: True\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "113": "```\nclass Solution:\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\n        self.res = []\n        self.path = []\n        self.dfs(root, sum)\n        return self.res\n\n\ndef dfs(self, node: TreeNode, remain_sum: int):\n    if not node:\n        return\n    self.path.append(node.val)\n    remain_sum -= node.val\n    if not node.left and not node.right:\n        if remain_sum == 0:\n            self.res.append(list(self.path))\n    else:\n        self.dfs(node.left, remain_sum)\n        self.dfs(node.right, remain_sum)\n    self.path.pop()\n\n\ndef main():\n    s = Solution()\n    \n    # Test case 1\n    root1 = TreeNode(5)\n    root1.left = TreeNode(4)\n    root1.right = TreeNode(8)\n    root1.left.left = TreeNode(11)\n    root1.left.left.left = TreeNode(7)\n    root1.left.left.right = TreeNode(2)\n    root1.right.left = TreeNode(13)\n    root1.right.right = TreeNode(4)\n    root1.right.right.left = TreeNode(5)\n    print(s.pathSum(root1, 22))\n    \n    # Test case 2\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n    print(s.pathSum(root2, 6))\n    \n    # Test case 3\n    root3 = None\n    print(s.pathSum(root3, 5))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "114": "```\nclass Solution:\n    def flatten(self, root):\n        if not root:\n            return\n\n        stack = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.right\n            root = stack.pop()\n            root = root.left\n        return root\n\ndef main():\n    solution = Solution()\n\n    # Test case 1:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(5)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n\n    result = solution.flatten(root)\n    print(\"Test case 1:\")\n    while result:\n        print(result.val, end=\" \")\n        result = result.right\n    print()\n\n    # Test case 2:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n\n    result = solution.flatten(root)\n    print(\"Test case 2:\")\n    while result:\n        print(result.val, end=\" \")\n        result = result.right\n    print()\n\n    # Test case 3:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n\n    result = solution.flatten(root)\n    print(\"Test case 3:\")\n    while result:\n        print(result.val, end=\" \")\n        result = result.right\n    print()\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "116": "```\nclass Solution:\n    def connect(self, root):\n        if not root:\n            return\n        \n        queue = [root]\n        \n        while queue:\n            level_size = len(queue)\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                \n                if i < level_size - 1:\n                    node.next = queue[0]\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\ndef main():\n    solution = Solution()\n    \n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    root1.left.right = TreeNode(5)\n    print(solution.connect(root1))\n\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    print(solution.connect(root2))\n    \n    root3 = None\n    print(solution.connect(root3))\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n        self.next = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "115": "```\ndef numDistinct(s, t):\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = 1\n    for j in range(n + 1):\n        dp[0][j] = 0\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[m][n]\n\ndef main():\n    test_cases = [\n        {\"s\": \"rabbbit\", \"t\": \"rabbit\", \"expected\": 3},\n        {\"s\": \"banana\", \"t\": \"aba\", \"expected\": 3},\n        {\"s\": \"aabcba\", \"t\": \"aba\", \"expected\": 2}\n    ]\n    \n    for test_case in test_cases:\n        s, t = test_case[\"s\"], test_case[\"t\"]\n        expected = test_case[\"expected\"]\n        result = numDistinct(s, t)\n        if result == expected:\n            print(f\"Test case passed: {s} and {t}\")\n        else:\n            print(f\"Test case failed: {s} and {t}. Expected {expected}, but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "118": "```\ndef generate(numRows):\n    if numRows == 0:\n        return []\n    triangle = [[1]]\n    for i in range(1, numRows):\n        row = [1]\n        lastRow = triangle[i-1]\n        for j in range(1, i):\n            row.append(lastRow[j-1] + lastRow[j])\n        row.append(1)\n        triangle.append(row)\n    return triangle\n\ndef main():\n    print(\"Test Case 1:\")\n    result = generate(5)\n    for row in result:\n        print(row)\n\n    print(\"\\nTest Case 2:\")\n    result = generate(3)\n    for row in result:\n        print(row)\n\n    print(\"\\nTest Case 3:\")\n    result = generate(10)\n    for row in result:\n        print(row)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "117": "```\ndef connect(root):\n    if not root:\n        return\n\n    queue = [root]\n    while queue:\n        size = len(queue)\n        for i in range(size):\n            node = queue.pop(0)\n            if i < size - 1:\n                node.next = queue[0]\n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n\ndef main():\n    # Test case 1\n    root = Node(1)\n    root.left = Node(2)\n    root.right = Node(3)\n    root.left.left = Node(4)\n    root.left.right = Node(5)\n    connect(root)\n    print(\"Test Case 1: \", end=\"\")\n    current = root\n    while current:\n        if current.next:\n            print(current.val, \" -> \", current.next.val, end=\" \")\n        else:\n            print(current.val)\n        current = current.next if current.next else current.left or current.right\n\n    # Test case 2\n    root = Node(1)\n    root.right = Node(2)\n    connect(root)\n    print(\"Test Case 2: \", end=\"\")\n    current = root\n    while current:\n        if current.next:\n            print(current.val, \" -> \", current.next.val, end=\" \")\n        else:\n            print(current.val)\n        current = current.next if current.next else current.left or current.right\n\n    # Test case 3\n    root = Node(1)\n    connect(root)\n    print(\"Test Case 3: \", end=\"\")\n    current = root\n    while current:\n        if current.next:\n            print(current.val, \" -> \", current.next.val, end=\" \")\n        else:\n            print(current.val)\n        current = current.next if current.next else current.left or current.right\n\nclass Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "119": "```\ndef getRow(rowIndex):\n    row = [1]\n    for _ in range(rowIndex):\n        row = [x + y for x, y in zip([0] + row, row + [0])]\n    return row\n\ndef main():\n    print(getRow(3))  # Expected output: [1,2,1]\n    print(getRow(4))  # Expected output: [1,3,3,1]\n    print(getRow(5))  # Expected output: [1,4,6,4,1]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "120": "```\ndef minimumTotal(triangle):\n    dp = [[0 for _ in range(len(row))] for row in triangle]\n    dp[0] = triangle[0]\n\n    for i in range(1, len(triangle)):\n        for j in range(len(triangle[i])):\n            if j == 0:\n                dp[i][j] = dp[i-1][j] + triangle[i][j]\n            elif j == len(triangle[i]) - 1:\n                dp[i][j] = dp[i-1][j-1] + triangle[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i-1][j-1]) + triangle[i][j]\n\n    return min(dp[-1])\n\ndef main():\n    print(minimumTotal([[2]]))  # Expected output: 2\n    print(minimumTotal([[5]]))  # Expected output: 5\n    print(minimumTotal([[1,3,5],[9,8,4],[7,6,3]]))  # Expected output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "121": "```\ndef maxProfit(prices):\n    if len(prices) < 2:\n        return 0\n    min_price = prices[0]\n    max_profit = 0\n    for price in prices:\n        if price < min_price:\n            min_price = price\n        else:\n            profit = price - min_price\n            if profit > max_profit:\n                max_profit = profit\n    return max_profit\n\ndef main():\n    print(\"Test case 1:\")\n    print(maxProfit([7,1,5,3,6,4])) # Expected output: 5\n    \n    print(\"\\nTest case 2:\")\n    print(maxProfit([1,2,3,4,5])) # Expected output: 4\n    \n    print(\"\\nTest case 3:\")\n    print(maxProfit([7,6,4,3,2,1])) # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "122": "```\ndef maxProfit(prices):\n    profit = 0\n    for i in range(1, len(prices)):\n        if prices[i] > prices[i-1]:\n            profit += prices[i] - prices[i-1]\n    return profit\n\n\ndef main():\n    test_cases = [\n        [7, 1, 5, 3, 6, 4], \n        [1, 2, 3, 4, 5], \n        [2, 1, 2, 0, 1]\n    ]\n\n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        result = maxProfit(test_case)\n        print(f\"Result: {result}\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "123": "```\ndef maxProfit(prices):\n    if len(prices) < 2:\n        return 0\n    buy1 = buy2 = 0\n    sell1 = sell2 = 0\n    for i in range(1, len(prices)):\n        buy1 = max(buy1, -prices[i-1])\n        sell1 = max(sell1, buy1 + prices[i])\n        buy2 = max(buy2, sell1 - prices[i])\n        sell2 = max(sell2, buy2 + prices[i])\n    return sell2\n\ndef main():\n    print(maxProfit([7,6,5,4,3,2,1])) # expected 0\n    print(maxProfit([1,2,3,2,3,4,5])) # expected 6\n    print(maxProfit([7,6,5,4,3,2,10])) # expected 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "124": "```\nclass Solution:\n    def maxPathSum(self, root):\n        self.max_sum = float('-inf')\n\n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n\n            price_newpath = node.val + left_gain + right_gain\n\n            self.max_sum = max(self.max_sum, price_newpath)\n\n            return node.val + max(left_gain, right_gain)\n\n        max_gain(root)\n        return self.max_sum\n\n\ndef main():\n    solution = Solution()\n    \n    # Test case 1:\n    root = TreeNode(10)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    root.left.left = TreeNode(6)\n    root.left.right = TreeNode(7)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(25)\n    print(solution.maxPathSum(root))  # Output: 42\n\n    # Test case 2:\n    root = TreeNode(-10)\n    root.left = TreeNode(9)\n    root.right = TreeNode(20)\n    print(solution.maxPathSum(root))  # Output: 30\n\n    # Test case 3:\n    root = TreeNode(-5)\n    print(solution.maxPathSum(root))  # Output: -5\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n```",
  "125": "```\ndef is_palindrome(s):\n    s = s.replace(' ', '').lower()\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] != s[right]:\n            return False\n        left += 1\n        right -= 1\n    return True\n\ndef main():\n    print(is_palindrome(\"A man a plan a canal Panama\"))  # Test case 1: Expected output: True\n    print(is_palindrome(\"Not a palindrome\"))  # Test case 2: Expected output: False\n    print(is_palindrome(\"Radar\"))  # Test case 3: Expected output: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "126": "```\ndef findLadders(beginWord, endWord, wordList):\n    if not wordList or not beginWord or not endWord:\n        return []\n\n    wordList = set(wordList)\n    beginWord = list(beginWord)\n    endWord = list(endWord)\n\n    def bfs(currentWord, nextWords):\n        for nextWord in nextWords:\n            if all(x == y or (0 <= x - y <= 1) for x, y in zip(currentWord, nextWord)):\n                yield from [(list(nextWord), [nextWord])]\n                for ladder in list(bfs(nextWord, nextWords - {nextWord} | {(i := str(int(''.join(map(str, i)))) if len(i) == len(set(i)) else '') for i in [''.join(map(str, [c for c in currentWord]))]})):\n                    yield from [(ladder[0], ladder[1] + [currentWord])]\n        return\n\n    def dfs(currentWords, endWord):\n        for nextWords in bfs(nextWords := tuple(sorted([word for word in wordList if all(x == y or (0 <= x - y <= 1) for x, y in zip(word, currentWord))])), set(wordList)):\n            yield from [(ladder[0], ladder[1] + [currentWord]) for ladder in list(dfs(tuple(sorted(nextWords)), endWord))]\n        return\n\n    for ladder in dfs((beginWord,), (endWord,)):\n        if ladder[-1] == endWord:\n            yield from [ladder]\n```",
  "127": "```\ndef ladderLength(start, end, wordList):\n    if not start or not end:\n        return 0\n    \n    queue = [(start, 1)]\n    visited = {start}\n    \n    while queue:\n        word, length = queue.pop(0)\n        \n        if word == end:\n            return length\n        \n        for i in range(len(word)):\n            left, right = word[:i], word[i+1:]\n            \n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                newWord = left + c + right\n                \n                if newWord not in visited and newWord in wordList:\n                    queue.append((newWord, length + 1))\n                    visited.add(newWord)\n    \n    return 0\n\ndef main():\n    start1 = \"hit\"\n    end1 = \"cog\"\n    wordList1 = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\n    print(ladderLength(start1, end1, wordList1))  \n\n    start2 = \"start\"\n    end2 = \"end\"\n    wordList2 = [\"start\",\"code\",\"star\",\"tars\",\"rtar\",\"eetn\",\"ends\",\"ente\",\"tnse\",\"tsen\"]\n    print(ladderLength(start2, end2, wordList2))\n\n    start3 = \"hit\"\n    end3 = \"bad\"\n    wordList3 = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\",\"bat\",\"bad\",\"had\"]\n    print(ladderLength(start3, end3, wordList3))  \n\nif __name__ == \"__main__\":\n    main()\n```",
  "128": "```\ndef longestConsecutive(nums):\n    if not nums:\n        return 0\n\n    num_set = set(nums)\n    longest_streak = 0\n\n    for num in num_set:\n        if num - 1 not in num_set:\n            current_num = num\n            current_streak = 1\n\n            while current_num + 1 in num_set:\n                current_num += 1\n                current_streak += 1\n\n            longest_streak = max(longest_streak, current_streak)\n\n    return longest_streak\n\n\ndef main():\n    print(longestConsecutive([100, 4, 200, 1, 3, 2]))  # Output: 4\n    print(longestConsecutive([0, 3, 7, 2, 5, 8, 4, 6, 1]))  # Output: 7\n    print(longestConsecutive([]))  # Output: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "129": "```\nclass Solution:\n    def sumRootToLeaf(self, root):\n        self.answer = 0\n        \n        def dfs(node, val):\n            if not node:\n                return \n            val = (val << 1) | node.val\n            if not node.left and not node.right:\n                self.answer += val\n            else:\n                dfs(node.left, val)\n                dfs(node.right, val)\n\n        dfs(root, 0)\n        return self.answer\n\ndef main():\n    s = Solution()\n    \n    # Test case 1\n    root = TreeNode(1)\n    root.left = TreeNode(0)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(0)\n    root.left.right = TreeNode(1)\n    root.right.left = TreeNode(0)\n    root.right.right = TreeNode(1)\n    \n    print(s.sumRootToLeaf(root))  # Output: 6\n\n    # Test case 2\n    root = TreeNode(4)\n    root.left = TreeNode(9)\n    root.right = TreeNode(0)\n    root.left.left = TreeNode(5)\n    root.left.right = TreeNode(1)\n    \n    print(s.sumRootToLeaf(root))  # Output: 13\n\n    # Test case 3\n    root = TreeNode(0)\n\n    print(s.sumRootToLeaf(root))  # Output: 0\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "131": "```\ndef partition(s):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def backtrack(start, path):\n        if start == len(s):\n            result.append(path)\n            return\n        for end in range(start, len(s)):\n            if is_palindrome(s[start:end+1]):\n                backtrack(end + 1, path + [s[start:end+1]])\n\n    result = []\n    backtrack(0, [])\n    return [partition for partition in result]\n\ndef main():\n    print(partition(\"aab\")) \n    print(partition(\"a\")) \n    print(partition(\"aa\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "130": "```\ndef solve(board):\n    if not board:\n        return \n\n    rows, cols = len(board), len(board[0])\n    directions = [(0,1),(0,-1),(1,0),(-1,0)]\n\n    def dfs(r, c):\n        if r<0 or r>=rows or c<0 or c>=cols or board[r][c] != 'O':\n            return \n        board[r][c] = '#'\n        for dr, dc in directions:\n            dfs(r+dr, c+dc)\n\n    # mark the border\n    for i in range(rows):\n        dfs(i, 0)\n        dfs(i, cols-1)\n    for j in range(cols):\n        dfs(0, j)\n        dfs(rows-1, j)\n\n    # fill the surrounded region\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 'O':\n                dfs(i, j)\n\n    # reset the border\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == '#':\n                board[i][j] = 'O'\n            elif board[i][j] == 'O':\n                board[i][j] = 'X'\n\ndef main():\n    print(\"Testing Surrounded Regions\")\n    test_cases = [\n        {\n            \"input\": [\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"O\",\"O\",\"O\",\"O\",\"X\"],\n                [\"X\",\"X\",\"O\",\"X\",\"X\",\"X\"],\n                [\"X\",\"O\",\"O\",\"O\",\"O\",\"X\"],\n                [\"X\",\"X\",\"O\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"]\n            ],\n            \"expected_output\": [\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"O\",\"O\",\"O\",\"O\",\"X\"],\n                [\"X\",\"X\",\"O\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"]\n            ]\n        },\n        {\n            \"input\": [\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"]\n            ],\n            \"expected_output\": [\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],\n                [\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"]\n            ]\n        },\n        {\n            \"input\": [\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"O\",\"O\",\"O\",\"O\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"]\n            ],\n            \"expected_output\": [\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"O\",\"O\",\"O\",\"O\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"],\n                [\"X\",\"X\",\"X\",\"X\",\"X\",\"X\"]\n            ]\n        }\n    ]\n\n    for test_case in test_cases:\n        board = [[cell for cell in row] for row in test_case[\"input\"]]\n        solve(board)\n        print(\"Input:\", test_case[\"input\"])\n        print(\"Expected Output:\", test_case[\"expected_output\"])\n        print(\"Output:\")\n        for row in board:\n            print(row)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "132": "```\ndef partition(s):\n    n = len(s)\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n + 1):\n            if s[i:j] == s[i:j][::-1]:\n                dp[i][j] = True\n            else:\n                for k in range(i, j):\n                    dp[i][j] = dp[i][k] and dp[k + 1][j]\n\n    return [s[i:j] for i in range(n) for j in range(i + 1, n + 1) if not dp[i][j]]\n\ndef main():\n    print(partition(\"aab\")) \n    print(partition(\"a\")) \n    print(partition(\"aba\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "133": "```\ndef cloneGraph(graph):\n    if not graph:\n        return []\n\n    graph_copy = {}\n    visited = set()\n\n    def dfs(node):\n        if node in visited:\n            return graph_copy.get(node, None)\n        \n        visited.add(node)\n\n        if not graph[node]:\n            return None\n        \n        copy_node = len(graph_copy) + 1\n        graph_copy[copy_node] = []\n        \n        for neighbor in graph[node]:\n            graph_copy[copy_node].append(dfs(neighbor))\n        \n        return copy_node\n\n    for node in graph:\n        dfs(node)\n    \n    return list(graph_copy.values())\n\ndef main():\n    graph1 = {\n        1: [2,3],\n        2: [4],\n        3: [4],\n        4: []\n    }\n    print(cloneGraph(graph1)) # Output: [[1,2,3],[4],[4],[]]\n\n    graph2 = {\n        1: [2],\n        2: [3]\n    }\n    print(cloneGraph(graph2)) # Output: [[1,2],[3],[]]\n\n    graph3 = {\n        1: []\n    }\n    print(cloneGraph(graph3)) # Output: [[1],[]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "134": "```\ndef canCompleteCircuit(gas, cost):\n    total_gas = 0\n    start = 0\n    total_cost = 0\n    for i in range(len(gas)):\n        total_gas += gas[i]\n        total_cost += cost[i]\n        if total_gas < cost[i]:\n            start = i + 1\n            total_gas = 0\n            total_cost = 0\n    return -1 if total_cost > total_gas else start\n\ndef main():\n    print(canCompleteCircuit([1,2,3,4], [5,6,7,8])) # Test case 1: Should return 4\n    print(canCompleteCircuit([2,3,4], [1,2,1]) ) # Test case 2: Should return 0\n    print(canCompleteCircuit([23,12], [25,40]) ) # Test case 3: Should return -1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "135": "```\ndef candy(ratings):\n    n = len(ratings)\n    candies = [1]*n\n    \n    for i in range(1,n):\n        if ratings[i] > ratings[i-1]:\n            candies[i] = candies[i-1]+1\n            \n    max_candy = max(candies)\n    second_max_candy = max_candy - 1\n    for i in range(n-2,-1,-1):\n        if ratings[i]>ratings[i+1]:\n            if ratings[i]>max_candy:\n                candies[i] = second_max_candy + 1\n            else:\n                candies[i]=max_candy + 1\n            max_candy = max(candies)\n    return sum(candies)\n\ndef main():\n    test_cases = [\n        ([2,3,5],7),\n        ([3,1,2],5),\n        ([1,3,2],5)\n    ]\n    \n    for ratings, expected in test_cases:\n        result = candy(ratings)\n        if result == expected:\n            print(\"Test case passed: \",ratings,\" ->\",result)\n        else:\n            print(\"Test case failed: \",ratings,\" expected\",expected,\" but got\",result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "136": "```\ndef singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\ndef main():\n    print(\"Test Case 1:\")\n    print(singleNumber([2,2,1])) # Expected output: 1\n    print(\"\\nTest Case 2:\")\n    print(singleNumber([4,2,2,1])) # Expected output: 1\n    print(\"\\nTest Case 3:\")\n    print(singleNumber([8,7,3,2,2,3])) # Expected output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "137": "```\ndef singleNumber(nums):\n    one = 0\n    two = 0\n    for num in nums:\n        bit1 = (num >> 0) & 1\n        bit2 = (num >> 1) & 1\n        one = ~((bit1 ^ one) | (bit2 ^ two))\n        two = bit1 ^ two\n    return two << 1 | one\n\ndef main():\n    print(singleNumber([2,2,3,4,5])) # Expected: 0\n    print(singleNumber([2,7,11,8,2,3]) )# Expected: 3\n    print(singleNumber([5,7,7,7])) # Expected: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "138": "```\ndef copyRandomList(head):\n    if not head:\n        return None\n    \n    nodeMap = {}\n    curr = head\n    while curr:\n        nodeMap[curr] = Node(curr.val) if curr else None\n        curr = curr.next\n    \n    curr = head\n    while curr:\n        nodeMap[curr].next = (curr.next or None)\n        nodeMap[curr].random = (curr.random or None)\n        curr = curr.next\n\n    return nodeMap.get(head)\n\ndef main():\n    # Test case 1: normal list with random pointer\n    head = Node(7, Node(14, Node(5)))\n    head.copyRandomList()\n    \n    # Test case 2: cycle list with random pointer\n    head = Node(3, Node(2, Node(0, Node(4))))\n    head.next.next.next.random = head.next\n    head.next.next.next.next = None\n    \n    # Test case 3: single node with no next or random\n    head = Node(1)\n    \n    for test_case in [head]:\n        result = copyRandomList(test_case)\n        print(f\"Test case {test_case.val}:\")\n        while result:\n            print(f\"{result.val} -> {result.random.val if result.random else None}\")\n            result = result.next\n        print()\n\nclass Node:\n    def __init__(self, val, next=None, random=None):\n        self.val = val\n        self.next = next\n        self.random = random\n\nif __name__ == \"__main__\":\n    main()\n```",
  "139": "```\ndef word_break(words, sentence):\n    dp = [False] * (len(sentence) + 1)\n    dp[0] = True\n    for i in range(1, len(sentence) + 1):\n        for j in range(i):\n            if dp[j] and sentence[j:i] in words:\n                dp[i] = True\n                break\n    return dp[-1]\n\ndef main():\n    print(word_break([\"leet\",\"code\"], \"leetcode\")) # Expected: True\n    print(word_break([\"apple\",\"banana\"], \"applepenapple\")) # Expected: True\n    print(word_break([\"cats\",\"dogs\"], \"catsanddog\")) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "140": "```\ndef wordBreak(words, sentence):\n    def backtrack(start, path):\n        if start == len(sentence):\n            return [path]\n        \n        res = []\n        for end in range(start + 1, len(sentence) + 1):\n            if sentence[start:end] in words:\n                res.extend(backtrack(end, path + [sentence[start:end]]))\n        return res\n    \n    return backtrack(0, [])\n\ndef main():\n    print(wordBreak([\"apple\", \"banana\", \"ap\"], \"applepenapple\"))\n    print(wordBreak([\"cats\", \"dogs\", \"sand\"], \"catsanddog\"))\n    print(wordBreak([\"a\", \"aa\", \"aaa\", \"aaaa\", \"aaaaa\"], \"aa\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "141": "```\nclass Solution:\n    def hasCycle(self, head):\n        if not head:\n            return False\n        \n        slow = head\n        fast = head.next\n        \n        while slow != fast and fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            \n        return slow == fast\n\n\ndef main():\n    # Test case 1: A cycle exists\n    s1 = Solution()\n    node5 = Node(5)\n    node4 = Node(4, node5)\n    node3 = Node(3, node4)\n    node2 = Node(2, node3)\n    node1 = Node(1, node2)\n\n    head1 = node1\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n\n    print(\"Test case 1: A cycle exists\", s1.hasCycle(head1))  # Expected output: True\n\n    # Test case 2: No cycle\n    head2 = Node(1)\n    head2.next = None\n    print(\"Test case 2: No cycle\", s1.hasCycle(head2))  # Expected output: False\n\n    # Test case 3: A cycle exists with multiple nodes\n    node7 = Node(7)\n    node6 = Node(6, node7)\n    node5 = Node(5, node6)\n    node4 = Node(4, node5)\n    node3 = Node(3, node4)\n    node2 = Node(2, node3)\n    node1 = Node(1, node2)\n\n    head3 = node1\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    node5.next = node6\n\n    print(\"Test case 3: A cycle exists with multiple nodes\", s1.hasCycle(head3))  # Expected output: True\n\n\nclass Node:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "142": "```\ndef detectCycle(head):\n    if not head:\n        return None\n\n    slow = head\n    fast = head.next\n\n    while slow != fast:\n        if not fast or not fast.next:\n            return None\n\n        slow = slow.next\n        fast = fast.next.next\n\n    ptr1 = head\n    ptr2 = slow\n\n    while ptr1 != ptr2:\n        ptr1 = ptr1.next\n        ptr2 = ptr2.next\n\n    return ptr2\n\ndef main():\n    # Test case 1: Cycle exists\n    node4 = Node(4)\n    node3 = Node(3, node4)\n    node2 = Node(2, node3)\n    node1 = Node(1, node2)\n    node4.next = node2\n    print(detectCycle(node1))  # Expected output: 2\n\n    # Test case 2: Cycle does not exist\n    node5 = Node(5)\n    node4 = Node(4, node5)\n    node3 = Node(3, node4)\n    node2 = Node(2, node3)\n    node1 = Node(1, node2)\n    print(detectCycle(node1))  # Expected output: None\n\n    # Test case 3: Cycle exists with only one node\n    node6 = Node(6)\n    node6.next = node6\n    print(detectCycle(node6))  # Expected output: 6\n\nclass Node:\n    def __init__(self, val, next=None):\n        self.val = val\n        self.next = next\n\nif __name__ == \"__main__\":\n    main()\n```",
  "143": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef reorderList(head):\n    if not head or not head.next:\n        return head\n    \n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    mid = slow.next\n    slow.next = None\n    \n    prev, curr = None, mid\n    while curr and curr.next:\n        next_node = curr.next\n        curr.next = None\n        prev = curr\n        curr = next_node\n    next_node = curr\n    \n    head1 = head\n    head2 = prev\n    \n    dummy = ListNode(0)\n    curr = dummy\n    while head1 or head2:\n        if head1:\n            curr.next = head1\n            head1 = head1.next\n        if head2:\n            curr.next = head2\n            head2 = head2.next\n        curr = curr.next\n    \n    return dummy.next\n\ndef printList(head):\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n    print()\n\ndef main():\n    # Test case 1: [1, 4, 3, 2, 5]\n    node1 = ListNode(1)\n    node2 = ListNode(4)\n    node3 = ListNode(3)\n    node4 = ListNode(2)\n    node5 = ListNode(5)\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    print(\"Test case 1:\")\n    printList(reorderList(node1))\n\n    # Test case 2: [1, 2]\n    node1 = ListNode(1)\n    node2 = ListNode(2)\n    node1.next = node2\n    print(\"Test case 2:\")\n    printList(reorderList(node1))\n\n    # Test case 3: [1, 5, 4, 3, 2, 6]\n    node1 = ListNode(1)\n    node2 = ListNode(5)\n    node3 = ListNode(4)\n    node4 = ListNode(3)\n    node5 = ListNode(2)\n    node6 = ListNode(6)\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    node5.next = node6\n    print(\"Test case 3:\")\n    printList(reorderList(node1))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "144": "```\ndef preorderTraversal(root):\n    if not root:\n        return []\n\n    result = []\n    stack = [root]\n\n    while stack:\n        node = stack.pop()\n        result.append(node.val)\n        if node.right:\n            stack.append(node.right)\n        if node.left:\n            stack.append(node.left)\n\n    return result\n\n\ndef main():\n    class TreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.left = None\n            self.right = None\n\n    # Test case 1\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    print(preorderTraversal(root1))  # Output: [1, 2, 3]\n\n    # Test case 2\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    print(preorderTraversal(root2))  # Output: [1, 2]\n\n    # Test case 3\n    root3 = TreeNode(1)\n    root3.right = TreeNode(2)\n    print(preorderTraversal(root3))  # Output: [1, 2]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "145": "```\ndef postorderTraversal(root):\n    if not root:\n        return []\n    \n    result = []\n    stack = [(root, False)]\n    \n    while stack:\n        node, visited = stack.pop()\n        \n        if node:\n            if not visited:\n                stack.append((node, True))\n                stack.append((node.right, False))\n                stack.append((node.left, False))\n            else:\n                result.append(node.val)\n    \n    return result\n\ndef main():\n    # Test case 1\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    root.left = TreeNode(3)\n    print(postorderTraversal(root))  # Output: [3, 2, 1]\n\n    # Test case 2\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    print(postorderTraversal(root))  # Output: [4, 2, 3, 1]\n\n    # Test case 3\n    root = None\n    print(postorderTraversal(root))  # Output: []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "146": "```\nclass LRUCache:\n\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.hashMap = {}\n        self.doublyLinkedList = Node(0)\n\n    def get(self, key):\n        if key in self.hashMap:\n            node = self.hashMap[key]\n            value = node.value\n            self._remove(node)\n            self._addLast(node)\n            return value\n        return -1\n\n    def put(self, key, value):\n        if key in self.hashMap:\n            self._remove(self.hashMap[key])\n        node = Node(key, value)\n        self.hashMap[key] = node\n        self._addLast(node)\n\n        if len(self.hashMap) > self.capacity:\n            head = self.doublyLinkedList\n            self.hashMap.pop(head.key)\n            self._remove(head)\n\n\n    def _remove(self, node):\n        prev = node.prev\n        next = node.next\n        if prev is not None:\n            prev.next = next\n        else:\n            self.doublyLinkedList = node.next\n        if next is not None:\n            next.prev = prev\n        else:\n            prev.next = None\n\n    def _addLast(self, node):\n        node.prev = self.doublyLinkedList\n        node.next = self.doublyLinkedList.next\n        if node.next is not None:\n            node.next.prev = node\n        else:\n            node.next = None\n        self.doublyLinkedList.next = node\n\n\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\ndef main():\n    cache = LRUCache(2)\n    print(cache.get(1))  # returns 1\n    cache.put(1, 1)\n    cache.put(2, 2)\n    print(cache.get(1))  # returns 1\n    cache.put(3, 3)      # evicts key 2\n    print(cache.get(2))   # returns -1 (not found)\n    print(cache.get(3))   # returns 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "147": "```\ndef insertionSortList(head):\n    dummy = ListNode(0)\n    curr = head\n    while curr:\n        prev = dummy\n        while prev.next and prev.next.val < curr.val:\n            prev = prev.next\n        temp = curr.next\n        curr.next = prev.next\n        prev.next = curr\n        curr = temp\n    return dummy.next\n\nclass Solution:\n    def insertionSortList(self, head):\n        return insertionSortList(head)\n\ndef main():\n    sol = Solution()\n    \n    # Test case 1:\n    node1 = ListNode(2)\n    node2 = ListNode(1)\n    head1 = node1\n    head1.next = node2\n    \n    print(\"Test Case 1: Insertion sort list\")\n    print(sol.insertionSortList(head1).val)\n\n    # Test case 2:\n    node3 = ListNode(5)\n    node4 = ListNode(3)\n    node5 = ListNode(4)\n    head2 = node3\n    head2.next = node4\n    head2.next.next = node5\n\n    print(\"\\nTest Case 2: Insertion sort list\")\n    print(sol.insertionSortList(head2).val)\n\n    # Test case 3:\n    node6 = ListNode(1)\n    node7 = ListNode(2)\n    node8 = ListNode(3)\n    head3 = node6\n    head3.next = node7\n    head3.next.next = node8\n\n    print(\"\\nTest Case 3: Insertion sort list\")\n    print(sol.insertionSortList(head3).val)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "148": "```\ndef sortList(head):\n    def quicksort(l, r):\n        if l >= r:\n            return\n        p = partition(l, r)\n        quicksort(l, p-1)\n        quicksort(p+1, r)\n\n    def partition(l, r):\n        pivot = head[l].val\n        i = l + 1\n        j = r\n        while True:\n            while i <= j and head[i-1].val < pivot:\n                i += 1\n            while i <= j and head[j].val > pivot:\n                j -= 1\n            if i <= j:\n                head[i-1], head[j] = head[j], head[i-1]\n                i, j = i + 1, j - 1\n            else:\n                head[l], head[j] = head[j], head[l]\n                return j\n\n    quicksort(0, len(head)-1)\n\ndef main():\n    class ListNode:\n        def __init__(self, val=0, next=None):\n            self.val = val\n            self.next = next\n\n    # Test case 1: A simple list with all distinct elements\n    head1 = ListNode(4)\n    head1.next = ListNode(2)\n    head1.next.next = ListNode(1)\n    head1.next.next.next = ListNode(3)\n    sortList(head1)\n\n    # Test case 2: A list with duplicates and some reversed order\n    head2 = ListNode(5)\n    head2.next = ListNode(5)\n    head2.next.next = ListNode(4)\n    head2.next.next.next = ListNode(3)\n    head2.next.next.next.next = ListNode(1)\n    head2.next.next.next.next.next = ListNode(2)\n    sortList(head2)\n\n    # Test case 3: An empty list\n    head3 = None\n    sortList(head3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "149": "```\ndef maxPoints(linePoints):\n    if not linePoints:\n        return 0\n\n    n = len(linePoints)\n    max_points = 0\n    for i in range(n):\n        slope_to_points = {}\n        same_points = 1\n        for j in range(i+1, n):\n            if linePoints[i] == linePoints[j]:\n                same_points += 1\n            else:\n                slope = float('inf')\n                if linePoints[j][0] - linePoints[i][0] != 0:\n                    slope = (linePoints[j][1] - linePoints[i][1]) * 1.0 / (linePoints[j][0] - linePoints[i][0])\n                if slope in slope_to_points:\n                    slope_to_points[slope] += 1\n                else:\n                    slope_to_points[slope] = 1\n        max_points_in_line = max(slope_to_points.values(), default=0) + same_points\n        max_points = max(max_points, max_points_in_line)\n\n    return max_points\n\ndef main():\n    print(maxPoints([[1, 1], [2, 2], [3, 3]])) # Should be 3\n    print(maxPoints([[1, 1], [3, 3]])) # Should be 2\n    print(maxPoints([[0, 0], [53, 191], [-15, -61], [-11, -32], [135, 519], [133, 511], [13, 47]])) # Should be 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "151": "```\ndef reverseWords(s):\n    return ' '.join(word[::-1] for word in s.split())\n\ndef main():\n    print(reverseWords(\"hello world\")) # \"olleh dlrow\"\n    print(reverseWords(\"a b c d e f g\")) # \"a b c d e f g\"\n    print(reverseWords(\"\")) # \"\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "150": "```\ndef evalRPN(stack):\n    ops = {'+': lambda x, y: x + y,\n           '-': lambda x, y: x - y,\n           '*': lambda x, y: x * y,\n           '/': lambda x, y: int(x / y) if x % y == 0 else int(y / x)}\n    \n    while len(stack) >= 2:\n        op = stack.pop()\n        y = int(stack.pop())\n        x = int(stack.pop())\n        \n        try:\n            stack.append(str(ops[op](x, y)))\n        except ZeroDivisionError:\n            return False\n    \n    return True if stack else None\n\ndef main():\n    test_cases = [\n        [\"2\", \"1\", \"+\", \"3\"],  # Should evaluate to 5\n        [\"4\", \"13\", \"5\", \"/-\",],  # Should evaluate to 6\n        [\"10\", \"6\", \"9\", \"3\", \"+\", \"-11\", \"*\", \"/\", \"*\", \"17\", \"+\", \"5\", \"+\"],  # Should evaluate to 22\n    ]\n\n    for test_case in test_cases:\n        stack = list(test_case)\n        print(f\"Test case: {test_case}, Result: {evalRPN(stack)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "152": "```\ndef maxProduct(nums):\n    if not nums:\n        return 0\n\n    res = nums[0]\n    min_val = nums[0]\n    result = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            res, min_val = min_val, res\n        res = max(nums[i], nums[i]*res)\n        min_val = min(min_val*nums[i], nums[i])\n        result = max(result, res)\n\n    return result\n\ndef main():\n    test_cases = [\n        [2,3,-2,4],\n        [-1,0,-1,10,5],\n        [0,2]\n    ]\n\n    for case in test_cases:\n        print(f\"Maximum Product Subarray: {case} -> {maxProduct(case)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "153": "```\ndef findMin(nums):\n    if len(nums) == 1:\n        return nums[0]\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        elif nums[mid] < nums[right]:\n            right = mid\n        else:\n            right -= 1\n    return nums[left]\n\ndef main():\n    print(findMin([3,4,5,1,2])) # Expected output: 1\n    print(findMin([2,1])) # Expected output: 1\n    print(findMin([7,8,9,10,11,12,13,0,1,2,3,4,5,6,7,8,9,10,11,12])) # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "154": "```\ndef findMin(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[right]:\n            left = mid + 1\n        elif nums[mid] < nums[right]:\n            right = mid\n        else:\n            right -= 1\n    return nums[left]\n\ndef main():\n    print(findMin([3,4,5,1,2])) # Expected output: 1\n    print(findMin([4,5,6,7,0,1,2])) # Expected output: 0\n    print(findMin([13,17,18,25,26,29,31,37,40])) # Expected output: 13\n\nif __name__ == \"__main__\":\n    main()\n```",
  "155": "```\nclass MinStack:\n\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        if not self.min_stack or x <= self.min_stack[-1]:\n            self.min_stack.append(x)\n\n    def pop(self) -> None:\n        if self.stack:\n            if self.stack.pop() == self.min_stack[-1]:\n                self.min_stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1] if self.stack else -1\n\n    def getMin(self) -> int:\n        return self.min_stack[-1] if self.min_stack else float('inf')\n\n\ndef main():\n    stack = MinStack()\n    \n    print(\"Test Case 1:\")\n    stack.push(10)\n    stack.push(20)\n    print(f\"Min: {stack.getMin()}\")\n    print(f\"Top: {stack.top()}\")\n    stack.pop()\n    print(f\"Min: {stack.getMin()}\")\n    print(f\"Top: {stack.top()}\")\n    \n    print(\"\\nTest Case 2:\")\n    stack = MinStack()\n    stack.push(5)\n    stack.push(3)\n    stack.push(15)\n    print(f\"Min: {stack.getMin()}\")\n    print(f\"Top: {stack.top()}\")\n    stack.pop()\n    print(f\"Min: {stack.getMin()}\")\n    print(f\"Top: {stack.top()}\")\n    \n    print(\"\\nTest Case 3:\")\n    stack = MinStack()\n    print(f\"Min: {stack.getMin()}\")\n    print(f\"Top: {stack.top()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n\n```",
  "156": "```\nclass Solution:\n    def upsideDownBinaryList(self, root):\n        if not root or not root.left:\n            return root\n        new_head = self.upsideDownBinaryList(root.right)\n        root.right = root.left\n        root.left = new_head\n        return root\n\n\ndef main():\n    sol = Solution()\n\n    # Test case 1\n    root1 = Node(1, None, Node(2, None, Node(3)))\n    result1 = sol.upsideDownBinaryList(root1)\n    print(\"Test case 1:\")\n    printTree(result1)\n\n    # Test case 2\n    root2 = Node(4, Node(2, Node(1), None), Node(3, None, Node(5)))\n    result2 = sol.upsideDownBinaryList(root2)\n    print(\"\\nTest case 2:\")\n    printTree(result2)\n\n    # Test case 3\n    root3 = Node(1, Node(2, None, Node(3, None, Node(4))))\n    result3 = sol.upsideDownBinaryList(root3)\n    print(\"\\nTest case 3:\")\n    printTree(result3)\n\n\nclass Node:\n    def __init__(self, val: int, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\ndef printTree(node):\n    if node is None:\n        return\n\n    printTree(node.right)\n    print(node.val, end=\" \")\n    printTree(node.left)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "157": "```\ndef read4(F):\n    result = \"\"\n    while True:\n        chunk = f.read(4)\n        for char in chunk:\n            if not char:\n                break\n            result += char\n        if len(chunk) < 4:\n            return result\n\n\ndef main():\n    test_case1()\n    test_case2()\n    test_case3()\n\n\ndef test_case1():\n    F = open(\"test.txt\", \"r\")\n    readed_file = \"\"\n    for i in range(5):\n        readed_file += read4(F)\n    print(readed_file)\n\n\ndef test_case2():\n    F = open(\"test.txt\", \"r\")\n    readed_file = \"\"\n    for i in range(7):\n        readed_file += read4(F)\n    print(readed_file)\n\n\ndef test_case3():\n    F = open(\"test.txt\", \"r\")\n    readed_file = \"\"\n    for i in range(8):\n        readed_file += read4(F)\n    print(readed_file)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "158": "```\ndef read4(FS):\n    result = \"\"\n    while True:\n        chunk = FS.read(4)\n        if len(chunk) < 4:\n            break\n        result += chunk.decode(\"utf-8\")\n    return result\n\n\ndef main():\n    FS = open(\"test.txt\", \"r\")\n    \n    test_case1 = read4(FS)\n    print(\"Test Case 1: \", test_case1)\n\n    FS.seek(0) \n\n    test_case2 = read4(FS)\n    print(\"Test Case 2: \", test_case2)\n\n    FS.seek(0) \n\n    test_case3 = read4(FS)\n    print(\"Test Case 3: \", test_case3)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "159": "```\ndef longest_substring(s):\n    if not s:\n        return 0\n    \n    max_length = 0\n    left = right = 0\n    char_count = {}\n    \n    while right < len(s):\n        if s[right] not in char_count:\n            char_count[s[right]] = 0\n        char_count[s[right]] += 1\n        \n        while len(char_count) > 2:\n            char_count[s[left]] -= 1\n            if char_count[s[left]] == 0:\n                del char_count[s[left]]\n            left += 1\n        \n        max_length = max(max_length, right - left + 1)\n        \n        right += 1\n    \n    return max_length\n\n\ndef main():\n    test_cases = [\n        {\"s\": \"eceba\", \"expected\": 4},\n        {\"s\": \"aa\", \"expected\": 2},\n        {\"s\": \"bbbloooop\", \"expected\": 3}\n    ]\n    \n    for case in test_cases:\n        print(\"Test case:\", case[\"s\"])\n        result = longest_substring(case[\"s\"])\n        if result == case[\"expected\"]:\n            print(\"Pass\")\n        else:\n            print(\"Fail, expected {} but got {}\".format(case[\"expected\"], result))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "160": "```\ndef getIntersectionNode(headA, headB):\n    if not headA or not headB:\n        return None\n    \n    nodeA = headA\n    nodeB = headB\n    \n    while nodeA != nodeB:\n        nodeA = headA if not nodeA else nodeA.next\n        nodeB = headB if not nodeB else nodeB.next\n        \n        if not nodeA or not nodeB:\n            return None\n    \n    return nodeA\n\ndef main():\n    # Test Case 1: Both lists have an intersection point.\n    print(\"Test Case 1:\")\n    headA = Node(4)\n    headA.next = Node(1)\n    headA.next.next = Node(8)\n    headB = Node(5)\n    headB.next = Node(6)\n    headB.next.next = headA.next\n    print(getIntersectionNode(headA, headB).val)  # Output: 1\n\n    # Test Case 2: No intersection point.\n    print(\"\\nTest Case 2:\")\n    headA = Node(4)\n    headA.next = Node(1)\n    headA.next.next = Node(8)\n    headB = Node(3)\n    headB.next = Node(2)\n    headB.next.next = Node(9)\n    print(getIntersectionNode(headA, headB))  # Output: None\n\n    # Test Case 3: Both lists have the same length.\n    print(\"\\nTest Case 3:\")\n    headA = Node(4)\n    headA.next = Node(1)\n    headA.next.next = Node(8)\n    headA.next.next.next = Node(9)\n    headB = Node(5)\n    headB.next = Node(6)\n    headB.next.next = Node(7)\n    headB.next.next.next = headA.next.next\n    print(getIntersectionNode(headA, headB).val)  # Output: 8\n\nclass Node:\n    def __init__(self, val=0):\n        self.val = val\n        self.next = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "161": "```\ndef oneEditDistance(s1, s2):\n    m, n = len(s1), len(s2)\n    if abs(m - n) > 1:\n        return False\n    if m == n:\n        i = j = diff = 0\n        while i < m and j < n:\n            if s1[i] != s2[j]:\n                diff += 1\n                if diff > 1:\n                    return False\n                if i != j:\n                    break\n            i, j = i + 1, j + 1\n        return diff <= 1\n    elif m < n:\n        i, j, k = 0, 0, 0\n        while i < m and j < n:\n            if s1[i] == s2[j]:\n                i, j = i + 1, j + 1\n            else:\n                k += 1\n                if k > 1:\n                    return False\n                j += 1\n        return k <= 1\n    else:\n        i, j, k = m - 1, n - 1, 0\n        while i >= 0 and j >= 0:\n            if s1[i] == s2[j]:\n                i, j = i - 1, j - 1\n            else:\n                k += 1\n                if k > 1:\n                    return False\n                j -= 1\n        return k <= 1\n\ndef main():\n    print(oneEditDistance(\"anxy\", \"anky\") == True)\n    print(oneEditDistance(\"pale\", \"plea\") == True)\n    print(oneEditDistance(\"ab\", \"ac\") == True)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "162": "```\ndef findPeakElement(nums):\n    if len(nums) == 1:\n        return 0\n    \n    for i in range(len(nums)):\n        if (i == 0 or nums[i-1] <= nums[i]) and (i == len(nums)-1 or nums[i] >= nums[i+1]):\n            return i\n\ndef main():\n    print(\"Test case 1: \")\n    nums = [1,2,3,1]\n    print(findPeakElement(nums)) # Output: 2\n\n    print(\"\\nTest case 2: \")\n    nums = [1,2,1,3,5,6,4]\n    print(findPeakElement(nums)) # Output: 5\n\n    print(\"\\nTest case 3: \")\n    nums = [1]\n    print(findPeakElement(nums)) # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "163": "```\ndef findMissingRanges(nums):\n    nums = [float('-inf')] + nums + [float('inf')]\n    ranges = []\n    for i in range(1, len(nums)):\n        if nums[i] != nums[i-1]+1:\n            start = nums[i-1]+1\n            end = nums[i]-1 if i == len(nums)-1 else nums[i]\n            ranges.append(f'[{start},{end}]' if start!=end else f'[{}]')\n    return ranges\n\ndef main():\n    print(findMissingRanges([0, 1, 3, 4, 6, 7, 9])) \n    print(findMissingRanges([1, 2, 3, 5, 6]))  \n    print(findMissingRanges([-1, 0, 1, 5, 6]) )\n\nif __name__ == \"__main__\":\n    main()\n```",
  "164": "```\ndef maximumGap(nums):\n    if len(nums) < 2:\n        return 0\n    nums = [x*100 + int(str(x)[0]) for x in sorted((x, i) for i, x in enumerate(nums))]\n    max_gap = 0\n    prev = float('inf')\n    for x, _ in sorted(nums):\n        if x > prev:\n            max_gap = max(max_gap, x - prev)\n        prev = x\n    return (max_gap // 100) if max_gap else 0\n\ndef main():\n    print(maximumGap([3,2,1])) # Expected: 1\n    print(maximumGap([0,4])) # Expected: 4\n    print(maximumGap([10]])) # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "165": "```\ndef compareVersion(version1, version2):\n    v1 = list(map(int, version1.split('.')))\n    v2 = list(map(int, version2.split('.')))\n\n    while len(v1) < len(v2):\n        v1.append(0)\n    while len(v2) < len(v1):\n        v2.append(0)\n\n    for i in range(len(v1)):\n        if v1[i] > v2[i]:\n            return 1\n        elif v1[i] < v2[i]:\n            return -1\n\n    return 0\n\n\ndef main():\n    print(compareVersion(\"1.0\", \"1\"))  # Expected: 1\n    print(compareVersion(\"1.0.3\", \"1.0.2\"))  # Expected: 1\n    print(compareVersion(\"1.10.5.8\", \"1.10.5\"))  # Expected: -1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "166": "```\ndef fractionToDecimal(numerator: int, denominator: int) -> str:\n    if numerator == 0:\n        return \"0\"\n\n    result = \"\"\n    if (numerator > 0) != (denominator > 0):\n        result += \"-\"\n\n    numerator, remainder = divmod(abs(numerator), abs(denominator))\n    result += str(numerator)\n\n    if remainder:\n        result += \".\"\n        decimal = {}\n        while remainder:\n            decimal[remainder], remainder = divmod(remainder * 10, denominator)\n            result += str(decimal[remainder])\n            if remainder: \n                result += \" \"\n\n        while len(result) < len(str(abs(numerator))) + len(str(abs(denominator))):\n            result += \"0\"\n\n    return result\n\n\ndef main():\n    print(fractionToDecimal(2, 1))  # Output: \"2\"\n    print(fractionToDecimal(4, 333))  # Output: \"1.(0)\"\n    print(fractionToDecimal(-50, 2))  # Output: \"-25.\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "167": "```\ndef twoSumSortedArray(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        current_sum = nums[left] + nums[right]\n        if current_sum == target:\n            return [left + 1, right + 1]\n        elif current_sum < target:\n            left += 1\n        else:\n            right -= 1\n\ndef main():\n    print(twoSumSortedArray([2,7,11,15],9)) \n    print(twoSumSortedArray([2,3,4,5,6,7,8,9],10))\n    print(twoSumSortedArray([-1,-2,-3,-5,0,1,2,3,4,5,6,7,8,9], 10))\n\nmain()\n```",
  "168": "```\ndef columnTitle(n):\n    res = \"\"\n    while n > 0:\n        n, remainder = divmod(n - 1, 26)\n        res = chr(65 + remainder) + res\n    return res\n\ndef main():\n    print(\"Test Case 1: \")\n    print(columnTitle(701)) # Expected output: \"ZY\"\n    \n    print(\"\\nTest Case 2: \")\n    print(columnTitle(28)) # Expected output: \"AB\"\n\n    print(\"\\nTest Case 3: \")\n    print(columnTitle(52)) # Expected output: \"FF\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "169": "```\ndef majorityElement(nums):\n    count = {}\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n    max_count = max(count.values())\n    return [num for num, cnt in count.items() if cnt == max_count][0]\n\ndef main():\n    print(majorityElement([2,2,1,1,1,2,2])) # Should print 2\n    print(majorityElement([3,3,4,2,4,4,2])) # Should print 3\n    print(majorityElement([6,6,6,7,7,7,8,8,8,9,9,9,9])) # Should print 9\n\nif __name__ == \"__main__\":\n    main()\n```",
  "170": "```\ndef twoSum(num, target):\n    hash_map = {}\n    for i in range(len(num)):\n        complement = target - num[i]\n        if complement in hash_map:\n            return [hash_map[complement], i]\n        hash_map[num[i]] = i\n    return []\n\ndef main():\n    print(twoSum([1,2,3], 4))  # Output: [0, 1]\n    print(twoSum([3,3], 6))   # Output: [0, 1]\n    print(twoSum([5,5,10], 15))  # Output: [1, 2]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "171": "```\ndef convert_to_title(n):\n    result = \"\"\n    while n > 0:\n        n, remainder = divmod(n - 1, 26)\n        result = chr(65 + remainder) + result\n    return result\n\ndef main():\n    print(\"Test Case 1:\")\n    print(convert_to_title(1))  # Should be \"A\"\n    print()\n    \n    print(\"Test Case 2:\")\n    print(convert_to_title(28))  # Should be \"AB\"\n    print()\n    \n    print(\"Test Case 3:\")\n    print(convert_to_title(701))  # Should be \"ZY\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "172": "```\ndef factorialTrailingZeroes(n):\n    count = 0\n    i = 5\n    while n // i >= 1:\n        count += n // i\n        i *= 5\n    return count\n\n\ndef main():\n    print(\"Test case 1: \", factorialTrailingZeroes(3))\n    print(\"Test case 2: \", factorialTrailingZeroes(5))\n    print(\"Test case 3: \", factorialTrailingZeroes(10))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "173": "```\ndef printTree(root):\n    if root:\n        printTree(root.left)\n        print(root.val),\n        printTree(root.right)\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass BSTIterator:\n\n    def __init__(self, root: 'TreeNode'):\n        self.stack = []\n        self.pushLeft(root)\n\n    def next(self):\n        if not self.hasNext():\n            return None\n        node = self.stack.pop()\n        if node.right:\n            self.pushLeft(node.right)\n        return node.val\n\n    def hasNext(self):\n        return bool(self.stack)\n\n    def pushLeft(self, root: 'TreeNode'):\n        while root:\n            self.stack.append(root)\n            root = root.left\n\ndef main():\n    # Test case 1\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(5)\n    root.right.right = TreeNode(7)\n\n    iterator = BSTIterator(root)\n    print(\"Test case 1:\")\n    while iterator.hasNext():\n        print(iterator.next())\n    print()\n\n    # Test case 2\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    iterator = BSTIterator(root)\n    print(\"Test case 2:\")\n    while iterator.hasNext():\n        print(iterator.next())\n    print()\n\n    # Test case 3\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(6)\n\n    iterator = BSTIterator(root)\n    print(\"Test case 3:\")\n    while iterator.hasNext():\n        print(iterator.next())\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "174": "```\ndef min_killed_enemies(kills):\n    n = len(kills)\n    dp = [[0]*n for _ in range(n)]\n    ans = 0\n    for i in range(1, n):\n        for j in range(i):\n            if kills[j] < i:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1\n                ans = max(ans, dp[i][j])\n    return ans\n\ndef main():\n    print(min_killed_enemies([2,0,4])) # Expected: 3\n    print(min_killed_enemies([5,9,6])) # Expected: 3\n    print(min_killed_enemies([1])) # Expected: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "175": "```\ndef combineTables(table1, table2):\n    result = set()\n    for row in table1:\n        key = tuple(row[0:2])\n        if key not in result:\n            result.add(key)\n    for row in table2:\n        key = tuple(row[0:2])\n        if key not in result:\n            result.add(key)\n    return list(result)\n\ndef main():\n    test_case_1_table1 = [(\"Julia\", \"F\"), (\"Bob\", \"M\")]\n    test_case_1_table2 = [(\"Bob\", \"M\"), (\"Maria\", \"F\")]\n    print(combineTables(test_case_1_table1, test_case_1_table2))\n\n    test_case_2_table1 = [(\"John\", \"M\"), (\"Jane\", \"F\"), (\"Alice\", \"F\")]\n    test_case_2_table2 = [(\"Bob\", \"M\"), (\"Maria\", \"F\"), (\"John\", \"M\")]\n    print(combineTables(test_case_2_table1, test_case_2_table2))\n\n    test_case_3_table1 = []\n    test_case_3_table2 = [(\"Alice\", \"F\"), (\"Bob\", \"M\"), (\"Charlie\", \"M\")]\n    print(combineTables(test_case_3_table1, test_case_3_table2))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "176": "```\ndef secondHighestSalary(self, salaries):\n    max_salary = float('-inf')\n    second_max_salary = float('-inf')\n\n    for salary in salaries:\n        if salary > max_salary:\n            second_max_salary = max_salary\n            max_salary = salary\n        elif salary < max_salary and salary > second_max_salary:\n            second_max_salary = salary\n\n    return -1 if second_max_salary == float('-inf') else second_max_salary\n\n\ndef main():\n    employees = [\n        {\"id\": 1, \"salary\": 200000},\n        {\"id\": 2, \"salary\": 300000},\n        {\"id\": 3, \"salary\": 400000},\n        {\"id\": 4, \"salary\": 500000}\n    ]\n\n    print(\"Second highest salary for the first set of employees:\", \n          secondHighestSalary([employee[\"salary\"] for employee in employees]))\n\n    employees = [\n        {\"id\": 1, \"salary\": 1000},  \n        {\"id\": 2, \"salary\": 2000},\n        {\"id\": 3, \"salary\": 3000}\n    ]\n\n    print(\"Second highest salary for the second set of employees:\", \n          secondHighestSalary([employee[\"salary\"] for employee in employees]))\n\n    employees = [\n        {\"id\": 1, \"salary\": 100},  \n        {\"id\": 2, \"salary\": 200},\n        {\"id\": 3, \"salary\": 1000}\n    ]\n\n    print(\"Second highest salary for the third set of employees:\", \n          secondHighestSalary([employee[\"salary\"] for employee in employees]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "177": "```\ndef nthHighestSalary(self, salaries: List[int], n: int) -> int:\n    if not salaries or n < 1:\n        return None\n    salaries = sorted(set(salaries), reverse=True)\n    if n > len(salaries):\n        return -1\n    return salaries[n-1]\n\ndef main():\n    print(nthHighestSalary([1000000, 999000], 2)) \n    print(nthHighestSalary([5,3]), 1))\n    print(nthHighestSalary([5,5], 1))\n\nmain()\n```",
  "178": "```\ndef findRankScores(scores):\n    ranks = {}\n    for i, score in enumerate(sorted(scores)):\n        if score not in ranks:\n            ranks[score] = i+1\n    return [''.join(f'#{i}' for i in map(str, sorted(ranks.values())))].index(''.join(map(str, [sorted(ranks.keys())[j-1] for j in range(1, 301)])))\n\ndef main():\n    scores = [100,200,300,400]\n    print(findRankScores(scores))  # Output: '#14'\n\n    scores = [37,62,30,101,100,5,50]\n    print(findRankScores(scores))  # Output: '#8'\n\n    scores = [37,62,30,40,100,70,80,10,100,99]\n    print(findRankScores(scores))  # Output: '#7'\n\nif __name__ == \"__main__\":\n    main()\n```",
  "179": "```\ndef largest_number(nums):\n    from functools import cmp_to_key\n    nums = list(map(str, nums))\n    nums.sort(key=cmp_to_key(lambda x, y: int(y + x) - int(x + y)))\n    return ''.join(nums).lstrip('0') or '0'\n\ndef main():\n    print(largest_number([3, 30, 34, 5, 9])) \n    print(largest_number([10,2]))  \n    print(largest_number([1,5,2]))\n\nmain()\n```",
  "180": "```\ndef findConsecutiveNumbers(nums):\n    if not nums:\n        return []\n\n    num_set = set()\n    result = []\n    for num in nums:\n        if num - 1 in num_set:\n            result.append(list(num_set))\n            num_set.clear()\n        num_set.add(num)\n\n    if num_set:\n        result.append(list(num_set))\n\n    return result\n\n\ndef main():\n    print(findConsecutiveNumbers([5,6,100,2,101,3])) # Expected: [[5, 6], [100, 101], [2, 3]]\n    print(findConsecutiveNumbers([1,2,3,4,5])) # Expected: [[1, 2, 3, 4, 5]]\n    print(findConsecutiveNumbers([0,3,7,2,5,8,4,6,10,1,9])) # Expected: [[0, 1], [2, 3], [4, 5], [6, 7, 8, 9, 10]]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "181": "```\ndef getEmployeesEarningMoreThanTheirManagers(employees):\n    salary_dict = {}\n    for employee in employees:\n        if employee[1] not in salary_dict:\n            salary_dict[employee[1]] = employee[2]\n        else:\n            if employee[2] > salary_dict[employee[1]]:\n                salary_dict[employee[1]].append(employee)\n            elif employee[2] == salary_dict[employee[1]]:\n                salary_dict[employee[1]].append(employee)\n\n    return [(manager, len(employees)) for manager, employees in salary_dict.items() if len(employees) > 0]\n\ndef main():\n    test_case1 = [\n        [\"John\", \"Aasen\", 100000],\n        [\"Jane\", \"John\", 50000],\n        [\"Jim\", \"John\", 90000],\n        [\"Alice\", \"Jane\", 30000]\n    ]\n    \n    test_case2 = [\n        [\"Jhonny\", \"Bobby\", 150000],\n        [\"Bobbi\", \"Jhonny\", 125000],\n        [\"Marty\", \"Bobbi\", 110000],\n        [\"Martha\", \"Marty\", 120000],\n        [\"Sara\", \"Martha\", 130000]\n    ]\n    \n    test_case3 = [\n        [\"Tom\", \"Jerry\", 10000],\n        [\"Jerry\", \"Tom\", 5000],\n        [\"Sarah\", \"Jerry\", 6000],\n        [\"Bob\", \"Sarah\", 3000]\n    ]\n\n    print(getEmployeesEarningMoreThanTheirManagers(test_case1))\n    print(getEmployeesEarningMoreThanTheirManagers(test_case2))\n    print(getEmployeesEarningMoreThanTheirManagers(test_case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "182": "```\ndef findDuplicates(emails):\n    seen = set()\n    duplicates = set()\n    for email in emails:\n        if email in seen:\n            duplicates.add(email)\n        else:\n            seen.add(email)\n    return list(duplicates)\n\ndef main():\n    test_cases = [\n        {\"emails\": [\"john@example.com\", \"jane@example.com\", \"john@example.com\"], \n         \"expected\": [\"john@example.com\"]},\n        {\"emails\": [\"a1@example.com\", \"b2@example.com\", \"c3@example.com\"], \n         \"expected\": []},\n        {\"emails\": [\"user1@example.com\", \"user2@example.com\", \"user1@example.com\", \"user3@example.com\"], \n         \"expected\": [\"user1@example.com\"]}\n    ]\n    \n    for test_case in test_cases:\n        result = findDuplicates(test_case[\"emails\"])\n        if sorted(result) == sorted(test_case[\"expected\"]):\n            print(\"Test case passed.\")\n        else:\n            print(\"Test case failed. Expected: {}, got: {}\".format(test_case[\"expected\"], result))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "183": "```\ndef read_orders(orders):\n    customer_orders = {}\n    for order in orders:\n        customer_orders[order[1]] = customer_orders.get(order[1], []) + [order[0]]\n    return customer_orders\n\ndef get_customers_who_never_order(customers, orders):\n    never_ordered = set(customers.keys())\n    never_ordered -= set(i for i in read_orders(orders).keys() if read_orders(orders)[i])\n    return list(never_ordered)\n\ndef main():\n    customers = [(\"John\", 1), (\"Alice\", 2), (\"Bob\", 3)]\n    orders = [(\"Order1\", \"John\"), (\"Order2\", \"John\"), (\"Order3\", \"Alice\")]\n    result = get_customers_who_never_order(customers, orders)\n    \n    print(\"Test Case 1:\")\n    print(result)  # Output: ['Bob']\n\n    customers = [(\"Mary\", 4), (\"Jane\", 5), (\"Peter\", 6)]\n    orders = []\n    result = get_customers_who_never_order(customers, orders)\n    \n    print(\"\\nTest Case 2:\")\n    print(result)  # Output: ['Mary', 'Jane', 'Peter']\n\n    customers = [(\"John1\", 7), (\"Alice1\", 8), (\"Bob1\", 9)]\n    orders = [(\"Order1\", \"John1\"), (\"Order2\", \"Alice1\")]\n    result = get_customers_who_never_order(customers, orders)\n    \n    print(\"\\nTest Case 3:\")\n    print(result)  # Output: ['Bob1']\n\nif __name__ == \"__main__\":\n    main()\n```",
  "184": "```\ndef highestSalary(self, employees):\n    salaries = {}\n    for employee in employees:\n        department_id = employee[\"departmentId\"]\n        salary = employee[\"salary\"]\n        if department_id not in salaries or salary > salaries[department_id]:\n            salaries[department_id] = salary\n    return list(salaries.items())\n\ndef main():\n    employees1 = [\n        {\"id\": 1, \"departmentId\": 1, \"salary\": 100000},\n        {\"id\": 2, \"departmentId\": 1, \"salary\": 150000},\n        {\"id\": 3, \"departmentId\": 2, \"salary\": 200000},\n    ]\n    print(highestSalary(employees1))\n\n    employees2 = [\n        {\"id\": 4, \"departmentId\": 1, \"salary\": 100000},\n        {\"id\": 5, \"departmentId\": 1, \"salary\": 110000},\n        {\"id\": 6, \"departmentId\": 3, \"salary\": 250000},\n    ]\n    print(highestSalary(employees2))\n\n    employees3 = [\n        {\"id\": 7, \"departmentId\": 2, \"salary\": 300000},\n        {\"id\": 8, \"departmentId\": 2, \"salary\": 350000},\n        {\"id\": 9, \"departmentId\": 1, \"salary\": 100000},\n    ]\n    print(highestSalary(employees3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "185": "```\ndef top3Salary(self, salaries: List[List[str]]) -> List[float]:\n    pass\n\ndef main():\n    salaries = [[1000000, \"John\"], [700000, \"Alice\"], [900000, \"Bob\"], \n               [600000, \"Eve\"], [800000, \"Mike\"]]\n    \n    print(top3Salary(None, salaries))\n\n    salaries2 = [[\"100\", \"John\"], [\"70\", \"Alice\"], [\"90\", \"Bob\"], [\"60\", \"Eve\"], [\"80\", \"Mike\"]]\n    \n    print(top3Salary(None, [[float(salary[0]) for salary in salaries2]]))\n\n    salaries3 = [[1.0, \"John\"], [0.7, \"Alice\"], [0.9, \"Bob\"], [0.6, \"Eve\"], [0.8, \"Mike\"]]\n    \n    print(top3Salary(None, [[float(salary[0]) for salary in salaries3]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "186": "```\ndef reverseWords(s):\n    words = s.split(\" \")\n    reversed_words = [word[::-1] for word in words]\n    return \" \".join(reversed_words)\n\ndef main():\n    print(reverseWords(\"God is good\"))\n    print(reverseWords(\"hello world\"))\n    print(reverseWords(\"alibaba is testing\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "187": "```\ndef findRepeatedDnaSequences(s):\n    seen = set()\n    twice_seen = set()\n\n    for i in range(len(s) - 9 + 1):\n        seq = s[i:i+10]\n        if seq in seen:\n            twice_seen.add(seq)\n        else:\n            seen.add(seq)\n\n    return list(twice_seen)\n\n\ndef main():\n    test_cases = [\n        {\"s\": \"AAAAACCCCC\", \"expected_result\": [\"ACC\",\"AAG\"]},\n        {\"s\": \"AAAAAAABCBLHHEGGHQEJJQPRPHXFFYXYWFZRTATRYUUYTRETYUUYTTRETYUU\"}, \n        {\"s\": \"\", \"expected_result\": []}\n    ]\n\n    for test_case in test_cases:\n        result = findRepeatedDnaSequences(test_case[\"s\"])\n        if result == test_case[\"expected_result\"]:\n            print(\"Test case passed\")\n        else:\n            print(\"Test case failed\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "188": "```\ndef maxProfit(k, prices):\n    n = len(prices)\n    if k > n // 2:\n        return sum(x - y for x, y in zip(prices[1:], prices[:-1]) if x > y)\n\n    dp = [[0] * (k + 1) for _ in range(n)]\n    min_price = [float('inf')] * (n + 1)\n    max_profit = 0\n\n    for i in range(1, n):\n        diff = prices[i] - prices[i - 1]\n        for j in range(min(k, i), 0, -1):\n            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1] + diff)\n            min_price[i] = min(min_price[i], prices[i] - dp[i][j])\n        max_profit = max(max_profit, min_price[i])\n\n    return max_profit\n\ndef main():\n    print(\"Test Case 1:\")\n    print(maxProfit(2, [7,1,5,3,6,4])) # Expected: 7\n    print()\n\n    print(\"Test Case 2:\")\n    print(maxProfit(1, [2,4,1])) # Expected: 2\n    print()\n\n    print(\"Test Case 3:\")\n    print(maxProfit(3, [2,1,2])) # Expected: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "189": "```\ndef rotate(nums, k):\n    n = len(nums)\n    k %= n\n    nums[:] = nums[-k:] + nums[:-k]\n\ndef main():\n    test_cases = [\n        {\"nums\": [1,2,3,4,5,6,7], \"k\": 3, \"expected\": [5,6,7,1,2,3,4]},\n        {\"nums\": [0,1,2], \"k\": 4, \"expected\": [2,0,1]},\n        {\"nums\": [-1,-100,3,99], \"k\": 2, \"expected\": [99,-1,-100,3]}\n    ]\n\n    for test_case in test_cases:\n        nums = test_case[\"nums\"][:]\n        k = test_case[\"k\"]\n        expected = test_case[\"expected\"]\n\n        rotate(nums, k)\n        if nums != expected:\n            print(f\"Test case failed: {test_case}\")\n            print(f\"Expected: {expected}\")\n            print(f\"Got: {nums}\")\n        else:\n            print(\"Test case passed\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "190": "```\ndef reverseBits(n):\n    result = 0\n    for _ in range(32):\n        result = (result << 1) | ((n & 1) ^ ((n >> 31) & 1))\n        n >>= 1\n    return result\n\ndef main():\n    print(\"Test Case 1:\")\n    assert reverseBits(0b00000010101010011101111000001111) == 0b11111101111111100111111111111100\n    print(\"Test Case 2:\")\n    assert reverseBits(3) == 3\n    print(\"Test Case 3:\")\n    assert reverseBits(4369028749479127435) == 3054198968252137839\n\nif __name__ == \"__main__\":\n    main()\n```",
  "191": "```\ndef hammingWeight(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n\n\ndef main():\n    print(\"Test case 1: hammingWeight(9) should be 4\")\n    print(hammingWeight(9))  # Output: 4\n\n    print(\"\\nTest case 2: hammingWeight(10) should be 1\")\n    print(hammingWeight(10))  # Output: 1\n\n    print(\"\\nTest case 3: hammingWeight(256) should be 1\")\n    print(hammingWeight(256))  # Output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "192": "```\ndef word_frequency(sentence):\n    from collections import Counter\n    words = sentence.split()\n    frequency = Counter(words)\n    return dict(frequency)\n\ndef main():\n    print(word_frequency(\"apple apple banana\"))\n    print(word_frequency(\"hello world hello world\"))\n    print(word_frequency(\"a b c a b c\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "193": "```\ndef validPhoneNumber(phoneNumber):\n    if len(phoneNumber) != 12:\n        return False\n    for char in phoneNumber:\n        if not char.isalnum():\n            return False\n        if char.isdigit() and len(char) > 1:\n            return False\n    return True\n\n\ndef main():\n    test_cases = [\n        {\"phoneNumber\": \"123-456-7890\", \"expectedOutput\": True},\n        {\"phoneNumber\": \"123-4567\", \"expectedOutput\": False},\n        {\"phoneNumber\": \"(123)-456-7890\", \"expectedOutput\": True}\n    ]\n\n    for test_case in test_cases:\n        phoneNumber = test_case[\"phoneNumber\"]\n        expected_output = test_case[\"expectedOutput\"]\n\n        actual_output = validPhoneNumber(phoneNumber)\n\n        if actual_output != expected_output:\n            print(f\"Test case failed: {phoneNumber} (Expected {expected_output}, got {actual_output})\")\n        else:\n            print(f\"Test case passed: {phoneNumber}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "194": "```\ndef processFile(filename):\n    with open(filename, 'r') as f:\n        lines = [line.strip().split() for line in f.readlines()]\n\n    result = [[lines[j][i] for j in range(len(lines))] for i in range(len(lines[0]))]\n\n    with open(f\"{filename}.trans\", 'w') as f:\n        for row in result:\n            print(' '.join(row), file=f)\n\ndef main():\n    processFile(\"testcase1.txt\")\n    processFile(\"testcase2.txt\")\n    processFile(\"testcase3.txt\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "195": "```\ndef findTenthLine(filename):\n    count = 0\n    for line in open(filename, 'r'):\n        count += 1\n        if count == 10:\n            return line.strip()\n\ndef main():\n    print(findTenthLine('test.txt') == \"This is the tenth line.\\n\")\n    print(findTenthLine('test2.txt') == \"This is not the tenth line.\")\n    print(findTenthLine('test3.txt') == \"\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "196": "```\ndef deleteDuplicateEmails(emails):\n    emails = list(set([email for email in emails if not email.startswith(\"joe\")]))\n    return sorted(list(set([tuple(sorted((name, email).split('@'))[1:]) + [name] for name, email in [(f\"j{i}@example.com\", f\"j{i}\") for i in range(10)]])))\n\ndef main():\n    print(deleteDuplicateEmails([\"joe2345@example.com\", \"joe1234@example.com\", \"joe4567@example.com\", \"alice999@example.com\"]))\n    print(deleteDuplicateEmails([\"a1@example.com\", \"a2@example.com\", \"a3@example.com\", \"b@example.com\"]))\n    print(deleteDuplicate Emails([\"john@example.com\", \"doe@example.com\", \"john.doe@example.com\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "197": "```\ndef findingRisingTemp(logs):\n    temp_map = {}\n    for log in logs:\n        id_, datetime, temp = log\n        if int(temp) > temp_map.get(id_, 0):\n            temp_map[id_] = int(temp)\n    return len([id_ for id_ in temp_map])\n\ndef main():\n    logs1 = [[\"101\", \"2023-02-01 13:23\", \"-10.5\"], \n             [\"101\", \"2023-03-01 14:20\", \"30\"], \n             [\"102\", \"2023-04-01 15:35\", \"45\"]]\n    print(findingRisingTemp(logs1)) # Output: 1\n\n    logs2 = [[\"101\", \"2023-02-01 13:23\", \"-10.5\"], \n             [\"101\", \"2023-03-01 14:20\", \"30\"], \n             [\"102\", \"2023-04-01 15:35\", \"45\"], \n             [\"103\", \"2023-05-01 16:40\", \"48\"]]\n    print(findingRisingTemp(logs2)) # Output: 1\n\n    logs3 = [[\"101\", \"2023-02-01 13:23\", \"-10.5\"], \n             [\"102\", \"2023-04-01 15:35\", \"45\"], \n             [\"103\", \"2023-05-01 16:40\", \"48\"]]\n    print(findingRisingTemp(logs3)) # Output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "198": "```\ndef rob(nums):\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    if n <= 2:\n        return max(nums)\n    \n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = nums[0]\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + nums[i])\n    \n    return dp[-1]\n\ndef main():\n    print(rob([2,7,9,3,1]))  # Expected output: 12\n    print(rob([0,0]))         # Expected output: 0\n    print(rob([5,1,1,5]))     # Expected output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "199": "```\nclass Solution:\n    def rightSideView(self, root):\n        if not root:\n            return []\n\n        def traverse(node, level):\n            if node:\n                if len(result) <= level:\n                    result.append([node.val])\n                else:\n                    result[level].append(node.val)\n\n                left = traverse(node.left, level + 1)\n                right = traverse(node.right, level + 1)\n\n        result = []\n        traverse(root, 0)\n        return [i[0] for i in result]\n\ndef main():\n    solution = Solution()\n    \n    # Test case 1\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    root1.left.right = TreeNode(5)\n    print(solution.rightSideView(root1))\n\n    # Test case 2\n    root2 = TreeNode(1)\n    root2.right = TreeNode(2)\n    print(solution.rightSideView(root2))\n\n    # Test case 3\n    root3 = TreeNode(1)\n    root3.left = TreeNode(2)\n    print(solution.rightSideView(root3))\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "200": "```\ndef numIslands(grid):\n    if not grid:\n        return 0\n    \n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(grid, i, j)\n                count += 1\n    return count\n\ndef dfs(grid, i, j):\n    if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]!='1':\n        return \n    grid[i][j] = '0'\n    dfs(grid, i+1, j)\n    dfs(grid, i-1, j)\n    dfs(grid, i, j+1)\n    dfs(grid, i, j-1)\n\ndef main():\n    test_case_1 = [\n        [\"1\",\"1\",\"1\",\"1\",\"0\"],\n        [\"1\",\"1\",\"0\",\"1\",\"0\"],\n        [\"1\",\"1\",\"0\",\"0\",\"0\"],\n        [\"0\",\"0\",\"0\",\"0\",\"0\"]\n    ]\n    print(numIslands(test_case_1))  # Output: 1\n\n    test_case_2 = [\n        [\"1\",\"1\",\"0\",\"0\",\"0\"],\n        [\"1\",\"1\",\"1\",\"0\",\"0\"],\n        [\"0\",\"0\",\"1\",\"0\",\"0\"],\n        [\"0\",\"0\",\"0\",\"1\",\"1\"]\n    ]\n    print(numIslands(test_case_2))  # Output: 3\n\n    test_case_3 = [\n        []\n    ]\n    print(numIslands(test_case_3))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "201": "```\ndef rangeBitwiseAnd(m, n):\n    shift = 0\n    while m < n:\n        m >>= 1\n        n >>= 1\n        shift += 1\n    return m << shift\n\ndef main():\n    print(\"Test case 1:\")\n    print(rangeBitwiseAnd(5, 8), end=\" \")\n    print(2)\n\n    print(\"\\nTest case 2:\")\n    print(rangeBitwiseAnd(0, 0), end=\" \")\n    print(0)\n\n    print(\"\\nTest case 3:\")\n    print(rangeBitwiseAnd(16, 24), end=\" \")\n    print(8)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "202": "```\ndef isHappy(n):\n    seen = set()\n    while n != 1 and n not in seen:\n        seen.add(n)\n        n = sum(int(i) ** 2 for i in str(n))\n    return n == 1\n\ndef main():\n    print(isHappy(19)) # False\n    print(isHappy(20)) # True\n    print(isHappy(2))   # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "204": "```\ndef countPrimes(n):\n    if n <= 2:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n    p = 2\n    \n    while p * p <= n:\n        if primes[p]:\n            for i in range(p*p, n, p):\n                primes[i] = False\n        p += 1\n    \n    return sum(primes)\n\ndef main():\n    print(countPrimes(10)) # Output: 4\n    print(countPrimes(15)) # Output: 8\n    print(countPrimes(25)) # Output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "203": "```\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef removeElements(head: ListNode) -> ListNode:\n    if head is None:\n        return None\n    \n    dummyHead = ListNode(0)\n    current = dummyHead\n    \n    while head is not None:\n        if head.val != val:\n            current.next = head\n            current = current.next\n        head = head.next\n    \n    current.next = None\n    return dummyHead.next\n\ndef main():\n    # Test case 1: Remove all elements\n    node5 = ListNode(5)\n    node4 = ListNode(4)\n    node3 = ListNode(3)\n    node2 = ListNode(2)\n    node1 = ListNode(1)\n\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n\n    result = removeElements(node1)\n    while result is not None:\n        print(result.val, end=\" \")\n        result = result.next\n    print()\n\n    # Test case 2: Remove some elements\n    node5 = ListNode(5)\n    node4 = ListNode(4)\n    node3 = ListNode(3)\n    node2 = ListNode(2)\n    node1 = ListNode(1)\n\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n\n    val = 3\n    result = removeElements(node1, val)\n    while result is not None:\n        print(result.val, end=\" \")\n        result = result.next\n    print()\n\n    # Test case 3: Remove all elements except one\n    node5 = ListNode(5)\n    node4 = ListNode(4)\n    node3 = ListNode(3)\n    node2 = ListNode(2)\n    node1 = ListNode(1)\n\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n\n    val = 1\n    result = removeElements(node1, val)\n    while result is not None:\n        print(result.val, end=\" \")\n        result = result.next\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "205": "```\ndef is_isomorphic(s, t):\n    if len(s) != len(t):\n        return False\n\n    s_to_t = {}\n    t_to_s = {}\n\n    for i in range(len(s)):\n        if s[i] not in s_to_t:\n            s_to_t[s[i]] = t[i]\n        else:\n            if s_to_t[s[i]] != t[i]:\n                return False\n        if t[i] not in t_to_s:\n            t_to_s[t[i]] = s[i]\n        else:\n            if t_to_s[t[i]] != s[i]:\n                return False\n\n    return True\n\n\ndef main():\n    print(is_isomorphic(\"egg\", \"add\"))  # Expected output: True\n    print(is_isomorphic(\"foo\", \"bar\"))  # Expected output: False\n    print(is_isomorphic(\"paper\", \"title\"))  # Expected output: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "206": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef reverseList(head):\n    prev = None\n    current = head\n    while current is not None:\n        next_node = current.next\n        current.next = prev\n        prev = current\n        current = next_node\n    return prev\n\ndef print_list(head):\n    node = head\n    while node is not None:\n        print(node.val, end=\" \")\n        node = node.next\n    print()\n\ndef main():\n    # Test case 1: Reverse a linked list with 3 nodes\n    head1 = ListNode(1)\n    head1.next = ListNode(2)\n    head1.next.next = ListNode(3)\n    print(\"Original List:\", end=\" \")\n    print_list(head1)\n    reversed_head1 = reverseList(head1)\n    print(\"Reversed List:\", end=\" \")\n    print_list(reversed_head1)\n\n    # Test case 2: Reverse a linked list with 5 nodes\n    head2 = ListNode(4)\n    head2.next = ListNode(3)\n    head2.next.next = ListNode(2)\n    head2.next.next.next = ListNode(1)\n    head2.next.next.next.next = ListNode(0)\n    print(\"\\nOriginal List:\", end=\" \")\n    print_list(head2)\n    reversed_head2 = reverseList(head2)\n    print(\"Reversed List:\", end=\" \")\n    print_list(reversed_head2)\n\n    # Test case 3: Reverse an empty linked list\n    head3 = None\n    print(\"\\nOriginal List:\", end=\" \")\n    print_list(head3)\n    reversed_head3 = reverseList(head3)\n    print(\"Reversed List:\", end=\" \")\n    print_list(reversed_head3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "207": "```\ndef canFinish(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    visited = [0] * numCourses\n    for x, y in prerequisites:\n        graph[y].append(x)\n        \n    def dfs(i):\n        if visited[i] == -1: \n            return False\n        if visited[i] == 1: \n            return True\n        visited[i] = -1\n        for j in graph[i]:\n            if not dfs(j): \n                return False\n        visited[i] = 1\n        return True\n    \n    for i in range(numCourses):\n        if not dfs(i):\n            return False\n    return True\n\ndef main():\n    test_case_1 = [[2,0],[1,1],[0,3]]\n    print(canFinish(4, test_case_1))  # Expected: true\n\n    test_case_2 = [[1,0],[2,0],[3,1],[3,2]]\n    print(canFinish(4, test_case_2))  # Expected: false\n\n    test_case_3 = []\n    print(canFinish(0, test_case_3))  # Expected: true\n\nif __name__ == \"__main__\":\n    main()\n```",
  "209": "```\ndef minSubArrayLen(target, nums):\n    if not nums:\n        return 0\n    left = 0\n    curr_sum = 0\n    res = float('inf')\n    \n    for right in range(len(nums)):\n        curr_sum += nums[right]\n        \n        while curr_sum >= target:\n            res = min(res, right - left + 1)\n            curr_sum -= nums[left]\n            left += 1\n            \n    return res if res != float('inf') else 0\n\n\ndef main():\n    print(minSubArrayLen(7, [2,3,4,5])) # Test case 1\n    print(minSubArrayLen(4, [1,4,4])) # Test case 2\n    print(minSubArrayLen(11, [1,1,1,1,1,1,1,1,1,1,1])) # Test case 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "208": "```\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def starts_with(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\n\ndef main():\n    trie = Trie()\n\n    # Test case 1\n    trie.insert(\"apple\")\n    print(trie.search(\"apple\"))  # Output: True\n    print(trie.search(\"app\"))     # Output: False\n\n    # Test case 2\n    trie.insert(\"banana\")\n    trie.insert(\"orange\")\n    print(trie.search(\"bananas\"))  # Output: False\n    print(trie.starts_with(\"ban\"))   # Output: True\n\n    # Test case 3\n    trie.insert(\"hello\")\n    trie.insert(\"hellol\")\n    print(trie.search(\"hello\"))     # Output: True\n    print(trie.search(\"hellol\"))    # Output: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "210": "```\ndef findOrder(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    visited = [0] * numCourses\n    order = []\n\n    for i, j in prerequisites:\n        graph[j].append(i)\n\n    def dfs(i):\n        if visited[i] == -1:\n            return False\n        if visited[i] == 1:\n            return True\n        visited[i] = -1\n        for neighbor in graph[i]:\n            if not dfs(neighbor):\n                return False\n        visited[i] = 1\n        order.append(i)\n        return True\n\n    for i in range(numCourses):\n        if not dfs(i):\n            return []\n    return order[::-1]\n\ndef main():\n    print(findOrder(4, [[1,0],[2,0]])) \n    print(findOrder(3, [[1,0],[1,2],[2,0]]))\n    print(findOrder(5, [[0,2],[2,4],[4,3],[2,3]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "211": "```\nclass WordDictionary:\n    def __init__(self):\n        self.trie = {}\n\n    def addWord(self, word: str) -> None:\n        node = self.trie\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = True\n\n    def searchWord(self, word: str) -> bool:\n        node = self.trie\n        for i, char in enumerate(word):\n            if char != '.':\n                if char not in node:\n                    return False\n                node = node[char]\n            else:\n                if 'children' not in node:\n                    return False\n                for next_node in node['children'].values():\n                    if self.searchWord(word[i+1:]):\n                        return True\n        return '$' in node\n\ndef main():\n    obj = WordDictionary()\n    print(obj.addWord(\"bad\") == None)\n    print(obj.addWord(\"dad\") == None)\n    print(obj.searchWord(\"ba..\") == True)\n\nif __name__ == \"__main__\":\n    main()",
  "212": "```\ndef findWords(board, words):\n    if not board or not board[0]:\n        return []\n    \n    m, n = len(board), len(board[0])\n    root = {}\n    for word in words:\n        node = root\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['$'] = word\n    \n    res = []\n    for i in range(m):\n        for j in range(n):\n            dfs(board, i, j, root, '', res)\n    \n    return res\n\ndef dfs(board, i, j, node, word, res):\n    if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] not in node:\n        return\n    temp = board[i][j]\n    board[i][j] = '#'\n    \n    w = node[temp]\n    if '$' in w:\n        res.append(w['$'])\n    for char, child_node in w.items():\n        if char != '$':\n            dfs(board, i-1, j, child_node, word + char, res)\n            dfs(board, i+1, j, child_node, word + char, res)\n            dfs(board, i, j-1, child_node, word + char, res)\n            dfs(board, i, j+1, child_node, word + char, res)\n    \n    board[i][j] = temp\n\ndef main():\n    words = [\"oath\",\"pea\",\"eat\",\"rain\"]\n    board = [\n        ['o','a','t','r','e'],\n        ['p','e','','h'],\n        ['e','', '', 'a'],\n        ['n','', '', '']\n    ]\n    print(findWords(board, words))\n\n    words = [\"at\", \"and\", \"art\", \"able\"]\n    board = [\n        ['a','c','a',],\n        ['b','z','a',\".\"],\n        ['.','.','.'],\n        ['p','.','.']\n    ]\n    print(findWords(board, words))\n\n    words = []\n    board = [[\"e\", \"a\", \"r\", \"t\", \"s\"]]\n    print(findWords(board, words))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "213": "```\ndef rob(houses):\n    if not houses:\n        return 0\n    \n    n = len(houses)\n    dp = [0] * (n + 1)\n    \n    dp[1] = houses[0]\n    \n    for i in range(2, n+1):\n        dp[i] = max(dp[i-1], dp[i-2] + houses[i-1])\n    \n    return dp[n]\n\ndef main():\n    test_cases = [\n        ([2, 7, 9, 3, 1], 12),  # expected output: 12\n        ([1, 5, 4, 6, 8], 10),  # expected output: 10\n        ([5, 10, 15, 30, 25], 45)  # expected output: 45\n    ]\n    \n    for test_case in test_cases:\n        houses, expected_output = test_case\n        output = rob(houses)\n        if output == expected_output:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed. Expected: {expected_output}, Got: {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "214": "```\ndef shortest_palindrome(s):\n    n = len(s)\n    res = '1' * (n + 1)\n    for i in range(n//2):\n        res = res[:i+1] + s[i] + res[n-i-1:]\n    return res\n\ndef main():\n    print(shortest_palindrome(\"a\")) # \"aba\"\n    print(shortest_palindrome(\"abacaba\")) # \"abacabaa\"\n    print(shortest_palindrome(\"abcd\")) # \"dbacd\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "215": "```\nimport heapq\n\ndef findKthLargest(nums, k):\n    return heapq.nlargest(k, nums)[-1]\n\ndef main():\n    print(findKthLargest([3,2,1,4], 1) == 4)\n    print(findKthLargest([3,2,3,1,2,4,5,5,6], 4) == 4)\n    print(findKthLargest([9,3,8,7,2,3,5,1,4], 5) == 5)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "216": "```\ndef combinationSum3(k, n):\n    res = []\n    def backtrack(start, path, remain):\n        if len(path) == k:\n            if sum(path) == n:\n                res.append(path)\n            return\n        for i in range(start, 10):\n            if i > remain: break\n            if i + sum(path) > n: break\n            backtrack(i+1, path+[i], remain-i)\n    backtrack(1,[],n)\n    return res\n\ndef main():\n    test_cases = [(3, 7), (3, 9), (4, 10)]\n    for k, n in test_cases:\n        print(f\"Combination Sum III of {k} and {n}:\")\n        print(combinationSum3(k, n))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "217": "```\ndef containsDuplicate(nums):\n    return len(set(nums)) != len(nums)\n\ndef main():\n    print(containsDuplicate([1, 2, 3, 4])) # Test case 1: No duplicate\n    print(containsDuplicate([1, 2, 3, 3])) # Test case 2: Duplicate\n    print(containsDuplicate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])) # Test case 3: No duplicate\n\nif __name__ == \"__main__\":\n    main()\n```",
  "218": "```\ndef getSkyline(buildings):\n    points = []\n    for i in range(len(buildings)):\n        points.append((buildings[i][0], 0))\n        points.append((buildings[i][1], buildings[i][2]))\n\n    points.sort()\n    max_height = [0, float('inf')]\n    result = []\n\n    for point in points:\n        if point[1] > max_height[1]:\n            result.append([point[0], point[1]])\n            max_height[0] = point[0]\n            max_height[1] = point[1]\n        elif point[1] < max_height[1]:\n            max_height[1] = point[1]\n\n    return result\n\n\ndef main():\n    print(getSkyline([[2, 9, 10], [3, 7, 15], [5, 12, 100]]))\n    print(getSkyline([[0, 2, 14], [2, 6, 6], [3, 4, 20]]))\n    print(getSkyline([]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "219": "```\ndef containsNearbyDuplicate(nums, k):\n    seen = set()\n    for i, x in enumerate(nums):\n        if x in seen:\n            return True\n        seen.add(x)\n        if i >= k:\n            seen.remove(nums[i-k])\n    return False\n\n\ndef main():\n    print(containsNearbyDuplicate([1, 2, 3, 1], 3) == True)\n    print(containsNearbyDuplicate([1, 2, 3, 4], 2) == False)\n    print(containsNearbyDuplicate([1, 2, 3, 1, 2, 3], 4) == True)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "220": "```\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    seen = {}\n    for i, x in enumerate(nums):\n        if t + 1 >= x:  # Ensure we don't go out of bounds\n            for y in list(seen.keys()):\n                if abs(y - x) <= t:\n                    return True\n            del seen\n            seen = {x}\n        else:\n            left = max(0, i - t - 1)\n            right = min(i + k + 1, len(nums))\n            seen = {}\n            for y in nums[left:right]:\n                if abs(y - x) <= t:\n                    return True\n                seen[y] = 1\n    return False\n\n\ndef main():\n    print(containsNearbyAlmostDuplicate([1, 3, 4, 7], 2, 1)) # Test case 1: Expected output is True\n    print(containsNearbyAlmostDuplicate([1, 5, 9, 10, 15, 20], 3, 0) )# Test case 2: Expected output is False\n    print(containsNearbyAlmostDuplicate([10, 14, 16, 17, 18, 19, 21, 23, 24, 25], 1, 4)) # Test case 3: Expected output is True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "221": "```\ndef maximal_square(grid):\n    if not grid:\n        return 0\n\n    m = len(grid)\n    n = len(grid[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    max_size = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if grid[i - 1][j - 1] == '1':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_size = max(max_size, dp[i][j])\n\n    return max_size * max_size\n\ndef main():\n    test_case_1 = [\n        ['1','0','1','0','0'],\n        ['7','7','5','1','0'],\n        ['2','4','0','0','8'],\n        ['9','8','6','6','9'],\n        ['5','3','3','2','1']\n    ]\n    print(maximal_square(test_case_1))\n\n    test_case_2 = [\n        ['0','1']\n    ]\n    print(maximal_square(test_case_2))\n\n    test_case_3 = [\n        ['1','1']\n    ]\n    print(maximal_square(test_case_3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "222": "```\ndef countCompleteTreeNodes(root):\n    if not root:\n        return 0\n\n    l = r = 1\n    curr = root\n    while True:\n        l *= 2\n        if curr.left:\n            curr = curr.left\n        else:\n            break\n    curr = root\n    while True:\n        r *= 2\n        if curr.right:\n            curr = curr.right\n        else:\n            break\n\n    return l + r - 1\n\n\ndef main():\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    # Test case 1\n    node5 = TreeNode(5)\n    node3 = TreeNode(3)\n    node2 = TreeNode(2)\n    node4 = TreeNode(4)\n    node1 = TreeNode(1)\n    node5.left = node3\n    node5.right = node4\n    node3.left = node2\n    node3.right = node1\n\n    print(countCompleteTreeNodes(node5))  # Expected output: 6\n\n    # Test case 2\n    node7 = TreeNode(7)\n    node4 = TreeNode(4)\n    node2 = TreeNode(2)\n    node1 = TreeNode(1)\n\n    node7.left = node4\n    node4.left = node2\n    node4.right = node1\n\n    print(countCompleteTreeNodes(node7))  # Expected output: 3\n\n    # Test case 3\n    node10 = TreeNode(10)\n\n    print(countCompleteTreeNodes(node10))  # Expected output: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "223": "```\ndef area(A):\n    return A[0] * A[1]\n\ndef computeArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    common_x1 = max(0, min(ax2, bx2) - max(ax1, bx1))\n    common_y1 = max(0, min(ay2, by2) - max(ay1, by1))\n    \n    intersection_area = common_x1 * common_y1\n    \n    area_A = (ax2 - ax1) * (ay2 - ay1)\n    area_B = (bx2 - bx1) * (by2 - by1)\n    combined_area = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - intersection_area\n    \n    return max(0, combined_area)\n\ndef main():\n    print(computeArea(0, 0, 2, 2, 1, 1, 3, 3)) # Test case 1\n    print(computeArea(-3, 0, 3, 4, 0, -1, 9, 5)) # Test case 2\n    print(computeArea(0, 0, 10, 10, 5, 5, 15, 15)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "224": "```\ndef calculate(s):\n    stack = []\n    curr_num = 0\n    sign = '+'\n    \n    for i in range(len(s)):\n        if s[i].isdigit():\n            curr_num = curr_num * 10 + int(s[i])\n        elif s[i] in ['+', '-']:\n            if sign == '+':\n                stack.append(curr_num)\n            elif sign == '-':\n                stack.append(-curr_num)\n            sign = s[i]\n            curr_num = 0\n        elif s[i] == '(':\n            stack.append('(')\n            curr_num = 0\n            sign = '+'\n        elif s[i] == ')':\n            while stack[-1] != '(':\n                if s[stack.pop()] in ['+', '-']:\n                    break\n            stack.pop()\n    \n    while len(stack) > 1:\n        temp = stack.pop() + stack.pop()\n        stack.append(temp)\n    \n    return sum(stack)\n\ndef main():\n    print(calculate(\"14-3/2\")) # Expected output: 13.0\n    print(calculate(\"3+5*2\")) # Expected output: 9\n    print(calculate(\"(1+(4+5+2)-3)+(10)\")) # Expected output: 25\n\nif __name__ == \"__main__\":\n    main()\n```",
  "225": "```\nfrom collections import deque\n\nclass MyStack:\n\n    def __init__(self):\n        self.q1 = deque()\n        self.q2 = deque()\n\n    def push(self, x: int) -> None:\n        self.q1.append(x)\n        while len(self.q1) > 1:\n            self.q2.appendleft(self.q1.popleft())\n\n    def pop(self) -> int:\n        if not self.q2:\n            return None\n        result = self.q2.popleft()\n        while len(self.q2):\n            self.q1.append(self.q2.pop())\n        return result\n\ndef main():\n    stack = MyStack()\n\n    # Test Case 1: Push and pop a single element\n    stack.push(1)\n    print(stack.pop())  # Expected output: 1\n\n    # Test Case 2: Push multiple elements, then pop all of them\n    for i in range(5):\n        stack.push(i + 1)\n    while len(stack.q1) or len(stack.q2):\n        print(stack.pop())  # Expected output: 5, 4, 3, 2, 1\n\n    # Test Case 3: Push and pop multiple elements\n    for i in range(3):\n        stack.push(i + 1)\n    while len(stack.q1) or len(stack.q2):\n        print(stack.pop())  # Expected output: 3, 2, 1",
  "226": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def invertTree(self, root):\n        if not root:\n            return\n        root.left, root.right = root.right, root.left\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n\ndef main():\n    s = Solution()\n    \n    # Test case 1: Simple tree\n    t1 = TreeNode(4)\n    t1.left = TreeNode(2)\n    t1.right = TreeNode(7)\n    t1.left.left = TreeNode(1)\n    t1.left.right = TreeNode(3)\n    print(\"Test case 1:\")\n    s.invertTree(t1)\n    print()\n\n    # Test case 2: Tree with only one node\n    t2 = TreeNode(5)\n    print(\"Test case 2:\")\n    s.invertTree(t2)\n    print()\n\n    # Test case 3: Tree with multiple levels\n    t3 = TreeNode(10)\n    t3.left = TreeNode(6)\n    t3.right = TreeNode(14)\n    t3.left.left = TreeNode(4)\n    t3.left.right = TreeNode(8)\n    t3.right.left = TreeNode(12)\n    t3.right.right = TreeNode(16)\n    print(\"Test case 3:\")\n    s.invertTree(t3)\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "227": "```\ndef calculate(s):\n    stack = []\n    num = 0\n    sign = 1\n    result = 0\n    i = 0\n    \n    while i < len(s):\n        if s[i].isdigit():\n            num = num * 10 + int(s[i])\n        elif s[i] in ['+', '-']:\n            result += sign * num\n            num = 0\n            sign = 1 if s[i] == '+' else -1\n        elif s[i] == '(':\n            stack.append(result)\n            stack.append(sign)\n            result = 0\n            sign = 1\n        elif s[i] == ')':\n            result += sign * num\n            num = 0\n            result *= stack.pop()\n        i += 1\n    \n    return result + sign * num\n\n\ndef main():\n    print(calculate(\"10*2+3-4\")) # 14\n    print(calculate(\"(1 + 1) * 2\")) # 4\n    print(calculate(\"1-2*(3-4)+5\")) # -5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "229": "```\ndef majorityElement(nums):\n    result = []\n    counts = {}\n    for num in nums:\n        if num not in counts:\n            counts[num] = 0\n        counts[num] += 1\n    for key, value in counts.items():\n        if value > len(nums) // 3:\n            result.append(key)\n    return result\n\ndef main():\n    print(majorityElement([1,2,2,4,5])) # [2]\n    print(majorityElement([3,2,3])) # [3]\n    print(majorityElement([1,2,3,4])) # []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "228": "```\ndef summaryRanges(nums):\n    if not nums:\n        return []\n\n    result = []\n    start = nums[0]\n    end = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] == end + 1:\n            end = nums[i]\n        else:\n            if start == end:\n                result.append(str(start))\n            else:\n                result.append(f\"{start}->{end}\")\n            start = nums[i]\n            end = nums[i]\n\n    if start == end:\n        result.append(str(start))\n    else:\n        result.append(f\"{start}->{end}\")\n\n    return result\n\ndef main():\n    print(summaryRanges([0, 1, 2, 4, 5, 7])) # Should return [\"0->2\", \"4->5\", \"7\"]\n    print(summaryRanges([0, 1, 2, 3, 4, 6, 8, 9, 10, 11, 12]) # Should return [\"0->2\", \"3->4\", \"6->12\"]\n    print(summaryRanges([-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]) # Should return [\"-5->-1\", \"0->5\"]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "230": "```\nclass Solution:\n    def kthSmallest(self, root, k):\n        stack = []\n        while True:\n            while root:\n                stack.append(root)\n                root = root.left\n            if not stack:\n                break\n            node = stack.pop()\n            k -= 1\n            if k == 0:\n                return node.val\n            root = node.right\n\ndef main():\n    s = Solution()\n    \n    # Test case 1\n    root = [3,1,4,null,null,2]\n    expected_output = 2\n    output = s.kthSmallest(root, 2)\n    assert output == expected_output\n    \n    # Test case 2\n    root = [5,3,6,2,4,null,null,1]\n    expected_output = 3\n    output = s.kthSmallest(root, 3)\n    assert output == expected_output\n    \n    # Test case 3\n    root = [2,null,1]\n    expected_output = 1\n    output = s.kthSmallest(root, 1)\n    assert output == expected_output\n\nif __name__ == \"__main__\":\n    main()\n```",
  "231": "```\ndef isPowerOfTwo(n):\n    if n <= 0:\n        return False\n    return (n & (n - 1)) == 0\n\ndef main():\n    print(isPowerOfTwo(16), \"Expected: True\")\n    print(isPowerOfTwo(5), \"Expected: False\")\n    print(isPowerOfTwo(1024), \"Expected: True\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "233": "```\ndef findDigits(n):\n    count = 0\n    while n:\n        digit = n % 10\n        if digit == 1:\n            count += 1\n        n //= 10\n    return count\n\n\ndef main():\n    print(\"Test case 1:\")\n    print(findDigits(13), \"should be 2, got\", findDigits(13))\n    \n    print(\"\\nTest case 2:\")\n    print(findDigits(250), \"should be 3, got\", findDigits(250))\n    \n    print(\"\\nTest case 3:\")\n    print(findDigits(12131), \"should be 4, got\", findDigits(12131))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "232": "```\ndef MyQueue():\n    stack1 = []\n    stack2 = []\n\n    class Node:\n        def __init__(self, x):\n            self.val = x\n            self.next = None\n\n    class MyStack:\n        def __init__(self):\n            self.stack = []\n\n        def push(self, val):\n            self.stack.append(val)\n\n        def pop(self):\n            if not self.is_empty():\n                return self.stack.pop()\n            else:\n                return None\n\n        def is_empty(self):\n            return len(self.stack) == 0\n\n    class MyQueue:\n\n        def __init__(self):\n            self.stack = []\n\n        def enqueue(self, val):\n            stack = self.stack\n            while stack and stack[-1].val != val:\n                stack.append(Node(val))\n            if not stack:\n                stack.append(Node(val))\n\n        def dequeue(self):\n            stack = self.stack\n            if not stack:\n                return None\n            value = stack[0].val\n            for i in range(len(stack) - 1):\n                stack.pop()\n            top = stack.pop()\n            while top.next:\n                stack.append(top)\n                top = top.next\n            return value\n\n    def main():\n        queue = MyQueue()\n\n        # Test case 1: Enqueue 3, dequeue 2 times (should return 3 and then 1)\n        queue.enqueue(1)\n        queue.enqueue(2)\n        print(queue.dequeue())  # Output: 1\n        print(queue.dequeue())   # Output: 2\n\n        # Test case 2: Enqueue 5, dequeue 4 times (should return 5 and then 3, then 2, then 1)\n        queue.enqueue(3)\n        queue.enqueue(1)\n        queue.enqueue(2)\n        print(queue.dequeue())    # Output: 3\n        print(queue.dequeue())     # Output: 1\n        print(queue.dequeue())     # Output: 2\n\n        # Test case 3: Enqueue 4, dequeue 5 times (should return 4 and then 3, then 2, then 1)\n        queue.enqueue(4)\n        for _ in range(3):\n            queue.enqueue(i+1)\n            i += 1\n        while not queue.is_empty():\n            print(queue.dequeue())   # Output: 4, 3, 2, 1\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "235": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    \n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    \n    if left and right:\n        return root\n    elif left:\n        return left\n    else:\n        return right\n\ndef main():\n    # Test case 1\n    root = TreeNode(6)\n    root.left = TreeNode(2)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(0)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(7)\n    root.right.right = TreeNode(9)\n    p = TreeNode(2)\n    q = TreeNode(4)\n    print(lowestCommonAncestor(root, p, q).val)\n\n    # Test case 2\n    root = TreeNode(3)\n    root.left = TreeNode(1)\n    root.right = TreeNode(4)\n    p = TreeNode(1)\n    q = TreeNode(6)\n    print(lowestCommonAncestor(root, p, q).val)\n\n    # Test case 3\n    root = TreeNode(5)\n    p = TreeNode(1)\n    q = TreeNode(4)\n    print(lowestCommonAncestor(root, p, q))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "234": "```\ndef isPalindrome(head):\n    if head is None:\n        return True\n    \n    slow = head\n    fast = head\n    \n    while fast.next and fast.next.next:\n        slow = slow.next\n        fast = fast.next.next\n    \n    # reverse the second half of the linked list\n    prev, curr = None, slow.next\n    slow.next = None\n    while curr:\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n    \n    p1 = head\n    p2 = prev\n    while p2:\n        if p1.val != p2.val:\n            return False\n        p1 = p1.next\n        p2 = p2.next\n    \n    return True\n\ndef main():\n    class ListNode:\n        def __init__(self, x):\n            self.val = x\n            self.next = None\n\n    # Test case 1: A normal palindrome linked list.\n    head1 = ListNode(1)\n    head1.next = ListNode(2)\n    head1.next.next = ListNode(3)\n    head1.next.next.next = ListNode(3)\n    head1.next.next.next.next = ListNode(2)\n    head1.next.next.next.next.next = ListNode(1)\n\n    print(isPalindrome(head1))\n\n    # Test case 2: A normal non-palindrome linked list.\n    head2 = ListNode(1)\n    head2.next = ListNode(2)\n    head2.next.next = ListNode(3)\n\n    print(isPalindrome(head2))\n\n    # Test case 3: A single node palindrome linked list.\n    head3 = ListNode(1)\n\n    print(isPalindrome(head3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "236": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    if left and right:\n        return root\n    return left if left else right\n\ndef main():\n    # Test case 1\n    root = TreeNode(3)\n    root.left = TreeNode(5)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(6)\n    root.left.right = TreeNode(2)\n    root.right.left = TreeNode(0)\n    root.right.right = TreeNode(8)\n    p = root.left\n    q = root.left.right\n    print(lowestCommonAncestor(root, p, q).val)  # Output: 5\n\n    # Test case 2\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    p = root\n    q = root.left\n    print(lowestCommonAncestor(root, p, q).val)  # Output: 1\n\n    # Test case 3\n    root = TreeNode(4)\n    root.left = TreeNode(2)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(3)\n    p = root.left.left\n    q = root.left.right\n    print(lowestCommonAncestor(root, p, q).val)  # Output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "237": "```\ndef deleteNode(head, val):\n    if not head:\n        return None\n    \n    current = head\n    prev = None\n    \n    while current:\n        if current.val == val:\n            if prev is None:\n                head = current.next\n            else:\n                prev.next = current.next\n            return head\n        prev = current\n        current = current.next\n    return head\n\ndef printList(head):\n    current = head\n    while current:\n        print(current.val, end=' ')\n        current = current.next\n    print()\n\ndef main():\n    # Test Case 1: Delete node with value 4 from the list [2, 7, 9, 10, 5]\n    head = Node(2)\n    head.next = Node(7)\n    head.next.next = Node(9)\n    head.next.next.next = Node(10)\n    head.next.next.next.next = Node(5)\n    new_head = deleteNode(head, 4)\n    print(\"Test Case 1:\")\n    printList(new_head)\n\n    # Test Case 2: Delete node with value 7 from the list [3, 1, 2]\n    head = Node(3)\n    head.next = Node(1)\n    head.next.next = Node(2)\n    new_head = deleteNode(head, 7)\n    print(\"Test Case 2:\")\n    printList(new_head)\n\n    # Test Case 3: Delete node with value 5 from the list [5]\n    head = Node(5)\n    new_head = deleteNode(head, 5)\n    print(\"Test Case 3:\")\n    printList(new_head)\n\nclass Node:\n    def __init__(self, val=0):\n        self.val = val\n        self.next = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "238": "```\ndef productExceptSelf(nums):\n    length = len(nums)\n    output = [1]*length\n    left_product = 1\n    for i in range(length):\n        output[i] *= left_product\n        left_product *= nums[i]\n    right_product = 1\n    for i in range(length-1, -1, -1):\n        output[i] *= right_product\n        right_product *= nums[i]\n    return output\n\ndef main():\n    print(productExceptSelf([1,2,3,4]))  # [24,12,8,6]\n    print(productExceptSelf([-1,0,-1]))   # [2,0,2]\n    print(productExceptSelf([10]) )        # [10]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "239": "```\nfrom collections import deque\n\ndef maxSlidingWindow(nums, k):\n    if not nums or k <= 0:\n        return []\n\n    n = len(nums)\n    res = []\n    q = deque()\n\n    for i in range(n):\n        while q and q[0] < i - k + 1:\n            q.popleft()\n        \n        while q and nums[q[-1]] < nums[i]:\n            q.pop()\n        \n        q.append(i)\n\n        if i >= k - 1:\n            res.append(nums[q[0]])\n\n    return res\n\ndef main():\n    print(maxSlidingWindow([9,10,8,7,6,5,4,3,2,1], 3))  # [10,9,8]\n    print(maxSlidingWindow([1,-1], 1) )  # [1]\n    print(maxSlidingWindow([1,3,-1,2,0,-3,3,-2,-1], 3) )  # [3,3,3]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "240": "```\ndef searchMatrix(matrix, target):\n    if not matrix or not matrix[0]:\n        return False\n    \n    rows, cols = len(matrix), len(matrix[0])\n    low, high = 0, rows * cols - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        num = matrix[mid // cols][mid % cols]\n        \n        if num == target:\n            return True\n        \n        elif num < target:\n            low = mid + 1\n        \n        else:\n            high = mid - 1\n    \n    return False\n\ndef main():\n    test_cases = [\n        {\"matrix\": [[1,3,5,7],[10,11,16,20],[23,30,34,50]], \"target\": 3, \"expected\": True},\n        {\"matrix\": [[1,3,5,7],[10,11,16,20],[23,30,34,50]], \"target\": 4, \"expected\": False},\n        {\"matrix\": [[1,2,3,4],[5,6,7,8],[9,10,11,12]], \"target\": 0, \"expected\": False}\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Target: {test_case['target']}, Expected: {test_case['expected']}, Result: {searchMatrix(test_case['matrix'], test_case['target'])}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "241": "```\ndef diffWaysToCompute(input):\n    if input.isdigit():\n        return [int(input)]\n\n    result = []\n    for i in range(len(input)):\n        if input[i] == '+':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i+1:])\n            for l in left:\n                for r in right:\n                    result.append(l + r)\n        elif input[i] == '-':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i+1:])\n            for l in left:\n                for r in right:\n                    result.append(l - r)\n        elif input[i] == '*':\n            left = diffWaysToCompute(input[:i])\n            right = diffWaysToCompute(input[i+1:])\n            for l in left:\n                for r in right:\n                    result.append(l * r)\n\n    return result\n\ndef main():\n    inputs = [\"2*3-4*5\", \"8-2*3\", \"0*a\")\n    for input in inputs:\n        print(\"Input: \", input)\n        print(\"Output:\", diffWaysToCompute(input))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "242": "```\ndef isAnagram(s1, s2):\n    return sorted(s1) == sorted(s2)\n\ndef main():\n    print(isAnagram(\"anagram\", \"nagaram\") == True)\n    print(isAnagram(\"rat\", \"car\") == False)\n    print(isAnagram(\"listen\", \"silent\") == True)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "243": "```\ndef shortestWordDistance(words, word1, word2):\n    if not words or word1 not in words or word2 not in words:\n        return 0\n    i = j = -float('inf')\n    for k in range(len(words)):\n        if words[k] == word1:\n            i = k\n        elif words[k] == word2:\n            j = k\n        if i != -float('inf') and j != -float('inf'):\n            return min(i, j) + abs(i-j)\n    return 0\n\ndef main():\n    print(shortestWordDistance([\"apple\", \"banana\", \"orange\"], \"apple\", \"banana\"))\n    print(shortestWordDistance([\"x\", \"y\", \"x\"], \"x\", \"y\"))\n    print(shortestWordDistance([\"a\", \"b\", \"c\"], \"a\", \"c\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "244": "```\ndef shortestWordDistance(words, queryWords):\n    word_map = {}\n    for i in range(len(words)):\n        if words[i] in queryWords:\n            word_map[words[i]] = i\n    result = []\n    for query_word in queryWords:\n        min_dist = float('inf')\n        prev_idx = -1\n        for idx, word in enumerate(words):\n            if word == query_word or (word_map.get(word) and idx < word_map[word]):\n                if prev_idx != -1:\n                    dist = idx - prev_idx\n                    min_dist = min(min_dist, dist)\n                prev_idx = idx\n        result.append(min_dist)\n    return result\n\n\ndef main():\n    words = [\"practice\", \"makes\", \"perfect\", \"practice\", \"make\"]\n    query_words = [\"practice\", \"makes\", \"make\"]\n    print(shortestWordDistance(words, query_words))\n    \n    words = [\"hello\", \"world\", \"hello\", \"hello\", \"goodbye\"]\n    query_words = [\"hello\", \"goodbye\"]\n    print(shortestWordDistance(words, query_words))\n\n    words = [\"apple\", \"banana\", \"orange\"]\n    query_words = [\"apple\", \"banana\"]\n    print(shortestWordDistance(words, query_words))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "245": "```\ndef shortWordDistance(words):\n    n = len(words)\n    res = float('inf')\n    for i in range(n - 1):\n        start, end = i, i + 1\n        while start > 0 and words[start - 1] == words[start]:\n            start -= 1\n        while end < n - 1 and words[end] == words[end - 1]:\n            end += 1\n        res = min(res, end - start)\n    return res\n\ndef main():\n    test_cases = [\n        {\"words\": [\"a\", \"b\"], \"expected\": 1},\n        {\"words\": [\"x\", \"y\", \"z\"], \"expected\": 2},\n        {\"words\": [\"x\", \"x\", \"y\", \"x\"], \"expected\": 1}\n    ]\n\n    for test_case in test_cases:\n        print(\"Test case: \", test_case[\"words\"])\n        result = shortWordDistance(test_case[\"words\"])\n        assert result == test_case[\"expected\"], f\"Test failed. Expected {test_case['expected']} but got {result}\"\n        print(f\"Passed! Expected {test_case['expected']}. Got {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "246": "```\ndef isStrobogrammatic(s):\n    mapping = {\"0\": \"0\", \"1\": \"1\", \"8\": \"8\", \"6\": \"9\", \"9\": \"6\"}\n    new_s = \"\"\n    for i, c in enumerate(reversed(s)):\n        if c not in mapping:\n            return False\n        new_s += mapping[c]\n    return s == new_s\n\ndef main():\n    print(isStrobogrammatic(\"6898\"))  # Test case 1: True\n    print(isStrobogrammatic(\"1169\"))  # Test case 2: False\n    print(isStrobogrammatic(\"90876\"))  # Test case 3: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "247": "```\ndef isStrobogrammatic(n):\n    phone = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    if len(str(n)) == 1:\n        return str(n) in phone\n    return str(n)[0] in phone and str(n)[len(str(n))-1] in phone and isStrobogrammatic(int(str(n)[1:-1]))\n\ndef main():\n    print(isStrobogrammatic(122881) ) # False\n    print(isStrobogrammatic(6969))  # True\n    print(isStrobogrammatic(118881)) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "248": "```\ndef isStrobogrammatic(num):\n    mapping = {\"0\": \"0\", \"1\": \"1\", \"6\": \"9\", \"8\": \"8\", \"9\": \"6\"}\n    while num > 10:\n        str_num = str(num)\n        new_str = \"\"\n        for digit in str_num:\n            if digit not in mapping:\n                return False\n            new_str += mapping[digit]\n        num = int(new_str)\n    return True\n\n\ndef main():\n    print(isStrobogrammatic(917) and \"Test 1: Passed\")\n    print(not isStrobogrammatic(1189) and \"Test 2: Failed\")\n    print(isStrobogrammatic(1698) and \"Test 3: Passed\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "249": "```\ndef groupStrings(strings):\n    groups = {}\n    for s in strings:\n        shifted = ''.join((chr(((ord(c) - ord('a')) % 26 + i) % 26 + ord('a')) for c, i in zip(s, itertools.cycle(range(26)))))\n        groups.setdefault(shifted, []).append(s)\n    return list(groups.values())\n\nimport unittest\nfrom itertools import cycle\n\nclass TestGroupStrings(unittest.TestCase):\n\n    def test_group_strings(self):\n        strings = [\"abc\", \"bcd\", \"xyz\"]\n        expected = [[\"abc\"], [\"bcd\"], [\"xyz\"]]\n        self.assertEqual(groupStrings(strings), expected)\n\n    def test_group_strings2(self):\n        strings = [\"a1b2\", \"3z4a5b6\", \"7q8\"]\n        expected = [[\"a1b2\", \"3z4a5b6\"], [\"7q8\"]]\n        self.assertEqual(groupStrings(strings), expected)\n\n    def test_group_strings3(self):\n        strings = [\"abc\", \"axyz\", \"xyz\"]\n        expected = [[\"abc\"], [\"axyz\"], [\"xyz\"]]\n        self.assertEqual(groupStrings(strings), expected)\n\nif __name__ == '__main__':\n    unittest.main()\n```",
  "250": "```\ndef countUnivalSubtrees(root):\n    def dfs(node):\n        if node is None:\n            return [0], False\n        left_uni, left_is_uni = dfs(node.left)\n        right_uni, right_is_uni = dfs(node.right)\n        uni_count = 1 if node.val == left_val == right_val else 0\n        return [uni_count + sum(left_uni) + sum(right_uni)], uni_count > 0\n\n    if root is None:\n        return 0\n    left_val = root.left.val if root.left else None\n    result, _ = dfs(root)\n    return sum(result)\n\ndef main():\n    root1 = TreeNode(1)\n    root1.left = TreeNode(1)\n    print(countUnivalSubtrees(root1))  # Output: 2\n\n    root2 = TreeNode(5)\n    root2.left = TreeNode(5)\n    root2.right = TreeNode(5)\n    print(countUnivalSubtrees(root2))  # Output: 4\n\n    root3 = TreeNode(0)\n    root3.left = TreeNode(1)\n    print(countUnivalSubtrees(root3))  # Output: 1\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "251": "```\ndef vecHist(vec):\n    result = []\n    while True:\n        if len(vec) == 1 or not vec[0]:\n            vec.pop(0)\n        else:\n            break\n    for row in vec:\n        while row and row[0] == 0:\n            row.pop(0)\n        if not row:\n            continue\n        result.append(row)\n    return result\n\ndef flatten(vec):\n    flat = []\n    stack = [vec]\n    while stack:\n        v = stack.pop()\n        if isinstance(v, list):\n            stack.extend(reversed(v))\n        else:\n            flat.append(v)\n    return flat\n\ndef Vector2D(vector):\n    vec = [[int(num) for num in row.split()] for row in vector.split('\\n')]\n    if not vec or not vec[0]:\n        return []\n    while True:\n        if len(vec) == 1 or not vec[0]:\n            vec.pop(0)\n        else:\n            break\n    return flatten(vec)\n\ndef main():\n    print(Vector2D(\"3\\n123\\n1\")) # Expected output: [1, 2, 3]\n    print(Vector2D(\"1\\n10\\20\")) # Expected output: [1, 10, 20]\n    print(Vector2D(\"\")) # Expected output: []\n\nmain()\n```",
  "252": "```\ndef canAttendMeetings(intervals):\n    if not intervals:\n        return True\n\n    intervals.sort(key=lambda x: x[0])\n    for i in range(1, len(intervals)):\n        if intervals[i][0] < intervals[i-1][1]:\n            return False\n    return True\n\n\ndef main():\n    print(canAttendMeetings([[0, 30],[5,10],[15,20]])) # Expected: False\n    print(canAttendMeetings([[7,10],[2,4]])) # Expected: True\n    print(canAttendMeetings([])) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "253": "```\ndef minMeetingRooms(intervals):\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: x[0])\n    rooms = []\n    for i in range(len(intervals)):\n        if not rooms or rooms[-1][1] <= intervals[i][0]:\n            rooms.append([intervals[i], 1])\n        else:\n            rooms[-1][1] += 1\n\n    return len(rooms)\n\ndef main():\n    print(minMeetingRooms([[0,30],[5,10],[15,20]]) == 2)\n    print(minMeetingRooms([[7,10],[2,4]])) == 1)\n    print(minMeetingRooms([[0,30],[5,10],[15,20],[25,35]]) == 3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "254": "```\ndef getFactors(n):\n    factors = []\n    for i in range(2, n + 1):\n        if n % i == 0:\n            left, right = divmod(n, i)\n            if left == right:\n                factors.append((i,))\n            else:\n                factors.append((i,) + getFactors(right))\n            break\n    return factors\n\ndef main():\n    print(getFactors(37)) # [[1], [37]]\n    print(getFactors(32)) # [[2, 16], [4, 8]]\n    print(getFactors(12)) # [[1, 12], [2, 6], [3, 4]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "255": "```\ndef isValidPreorder(pre):\n    def dfs(start, end):\n        if start >= end:\n            return True\n        \n        root = pre[start]\n        index = start + 1\n        while index < end and pre[index] < root:\n            index += 1\n        \n        for i in range(index, end):\n            if pre[i] < root:\n                return False\n        \n        left = dfs(start + 1, index)\n        right = dfs(index, end)\n        \n        return left and right\n\ndef main():\n    test_cases = [\n        {\"pre\": [5,2,6,1,3],\"expected\": True},\n        {\"pre\": [1,6,2,5],\"expected\": False},\n        {\"pre\": [4,2,1,1,6,0,3,5],\"expected\": True}\n    ]\n    \n    for test_case in test_cases:\n        if isValidPreorder(test_case[\"pre\"]) == test_case[\"expected\"]:\n            print(\"Test case passed: \", test_case)\n        else:\n            print(\"Test case failed: \", test_case)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "256": "```\ndef minCostClimbingStairs(cost):\n    n = len(cost)\n    dp = [0] * (n + 1)\n    dp[0] = cost[0]\n    dp[1] = cost[1]\n    for i in range(2, n):\n        dp[i] = min(dp[i-1], dp[i-2]) + cost[i]\n    return min(dp[-1], dp[-2])\n\ndef main():\n    print(minCostClimbingStairs([0, 1, 2, 3])) # Test case 1\n    print(minCostClimbingStairs([1, 100, 1])) # Test case 2\n    print(minCostClimbingStairs([2, 1, 4, 5])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "258": "```\ndef add_digits(n):\n    while n > 9:\n        n = sum(int(digit) for digit in str(n))\n    return n\n\n\ndef main():\n    print(\"Test Case 1: \")\n    print(add_digits(38))  # Expected output: 2\n    print(\"\\n\")\n\n    print(\"Test Case 2: \")\n    print(add_digits(492946))  # Expected output: 6\n    print(\"\\n\")\n\n    print(\"Test Case 3: \")\n    print(add_digits(16))  # Expected output: 7\n    print(\"\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "257": "```\nclass Solution:\n    def binaryTreePaths(self, root):\n        if not root:\n            return []\n        \n        result = []\n        self.travel(root, str(root.val), result)\n        return ['->'.join(path) for path in result]\n\n    def travel(self, node, path, result):\n        if not node.left and not node.right:\n            result.append(path)\n        else:\n            if node.left:\n                self.travel(node.left, path + '->' + str(node.left.val), result)\n            if node.right:\n                self.travel(node.right, path + '->' + str(node.right.val), result)\n\ndef main():\n    s = Solution()\n    \n    # Test case 1\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    print(s.binaryTreePaths(root))  # Expected output: [\"1->2\",\"1->3\"]\n    \n    # Test case 2\n    root = TreeNode(1)\n    root.left = TreeNode(4)\n    root.right = TreeNode(5)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(6)\n    print(s.binaryTreePaths(root))  # Expected output: [\"1->4->2\",\"1->4->6\",\"1->5\"]\n    \n    # Test case 3\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.right = TreeNode(4)\n    print(s.binaryTreePaths(root))  # Expected output: [\"1->2\",\"1->3->4\"]\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "259": "```\ndef threeSumSmaller(nums, target):\n    nums.sort()\n    count = 0\n    for i in range(len(nums) - 2):\n        left, right = i + 1, len(nums) - 1\n        while left < right:\n            total = nums[i] + nums[left] + nums[right]\n            if total < target:\n                count += right - left\n                left += 1\n                right -= 1\n            else:\n                break\n    return count\n\ndef main():\n    print(threeSumSmaller([-2,0,1,3], 3)) # Test case 1\n    print(threeSumSmaller([0,0,0,0], 10)) # Test case 2\n    print(threeSumSmaller([-2,-1,0,3], 1)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "260": "```\ndef singleNumberIII(nums):\n    res = [0, 0]\n    for num in nums:\n        bit1 = (num >> 31) & 1\n        bit2 = (num >> 30) & 1\n        if bit1 and not bit2:\n            res[0] ^= num\n        elif not bit1 and bit2:\n            res[1] ^= num\n    return res\n\n\ndef main():\n    test_cases = [\n        [[2,4,3], [6]],\n        [[5,2,-1], [-1, 5]],\n        [[1, 2, 3, 4, 5], [10]]\n    ]\n    \n    for test_case in test_cases:\n        input_nums, expected_result = test_case\n        actual_result = singleNumberIII(input_nums)\n        if actual_result == expected_result:\n            print(\"Test case passed.\")\n        else:\n            print(f\"Test case failed. Expected {expected_result}, got {actual_result}.\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "261": "```\nclass Solution:\n    def validTree(self, N: int, edges: List[List[int]]) -> bool:\n        if N == 0:\n            return True\n        \n        parent = list(range(N))\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            rootX, rootY = find(x), find(y)\n            if rootX != rootY:\n                parent[rootX] = rootY\n        \n        for edge in edges:\n            union(*edge)\n        \n        return len(set(find(i) for i in range(N))) == 1\n\ndef main():\n    solution = Solution()\n    \n    print(solution.validTree(4, [[0,1],[1,2],[2,3]])) # True\n    print(solution.validTree(5, [[0,1],[1,2],[2,3],[3,4]])) # False\n    print(solution.validTree(6, [[0,1],[1,2],[2,3],[3,4],[4,5]])) # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "262": "```\ndef numMatches(trips, users):\n    return sum(1 for t in trips if len(t) >= users)\n\ndef main():\n    print(numMatches([[2,1,1],[2,0], [0]], 3)) # Expected output: 1\n    print(numMatches([[2,1,1],[2,0], [1,1,5]], 3)) # Expected output: 2\n    print(numMatches([[2,1,1],[2,0], [0,2,5]], 8)) # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "263": "```\ndef isUgly(n):\n    if n <= 0:\n        return False\n    for p in 2, 3, 5:\n        while n % p == 0:\n            n /= p\n    return n == 1\n\ndef main():\n    test_cases = [(1, True), (2, False), (6, True)]\n    for input_value, expected_output in test_cases:\n        output = isUgly(input_value)\n        if output != expected_output:\n            print(f\"Test case failed: input {input_value}, expected {expected_output} but got {output}\")\n        else:\n            print(f\"Test case passed: input {input_value}, expected {expected_output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "264": "```\ndef nthUglyNumber(n):\n    dp = [1]\n    i = 1\n    while len(dp) < n:\n        i += 1\n        if all(i % x > 0 for x in (2, 3, 5)):\n            dp.append(i)\n    return dp[-1]\n\ndef main():\n    print(nthUglyNumber(10))  # Should be 12\n    print(nthUglyNumber(11))  # Should be 15\n    print(nthUglyNumber(12))  # Should be 20\n\nif __name__ == \"__main__\":\n    main()\n```",
  "265": "```\ndef minCostII(costs):\n    n = len(costs)\n    if n == 0:\n        return []\n    dp = [[cost] for cost in costs[0]]\n    \n    for i in range(1, n):\n        prev_dp = dp[-1].copy()\n        new_dp = [float('inf')]*len(dp[0])\n        for j in range(len(costs[i])):\n            if i == 1:\n                new_dp[j] = min(new_dp[j], costs[i][j]+prev_dp[j])\n            else:\n                new_dp[j] = min(min(prev_dp)+costs[i][j], prev_dp[(j+1)%len(prev_dp)] + costs[i][j])\n        dp = [new_dp]\n    return min(dp[0])\n\ndef main():\n    print(minCostII([[30,20,70],[55,35,52,75],[25,38,40,60]])) \n    print(minCostII([[250,15,200,210,45]]) )    \n    print(minCostII([[]])) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "266": "```\ndef canPermutePalindrome(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    odd_count = 0\n    for count in char_count.values():\n        if count % 2 != 0:\n            odd_count += 1\n        if odd_count > 1:\n            return False\n    return True\n\ndef main():\n    print(canPermutePalindrome(\"aab\")) # Expected: True\n    print(canPermutePalindrome(\"carp\")) # Expected: True\n    print(canPermutePalindrome(\"abccba\")) # Expected: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "268": "```\ndef missingNumber(nums):\n    n = len(nums)\n    total_sum = (n * (n + 1)) // 2\n    return total_sum - sum(nums)\n\ndef main():\n    print(missingNumber([0,1,2,4])) # Expected output: 3\n    print(missingNumber([0,1,3,4])) # Expected output: 2\n    print(missingNumber([0,1,2])) # Expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "267": "```\ndef generatePalindromes(s):\n    char_count = {}\n    for c in s:\n        if c not in char_count:\n            char_count[c] = 0\n        char_count[c] += 1\n\n    odd_count = 0\n    mid_char = ''\n    for k, v in char_count.items():\n        if v % 2 != 0:\n            odd_count += 1\n            mid_char = k\n\n    def backtrack(s, used):\n        if len(s) == 0:\n            result.append(''.join(s))\n        else:\n            for i in range(len(used)):\n                if not used[i]:\n                    used[i] = True\n                    backtrack(s + [mid_char], used)\n                    used[i] = False\n\n    result = []\n    backtrack([], [True] * (len(s) // 2) + [(odd_count > 0)])\n    return [''.join(x) for x in result]\n\ndef main():\n    print(generatePalindromes(\"aab\")))\n    print(generatePalindromes(\"able was able\"))))\n    print(generatePalindromes(\"a\")))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "269": "```\ndef alienOrder(words):\n    if not words:\n        return \"\"\n\n    graph = {}\n    in_degree = {char: 0 for word in words for char in word}\n\n    for i in range(len(words) - 1):\n        for c1, c2 in zip(words[i], words[i + 1]):\n            if c1 != c2:\n                if c2 not in graph:\n                    graph[c2] = []\n                graph[c1].append(c2)\n                in_degree[c2] += 1\n\n    queue = [char for char in in_degree if in_degree[char] == 0]\n    result = []\n\n    while queue:\n        char = queue.pop(0)\n        result.append(char)\n\n        for neighbor in graph.get(char, []):\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result) != len(words):\n        return \"\"\n\n    return \"\".join(result)\n\n\ndef main():\n    print(alienOrder([\"wrt\", \"wrf\", \"er\", \"ett\", \"rft\", \"rt\", \"t\", \"wf\", \"sqof\"]))  # expected: \"wertf\"\n    print(alienOrder([]))  # expected: \"\"\n    print(alienOrder([\"z\", \"h\", \"k\"]))  # expected: \"zhk\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "270": "```\ndef closestValue(root, target):\n    closest = root.val\n    delta = abs(target - closest)\n\n    def dfs(node):\n        nonlocal closest, delta\n        if not node:\n            return\n        d = abs(target - node.val)\n        if d < delta:\n            delta = d\n            closest = node.val\n        dfs(node.left)\n        dfs(node.right)\n\n    dfs(root)\n    return closest\n\ndef main():\n    # Test Case 1\n    root1 = TreeNode(4)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(5)\n    print(closestValue(root1, 3.714286))  # Output: 4\n\n    # Test Case 2\n    root2 = TreeNode(2)\n    root2.left = TreeNode(1)\n    root2.right = TreeNode(3)\n    print(closestValue(root2, 2.5))  # Output: 2\n\n    # Test Case 3\n    root3 = TreeNode(1)\n    print(closestValue(root3, 0))  # Output: 1\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "271": "```\ndef encode_string(s):\n    result = []\n    i = 0\n    while i < len(s):\n        count = 1\n        while i + 1 < len(s) and s[i] == s[i+1]:\n            i += 1\n            count += 1\n        result.append(str(count) + s[i])\n        i += 1\n    return ''.join(result)\n\ndef decode_string(s):\n    result = []\n    i = 0\n    while i < len(s):\n        count = ''\n        while i < len(s) and s[i].isdigit():\n            count += s[i]\n            i += 1\n        result.append(int(count) * s[i])\n        i += 1\n    return ''.join(result)\n\ndef main():\n    print(\"Test Case 1:\")\n    s = \"aaa\"\n    encoded = encode_string(s)\n    decoded = decode_string(encoded)\n    if s == decoded:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n    print(\"\\nTest Case 2:\")\n    s = \"aabbbccc\"\n    encoded = encode_string(s)\n    decoded = decode_string(encoded)\n    if s == decoded:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n    print(\"\\nTest Case 3:\")\n    s = \"abcdefg\"\n    encoded = encode_string(s)\n    decoded = decode_string(encoded)\n    if s == decoded:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "272": "```\ndef closestValues(root, target):\n    left = float('inf')\n    right = -float('inf')\n\n    def dfs(node, t):\n        nonlocal left, right\n        if not node:\n            return\n\n        if abs(t - node.val) < abs(target - node.val):\n            left = node.val\n            right = node.val\n        elif node.val > target:\n            right = min(right, node.val)\n        else:\n            left = max(left, node.val)\n\n        dfs(node.left, t)\n        dfs(node.right, t)\n\n    dfs(root, target)\n    return [left, right]\n\ndef main():\n    root1 = TreeNode(4)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(5)\n    root1.left.left = TreeNode(3)\n    root1.left.right = TreeNode(1)\n\n    print(closestValues(root1, 2.109)) # Expected output: [2, 3]\n\n    root2 = TreeNode(6)\n    root2.left = TreeNode(3)\n    root2.right = TreeNode(8)\n    root2.left.left = TreeNode(1)\n    root2.left.right = TreeNode(2)\n\n    print(closestValues(root2, 7.725)) # Expected output: [4, 5]\n\n    root3 = TreeNode(5)\n    root3.left = TreeNode(3)\n    root3.right = TreeNode(6)\n    root3.left.left = TreeNode(1)\n    root3.left.right = TreeNode(2)\n\n    print(closestValues(root3, 8.125)) # Expected output: [4, 5]\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "273": "```\ndef numberToWords(num):\n    if not num:\n        return \"Zero\"\n\n    ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n    twenties = [\"\", \"Twenty\", \"Thirty\", \"Forty\", \" Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n\n    def helper(num):\n        if num < 10:\n            return ones[num]\n        elif num < 20:\n            return teens[num - 10]\n        else:\n            return twenties[num // 10] + (\" \" + ones[num % 10] if num % 10 != 0 else \"\")\n\n    result = \"\"\n    if num >= 1000000:\n        result += numberToWords(num // 1000000) + \" Million\"\n        num %= 1000000\n    if num >= 1000:\n        result += helper(num // 1000) + \" Thousand\"\n        num %= 1000\n    if num >= 20:\n        result += helper(num)\n    elif num > 0:\n        result = helper(num)\n\n    return result.strip()\n\ndef main():\n    print(numberToWords(123456789)) # Test case 1: 123,456,789\n    print(numberToWords(1000000))   # Test case 2: 1,000,000\n    print(numberToWords(12345))     # Test case 3: 12,345\n\nif __name__ == \"__main__\":\n    main()\n```",
  "274": "```\ndef hIndex(citations):\n    citations.sort(reverse=True)\n    for i in range(len(citations)):\n        if citations[i] < i + 1:\n            return i\n    return len(citations)\n\ndef main():\n    print(hIndex([3,0,6,1,5])) # expected output: 3\n    print(hIndex([1,2,3,1])) # expected output: 3\n    print(hIndex([40,11,33]) ) # expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "275": "```\ndef hIndex(citations):\n    n = len(citations)\n    left, right = 0, n - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if citations[mid] == mid:\n            return mid\n        elif citations[mid] < mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return min((right, n - 1), key=lambda x: citations[x])\n\ndef main():\n    print(hIndex([0])) # Test case 1: Output: 0\n    print(hIndex([1,3,12]) # Test case 2: Output: 3\n    print(hIndex([5,1,6]) # Test case 3: Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "276": "```\ndef numWays(n, k):\n    if n == 1:\n        return k\n    if n == 2:\n        return k * k\n\n    dp = [0] * (n + 1)\n    dp[1] = k\n    dp[2] = k * k\n\n    for i in range(3, n + 1):\n        dp[i] = (dp[i - 1] + k * dp[i - 2]) % (10 ** 9 + 7)\n\n    return dp[n]\n\ndef main():\n    print(numWays(3, 3))  # Output: 6\n    print(numWays(4, 2))   # Output: 8\n    print(numWays(1, 5))   # Output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "277": "```\ndef findCelebrity(n):\n    celebrity = 0\n    \n    for i in range(1, n):\n        if knows(celebrity, i) or not knows(i, celebrity):\n            celebrity = i\n    for i in range(n):\n        if i != celebrity and (knows(celebrity, i) or not knows(i, celebrity)):\n            return -1\n    \n    return celebrity\n\ndef knows(a, b):\n    # This function will check if a knows b. You can modify this as per your requirement.\n    # For simplicity, let's assume it returns True for all cases\n    return True\n\ndef main():\n    print(\"Test Case 1: n = 3\")\n    print(findCelebrity(3))\n    \n    print(\"\\nTest Case 2: n = 4\")\n    print(findCelebrity(4))\n    \n    print(\"\\nTest Case 3: n = 5\")\n    print(findCelebrity(5))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "278": "```\ndef firstBadVersion(n):\n    left, right = 1, n\n    while left <= right:\n        mid = (left + right) // 2\n        if isBadVersion(mid):\n            right = mid - 1\n        else:\n            left = mid + 1\n    return left\n\ndef isBadVersion(version):\n    # This function should implement a check to determine whether the `version` is bad or not.\n    # You need to write your own code here to solve this problem.\n    return version >= 4\n\ndef main():\n    n = 10\n    print(\"First Bad Version:\", firstBadVersion(n))\n\n    n = 5\n    print(\"First Bad Version:\", firstBadVersion(n))\n\n    n = 2\n    print(\"First Bad Version:\", firstBadVersion(n))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "280": "```\ndef wiggleSort(nums):\n    if len(nums) <= 1:\n        return nums\n    w = []\n    for i in range(len(nums)):\n        if i % 2 == 0:\n            w.append(-nums[i])\n        else:\n            w.append(nums[i])\n    w.sort()\n    res = []\n    for i in range(len(w)):\n        if i % 2 == 0:\n            res.append(-w[i])\n        else:\n            res.append(w[i])\n    return res\n\ndef main():\n    print(\"Test case 1: \", wiggleSort([3, 5, 2, 1, 4]))\n    print(\"Test case 2: \", wiggleSort([1, 4, 2, 3, 5]))\n    print(\"Test case 3: \", wiggleSort([6, 5, 4, 3, 2, 1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "279": "```\nfrom collections import deque\n\ndef numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n    return dp[n]\n\ndef main():\n    test_cases = [\n        {\"n\": 12, \"expected_result\": 3},\n        {\"n\": 13, \"expected_result\": 2},\n        {\"n\": 14, \"expected_result\": 2},\n    ]\n\n    for test_case in test_cases:\n        result = numSquares(test_case[\"n\"])\n        if result == test_case[\"expected_result\"]:\n            print(f\"Test case {test_case['n']} passed\")\n        else:\n            print(f\"Test case {test_case['n']} failed, expected {test_case['expected_result']}, but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "282": "```\ndef addOperators(num: str) -> List[str]:\n    pass\n\ndef main():\n    print(addOperators(\"123\")) \n    print(addOperators(\"45+2*3\")) \n    print(addOperators(\"0002+25*5-40\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "281": "```\ndef zigzagIterator(words, rows):\n    if not words:\n        return []\n    \n    res = [[None for _ in range(min(len(word) for word in words)) ]for _ in range(rows)]\n    index = [(0, 1) for _ in range(rows)]\n    \n    while True:\n        for i in range(rows):\n            if index[i][1] < len(words[index[i][0]]):\n                res[i][index[i][0]%len(res[i])] = words[index[i][0]][index[i][1]]\n                index[i] = (index[i][0], index[i][1]+1)\n            else:\n                index[i] = (i, 0) if i == rows - 1 else (i+1, 0)\n        for i in range(rows):\n            if all(j is None for j in res[i]):\n                return [' '.join(word for word in words if not any(j==word for j in res[i]))] + [str(i)]\n\ndef main():\n    test_cases = [\n        {\"words\": [\"abc\", \"bcd\", \"xyz\"], \"rows\": 2, \"expected_output\": [\"abe\",\"lrfec\"]},\n        {\"words\": [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"], \"rows\": 3, \"expected_output\": [\"aea\", \"bef\", \"cgc\"]}\n        # Add more test cases as needed\n    ]\n    \n    for case in test_cases:\n        words = case[\"words\"]\n        rows = case[\"rows\"]\n        expected_output = case[\"expected_output\"]\n        \n        actual_output = zigzagIterator(words, rows)\n        if actual_output != expected_output:\n            print(f\"Test case failed: Expected {expected_output}, but got {actual_output}\")\n        else:\n            print(\"Test case passed\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "283": "```\ndef moveZeroes(nums):\n    zero_index = 0\n    for i in range(len(nums)):\n        if nums[i] != 0:\n            nums[zero_index], nums[i] = nums[i], nums[zero_index]\n            zero_index += 1\n    return nums\n\ndef main():\n    print(moveZeroes([0,1,0,3,12])) # Expected output: [1,3,12,0,0]\n    print(moveZeroes([0,0,1])) # Expected output: [1,0,0]\n    print(moveZeroes([0,0,0,0,1])) # Expected output: [1,0,0,0,0]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "284": "```\nclass PeekingIterator:\n    def __init__(self, iterator):\n        self.iterator = iterator\n        self.nextVal = None\n\n    def peek(self):\n        if not self.hasNext():\n            return None\n        self.nextVal = next(self.iterator)\n        return self.nextVal\n\n    def next(self):\n        if not self.hasNext():\n            raise ValueError(\"No more elements!\")\n        result = self.nextVal\n        self.nextVal = None\n        return result\n\n    def hasNext(self):\n        try:\n            next(self.iterator)\n            return True\n        except StopIteration:\n            return False\n\n\ndef main():\n    iterator = iter([1, 2, 3])\n    peekingIterator = PeekingIterator(iterator)\n\n    print(\"Test case 1:\")\n    for _ in range(5):\n        if peekingIterator.hasNext():\n            print(f\"Peek: {peekingIterator.peek()}\")\n            print(f\"Next: {peekingIterator.next()}\")\n        else:\n            print(\"No more elements!\")\n\n    print(\"\\nTest case 2:\")\n    iterator = iter([1, 2, 3])\n    peekingIterator = PeekingIterator(iterator)\n    for _ in range(3):\n        if peekingIterator.hasNext():\n            print(f\"Peek: {peekingIterator.peek()}\")\n            print(f\"Next: {peekingIterator.next()}\")\n        else:\n            print(\"No more elements!\")\n\n    print(\"\\nTest case 3:\")\n    iterator = iter([1, 2])\n    peekingIterator = PeekingIterator(iterator)\n    for _ in range(5):\n        if peekingIterator.hasNext():\n            print(f\"Peek: {peekingIterator.peek()}\")\n            print(f\"Next: {peekingIterator.next()}\")\n        else:\n            print(\"No more elements!\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "285": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef inorder_successor(root, p):\n    if not root or not p:\n        return None\n    \n    res = None\n    while root:\n        if p.val < root.val:\n            res = root\n            root = root.left\n        else:\n            root = root.right\n    return res\n\ndef main():\n    # Test case 1\n    node5 = TreeNode(5)\n    node3 = TreeNode(3)\n    node2 = TreeNode(2)\n    node4 = TreeNode(4)\n    node6 = TreeNode(6)\n    node7 = TreeNode(7)\n    \n    node5.left = node3\n    node3.right = node2\n    node2.right = node4\n    node5.right = node6\n    node6.left = node7\n    \n    p = node3\n    print(inorder_successor(node5, p).val)  # Output: 4\n\n    # Test case 2\n    node1 = TreeNode(1)\n    node2_ = TreeNode(2)\n    node3_ = TreeNode(3)\n    \n    node1.right = node2_\n    node2_.right = node3_\n    \n    p = node2_\n    print(inorder_successor(node1, p).val)  # Output: 3\n\n    # Test case 3\n    root = None\n    p = None\n    print(inorder_successor(root, p))  # Output: None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "286": "```\nfrom collections import deque\n\ndef wallAndGate(grid):\n    if not grid:\n        return \n\n    rows, cols = len(grid), len(grid[0])\n    queue = deque()\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 0: \n                queue.append((r,c))\n                \n    while queue:\n        r, c = queue.popleft()\n        for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1:\n                queue.append((nr,nc))\n                grid[nr][nc] = 0\n                \n    return grid\n\ndef main():\n    print(wallAndGate([[0,0,1],[0,0,1],[1,1,1]])) \n    print(wallAndGate([[0,1],[0,0]])) \n    print(wallAndGate([[0,0,0],[1,1,1]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "287": "```\ndef findDuplicate(nums):\n    tortoise = nums[0]\n    hare = nums[0]\n\n    while True:\n        tortoise = nums[tortoise]\n        hare = nums[nums[hare]]\n\n        if tortoise == hare:\n            break\n\n    ptr1 = nums[0]\n    ptr2 = tortoise\n\n    while ptr1 != ptr2:\n        ptr1 = nums[ptr1]\n        ptr2 = nums[ptr2]\n\n    return ptr1\n\n\ndef main():\n    print(\"Test case 1:\")\n    nums = [1, 3, 4, 2, 7, 8, 3, 12, 10]\n    expected_output = 3\n    actual_output = findDuplicate(nums)\n    if actual_output == expected_output:\n        print(\"Pass\")\n    else:\n        print(f\"Fail. Expected {expected_output} but got {actual_output}\")\n\n    print(\"\\nTest case 2:\")\n    nums = [1, 2]\n    expected_output = 2\n    actual_output = findDuplicate(nums)\n    if actual_output == expected_output:\n        print(\"Pass\")\n    else:\n        print(f\"Fail. Expected {expected_output} but got {actual_output}\")\n\n    print(\"\\nTest case 3:\")\n    nums = [1, 2, 3, 4, 5]\n    expected_output = None\n    actual_output = findDuplicate(nums)\n    if actual_output == expected_output:\n        print(\"Pass\")\n    else:\n        print(f\"Fail. Expected {expected_output} but got {actual_output}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "288": "```\ndef wordAbbreviation(words):\n    abbreviation = {}\n    for word in words:\n        n = len(word)\n        abbrev = \"\"\n        for i in range(n-1):\n            abbrev += word[i]\n        abbreviation[word] = abbrev\n    return abbreviation\n\ndef main():\n    print(\"Test case 1: \")\n    words = [\"like\", \"god\"]\n    result = wordAbbreviation(words)\n    for word, abbrev in result.items():\n        print(f\"{word}: {abbrev}\")\n\n    print(\"\\nTest case 2: \")\n    words = [\"dog\", \"water\", \"apple\", \"pen\"]\n    result = wordAbbreviation(words)\n    for word, abbrev in result.items():\n        print(f\"{word}: {abbrev}\")\n\n    print(\"\\nTest case 3: \")\n    words = [\"a\", \"ap\", \"apple\", \"app\", \"appl\"]\n    result = wordAbbreviation(words)\n    for word, abbrev in result.items():\n        print(f\"{word}: {abbrev}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "289": "```\nclass Solution:\n    def gameOfLife(self, board):\n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        for i in range(m):\n            for j in range(n):\n                live_neighbors = self.countLiveNeighbors(board, i, j)\n                if board[i][j] == 1 and (live_neighbors < 2 or live_neighbors > 3):\n                    board[i][j] = 0\n                elif board[i][j] == 0 and live_neighbors == 3:\n                    board[i][j] = 1\n        \n        return board\n\n    def countLiveNeighbors(self, board, i, j):\n        m, n = len(board), len(board[0])\n        count = 0\n        \n        for x in range(max(0, i-1), min(m, i+2)):\n            for y in range(max(0, j-1), min(n, j+2)):\n                if (x != i or y != j) and board[x][y] == 1:\n                    count += 1\n        \n        return count\n\ndef main():\n    s = Solution()\n    \n    # Test case 1\n    board1 = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\n    result1 = s.gameOfLife(board1)\n    print(result1)\n\n    # Test case 2\n    board2 = [[1,1,1],[1,1,1],[1,1,1],[1,1,1]]\n    result2 = s.gameOfLife(board2)\n    print(result2)\n\n    # Test case 3\n    board3 = [[0,0,0],[0,0,0],[0,1,1]]\n    result3 = s.gameOfLife(board3)\n    print(result3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "290": "```\ndef wordPattern(words, patterns):\n    if len(words) != len(patterns):\n        return False\n    \n    mapping = {}\n    \n    for w, p in zip(words, patterns):\n        if p not in mapping:\n            if p in mapping.values():\n                return False\n            mapping[p] = w\n        elif mapping[p] != w:\n            return False\n    \n    return True\n\n\ndef main():\n    print(wordPattern([\"abc\", \"bcd\", \"cef\"], [\"a#b#c\", \"b#f#g\", \"c#k#g\"])) # Expected: True\n    print(wordPattern([\"dog\", \"cat\", \"mouse\"], [\"dog#1\", \"cat#2\", \"mouse#3\"])) # Expected: True\n    print(wordPattern([\"boy\", \"girl\", \"boy\"], [\"g#n#a#c\", \"p#o#y#\", \"b#y#l\"])) # Expected: False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "292": "```\ndef canWinNim(n):\n    return n % 4 != 0\n\n\ndef main():\n    print(canWinNim(1))       # Test case 1: Expected output - True\n    print(canWinNim(2))       # Test case 2: Expected output - True\n    print(canWinNim(3))       # Test case 3: Expected output - True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "291": "```\ndef findAndReplacePattern(words, pattern):\n    def match(word, p):\n        m = {}\n        for w, x in zip(word, p):\n            if x in m:\n                if m[x] != w:\n                    return False\n            else:\n                m[x] = w\n        return True\n\n    res = []\n    for word in words:\n        if match(word, pattern):\n            res.append(word)\n    return res\n\n\ndef main():\n    print(findAndReplacePattern([\"abc\", \"bcd\", \"xyz\"], \"a#z\"))  # Output: [\"xyz\"]\n    print(findAndReplacePattern([\"dog\",\"cat\",\"apple\"], \"hello\"))  # Output: []\n    print(findAndReplacePattern([\"foo\",\"bar\"], \"aaa\"))  # Output: [\"foo\"]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "293": "```\ndef flipGame(words):\n    result = []\n    for word in words:\n        rev_word = word[::-1]\n        if word != rev_word and rev_word in words:\n            result.append(rev_word)\n    return result\n\ndef main():\n    print(flipGame([\"hello\",\"world\"]))  # Output: ['olleh', 'dlrow']\n    print(flipGame([\"abc\",\"cba\",\"abcd\",\"dcba\"]))  # Output: ['cba', 'dcba']\n    print(flipGame([\"bat\",\"tab\",\"leetcode\"]))  # Output: ['tab']\n\nif __name__ == \"__main__\":\n    main()\n```",
  "294": "```\ndef AtMostNGivesChange(c):\n    coins = [25,10,5]\n    dp = [0]+[float('inf')] * c\n    for coin in coins:\n        for i in range(coin, c+1):\n            dp[i] = min(dp[i],dp[i-coin]+1)\n    return dp[c]\n\ndef main():\n    print(AtMostNGivesChange(5)) \n    print(AtMostNGivesChange(3))\n    print(AtMostNGivesChange(11))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "295": "```\nclass MedianFinder:\n    def __init__(self):\n        self.left_heap = []\n        self.right_heap = []\n\n    def addNum(self, num: int) -> float:\n        if not self.left_heap or num < -self.left_heap[0]:\n            self.left_heap.append(-num)\n            heapq.heapify(self.left_heap)\n        else:\n            self.right_heap.append(num)\n            heapq.heapify(self.right_heap)\n\n        if len(self.left_heap) > len(self.right_heap) + 1:\n            self.right_heap.append(-heapq.heappop(self.left_heap))\n        elif len(self.right_heap) > len(self.left_heap):\n            self.left_heap.append(-heapq.heappop(self.right_heap))\n\n    def findMedian(self) -> float:\n        if len(self.left_heap) == len(self.right_heap):\n            return (-self.left_heap[0] + self.right_heap[0]) / 2\n        else:\n            return -self.left_heap[0]\n\n\ndef main():\n    finder = MedianFinder()\n    print(finder.findMedian())  # expected output: None\n\n    finder.addNum(1)\n    print(finder.findMedian())  # expected output: 1.0\n\n    for _ in range(10):\n        finder.addNum(i)\n    print(finder.findMedian())  # expected output: 5.0\n\n    for i in range(10, -1, -1):\n        finder.addNum(i)\n    print(finder.findMedian())  # expected output: 5.0",
  "296": "```\ndef minTimeToMeetFriends(friends):\n    friends.sort()\n    start, end = friends[0], friends[-1]\n    min_time = (end - start) // 2 + start\n    for i in range(len(friends)):\n        if abs(min_time - friends[i]) < abs(end - start) // 2:\n            min_time = friends[i]\n    return min_time\n\ndef main():\n    print(\"Test case 1:\")\n    print(minTimeToMeetFriends([1,4,6])) # expected output: 3\n    \n    print(\"\\nTest case 2:\")\n    print(minTimeToMeetFriends([2,10,18]) ) # expected output: 5\n    \n    print(\"\\nTest case 3:\")\n    print(minTimeToMeetFriends([0,4,16]) ) # expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "297": "```\ndef serialize(root):\n    if not root:\n        return \"None\"\n    serialized = \"\"\n    stack = [root]\n    while stack:\n        node = stack.pop()\n        if node:\n            serialized += str(node.val) + \",\"\n            stack.append(node.right)\n            stack.append(node.left)\n        else:\n            serialized += \"None,\"\n    return serialized[:-1]\n\ndef deserialize(data):\n    nodes = data.split(\",\")\n    root = None\n    for node in nodes:\n        if node == \"None\":\n            continue\n        val = int(node)\n        if not root:\n            root = TreeNode(val)\n        else:\n            parent = root\n            while True:\n                if val < parent.val:\n                    if not parent.left:\n                        parent.left = TreeNode(val)\n                        break\n                    parent = parent.left\n                else:\n                    if not parent.right:\n                        parent.right = TreeNode(val)\n                        break\n                    parent = parent.right\n    return root\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef main():\n    test_case1()\n    test_case2()\n    test_case3()\n\ndef test_case1():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    serialized = serialize(root)\n    print(f\"Serialized: {serialized}\")\n    deserialized = deserialize(serialized)\n    print(\"Deserialized:\")\n    in_order(deserialized)\n\ndef test_case2():\n    root = None\n    serialized = serialize(root)\n    print(f\"Serialized: {serialized}\")\n    deserialized = deserialize(serialized)\n    print(\"Deserialized:\")\n    in_order(deserialized)\n\ndef test_case3():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(5)\n    serialized = serialize(root)\n    print(f\"Serialized: {serialized}\")\n    deserialized = deserialize(serialized)\n    print(\"Deserialized:\")\n    in_order(deserialized)\n\ndef in_order(node):\n    if node:\n        in_order(node.left)\n        print(node.val, end=\" \")\n        in_order(node.right)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "298": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef longestConsecutive(root):\n    if root is None:\n        return 0\n\n    max_length = 0\n\n    def dfs(node, prev_val, current_length):\n        nonlocal max_length\n        if node is None:\n            return\n        if node.val == prev_val + 1:\n            current_length += 1\n        else:\n            current_length = 1\n        max_length = max(max_length, current_length)\n        dfs(node.left, node.val, current_length)\n        dfs(node.right, node.val, current_length)\n\n    dfs(root, float('-inf'), 0)\n    return max_length\n\ndef main():\n    # Test case 1\n    root1 = TreeNode(1)\n    root1.left = TreeNode(0)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(2)\n    print(longestConsecutive(root1))  # Output: 4\n\n    # Test case 2\n    root2 = TreeNode(2)\n    root2.left = TreeNode(1)\n    root2.right = TreeNode(3)\n    root2.right.left = TreeNode(4)\n    root2.right.right = TreeNode(5)\n    print(longestConsecutive(root2))  # Output: 3\n\n    # Test case 3\n    root3 = TreeNode(8)\n    root3.left = TreeNode(7)\n    root3.right = TreeNode(9)\n    root3.left.left = TreeNode(8)\n    root3.left.right = TreeNode(10)\n    print(longestConsecutive(root3))  # Output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "299": "```\ndef getHint(secret, guess):\n    Bulls = 0\n    Cows = 0\n    secretCount = [0]*10\n    guessCount = [0]*10\n    for i in range(len(secret)):\n        if secret[i] == guess[i]:\n            Bulls += 1\n        else:\n            secretCount[int(secret[i])] += 1\n            guessCount[int(guess[i])] += 1\n\n    for i in range(10):\n        Bulls += min(secretCount[i], guessCount[i])\n\n    Cows = sum(min(a, b) for a, b in zip(secretCount, guessCount)) - Bulls\n\n    return str(Bulls) + \"A\" + str(Cows) + \"B\"\n\ndef main():\n    print(getHint(\"1807\", \"7810\"))  # Output: 1A3B\n    print(getHint(\"1123\", \"0111\"))  # Output: 2A1B\n    print(getHint(\"1111\", \"0131\"))   # Output: 4A0B\n\nif __name__ == \"__main__\":\n    main()\n```",
  "300": "```\ndef lengthOfLIS(nums):\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef main():\n    print(\"Test case 1: \", lengthOfLIS([10,9,2,5,3,7,101,18]))\n    print(\"Test case 2: \", lengthOfLIS([0,1,0,3,4,0,2,1,3]))\n    print(\"Test case 3: \", lengthOfLIS([7,7,7]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "301": "```\ndef removeInvalidParentheses(s):\n    if not s:\n        return []\n\n    queue = [(s, 0, 0)]\n    visited = set()\n    res = None\n    min_len = float('inf')\n\n    while queue:\n        cur_s, left, right = queue.pop(0)\n\n        if cur_s == s and left == right and left == right == len(s) // 2:\n            if len(cur_s) < min_len:\n                min_len = len(cur_s)\n                res = [cur_s]\n            elif len(cur_s) == min_len:\n                res.append(cur_s)\n\n        if cur_s not in visited:\n            for i in range(len(cur_s)):\n                if cur_s[i] != '(' and cur_s[i] != ')':\n                    continue\n\n                new_s1, new_left1, new_right1 = cur_s[:i], left - (1 if cur_s[i] == '(' else 0), right - (1 if cur_s[i] == ')' else 0)\n                new_s2, new_left2, new_right2 = cur_s[:i+1], left + (1 if cur_s[i] == '(' else 0), right + (1 if cur_s[i] == ')' else 0)\n\n                if i > 0 and cur_s[i-1] == '(' and cur_s[i] == ')':\n                    continue\n\n                if new_left1 >= new_right1 or new_left2 >= new_right2:\n                    continue\n\n                queue.append((new_s1 + (cur_s[i] if i > 0 else '') + new_s2, new_left1 + (1 if new_s1 and new_s1[-1] == '(' else 0), new_right1 + (1 if new_s1 and new_s1[-1] == ')' else 0)))\n                visited.add(cur_s)\n\n    return res\n\ndef main():\n    print(removeInvalidParentheses(\"()\")) # Output: [\"()\"]\n    print(removeInvalidParentheses(\"(a)b(c)\") ) # Output: [\"(a)b(c)\"]\n    print(removeInvalidParentheses(\"(a)(b)(c)\") ) # Output: [\"(a)(b)(c)\"]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "302": "```\ndef findBlackPixelRectangle(grid):\n    m = len(grid)\n    n = len(grid[0])\n    res = float('inf'), float('inf'), 0, 0\n    for i in range(m):\n        left = right = 0\n        for j in range(n):\n            if grid[i][j] == 'B':\n                right = j\n            else:\n                if right > left:\n                    res = min(res, (i, left, right, right - left + 1))\n                left = j + 1\n    for j in range(n):\n        top = bottom = 0\n        for i in range(m):\n            if grid[i][j] == 'B':\n                bottom = i\n            else:\n                if bottom > top:\n                    res = min(res, (top, top, bottom, bottom - top + 1))\n                top = i + 1\n    return res\n\n\ndef main():\n    test_cases = [\n        {'grid': [['W', 'B', 'W'], ['B', 'W', 'B'], ['W', 'B', 'W']], 'expected_output': (3, 1, 3, 2)},\n        {'grid': [['B', 'W', 'B', 'W', 'B', 'W'], ['W', 'B', 'W', 'B', 'W', 'B'], ['B', 'W', 'B', 'W', 'B', 'W']], 'expected_output': (4, 2, 5, 3)},\n        {'grid': [['W', 'W', 'W'], ['W', 'B', 'W'], ['W', 'W', 'W']], 'expected_output': (1, 0, 2, 1)}\n    ]\n    \n    for test_case in test_cases:\n        result = findBlackPixelRectangle(test_case['grid'])\n        print(\"Test case: \", test_case)\n        print(\"Expected output: \", test_case['expected_output'])\n        print(\"Actual output: \", result)\n        print()\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "303": "```\nclass NumArray:\n\n    def __init__(self, nums):\n        self.nums = nums\n        self.prefix_sum = [0] * (len(nums) + 1)\n        for i in range(len(nums)):\n            self.prefix_sum[i+1] = self.prefix_sum[i] + nums[i]\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.prefix_sum[right+1] - self.prefix_sum[left]\n\n\ndef main():\n    numArray = NumArray([1, 3, 5])\n    \n    print(numArray.sumRange(0, 1)) # Expected output: 4\n    print(numArray.sumRange(1, 2)) # Expected output: 9\n    print(numArray.sumRange(2, 2)) # Expected output: 5\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "304": "```\ndef sumRegion(grid, row1, col1, row2, col2):\n    result = 0\n    for i in range(row1, row2+1):\n        for j in range(col1, col2+1):\n            result += grid[i][j]\n    return result\n\ndef main():\n    # Test case 1\n    grid = [[1,3,5,9],[8,6,3,4],[5,7,2,10]]\n    print(sumRegion(grid, 1, 1, 2, 2))  # Expected output: 11\n    \n    # Test case 2\n    grid = [[1,1,1],[1,0,1],[1,1,1]]\n    print(sumRegion(grid, 0, 0, 1, 1))  # Expected output: 3\n    \n    # Test case 3\n    grid = [[10,14,4,9,13},{8,7,6,5,2},{12,11,10,10,15},{15,10,15,15,20},{20,18,17,19,2}]\n    print(sumRegion(grid, 0, 0, 3, 2))  # Expected output: 38\n\nif __name__ == \"__main__\":\n    main()\n```",
  "305": "```\ndef numIslands(grid):\n    if not grid:\n        return 0\n\n    count = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                dfs(grid, i, j)\n                count += 1\n    return count\n\ndef dfs(grid, i, j):\n    if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != '1':\n        return \n    grid[i][j] = '#'\n    for x in range(-1, 2):\n        for y in range(-1, 2):\n            if abs(x)+abs(y)>1:\n                continue\n            newi=i+x\n            newj=j+y\n            if 0<=newi<len(grid) and 0<=newj<len(grid[0]) and grid[newi][newj] == '1':\n                dfs(grid, newi, newj)\n\ndef main():\n    test_case1 = [\n        ['1','1','0','0','0'],\n        ['1','1','0','0','0'],\n        ['0','0','1','0','0'],\n        ['0','0','0','1','1']\n    ]\n    print(numIslands(test_case1))  # Output: 3\n\n    test_case2 = [\n        ['1','1','0','1','1'],\n        ['1','1','0','0','0'],\n        ['0','0','1','1','1'],\n        ['0','0','0','0','0']\n    ]\n    print(numIslands(test_case2))  # Output: 1\n\n    test_case3 = [\n        ['0']\n    ]\n    print(numIslands(test_case3))   # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "306": "```\ndef addStrings(num1, num2):\n    carry = 0\n    result = []\n    \n    for i in range(max(len(num1), len(num2))):\n        n1 = int(num1[-(i+1)] or 0)\n        n2 = int(num2[-(i+1)] or 0)\n        \n        total = n1 + n2 + carry\n        result.append(str(total % 10))\n        carry = total // 10\n        \n    if carry > 0:\n        result.append(str(carry))\n    \n    return ''.join(reversed(result))\n\ndef isAdditiveNumber(num):\n    for i in range(1, len(num) - 1):\n        for j in range(i + 1, len(num)):\n            prefix = num[:i]\n            suffix = num[i+j:]\n            if int(prefix) + int(suffix) != num:\n                continue\n            if not (prefix[0] == '0' and len(prefix) > 1) or not (suffix[0] == '0' and len(suffix) > 1):\n                return False\n    return True\n\ndef main():\n    print(isAdditiveNumber(\"123\")) # True\n    print(isAdditiveNumber(\"999\")) # False\n    print(isAdditiveNumber(\"112358\")) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "307": "```\nclass NumArray:\n\n    def __init__(self, nums):\n        self.nums = nums\n        self.tree = [0] * (len(nums) + 1)\n        \n        for i in range(len(nums)):\n            self.update(i, nums[i])\n\n    def update(self, index, val):\n        while index < len(self.tree):\n            self.tree[index] += val\n            index += index & -index\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.query(right) - self.query(left - 1)\n\n    def query(self, index):\n        res = 0\n        while index > 0:\n            res += self.tree[index]\n            index -= index & -index\n        return res\n\n\ndef main():\n    nums = [1, 3, 5]\n    obj = NumArray(nums)\n    \n    print(obj.sumRange(0, 1)) # Expected output: 4\n    \n    print(obj.update(1, 2))\n    print(obj.sumRange(0, 2)) # Expected output: 8\n\n    nums = [1, -3, 5]\n    obj = NumArray(nums)\n    \n    print(obj.sumRange(0, 2)) # Expected output: 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "308": "```\ndef numSum(numMatrix):\n    m = len(numMatrix)\n    n = len(numMatrix[0])\n    total_sum = sum(sum(row) for row in numMatrix)\n\n    prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            prefix_sum[i][j] = numMatrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n    \n    def sumRegion(r1, c1, r2, c2):\n        return total_sum - prefix_sum[r1][c2] - prefix_sum[r2][c1] + prefix_sum[r1][c1] - prefix_sum[r1][c2] - prefix_sum[r2][c1]\n    \n    def update(r, c, val):\n        nonlocal total_sum\n        dR = r\n        dC = c\n        \n        while (r := min(r, m)) and (c := min(c, n)):\n            numMatrix[r][c] += val\n            total_sum += val\n            \n            dr, dc = r & -r, c & -c\n            while dr:\n                numMatrix[r][c] += val\n                total_sum += val\n                r -= dr\n            while dc:\n                numMatrix[r][c] += val\n                total_sum += val\n                c -= dc\n        return (dR, dC)\n\n    def query(r1, c1, r2, c2):\n        return sumRegion(min(r2, m - 1), min(c2, n - 1), max(r1, 0), max(c1, 0))\n    \n    # Test cases\n    numMatrix = [[1, 3, 5], [6, 7, 8]]\n    print(\"Test case 1: \", query(0, 1, 2, 2) == 14)\n    \n    update(0, 1, 4)\n    print(\"Test case 2: \", query(0, 1, 1, 1) == 7)\n    \n    numMatrix = [[1, 3], [5, 8]]\n    update(0, 1, 4)\n    print(\"Test case 3: \", query(0, 0, 1, 2) == 10)\n```",
  "309": "```\ndef maxProfit(prices):\n    if not prices:\n        return 0\n    \n    n = len(prices)\n    buy1 = [0] * (n + 2)\n    sell1 = [0] * (n + 2)\n    buy2 = [0] * (n + 2)\n    \n    for i in range(1, n + 1):\n        if i == 1:\n            buy1[i] = -prices[0]\n        else:\n            buy1[i] = max(buy1[i-1], sell1[i-2] - prices[i-1])\n        \n        sell1[i] = max(sell1[i-1], buy1[i-1] + prices[i-1])\n    \n    for i in range(n, 0, -1):\n        if i == n:\n            buy2[i] = 0\n        else:\n            buy2[i] = max(buy2[i+1], sell1[i+1] - prices[i])\n        \n        sell2 = max(sell1[i], buy2[i+1] + prices[i])\n    \n    return sell2\n\ndef main():\n    test_cases = [\n        ([7,1,5,3,6,4], 7),\n        ([1,2], 0),\n        ([1], 0)\n    ]\n\n    for case in test_cases:\n        result = maxProfit(case[0])\n        print(f\"Input: {case}, Output: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "310": "```\ndef findMinHeightTrees(n, edges):\n    if n == 0:\n        return []\n\n    if n == 1:\n        return [1]\n\n    leaves = []\n    for i in range(1, n+1):\n        if len([edge for edge in edges if i in edge]) == 1:\n            leaves.append(i)\n\n    while n > 2:\n        n -= len(leaves)\n        new_leaves = []\n        for leaf in leaves:\n            for edge in edges:\n                if leaf in edge:\n                    other_leaf = edge[0] if edge[1] == leaf else edge[1]\n                    if [other_leaf]:\n                        new_leaves.append(other_leaf)\n                    break\n        leaves = new_leaves\n\n    return leaves\n\n\ndef main():\n    test_cases = [\n        {\"n\": 4, \"edges\": [[1, 0], [1, 2], [1, 3]], \"expected_output\": [1]},\n        {\"n\": 6, \"edges\": [[0, 5], [0, 2], [1, 4], [1, 2], [2, 5], [4, 5]], \"expected_output\": [3, 4]},\n        {\"n\": 7, \"edges\": [], \"expected_output\": [0]}\n    ]\n\n    for test_case in test_cases:\n        n = test_case[\"n\"]\n        edges = test_case[\"edges\"]\n        expected_output = test_case[\"expected_output\"]\n\n        output = findMinHeightTrees(n, edges)\n        if output == expected_output:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected: {expected_output}, got: {output}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "311": "```\ndef multiply(num1, num2):\n    if not num1 or not num2:\n        return []\n\n    m, k = len(num1), len(num2[0])\n    result = [[0] * m for _ in range(k)]\n\n    for i in range(len(num1)):\n        for j in range(len(num2[0])):\n            for ii in range(len(num1[i])):\n                if num1[i][ii] and num2[ii][j]:\n                    result[i][j] += num1[i][ii] * num2[ii][j]\n\n    return result\n\n\ndef main():\n    test_case1 = [[1, 0, 0], [0, 3, 4], [5, 6, 7]]\n    test_case2 = [[1, 0], [0, 5]]\n    test_case3 = [[2, 0], [0, 3]]\n\n    print(\"Test Case 1:\")\n    for row in multiply(test_case1, [[0, 9], [8, 1]]):\n        print(row)\n    print()\n\n    print(\"Test Case 2:\")\n    for row in multiply(test_case2, [[0], [6]]):\n        print(row)\n    print()\n\n    print(\"Test Case 3:\")\n    for row in multiply(test_case3, [[5, 0], [0, 3]]):\n        print(row)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "312": "```\ndef maxCoins(nums):\n    n = len(nums)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for length in range(1, n + 1):\n        for left in range(n - length + 1):\n            right = left + length\n            if left == 0:\n                dp[left][right] = min([i * (i + 1) for i in nums[:left+1]]) + \\\n                                   dp[left+1][right]\n            elif right == n:\n                dp[left][right] = min([i * (i + 1) for i in nums[left:right+1]]) + \\\n                                   dp[left][right-1]\n            else:\n                dp[left][right] = max([i * (i + 1) + dp[i+1][j-1] \n                                        for i in range(left, right+1)\n                                        for j in range(i+1, right+1)])\n\n    return dp[0][n-1]\n\ndef main():\n    print(maxCoins([3, 4, 5])) # Output: 25\n    print(maxCoins([9, 2, 3, 3, 7, 1])) # Output: 18\n    print(maxCoins([12])) # Output: 9\n\nif __name__ == \"__main__\":\n    main()\n```",
  "313": "```\ndef nthSuperUglyNumber(n, primes):\n    ugly = [1]\n    def get():\n        v = min(ugly)\n        yield v\n        ugly.append(v * min(primes))\n    return [next(get) for _ in range(n-1)]\n\nif __name__ == \"__main__\":\n    print(nthSuperUglyNumber(12, [2, 7, 13])) # Expected output: [1, 2, 4, 6, 8, 14, 20, 26, 36, 52, 68, 84]\n    print(nthSuperUglyNumber(15, [2,3,5])) # Expected output: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 20, 24, 30, 32]\n    print(nthSuperUglyNumber(10, [5,3])) # Expected output: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]",
  "314": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef verticalOrder(root):\n    if not root:\n        return []\n\n    min_col = max_col = 0\n    dict_result = {}\n    for row in getColumns(root, min_col, max_col):\n        if not row:\n            continue\n        key = tuple(sorted(row))\n        if key not in dict_result:\n            dict_result[key] = []\n        dict_result[key].extend(row)\n\n    return [vals for vals in dict_result.values()]\n\n\ndef getColumns(root, min_col, max_col):\n    if root is None:\n        return []\n\n    queue = [(root, min_col)]\n    while queue:\n        node, col = queue.pop(0)\n        if node:\n            if col < min_col:\n                min_col = col\n            elif col > max_col:\n                max_col = col\n            yield [node.val] + (getColumns(node.left, col - 1) or []) + (getColumns(node.right, col + 1) or [])\n        else:\n            yield []\n\n\ndef main():\n    # Test case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(9)\n    root1.right = TreeNode(20)\n    root1.right.left = TreeNode(15)\n    root1.right.right = TreeNode(7)\n    print(verticalOrder(root1))\n\n    # Test case 2\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    root2.left.left = TreeNode(3)\n    root2.left.right = TreeNode(4)\n    root2.right = TreeNode(5)\n    print(verticalOrder(root2))\n\n    # Test case 3\n    root3 = None\n    print(verticalOrder(root3))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "315": "```\ndef countSmallerNumbersThanTarget(nums, target):\n    def merge(p, q):\n        x = y = 0\n        result = []\n        while x < p and y < q:\n            if nums[x] <= nums[y]:\n                result.append(nums[x])\n                x += 1\n            else:\n                result.append(nums[y])\n                y += 1\n        result.extend([nums[i] for i in range(x, p)] + [nums[i] for i in range(y, q)])\n        return result\n\n    def count(arr):\n        ans = [0] * (len(arr) + 10)\n        for i in arr:\n            ans[i] += 1\n        for j in range(1, len(ans)):\n            ans[j] += ans[j - 1]\n        return ans\n\n    res = [0] * len(nums)\n    nums2 = [(x, idx) for idx, x in enumerate(nums)]\n    nums2.sort()\n    result = []\n    idx = 0\n    for i in range(len(nums)):\n        while idx < len(nums2) - 1 and nums2[idx][0] <= target:\n            idx += 1\n        res[i] = idx\n        result.append(idx)\n    print(\"Test Case 1: \", res)\n\n    nums = [5, 2, 6, 1]\n    target = 5\n    res = countSmallerNumbersThanTarget(nums, target)\n    for i in range(len(res)):\n        while idx < len(nums2) - 1 and nums2[idx][0] <= target:\n            idx += 1\n        res[i] = idx\n    print(\"Test Case 2: \", res)\n\n    nums = [6, 5, 4, 3]\n    target = 5\n    res = countSmallerNumbersThanTarget(nums, target)\n    for i in range(len(res)):\n        while idx < len(nums2) - 1 and nums2[idx][0] <= target:\n            idx += 1\n        res[i] = idx\n    print(\"Test Case 3: \", res)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "316": "```\ndef removeDuplicateLetters(s):\n    s = list(s)\n    res = []\n    while s:\n        for char in set(s):\n            if not any(char == c and i < len(res) and res[i] > char for i, c in enumerate(res)):\n                res.append(char)\n                s.pop(s.index(char))\n                break\n    return ''.join(res)\n\ndef main():\n    print(removeDuplicateLetters(\"bcab\"))  # Output: \"abc\"\n    print(removeDuplicateLetters(\"aa\"))  # Output: \"\"\n    print(removeDuplicateLetters(\"abcabcbb\"))  # Output: \"abc\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "317": "```\ndef shortestDistance(grid):\n    if not grid:\n        return []\n\n    m, n = len(grid), len(grid[0])\n    buildings = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == 1]\n    \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    distances = [[-1]*n for _ in range(m)]\n\n    for x, y in buildings:\n        queue = [(x, y, 0)]  # queue stores cells as (x, y, distance)\n        while queue:\n            px, py, pd = queue.pop(0)\n            if grid[px][py] == 1:\n                continue\n            for dx, dy in directions:\n                nx, ny = px + dx, py + dy\n                if 0 <= nx < m and 0 <= ny < n and distances[nx][ny] == -1:\n                    distances[nx][ny] = pd\n                    queue.append((nx, ny, pd + 1))\n    \n    return [[max(0, d) for d in row] for row in distances]\n\ndef main():\n    test_cases = [\n        {\n            'grid': [\n                [0,2,3,4,5],\n                [5,3,7,8,9],\n                [4,1,6,11,12],\n                [10,7,8,13,14],\n                [15,16,17,18,19]\n            ],\n            'expected': [[1,0,2],[-1,-1,1],[5,1,2],[-1,2,3],[-1,1,2]]\n        },\n        \n        {\n            'grid': [\n                [1,0,2,0],\n                [0,0,0,0],\n                [9,0,3,0],\n                {4,0,7,8,6},\n                [6,6,5,5,5]\n            ],\n            'expected': [[1,0,1],[-1,-1,-1],[-1,2,3],[4,3,2],[5,4,3]]\n        },\n        \n        {\n            'grid': [\n                [1, 0],\n                [0, 1]\n            ],\n            'expected': [[1, 1], [-1, -1]]\n        }\n    ]\n    \n    for test_case in test_cases:\n        result = shortestDistance(test_case['grid'])\n        if result == test_case['expected']:\n            print(\"Test case passed\")\n        else:\n            print(\"Test case failed\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "318": "```\ndef max_product(words):\n    n = len(words)\n    masks = [0] * n\n    \n    for i in range(n):\n        for char in words[i]:\n            masks[i] |= 1 << (ord(char) - ord('a'))\n    \n    max_len1 = 0\n    max_len2 = 0\n    \n    for i in range(n):\n        len1 = 0\n        len2 = 0\n        \n        for j in range(i+1, n):\n            if masks[i] & masks[j]:\n                continue\n            \n            len1 += 1\n            len2 += 1\n            \n            max_len1 = max(max_len1, len1)\n            max_len2 = max(max_len2, len2)\n    \n    return max_len1 * max_len2\n\n\ndef main():\n    print(max_product([\"abcw\", \"baz\", \"foo\", \"bar\", \"fxyz\", \"abcdef\"])) # Expected output: 16\n    print(max_product([\"a\", \"ab\", \"abc\", \"d\", \"cd\", \"bcd\", \"abcd\"])) # Expected output: 4\n    print(max_product([\"a\", \"aa\", \"aaa\"])) # Expected output: 9\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "319": "```\ndef numLightson(n):\n    return (n + 1) // 3\n\n\ndef flipLights(n):\n    return len([s for s in range(2**n) if sum((int(b) ^ int('1' << i)) & 1) <= 1])\n\n\ndef main():\n    print(\"Test Case 1: \", numLightson(5))\n    print(\"Test Case 2: \", flipLights(3))\n    print(\"Test Case 3: \", flipLights(4))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "320": "```\ndef generateAbbreviations(word):\n    def backtrack(abbrev, start):\n        if len(abbrev) == len(word) + 1:\n            result.append(abbrev)\n            return\n        for i in range(start, len(word)):\n            abbrev += (word[i] if i == 0 or word[i - 1].isdigit() else \"\") + \"*\" * (i - start)\n    result = []\n    backtrack(\"\", 0)\n    return result\n\ndef main():\n    print(generateAbbreviations(\"word\"))\n    print(generateAbbreviations(\"not\"))\n    print(generateAbbreviations(\"applepie\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "321": "```\ndef maximumNumber(arr1, arr2):\n    n = len(arr1)\n    m = len(arr2)\n\n    res = [0] * (n + m - 1)\n    i = j = k = 0\n\n    while i < n and j < m:\n        if arr1[i] > arr2[j]:\n            res[k] = arr1[i]\n            i += 1\n        elif arr1[i] < arr2[j]:\n            res[k] = arr2[j]\n            j += 1\n        else:\n            res[k] = arr1[i]\n            i += 1\n            j += 1\n        k += 1\n\n    while i < n:\n        res[k] = arr1[i]\n        i += 1\n        k += 1\n\n    while j < m:\n        res[k] = arr2[j]\n        j += 1\n        k += 1\n\n    return res\n\n\ndef main():\n    print(maximumNumber([3, 4, 6, 7], [1, 2, 8, 9])) \n    print(maximumNumber([2, 1, 5], [3, 4, 7])) \n    print(maximumNumber([9, 8, 7], [1, 2, 3, 4]))",
  "322": "```\ndef coinChange(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if i - coin >= 0 and dp[i - coin] + 1 < dp[i]:\n                dp[i] = dp[i - coin] + 1\n    return dp[amount] if dp[amount] != float('inf') else -1\n\ndef main():\n    print(coinChange([1,2,5], 11)) # Expected output: 3\n    print(coinChange([2], 3)) # Expected output: -1\n    print(coinChange([1], 0)) # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "323": "```\ndef numComponents(head, G):\n    res = 0\n    last = -1\n    curr = head\n\n    while curr:\n        first = curr.next\n        while first:\n            if first.val < curr.val or (first.val == curr.val and first.next is None):\n                return 0\n            first = first.next\n        res += 1\n        last = curr.val\n        curr = curr.next\n\n    return res\n\n\ndef main():\n    print(numComponents(0, [[0, 1], [1, 4], [3, 4]])) \n    print(numComponents(1, [[0, 1],[2,3],[3,4],[1,2]]))\n    print(numComponents(2, []))\n\nmain()\n```",
  "324": "```\ndef wiggleSort(nums):\n    if len(nums) <= 1:\n        return nums\n\n    pivot = quickselect(nums, len(nums)//2)\n\n    left, right = [], []\n    for num in nums:\n        if num < pivot:\n            left.append(num)\n        elif num > pivot:\n            right.append(num)\n\n    return left + [pivot]*((len(nums)-len(left)-len(right))//2) + (right[::-1] if len(right) % 2 else [])\n\ndef quickselect(arr, k):\n    if len(arr) == 1:\n        return arr[0]\n\n    pivot = arr[len(arr)//2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n\n    if k < len(left):\n        return quickselect(left, k)\n    elif k < len(left) + len(middle):\n        return middle[0]\n    else:\n        return quickselect(right, k - len(left) - len(middle))\n\ndef main():\n    print(wiggleSort([1,5,1,1,6,4])) \n    print(wiggleSort([3,3,2,7,2,3,1])) \n    print(wiggleSort([2,1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "325": "```\ndef maxEqualFrequency(nums, k):\n    n = len(nums)\n    freq = {}\n    for x in nums:\n        if x not in freq:\n            freq[x] = 0\n        freq[x] += 1\n    seen = set()\n    for i, x in enumerate(nums):\n        for j in range(i+1, n):\n            y = sum(freq) - freq.get(x, 0)\n            z = sum(1 for k in freq if k < y)\n            if z == k:\n                return j - i + 1\n    return 0\n\ndef main():\n    print(maxEqualFrequency([1,3], 3)) \n    print(maxEqualFrequency([-3,-5,-2,-4,-2], -2))\n    print(maxEqualFrequency([5,6,7,8,9], 4))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "326": "```\ndef myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    if n < 0:\n        return 1 / myPow(x, -n)\n    if n % 2 == 0:\n        half_pow = myPow(x, n // 2)\n        return half_pow * half_pow\n    return x * myPow(x, n - 1)\n\ndef main():\n    print(myPow(3, 5)) # should be 243.0\n    print(myPow(2, -2)) # should be 0.25\n    print(myPow(4, 0)) # should be 1\n\nmain()\n```",
  "327": "```\ndef rangeSum(N, L, R):\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N+1):\n        prefix_sum[i] = prefix_sum[i-1] + L[i-1]\n\n    def count_range_sum(L, R):\n        left = 0\n        right = len(prefix_sum) - 1\n\n        while left <= right:\n            mid = (left + right) // 2\n            curr_sum = prefix_sum[mid+1]\n            if L <= curr_sum <= R:\n                return mid+1\n\n            if curr_sum < L:\n                left = mid+1\n            else:\n                right = mid-1\n        return 0\n\n    res = count_range_sum(R, N)\n    for i in range(2):\n        res += count_range_sum(L+i, R)\n\n    return res\n\ndef main():\n    print(rangeSum(4, [-3,-2,-4,-5], -8)) # Expected output: 6\n    print(rangeSum(4, [1,2,3,4], 0)) # Expected output: 3\n    print(rangeSum(7, [0,9,5,0,4,9,7,8,8], 14)) # Expected output: 6\n\nmain()\n```",
  "328": "```\ndef oddEvenList(head):\n    if not head or not head.next:\n        return head\n\n    even = head\n    odd = head.next\n\n    while odd and odd.next:\n        even.next = odd.next\n        even = even.next\n        odd.next = even.next\n        odd = odd.next\n\n    even.next = odd\n    return head\n\n\ndef printList(head):\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\n\ndef main():\n    # Test case 1: Empty list\n    head = None\n    print(\"Odd Even Linked List for empty list:\")\n    printList(oddEvenList(head))\n\n    # Test case 2: Odd length list\n    head = Node(1, Node(2, Node(3, Node(4))))\n    print(\"\\nOdd Even Linked List for odd length list:\")\n    printList(oddEvenList(head))\n\n    # Test case 3: Even length list\n    head = Node(1, Node(2, Node(3, Node(4, Node(5)))))\n    print(\"\\nOdd Even Linked List for even length list:\")\n    printList(oddEvenList(head))\n\n\nclass Node:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "329": "```\ndef longest_increasing_path(grid):\n    if not grid:\n        return 0\n\n    rows, cols = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(i, j):\n        if visited[i][j]:\n            return 1\n        visited[i][j] = True\n\n        max_len = 1\n        for d in directions:\n            ni, nj = i + d[0], j + d[1]\n            if 0 <= ni < rows and 0 <= nj < cols and grid[ni][nj] > grid[i][j]:\n                max_len = max(max_len, 1 + dfs(ni, nj))\n        visited[i][j] = False\n        return max_len\n\n    visited = [[False] * cols for _ in range(rows)]\n    longest_path = 0\n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j] > -1:\n                longest_path = max(longest_path, dfs(i, j))\n\n    return longest_path\n\n\ndef main():\n    test_cases = [\n        # Test Case 1: \n        [[9, 9, 4], [6, 6, 8], [2, 1, 1]],\n\n        # Test Case 2:\n        [[3, 3, 3], [3, 3, 3], [3, 3, 3]],\n\n        # Test Case 3: \n        [[1, 2], [4, 5]]\n    ]\n\n    for test_case in test_cases:\n        print(f\"Longest Increasing Path in a Matrix: {longest_increasing_path(test_case)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "330": "```\ndef minStartValue(arr):\n    total = 0\n    for x in arr:\n        total += x\n    if total < 1:\n        return 1 + -total\n    else:\n        return 1\n\ndef main():\n    print(minStartValue([-3,2,-5,4,1,-12,6,7,-15,13,8,-5,23])) # expected output: 6\n    print(minStartValue([-5,0,-10]) ) # expected output: 11\n    print(minStartValue([7]) ) # expected output: 7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "331": "```\ndef isSameTree(p, q):\n    if not p and not q:\n        return True\n    if not p or not q:\n        return False\n    if p.val != q.val:\n        return False\n    return isSameTree(p.left, q.left) and isSameTree(p.right, q.right)\n\ndef str2node(S):\n    if not S:\n        return None\n    values = []\n    i = 0\n    while i < len(S):\n        while i + 1 < len(S) and S[i+1] != ',':\n            i += 1\n        values.append(int(S[:i]))\n        S = S[i+1:]\n        i = 0\n    return TreeNode(values[0]), [TreeNode(val) for val in values[1:]]\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef deserialize(data):\n    if not data:\n        return None\n    node_queue = deque([TreeNode(int(data.pop(0)))])\n    while node_queue and data:\n        last_node = node_queue.popleft()\n        val = int(data.pop(0))\n        if val != 0:\n            last_node.left = TreeNode(val)\n            node_queue.append(last_node.left)\n        else:\n            data.insert(0, '0')\n        val = int(data.pop(0))\n        if val != 0:\n            last_node.right = TreeNode(val)\n            node_queue.append(last_node.right)\n        else:\n            data.insert(0, '0')\n    return last_node\n\ndef isValidSerialization preorder:\n    nodes = preorder.split(\",\")\n    if len(nodes) == 1:\n        return True\n    for i in range(len(nodes)-1):\n        if nodes[i] != \"\": \n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    main()\n\ndef main():\n    assert isSameTree(str2node(\"1,1,2,null,null\"), str2node(\"1,2\")) == True\n    assert isSameTree(str2node(\"1,2\"), str2node(\"1\")) == False\n    print(isValidSerialization('9,3,4,#,#,1,#,#,2,#,6,#,#'))\n```",
  "332": "```\nfrom collections import defaultdict\n\ndef findItinerary(graph):\n    graph = sorted([(city, flight) for city in graph for flight in graph[city]])[::-1]\n    itinerary = []\n    for (city, _) in set((city, _) for (_, city) in graph):\n        while graph[city]:\n            _, flight = graph.pop(0)\n            if not itinerary or itinerary[-1] != flight:\n                itinerary.append(flight)\n            else:\n                break\n    return ['STN'] + itinerary\n\ndef main():\n    graph1 = {\"JFK\": [\"SFO\", \"ATL\"], \"SFO\": [], \"ATL\": []}\n    print(findItinerary(graph1))  # Expected output: ['STN', 'ATL', 'SFO', 'JFK']\n\n    graph2 = {\"MIA\": [\"OMA\"], \"OMA\": [\"LAX\"], \"LAX\": [\"SFO\"], \"SFO\": [\"MIA\"]}\n    print(findItinerary(graph2))  # Expected output: ['STN', 'MIA', 'SFO', 'LAX', 'OMA']\n\n    graph3 = {\"JFK\": [\"KUL\", \"SIN\"], \"SIN\": [], \"KUL\": []}\n    print(findItinerary(graph3))  # Expected output: ['STN', 'KUL', 'SIN', 'JFK']\n\nif __name__ == \"__main__\":\n    main()\n```",
  "333": "```\nclass Solution:\n    def maxDepth(self, root):\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n    def dfs(self, node, min_val, max_val):\n        if not node:\n            return float('inf')\n        new_min = max(min_val, node.val)\n        new_max = min(max_val, node.val)\n        left_depth = self.dfs(node.left, new_min, new_max) + 1\n        right_depth = self.dfs(node.right, new_min, new_max) + 1\n        return max(left_depth, right_depth)\n\n    def largestBSTSubtree(self, root):\n        if not root:\n            return 0\n        depth = self.maxDepth(root)\n        return min(depth, self.dfs(root, float('-inf'), float('inf')))\n\ndef main():\n    s = Solution()\n    \n    # Test Case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(1)\n    root1.right = TreeNode(4)\n    root1.left.left = TreeNode(3)\n    root1.left.right = TreeNode(nullValue=0)\n    print(s.largestBSTSubtree(root1))  # Expected Output: 5\n\n    # Test Case 2\n    root2 = TreeNode(2)\n    root2.left = TreeNode(1)\n    root2.right = TreeNode(4)\n    root2.left.left = TreeNode(0)\n    root2.left.right = TreeNode(nullValue=3)\n    print(s.largestBSTSubtree(root2))  # Expected Output: 3\n\n    # Test Case 3\n    root3 = TreeNode(1)\n    root3.left = TreeNode(4)\n    root3.right = TreeNode(5)\n    root3.left.left = TreeNode(nullValue=2)\n    root3.left.right = TreeNode(3)\n    print(s.largestBSTSubtree(root3))  # Expected Output: 2\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nnullValue = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "334": "```\ndef increasingTriplet(nums):\n    if len(nums) < 3:\n        return False\n\n    first = second = float('inf')\n    for num in nums:\n        if num <= first:\n            first = num\n        elif num <= second:\n            second = num\n        else:\n            return True\n\n    return False\n\n\ndef main():\n    print(increasingTriplet([1, 2, 3, 4, 5]))  # Test case 1: True\n    print(increasingTriplet([5, 4, 2, 3]))   # Test case 2: False\n    print(increasingTriplet([1, 2, 1, 6, 7])) # Test case 3: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "335": "```\ndef isSelfCrossing(x):\n    if len(x) < 1:\n        return False\n    for i in range(1, len(x)):\n        if x[i-1] >= x[i]:\n            return True\n    return False\n\n\ndef main():\n    print(isSelfCrossing([4,7,1,8]))  # Test case 1: True\n    print(isSelfCrossing([5,0,4]))     # Test case 2: False\n    print(isSelfCrossing([9,-3,2,-1,1])) # Test case 3: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "336": "```\ndef palindromePairs(words):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.word = None\n\n    class Trie:\n        def __init__(self):\n            self.root = TrieNode()\n\n        def insert(self, word):\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.word = word\n\n        def search(self, word):\n            node = self.root\n            for char in word:\n                if char not in node.children:\n                    return None\n                node = node.children[char]\n            return node.word\n\n    def find_paired_palindromes(words):\n        trie = Trie()\n        paired_palindromes = []\n        for i, word in enumerate(words):\n            if is_palindrome(word):\n                paired_palindromes.append((i, -1))\n            for j in range(len(word)):\n                prefix = word[:j]\n                suffix = word[j:]\n                if is_palindrome(prefix) and is_palindrome(suffix):\n                    paired_palindromes.append((i, len(words) + j))\n            for j in range(len(word), 0, -1):\n                prefix = word[:j]\n                suffix = word[j:]\n                if is_palindrome(prefix) and is_palindrome(suffix):\n                    paired_palindromes.append((len(words) + j, i))\n        return paired_palindromes\n\n    def find_pairs(trie, words):\n        paired_palindromes = []\n        for i, word in enumerate(words):\n            for j in range(len(word)):\n                prefix = word[:j]\n                if is_palindrome(prefix):\n                    node = trie.root\n                    for char in reversed(prefix):\n                        if char not in node.children:\n                            break\n                        node = node.children[char]\n                    if node.word and node.word != word and is_palindrome(node.word + word[j:]):\n                        paired_palindromes.append((i, len(words) + j))\n            for j in range(len(word), 0, -1):\n                prefix = word[:j]\n                node = trie.root\n                for char in prefix:\n                    if char not in node.children:\n                        break\n                    node = node.children[char]\n                if node.word and node.word != word and is_palindrome(node.word + word[j:]):\n                    paired_palindromes.append((len(words) + j, i))\n        return paired_palindromes\n\n    def find_all_pairs(words):\n        trie = Trie()\n        for word in words:\n            trie.insert(word)\n        return find_pairs(trie, words)\n\n    def solution(words):\n        result = []\n        for i, word in enumerate(words):\n            if is_palindrome(word):\n                result.extend(find_paired_palindromes([word]))\n        result.extend(find_all_pairs(words))\n        return [[x, y] for x, y in set(tuple(sorted(p)) for p in result)]\n\ndef main():\n    words = [\"abcd\",\"dcba\",\"lls\",\"ser\",\"aro\",\"badc\"]\n    print(solution(words))\n\n    words = [\"a\",\"\"]\n    print(solution(words))\n\n    words = [\"ab\",\"ba\",\"c\"]\n    print(solution(words))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "337": "```\nclass Solution:\n    def robIII(self, root):\n        if not root:\n            return 0\n        \n        memo = {}\n        \n        def dfs(node):\n            if node in memo:\n                return memo[node]\n            \n            total = node.val\n            \n            if node.left:\n                left = dfs(node.left)\n                right = dfs(node.right)\n                total += max(left, 0) + max(right, 0)\n            else:\n                total = 0\n            \n            memo[node] = total\n            return total\n        \n        return max(0, dfs(root))\n    \ndef main():\n    s = Solution()\n    root1 = TreeNode(3)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(5)\n    root1.left.left = TreeNode(1)\n    root1.left.right = TreeNode(4)\n    print(s.robIII(root1))  # Output: 9\n    \n    root2 = TreeNode(7)\n    root2.left = TreeNode(3)\n    root2.right = TreeNode(4)\n    root2.left.left = TreeNode(1)\n    root2.left.right = TreeNode(2)\n    print(s.robIII(root2))  # Output: 10\n    \n    root3 = TreeNode(5)\n    root3.left = TreeNode(3)\n    root3.right = TreeNode(2)\n    print(s.robIII(root3))  # Output: 8\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right",
  "338": "```\ndef countBits(n):\n    result = [0]\n    for i in range(1, n+1):\n        if i & (i - 1) == 0:\n            result.append(1)\n        else:\n            result.append(result[-1] + 1)\n    return result\n\n\ndef main():\n    print(countBits(5))  # Output: [0, 1, 1, 2, 1, 2]\n    print(countBits(10))  # Output: [0, 1, 1, 2, 1, 2, 3, 1, 2, 2, 3]\n    print(countBits(15))  # Output: [0, 1, 1, 2, 1, 2, 3, 1, 2, 2, 3, 2, 3]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "339": "```\ndef depthSum(nestedList):\n    def dfs(node):\n        if isinstance(node, int):\n            return node\n        elif isinstance(node, list):\n            return sum(dfs(subnode) for subnode in node)\n    \n    total = 0\n    stack = [(nestedList, 1)]\n    while stack:\n        node, depth = stack.pop()\n        total += dfs(node) * depth\n    return total\n\n\ndef main():\n    print(depthSum([1,[4,[6]]])) # Output: 13\n    print(depthSum([0,[0,[0,[0,[5,2]]]]])) # Output: 5\n    print(depthSum([1,[1,[1,[3,9]]]])) # Output: 18\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "340": "```\ndef characterReplacement(s: str, k: int) -> int:\n    if not s or k < 0:\n        return 0\n    \n    n = len(s)\n    char_count = [0] * 26\n    max_length = 0\n    left = 0\n    max_count = 0\n\n    for right in range(n):\n        char_count[ord(s[right]) - ord('a')] += 1\n        max_count = max(max_count, char_count[ord(s[right]) - ord('a')])\n\n        while right - left + 1 - max_count > k:\n            char_count[ord(s[left]) - ord('a')] -= 1\n            left += 1\n\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n\n\ndef main():\n    print(characterReplacement(\"ABAB\", 2))  # Output: 4\n    print(characterReplacement(\"AABABB\", 3))  # Output: 6\n    print(characterReplacement(\"AAAAAAAAAAAAAAAC\", 5))  # Output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "341": "```\ndef flattenNestedListIterator(lists):\n    result = []\n    def dfs(lst):\n        while lst:\n            if isinstance(lst[0], list):\n                dfs(lst.pop(0))\n            else:\n                result.append(lst.pop(0))\n\n    dfs(lists)\n    return iter(result)\n\ndef main():\n    # Test case 1\n    lists = [[1,2], [3,], [4,5,6]]\n    expected_result = [1, 2, 3, 4, 5, 6]\n    result = list(flattenNestedListIterator(lists))\n    print(result == expected_result)\n\n    # Test case 2\n    lists = [1, [4, 5, [6]], 7, [8, [9]]]\n    expected_result = [1, 4, 5, 6, 7, 8, 9]\n    result = list(flattenNestedListIterator(lists))\n    print(result == expected_result)\n\n    # Test case 3\n    lists = [[1,2], [3,[4,5]], [6]]\n    expected_result = [1, 2, 3, 4, 5, 6]\n    result = list(flattenNestedListIterator(lists))\n    print(result == expected_result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "342": "```\nclass Solution:\n    def isPowerOfFour(self, n: int) -> bool:\n        if n <= 0:\n            return False\n        if (n & (n - 1)) == 0 and ((n >> 1) & 0x7fffffff) == 0:\n            return True\n        return False\n\nif __name__ == \"__main__\":\n    s = Solution()\n    print(s.isPowerOfFour(16), \"Expected: True\")\n    print(s.isPowerOfFour(5), \"Expected: False\")\n    print(s.isPowerOfFour(1), \"Expected: True\")\n```",
  "343": "```\ndef integerBreak(n):\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    res = 1\n    for i in range(4, n+1):\n        res *= i-1\n    return res\n\ndef main():\n    print(integerBreak(2)) # Test case 1: n = 2\n    print(integerBreak(3)) # Test case 2: n = 3\n    print(integerBreak(5)) # Test case 3: n = 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "344": "```\ndef reverseString(s):\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        s[left], s[right] = s[right], s[left]\n        left += 1\n        right -= 1\n    return \"\".join(s)\n\ndef main():\n    print(\"Test case 1: \")\n    print(reverseString(\"hello\")) # expected output: \"olleh\"\n\n    print(\"\\nTest case 2: \")\n    print(reverseString(\"abcde\")) # expected output: \"edcba\"\n\n    print(\"\\nTest case 3: \")\n    print(reverseString(\"a\")) # expected output: \"a\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "345": "```\ndef reverseVowels(s):\n    vowels = set('aeiouAEIOU')\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] not in vowels:\n            left += 1\n        elif s[right] not in vowels:\n            right -= 1\n        else:\n            s[left], s[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n    return ''.join(s)\n\ndef main():\n    print(reverseVowels(\"hello\")) # Expected: \"holle\"\n    print(reverseVowels(\"leetcode\")) # Expected: \"leotcede\"\n    print(reverseVowels(\"aao\")) # Expected: \"oaa\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "346": "```\nclass MovingAverage:\n    def __init__(self, size):\n        self.size = size\n        self.queue = []\n\n    def next(self, val: int) -> float:\n        if len(self.queue) == self.size:\n            self.queue.pop(0)\n        self.queue.append(val)\n        return sum(self.queue) / len(self.queue)\n\ndef main():\n    ma = MovingAverage(3)\n    print(ma.next(1))  # 1.00000\n    print(ma.next(3))  # 2.00000\n    print(ma.next(5))  # 3.00000\n\nif __name__ == \"__main__\":\n    main()\n```",
  "347": "```\nimport heapq\nfrom collections import Counter\n\ndef topKFrequent(nums, k):\n    count = Counter(nums)\n    return [x[0] for x in heapq.nlargest(k, count.items(), key=lambda x: x[1])]\n\ndef main():\n    print(topKFrequent([1,1,1,2,2,3], 2))\n    print(topKFrequent([-1,-1,1,1,2,3], 2))\n    print(topKFrequent([0,0,1,1,2,2,3,3,4,5,6], 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "349": "```\ndef intersect(nums1, nums2):\n    set1 = set(nums1)\n    set2 = set(nums2)\n    \n    return list(set1 & set2)\n\ndef main():\n    print(intersect([1,2,3], [3,4,5])) # Expected output: [3]\n    print(intersect([1, 2, 3], [4, 5, 6])) # Expected output: []\n    print(intersect([1, 2], [2, 3])) # Expected output: [2]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "348": "```\nclass TicTacToe:\n\n    def __init__(self, n: int):\n        self.n = n\n        self.rows = [0] * n\n        self.cols = [0] * n\n        self.diags = [0]\n\n    def move(self, row: int, col: int, player: int) -> int:\n        if row < 0 or row >= self.n or col < 0 or col >= self.n:\n            return 0\n\n        if player == 1:\n            sign = 1\n        else:\n            sign = -1\n\n        self.rows[row] += sign\n        self.cols[col] += sign\n        if row == col:\n            self.diags[0] += sign\n        if row + col == self.n - 1:\n            self.diags[1] += sign\n\n        if abs(self.rows[row]) == self.n or abs(self.cols[col]) == self.n or abs(self.diags[0]) == self.n or abs(self.diags[1]) == self.n:\n            return player\n        return 0\n\n\ndef main():\n    tic_tac_toe = TicTacToe(3)\n    print(tic_tac_toe.move(0, 0, 1)) # expected output: 1\n    print(tic_tac_toe.move(0, 1, 2)) # expected output: 2\n    print(tic_tac_toe.move(2, 2, 1)) # expected output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "350": "```\ndef intersect(nums1, nums2):\n    result = []\n    for num in set(nums1):\n        if num in nums2:\n            count1 = nums1.count(num)\n            count2 = nums2.count(num)\n            for _ in range(min(count1, count2)):\n                result.append(num)\n    return sorted(result)\n\ndef main():\n    print(intersect([1, 2], [1, 3])) # Expected output: [1]\n    print(intersect([4, 9, 0], [9, 0, 4]) ) # Expected output: [0, 4, 9]\n    print(intersect([4, 9, 0], []) ) # Expected output: []\n\nmain()\n```",
  "351": "```\ndef rowsCovered(pattern):\n    n = len(pattern)\n    dp = [0] * (1 << n)\n    \n    for i in range(1 << n):\n        for j in range(n):\n            if ((i >> j) & 1):\n                if pattern[j] == 'up':\n                    i &= ~(1 << j)\n                elif pattern[j] == 'down':\n                    i |= 1 << j\n                elif pattern[j] == 'right':\n                    pass\n                elif pattern[j] == 'left':\n                    i |= 1 << j\n    \n    return dp.index(max(dp))\n\ndef main():\n    test_cases = [(1, \"123\"), (2, \"124\"), (3, \"1234\")]\n    \n    for case in test_cases:\n        n, pattern = case\n        print(f\"Test case {n}: The minimum number of rows needed to unlock is {rowsCovered(pattern)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "352": "```\nclass SummaryRanges:\n\n    def __init__(self):\n        self.start = None\n        self.end = None\n        self.values = []\n\n    def addNum(self, val: int) -> None:\n        if not self.values or val - self.values[-1] > 1:\n            if self.start is not None and self.end is not None:\n                self.values.append((self.start, self.end))\n                self.start = None\n                self.end = None\n            self.values.append((val, val))\n        elif val == self.values[-1][1] + 1:\n            self.values[-1] = (self.values[-1][0], val)\n        else:\n            self.values.append((val, val))\n\n    def getSummary(self) -> list:\n        result = []\n        for start, end in self.values:\n            if start == end:\n                result.append(f\"{start}\")\n            else:\n                result.append(f\"{start}->{end}\")\n        return [\"[\" + \",\".join(result) + \"]\"]\n\n\ndef main():\n    summaryRanges = SummaryRanges()\n    \n    # Test Case 1\n    summaryRanges.addNum(1)\n    print(summaryRanges.getSummary())  # Output: [\"[1]\"]\n    \n    # Test Case 2\n    summaryRanges.addNum(3)\n    print(summaryRanges.getSummary())  # Output: [\"[1, 1]\", \"[3]\"]\n    \n    # Test Case 3\n    for i in range(1, 9):\n        summaryRanges.addNum(i)\n    print(summaryRanges.getSummary())  # Output: [\"[1, 7]\"]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "353": "```\ndef snakeGame(board):\n    if not board:\n        return 0\n    \n    rows, cols = len(board), len(board[0])\n    snake = [[0]*cols for _ in range(rows)]\n    directions = [(0,1),(0,-1),(1,0),(-1,0)] # right, left, down, up\n    score = 0\n    head = [0,0]\n    food = []\n    \n    def valid(head):\n        return 0 <= head[0] < rows and 0 <= head[1] < cols\n    \n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 'F':\n                food.append([i,j])\n    \n    while True:\n        if not valid(head) or snake[head[0]][head[1]]: # hit wall or self\n            return score\n        \n        snake[head[0]][head[1]] = 1\n        \n        if head in food:\n            score += 1\n            food.remove(head)\n        \n        new_head = [(head[0]+x[0],head[1]+x[1]) for x in directions][random.randint(0,3)]\n        \n        if valid(new_head):\n            head = new_head\n        else: # cannot move, game over\n            return score\n\ndef main():\n    board1 = [['#','#\",\"#','#','#'],\n             ['#','.','.','.','F'],\n             ['#','.','.','.','#'],\n             ['#','.','.','.','#'],\n             ['#','#',\"#\",\"#\"]]\n    print(snakeGame(board1))\n    \n    board2 = [['#',\"#\",\"#\",\"#\"],\n             ['#','.','.','.'],\n             ['#','.','.','.'],\n             ['#','.','.','.'],\n             ['#',\"#\",\"#\",\"#\"]]\n    print(snakeGame(board2))\n    \n    board3 = [['#',\"#\",\"#\",\"#\"],\n             ['#','.','F','.'],\n             ['#','.','.','.'],\n             ['#','.','.','.'],\n             ['#',\"#\",\"#\" \"#\"]]\n    print(snakeGame(board3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "354": "```\ndef maxEnvelopes(envelopes):\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    dp = [1] * len(envelopes)\n    \n    for i in range(1, len(envelopes)):\n        for j in range(i):\n            if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                \n    return max(dp)\n\ndef main():\n    test_cases = [\n        [[5,4],[6,7],[6,3],[7,2]],\n        [[1,3],[3,3],[5,3],[0,0]],\n        [[10,14],[5,15],[13,12]]\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Test case: {test_case}, Max Envelopes: {maxEnvelopes(test_case)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "355": "```\nclass Tweet:\n    def __init__(self, tweetId: int, userId: int):\n        self.tweetId = tweetId\n        self.userId = userId\n\nclass Twitter:\n\n    def __init__(self):\n        self.users = {}\n        self.tweets = []\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        if userId not in self.users:\n            self.users[userId] = []\n        self.users[userId].append(tweetId)\n        self.tweets.append((userId, tweetId))\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        res = []\n        for tweet in self.tweets[::-1]:\n            if tweet[0] == userId or len(res) >= 10:\n                break\n            res.append(tweet[1])\n        return res\n\ndef main():\n    tw = Twitter()\n    print(tw.getNewsFeed(1)) # []\n    tw.postTweet(1, 5)\n    print(tw.getNewsFeed(1)) # [5]\n    tw.postTweet(2, 6)\n    tw.postTweet(1, 7)\n    print(tw.getNewsFeed(1)) # [7, 5]\n    print(tw.getNewsFeed(2)) # [6]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "356": "```\ndef reflection(p):\n    n = len(p)\n    result = [[p[0][0], p[0][1]], [p[n-1][0], p[n-1][1]]]\n    for i in range(1, n - 1):\n        if (p[i][0] > p[i-1][0]) == (p[i][0] < p[i+1][0]):\n            result.append([p[i][0], p[i][1]])\n        else:\n            result.append([p[n-i-1][0], p[n-i-1][1]])\n    return result\n\ndef main():\n    test_cases = [\n        {\"points\": [[1, 1], [-1, 1], [-1, -1], [1, -1]], \"expected\": [[1, 1], [-1, 1], [-1, -1], [1, -1]]},\n        {\"points\": [[-1, 0], (0, 4), (2, 3)], \"expected\": [[1, 0], (0, 4), (2, 3)]},\n        {\"points\": [[0, 0], (0, 5), (-5, -5)], \"expected\": [[0, 0], (0, 5), (-5, -5)]}\n    ]\n\n    for test_case in test_cases:\n        result = reflection(test_case[\"points\"])\n        if result == test_case[\"expected\"]:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected: {test_case['expected']}, got: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "357": "```\ndef countNumbersWithUniqueDigits(n):\n    MOD = 10**9 + 7\n    ans = 1\n    unique = 1\n    for i in range(1, n+1):\n        ans *= (26 - unique)\n        if i < 26:\n            unique = i\n        else:\n            unique = 26\n    return int(ans % MOD)\n\ndef main():\n    print(countNumbersWithUniqueDigits(3)) # Test case 1\n    print(countNumbersWithUniqueDigits(4)) # Test case 2\n    print(countNumbersWithUniqueDigits(5)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "358": "```\ndef rearrange_string(s: str, k: int) -> List[str]:\n    ...\n\ndef main():\n    print(rearrange_string(\"aaabbbcc\", 1)) \n    print(rearrange_string(\"aabcdd\", 2))\n    print(rearrange_string(\"abcd\", 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "360": "```\ndef sortTransformedArray(nums):\n    n = len(nums)\n    res = [0] * n\n    left, right = 0, n - 1\n    for i in range(n):\n        if abs(nums[left]) > abs(nums[right]):\n            res[i] = nums[left]\n            left += 1\n        else:\n            res[i] = nums[right]\n            right -= 1\n\ndef main():\n    print(\"Test case 1:\")\n    nums = [-4, -2, 2, 4]\n    result = sortTransformedArray(nums)\n    print(result)\n\n    print(\"\\nTest case 2:\")\n    nums = [0, 1, 3, 10]\n    result = sortTransformedArray(nums)\n    print(result)\n\n    print(\"\\nTest case 3:\")\n    nums = [-1000, -1]\n    result = sortTransformedArray(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "359": "```\nclass LRUCache:\n\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            value = self.cache.pop(key)\n            self.cache[key] = value  # move to the end\n            return value\n        else:\n            return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.cache.pop(key)\n        elif len(self.cache) >= self.capacity:\n            k = next(iter(self.cache))  # remove the least recently used\n            self.cache.pop(k)\n        self.cache[key] = value\n\ndef main():\n    cache1 = LRUCache(2)\n    print(cache1.get(1))  # returns -1 (not found)\n    cache1.put(1, 1)\n    print(cache1.get(1))  # returns 1\n    cache1.put(2, 2)\n    print(cache1.get(1))   # returns 1\n    print(cache1.get(3))   # returns -1 (not found)\n    cache1.put(3, 3)       # evicts key 2\n    print(cache1.get(2))   # returns -1 (not found)\n\n    cache2 = LRUCache(3)\n    cache2.put(1, 1)\n    cache2.put(2, 2)\n    print(cache2.get(1))   # returns 1\n    print(cache2.get(2))   # returns 2\n    cache2.put(3, 3)       # evicts key 1\n    print(cache2.get(1))   # returns -1 (not found)\n\n    cache3 = LRUCache(5)\n    for i in range(5):\n        cache3.put(i, i * i)\n    print(cache3.get(4))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "361": "```\ndef maxDiff(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    dp[0][0] = grid[0][0]\n    for i in range(1, m):\n        dp[i][0] = dp[i-1][0] + grid[i][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + grid[0][j]\n\n    for i in range(1, m):\n        for j in range(1, n):\n            if grid[i][j]:\n                dp[i][j] = max(min(dp[i-1][j], dp[i][j-1]), 0) + grid[i][j]\n            else:\n                dp[i][j] = max(min(dp[i-1][j], dp[i][j-1]), 0)\n    \n    res = float('-inf')\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j]:\n                res = max(res, dp[i][j])\n    return res\n\n\ndef main():\n    test_cases = [\n        [[0,0,0,1],[4,5,7,8],[0,3,6,9]],\n        [[0,1,2,3],[3,4,5,6],[1,2,4,5]],\n        [[0,0,0],[2,2,2]]\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        result = maxDiff(test_case)\n        print(f\"Result: {result}\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "362": "```\ndef hitCounter(filename):\n    from collections import deque\n\n    class HitCounter:\n        def __init__(self):\n            self.hit_time = []\n            self.hits = deque()\n\n        def hit(self, timestamp: int) -> None:\n            if not self.hits or timestamp - self.hit_time[0] > 300:\n                if self.hits:\n                    self.hit_time.pop(0)\n                    self.hits.popleft()\n            while self.hits and self.hit_time[-1] <= timestamp - 300:\n                self.hit_time.pop()\n                self.hits.popleft()\n            self.hit_time.append(timestamp)\n            self.hits.append(None)\n\n        def getHits(self, timestamp: int) -> list:\n            start = max(0, self.hit_time[0] - (timestamp - 299))\n            return [t for t in self.hit_time if t >= start]\n\n    def main():\n        h = HitCounter()\n        print(h.getHits(2500)) # Test Case 1\n        h.hit(1500)\n        h.hit(2808)\n        h.hit(2941)\n        print(h.getHits(2967)) # Test Case 2\n        time.sleep(5) \n        for _ in range(3):\n            h.hit(int(time.time() * 1000))\n        print(h.getHits(int(time.time() * 1000))) # Test Case 3\n\n    if __name__ == \"__main__\":\n        import time\n        main()\n```",
  "363": "```\ndef maxSumSubmatrix(matrix, k):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    res = float('-inf')\n    for left in range(n):\n        temp = [0] * m\n        for right in range(left, n):\n            prefix_sum = [a + b for a, b in zip(temp, [matrix[i][right] - matrix[i][left] for i in range(m)])]\n            prefix_sum.sort()\n            res = max(res, sum([prefix_sum[i] + prefix_sum[-1 -i] for i in range((m+1)//2)]))\n    return res if res > k else 0\n\ndef main():\n    test_cases = [\n        {\"matrix\": [[1,0,1],[0,-2,3]], \"k\": 2, \"expected_result\": 2},\n        {\"matrix\": [[-1,-1,-1],[1,1,1]], \"k\": 3, \"expected_result\": 0},\n        {\"matrix\": [[10,-3,10,4,6],[-3,8,5,-6,1],[3,9,-7,7,-5]],\"k\":15,\"expected_result\":23}\n    ]\n    \n    for test_case in test_cases:\n        result = maxSumSubmatrix(test_case[\"matrix\"], test_case[\"k\"])\n        if result == test_case[\"expected_result\"]:\n            print(\"Test case passed\")\n        else:\n            print(f\"Test case failed, expected {test_case['expected_result']} but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "364": "```\ndef maxDepth(nestedList):\n    if not isinstance(nestedList, list):\n        return 0\n    depth = 1\n    for item in nestedList:\n        depth = max(depth, 1 + maxDepth(item))\n    return depth\n\ndef depthSum(nestedList):\n    def dfs(node, level):\n        if isinstance(node, list):\n            return sum(dfs(child, level+1) for child in node)\n        else:\n            return node * (2 ** (level-1))\n\n    return dfs(nestedList, 1)\n\ndef maxDepthSum(nestedList):\n    depth = maxDepth(nestedList)\n    return depthSum(nestedList)\n\ndef main():\n    print(maxDepthSum([1,[4,[6],7],[8,[0]]])) # Expected output: 15\n    print(maxDepthSum([[0,2], [3,[],]. [9]])) # Expected output: 5\n    print(maxDepthSum([1,[12],34])) # Expected output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "365": "```\ndef numSteps(steps):\n    steps = str(steps)\n    return len([i for i in range(len(steps)) if (steps[i] == '1' and (i == 0 or steps[i-1] == '0')) or (steps[i] == '0' and (i == 0 or steps[i-1] == '1'))])\n\ndef main():\n    print(numSteps(8)) # Test case 1\n    print(numSteps(4)) # Test case 2\n    print(numSteps(7)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "366": "```\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef findLeaves(root):\n    if not root:\n        return []\n\n    leaves = []\n    stack = [(root, 'root')]\n\n    while stack:\n        node, parent_type = stack.pop()\n\n        if not node.left and not node.right:\n            if parent_type == 'root':\n                leaves.append(node.val)\n            else:\n                leaves.append(node.val - 1)\n\n        if parent_type != 'root' and (node.left or node.right):\n            stack.append((node.left, 'left'))\n            stack.append((node.right, 'right'))\n\n    return leaves\n\ndef main():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n\n    print(findLeaves(root))  # Output: [4, 5]\n\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    root.right.left = TreeNode(6)\n\n    print(findLeaves(root))  # Output: [4, 5, 6]\n\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n\n    print(findLeaves(root))  # Output: []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "367": "```\ndef isPerfectSquare(n):\n    if n < 2:\n        return True\n    left, right = 2, n\n    while left <= right:\n        mid = (left + right) // 2\n        square = mid * mid\n        if square == n:\n            return True\n        elif square > n:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return False\n\ndef main():\n    test_cases = [(16, True), (14, False), (4, True)]\n    for n, expected in test_cases:\n        result = isPerfectSquare(n)\n        print(f\"Test case {n}: expected={expected}, actual={result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "368": "```\ndef findLCS(a):\n    dp = [[x for x in range(len(a)+1)] for y in range(len(a)+1)]\n    for i in range(1, len(a)+1):\n        for j in range(1, len(a)+1):\n            if a[i-1] == a[j-1]:\n                dp[i][j] = 1 + dp[i-1][j-1]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[-1][-1]\n\ndef largestDivisibleSubset(nums):\n    if not nums:\n        return []\n    \n    nums.sort()\n    dp = [[num] for num in nums]\n    \n    for i in range(len(nums)):\n        for j in range(i):\n            if nums[i] % nums[j] == 0 and len(dp[i]) < len(dp[j]) + 1:\n                dp[i] = dp[j] + [nums[i]]\n                \n    return max(dp, key=len)\n\ndef main():\n    print(\"Largest Divisible Subset of [12, 5, 9, 20]:\")\n    print(largestDivisibleSubset([12, 5, 9, 20]))\n    \n    print(\"\\nLargest Divisible Subset of [4, 8, 13, 16, 24]\"):\n    print(largestDivisibleSubset([4, 8, 13, 16, 24]))\n\n    print(\"\\nLargest Divisible Subset of [1, 2, 3, 4, 5]:\")\n    print(largestDivisibleSubset([1, 2, 3, 4, 5]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "369": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef addOne(head):\n    dummy = ListNode(0)\n    current = dummy\n    carry = 1\n    \n    while head or carry:\n        if head:\n            current.next = ListNode((head.val + carry) % 10)\n            head = head.next\n        else:\n            current.next = ListNode(carry % 10)\n        \n        carry //= 10\n        \n        current = current.next\n\n    return dummy.next\n\n\ndef printList(head):\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n    print()\n\n\ndef main():\n    # Test Case 1\n    node1 = ListNode(7)\n    node2 = ListNode(2)\n    node3 = ListNode(7)\n    \n    node1.next = node2\n    node2.next = node3\n    \n    printList(addOne(node1))  # Output: 8 3 8\n\n    # Test Case 2\n    node4 = ListNode(5)\n    node5 = ListNode(6)\n    node6 = ListNode(7)\n    \n    node4.next = node5\n    node5.next = node6\n    \n    printList(addOne(node4))  # Output: 6 7 8\n\n    # Test Case 3\n    node7 = ListNode(9)\n    node8 = ListNode(9)\n    node9 = ListNode(9)\n    \n    node7.next = node8\n    node8.next = node9\n    \n    printList(addOne(node7))  # Output: 0 0 0 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "371": "```\ndef getSum(a: int, b: int) -> int:\n    while b:\n        carry = a & b\n        a = a ^ b\n        b = carry << 1\n    return a\n\ndef main():\n    print(getSum(14, 4)) # Test case 1: 18\n    print(getSum(-6, 9)) # Test case 2: 3\n    print(getSum(0, 2147483647)) # Test case 3: 2147483647\n\nif __name__ == \"__main__\":\n    main()\n```",
  "370": "```\ndef subarraySum(nums, k):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n    \n    count = 0\n    seen = {0: 1}\n    total = 0\n    \n    for i in range(n):\n        total += nums[i]\n        if (total - k) in seen:\n            count += seen[total - k]\n        if total not in seen:\n            seen[total] = 0\n        seen[total] += 1\n    \n    return count\n\ndef main():\n    print(subarraySum([1, 2, 3], 3)) # Test case 1: Expected output is 2\n    print(subarraySum([-1, -1, 1], 0)) # Test case 2: Expected output is 5\n    print(subarraySum([0, 0, 0], 0)) # Test case 3: Expected output is 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "372": "```\ndef myPow(x: float, n: int) -> float:\n    if n == 0:\n        return 1\n    if n < 0:\n        x = 1 / x\n        n = -n\n    \n    if n % 2:\n        return x * myPow(x, n-1)\n    else:\n        halfpow = myPow(x, n//2)\n        return halfpow * halfpow\n\ndef main():\n    print(\"Test case 1:\")\n    print(myPow(2.0,10), \"should be\", pow(2,10))\n    print()\n\n    print(\"Test case 2:\")\n    print(myPow(-3.0,2), \"should be\", -9)\n    print()\n\n    print(\"Test case 3:\")\n    print(myPow(5.0,-2), \"should be\", 0.25)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "373": "```\nimport heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n\n    heap = []\n    for i in range(min(len(nums1), len(nums2))):\n        if i < len(nums2) - 1:\n            heapq.heappush(heap, (nums1[i], nums2[i], i))\n        else:\n            break\n\n    result = []\n    while k > 0 and heap:\n        val, num, i = heapq.heappop(heap)\n        result.append((nums1[i], nums2[i]))\n        if i + 1 < len(nums1):\n            heapq.heappush(heap, (nums1[i+1], nums2[i], i+1))\n        k -= 1\n\n    return result[:k]\n\n\ndef main():\n    test_cases = [\n        ([1,7],[5,9],3),\n        ([1,2],[1,3],3),\n        ([1,1,1],[1,1],4)\n    ]\n\n    for nums1, nums2, k in test_cases:\n        print(f\"Test case: {nums1}, {nums2}, {k}\")\n        result = kSmallestPairs(nums1, nums2, k)\n        print(result)\n        print()\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "374": "```\ndef getGuessNumber(start, end, target):\n    while start <= end:\n        mid = (start + end) // 2\n        if target == mid:\n            return mid\n        elif target > mid:\n            start = mid + 1\n        else:\n            end = mid - 1\n    return -1\n\ndef main():\n    print(getGuessNumber(1, 10, 9))  # Test case 1: Target is in the middle\n    print(getGuessNumber(2, 3, 4))   # Test case 2: Target is one more than the end\n    print(getGuessNumber(5, 8, 6))   # Test case 3: Target is exactly at the start\n\nif __name__ == \"__main__\":\n    main()\n```",
  "375": "```\ndef getGuessNumber(low, high):\n    left = 1\n    right = (high + low) // 2\n    \n    while True:\n        mid = (right - left) // 2 + left\n        \n        if guess(mid) == target:\n            return mid\n        elif guess(mid) < target:\n            left = mid + 1\n        else:\n            right = mid\n\ndef getGuessNumber(low, high):\n    n = high - low + 1\n    for i in range(2, int(n**0.5) + 1):\n        if (high - low + 1) % i == 0 and guess((low + high)//2) != target:\n            return ((high - low + 1) // i) * i\n\ndef getGuessNumber(low, high):\n    n = high - low + 1\n    for i in range(2, int(n**0.5) + 1):\n        if (high - low + 1) % i == 0 and guess((low + high)//2) != target:\n            return ((high - low + 1) // i) * i\n\ndef getGuessNumber(low, high):\n    n = high - low + 1\n    for i in range(2, int(n**0.5) + 1):\n        if (high - low + 1) % i == 0 and guess((low + high)//2) != target:\n            return ((high - low + 1) // i) * i\n\ndef getGuessNumber(low, high):\n    n = high - low + 1\n    for i in range(2, int(n**0.5) + 1):\n        if (high - low + 1) % i == 0 and guess((low + high)//2) != target:\n            return ((high - low + 1) // i) * i\n\nif __name__ == '__main__':\n    print(getGuessNumber(1, 10))\n    print(getGuessNumber(-5, 7))\n    print(getGuessNumber(8, 12))\n\n```\nNote that the `guess` function is not provided in this solution.",
  "376": "```\ndef wiggleMaxLength(nums):\n    if len(nums) < 2:\n        return len(nums)\n\n    up = [0] * (len(nums) + 1)\n    down = [0] * (len(nums) + 1)\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            up[i] = max(up[i], down[i - 1] + 1)\n        elif nums[i] < nums[i - 1]:\n            down[i] = max(down[i], up[i - 1] + 1)\n\n    return max(max(upper for upper in up if (i == len(nums) - 1 or nums[upper] <= nums[upper + 1])) for i in range(len(nums)))\n\ndef main():\n    print(wiggleMaxLength([1,2,3,4,5,6,7,8])) # Test case 1\n    print(wiggleMaxLength([1,17,5,10,13,16,9,18])) # Test case 2\n    print(wiggleMaxLength([1,2,3,3,2,1,1,1])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "377": "```\ndef combinationSum4(nums, target):\n    dp = [0] * (target + 1)\n    dp[0] = 1\n    for i in range(1, target + 1):\n        for num in nums:\n            if i >= num:\n                dp[i] += dp[i - num]\n    return dp[target]\n\ndef main():\n    print(combinationSum4([9], 3)) # Test case 1\n    print(combinationSum4([7,3,2,6], 7)) # Test case 2\n    print(combinationSum4([5,3,4], 8)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "378": "```\ndef kthSmallest(matrix, k):\n    n = len(matrix)\n    min_val = matrix[0][0]\n    max_val = matrix[n-1][n-1]\n\n    while True:\n        mid_val = (min_val + max_val) // 2\n        count = sum(1 for row in matrix if any(cell <= mid_val for cell in row))\n\n        if count == k:\n            return mid_val\n\n        if count < k:\n            min_val = mid_val + 1\n        else:\n            max_val = mid_val - 1\n\n\ndef main():\n    test_case1 = [\n        [1,   5,  9],\n        [20, 28, 15],\n        [23, 30, 25]\n    ]\n    print(kthSmallest(test_case1, 5))  # Expected output: 15\n\n    test_case2 = [\n        [14, 24, 27, 65],\n        [53, 58, 62, 78],\n        [41, 47, 51, 91],\n        [49, 55, 63, 68]\n    ]\n    print(kthSmallest(test_case2, 12))  # Expected output: 52\n\n    test_case3 = [\n        [1, 2],\n        [5, 6]\n    ]\n    print(kthSmallest(test_case3, 4))  # Expected output: 5\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "379": "```\ndef phoneNumberDirectory():\n    class PhoneDirectory:\n        def __init__(self):\n            self.available = set()\n            self.assignment = {}\n\n        def getNumber(self):\n            if not self.available:\n                return -1\n            available = list(self.available)\n            number = available.pop(0)\n            for i in range(len(self.assignment)):\n                if self.assignment[i] is None:\n                    self.assignment[i] = number\n                    break\n            else:\n                self.available.add(number)\n            return number\n\n        def checkNumber(self, number):\n            return number in self.assignment.values()\n\n    class Solution:\n        def judgeCircle(self, moves: str) -> bool:\n            x, y = 0, 0\n            for move in moves:\n                if move == 'U':\n                    y += 1\n                elif move == 'D':\n                    y -= 1\n                elif move == 'L':\n                    x -= 1\n                elif move == 'R':\n                    x += 1\n            return x == 0 and y == 0\n\n    def main():\n        phone_directory = PhoneDirectory()\n        print(phone_directory.getNumber())  # Output: 0\n        print(phone_directory.checkNumber(0))  # Output: True\n        phone_directory.available.add(4)\n        phone_directory.assignment[1] = 3\n        phone_directory.assignment[2] = 4\n        print(phone_directory.getNumber())  # Output: 3\n        print(phone_directory.checkNumber(3))  # Output: True\n        print(phone_directory.checkNumber(4))  # Output: True\n        print(phone_directory.checkNumber(5))  # Output: False\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "380": "```\nimport random\n\nclass RandomizedSet:\n\n    def __init__(self):\n        self.map = {}\n        self.list = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.map:\n            return False\n        self.map[val] = len(self.list)\n        self.list.append(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.map:\n            return False\n        index = self.map[val]\n        last_val = self.list[-1]\n        self.list[index] = last_val\n        self.map[last_val] = index\n        self.list.pop()\n        del self.map[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.list)\n\n\ndef main():\n    randomizedSet = RandomizedSet()\n\n    print(randomizedSet.insert(1))  # Expected: True\n    print(randomizedSet.insert(2))  # Expected: True\n    print(randomizedSet.getRandom())  # Expected: 1 or 2\n\n    print(randomizedSet.remove(1))   # Expected: True\n    print(randomizedSet.insert(2))   # Expected: False (already exists)\n    print(randomizedSet.getRandom())  # Expected: 2\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "381": "```\nimport random\n\nclass RandomizedSet:\n\n    def __init__(self):\n        self.dict = {}\n        self.list = []\n\n    def insert(self, val: int) -> bool:\n        if val in self.dict:\n            return False\n        self.dict[val] = len(self.list)\n        self.list.append(val)\n        return True\n\n    def remove(self, val: int) -> bool:\n        if val not in self.dict:\n            return False\n        index = self.dict[val]\n        last_element = self.list[-1]\n        self.list[index] = last_element\n        self.dict[last_element] = index\n        self.list.pop()\n        del self.dict[val]\n        return True\n\n    def getRandom(self) -> int:\n        return random.choice(self.list)\n\n\ndef main():\n    randomizedSet = RandomizedSet()\n\n    # Test case 1\n    print(randomizedSet.insert(1))\n    print(randomizedSet.insert(2))\n    print(randomizedSet.getRandom())\n    print(randomizedSet.remove(1))\n    print(randomizedSet.getRandom())\n\n    # Test case 2\n    print(randomizedSet.insert(-3))\n    print(randomizedSet.insert(-2))\n    print(randomizedSet.insert(-4))\n    print(randomizedSet.getRandom())\n    print(randomizedSet.remove(-2))\n    print(randomizedSet.getRandom())\n\n    # Test case 3\n    print(randomizedSet.insert(0))\n    print(randomizedSet.insert(1))\n    print(randomizedSet.insert(1))\n    print(randomizedSet.getRandom())\n    print(randomizedSet.remove(0))\n    print(randomizedSet.getRandom())\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "382": "```\nimport random\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef getRandomNode(head):\n    if not head:\n        return None\n    \n    result = head\n    length = 1\n    current = head\n    \n    while current:\n        r = random.randint(0, length - 1)\n        if r == length - 1:\n            result = current\n        current = current.next\n        length += 1\n    \n    return result\n\ndef main():\n    # Test case 1\n    node4 = ListNode(4)\n    node3 = ListNode(3)\n    node2 = ListNode(2)\n    node1 = ListNode(1)\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    print(\"Test Case 1: \", getRandomNode(node1).val)\n\n    # Test case 2\n    node5 = ListNode(5)\n    node4 = ListNode(4)\n    node3 = ListNode(3)\n    node2 = ListNode(2)\n    node1 = ListNode(1)\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    print(\"Test Case 2: \", getRandomNode(node1).val)\n\n    # Test case 3\n    node6 = ListNode(6)\n    node5 = ListNode(5)\n    node4 = ListNode(4)\n    node3 = ListNode(3)\n    node2 = ListNode(2)\n    node1 = ListNode(1)\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    node5.next = node6\n    print(\"Test Case 3: \", getRandomNode(node1).val)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "383": "```\ndef canConstruct(ransomNote, magazine):\n    ransomCount = {}\n    for char in ransomNote:\n        if char in ransomCount:\n            ransomCount[char] += 1\n        else:\n            ransomCount[char] = 1\n    for char in magazine:\n        if char in ransomCount and ransomCount[char] > 0:\n            ransomCount[char] -= 1\n    return all(value <= 0 for value in ransomCount.values())\n\ndef main():\n    print(canConstruct(\"a\", \"b\")) # False\n    print(canConstruct(\"aa\", \"aba\")) # True\n    print(canConstruct(\"aa\", \"aaa\")) # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "384": "```\nimport random\n\ndef shuffle(nums):\n    n = len(nums)\n    for i in range(n - 1):\n        r = i + int(random.random() * (n - i))\n        nums[r], nums[i] = nums[i], nums[r]\n    return nums\n\ndef main():\n    print(\"Test Case 1:\")\n    nums = [2, 5, 3, 8, 4, 6, 7]\n    shuffled_nums = shuffle(nums.copy())\n    print(shuffled_nums)\n\n    print(\"\\nTest Case 2:\")\n    nums = [1, 2]\n    shuffled_nums = shuffle(nums.copy())\n    print(shuffled_nums)\n\n    print(\"\\nTest Case 3:\")\n    nums = [1, 2, 3, 4, 5]\n    shuffled_nums = shuffle(nums.copy())\n    print(shuffled_nums)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "385": "```\ndef getMiniString(s):\n    def isSpace(c):\n        return c.isspace()\n\n    def parse():\n        res = []\n        i = 0\n        while i < len(s):\n            if s[i] == '(':\n                res.append('(')\n                i += 1\n                stack = []\n                j = i\n                while j < len(s) and not isSpace(s[j]):\n                    if s[j] in ['(', ')']:\n                        break\n                    stack.append(s[j])\n                    j += 1\n                for k in range(len(stack)-1, -1, -1):\n                    res.append(stack[k])\n            elif s[i] == ')':\n                res.append(')')\n                i += 1\n            else:\n                j = i\n                while j < len(s) and not isSpace(s[j]):\n                    if s[j] in ['(', ')']:\n                        break\n                    res.append(s[j])\n                    j += 1\n                res.append(' ')\n        return ''.join(res)\n\n    return parse()\n\ndef main():\n    print(getMiniString(\"))((()))\")) # Test case 1\n    print(getMiniString(\"(()())(())\")) # Test case 2\n    print(getMiniString(\"(a(b(c)d)\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "386": "```\ndef lexicalOrder(n):\n    res = []\n    for i in range(1, n+1):\n        if i > 1 and str(i)[0] == str(i-1)[0]:\n            continue\n        res.append(i)\n    return res\n\ndef main():\n    test_cases = [(10, [1, 3, 9]), (15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]), (3, [1, 2, 3])]\n    for test_case in test_cases:\n        print(f\"Input: {test_case[0]}\")\n        print(f\"Output: {lexicalOrder(test_case[0])}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "387": "```\ndef firstUncompromisingCharacter(s):\n    char_count = {}\n    \n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    \n    for i, char in enumerate(s):\n        if char_count[char] == 1:\n            return i\n\ndef main():\n    test_cases = [\n        (\"leetcode\", 0),\n        (\"loveleetcode\", 2),\n        (\"aabbcc\", -1)\n    ]\n    \n    for s, expected in test_cases:\n        result = firstUncompromisingCharacter(s)\n        if result == expected:\n            print(f\"Test case {s} passed.\")\n        else:\n            print(f\"Test case {s} failed. Expected {expected}, but got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "388": "```\ndef lengthLongestPath(path):\n    max_len = 0\n    stack = []\n\n    for p in path:\n        if '.' in p:\n            while stack and stack[-1] != '..':\n                if not stack[-1].isdigit():\n                    return max_len\n                stack.pop()\n            stack.pop()\n            max_len = len(p)\n        else:\n            while p.count('/') < len(stack) or (stack and stack[-1] == '..'):\n                if stack and stack[-1] == '.':\n                    stack.pop()\n                elif not stack[-1].isdigit():\n                    return max_len\n                stack.pop()\n            max_len += len(p.split('/')[-1]) + 1\n\n    return max_len\n\n\ndef main():\n    print(lengthLongestPath([\"/a\", \"/a/b\", \"/c/d\", \"/d\"])) # Output: 4\n    print(lengthLongestPath([\"/a\", \"/a/b/c\"])) # Output: 5\n    print(lengthLongestPath([\"/a\", \"/a/b/c\", \"/a/b/c///\"])) # Output: 6",
  "389": "```\ndef findDifference(words):\n    word_set = set(words)\n    common_chars = set.intersection(*[set(word) for word in words])\n    uncommon_chars = set.difference(set.union(*[set(word) for word in words]), common_chars)\n\n    return list(common_chars), list(uncommon_chars)\n\ndef main():\n    test_cases = [\n        {\"words\": [\"daddy\", \"baby\"], \"expected_common_chars\": ['a', 'y'], \"expected_uncommon_chars\": ['b', 'd']},\n        {\"words\": [\"hello\", \"world\"], \"expected_common_chars\": ['o'], \"expected_uncommon_chars\": ['h', 'w', 'r']},\n        {\"words\": [\"mango\", \"orange\", \"apricot\"], \"expected_common_chars\": [], \"expected_uncommon_chars\": ['a', 'n', 'o', 'g', 'p']}\n    ]\n\n    for test_case in test_cases:\n        common_chars, uncommon_chars = findDifference(test_case[\"words\"])\n        assert set(common_chars) == set(test_case[\"expected_common_chars\"]), f\"Expected {test_case['expected_common_chars']} but got {common_chars}\"\n        assert set(uncommon_chars) == set(test_case[\"expected_uncommon_chars\"]), f\"Expected {test_case['expected_uncommon_chars']} but got {uncommon_chars}\"\n\n    print(\"All test cases passed!\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "390": "```\ndef lastRemaining(n):\n    if n == 1:\n        return 0\n    isEven = n % 2 == 0\n    if isEven:\n        n //= 2\n    else:\n        n //= 2 + 1\n    return 1 - lastRemaining(n)\n\ndef main():\n    print(lastRemaining(9)) # Test case 1\n    print(lastRemaining(10)) # Test case 2\n    print(lastRemaining(11)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "391": "```\ndef calculateArea(w, h):\n    return w * h\n\ndef totalArea(rectangles):\n    area = 0\n    for rectangle in rectangles:\n        area += calculateArea(rectangle[2], rectangle[3])\n    return area\n\ndef absorbentRectangle(rectangles):\n    rectangles.sort(key=lambda x: (x[1], x[0]))\n    left, right = 0, float('inf')\n    absorbed = 0\n    for w, h, x1, y1, x2, y2 in rectangles:\n        if x1 > right or y1 < left:\n            continue\n        if x1 <= left and y1 >= right:\n            absorbed += (right - left) * max(0, min(y2, y1) - max(y1, y2))\n            continue\n        left = max(left, x1)\n        right = min(right, x2)\n    return absorbed\n\ndef main():\n    print(absorbentRectangle([[5, 8, 22, 7, 15, 28], [3, 9, 10, 23, 19, 26], [4, 25, 15, 24, 20, 25]])) # Expected: 56\n    print(absorbentRectangle([[1, 3, 7, 2, 6, 8], [3, 9, 10, 23, 19, 26], [4, 25, 15, 24, 20, 25]])) # Expected: 58\n    print(absorbentRectangle([[1, 2, 7, 6, 12, 3]])) # Expected: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "392": "```\ndef isSubsequence(s, t):\n    i = j = 0\n    while i < len(s) and j < len(t):\n        if s[i] == t[j]:\n            i += 1\n        j += 1\n    return i == len(s)\n\ndef main():\n    print(isSubsequence(\"abc\", \"ahbgdc\") == True)\n    print(isSubsequence(\"axc\", \"ahbgdc\") == False)\n    print(isSubsequence(\"ab\", \"b\") == True)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "393": "```\ndef validUtf8(data):\n    n = len(data)\n    for i in range(n):\n        byte = data[i]\n        if byte < 128:\n            if any((data[j] >> 5) & 0xF != 0xC for j in range(i+1, i+4)):\n                return False\n        elif byte >> 6 == 0x2:\n            if any(data[j] >> 3 == 0x1 for j in range(i+1, n)) or (n - i) < 2:\n                return False\n        else:\n            return False\n    return True\n\ndef main():\n    print(validUtf8([197,130,1]) and \"Valid\")\n    print(not validUtf8([235,14,116,114]) and \"Invalid\")\n    print(validUtf8([249,192,126,226,128,156]) and \"Valid\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "394": "```\ndef decodeString(s):\n    res = 0\n    mul = 1\n    temp_str = ''\n    for c in s:\n        if c == '[':\n            res = decodeStringHelper(res, mul, temp_str) + ' '\n            res += temp_str\n            temp_str = ''\n        elif c == ']':\n            return int(res)\n        elif '0' <= c <= '9':\n            mul *= int(c)\n        else:\n            temp_str += c\n    return temp_str\n\ndef decodeStringHelper(res, mul, temp_str):\n    if '[' not in temp_str:\n        return res + str(mul) * len(temp_str), 0, ''\n    i = temp_str.index('[')\n    j = temp_str.index(']')\n    count = int(temp_str[:i-1])\n    res2, mul2, temp_str = decodeStringHelper(0, 1, temp_str[i+1:j])\n    return str(count * mul) + res2, mul2 * count, temp_str\n\ndef main():\n    test_cases = [\n        (\"3[a]2[bc]\", \"aaabcc\"),\n        (\"4[ab]c\", \"cabca\"),\n        (\"20[one]a\", \"aonea\"),\n    ]\n\n    for s, expected in test_cases:\n        result = decodeString(s)\n        print(f\"Test case {s} -> {result} (Expected: {expected})\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "395": "```\ndef characterReplacement(s, k):\n    max_len = 0\n    start = 0\n    char_count = {}\n    for end in range(len(s)):\n        char_count[s[end]] = char_count.get(s[end], 0) + 1\n        \n        while (end - start + 1) - max(char_count.values()) > k:\n            char_count[s[start]] -= 1\n            if char_count[s[start]] == 0:\n                del char_count[s[start]]\n            start += 1\n            \n        max_len = max(max_len, end - start + 1)\n    return max_len\n\n\ndef main():\n    print(characterReplacement(\"ABAB\", 2))  # Output: 4\n    print(characterReplacement(\"AAABBCCC\", 2))  # Output: 10\n    print(characterReplacement(\"AAAAAA\", 3))  # Output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "396": "```\ndef maxRotateFunction(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    ans = nums[0]\n    cur_sum = sum(i * num for i, num in enumerate(nums))\n    \n    for _ in range(n):\n        cur_sum += total_sum\n        cur_sum -= nums.pop(0) * (n - 1)\n        ans = max(ans, cur_sum)\n        \n    return ans\n\ndef main():\n    test_case_1 = [4, 3, 2, 6]\n    print(\"Test case 1: \", maxRotateFunction(test_case_1))\n    \n    test_case_2 = [0, 0]\n    print(\"Test case 2: \", maxRotateFunction(test_case_2))\n    \n    test_case_3 = [0,1,0]\n    print(\"Test case 3: \", maxRotateFunction(test_case_3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "397": "```\ndef integerReplacement(n):\n    if n == 1:\n        return 0\n    if n % 2 == 0:\n        return 1 + integerReplacement(n // 2)\n    else:\n        return 1 + min(integerReplacement((n - 1) // 2), integerReplacement((n + 1) // 2))\n\ndef main():\n    print(integerReplacement(8))  # Test case 1\n    print(integerReplacement(15))  # Test case 2\n    print(integerReplacement(1000000))  # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "398": "```\nimport random\n\nclass Solution:\n    def __init__(self, nums):\n        self.nums = nums\n        self.total = len(nums)\n\n    def pick(self):\n        return random.choice(self.nums)\n\n\ndef main():\n    solution = Solution([1,2,3,4])\n\n    print(\"Test case 1:\")\n    for _ in range(10):\n        print(solution.pick(), end=\" \")\n    print()\n\n    solution = Solution([1,1,2,3])\n    print(\"Test case 2:\")\n    for _ in range(5):\n        print(solution.pick(), end=\" \")\n    print()\n\n    solution = Solution([0,1])\n    print(\"Test case 3:\")\n    for _ in range(10):\n        print(solution.pick(), end=\" \")\n    print()\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "399": "```\ndef calculate_division(expressions):\n    graph = {}\n    for expr in expressions:\n        left, right, value = map(str.strip, expr.split('/'))\n        if left not in graph:\n            graph[left] = float(value)\n        else:\n            graph[left] /= float(value)\n        if right not in graph:\n            graph[right] = 1.0 / float(value)\n    return graph\n\ndef main():\n    print(calculate_division([\"3/2\", \"1/3\", \"2/4\"]))\n    print(calculate_division([\"1000/100\", \"-50/20\", \"10/2\"]))\n    print(calculate_division([\"a/b\", \"b/c\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "400": "```\ndef findNthDigit(n):\n    length = 1\n    count = 9\n    while n > (length * 10 ** (length - 1)):\n        n -= length * 10 ** (length - 1)\n        length += 1\n        count *= 10\n    start = count + 1\n    for _ in range(n - 1):\n        start += 1\n    return str(start)[n % length]\n\ndef main():\n    print(findNthDigit(3))  # Should be \"1\"\n    print(findNthDigit(9))  # Should be \"8\"\n    print(findNthDigit(15))  # Should be \"4\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "401": "```\ndef readBinaryWatch(minutes):\n    result = []\n    for i in range(1 << 10): # 2^10 because there are 10 bits\n        h = (i >> 6) & 1\n        m = i & 0x3f\n        if h + m <= 60:\n            result.append(f\"{h} hours and {m:02d} minutes\")\n    return sorted(result)\n\ndef main():\n    test_cases = [\n        {\"minutes\": 0, \"expected_output\": [\"12:00\"]},\n        {\"minutes\": 5, \"expected_output\": [\"10:55\", \"11:55\", \"12:05\", \"12:55\", \"2:55\", \"3:55\", \"4:55\", \"5:55\", \"6:55\"]},\n        {\"minutes\": 30, \"expected_output\": [\"11:30\"]}\n    ]\n\n    for test_case in test_cases:\n        minutes = test_case[\"minutes\"]\n        expected_output = test_case[\"expected_output\"]\n\n        actual_output = readBinaryWatch(minutes)\n\n        if actual_output != expected_output:\n            print(f\"Test case failed. Expected {expected_output} but got {actual_output}\")\n        else:\n            print(f\"Test case passed: {expected_output} == {actual_output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "402": "```\ndef removeKdigits(num: str, k: int) -> str:\n    stack = []\n    for digit in num:\n        while k > 0 and (stack == [] or int(digit) >= stack[-1]):\n            stack.pop()\n            k -= 1\n        if k > 0:\n            stack.append(digit)\n    return ''.join(stack).lstrip('0') or '0'\n\ndef main():\n    print(removeKdigits(\"1432219\", 3)) # \"1219\"\n    print(removeKdigits(\"10200\", 1)) # \"100\"\n    print(removeKdigits(\"9876543321123\", 8)) # \"9874\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "403": "```\ndef minFrogJump(stones):\n    n = len(stones)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            if stones[i] - stones[j] <= 2:\n                dp[i] = min(dp[i], dp[j] + 1)\n    return dp[-1]\n\ndef main():\n    print(minFrogJump([0,1,3,5,6,8,12,17])) # Test case 1\n    print(minFrogJump([34,35,36])) # Test case 2\n    print(minFrogJump([1])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "404": "```\nclass Solution:\n    def sumOfLeftLeaves(self, root):\n        if not root or (not root.left and not root.right):\n            return 0\n        \n        total = 0\n        stack = [(root, False)]\n        \n        while stack:\n            node, is_left = stack.pop()\n            \n            if node:\n                if is_left and not node.left and not node.right:\n                    total += node.val\n                else:\n                    stack.append((node.right, False))\n                    stack.append((node.left, True))\n\n        return total\n\ndef main():\n    s = Solution()\n\n    # Test case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(9)\n    root1.right = TreeNode(20)\n    root1.right.left = TreeNode(15)\n    root1.right.right = TreeNode(7)\n    print(s.sumOfLeftLeaves(root1))  # Output: 24\n\n    # Test case 2\n    root2 = TreeNode(5)\n    root2.left = TreeNode(4)\n    root2.right = TreeNode(3)\n    root2.left.left = TreeNode(2)\n    root2.left.right = TreeNode(1)\n    print(s.sumOfLeftLeaves(root2))  # Output: 6\n\n    # Test case 3\n    root3 = TreeNode(0)\n    print(s.sumOfLeftLeaves(root3))  # Output: 0\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "405": "```\ndef toHex(num):\n    if num < 0:\n        return \"0x\" + hex(-num)[2:]\n\n    result = \"\"\n    while num > 0:\n        result = hex(num % 16)[2:].upper() + result\n        num //= 16\n\n    if not result:\n        result = \"0\"\n\n    return \"0x\" + result\n\ndef main():\n    print(toHex(26)) \n    print(toHex(-1))\n    print(toHex(601591225474224400))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "406": "```\ndef reconstructQueue(people):\n    people.sort(key=lambda x: (-x[0], x[1]))\n    result = []\n    for person in people:\n        result.insert(person[1], person)\n    return result\n\n\ndef main():\n    print(reconstructQueue([[7,0],[4,4],[7,1],[5,0],[5,2],[6,2],[3,2]]))\n    print(reconstructQueue([[9,0],[5,4],[10,2]]))\n    print(reconstructQueue([[6,0],[5,0],[4,4],[3,3]]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "407": "```\ndef trapRainWater(heightMap):\n    if not heightMap:\n        return 0\n    \n    m, n = len(heightMap), len(heightMap[0])\n    heap = [(heightMap[0][i], i, 0) for i in range(n)]\n    heapq.heapify(heap)\n    \n    rain = 0\n    while heap:\n        h, x, y = heapq.heappop(heap)\n        \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < m and 0 <= ny < n and heightMap[nx][ny] >= h:\n                rain += h - heightMap[nx][ny]\n                heightMap[nx][ny] = h\n                heapq.heappush(heap, (h, nx, ny))\n    \n    return rain\n\ndef main():\n    print(trapRainWater([[1,4,3,2,5,25],[11,11,3,7,2,14],[2,13,19,4,5,6], [9,8,27,4,26,2], [4,5,7,3,16,28]])) # Expected 10\n    print(trapRainWater([[1,2,3,4,5,25],[11,11,3,7,2,14],[2,13,19,4,5,6], [9,8,27,4,26,2], [4,5,7,3,16,28]])) # Expected 10\n    print(trapRainWater([[1,1,1,1,1,1],[0,1,0,1,0,0],[1,1,2,1,1,0], [0,0,1,1,0,0], [0,0,0,1,1,1]])) # Expected 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "408": "```\ndef validWordAbbreviation(word, abbr):\n    n = len(word)\n    m = len(abbr)\n\n    if m > n:\n        return False\n\n    i = j = 0\n    while i < n and j < m:\n        if word[i] == abbr[j]:\n            i += 1\n            j += 1\n        elif '0' <= abbr[j] <= '9':\n            if i == 0 or word[i-1] != abbr[j]:\n                return False\n            i += 1\n        else:\n            return False\n\n    return i == n and j == m\n\n\ndef main():\n    print(validWordAbbreviation(\"internationalization\", \"i18n\")) # True\n    print(validWordAbbreviation(\"applepenapple\", \"a4p6\")) # True\n    print(validWordAbbreviation(\"applepenapple\", \"a11e\")) # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "409": "```\ndef longest_palindrome(s):\n    s = ''.join(c for c in s if c.isalnum())\n    s = s.lower()\n    s += '#'\n    s += '#'\n    L = len(s)\n    P = [0] * L\n    C = R = 0\n    for i in range(1, L-1):\n        if R > i:\n            i_mirror = 2*C-i\n            P[i] = min(R-i, P[i_mirror])\n        else:\n            P[i] = 0\n\n        while s[i + 1 + P[i]] == s[i - 1 - P[i]]:\n            P[i] += 1\n\n        if i + P[i] > R:\n            C = i\n            R = i + P[i]\n\n    return max(P)\n\ndef main():\n    print(longest_palindrome(\"babad\")) # Expected output: 3\n    print(longest_palindrome(\"cbbd\")) # Expected output: 2\n    print(longest_palindrome(\"a\")) # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "410": "```\ndef maxUncrossedLines(c1, c2):\n    m, n = len(c1), len(c2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if c1[i - 1] == c2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\ndef main():\n    print(maxUncrossedLines([1, 2, 3, 4], [1, 3, 4])) # Output: 4\n    print(maxUncrossedLines([2, 5, 1, 3, 4, 10], [9, 20, 2, 10, 3, 1])) # Output: 6\n    print(maxUncrossedLines([1, 2], [1, 1])) # Output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "412": "```\ndef fizzBuzz(n):\n    result = []\n    for i in range(1, n+1):\n        if i % 3 == 0 and i % 5 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n\ndef main():\n    print(fizzBuzz(3)) # Test case 1\n    print(fizzBuzz(6)) # Test case 2\n    print(fizzBuzz(15)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "411": "```\ndef minimumUniqueWordAbbreviation(words):\n    def backtrack(start, path):\n        if start == len(word):\n            return True\n        for end in range(start + 1, min(len(word) + 1, end + 1)):\n            new_path = path + word[start:end]\n            if is_valid(new_path, seen):\n                seen.add(new_path)\n                if backtrack(end, new_path):\n                    return True\n                seen.remove(new_path)\n        return False\n\n    def is_valid(path, seen):\n        for p in seen:\n            if len(p) < len(path) and path.startswith(p):\n                return False\n        return True\n\n    words.sort()\n    shortest = min(len(word) for word in words)\n    abbreviations = []\n    for word in words:\n        while len(word) > 1:\n            for i in range(1, len(word)):\n                new_word = word[:i] + str(len(word) - i) + word[i:]\n                if is_valid(new_word, set(map(str, abbreviations))):\n                    abbreviations.append(int(new_word))\n                    break\n            else:\n                abbreviations.append(int(word))\n            break\n    return abbreviations\n\n\ndef main():\n    print(minimumUniqueWordAbbreviation([\"time\", \"me\", \"bell\"]))  # [3,4,5]\n    print(minimumUniqueWordAbbreviation([\"a113v\", \"4l760\"])  # [1,6])\n    print(minimumUniqueWordAbbreviation([\"word\", \"word2\", \"wd\"]))  # [4,34,5]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "413": "```\ndef numberOfArithmeticSlices(nums):\n    n = len(nums)\n    dp = [0] * (n + 1)\n    count = 0\n    for i in range(2, n):\n        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n            dp[i] = dp[i-1] + 1\n        else:\n            dp[i] = 0\n        count += dp[i]\n    return count\n\ndef main():\n    print(numberOfArithmeticSlices([2,4,5])) # Expected output: 3\n    print(numberOfArithmeticSlices([0,2,3,4,6])) # Expected output: 7\n    print(numberOfArithmeticSlices([1])) # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "414": "```\ndef thirdMax(nums):\n    nums = list(set(nums))\n    if len(nums) < 3:\n        return max(nums)\n    nums.sort(reverse=True)\n    return nums[2]\n\ndef main():\n    print(thirdMax([1, 2]))  # Expected output: 2\n    print(thirdMax([3, 2, 1]))  # Expected output: 1\n    print(thirdMax([1, 2, 3, 4, 5]))  # Expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "415": "```\ndef addStrings(num1, num2):\n    carry = 0\n    result = ''\n    for i in range(max(len(num1), len(num2))):\n        n1 = int(num1[-1 - i]) if i < len(num1) else 0\n        n2 = int(num2[-1 - i]) if i < len(num2) else 0\n        total = n1 + n2 + carry\n        result = str(total % 10) + result\n        carry = total // 10\n    return '1' + result if carry > 0 else result\n\ndef main():\n    print(addStrings(\"123\", \"456\") == \"579\"))\n    print(addStrings(\"11\", \"111\") == \"122\"))\n    print(addStrings(\"9999\", \"99\") == \"10978\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "416": "```\ndef canPartition(nums):\n    total_sum = sum(nums)\n    if total_sum % 2 != 0:\n        return False\n    target_sum = total_sum // 2\n    dp = [False] * (target_sum + 1)\n    dp[0] = True\n    for num in nums:\n        for i in range(target_sum, num - 1, -1):\n            if dp[i - num]:\n                dp[i] = True\n    return dp[target_sum]\n\ndef main():\n    print(canPartition([1,2,5])) # Expected: True\n    print(canPartition([1,2,3,5])) # Expected: False\n    print(canPartition([10, 7, 4, 6, 8, 11, 9])) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "418": "```\ndef wordsTyping(sentence, rows):\n    total_length = len(sentence) * (rows + 1)\n    for word in sentence:\n        total_length += len(word)\n    \n    remaining_chars = total_length % len(sentence)\n    start = 0\n    count = 0\n    for i in range(remaining_chars):\n        if sentence[i] == ' ':\n            start = i+1\n        else:\n            count += 1\n    return count\n\ndef main():\n    print(wordsTyping([\"hello\",\"world\"],2)) \n    print(wordsTyping([\"a\",\"b\",\"c\",\"d\",\"e\",\"ba\"],5))\n    print(wordsTyping([\"apple\",\"banana\"],3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "417": "```\ndef PacificAtlantic(heightMap):\n    m, n = len(heightMap), len(heightMap[0])\n    pacific = [[False]*n for _ in range(m)]\n    atlantic = [[False]*n for _ in range(m)]\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n:\n            return False\n        if heightMap[i][j] <= 0:\n            return False\n        pacific[i][j] = True\n\n    def dfs2(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n:\n            return False\n        if heightMap[i][j] <= 0:\n            return False\n        atlantic[i][j] = True\n\n    for i in range(m):\n        dfs(i, 0)\n        dfs2(i, n-1)\n\n    for j in range(n):\n        dfs(0, j)\n        dfs2(m-1, j)\n\n    res = []\n    for i in range(m):\n        for j in range(n):\n            if pacific[i][j] and atlantic[i][j]:\n                res.append([i, j])\n\n    return res\n\n\ndef main():\n    test_cases = [\n        [[1, 2, 2, 3, 5], [6, 6, 2, 2, 1], [1, 2, 1, 2, 1], [4, 3, 2, 3, 1]],\n        [[2, 1], [1, 2]],\n        [[1]]\n    ]\n    for test_case in test_cases:\n        print(PacificAtlantic(test_case))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "419": "```\ndef countBattleships(board):\n    m, n = len(board), len(board[0])\n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == 'X' and (i == 0 or board[i-1][j] != 'X') and (j == 0 or board[i][j-1] != 'X'):\n                ans += 1\n    return ans\n\ndef main():\n    print(countBattleships([\n        [\"X\", \".\", \".\", \"X\"],\n        [\".\", \"\", \".\", \"\"],\n        [\".\" , \" \", \"X\", \" \"],\n        [\".\", \"X\", \" \", \".\"]\n    ])) # Expected: 2\n\n    print(countBattleships([\n        [\"W\",\"L\",\"W\",\"H\",\"B\"],\n        [\"W\",\"R\",\"S\",\"Y\",\"C\"],\n        [\"E\",\"V\",\"A\",\"P\",\"T\"],\n        [\"D\",\"T\",\"S\",\"T\",\"N\"]\n    ])) # Expected: 3\n\n    print(countBattlesships([\".\", \".\", \".\"])) # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "420": "```\ndef strongPassword(password):\n    n = len(password)\n\n    if not password.isalnum():\n        return [False, False]\n\n    hasLowercase = False\n    hasUppercase = False\n    hasDigit = False\n    hasSpecialChar = 0\n\n    for char in password:\n        if char.islower():\n            hasLowercase = True\n        elif char.isupper():\n            hasUppercase = True\n        elif char.isdigit():\n            hasDigit = True\n        else:\n            hasSpecialChar += 1\n\n    if n < 6:\n        return [False, False]\n    elif not hasLowercase or not hasUppercase or not hasDigit:\n        return [False, min(3, hasSpecialChar)]\n    else:\n        return [True, max(0, 6 - n)]\n\ndef main():\n    passwords = [\"IloveYou\", \"Weallhackhere\", \"12345\", \"Aa1b2\"]\n    for password in passwords:\n        result = strongPassword(password)\n        print(f\"{password}: {result[0]} (at least {result[1]} characters must be changed)\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "421": "```\ndef findMaximumXOR(self, nums):\n    root = {}\n    for num in nums:\n        temp = num\n        node = root\n        max_xor = 0\n        while temp > 0:\n            bit = temp & 1\n            if '1' not in node or '0' not in node:\n                node['1'] = {'0': {}, '1': {}}\n                node['0'] = {'0': {}, '1': {}}\n                node[bit] = {}\n                temp >>= 1\n                continue\n            temp >>= 1\n            node = node[bit]\n            if '1' in node and '0' not in node:\n                max_xor = (max_xor | 1)\n            elif '0' in node and '1' not in node:\n                max_xor = (max_xor | 0)\n        self.max_xor = max(max_xor, nums[0] ^ num)\n\n    return self.max_xor\n\nclass Solution:\n    def __init__(self):\n        self.max_xor = 0\n    def main(self):\n        solution = Solution()\n        print(solution.findMaximumXOR([3,10,5,25,2,8])) # should be 28\n        print(solution.findMaximumXOR([6,5,7,1,4])) # should be 7\n        print(solution.findMaximumXOR([0,9])) # should be 9",
  "422": "```\ndef isValidWordsquare(board):\n    for i in range(len(board)):\n        temp = []\n        for j in range(len(board[0])):\n            while len(temp) <= j:\n                temp.append(\"\")\n            if board[i][j] != temp[j]:\n                return False\n    for j in range(len(board[0])):\n        temp = []\n        for i in range(len(board)):\n            while len(temp) <= i:\n                temp.append(\"\")\n            if board[i][j] != temp[i]:\n                return False\n    return True\n\ndef main():\n    test_cases = [\n        {\"board\": [[\"abcd\", \"bnja\", \"cjdc\", \"dehp\"]], \"expected\": True},\n        {\"board\": [[\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"]], \"expected\": False},\n        {\"board\": [[\"a\", \"b\", \"c\", \"d\", \"e\"], [\"e\", \"d\", \"c\", \"b\", \"a\"]], \"expected\": True}\n    ]\n    \n    for test_case in test_cases:\n        result = isValidWordsquare(test_case[\"board\"])\n        if result != test_case[\"expected\"]:\n            print(f\"Test case failed: {test_case}\")\n            return\n    print(\"All test cases passed!\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "423": "```\ndef originalDigits(b):\n    count = [0] * 10\n    words = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"]\n    letters = [\"z\", \"o\", \"w\", \"t\", \"h\", \"r\", \"f\", \"v\", \"s\", \"i\", \"n\", \"e\", \"a\", \"l\", \"c\"]\n    for i in range(10):\n        for letter in words[i]:\n            if letter in letters:\n                letters.remove(letter)\n        count[i] = len(words[i]) - sum([words[i].count(letter) for letter in words[i]])\n    result = [0] * 26\n    for word in b.split():\n        for char in word.lower():\n            if char in \"abcdefghijklmnopqrstuvwxyz\":\n                result[ord(char) - ord('a')] += 1\n    digit_count = [0] * 10\n    for i in range(10):\n        for letter in words[i]:\n            if letter.lower() in {chr(i + ord('a')) for i in range(26)}:\n                digit_count[i] += sum([result[ord(char) - ord('a')] for char in word.lower()])\n    return [digit * 1000**2 + hundred * 1000 + ten * 10 + one for one, ten, hundred, digit in zip(*[[(i,) * (count[i]) for i in range(10)] for _ in range(4)])][min((i[3],) for i in enumerate(digit_count) if i[1] > 0)]\n\ndef main():\n    print(originalDigits(\"one8two2\")) # Expected: [5,0,9]\n    print(originalDigits(\"123\")) # Expected: [1,2,3]\n    print(originalDigits(\"owoztneoouf\")) # Expected: [0,1,6,9]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "424": "```\ndef characterReplacement(s: str, k: int) -> int:\n    n = len(s)\n    max_len = 0\n    start = 0\n    char_count = [0] * 26\n\n    for end in range(n):\n        char_count[ord(s[end]) - ord('a')] += 1\n        while (end - start + 1) - max(char_count) > k:\n            char_count[ord(s[start]) - ord('a')] -= 1\n            start += 1\n        max_len = max(max_len, end - start + 1)\n\n    return max_len\n\ndef main():\n    print(characterReplacement(\"ABAB\", 2)) # Expected output: 4\n    print(characterReplacement(\"AABAAACCC\", 3)) # Expected output: 7\n    print(characterReplacement(\"BBA\", 5)) # Expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "426": "```\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.prev = None\n        self.next = None\n\ndef treeToDoublyList(root):\n    if not root:\n        return None\n\n    dummy = Node(0)\n    prev = dummy\n    stack = []\n    curr = root\n\n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n\n        node = stack.pop()\n        node.prev = prev\n        prev.next = node\n        prev = node\n\n        curr = node.right\n\n    return dummy.next\n\ndef main():\n    # Test case 1\n    root1 = Node(4)\n    root1.left = Node(2)\n    root1.right = Node(5)\n    root1.left.left = Node(1)\n    root1.left.right = Node(3)\n    root1.right.left = Node(6)\n\n    print(\"Test Case 1:\")\n    print(treeToDoublyList(root1))\n\n    # Test case 2\n    root2 = Node(8)\n    root2.left = Node(7)\n    root2.right = Node(9)\n\n    print(\"\\nTest Case 2:\")\n    print(treeToDoublyList(root2))\n\n    # Test case 3\n    root3 = None\n\n    print(\"\\nTest Case 3:\")\n    print(treeToDoublyList(root3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "425": "```\ndef wordSquares(words):\n    # your implementation here\n\nclass Solution:\n    def wordSquares(self, words):\n        self.trie = {}\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['#'] = {'word': word}\n\n    def search(self, prefix):\n        node = self.trie\n        for char in prefix:\n            if char not in node:\n                return []\n            node = node[char]\n        words = [node['#']['word']]\n        queue = [(node, [prefix])]\n        while queue:\n            node, path = queue.pop(0)\n            for char, child in node.items():\n                if char == '#':\n                    continue\n                queue.append((child, path + [char]))\n                if 'word' in child:\n                    words.append(child['word'])\n        return words\n\n    def wordSquares(self, words):\n        self.wordSquares(words)\n        min_len = len(min(words, key=len))\n        result = []\n        for i in range(min_len):\n            row = ['' for _ in range(len(words))]\n            for j in range(1 << len(words)):\n                prefix = ''\n                for k in range(len(words)):\n                    if (j & (1 << k)):\n                        prefix += words[k][i]\n                    else:\n                        prefix += '-'\n                words_list = self.search(prefix)\n                for k, word in enumerate(words_list):\n                    row[k] = word[i]\n            result.append(row)\n        return result\n\ndef main():\n    solution = Solution()\n    print(solution.wordSquares([[\"oath\",\"pea\",\"eat\",\"rain\"]])) \n    print(solution.wordSquares([[\"acts\",\"beep\",\"at\",\"week\"]]))\n    print(solution.wordSquares([[]]))\n\nif __name__ == \"__main__\":\n    main()",
  "428": "```\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef serialize(root):\n    def helper(node):\n        if node:\n            vals.append(str(node.val))\n            for child in node.children:\n                helper(child)\n        else:\n            vals.append('null')\n    vals = []\n    helper(root)\n    return ' '.join(vals)\n\ndef deserialize(data):\n    nodes = data.split()\n    root = None\n    i = 0\n    def helper():\n        nonlocal i\n        if nodes[i] != 'null':\n            node = Node(int(nodes[i]))\n            i += 1\n            for j in range(i, len(nodes)):\n                if nodes[j].isdigit():\n                    break\n            node.children = [helper() for _ in range(len(nodes[i+1:j]))]\n            return node\n        else:\n            i += 1\n            return None\n    root = helper()\n    return root\n\ndef main():\n    # Test case 1\n    tree1 = Node(1)\n    tree1.children = [Node(2), Node(3), Node(4)]\n    tree1.children[0].children = [Node(5)]\n    tree1.children[1].children = [Node(6), Node(7)]\n    print(serialize(tree1))\n    deserialized_tree1 = deserialize(serialize(tree1))\n    # Test case 2\n    tree2 = Node(1)\n    tree2.children = [Node(2), Node(3), Node(4)]\n    print(serialize(tree2))\n    deserialized_tree2 = deserialize(serialize(tree2))\n    # Test case 3\n    tree3 = None\n    print(serialize(tree3))\n    deserialized_tree3 = deserialize(serialize(tree3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "427": "```\nclass Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\nclass QuadTree:\n    def __init__(self, root: 'Node' = None):\n        this.root = root;\n\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        if not grid:\n            return null;\n        return constructQuadTree(grid);\n\n    def constructQuadTree(grid: List[List[int]]) -> 'Node':\n        if not grid or not grid[0]:\n            return new Node(0, True, None, None, None, None);\n        \n        height = 0\n        while (1 << height) > grid.length:\n            height += 1;\n        \n        if allSameValue(grid):\n            return new Node(grid[0][0], True, None, None, None, None);\n\n        midY = grid.length / 2;\n        midX = grid[0].length / 2;\n\n        topLeft = constructQuadTree(getSubGrid(grid, 0, 0, midX, midY));\n        topRight = constructQuadTree(getSubGrid(grid, midX, 0, grid[0].length, midY));\n        bottomLeft = constructQuadTree(getSubGrid(grid, 0, midY, midX, grid.length));\n        bottomRight = constructQuadTree(getSubGrid(grid, midX, midY, grid[0].length, grid.length));\n\n        return new Node(1, False, topLeft, topRight, bottomLeft, bottomRight);\n\n    def getSubGrid(grid: List[List[int]], startX: int, startY: int, endX: int, endY: int) -> List[List<int]]:\n        if (startX >= endX or startY >= endY):\n            return [];\n        \n        result = new ArrayList<>();\n        for i in range(startY, endY):\n            row = new ArrayList<>();\n            for j in range(startX, endX):\n                row.add(grid[i][j]);\n            result.add(row);\n        return result;\n\n    def allSameValue(grid: List[List[int]]) -> boolean:\n        if not grid or not grid[0]:\n            return true;\n        \n        val = grid[0][0];\n        for i in range(grid.length):\n            for j in range(grid[0].length):\n                if (grid[i][j] != val):\n                    return false;\n        return true;\n\npublic class Main {\n    public static void main(String[] args) {\n        QuadTree quadTree = new QuadTree();\n        Node node1 = quadTree.construct(new int[][]{{1, 1, 1, 1, 0}, {0, 1, 1, 0, 0}, {0, 0, 1, 0, 0}, {0, 0, 0, 0, 1}});\n        System.out.println(node1.val);\n        \n        Node node2 = quadTree.construct(new int[][]{{4, 3, 3, 2, 3, 3, 1 }, \n            {9, 6, 5, 7, 5, 5, 9}, \n            {5, 8, 8, 9, 8, 9, 5},\n            {8, 7, 9, 6, 6, 8, 8}, \n            {4, 3, 3, 2, 3, 3, 1 }, \n            {9, 6, 5, 7, 5, 5, 9}});\n        System.out.println(node2.val);\n        \n        Node node3 = quadTree.construct(new int[][]{{1, 0}, {0, 0}});\n        System.out.println(node3.val);\n    }\n}\n```",
  "429": "```\ndef printLevelOrder(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n            \n            for child in node.children:\n                queue.append(child)\n        result.append(level)\n\n    return result\n\ndef main():\n    # Test Case 1\n    root = Node(1)\n    child1 = Node(3)\n    child2 = Node(5)\n    child3 = Node(6)\n    child4 = Node(7)\n    \n    root.children = [child1, child2]\n    child1.children = [child3, child4]\n\n    print(printLevelOrder(root))\n\n    # Test Case 2\n    root = Node(1)\n    child1 = Node(2)\n    child2 = Node(3)\n\n    root.children = [child1, child2]\n    \n    print(printLevelOrder(root))\n\n    # Test Case 3\n    root = Node(1)\n    \n    print(printLevelOrder(root))\n\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children else []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "430": "```\nclass Node:\n    def __init__(self, val: int = 0, prev: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\ndef flatten(head: 'Node') -> 'Node':\n    if not head:\n        return None\n\n    curr = head\n    while curr and curr.next:\n        next_node = curr.next\n        while next_node and next_node.next:\n            next_node = next_node.next\n        curr.next = next_node.next\n        if curr.next:\n            curr.next.prev = curr\n        else:\n            break\n        curr = curr.next\n\n    return head\n\n\ndef print_list(head: 'Node') -> None:\n    while head:\n        print(head.val, end=' ')\n        head = head.next\n    print()\n\n\ndef main():\n    # Test case 1\n    node4 = Node(4)\n    node5 = Node(5)\n    node6 = Node(6)\n    node7 = Node(7)\n    node8 = Node(8)\n    node9 = Node(9)\n    node10 = Node(10)\n    node11 = Node(11)\n\n    node3 = Node(3, None, node4)\n    node2 = Node(2, None, node3)\n    node1 = Node(1, None, node2)\n    node0 = Node(0, None, node1)\n\n    node10.prev = node9\n    node9.next = node10\n\n    node7.prev = node6\n    node6.next = node7\n\n    node5.prev = node4\n    node4.next = node5\n\n    head = node0\n    print_list(flatten(head))  # Output: 0 1 2 3 4 5 6 7 8 9 10 11\n\n    # Test case 2\n    node13 = Node(13)\n    node14 = Node(14)\n\n    node12 = Node(12, None, node13)\n    node11.next = node12\n\n    node10.prev = node9\n    node9.next = node10\n\n    head = node0\n    print_list(flatten(head))  # Output: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14\n\n    # Test case 3\n    head = None\n    print_list(flatten(head))  # Output:\n\nif __name__ == \"__main__\":\n    main()\n```",
  "431": "```\ndef encode(naryTree):\n    def dfs(node):\n        if not node:\n            return None\n        result = TreeNode(1)\n        stack = [(node, result)]\n        while stack:\n            node, result = stack.pop()\n            if node.right:\n                child = TreeNode(0)\n                if node.left:\n                    stack.append((node.left, child))\n                    node.left = None\n                while stack and stack[-1][0].right:\n                    stack[-1][0] = stack[-1][0].right\n                result.right = child\n            if node.left:\n                stack.append((node.left, result))\n                node.left = None\n        return result\n\n    return dfs(naryTree)\n\nclass TreeNode:\n    def __init__(self, val=0, children=None):\n        self.val = val\n        self.children = children if children else []\n\ndef main():\n    n1 = TreeNode(1)\n    n2 = TreeNode(3)\n    n3 = TreeNode(4)\n    n4 = TreeNode(5)\n    n5 = TreeNode(6)\n    naryTree = TreeNode(1, [n1, n2, n3], [n4, n5])\n\n    root = encode(naryTree)\n\n    print(\"Test Case 1: \")\n    treePrint(root)\n\n    n1 = TreeNode(1)\n    n2 = TreeNode(2)\n    n3 = TreeNode(3)\n    naryTree = TreeNode(1, [n1], [n2, n3])\n\n    root = encode(naryTree)\n\n    print(\"Test Case 2: \")\n    treePrint(root)\n\n    n1 = TreeNode(1)\n    n2 = TreeNode(2)\n    naryTree = TreeNode(1, [n1, n2])\n\n    root = encode(naryTree)\n\n    print(\"Test Case 3: \")\n    treePrint(root)\n\ndef treePrint(node):\n    if node:\n        print(node.val, end=' ')\n        for child in node.children:\n            treePrint(child)\n```",
  "432": "```\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass AllOne:\n    def __init__(self):\n        self.root = Node(0, 0)\n        self.minNode = self.root\n        self.maxNode = self.root\n\n    def inc(self, key):\n        if self.get(key) is not None:\n            node = self.get(key)\n            prevNode = node.prev\n            node.prev = None\n            if prevNode is not None:\n                prevNode.next = node.next\n                if node == self.minNode:\n                    self.minNode = prevNode\n            else:\n                node.next = self.root.next\n                if node.next is not None:\n                    node.next.prev = node\n                else:\n                    self.maxNode = node\n            self.push(key, 1)\n\n    def dec(self, key):\n        node = self.get(key)\n        if node is None:\n            return\n        prevNode = node.prev\n        nextNode = node.next\n        node.prev = None\n        if nextNode is not None:\n            nextNode.prev = node\n        else:\n            self.maxNode = node\n        self.pop(key, 1)\n\n    def get(self, key):\n        root = self.root\n        while True:\n            if key <= root.key:\n                if root.left is not None and root.left.key == key:\n                    return root.left\n                elif root.left is None:\n                    break\n                root = root.left\n            else:\n                if root.right is not None and root.right.key >= key:\n                    return root.right\n                elif root.right is None:\n                    break\n                root = root.right\n\n    def push(self, key, value):\n        node = Node(key, value)\n        self.root.push(node)\n\n    def pop(self, key, value):\n        self.root.pop(key, value)\n\n    def getLeastRecentKey(self):\n        return self.minNode.key if self.minNode.value > 0 else None\n\ndef main():\n    obj = AllOne()\n    print(obj.getLeastRecentKey()) # Expected: None\n    obj.inc(1)\n    print(obj.getLeastRecentKey()) # Expected: 1\n    obj.dec(1)\n    print(obj.getLeastRecentKey()) # Expected: None",
  "433": "```\ndef minMutation(root, start, end):\n    if not root:\n        return -1\n\n    queue = [(root, [start])]\n    visited = set([start])\n\n    while queue:\n        node, path = queue.pop(0)\n        if node.val == end:\n            return len(path) - 1\n\n        for child in node.children:\n            new_path = list(path)\n            new_path.append(child.val)\n            if child.val not in visited:\n                queue.append((child, new_path))\n                visited.add(child.val)\n\n    return -1\n\ndef main():\n    root = Node('p', ['o', 'q'], {'o': Node('b', [], {'b': Node('y', [], {}), 'a': Node('r', [], {})}, {'y': Node('t', [], {}), 'n': Node('x', [], {})}), 'q': Node('s', [], {}})\n    print(minMutation(root, 'p', 'y'))  # Output: 3\n    print(minMutation(root, 'q', 'z'))   # Output: -1\n    print(minMutation(root, 'a', 'c'))   # Output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "434": "```\ndef countSegments(s):\n    return len([i for i in s.split() if i])\n\ndef main():\n    print(countSegments(\"Hello World\")) # Test case 1: \"Hello World\" -> 2\n    print(countSegments(\"     \")) # Test case 2: \"     \" -> 0\n    print(countSegments(\"Hello   World  \")) # Test case 3: \"Hello   World  \" -> 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "435": "```\ndef eraseOverlapIntervals(intervals):\n    if not intervals:\n        return 0\n\n    intervals.sort(key=lambda x: (x[1], x[0]))\n\n    end = intervals[0][1]\n    count = 1\n\n    for i in range(1, len(intervals)):\n        if intervals[i][0] >= end:\n            end = intervals[i][1]\n            count += 1\n        elif intervals[i][1] < end:\n            end = intervals[i][1]\n\n    return len(intervals) - count\n\n\ndef main():\n    print(eraseOverlapIntervals([[0,2],[1,3]]))  # Output: 1\n    print(eraseOverlapIntervals([[0,2],[1,2],[2,3]]))  # Output: 2\n    print(eraseOverlapIntervals([[1,3],[2,4]]))  # Output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "436": "```\ndef findRightInterval(intervals):\n    x = [(interval[1], i) for i, interval in enumerate(intervals)]\n    x.sort()\n    def search(interval):\n        left, right = 0, len(x)-1\n        while left <= right:\n            mid = (left+right)//2\n            if x[mid][0] >= interval[0]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return x[left][1]\n    return [search(interval) for interval in intervals]\n\ndef main():\n    print(findRightInterval([[3,4],[2,3],[1,2]]))\n    print(findRightInterval([[1,2]]))\n    print(findRightInterval([[0,2],[5,5],[7,10]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "437": "```\nclass Solution:\n    def pathSum(self, root: TreeNode, targetSum: int) -> int:\n        if not root:\n            return 0\n        \n        self.count = 0\n        self.dfs(root, targetSum)\n        \n        return self.count\n\n    def dfs(self, node, target):\n        if not node:\n            return 0\n        \n        left = node.val + self.dfs(node.left, target - node.val)\n        right = node.val + self.dfs(node.right, target - node.val)\n        \n        if left == target or right == target:\n            self.count += 1\n        \n        return max(left, right)\n\ndef main():\n    s = Solution()\n    \n    root = TreeNode(10)\n    root.left = TreeNode(-3)\n    root.right = TreeNode(9)\n    root.left.left = TreeNode(5)\n    root.left.right = TreeNode(-2)\n    root.right.right = TreeNode(2)\n    root.left.left.left = TreeNode(3)\n    root.left.left.right = TreeNode(1)\n    \n    print(s.pathSum(root, 8))  # Output: 2\n    print(s.pathSum(root, 7))  # Output: 3\n    print(s.pathSum(root, -5))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "438": "```\ndef groupAnagrams(strs):\n    anagrams = {}\n    for s in strs:\n        sorted_str = \"\".join(sorted(s))\n        if sorted_str not in anagrams:\n            anagrams[sorted_str] = [s]\n        else:\n            anagrams[sorted_str].append(s)\n    return list(anagrams.values())\n\ndef main():\n    print(groupAnagrams([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]))\n    print(groupAnagrams([\"\"]))\n    print(groupAnagrams([\"a\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "439": "```\nclass Solution:\n    def parseTernary(self, expression: str) -> str:\n        if not expression or len(expression) == 1:\n            return expression\n        \n        i = 0\n        while i < len(expression):\n            if expression[i] in ['?', ':']:\n                return expression[:i] + self.parseTernary(expression[i+1:]) if expression[i] == '?' else self.parseTernary(expression[i+1:]) + expression[i:] \n            i += 1\n        \n        return expression\n\ndef main():\n    solution = Solution()\n    \n    print(solution.parseTernary(\"a?b:c\"))  # a?b:c\n    print(solution.parseTernary(\"a?:c\"))  # a?:c\n    print(solution.parseTernary(\"a:b:c\"))  # a:b:c\n\nif __name__ == \"__main__\":\n    main()\n```",
  "440": "```\nclass Solution:\n    def getSmallestString(self, n: int, k: int) -> str:\n        root = {}\n        for i in range(1, 27):\n            if i <= 9:\n                t = str(i)\n            else:\n                t = chr(ord('a') + i - 10)\n            if i not in root:\n                root[i] = {}\n            for j in range(i):\n                root[i][j+1] = {}\n            root[i][0] = str(t)\n\n        res = \"\"\n        temp = k\n        for i in range(n-1, -1, -1):\n            if temp <= 25 and len(res) < n:\n                res = 'a' * (n - len(res)) + chr(ord('a') + temp - 1) + res\n                temp -= 1\n            else:\n                while temp > i * 26 + 1:\n                    root[i+1][temp % (i+1)].setdefault(temp // (i+1), {})\n                    res = chr(ord('z') - (temp % (i+1))) + res\n                    temp //= i+1\n                if temp == i*26+1:\n                    res += 'a' * (n - len(res))\n                else:\n                    res += str(temp - i*26) + res\n\n        return res\n\ndef main():\n    s = Solution()\n    print(s.getSmallestString(3, 27)) # \"jay\"\n    print(s.getSmallestString(5, 13)) # \"a3e1i2\"\n    print(s.getSmallestString(500, 498)) # \"bhhhhhiiiiiiiiiilooppqqrrssttttuuuwwyyyyzz\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "441": "```\ndef arrangeCoins(n):\n    return min((1 + (8 * n)) ** 0.5 - 1) // 2\n\ndef main():\n    print(arrangeCoins(5)) \n    print(arrangeCoins(8))\n    print(arrangeCoins(2))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "442": "```\ndef findDuplicates(nums):\n    seen = set()\n    duplicates = []\n    \n    for num in nums:\n        if num in seen:\n            if num not in duplicates:\n                duplicates.append(num)\n        else:\n            seen.add(num)\n    \n    return duplicates\n\n\ndef main():\n    print(findDuplicates([4, 3, 2, 7, 8, 3, 1, 5, 6]) == [3, 4])\n    print(findDuplicates([1, 2, 3, 4]) == [])\n    print(findDuplicates([1, 3, 2, 2]) == [2])\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "443": "```\ndef compress(s):\n    if not s:\n        return s\n\n    compressed = []\n    i = 0\n    while i < len(s):\n        count = 1\n        while i + 1 < len(s) and s[i] == s[i+1]:\n            i += 1\n            count += 1\n        compressed.append(s[i] + str(count))\n        i += 1\n\n    return ''.join(compressed)\n\n\ndef main():\n    print(\"Test case 1: \")\n    print(compress(\"aaabbcc\"))  # Output: \"a3b2c2\"\n\n    print(\"\\nTest case 2: \")\n    print(compress(\"abc\"))  # Output: \"abc\"\n\n    print(\"\\nTest case 3: \")\n    print(compress(\"aabbccc\"))  # Output: \"a2b2c3\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "444": "```\ndef sequenceReconstruction(shuffles, seq):\n    from collections import defaultdict, deque\n\n    graph = defaultdict(list)\n    indegree = {i: 0 for i in range(len(seq) + 1)}\n\n    for shuffle in shuffles:\n        for j in range(len(shuffle) - 1):\n            a, b = shuffle[j], shuffle[j + 1]\n            if seq[a] < seq[b]:\n                graph[seq.index(a)].append(seq.index(b))\n                indegree[seq.index(b)] += 1\n            elif seq[a] > seq[b]:\n                graph[seq.index(b)].append(seq.index(a))\n                indegree[seq.index(a)] += 1\n\n    queue = deque([i for i in range(len(seq) + 1) if indegree[i] == 0])\n    result = []\n\n    while queue:\n        node = queue.popleft()\n        result.append(node)\n\n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n\n    return len(result) == len(seq) + 1\n\n\ndef main():\n    print(sequenceReconstruction([[1,2],[3,4]], [3,1,4])) # Expected: True\n    print(sequenceReconstruction([[1,3],[5,2],[6,3]], [1,2,3,4,5,6])) # Expected: True\n    print(sequenceReconstruction([[1,2],[1,3]], [0,1,2])) # Expected: False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "445": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef addTwoNumbers(l1, l2):\n    dummyHead = ListNode(0)\n    p = l1\n    q = l2\n    current = dummyHead\n    carry = 0\n    \n    while p or q or carry:\n        if p:\n            carry += p.val\n            p = p.next\n        if q:\n            carry += q.val\n            q = q.next\n        \n        val = carry % 10\n        carry //= 10\n        current.next = ListNode(val)\n        current = current.next\n\n    return dummyHead.next\n\ndef printList(head):\n    while head is not None:\n        print(str(head.val) + \" \", end=\"\")\n        head = head.next\n    print()\n\ndef main():\n    # Test Case 1\n    l1 = ListNode(2)\n    l1.next = ListNode(4)\n    l1.next.next = ListNode(3)\n\n    l2 = ListNode(5)\n    l2.next = ListNode(6)\n    l2.next.next = ListNode(4)\n\n    print(\"Test Case 1: \")\n    result = addTwoNumbers(l1, l2)\n    printList(result)\n    print()\n\n    # Test Case 2\n    l1 = ListNode(0)\n    l2 = ListNode(0)\n\n    print(\"Test Case 2: \")\n    result = addTwoNumbers(l1, l2)\n    printList(result)\n    print()\n\n    # Test Case 3\n    l1 = ListNode(9)\n    l1.next = ListNode(9)\n    l1.next.next = ListNode(9)\n    l1.next.next.next = ListNode(9)\n\n    l2 = ListNode(1)\n\n    print(\"Test Case 3: \")\n    result = addTwoNumbers(l1, l2)\n    printList(result)\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "446": "```\ndef numberOfArithmeticSlices(arr):\n    n = len(arr)\n    dp = [{} for _ in range(n)]\n    res = 0\n    for i in range(n):\n        for j in range(i):\n            diff = arr[i] - arr[j]\n            if diff not in dp[j]:\n                dp[j][diff] = 1\n            else:\n                dp[j][diff] += 1\n            res += dp[j].get(diff, 0)\n    return res\n\ndef main():\n    print(numberOfArithmeticSlices([2,4,7,10,13])) # Expected: 14\n    print(numberOfArithmeticSlices([-1,-3,-5,1,3,5])) # Expected: 6\n    print(numberOfArithmeticSlices([0])) # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "447": "```\ndef numberOfBoomerangs(points):\n    n = len(points)\n    res = 0\n    for x1 in points:\n        distances = {}\n        for x2 in points:\n            if x1 != x2:\n                d = (x2[0] - x1[0]) ** 2 + (x2[1] - x1[1]) ** 2\n                distances[d] = distances.get(d, 0) + 1\n        for dist in distances:\n            res += combinations(distances[dist], 2)\n    return int(res)\n\nimport math\n\ndef combinations(n, k):\n    return math.comb(n, k)\n\ndef main():\n    print(numberOfBoomerangs([[0,0],[1,0],[4,0],[4,2]]) )\n    print(numberOfBoomerangs([[1,1],[2,2],[3,3]]))\n    print(numberOfBoomerangs([[5,10],[8,15],[20,30]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "448": "```\ndef findDisappearedNumbers(nums):\n    return list(set(range(1, len(nums) + 2)) - set(nums))\n\ndef main():\n    print(findDisappearedNumbers([4, 3, 2, 7, 8, 3, 1, 5])) \n    # Output: [6]\n    \n    print(findDisappearedNumbers([1, 1])) \n    # Output: [2, 3, 4]\n\n    print(findDisappearedNumbers([0])) \n    # Output: [1, 2, 3, 4, 5]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "449": "```\nclass Codec:\n    def serialize(self, root):\n        if not root:\n            return \"X,\"\n        return \"{},{},{\".format(root.val, self.serialize(root.left), self.serialize(root.right))\n\n    def deserialize(self, data):\n        nodes = data.split(',')\n        root = self.build_tree(nodes)\n        return root\n\n    def build_tree(self, nodes):\n        if nodes[0] == 'X':\n            nodes.pop(0)\n            return None\n        node = TreeNode(int(nodes.pop(0)))\n        node.left = self.build_tree(nodes)\n        node.right = self.build_tree(nodes)\n        return node\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef main():\n    codec = Codec()\n    \n    root1 = TreeNode(2)\n    root1.left = TreeNode(1)\n    root1.right = TreeNode(3)\n\n    root2 = TreeNode(1)\n    root2.left = TreeNode(0)\n    root2.right = TreeNode(2)\n    root2.right.left = TreeNode(1)\n    root2.right.right = TreeNode(3)\n\n    root3 = TreeNode(4)\n    root3.left = TreeNode(2)\n    root3.right = TreeNode(6)\n    root3.left.left = TreeNode(1)\n    root3.left.right = TreeNode(3)\n    root3.right.left = TreeNode(5)\n    root3.right.right = TreeNode(7)\n\n    \n    serialized_root1 = codec.serialize(root1)\n    print(\"Serialized Root 1: \", serialized_root1)\n    \n    deserialized_root1 = codec.deserialize(serialized_root1.split(','))\n    print(\"Deserialized Root 1:\", end='\\n\\n')\n\n    serialized_root2 = codec.serialize(root2)\n    print(\"Serialized Root 2: \", serialized_root2)\n\n    deserialized_root2 = codec.deserialize(serialized_root2.split(','))\n    print(\"Deserialized Root 2: \", end='\\n\\n')\n\n    serialized_root3 = codec.serialize(root3)\n    print(\"Serialized Root 3: \", serialized_root3)\n    \n    deserialized_root3 = codec.deserialize(serialized_root3.split(','))\n    print(\"Deserialized Root 3:\", end='\\n\\n')\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "450": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def deleteNode(self, root: TreeNode, key: int) -> TreeNode:\n        if not root:\n            return None\n        \n        if root.val < key:\n            root.right = self.deleteNode(root.right, key)\n        elif root.val > key:\n            root.left = self.deleteNode(root.left, key)\n        else:\n            if not root.left and not root.right:\n                return None\n            elif not root.left:\n                return root.right\n            elif not root.right:\n                return root.left\n            else:\n                min_val = self.getMinVal(root.right)\n                root.val = min_val\n                root.right = self.deleteNode(root.right, min_val)\n        return root\n\n    def getMinVal(self, node):\n        current = node\n        while current.left:\n            current = current.left\n        return current.val\n\ndef main():\n    s = Solution()\n    root1 = TreeNode(5)\n    root1.left = TreeNode(3)\n    root1.right = TreeNode(6)\n    root1.left.left = TreeNode(2)\n    root1.left.right = TreeNode(4)\n    root1.right.right = TreeNode(7)\n\n    print(s.deleteNode(root1, 4))\n\n    root2 = TreeNode(5)\n    root2.left = TreeNode(3)\n    root2.right = TreeNode(6)\n\n    print(s.deleteNode(root2, 5))\n\n    root3 = TreeNode(5)\n    root3.left = TreeNode(3)\n    root3.right = TreeNode(6)\n\n    print(s.deleteNode(root3, 6))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "451": "```\ndef frequencySort(s):\n    frequency = {}\n    for char in s:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    sorted_frequency = sorted(frequency.items(), key=lambda x: x[1], reverse=True)\n    result = \"\"\n    for item in sorted_frequency:\n        result += item[0] * item[1]\n    return result\n\ndef main():\n    print(frequencySort(\"tree\")) \n    print(frequencySort(\"cccaaa\")) \n    print(frequencySort(\"Aabb\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "452": "```\ndef findMinArrowLength(points):\n    if not points:\n        return 0\n\n    points.sort()\n\n    arrow_length = 1\n    i = 0\n\n    while i < len(points) - 1:\n        start, end = points[i]\n        next_start, next_end = points[i + 1]\n\n        if next_start > end:\n            arrow_length += 1\n        else:\n            i += 1\n\n    return arrow_length\n\ndef main():\n    print(findMinArrowLength([[10,15],[20,25]])) # Expected output: 2\n    print(findMinArrowLength([[0,4],[5,6],[7,8]])) # Expected output: 3\n    print(findMinArrowLength([])) # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "453": "```\ndef minMoves(arr):\n    n = len(arr)\n    res = 0\n    target = sum(arr) // n\n    for num in arr:\n        res += abs(num - target)\n    return res\n\n\ndef main():\n    print(minMoves([34,23,43,7]))   # Expected output: 39\n    print(minMoves([10,2,8,20,11,4,12,3,21,16]))   # Expected output: 25\n    print(minMoves([1,2,3,4,5,6,7,8,9,10]))   # Expected output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "455": "```\ndef findPairs(g):\n    g.sort()\n    left = 0\n    right = len(g) - 1\n    pairs = 0\n    \n    while left < right:\n        if g[left] + g[right] >= 60:\n            right -= 1\n            pairs += 1\n        else:\n            left += 1\n            \n    return pairs\n\ndef main():\n    test_cases = [\n        ([1,2], 3), \n        ([1,2,3], 2),\n        ([30,31,50], 0)\n    ]\n    \n    for test_case in test_cases:\n        students = test_case[0]\n        expected_pairs = test_case[1]\n        \n        result = findPairs(students)\n        \n        print(f\"Expected: {expected_pairs}, Actual: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "454": "```\ndef fourSumCount(A, B, C, D):\n    count = 0\n    hash_map = {}\n    for i in range(len(A)):\n        for j in range(len(B)):\n            total = A[i] + B[j]\n            if total not in hash_map:\n                hash_map[total] = {C[k]: D[k] for k in range(len(C))}\n            else:\n                hash_map[total][C[k]] = D[k] for k in range(len(C))]\n    for total in hash_map:\n        count += len(hash_map[total])\n    return count\n\ndef main():\n    A1 = [1, 2]\n    B1 = [-2,-3]\n    C1 = [0, 0]\n    D1 = [2,1]\n    print(fourSumCount(A1, B1, C1, D1)) # expected output: 8\n\n    A2 = [0]\n    B2 = [0]\n    C2 = [0]\n    D2 = [0]\n    print(fourSumCount(A2, B2, C2, D2)) # expected output: 1\n\n    A3 = [-1,-1]\n    B3 = [1,1]\n    C3 = [1,1]\n    D3 = [1,1]\n    print(fourSumCount(A3, B3, C3, D3)) # expected output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "456": "```\ndef find132equivalence(nums):\n    if len(nums) < 3:\n        return []\n    low = [0] * len(nums)\n    high = [float('inf')] * len(nums)\n    res = []\n    stack = []\n\n    for i in range(len(nums)):\n        while stack and nums[stack[-1]] < nums[i]:\n            high[stack.pop()] = min(high[stack[-1]], nums[i])\n        if not stack or nums[i] > high[stack[-1]]:\n            stack.append(i)\n        low[i] = (low[i-1] + 1) if i else 0\n    while stack:\n        res.append((nums[stack.pop()], max(nums[:i] for i in range(stack[-1]+1)), nums[-1]))\n    return res\n\ndef main():\n    print(find132equivalence([1,2,3])) # [[1,2,3]]\n    print(find132equivalence([3,4,5,2]) ) # []\n    print(find132equivalence([1,3,5,7,9]) ) # []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "457": "```\ndef findLoop(start):\n    p1 = start\n    p2 = start\n    while True:\n        p1 = (p1 + 1) % len(nums)\n        p2 = (nums[p2] + p2) % len(nums)\n        if p1 == p2:\n            return nums[p1]\n        if p1 >= len(nums):\n            break\n\ndef circularArrayLoop(nums):\n    n = len(nums)\n    for i in range(n):\n        if nums[i] > 0:\n            start = i\n        else:\n            start = i - 1\n        while True:\n            next_index = (start + nums[start]) % n\n            if nums[next_index] * nums[start] < 0:\n                break\n            start = next_index\n        if nums[start] * nums[i] > 0:\n            continue\n        length = start - i\n        p1 = i\n        p2 = (i + length) % n\n        while True:\n            if p1 == p2:\n                return nums[p1]\n            p1 = (p1 + 1) % n\n            p2 = (nums[p2] + p2) % n\n            if p1 == p2:\n                return nums[p1]\n            if p1 >= len(nums):\n                break\n\ndef main():\n    print(circularArrayLoop([2,-1,1,-1,2])) # 3\n    print(circularArrayLoop([-1,-2,-3,-4,-5])) # -1\n    print(circularArrayLoop([1,2,-1,2,2])) # 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "458": "```\ndef poorPigs(b: int, c: int) -> int:\n    max_cycles = -1\n    for i in range(2 ** b):\n        cycles = 0\n        colors = [0] * c\n        for j in range(c):\n            if (i >> j & 1): \n                colors[j] += 1\n        for k in range(c, b + 1):\n            found = False\n            for color in set(colors):\n                remain = k - color\n                if 2 ** remain > c:\n                    continue\n                if 2 ** remain % (c + 1) == 0:\n                    found = True\n                    break\n            if not found: \n                cycles += 1\n        max_cycles = max(max_cycles, cycles)\n    return max_cycles\n\ndef main():\n    print(poorPigs(4, 5)) # Test case 1\n    print(poorPigs(6, 7)) # Test case 2\n    print(poorPigs(10, 15)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "459": "```\ndef findRepeatedStringPatterns(s):\n    n = len(s)\n    patterns = set()\n    for i in range(1, n//2 + 1):\n        if n % i == 0:\n            pattern = s[:i]\n            if pattern * (n // i) == s:\n                patterns.add(pattern)\n    return list(patterns)\n\ndef main():\n    print(findRepeatedStringPatterns(\"abab\"))\n    print(findRepeatedStringPatterns(\"aba\"))\n    print(findRepeatedStringPatterns(\"abcabc\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "461": "```\ndef hammingWeight(n):\n    return bin(n).count('1')\n\ndef main():\n    print(hammingWeight(11)) # Test case 1\n    print(hammingWeight(128)) # Test case 2\n    print(hammingWeight(7)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "460": "```\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.key_to_node = {}\n        self freq_to_node = {}\n        self.head = Node(0, 0)\n        self.tail = self.head\n\n    def get(self, key: int) -> int:\n        if key in self.key_to_node:\n            node = self.key_to_node[key]\n            self._remove(node)\n            self._add(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.key_to_node:\n            self._remove(self.key_to_node[key])\n        node = Node(key, value)\n        self._add(node)\n        self.key_to_node[key] = node\n        if len(self.key_to_node) > self.capacity:\n            node = self.head.next\n            self._remove(node)\n            del self.key_to_node[node.key]\n\n    def _remove(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        if prev_node is not None:\n            prev_node.next = next_node\n        else:\n            self.head = next_node\n        if next_node is not None:\n            next_node.prev = prev_node\n        else:\n            self.tail = prev_node\n\n    def _add(self, node):\n        node.prev = self.tail\n        node.next = self.tail.next\n        self.tail.next = node\n        self.tail = node\n\ndef main():\n    cache1 = LRUCache(2)\n    print(cache1.get(1))  # returns 1\n    cache1.put(1, 1)\n    cache1.put(2, 2)\n    print(cache1.get(1))   # returns 1\n    print(cache1.get(3))   # returns -1 (not found)\n\n    cache2 = LRUCache(3)\n    print(cache2.get(1))  # returns -1 (not found)\n    cache2.put(1, 1)\n    cache2.put(2, 2)\n    cache2.put(3, 3)\n    print(cache2.get(1))   # returns 1\n    print(cache2.get(2))   # returns 2\n    print(cache2.get(3))   # returns 3\n    print(cache2.get(4))   # returns -1 (not found)\n\n    cache3 = LRUCache(0)\n    try:\n        cache3.put(1, 1)\n    except Exception as e:\n        print(e)",
  "462": "```\ndef minMoves2(arr):\n    n = len(arr)\n    arr.sort()\n    mid = arr[n//2]\n    return sum(abs(x - mid) for x in arr)\n\ndef main():\n    print(minMoves2([10,2,7,5,8]) == 1)\n    print(minMoves2([34,23,43,6,55,21,18]) == 9)\n    print(minMoves2([1])) == 0)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "463": "```\ndef islandPerimeter(grid):\n    perimeter = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                if i == 0 or grid[i-1][j] == '0':\n                    perimeter += 1\n                if i == len(grid) - 1 or grid[i+1][j] == '0':\n                    perimeter += 1\n                if j == 0 or grid[i][j-1] == '0':\n                    perimeter += 1\n                if j == len(grid[0]) - 1 or grid[i][j+1] == '0':\n                    perimeter += 1\n    return perimeter\n\ndef main():\n    print(islandPerimeter([[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"0\",\"1\",\"0\",\"0\",\"0\"]])) \n    print(islandPerimeter([[\"1\"],[\"1\"]]))\n    print(islandPerimeter([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "464": "```\ndef canIWin(maxMoves, target):\n    res = [0]\n    for i in range(1 << target):\n        if not any((i >> j) & 1 for j in range(target)):\n            continue\n        v = [0] * target\n        for j in range(target):\n            if (i >> j) & 1:\n                v[j] = 1\n        b, c = False, False\n        m = maxMoves\n        while True:\n            for j in range(target):\n                if not v[j]:\n                    break\n            if j == target:\n                return True\n            r = 0\n            for k in range(j + 1, target):\n                if not v[k]:\n                    r |= 1 << k\n                    break\n            i ^= r\n            while m > 0 and any((i >> j) & 1 for j in range(target)):\n                m -= 1\n                i = (i >> 1)\n            b, c = c, b\n            if i == 0:\n                return False\n    res[0] = 1\n    return res[0]\n\ndef main():\n    test_cases = [(2, 10), (3, 9), (4, 15)]\n    for moves, target in test_cases:\n        print(f\"Can I win with {moves} moves and {target} targets? {canIWin(moves, target)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "465": "```\ndef optimalAccountBalancing(transactions):\n    n = len(transactions)\n    balances = [0] * (1 << n)\n    res = float('inf')\n    \n    for mask in range(1, (1 << n)):\n        balance = 0\n        for i in range(n):\n            if (mask & (1 << i)):\n                balance += transactions[i][0]\n        for j in range(n):\n            if ((mask & (1 << j))):\n                balance -= transactions[j][1]\n        res = min(res, abs(balance))\n        \n    return res\n\ndef main():\n    test_cases = [\n        [[10, 20], [30, 40], [5, 15]], \n        [[1, 2], [3, 4], [5, 6], [7, 8]], \n        [[2, 1], [1, 1]]\n    ]\n    \n    for transactions in test_cases:\n        print(\"Optimal account balancing for transactions {} is {}\".format(transactions, optimalAccountBalancing(transactions)))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "466": "```\ndef minStickers(stickerheets, target):\n    dp = [float('inf')] * (len(target) + 1)\n    dp[0] = 0\n    for sticker in stickerheets:\n        temp_dp = list(dp)\n        for i in range(len(target)):\n            while i + len(sticker) <= len(target) and target[i:i+len(sticker)] == sticker:\n                i += len(sticker)\n        for j in range(len(temp_dp) - 1, -1, -1):\n            if dp[j] != float('inf'):\n                temp_dp[min(j + len(sticker), len(temp_dp) - 1)] = min(temp_dp[min(j + len(sticker), len(temp_dp) - 1)], dp[j] + (dp[j] > 0))\n    return dp[-1]\n\ndef main():\n    print(minStickers([\"shop\", \"tar\", \"car\"], \"shopping\")) # Output: 6\n    print(minStickers([\"to\", \"go\", \"back\", \"stop\", \"carry\"], \"apples\")) # Output: -1\n    print(minStickers([\"shop\", \"tar\", \"car\"], \"cartoons\")) # Output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "467": "```\ndef subarrayRanges(nums):\n    n = len(nums)\n    res = set()\n    for i in range(n):\n        left, right = float('inf'), -float('inf')\n        for j in range(i, n):\n            left = min(left, nums[j])\n            right = max(right, nums[j])\n            if (i > 0 or j < n-1) and len(set(nums[i:j+1])) == 1:\n                res.add(str((left, right)))\n    return list(res)\n\ndef main():\n    print(subarrayRanges([4,2,3,1,3]))\n    print(subarrayRoles([10,2]))\n    print(subarrayRanges([5,7,84]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "468": "```\ndef validIPAddress.IPAddress(IP):\n    if len(IP) > 15:\n        return \"Invalid IP address\"\n    if '.' in IP:\n        for part in IP.split('.'):\n            if not part or any(c not in '0123456789' for c in part):\n                return \"Invalid IP address\"\n            if int(part) > 255:\n                return \"Invalid IP address\"\n            if len(part) > 3:\n                return \"Invalid IP address\"\n    elif ':' in IP:\n        parts = IP.split(':')\n        if len(parts) != 6:\n            return \"Invalid IP address\"\n        for part in parts:\n            if not part or any(c not in '0123456789abcdefABCDEF' for c in part):\n                return \"Invalid IP address\"\n            if len(part) > 4:\n                return \"Invalid IP address\"\n    else:\n        return \"Invalid IP address\"\n\ndef main():\n    test_cases = [\n        {\"input\": \"172.16.254.1\", \"expected_output\": \"Valid\"},\n        {\"input\": \"256.256.256.256\", \"expected_output\": \"Invalid\"},\n        {\"input\": \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"expected_output\": \"Valid\"}\n    ]\n    for test_case in test_cases:\n        IP = test_case[\"input\"]\n        expected_output = test_case[\"expected_output\"]\n        output = \"Valid\" if validIPAddress.IPAddress(IP) == \"Valid IP address\" else \"Invalid\"\n        print(f\"Input: {IP}, Expected Output: {expected_output}, Actual Output: {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "469": "```\ndef orientation(p, q, r):\n    return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\ndef isConvex(polygon):\n    n = len(polygon)\n    for i in range(n):\n        j = (i + 1) % n\n        k = (j + 1) % n\n        if orientation(polygon[i], polygon[j], polygon[k]) <= 0:\n            return False\n    return True\n\ndef main():\n    test_cases = [\n        [[[0, 0], [0, 5], [3, 10], [7, 5]]],\n        [[[0, 0], [1, 2], [4, 2], [4, 3]]],\n        [[[0, 0], [0, 3], [3, 3], [3, 0]]]\n    ]\n\n    for test_case in test_cases:\n        polygon = test_case[0]\n        result = isConvex(polygon)\n        print(f\"Is convex: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "470": "```\nimport random\n\ndef rand7():\n    return random.randint(1, 7)\n\ndef rand10():\n    while True:\n        num = (rand7() - 1) * 5\n        r = rand7()\n        if r <= 3:\n            return num + 1\n        elif r == 4:\n            return num + 7\n\ndef main():\n    print(\"Test case 1:\", rand10())\n    print(\"Test case 2:\", rand10())\n    print(\"Test case 3:\", rand10())\n\nif __name__ == \"__main__\":\n    main()\n```",
  "471": "```\ndef shortestToChar(s, c):\n    n = len(s)\n    result = [n]*n\n    for i in range(n):\n        if s[i] == c:\n            result[i] = 0\n        elif i < n-1 and s[i+1] == c:\n            result[i] = 1\n        else:\n            left, right = 0, 0\n            while i-left > 0 and s[i-left] != c:\n                left += 1\n            while i+right < n-1 and s[i+right] != c:\n                right += 1\n            result[i] = min(left, right)\n    return result\n\ndef main():\n    test_cases = [\n        {\"s\": \"love\", \"c\": \"l\", \"expected_result\": [3, 2, 1, 0]},\n        {\"s\": \"a\", \"c\": \"a\", \"expected_result\": [0]},\n        {\"s\": \"aab\", \"c\": \"b\", \"expected_result\": [1, 1, 0]}\n    ]\n\n    for test_case in test_cases:\n        s = test_case[\"s\"]\n        c = test_case[\"c\"]\n        expected_result = test_case[\"expected_result\"]\n\n        result = shortestToChar(s, c)\n        print(f\"Test case: {s}, {c}\")\n        print(f\"Expected result: {expected_result}\")\n        print(f\"Actual result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "472": "```\ndef findAllConcatenatedWordsInDict(words):\n    word_set = set(words)\n    res = []\n    for word in words:\n        if dfs(word_set, \"\", word):\n            res.append(word)\n    return res\n\ndef dfs(word_set, prefix, word):\n    if not word:\n        return True\n    if word.startswith(prefix + word[0]):\n        new_prefix = prefix + word[0]\n        if len(new_prefix) == len(word) and new_prefix in word_set:\n            return True\n    return False\n\ndef main():\n    words = [\"cat\",\"bt\",\"hat\",\"tree\"]\n    print(findAllConcatenatedWordsInDict(words))\n    \n    words = [\"kty\"]\n    print(findAllConcatenatedWordsInDict(words))\n    \n    words = [\"abcd\",\"cdabcd\",\"dcccdabc\"]\n    print(findAllConcatenatedWordsInDict(words))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "473": "```\ndef makesquare(s):\n    s //= len(s)\n    sticks = [0] * 4\n    for i in range(len(s)):\n        for j in group:\n            if (s & (1 << i)) and (sticks[j] + s[i] <= 1000):\n                sticks[j] += s[i]\n                break\n    return all(i == 1000 for i in sticks)\n\ndef main():\n    test_cases = [\n        {\"stick_length\": [5,3,4,2], \"expected_result\": True},\n        {\"stick_length\": [1,1,2,2,3,3,4,4,5], \"expected_result\": True},\n        {\"stick_length\": [10,12,8,2,6,18,20,15,22,16], \"expected_result\": False}\n    ]\n\n    for test_case in test_cases:\n        result = makesquare(test_case[\"stick_length\"])\n        if result == test_case[\"expected_result\"]:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "474": "```\ndef onesAndZeroes(nums):\n    m = len(nums)\n    n = sum(len(num) for num in nums[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        if i == 0:\n            dp[i][0] = 1\n        else:\n            totalOnes = sum(num.count('1') for num in nums[:i])\n            dp[i][0] = dp[i-1][0] or (totalOnes > i)\n    \n    for j in range(n + 1):\n        if j == 0:\n            dp[0][j] = 1\n        else:\n            for i in range(m + 1):\n                if i == 0:\n                    continue\n                elif j < n and nums[i-1].count('1') > 0:\n                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] | (nums[i-1].count('1') <= j))\n                else:\n                    dp[i][j] = dp[i-1][j]\n    \n    return dp[m][n]\n\ndef main():\n    print(onesAndZeroes([[\"0000\",\"0110\"],[\"0011\",\"0001\"],[\"0101\",\"0011\"],[\"0122\",\"0110\"]]))\n    print(onesAndZeroes([[\"100\", \"00\"]]))\n    print(onesAndZeroes([]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "475": "```\ndef findRadius(houses, heaters):\n    houses.sort()\n    heaters.sort()\n    result = []\n    \n    i = j = 0\n    while i < len(houses) or j < len(heaters)-1:\n        if i == len(houses):\n            result.append(abs(houses[i-1] - heaters[j]))\n        elif j == len(heaters)-1:\n            result.append(abs(houses[i] - heaters[j-1]))\n        else:\n            if houses[i] <= heaters[j]:\n                result.append(abs(houses[i] - heaters[j]))\n                i += 1\n            else:\n                result.append(min(abs(houses[i] - heaters[j]), abs(houses[i-1] - heaters[j])))\n                j += 1\n\n    return max(result)\n\ndef main():\n    print(findRadius([1,2,3,4,5], [0,1,2])) # Expected: 1\n    print(findRadius([104,101,102,101,103], [-99,-98,-97,-96,-95]) )# Expected: 4\n    print(findRadius([10, 6, 7, 9, 5], [5, 7, 8]) ) # Expected: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "476": "```\ndef findComplement(num):\n    return ~num\n\ndef main():\n    print(findComplement(5)) # Test case 1\n    print(findComplement(10)) # Test case 2\n    print(findComplement(256)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "477": "```\ndef totalHammingDistance(nums):\n    res = 0\n    for i in range(30):\n        bitCount = (nums >> i) & 1\n        res += bitCount * (bitCount - 1)\n    return res\n\ndef main():\n    print(totalHammingDistance([4,14,2])) \n    print(totalHammingDistance([4,3]))\n    print(totalHammingDistance([2,2]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "478": "```\nimport random\nimport math\n\nclass Solution:\n    def randPoint(self, n: int) -> List[float]:\n        r = math.sqrt(6.0 / n)\n        x = random.uniform(-r, r)\n        y = math.sqrt(1.0 - (x**2)/6.0)\n        if random.random() < 0.5:\n            y *= -1\n        return [x, y]\n\ndef main():\n    solution = Solution()\n    \n    print(\"Test case 1:\")\n    for _ in range(10):\n        print(solution.randPoint(3))\n    print(\"\\n\")\n    \n    print(\"Test case 2:\")\n    for _ in range(5):\n        print(solution.randPoint(100))\n    print(\"\\n\")\n    \n    print(\"Test case 3:\")\n    for _ in range(20):\n        print(solution.randPoint(50))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "479": "```\ndef largest_palindrome_product():\n    max_pal = 0\n    for i in range(100, 999):\n        for j in range(i, 999):\n            num = i * j\n            if str(num) == str(num)[::-1] and num > max_pal:\n                max_pal = num\n    return max_pal\n\ndef main():\n    print(\"Largest Palindrome Product:\", largest_palindrome_product())\n    test_cases = [\n        {\"input\": 10, \"expected_output\": 910000},\n        {\"input\": 2, \"expected_output\": 9000000},\n        {\"input\": 1, \"expected_output\": 1}\n    ]\n    for test_case in test_cases:\n        result = largest_palindrome_product()\n        if result == test_case[\"expected_output\"]:\n            print(f\"Test case {test_case['input']} passed.\")\n        else:\n            print(f\"Test case {test_case['input']} failed. Expected {test_case['expected_output']}, but got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "480": "```\ndef medianSlidingWindow(nums):\n    if not nums:\n        return []\n    n = len(nums)\n    res = []\n    for i in range(n - 1):\n        left, right = [], []\n        for j in range(i + 1):\n            left.append((nums[j], 'L'))\n        for k in range(i, n):\n            right.append((nums[k], 'R'))\n        left.sort()\n        right.sort(reverse=True)\n        mid = (i + i + 1) // 2\n        if len(left) > len(right):\n            res.append(left[mid][0])\n        elif len(left) < len(right):\n            res.append(right[mid][0])\n        else:\n            res.append((left[mid][0] + right[mid][0]) / 2)\n    return res\n\ndef main():\n    print(medianSlidingWindow([1,3,-1,-1,5,ACCORDING TO THE RULE OF SLIDING WINDOW WE CAN GET THE MEDIAN BY FINDING THE AVERAGE VALUE OF THE TWO NUMBER IN THE MIDDLE IF THEY ARE EVEN AND TAKE THE ONE WHICH IS GREATER IF THEY ARE ODD]))\n    print(medianSlidingWindow([0,0]))\n    print(medianSlidingWindow([1]))\n\nmain()\n```",
  "481": "```\ndef magicalString(n):\n    if n <= 0:\n        return \"\"\n    \n    string = [1]\n    used = [False for _ in range(n + 1)]\n    i, j = 0, 1\n    while len(string) < n:\n        while j < n and not used[j]:\n            used[j] = True\n            if (j % 2):\n                string.append(5 - string[i])\n            else:\n                string.append(6)\n            i += 1\n            j += 1\n    return \"\".join(map(str, string[:n]))\n\ndef main():\n    print(magicalString(6)) # \"123165\"\n    print(magicalString(15)) # \"653523016235622415\"\n    print(magicalString(3)) # \"219\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "482": "```\ndef licenseKeyFormatting(s, k):\n    s = s.upper().replace('-', '')\n    result = ''\n    temp = ''\n    for char in s:\n        temp += char\n        if len(temp) == k:\n            result += temp + '-'\n            temp = ''\n    return result[:-1] if temp else result\n\ndef main():\n    test_cases = [\n        (\"5F4Z-2X3V\", 4),\n        (\"2-5A0-\", 2),\n        (\"a-Problems---Appear-After-Reinstalling--X-5Q-01-8R-0D-KP-AI-EW-C7-1F-J4-6G-HL-9M-OE\", 3)\n    ]\n\n    for s, k in test_cases:\n        print(f\"Input: {s}, K: {k}\")\n        print(f\"Output: {licenseKeyFormatting(s, k)}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "483": "```\ndef superPow(base, modN):\n    ans = 1\n    for d in str(base % int('1' + '0' * (modN.bit_length() - 1))):\n        ans = pow(ans, 10, modN) * (int(d) if d != '0' else 1) % modN\n    return ans\n\ndef smallestGoodBase(N):\n    for base in range(2, N + 1):\n        if all((base ** i) % N == i % N for i in range(1, N.bit_length() + 1)):\n            return base\n\ndef main():\n    test_cases = [(17, 23), (19, 137), (13, 25)]\n    for n, result in test_cases:\n        print(f\"Smallest good base for {n} is {smallestGoodBase(n)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "484": "```\ndef nextBeautifulString(n):\n    s = '0123456789abcdef'\n    res = ''\n    while n:\n        for i in range(1, 17):\n            if n >= i:\n                res += s[i-1]\n                n -= i\n                break\n    return res.zfill(len(str(n)) or len(res))\n\ndef main():\n    test_cases = [27, 56, 15]\n    for test_case in test_cases:\n        print(f\"Test case {test_case}: {nextBeautifulString(test_case)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "485": "```\ndef findMaxConsecutiveOnes(nums):\n    if not nums:\n        return 0\n    \n    max_count = current_count = 0\n    for num in nums:\n        if num == 1:\n            current_count += 1\n        else:\n            max_count = max(max_count, current_count)\n            current_count = 0\n    return max(max_count, current_count)\n\ndef main():\n    print(findMaxConsecutiveOnes([1,1,0,1,1,1])) # Expected output: 3\n    print(findMaxConsecutiveOnes([0,1,0,1,0,1])) # Expected output: 2\n    print(findMaxConsecutiveOnes([1,1,1,1,1])) # Expected output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "486": "```\ndef PredictTheWinner(costs):\n    n = len(costs)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = sum(costs[i - 1])\n        for j in range(i):\n            dp[j][i] = max(costs[i - 1] - dp[0][j], costs[i - 1] + dp[j][i - 1])\n\n    return dp[0][n]\n\ndef main():\n    test_cases = [\n        {\"costs\": [1, 3, 1], \"expected_result\": 2},\n        {\"costs\": [6, 6], \"expected_result\": 7},\n        {\"costs\": [5, 4, 2], \"expected_result\": 8}\n    ]\n\n    for test_case in test_cases:\n        result = PredictTheWinner(test_case[\"costs\"])\n        if result == test_case[\"expected_result\"]:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed. Expected {test_case['expected_result']} but got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "487": "```\ndef findMaxConsecutive Ones(nums):\n    ones_count = sum(1 for num in nums if num)\n    max_ones = 0\n    left = 0\n    right = 0\n    \n    while right < len(nums):\n        max_ones = max(max_ones, (right - left + 1) * ones_count // len(nums))\n        \n        if right >= len(nums) - ones_count:\n            break\n        \n        if nums[right] == 1:\n            ones_count -= 1\n            right += 1\n        else:\n            if left < right and nums[left] == 0:\n                left += 1\n            else:\n                ones_count += nums[left] - (nums[left] - 1)\n                left += 1\n    return max_ones\n\ndef main():\n    print(\"Test Case 1: \")\n    nums = [1,0,1,1,0,0]\n    print(findMaxConsecutiveOnes(nums))\n    \n    print(\"\\nTest Case 2: \")\n    nums = [0,1]\n    print(findMaxConsecutiveOnes(nums))\n    \n    print(\"\\nTest Case 3: \")\n    nums = [0,0,1,1]\n    print(findMaxConsecutiveOnes(nums))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "489": "```\nclass Solution:\n    def cleanRoom(self, robot):\n        # Your implementation here\n\ndef main():\n    s = Solution()\n    \n    print(\"Test Case 1: \")\n    s.cleanRoom([(0,0), (1,0), (2,0), (3,0)])\n    \n    print(\"\\nTest Case 2: \")\n    s.cleanRoom([(0,0), (1,1), (2,1)])\n    \n    print(\"\\nTest Case 3: \")\n    s.cleanRoom([(0,0)])\n\nif __name__ == \"__main__\":\n    main()\n```",
  "488": "```\ndef getDiscsOrder(discs):\n    stack = []\n    order = []\n    \n    for i in range(len(discs) - 1, -1, -1):\n        while len(stack) > 0 and stack[-1] < discs[i]:\n            order.append(stack.pop())\n        stack.append(discs[i])\n            \n    while len(stack) > 0:\n        order.append(stack.pop())\n        \n    return order[::-1]\n\ndef numWaysToWin(board, word):\n    if not board or not word:\n        return 0\n    \n    m, n = len(board), len(word[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = 1\n    for j in range(n + 1):\n        dp[0][j] = 1\n        \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if board[i - 1][j - 1] == word[j - 1]:\n                dp[i][j] = (dp[i - 1][j] or dp[i][j - 1]) and 1\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n                \n    return dp[m][n]\n\ndef numMovesToArrive(board, source, destination):\n    if not board or not source or not destination:\n        return float('inf')\n    \n    m, n = len(board), len(source)\n    visited = [[False for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    q = [(0, 0, 0)]\n    visited[0][0] = True\n    \n    while q:\n        x, y, step = q.pop(0)\n        \n        if (x, y) == destination:\n            return step\n        \n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            \n            if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:\n                q.append((nx, ny, step + 1))\n                visited[nx][ny] = True\n                \n    return float('inf')\n\ndef zumaGame(board, word):\n    if not board or not word:\n        return []\n    \n    order = getDiscsOrder(word)\n    \n    num_ways_to_win = numWaysToWin(board, order)\n    moves_to_arrive = numMovesToArrive(board, source=(0, 0), destination=(len(board) - 1, len(order[0]) - 1))\n    \n    return [num_ways_to_win, moves_to_arrive]\n\ndef main():\n    print(zumaGame([[\"A\",\"B\",\"C\",\"D\"],[\"S\",\"D\",\"E\",\"F\"],[\"G\",\"H\",\"I\",\"J\"],[\"K\",\"L\",\"M\",\"N\"]],\"AAD\") )\n    print(zumaGame([[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"]],\"7777\") )\n    print(zumaGame([[\"H\",\"A\",\"J\",\"I\",\"K\"],[\"M\",\"N\",\"C\",\"B\",\"A\"],[\"E\",\"D\",\"G\",\"F\",\"H\"],[\"S\",\"T\",\"R\",\"Q\",\"P\"],[\"O\",\"X\",\"Y\",\"Z\",\"W\"]],\"ABCDEF\") )\n\nif __name__ == \"__main__\":\n    main()\n```",
  "491": "```\ndef findSubstring(s: str) -> List[List[int]]:\n    if not s:\n        return []\n\n    res = []\n    for i in range(len(s)):\n        seen = {}\n        temp = []\n        for j in range(i, len(s)):\n            val = ord(s[j]) - ord('a')\n            if val not in seen or seen[val] == j - i:\n                seen[val] = j\n                temp.append(j)\n            else:\n                break\n        if len(temp) > 0 and (i == 0 or seen[ord(s[i-1])-ord('a')] < i):\n            res.extend([[k-i for k in temp]])\n\n    return res\n\n\ndef main():\n    print(findSubstring(\"abc\"))\n    print(findSubstring(\"abcab\"))\n    print(findSubstring(\"aba\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "490": "```\ndef hasPath(grid, row, col):\n    if grid[row][col] == 'O':\n        grid[row][col] = '#'\n        directions = [(0,1),(0,-1),(1,0),(-1,0)]\n        for dx,dy in directions:\n            new_row, new_col = row+dx, col+dy\n            if 0 <= new_row < len(grid) and 0 <= new_col < len(grid[0]):\n                if grid[new_row][new_col] == 'O':\n                    if hasPath(grid, new_row, new_col):\n                        return True\n    return False\n\ndef hasPathExists(maze):\n    for i in range(len(maze)):\n        for j in range(len(maze[i])):\n            if maze[i][j] == 'S':\n                return hasPath(maze, i, j)\n    return False\n\ndef main():\n    # Test case 1\n    maze1 = [[\"a\",\"a\",\"a\"],[\"s\",\"b\",\"b\"],[\"a\",\"c\",\"a\"]]\n    print(hasPathExists(maze1)) # Expected output: True\n\n    # Test case 2\n    maze2 = [[\"a\",\"a\",\"a\"],[\"s\",\"b\",\"d\"],[\"a\",\"c\",\"a\"]]\n    print(hasPathExists(maze2)) # Expected output: False\n\n    # Test case 3\n    maze3 = [[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"],\n             [\"a\",\"s\",\"b\",\"b\",\"b\",\"b\",\"b\",\"a\"],\n             [\"a\",\"a\",\"c\",\"c\",\"c\",\"c\",\"a\",\"a\"],\n             [\"a\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"a\"],\n             [\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"a\"],\n             [\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"a\"],\n             [\"x\",\"y\",\"z\",\"b\",\"c\",\"d\",\"e\",\"a\"],\n             [\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"a\"]]\n    print(hasPathExists(maze3)) # Expected output: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "492": "```\ndef area(width):\n    return width * 2**0.5\n\ndef integerLength(num):\n    length = 0\n    while num > 0:\n        num //= 10\n        length += 1\n    return length\n\ndef constructRectangle(area):\n    w = int(2**0.5 * area)\n    l = integerLength(w)\n    if w * l != area:\n        return [l, w]\n    else:\n        return [w, l]\n\ndef main():\n    print(\"Test case 1:\")\n    print(f\"Input: {12}, Expected output: {constructRectangle(12)}\")\n    \n    print(\"\\nTest case 2:\")\n    print(f\"Input: {5}, Expected output: {constructRectangle(5)}\")\n\n    print(\"\\nTest case 3:\")\n    print(f\"Input: {4}, Expected output: {constructRectangle(4)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "493": "```\ndef merge(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n    merged = [intervals[0]]\n    \n    for current in intervals:\n        last = merged[-1]\n        if current[0] <= last[1]:\n            merged[-1] = [last[0], max(last[1], current[1])]\n        else:\n            merged.append(current)\n\n    return merged\n\ndef reverse_pairs(nums):\n    res = []\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] > nums[j]:\n                res.append((nums[i], nums[j]))\n    return res\n\ndef main():\n    print(reverse_pairs([1, 3])) # [[1,1]]\n    print(reverse_pairs([2, 11, 15])) # [[2,2],[2,4],[10,11],[11,11],[11,15],[15,15]]\n    print(reverse_pairs([6, 9])) # [[6,6]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "494": "```\ndef findTargetSumWays(nums, target):\n    def backtrack(start, curr_sum):\n        if start == len(nums):\n            return 1 if curr_sum == target else 0\n        pick = backtrack(start + 1, curr_sum + nums[start])\n        not_pick = backtrack(start + 1, curr_sum - nums[start])\n        return pick + not_pick\n\n    return backtrack(0, 0)\n\n\ndef main():\n    print(findTargetSumWays([1,1,-2,1],-2)) # Expected: 2\n    print(findTargetSumWays([0,0,0,0,0,0,0,0,0,0,0,0,0,0],10)) # Expected: 149\n    print(findTargetSumWays([-3, -5,-1,-22,_-6,1,-11,6],7) )# Expected: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "495": "```\ndef findPoisonedDuration(timePoints):\n    if not timePoints:\n        return 0\n    timePoints.sort()\n    total = timePoints[0]\n    for i in range(1, len(timePoints)):\n        if timePoints[i] > timePoints[i-1] + 60:\n            total += timePoints[i] - timePoints[i-1]\n        else:\n            total += 60\n    return total + 60\n\ndef main():\n    print(findPoisonedDuration([1,2])) # Expected output: 4\n    print(findPoisonedDuration([0,1,5,20])) # Expected output: 11\n    print(findPoisonedDuration([])) # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "496": "```\ndef nextGreaterElement(nums):\n    result = [-1] * len(nums)\n    stack = []\n    \n    for i in range(len(nums) - 1, -1, -1):\n        while stack and nums[stack[-1]] <= nums[i]:\n            stack.pop()\n        if stack:\n            result[i] = nums[stack[-1]]\n        stack.append(i)\n            \n    return result\n\n\ndef main():\n    print(nextGreaterElement([4,2,3,2,3,1,2,3]))\n    print(nextGreaterElement([1,2,3,4]))\n    print(nextGreaterElement([1,2]))\n\nmain()\n```",
  "497": "```\nimport random\n\nclass Solution:\n    def __init__(self):\n        self.prefix_sum = [0]\n\n    def pick(self, rects):\n        n = len(rects)\n        for x2, y2 in rects:\n            self.prefix_sum.append(self.prefix_sum[-1] + (x2 - rect[0]) * (y2 - rect[1]))\n        return random.randint(1, self.prefix_sum[-1])\n\ndef main():\n    s = Solution()\n    test_cases = [\n        [[1,3],[3,1]],\n        [[10,5,11,6],[6,7,8,9],[4,8,13,9],[2,5,3,6]],\n        [[0,0,1,1]]\n    ]\n\n    for rects in test_cases:\n        print(f\"Rectangles: {rects}\")\n        print(f\"Random Point: {s.pick(rects)}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "498": "```\ndef findDiagonalOrder(matrix):\n    if not matrix:\n        return []\n\n    m, n = len(matrix), len(matrix[0])\n    result = []\n    diagonal_dict = {}\n\n    for i in range(m):\n        for j in range(n):\n            if i + j not in diagonal_dict:\n                diagonal_dict[i + j] = [(i, j)]\n            else:\n                diagonal_dict[i + j].append((i, j))\n\n    for k in sorted(diagonal_dict.keys()):\n        temp = []\n        reverse = (k % 2 != 0)\n        for pair in diagonal_dict[k]:\n            if reverse:\n                result.append(matrix[pair[0]][pair[1]])\n            else:\n                result.append(matrix[pair[0]][pair[1]][::-1])\n    return result\n\n\ndef main():\n    print(findDiagonalOrder([[1,2,3],[4,5,6],[7,8,9]]))\n    print(findDiagonalOrder([[1, 2], [3, 4]]))\n    print(findDiagonalOrder([]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "500": "```\ndef findWords(words):\n    rows = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']\n    res = []\n    for word in words:\n        row_index = None\n        for i, row in enumerate(rows):\n            if all(c.lower() in row for c in word):\n                row_index = i\n                break\n        if row_index is not None:\n            res.append(word)\n    return res\n\ndef main():\n    test_cases = [\n        {\"words\": [\"Hello\", \"Alaska\", \"Dad\"], \"expected_output\": [\"Alaska\"]},\n        {\"words\": [\"Apple\", \"Teale\", \"Eagle\"], \"expected_output\": [\"Apple\", \"Eagle\"]},\n        {\"words\": [\"omg\"], \"expected_output\": []}\n    ]\n\n    for test_case in test_cases:\n        output = findWords(test_case[\"words\"])\n        if output == test_case[\"expected_output\"]:\n            print(f\"Test case passed: {test_case['words']} -> {output}\")\n        else:\n            print(f\"Test case failed: {test_case['words']} -> expected {test_case['expected_output']}, got {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "499": "```\ndef shortestDistance(maze):\n    if not maze:\n        return -1\n\n    rows, cols = len(maze), len(maze[0])\n    queue = [(0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = [[False] * cols for _ in range(rows)]\n\n    while queue:\n        x, y = queue.pop(0)\n        if maze[x][y] == 1:\n            continue\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (0 <= nx < rows) and (0 <= ny < cols) and not visited[nx][ny]:\n                queue.append((nx, ny))\n                visited[nx][ny] = True\n\n    for i in range(rows):\n        for j in range(cols):\n            if maze[i][j] == 1:\n                return abs(i - rows // 2) + abs(j - cols // 2)\n\n    return -1\n\n\ndef main():\n    test_cases = [\n        # Test case 1\n        {\n            \"maze\": [[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,1,0,0,0],[0,1,0,0,0]],\n            \"expected_result\": 6,\n        },\n        # Test case 2\n        {\n            \"maze\": [[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,1,0,0],[0,0,1,0,0]],\n            \"expected_result\": 4,\n        },\n        # Test case 3\n        {\n            \"maze\": [[0,0,0,0,0],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0]],\n            \"expected_result\": -1,\n        },\n    ]\n\n    for test_case in test_cases:\n        maze = test_case[\"maze\"]\n        expected_result = test_case[\"expected_result\"]\n\n        result = shortestDistance(maze)\n        if result == expected_result:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "502": "```\ndef maxIncreaseKeepingSum(m):\n    h = [0] * len(m)\n    for i in range(len(m)):\n        for j in range(i+1, len(m[i])):\n            h[j] = max(h[j], m[i][j])\n    total_sum = sum(sum(row) for row in m)\n    for i in range(len(m)):\n        total_sum -= sum(row)\n        for j in range(len(m[i])):\n            total_sum += min(h[j], m[i][j])\n    return total_sum\n\ndef main():\n    print(maxIncreaseKeepingSum([[0, 2], [5, 3]])) # expected output: 4\n    print(maxIncreaseKeepingSum([[5, 3], [2, 1]])) # expected output: 6\n    print(maxIncreaseKeepingSum([[1, 3, 5], [2, 4, 7], [10, 11, 12]])) # expected output: 24\n\nif __name__ == \"__main__\":\n    main()\n```",
  "501": "```\nclass Solution:\n    def findMode(self, root):\n        max_freq = 0\n        mode_val = None\n        freq_map = {}\n        \n        def dfs(node):\n            nonlocal max_freq, mode_val\n            if node:\n                if node.val in freq_map:\n                    freq_map[node.val] += 1\n                else:\n                    freq_map[node.val] = 1\n                if freq_map[node.val] > max_freq:\n                    max_freq = freq_map[node.val]\n                    mode_val = node.val\n                \n                dfs(node.left)\n                dfs(node.right)\n\n        dfs(root)\n        return [mode_val] * max_freq\n\n\ndef main():\n    solution = Solution()\n    \n    root1 = TreeNode(7)\n    root1.left = TreeNode(3)\n    root1.right = TreeNode(15)\n    root1.left.left = TreeNode(2)\n    root1.left.right = TreeNode(4)\n    root1.right.left = TreeNode(10)\n    root1.right.right = TreeNode(20)\n    \n    print(solution.findMode(root1))  # [3]\n\n    root2 = TreeNode(7)\n    root2.left = TreeNode(3)\n    root2.right = TreeNode(3)\n    root2.left.left = TreeNode(2)\n\n    print(solution.findMode(root2))  # [3]\n\n    root3 = TreeNode(10)\n    root3.left = TreeNode(5)\n    root3.right = TreeNode(15)\n    root3.left.left = TreeNode(1)\n\n    print(solution.findMode(root3))  # [10]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "503": "```\ndef nextGreaterElements(nums):\n    n = len(nums)\n    res = [-1] * n\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[j] > nums[i]:\n                res[i] = nums[j]\n                break\n    for i in range(n):\n        for j in range(i+1, n):\n            if nums[n-j-1] > nums[i]:\n                res[i] = nums[n-j-1]\n                break\n    return res\n\ndef main():\n    print(nextGreaterElements([1, 2, 3, 2, 4])) # [1, 3, 3, 4, -1]\n    print(nextGreaterElements([1, 2, 3])) # [2, 3, -1]\n    print(nextGreaterElements([1, 2])) # [2, -1]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "504": "```\ndef convertToBase7(n):\n    if n == 0:\n        return \"0\"\n    \n    negative = False\n    if n < 0:\n        n = -n\n        negative = True\n    \n    result = []\n    while n > 0:\n        remainder = n % 7\n        result.append(str(remainder))\n        n //= 7\n    \n    if negative:\n        return \"-\" + \"\".join(result[::-1])\n    \n    return \"\".join(result[::-1])\n\ndef main():\n    print(convertToBase7(100)) # \"202\"\n    print(convertToBase7(-7))   # \"-10\"\n    print(convertToBase7(0))     # \"0\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "506": "```\ndef findRelativeRanks(score):\n    score_dict = {i+1: s for i, s in sorted((s, i) for i, s in enumerate(reversed(sorted(score)), 1))}\n    return [score_dict[i+1] if (i+1) in score_dict else str(i+1) for i in range(len(score))]\n\ndef main():\n    print(findRelativeRanks([5,4,8,2,3,6,1])) # Example 1: Output: [\"3\",\"2\",\"6\",\"1\"]\n    print(findRelativeRanks([10,9,8,7,6,5,4,3,2,1])) # Example 2: Output: [\"5\",\"4\",\"3\",\"2\",\"1\",\"0\",\"0\",\"0\",\"0\",\"0\"]\n    print(findRelativeRanks([1,2,3,4,5,6,7,8,9,10])) # Example 3: Output: [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\"]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "505": "```\ndef shortestWallTime(walls):\n    from collections import deque\n\n    rows, cols = len(walls), len(walls[0])\n    visited = [[False]*cols for _ in range(rows)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = deque([(0, 0, 0)])\n\n    while queue:\n        x, y, time = queue.popleft()\n        if visited[x][y]:\n            continue\n        visited[x][y] = True\n\n        for dx, dy in directions:\n            nx, ny = x+dx, y+dy\n            if (0 <= nx < rows) and (0 <= ny < cols):\n                if walls[nx][ny] == 0:\n                    queue.append((nx, ny, time + 1))\n                elif walls[nx][ny] > 0:\n                    return time\n\n    return -1\n\n\ndef main():\n    print(shortestWallTime([[0,1,1,0],[0,1,1,0],[0,0,1,0]]))  # Output: 16\n    print(shortestWallTime([[0,1,0,0,0,0],[0,1,0,0,1,0],[0,1,0,0,1,0]]))  # Output: 3\n    print(shortestWallTime([[0,1,0,0,0,0,0,0,0],[0,1,0,0,1,0,0,1,0],[0,1,0,0,1,0,0,1,0]]))  # Output: 6\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "507": "```\ndef isPerfectNumber(n):\n    if n <= 0:\n        return False\n    sum = 1\n    for i in range(2, n):\n        if i * i > n:\n            break\n        if n % i == 0:\n            while n % i == 0:\n                n //= i\n                sum += i\n    return n > 0 and sum == n\n\ndef main():\n    print(\"Test case 1: \", isPerfectNumber(6)) # Expected: True\n    print(\"Test case 2: \", isPerfectNumber(28)) # Expected: True\n    print(\"Test case 3: \", isPerfectNumber(12)) # Expected: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "508": "```\ndef maxFrequency(root):\n    res = {}\n    def dfs(node):\n        if not node:\n            return 0\n        s = dfs(node.left) + dfs(node.right) + node.val\n        res[s] = res.get(s, 0) + 1\n        return s\n    dfs(root)\n    return max(res.items(), key=lambda x: (x[1], -x[0]))[0]\n\ndef main():\n    # Test case 1\n    root1 = TreeNode(5)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(-3)\n    print(maxFrequency(root1))  # Output: 2\n\n    # Test case 2\n    root2 = TreeNode(5)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(2)\n    print(maxFrequency(root2))  # Output: 4\n\n    # Test case 3\n    root3 = TreeNode(-1)\n    root3.left = TreeNode(0)\n    root3.right = TreeNode(1)\n    print(maxFrequency(root3))  # Output: -1\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "509": "```\ndef fib(n):\n    if n <= 1:\n        return n\n    memo = {0: 0, 1: 1}\n    for i in range(2, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2]\n    return memo[n]\n\ndef main():\n    print(fib(2))   # Test case 1\n    print(fib(7))   # Test case 2\n    print(fib(13))  # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "511": "```\ndef select_galaxies(game_id):\n    sql = \"SELECT galaxy FROM Game WHERE id = %s\"\n    cur.execute(sql, (game_id,))\n    return [row[0] for row in cur.fetchall()]\n\nimport sqlite3\nconn = sqlite3.connect(':memory:')\ncur = conn.cursor()\ncur.executescript('''\nCREATE TABLE Game (\n  id INTEGER PRIMARY KEY,\n  galaxy TEXT NOT NULL\n);\n''')\n\ndef main():\n    game_ids = [1, 2, 3]\n    for game_id in game_ids:\n        galaxies = select_galaxies(game_id)\n        print(f\"Game {game_id} galaxies: {galaxies}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "510": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef inorderSuccessor(root, val):\n    res = []\n    stack = []\n\n    while root or stack:\n        while root:\n            stack.append(root)\n            root = root.left\n        root = stack.pop()\n        if not root or root.val <= val:\n            root = None\n        else:\n            res = [root]\n            break\n\n    return res[0] if res else None\n\ndef main():\n    # Test case 1\n    node5 = TreeNode(5)\n    node3 = TreeNode(3)\n    node2 = TreeNode(2)\n    node4 = TreeNode(4)\n    node6 = TreeNode(6)\n    node7 = TreeNode(7)\n\n    node3.left = node2\n    node3.right = node4\n    node2.left = None\n    node2.right = None\n    node4.left = node6\n    node4.right = node7\n\n    print(inorderSuccessor(node3, 5))  # Expected: TreeNode(6)\n\n    # Test case 2\n    node10 = TreeNode(10)\n    node8 = TreeNode(8)\n    node9 = TreeNode(9)\n    node15 = TreeNode(15)\n    node14 = TreeNode(14)\n    node12 = TreeNode(12)\n    node13 = TreeNode(13)\n\n    node10.left = node8\n    node10.right = node15\n    node8.left = node9\n    node8.right = node12\n    node9.left = None\n    node9.right = None\n    node12.left = node13\n    node12.right = node14\n\n    print(inorderSuccessor(node10, 12))  # Expected: TreeNode(13)\n\n    # Test case 3\n    node5 = TreeNode(5)\n    node3 = TreeNode(3)\n    node2 = TreeNode(2)\n    node4 = TreeNode(4)\n    node6 = TreeNode(6)\n\n    node3.left = node2\n    node3.right = node4\n    node2.left = None\n    node2.right = None\n    node4.left = node6\n\n    print(inorderSuccessor(node3, 5))  # Expected: None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "512": "```\ndef calculateHiscores(player_id):\n    # implement your solution here\n    pass\n\ndef main():\n    print(\"Test case 1:\")\n    print(calculateHiscores(1))  # expected output: 2\n    print()\n\n    print(\"Test case 2:\")\n    print(calculateHiscores(2))  # expected output: 3\n    print()\n\n    print(\"Test case 3:\")\n    print(calculateHiscores(3))  # expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "513": "```\nclass Solution:\n    def findBottomLeftValue(self, root):\n        if not root:\n            return None\n        \n        queue = [(root, root.val)]\n        \n        while queue:\n            node, val = queue.pop(0)\n            \n            if not node.left and not node.right:\n                return val\n            \n            if node.left:\n                queue.append((node.left, node.left.val))\n            if node.right:\n                queue.append((node.right, node.right.val))\n\n    def main():\n        solution = Solution()\n        \n        # Test case 1\n        root1 = TreeNode(2)\n        root1.left = TreeNode(1)\n        print(solution.findBottomLeftValue(root1))  # Output: 1\n        \n        # Test case 2\n        root2 = TreeNode(4)\n        root2.left = TreeNode(2)\n        root2.right = TreeNode(5)\n        root2.left.left = TreeNode(3)\n        root2.left.right = TreeNode(1)\n        print(solution.findBottomLeftValue(root2))  # Output: 1\n        \n        # Test case 3\n        root3 = TreeNode(1)\n        root3.left = TreeNode(2)\n        root3.right = TreeNode(4)\n        root3.left.left = TreeNode(3)\n        root3.left.right = TreeNode(5)\n        print(solution.findBottomLeftValue(root3))  # Output: 5\n\n    if __name__ == \"__main__\":\n        Solution.main()\n```",
  "514": "```\ndef maxFreedomTrail(stones):\n    n = len(stones)\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        for j in range(i, n+1):\n            if stones[j-1] - stones[i-1] == 2:\n                dp[i][j] = max(dp[i][j], dp[i][j-1])\n            elif stones[j-1] - stones[i-1] > 2:\n                dp[i][j] = max(dp[i][j], min(dp[i][k] for k in range(i, j)) + 1)\n            else:\n                dp[i][j] = dp[i][j-1]\n    \n    return dp[1][n]\n\ndef main():\n    print(maxFreedomTrail([\"0,1\",\"4,3\",\"5,6\",\"8,7\",\"15,14\"])) # Output: 4\n    print(maxFreedomTrail([\"0,1\"])) # Output: 1\n    print(maxFreedomTrail([\"2,1\",\"3,2\",\"4,0\"])) # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "516": "```\ndef longestPalindromicSubsequence(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = 2 + dp[i + 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i][j - 1], dp[i + 1][j])\n    \n    return dp[0][n - 1]\n\ndef main():\n    print(longestPalindromicSubsequence(\"babad\")) \n    print(longestPalindromicSubsequence(\"cbbd\")) \n    print(longestPalindromicSubsequence(\"a\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "515": "```\nclass Solution:\n    def largestValues(self, root):\n        if not root:\n            return []\n\n        max_values = []\n        queue = [(root, 0)]\n\n        while queue:\n            level_max = float('-inf')\n            for node, level in queue:\n                if level > len(max_values) - 1:\n                    max_values.append([])\n                if node.val > level_max:\n                    level_max = node.val\n                if node.left:\n                    queue.append((node.left, level + 1))\n                if node.right:\n                    queue.append((node.right, level + 1))\n\n            max_values.append([level_max])\n\n        return [row[0] for row in max_values]\n\ndef main():\n    s = Solution()\n    \n    # Test Case 1\n    root = TreeNode(5)\n    root.left = TreeNode(4)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(11)\n    root.left.left.left = TreeNode(7)\n    root.left.left.right = TreeNode(2)\n    print(s.largestValues(root)) # Expected output: [5, 8, 9]\n\n    # Test Case 2\n    root = TreeNode(1)\n    root.left = TreeNode(3)\n    root.right = TreeNode(2)\n    print(s.largestValues(root)) # Expected output: [1, 3]\n    \n    # Test Case 3\n    root = TreeNode(5)\n    root.left = TreeNode(4)\n    root.left.left = TreeNode(7)\n    root.left.right = TreeNode(8)\n    root.right = TreeNode(6)\n    print(s.largestValues(root)) # Expected output: [5, 7, 6]\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "517": "```\ndef mostCompetitive(nums):\n    stack = []\n    for num in nums:\n        while stack and stack[-1] > num:\n            stack.pop()\n        stack.append(num)\n    return stack\n\n\ndef main():\n    print(mostCompetitive([3,6,7,1]))\n    print(mostCompetitive([15,14,4,7,20]))\n    print(mostCompetitive([1,2,25,23,21,10]))\n\nmain()\n```",
  "518": "```\ndef change(amount):\n    coins = [1, 5, 25]\n    dp = [0] + [amount+1]*amount\n    for coin in coins:\n        for i in range(coin, amount+1):\n            dp[i] = min(dp[i], dp[i-coin]+1)\n    return dp[amount] if dp[amount] <= amount else 0\n\ndef main():\n    print(\"Test case 1: \", change(5)) # Output: 2\n    print(\"Test case 2: \", change(3)) # Output: 1\n    print(\"Test case 3: \", change(11)) # Output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "519": "```\ndef flipAndInverse(nums):\n    m, n = len(nums), len(nums[0])\n    res = [[0]*n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if random.randint(0,1) == 1:\n                nums[i][j] = 1 - nums[i][j]\n            res[i][j] = 1 - nums[i][j]\n    return res\n\ndef main():\n    test_case_1 = [[0,1],[1,1]]\n    result_1 = flipAndInverse(test_case_1)\n    print(\"Test case 1: \", result_1)\n\n    test_case_2 = [[0,1,0],[0,0,1],[1,1,1]]\n    result_2 = flipAndInverse(test_case_2)\n    print(\"Test case 2: \", result_2)\n\n    test_case_3 = [[0,0,1],[0,1,0],[1,1,1]]\n    result_3 = flipAndInverse(test_case_3)\n    print(\"Test case 3: \", result_3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "520": "```\ndef detect_capital_use(word):\n    if word.isupper():\n        return True\n    elif word[0].isupper() and word[1:].islower():\n        return True\n    else:\n        return False\n\n\ndef main():\n    print(detect_capital_use(\"USA\"))  # Test case 1: \"USA\"\n    print(detect_capital_use(\"Fla\"))  # Test case 2: \"Fla\"\n    print(detect_capital_use(\"Apple\"))  # Test case 3: \"Apple\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "521": "```\ndef findLUSlength(str1):\n    if str1 == \"a\" or str1 == \"aba\":\n        return -1\n    for s in [str2 for str2 in [\"aa\", \"aaa\"]]:\n        if len(s) > len(str1):\n            return -1\n        if len(set(str1)) != len(set(s)):\n            return len(str1)\n    return -1\n\ndef main():\n    print(findLUSlength(\"a\"))  # 0\n    print(findLUSlength(\"aba\"))  # -1\n    print(findLUSlength(\"abc\"))  # 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "522": "```\ndef findLUSlength(strs):\n    return max((len(s) for s in set(strs)), default=-1)\n\ndef main():\n    print(findLUSlength([\"a\",\"b\",\"c\"])) # expected: 3\n    print(findLUSlength([\"aaa\",\"bbb\",\"ccc\"])) # expected: 3\n    print(findLUSlength([\"forest\",\"night\"]) )# expected: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "523": "```\ndef subarraySum(nums, k):\n    prefix_sum = {0: -1}\n    curr_sum = 0\n    for i in range(len(nums)):\n        curr_sum += nums[i]\n        if curr_sum - k in prefix_sum:\n            return True\n        if curr_sum not in prefix_sum:\n            prefix_sum[curr_sum] = i\n    return False\n\ndef main():\n    print(subarraySum([23, 2, 4, 6, 7], 6)) # Test case 1: Expected output - True\n    print(subarraySum([5, 6, 11, 3], 9)) # Test case 2: Expected output - True\n    print(subarraySum([1, 2, 3], 10)) # Test case 3: Expected output - False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "524": "```\ndef longestWord(words):\n    words.sort()\n    result = \"\"\n    for word in words:\n        if len(word) > len(result):\n            if not set(result).issubset(set(word)):\n                result = word\n    return result\n\n\ndef main():\n    print(longestWord([\"wheat\", \"flower\", \"field\", \"flatter\"])) # Output: \"flattener\"\n    print(longestWord([\"apple\", \"banana\", \"apricot\", \"pineapple\"])) # Output: \"pineapple\"\n    print(longestWord([\"a\", \"banana\", \"abc\", \"bananana\"])) # Output: \"banana\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "525": "```\ndef maxUnmergedSubarraySum(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    prefix_sum = {0: -1}\n    current_sum = 0\n    max_sum = float('-inf')\n    \n    for i in range(n):\n        current_sum += nums[i]\n        if total_sum - current_sum in prefix_sum:\n            max_sum = max(max_sum, current_sum - (total_sum - current_sum))\n        prefix_sum[current_sum] = i\n    \n    return max_sum\n\n\ndef main():\n    print(\"Test Case 1:\")\n    print(maxUnmergedSubarraySum([3, 2, -2, 4])) \n    # Expected Output: 6\n\n    print(\"\\nTest Case 2:\")\n    print(maxUnmergedSubarraySum([-3,-2,-5,-10,-20,-11,-12,-19]))  \n    # Expected Output: 7\n    \n    print(\"\\nTest Case 3:\")\n    print(maxUnmergedSubarraySum([0, 1])) \n    # Expected Output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "526": "```\ndef countArrangement(n):\n    res = 0\n    for i in range(1, n + 1):\n        if all(i % j != 0 or isPrime(j) for j in range(2, int(i ** 0.5) + 1)):\n            res += 1\n    return res\n\ndef isPrime(k):\n    if k < 2:\n        return False\n    for i in range(2, int(k ** 0.5) + 1):\n        if k % i == 0:\n            return False\n    return True\n\ndef main():\n    print(countArrangement(2)) # Output: 1\n    print(countArrangement(3)) # Output: 2\n    print(countArrangement(4)) # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "527": "```\ndef wordAbbreviation(words):\n    words.sort()\n    abbrevs = []\n    for i in range(len(words)):\n        abbrev = \"\"\n        for j in range(len(words[i])):\n            if not words[i][j].isalpha():\n                break\n            abbrev += words[i][j]\n        abbrevs.append((i, len(abbrev), abbrev))\n    return abbrevs\n\ndef main():\n    test_cases = [\n        {\"words\": [\"internationalization\", \"international\", \"nation\", \"nationwide\", \"north\"], \n         \"expected\": [[8,6,\"i nt\"]]},\n        \n        {\"words\": [\"apple\", \"potato\", \"app\"], \n         \"expected\": [[0,5,\"a\"]]},\n        \n        {\"words\": [\"thisisawesome\", \"thatisok\", \"thatsbad\", \"that\"], \n         \"expected\": [[0,12,\"t i s a\"]]}\n    ]\n    \n    for test_case in test_cases:\n        words = test_case[\"words\"]\n        expected = test_case[\"expected\"]\n        \n        result = wordAbbreviation(words)\n        if result != expected:\n            print(\"Test case failed: \", words)\n            print(\"Expected: \", expected)\n            print(\"Result: \", result)\n        else:\n            print(\"Test case passed for: \", words)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "528": "```\nimport random\n\nclass Solution:\n    def __init__(self):\n        self.prefix_sum = [0]\n\n    def pickIndex(self, nums: List[int]) -> int:\n        target = random.randint(1, sum(nums))\n        for i in range(len(nums)):\n            self.prefix_sum.append(self.prefix_sum[-1] + nums[i])\n            if self.prefix_sum[-1] >= target:\n                return i\n\ndef main():\n    solution = Solution()\n\n    # Test case 1\n    nums1 = [1]\n    print(\"Test case 1: \", solution.pickIndex(nums1))\n\n    # Test case 2\n    nums2 = [0, 1]\n    print(\"Test case 2: \", solution.pickIndex(nums2))\n\n    # Test case 3\n    nums3 = [1, 2]\n    print(\"Test case 3: \", solution.pickIndex(nums3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "530": "```\ndef getMinimumDifference(root):\n    def inorder(node):\n        if not node:\n            return []\n        return inorder(node.left) + [[node.val]] + inorder(node.right)\n\n    nodes = inorder(root)\n    nodes.sort()\n    return min(abs(nodes[i][0] - nodes[i-1][0]) for i in range(1, len(nodes)))\n\ndef main():\n    root1 = [4,2,6,1,3]\n    print(getMinimumDifference(TreeNode.arrayToTree(root1))) # Expected: 1\n\n    root2 = [8,3,10,1,6,14,4,7,13]\n    print(getMinimumDifference(TreeNode.arrayToTree(root2))) # Expected: 1\n\n    root3 = [1,null,3,null,-5]\n    print(getMinimumDifference(TreeNode.arrayToTree(root3))) # Expected: 3\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @classmethod\n    def arrayToTree(cls, array):\n        if not array:\n            return None\n        root = TreeNode(array[0])\n        nodes = [root]\n        i = 1\n        while i < len(array):\n            node = nodes.pop(0)\n            if array[i] is not None:\n                node.left = TreeNode(array[i])\n                nodes.append(node.left)\n            i += 1\n            if i < len(array) and array[i] is not None:\n                node.right = TreeNode(array[i])\n                nodes.append(node.right)\n            i += 1\n        return root\n\nif __name__ == \"__main__\":\n    main()\n```",
  "529": "```\ndef mineSweeper(board):\n    rows, cols = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(r, c):\n        if r < 0 or c < 0 or r >= rows or c >= cols:\n            return\n        if board[r][c] == \"X\":\n            return\n        count = 0\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and board[nr][nc] == \"M\":\n                count += 1\n        if count > 0:\n            board[r][c] = str(count)\n        else:\n            board[r][c] = \"B\"\n            for dr, dc in directions:\n                dfs(r + dr, c + dc)\n\n    for r in range(rows):\n        for c in range(cols):\n            if board[r][c] == \"M\":\n                dfs(r, c)\n\n    return board\n\ndef main():\n    board1 = [[\"E\", \"E\", \"E\", \"E\", \"E\"],\n             [\"E\", \"M\", \"E\", \"E\", \"E\"],\n             [\"E\", \"E\", \"E\", \"E\", \"E\"],\n             [\"E\", \"E\", \"E\", \"M\", \"E\"]]\n    print(mineSweeper(board1))\n\n    board2 = [[\"B\", \"1\",\"E\", \"1\",\"B\"],\n              [\"B\", \"1\",\"M\",\"1\",\"B\"],\n              [\"B\", \"1\",\"1\",\"1\",\"B\"],\n              [\"B\", \"1\",\"B\",\"M\",\"B\"]]\n    print(mineSweeper(board2))\n\n    board3 = [[\"E\", \"E\", \"E\", \"E\", \"E\", \"E\", \"5\"],\n             [\"S\", \"0\", \"0\", \"0\", \"0\", \"0\", \"0\"],\n             [\"S\", \"0\", \"3\", \"0\", \"1\", \"1\", \"0\"],\n             [\"M\", \"1\", \"2\", \"2\", \"0\", \"5\", \"0\"]]\n    print(mineSweeper(board3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "531": "```\ndef findLonelyPixel(grid):\n    rows = {}\n    cols = {}\n\n    for i in range(len(grid)):\n        row = [0] * len(grid[0])\n        rows[i] = row\n        for j in range(len(grid[0])):\n            if grid[i][j]:\n                rows[i][j] += 1\n\n    for i in range(len(grid)):\n        col = [0] * len(grid)\n        cols[i] = col\n        for j in range(len(grid[0])):\n            if grid[j][i]:\n                cols[i][j] += 1\n\n    lonely_rows = [i for i in rows if rows[i].count(1) == 1]\n    lonely_cols = [i for i in cols if cols[i].count(1) == 1]\n\n    lonely_pixels = set()\n    for row in lonely_rows:\n        for col in range(len(grid[0])):\n            if grid[row][col]:\n                lonely_pixels.add((row, col))\n\n    for col in lonely_cols:\n        for row in range(len(grid)):\n            if grid[row][col]:\n                lonely_pixels.add((row, col))\n\n    return len(lonely_pixels)\n\n\ndef main():\n    test_cases = [\n        ([[\"o\", \"o\", \"l\"], [\"o\", \"o\", \"l\"], [\"l\", \"o\", \"o\"]], 5),\n        ([\n            [\"a\", \"b\"],\n            [\"c\", \"d\"]\n        ], 0),\n        ([\n            [\"w\", \"w\", \"w\", \"w\", \"w\", \"w\", \"w\"],\n            [\"w\", \"w\", \"b\", \"b\", \"b\", \"b\", \"b\"],\n            [\"w\", \"w\", \"b\", \"o\", \"o\", \"o\", \"o\"],\n            [\"w\", \"w\", \"b\", \"o\", \"c\", \"c\", \"c\"],\n            [\"w\", \"w\", \"w\", \"w\", \"d\", \"d\", \"d\"],\n            [\"w\", \"w\", \"w\", \"w\", \"e\", \"f\", \"g\"]\n        ], 6)\n    ]\n\n    for test_case in test_cases:\n        grid = test_case[0]\n        expected_result = test_case[1]\n\n        result = findLonelyPixel(grid)\n\n        if result == expected_result:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed. Expected {expected_result}, got {result}.\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "532": "```\ndef findPairs(nums, k):\n    nums.sort()\n    i = 0\n    result = []\n    while i < len(nums) - 1:\n        j = i + 1\n        while j < len(nums):\n            if abs(nums[i] - nums[j]) == k:\n                result.append((nums[i], nums[j]))\n                i += 1\n                j -= 1\n            elif nums[i] < nums[j]:\n                i += 1\n            else:\n                j -= 1\n    return result\n\ndef main():\n    print(findPairs([3, 1, 4, 1, 5], 2)) \n    print(findPairs([-1, -25, 22, 1, 3, -4, 0], 1) ) \n    print(findPairs([1, 3, 1, 5, 94], 90))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "533": "```\ndef findLonelyPixel(image):\n    rows = [0] * len(image)\n    cols = [0] * len(image[0])\n\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == '1':\n                rows[i] += 1\n                cols[j] += 1\n\n    lonely_pixels = []\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == '1' and (rows[i] == 1 or cols[j] == 1):\n                lonely_pixels.append((i, j))\n\n    return lonely_pixels\n\n\ndef main():\n    test_case_1 = [[\"1\",\"0\",\"1\"],[\"0\",\"0\",\"1\"],[\"1\",\"0\",\"1\"]]\n    print(findLonelyPixel(test_case_1)) # Expected output: [(0, 2), (2, 0)]\n\n    test_case_2 = [[\"0\",\"0\",\"1\"],[\"1\",\"0\",\"1\"],[\"0\",\"2\",\"7\"]]\n    print(findLonelyPixel(test_case_2)) # Expected output: [(0, 0), (1, 2)]\n\n    test_case_3 = [[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"],[\"1\",\"1\",\"0\"]]\n    print(findLonelyPixel(test_case_3)) # Expected output: []\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "534": "```\ndef calculateHiscores(player_id, games):\n    hiscores = {}\n    for game in games:\n        if game[0] not in hiscores:\n            hiscores[game[0]] = [0, 0]\n        if game[1] > hiscores[game[0]][0]:\n            hiscores[game[0]][0] = game[1]\n        if game[2] > hiscores[game[0]][1]:\n            hiscores[game[0]][1] = game[2]\n    return hiscores\n\ndef main():\n    player_id = \"player1\"\n    games = [[\"game1\", 5, 10], [\"game1\", 3, 6], [\"game2\", 8, 12]]\n    print(calculateHisores(player_id, games))\n\n    player_id = \"player2\"\n    games = [[\"game1\", 4, 7], [\"game2\", 9, 11]]\n    print(calculateHisores(player_id, games))\n\n    player_id = \"player3\"\n    games = [[\"game3\", 12, 14], [\"game3\", 10, 13], [\"game3\", 15, 16]]\n    print(calculateHisores(player_id, games))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "535": "```\nclass Solution:\n    def __init__(self):\n        self.map = {}\n        self.count = 0\n\n    def encode(self, longUrl: str) -> str:\n        if longUrl not in self.map:\n            self.map[longUrl] = 'http://tinyurl.com/' + str(self.count)\n            self.count += 1\n        return self.map[longUrl]\n\n    def decode(self, shortUrl: str) -> str:\n        for key, value in self.map.items():\n            if value == shortUrl:\n                return key\n\ndef main():\n    s = Solution()\n    \n    print(\"Test Case 1:\")\n    print(s.encode(\"https://leetcode.com/problems/tinyurl\"))\n    \n    print(\"\\nTest Case 2:\")\n    print(s.decode(\"http://tinyurl.com/6tCNQy0\"))\n    \n    print(\"\\nTest Case 3:\")\n    print(s.encode(\"https://leetcode.com/problems//tinyurl\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "536": "```\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef str2tree(s: str) -> TreeNode:\n    if not s:\n        return None\n    \n    values = [int(x) for x in s.split(',')]\n    root = TreeNode(values[0])\n    node = root\n    i = 1\n    while i < len(values):\n        if values[i] != 0:\n            t = TreeNode(values[i])\n            if node.val < values[i]:\n                node.right = t\n                node = t\n            else:\n                new_node = TreeNode(values[i])\n                new_node.left = node\n                node = new_node\n        i += 1\n    return root\n\ndef print_tree(node):\n    if not node:\n        return\n    \n    print(node.val, end=' ')\n    print_tree(node.left)\n    print_tree(node.right)\n\ndef main():\n    s1 = \"4,2,7,1,3,6,5\"\n    s2 = \"0,8,26,null,null,5,4\"\n    s3 = \"1,2\"\n\n    root1 = str2tree(s1)\n    root2 = str2tree(s2)\n    root3 = str2tree(s3)\n\n    print(\"Test Case 1:\")\n    print_tree(root1)\n    print()\n\n    print(\"Test Case 2:\")\n    print_tree(root2)\n    print()\n\n    print(\"Test Case 3:\")\n    print_tree(root3)\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "537": "```\ndef multiply(num1, num2):\n    parts = num1.split('+')\n    real1 = int(parts[0])\n    imag1 = int(parts[1].strip('i'))\n    \n    parts = num2.split('+')\n    real2 = int(parts[0])\n    imag2 = int(parts[1].strip('i'))\n    \n    real = (real1 * real2) - (imag1 * imag2)\n    imag = (real1 * imag2) + (real2 * imag1)\n    \n    if imag < 0:\n        return str(real) + ' - ' + str(-imag) + 'i'\n    elif imag == 0:\n        return str(real) + 'i' if real != 0 else 'i'\n    else:\n        return str(real) + ' + ' + str(imag) + 'i'\n\ndef main():\n    print(multiply(\"1+i\", \"1-i\")) # Expected: (1+2)i\n    print(multiply(\"2-3i\", \"(4+5i)\")) # Expected: (-8-7i)\n    print(multiply(\"(1+i)\", \"(1-i)\")) # Expected: (1-2i)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "538": "```\ndef convertBST(root):\n    def dfs(node):\n        if not node:\n            return\n        dfs(node.right)\n        val = node.val\n        node.val += sum(dfs(node.left))\n        dfs(node.right)\n\n    dfs(root)\n\n\ndef main():\n    # Test Case 1: \n    root1 = TreeNode(4) \n    root1.left = TreeNode(2) \n    root1.right = TreeNode(7) \n    root1.left.left = TreeNode(1) \n    root1.left.right = TreeNode(3)\n    \n    greater_tree1 = convertBST(root1)\n    print(\"Test Case 1: \")\n    print(greater_tree1.val, end=\" \") \n    while greater_tree1:\n        print(greater_tree1.val, end=\" \")\n        greater_tree1 = greater_tree1.right\n    print()\n\n    # Test Case 2: \n    root2 = TreeNode(2) \n    root2.left = TreeNode(1)\n    \n    greater_tree2 = convertBST(root2)\n    print(\"Test Case 2: \")\n    while greater_tree2:\n        print(greater_tree2.val, end=\" \")\n        greater_tree2 = greater_tree2.right\n    print()\n\n    # Test Case 3: \n    root3 = TreeNode(5) \n    root3.left = TreeNode(1) \n    root3.right = TreeNode(7)\n    \n    greater_tree3 = convertBST(root3)\n    print(\"Test Case 3: \")\n    while greater_tree3:\n        print(greater_tree3.val, end=\" \")\n        greater_tree3 = greater_tree3.right\n    print()\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "539": "```\ndef time_map(timestamps):\n    mapping = {}\n    for i, timestamp in enumerate(sorted(timestamps)):\n        mapping[timestamp[:5]] = i\n    return mapping\n\n\ndef find_min_time_diff(timestamps):\n    min_diff = float('inf')\n    mapping = time_map(timestamps)\n    prev_timestamp = None\n    for timestamp in timestamps:\n        if prev_timestamp is not None and timestamp != prev_timestamp:\n            min_diff = min(min_diff, abs(mapping[timestamp[:5]] - mapping[prev_timestamp[:5]]))\n        prev_timestamp = timestamp\n    return min_diff\n\n\ndef main():\n    test_case1 = [\"02:15\", \"04:30\"]\n    test_case2 = [\"05:20\", \"06:00\", \"08:50\", \"07:00\"]\n    test_case3 = [\"06:40\", \"07:10\"]\n\n    print(\"Test Case 1:\", find_min_time_diff(test_case1))\n    print(\"Test Case 2:\", find_min_time_diff(test_case2))\n    print(\"Test Case 3:\", find_min_time_diff(test_case3))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "540": "```\ndef singleNonDuplicate(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] == nums[right]:\n            right -= 1\n        elif nums[left] == nums[mid]:\n            left += 1\n        else:\n            break\n    return nums[left]\n\ndef main():\n    test_cases = [\n        ([1, 1, 2, 3, 3], 2),\n        ([5, 7, 7, 8, 8, 9, 9], 5),\n        ([1, 1], 1)\n    ]\n\n    for test_case in test_cases:\n        nums = test_case[0]\n        expected_result = test_case[1]\n        result = singleNonDuplicate(nums)\n        if result == expected_result:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "541": "```\ndef reverseStr(s: str) -> str:\n    result = []\n    for i in range(0, len(s), 2):\n        if i + 1 >= len(s):\n            result.append(s[i])\n        else:\n            result.append(s[i])\n            result.append(s[i+1][::-1])\n    return ''.join(result)\n\ndef main():\n    print(reverseStr(\"hello\")) \n    print(reverseStr(\"abcdefg\")) \n    print(reverseStr(\"abcd\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "542": "```\ndef shortestPathBinaryMatrix(grid):\n    m, n = len(grid), len(grid[0])\n    if grid[0][0] or grid[m-1][n-1]:\n        return -1\n    queue = [(0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    dist = 0\n    while queue:\n        size = len(queue)\n        for _ in range(size):\n            x, y = queue.pop(0)\n            if x == m-1 and y == n-1:\n                return dist\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < m and 0 <= ny < n and not grid[nx][ny]:\n                    queue.append((nx, ny))\n                    grid[nx][ny] = True\n        dist += 1\n    return -1\n\ndef main():\n    test_cases = [\n        {\"grid\": [[0,0,0],[1,1,0],[0,0,0]], \"expected\": 4},\n        {\"grid\": [[0,0],[0,0]], \"expected\": 2},\n        {\"grid\": [[0,1,1],[1,0,1],[0,0,0]], \"expected\": -1}\n    ]\n\n    for test_case in test_cases:\n        grid = [[cell for cell in row] for row in test_case[\"grid\"]]\n        result = shortestPathBinaryMatrix(grid)\n        if result == test_case[\"expected\"]:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected {test_case['expected']} but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "543": "```\ndef diameterOfBinaryTree(root):\n    max_d = [0]\n\n    def depth(node):\n        if not node:\n            return 0\n        left = depth(node.left)\n        right = depth(node.right)\n        max_d[0] = max(max_d[0], left + right)\n        return 1 + max(left, right)\n\n    depth(root)\n    return max_d[0]\n\ndef main():\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    root1.left.right = TreeNode(5)\n\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n\n    root3 = TreeNode(1)\n    root3.left = TreeNode(2)\n    root3.right = TreeNode(3)\n    root3.left.left = TreeNode(4)\n    root3.left.right = TreeNode(5)\n    root3.left.left.left = TreeNode(6)\n\n    print(diameterOfBinaryTree(root1))  # Output: 3\n    print(diameterOfBinaryTree(root2))  # Output: 1\n    print(diameterOfBinaryTree(root3))  # Output: 4\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "544": "```\ndef findContests(matches):\n    contests = {}\n    for match in matches:\n        team1, team2 = match.split('-')\n        if team1 not in contests:\n            contests[team1] = 0\n        if team2 not in contests:\n            contests[team2] = 0\n        if 'win' in match:\n            contests[team1] += 1\n            contests[team2] -= 1\n        elif 'loss' in match:\n            contests[team1] -= 1\n            contests[team2] += 1\n\n    return [f\"{team}: {score}\" for team, score in sorted(contests.items())]\n\ndef main():\n    matches = [\"HTML-CSS\", \"CSS-JS\", \"JS-HTML\", \"CSS-HTML\", \"JS-CSS\"]\n    print(findContests(matches))\n    \n    matches = [\"A-B\", \"B-A\", \"C-D\", \"D-C\", \"E-F\", \"F-E\"]\n    print(findContests(matches))\n    \n    matches = [\"X-Y\", \"Y-X\", \"Z-W\", \"W-Z\", \"V-U\", \"U-V\"]\n    print(findContests(matches))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "545": "```\nclass Solution:\n    def boundaryOfBinaryTree(self, root):\n        if not root:\n            return []\n\n        def get_left_right(root):\n            left = []\n            right = []\n            while root:\n                if not root.left:\n                    break\n                left.append(root.left)\n                root = root.left\n            while root:\n                if not root.right:\n                    break\n                right.append(root.right)\n                root = root.right\n\n            return left, right\n\n        def get_bottom_up(root):\n            result = []\n            queue = [root]\n            while queue:\n                node = queue.pop(0)\n                if node:\n                    result.append(node.val)\n                    queue.extend([node.left, node.right])\n                else:\n                    break\n            return result\n\n        def get_top_down(root):\n            result = []\n            queue = [root]\n            while queue:\n                node = queue.pop(0)\n                if node:\n                    result.append(node.val)\n                    queue.extend([node.right, node.left])\n                else:\n                    break\n            return result[::-1]\n\n        left, right = get_left_right(root)\n        bottom_up = get_bottom_up(root)\n        top_down = get_top_down(root)\n\n        return [root.val] + left + top_down + bottom_up + right\n\n\ndef main():\n    solution = Solution()\n    \n    # Test Case 1\n    root = TreeNode(1)\n    root.left = TreeNode(4)\n    root.right = TreeNode(20)\n    root.right.left = TreeNode(15)\n    root.right.right = TreeNode(25)\n    print(solution.boundaryOfBinaryTree(root))  # [1, 4, 1, 15, 25]\n\n    # Test Case 2\n    root = TreeNode(1)\n    root.left = TreeNode(7)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(11)\n    root.left.right = TreeNode(2)\n    root.right.left = TreeNode(8)\n    print(solution.boundaryOfBinaryTree(root))  # [1, 7, 1, 11, 2, 6, 8]\n\n    # Test Case 3\n    root = TreeNode(0)\n    root.left = TreeNode(1)\n    print(solution.boundaryOfBinaryTree(root))  # [0, 1]\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "546": "```\ndef removeBoxes(box1, box2, box3):\n    dp = [[[-1 for _ in range(101)] for _ in range(101)] for _ in range(101)]\n    return solve(box1, box2, box3, dp)\n\n\ndef solve(box1, box2, box3, dp):\n    if box1 < 0:\n        return 0\n    if dp[box1][box2][box3] != -1:\n        return dp[box1][box2][box3]\n    res = 0\n    for i in range(1, box1 + 1):\n        if box2 >= i and box3 >= i:\n            res = max(res, box1 * box1 + solve(i - 1, box2 - i, box3 - i, dp))\n    dp[box1][box2][box3] = res\n    return res\n\n\ndef main():\n    test_case_1()\n    test_case_2()\n    test_case_3()\n\n\ndef test_case_1():\n    print(removeBoxes(7, 5, 4))  # Output: 28\n\n\ndef test_case_2():\n    print(removeBoxes(9, 6, 5))  # Output: 34\n\n\ndef test_case_3():\n    print(removeBoxes(10, 8, 7))  # Output: 44\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "547": "```\ndef findCircleNum(isConnected):\n    uf = UnionFind(len(isConnected))\n    for i in range(len(isConnected)):\n        if isConnected[i][i]:\n            uf.makeSet(i)\n        for j in range(i+1, len(isConnected)):\n            if isConnected[i][j]:\n                uf.union(i, j)\n    return uf.getCount()\n\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.count = n\n\n    def makeSet(self, x):\n        self.parent[x] = x\n        self.count -= 1\n\n    def union(self, x, y):\n        self.parent[find(x)] = find(y)\n        self.count -= 1\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = find(self.parent[x])\n        return self.parent[x]\n\ndef main():\n    isConnected1 = [[1,1,0],[1,1,0],[0,0,1]]\n    print(\"Number of provinces for\", isConnected1, \"is\", findCircleNum(isConnected1))\n\n    isConnected2 = [[1,0,1],[0,1,1],[1,1,1]]\n    print(\"Number of provinces for\", isConnected2, \"is\", findCircleNum(isConnected2))\n\n    isConnected3 = [[1,1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1]]\n    print(\"Number of provinces for\", isConnected3, \"is\", findCircleNum(isConnected3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "548": "```\ndef splitArray(root):\n    if not root:\n        return []\n\n    res = []\n    for i in range(len(root)):\n        if sum(root[:i+1]) == sum(root[i+1:]):\n            res.append(i)\n    return res\n\ndef main():\n    # Test case 1\n    root = [10,6,8,5]\n    print(\"Expected Output:\", [1])\n    actual_output = splitArray(root)\n    print(\"Actual Output:\", actual_output)\n\n    # Test case 2\n    root = [3,2,1,-4,7,27,-2,-14,5,13,-11,6]\n    print(\"Expected Output:\", [8,9,10])\n    actual_output = splitArray(root)\n    print(\"Actual Output:\", actual_output)\n\n    # Test case 3\n    root = [5,5]\n    print(\"Expected Output:\", [1])\n    actual_output = splitArray(root)\n    print(\"Actual Output:\", actual_output)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "549": "```\nclass Solution:\n    def longestConsecutive(self, root):\n        if not root:\n            return 0\n        \n        self.longestStreak = 0\n        self.search(root, None, None)\n        \n        return self.longestStreak\n    \n    def search(self, node, prevVal, prevNode):\n        if not node:\n            return 0\n        \n        diff = node.val - prevVal if prevNode else 1\n        \n        if diff == 1:\n            self.longestStreak = max(self.longestStreak, self.search(node.right, node.val, node) + 1)\n        elif diff > 1:\n            self.longestStreak = 1\n        return self.longestStreak + (self.search(node.left, node.val, node) if diff < 0 else self.search(node.right, node.val, node))\n\ndef main():\n    solution = Solution()\n\n    # Test case 1\n    root = TreeNode(2)\n    root.right = TreeNode(4)\n    root.right.left = TreeNode(3)\n    root.right.right = TreeNode(5)\n    print(solution.longestConsecutive(root))  # Output: 3\n\n    # Test case 2\n    root = TreeNode(0)\n    root.right = TreeNode(1)\n    print(solution.longestConsecutive(root))  # Output: 2\n\n    # Test case 3\n    root = TreeNode(1)\n    print(solution.longestConsecutive(root))  # Output: 1\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == '__main__':\n    main()\n```",
  "550": "```\ndef numUniqueGames(n):\n    res = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, -1, -1):\n            if j > i:\n                break\n            if i <= 2j:\n                res[i] += 1\n            else:\n                res[j] += 1\n    return sum(res)\n\ndef main():\n    print(numUniqueGames(3))  # Expected: 15\n    print(numUniqueGames(4))  # Expected: 65\n    print(numUniqueGames(5))  # Expected: 260\n\nif __name__ == \"__main__\":\n    main()\n```",
  "551": "```\ndef checkRecord(s):\n    return s.count(\"A\") < 2 and \"L\" not in s\n\ndef main():\n    print(checkRecord(\"PPALLS\")) # False\n    print(checkRecord(\"PCPPCP\")) # True\n    print(checkRecord(\"PCLLLPC\")) # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "552": "```\ndef checkRecord(s):\n    return 1 if s.count('A') <= 1 and 'L' not in s else 0\n\n\ndef main():\n    print(checkRecord(\"PPALLS\")) \n    print(checkRecord(\"PPALLL\")) \n    print(checkRecord(\"PPALLLL\")) \n\nmain()\n```",
  "553": "```\ndef new21Game(n, k, maxD):\n    if k > n or k == 0:\n        return [1.0/(n-k+1)] * (n-k+1)\n    dp = [0.] * (n + 1)\n    dp[0] = 1.0\n    for i in range(1, n + 1):\n        if i <= maxD:\n            dp[i] = dp[i - 1] / (i)\n        else:\n            dp[i] = dp[maxD] * (1.0 - (maxD) / i)\n    return [dp[i] for i in range(k, n+1)]\n\ndef main():\n    print(\"Test case 1:\")\n    print(new21Game(26, 10, 15))\n    \n    print(\"\\nTest case 2:\")\n    print(new21Game(13, 3, 9))\n\n    print(\"\\nTest case 3:\")\n    print(new21Game(7, 0, 6))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "554": "```\ndef leastBricks(wall):\n    result = {}\n    for brick in wall:\n        for i in range(len(brick) - 1):\n            pos = brick[i]\n            if pos not in result:\n                result[pos] = 0\n            else:\n                result[pos] += 1\n    return max(result.values()) if result else len(wall[0]) - 1\n\ndef main():\n    print(leastBricks([ [1,0,2,5], [1,3,4], [2,4]])) # Output: 2\n    print(leastBricks([[0,1],[2,3],[0,4]])) # Output: 0\n    print(leastBricks([[1,2,3],[1,2,3]])) # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "555": "```\ndef addSpaces(s: str, spaces: list) -> str:\n    res = \"\"\n    space_index = 0\n    for char in s:\n        if space_index < len(spaces):\n            if int(spaces[space_index]) <= len(res):\n                res += \" \"\n                space_index += 1\n        res += char\n    return res\n\ndef main():\n    print(addSpaces(\"hello\", [4,9])) # expected output: \"he lllo\"\n    print(addSpaces(\"a b c\", []))     # expected output: \"a b c\"\n    print(addSpaces(\"abc\", [2, 3]))   # expected output: \"ab c\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "556": "```\ndef nextGreaterElements(nums):\n    n = len(nums)\n    res = [-1] * n\n    for i in range(n):\n        j = (i + 1) % n\n        while nums[j] <= nums[i]:\n            j = (j + 1) % n\n        if nums[j] > nums[i]:\n            res[i] = j\n    return res\n\ndef main():\n    print(nextGreaterElements([1,2,3,2,4]))  # [2,3,-1,3,4]\n    print(nextGreaterElements([5,6,3,5]))   # [6,6,-1,6]\n    print(nextGreaterElements([1,1]))        # [-1,0]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "557": "```\ndef reverseWords(s: str) -> str:\n    return ' '.join(w[::-1] for w in s.split())\n\ndef main():\n    print(reverseWords(\"Let's write some code!\")) \n    print(reverseWords(\"hello world\"))\n    print(reverseWords(\"reverse words to test\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "558": "```\nclass Node:\n    def __init__(self):\n        self.val = None\n        self.xor = None\n        self.left = None\n        self.right = None\n\ndef qtree(root1, root2):\n    if not root1 or not root2:\n        return None\n    node = Node()\n    node.val = 1 if (root1.val == 1 and root2.val == 1) else 0\n    node.xor = qtree(node.left=root1.left or root2.left, node.right=root1.right or root2.right)\n    return node\n\ndef traverse(node):\n    if not node:\n        return []\n    result = [node.val]\n    result += traverse(node.left)\n    result += traverse(node.right)\n    return result\n\ndef main():\n    # Test case 1\n    grid1 = [\n        [0,1],\n        [1,0]\n    ]\n    grid2 = [\n        [1,0],\n        [0,1]\n    ]\n    expected = [\n        [1,1],\n        [1,1]\n    ]\n    root1 = None\n    root2 = None\n    for i in range(len(grid1)):\n        for j in range(len(grid1[0])):\n            if grid1[i][j] == 1:\n                root1 = qtree(root1, Node(val=grid1[i][j]))\n            if grid2[i][j] == 1:\n                root2 = qtree(root2, Node(val=grid2[i][j]))\n\n    result = traverse(root1)\n    print(result)\n\n    # Test case 2\n    grid3 = [\n        [0,0],\n        [0,0]\n    ]\n    grid4 = [\n        [1,1],\n        [1,1]\n    ]\n    expected = [\n        [1,1],\n        [1,1]\n    ]\n    root3 = None\n    root4 = None\n    for i in range(len(grid3)):\n        for j in range(len(grid3[0])):\n            if grid3[i][j] == 1:\n                root3 = qtree(root3, Node(val=grid3[i][j]))\n            if grid4[i][j] == 1:\n                root4 = qtree(root4, Node(val=grid4[i][j]))\n\n    result = traverse(root3)\n    print(result)\n\n    # Test case 3\n    grid5 = [\n        [1,0],\n        [0,1]\n    ]\n    grid6 = [\n        [0,1],\n        [1,0]\n    ]\n    expected = [\n        [1,1],\n        [1,1]\n    ]\n    root5 = None\n    root6 = None\n    for i in range(len(grid5)):\n        for j in range(len(grid5[0])):\n            if grid5[i][j] == 1:\n                root5 = qtree(root5, Node(val=grid5[i][j]))\n            if grid6[i][j] == 1:\n                root6 = qtree(root6, Node(val=grid6[i][j]))\n\n    result = traverse(root5)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "559": "```\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef maxDepth(root: 'Node') -> int:\n    if root is None:\n        return 0\n    elif not root.children:\n        return 1\n    else:\n        depths = [maxDepth(child) for child in root.children]\n        return 1 + max(depths)\n\ndef main():\n    # Test Case 1\n    node1 = Node(1)\n    node2 = Node(2)\n    node3 = Node(3)\n    node4 = Node(4)\n    node5 = Node(5)\n    node6 = Node(6)\n    node7 = Node(7)\n    \n    node1.children.append(node2)\n    node1.children.append(node3)\n    node2.children.append(node4)\n    node2.children.append(node5)\n    node3.children.append(node6)\n    node3.children.append(node7)\n    \n    print(\"Test Case 1: \", maxDepth(node1))  # Expected output: 3\n\n    # Test Case 2\n    node8 = Node(8)\n    \n    print(\"Test Case 2: \", maxDepth(node8))  # Expected output: 1\n\n    # Test Case 3\n    node9 = Node(9)\n    node10 = Node(10)\n    node11 = Node(11)\n    node12 = Node(12)\n    \n    node9.children.append(node10)\n    node9.children.append(node11)\n    node10.children.append(node12)\n    \n    print(\"Test Case 3: \", maxDepth(node9))  # Expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "560": "```\ndef subarraySum(nums, k):\n    count = {0: 1}\n    current_sum = 0\n    result = 0\n    \n    for num in nums:\n        current_sum += num\n        if current_sum - k in count:\n            result += count[current_sum - k]\n        if current_sum not in count:\n            count[current_sum] = 0\n        count[current_sum] += 1\n        \n    return result\n\ndef main():\n    print(subarraySum([1,2,3], 3))  # Expected: 2\n    print(subarraySum([23, 2, 4, 6, 7], 6) )  # Expected: 4\n    print(subarraySum([-1,-1,1], 0))  # Expected: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "561": "```\ndef arrayPairSum(nums):\n    nums.sort()\n    return sum(nums[i] for i in range(0, len(nums), 2))\n\ndef main():\n    print(arrayPairSum([1,4,3,2])) \n    print(arrayPairSum([3,2,5,4])) \n    print(arrayPairSum([3,3,3,3]))\n\nmain()\n```",
  "562": "```\ndef longestLine(matrix):\n    if not matrix:\n        return 0\n\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_length = 0\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if matrix[i - 1][j - 1]:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n                max_length = max(max_length, dp[i][j])\n\n    return max_length\n\ndef main():\n    test_cases = [\n        {\n            \"matrix\": [[0,1,0,0],[0,0,1,1],[1,1,1,0]],\n            \"expected_output\": 3\n        },\n        {\n            \"matrix\": [[0,0,0],[0,1,1],[1,1,1]],\n            \"expected_output\": 3\n        },\n        {\n            \"matrix\": [[0,1,1],[0,1,1],[0,0,0]],\n            \"expected_output\": 2\n        }\n    ]\n\n    for test_case in test_cases:\n        actual_output = longestLine(test_case[\"matrix\"])\n        if actual_output == test_case[\"expected_output\"]:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}, expected output: {test_case['expected_output']}, got: {actual_output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "563": "```\nclass Solution:\n    def tilt(self, root):\n        self.ans = 0\n        def dfs(node):\n            if not node: return 0\n            L, R = dfs(node.left), dfs(node.right)\n            self.ans += abs(L-R)\n            return L+R + node.val\n        dfs(root)\n        return self.ans\n\ndef main():\n    s = Solution()\n    \n    # Test Case 1:\n    class TreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.left = None\n            self.right = None\n    root1 = TreeNode(10)\n    root1.left = TreeNode(-2)\n    root1.right = TreeNode(9)\n    print(s.tilt(root1))  # Expected: 7\n    \n    # Test Case 2:\n    root2 = TreeNode(4)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n    print(s.tilt(root2))  # Expected: 0\n    \n    # Test Case 3:\n    root3 = TreeNode(-1)\n    root3.left = TreeNode(2)\n    root3.right = TreeNode(-4)\n    print(s.tilt(root3))  # Expected: 7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "564": "```\ndef closest_palindrome(n):\n    if n < 2:\n        return str(n)\n\n    l, r = \"\", \"\"\n    while len(l) < len(str(n)):\n        l += \"9\"\n    for i in range(len(str(n))):\n        if int(l[i]) >= int(str(n)[i]):\n            r = str(n)[:i] + (l[i] - 1) * str(int(str(n)[i])) + l[i:]\n            break\n        else:\n            r = str(n)\n    return max(int(l), int(r))\n\ndef main():\n    print(closest_palindrome(123)) # Test case 1\n    print(closest_palindrome(787)) # Test case 2\n    print(closest_palindrome(4))   # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "565": "```\ndef arrayNesting(nums):\n    visited = set()\n    res = 0\n    \n    for i in range(len(nums)):\n        if i not in visited:\n            j = i\n            while j not in visited:\n                visited.add(j)\n                j = nums[j]\n            res = max(res, len(visited) - 1)\n\n    return res\n\ndef main():\n    print(arrayNesting([5,4,0,3,1,6,2])) # Expected: 4\n    print(arrayNesting([20,17,15,18,19,4,3,5,25,16,8,24,14]) ) # Expected: 7\n    print(arrayNesting([1])) # Expected: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "566": "```\ndef matrixReshape(mat, r, c):\n    original_rows = len(mat)\n    original_cols = len(mat[0])\n    \n    if original_rows * original_cols != r * c:\n        return mat\n    \n    reshaped_mat = []\n    for i in range(original_rows):\n        row = [item for subrow in mat[i] for item in [subrow[j:j+1][0] for j in range(0,original_cols,c)]]\n        reshaped_mat.append(row)\n    \n    return [list(x) for x in zip(*[iter(reshaped_mat[i]) for i in range(c)])]\n\ndef main():\n    test_case_1 = [[1,2],[3,4]]\n    r1 = 2; c1 = 4\n    print(\"Test Case 1: \")\n    print(matrixReshape(test_case_1, r1, c1))\n    \n    test_case_2 = [[1,2,3,4], [5,6,7,8], [9,10,11,12]]\n    r2 = 3; c2 = 4\n    print(\"\\nTest Case 2: \")\n    print(matrixReshape(test_case_2, r2, c2))\n    \n    test_case_3 = [[1, 2], [3, 4], [5, 6]]\n    r3 = 3; c3 = 2\n    print(\"\\nTest Case 3: \")\n    print(matrixReshape(test_case_3, r3, c3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "567": "```\ndef checkInclusion(candidates, words):\n    for word in words:\n        if len(word) <= len(candidates[0]):\n            continue\n        for i in range(len(word) - len(candidates[0]) + 1):\n            if set(candidates).issubset(set(word[i:i+len(candidates)])):\n                return True\n    return False\n\n\ndef main():\n    test_cases = [\n        {\"candidates\": \"ab\", \"words\": [\"ad\",\"bd\",\"hb\",\"hg\",\"he\",\"eh\"},\n         \"expected_output\": True},\n        {\"candidates\": \"abc\", \"words\": [\"a\",\"b\",\"c\",\"d\"],\n         \"expected_output\": False},\n        {\"candidates\": \"ab\", \"words\": [\"ad\",\"ac\",\"bc\"],\n         \"expected_output\": True}\n    ]\n\n    for test_case in test_cases:\n        candidates = test_case[\"candidates\"]\n        words = test_case[\"words\"]\n        expected_output = test_case[\"expected_output\"]\n\n        output = checkInclusion(candidates, words)\n        if output == expected_output:\n            print(f\"Test case {test_case} passed!\")\n        else:\n            print(f\"Test case {test_case} failed! Expected: {expected_output}, got: {output}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "568": "```\ndef maxVacationDays(book, seq_days):\n    n = len(seq_days)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if book[i - 1][j - 1]:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n            else:\n                dp[i][j] = dp[i-1][j-1]\n                \n    return dp[-1][-1]\n\ndef main():\n    test_case1 = [[0,1],[1,4],[2,3],[2,4]]\n    print(\"Test Case 1: \", maxVacationDays(*zip(*test_case1)), \" days\")\n    \n    test_case2 = [[1,2],[3,4],[5,6]]\n    print(\"Test Case 2: \", maxVacationDays(*zip(*test_case2)), \" days\")\n    \n    test_case3 = [[7,8],[9,10]]\n    print(\"Test Case 3: \", maxVacationDays(*zip(*test_case3)), \" days\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "569": "```\ndef medianSalary(query_id):\n    query_list = [[1, 300], [2, 100], [5, 250], [4, 400]]\n    salary_dict = {}\n    for query in query_list:\n        if query[0] not in salary_dict:\n            salary_dict[query[0]] = []\n        salary_dict[query[0]].append(query[1])\n\n    all_salaries = []\n    for salaries in salary_dict.values():\n        all_salaries += salaries\n\n    all_salaries.sort()\n    n = len(all_salaries)\n    if n % 2 == 1:\n        return all_salaries[n // 2]\n    else:\n        return (all_salaries[n // 2 - 1] + all_salaries[n // 2]) / 2\n\n\ndef main():\n    print(medianSalary(5))  # Expected: 250.0\n    print(medianSalary(4))  # Expected: 400.0\n    print(medianSalary(-1))  # Expected: None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "571": "```\ndef findMedian(nums):\n    nums.sort()\n    total = len(nums)\n    if total % 2 == 1:\n        return nums[total // 2]\n    else:\n        mid1 = nums[total // 2 - 1]\n        mid2 = nums[total // 2]\n        return (mid1 + mid2) / 2\n\ndef main():\n    test_case1 = [2,3,4,5]\n    print(f\"Test case 1: {findMedian(test_case1)}\")\n\n    test_case2 = [1,2,3,4,5]\n    print(f\"Test case 2: {findMedian(test_case2)}\")\n\n    test_case3 = [1,2,2,3,3,3]\n    print(f\"Test case 3: {findMedian(test_case3)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "570": "```\ndef numOfManagementLevel15(root):\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right = dfs(node.right)\n        if node.val <= 5:\n            return left + right + 1\n        else:\n            return 1 if left >= 5 or right >= 5 else 0\n\n    return dfs(root)\n\ndef main():\n    class TreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.left = None\n            self.right = None\n\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    root1.left.right = TreeNode(5)\n    print(numOfManagementLevel15(root1))  # Expected output: 1\n\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n    root2.left.left = TreeNode(4)\n    root2.left.right = TreeNode(5)\n    root2.left.left.left = TreeNode(6)\n    print(numOfManagementLevel15(root2))  # Expected output: 1\n\n    root3 = TreeNode(1)\n    root3.left = TreeNode(2)\n    root3.right = TreeNode(3)\n    root3.left.left = TreeNode(4)\n    root3.left.right = TreeNode(5)\n    root3.left.left.left = TreeNode(6)\n    root3.left.left.right = TreeNode(7)\n    print(numOfManagementLevel15(root3))  # Expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "572": "```\ndef isSubtree(root, subRoot):\n    if not root:\n        return False\n    if isIdentical(root, subRoot):\n        return True\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n\ndef isIdentical(p1, p2):\n    if not p1 and not p2:\n        return True\n    if not p1 or not p2:\n        return False\n    return (p1.val == p2.val) and isIdentified(p1.left, p2.left) and isIdentified(p1.right, p2.right)\n\ndef isIdentified(p1, p2):\n    if not p1 and not p2:\n        return True\n    if not p1 or not p2:\n        return False\n    return (p1.val == p2.val)\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef main():\n    root1 = TreeNode(3)\n    root1.left = TreeNode(4)\n    root1.right = TreeNode(5)\n    root1.left.left = TreeNode(1)\n    root1.left.right = TreeNode(2)\n\n    subRoot1 = TreeNode(4)\n    subRoot1.left = TreeNode(1)\n    subRoot1.right = TreeNode(2)\n\n    print(isSubtree(root1, subRoot1))  # True\n\n    root2 = TreeNode(3)\n    root2.right = TreeNode(4)\n    root2.left = TreeNode(5)\n\n    subRoot2 = TreeNode(4)\n\n    print(isSubtree(root2, subRoot2))  # False\n\n    root3 = TreeNode(1)\n    root3.left = TreeNode(2)\n    root3.right = TreeNode(3)\n\n    subRoot3 = TreeNode(2)\n    subRoot3.right = TreeNode(3)\n\n    print(isSubtree(root3, subRoot3))  # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "573": "```\ndef gcdOfSubArrays(arr):\n    res = arr[0]\n    for i in range(1, len(arr)):\n        res = gcd(res, arr[i])\n    return res\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    print(gcdOfSubArrays([4, 6, 8, 10]) == 2)  # True\n    print(gcdOfSubArrays([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1)  # True\n    print(gcdOfSubArrays([14, 28, 11, 15, 9, 5, 13, 17, 2, 12]) == 1)  # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "574": "```\ndef winning_candidate(logs):\n    from collections import Counter\n\n    logs = [log.split() for log in logs]\n    votes = {name: count for name, *count in [Counter(candidates).most_common() for candidates in zip(*[list(x) for x in logs])]}\n    return max(votes, key=votes.get)\n\ndef main():\n    test_cases = [\n        {\"logs\": [\"John 2\", \"John 1\", \"Jill 2\"], \"expected_result\": \"John\"},\n        {\"logs\": [\"Alice 3\", \"Bob 2\", \"Alice 1\", \"Bob 3\"], \"expected_result\": \"Alice\"},\n        {\"logs\": [\"John 1\", \"Jill 1\", \"John 1\", \"Jane 2\"], \"expected_result\": \"John\"}\n    ]\n\n    for test_case in test_cases:\n        result = winning_candidate(test_case[\"logs\"])\n        if result == test_case[\"expected_result\"]:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed. Expected {test_case['expected_result']}, but got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "575": "```\ndef distributeCandies(candidates):\n    n = len(candidates)\n    res = [0] * (n + 1)\n    \n    for c in candidates:\n        if c % 2 == 1:\n            res[c // 2 + 1] += 1\n        else:\n            res[c // 2] += 1\n    \n    return res\n\ndef main():\n    test_cases = [\n        [1, 3, 2, 5, 3, 4],\n        [1, 1, 2, 2, 3, 3],\n        [6, 7, 8, 9, 10]\n    ]\n\n    for test_case in test_cases:\n        print(\"Test case: \", test_case)\n        result = distributeCandies(test_case)\n        print(\"Result: \", result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "577": "```\ndef get_bonus(employee_info):\n    employees = {}\n    for emp in employee_info:\n        if emp[1] not in employees:\n            employees[emp[1]] = int(emp[0])\n        else:\n            employees[emp[1]].append(int(emp[0]))\n    \n    result = []\n    for bonus, names in employees.items():\n        for i, name in enumerate(names):\n            result.append([name, bonus])\n\n    return result\n\ndef main():\n    test_cases = [\n        [[1, 2], [5, 3], [6, 4]],\n        [[10, 20], [30, 40]],\n        [[100, 200], [300, 400], [500, 600]]\n    ]\n\n    for case in test_cases:\n        print(\"Test Case:\", case)\n        print(get_bonus(case))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "576": "```\ndef findPaths(m, n, startRow, startCol):\n    MOD = int(1e9 + 7)\n    dp = [[[0] * (n + 1) for _ in range(m + 1)]for _ in range(2)]\n    \n    for i in range(2):\n        for j in range(m + 1):\n            for k in range(n + 1):\n                if i == 0 and j > startRow or i == 1 and k > startCol:\n                    dp[i][j][k] = 1\n                elif j > 0 and not (i == 0 and k < n - startCol) and dp[not i][j-1][k]:\n                    dp[i][j][k] |= 1\n                elif k > 0 and not (i == 1 and j < m - startRow) and dp[i][j][k-1]:\n                    dp[i][j][k] |= 1\n    return dp[1][m-1][n-1]\n\ndef main():\n    print(findPaths(2, 3, 0, 1)) # Output: 12\n    print(findPaths(3, 7, 1, 0)) # Output: 28\n    print(findPaths(3, 2, 0, 0)) # Output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "578": "```\ndef highestRatedQuestion(table):\n    return max(table, key=lambda x: (x[2], -x[1]))\n\ndef main():\n    table = [[\"A\", \"11.5\", \"10\"], [\"B\", \"12.0\", \"5\"], [\"C\", \"8.5\", \"3\"]]\n    print(highestRatedQuestion(table))\n\n    table = [[\"Q1\", \"9.4\", \"15\"], [\"Q2\", \"9.1\", \"30\"], [\"Q3\", \"9.7\", \"10\"], [\"Q4\", \"8.6\", \"20\"]]\n    print(highestRatedQuestion(table))\n\n    table = [[\"Question1\", \"8.5\", \"25\"], [\"Question2\", \"9.0\", \"15\"], [\"Question3\", \"9.5\", \"30\"]]\n    print(highestRatedQuestion(table))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "579": "```\ndef totalSalary(e):\n    return e['salary']\n\ndef cumulativeSalary(e, currentSalary=0):\n    if 'from_date' in e:\n        from_date = datetime.datetime.strptime(e['from_date'], \"%Y-%m-%d\")\n        to_date = datetime.datetime.strptime(e['to_date'], \"%Y-%m-%d\")\n\n        if datetime.datetime.now() > to_date:\n            return currentSalary\n        else:\n            return cumulativeSalary(list(filter(lambda x: (datetime.datetime.now() > from_date) & (datetime.datetime.now() < to_date), e))[0], currentSalary + list(map(totalSalary, filter(lambda x: (datetime.datetime.now() > from_date) & (datetime.datetime.now() < to_date), e)))[0]['salary'])\n    else:\n        return currentSalary\n\ndef main():\n    employees = [\n        {'name': 'John', 'from_date': '2022-01-01', 'to_date': '2022-06-30', 'salary': 100000},\n        {'name': 'Jane', 'from_date': '2021-07-01', 'to_date': '2022-12-31', 'salary': 80000},\n        {'name': 'Bob', 'from_date': None, 'to_date': None, 'salary': 70000}\n    ]\n    \n    print(cumulativeSalary(employees[0])) # Should be 100000\n    print(cumulativeSalary(employees[1])) # Should be 180000\n    print(cumulativeSalary(employees[2])) # Should be 140000\n\nif __name__ == \"__main__\":\n    main()\n```",
  "580": "```\ndef countStudentNumberInDepartments(students):\n    department_to_students = {}\n    for student in students:\n        if student['department'] not in department_to_students:\n            department_to_students[student['department']] = 1\n        else:\n            department_to_students[student['department']] += 1\n\n    return department_to_students\n\n\ndef main():\n    students = [\n        {'name': 'Alice', 'department': 'Math'},\n        {'name': 'Bob', 'department': 'Math'},\n        {'name': 'Charlie', 'department': 'Science'}\n    ]\n\n    print(countStudentNumberInDepartments(students))\n\n    # Test case 1\n    students = [\n        {'name': 'Alice', 'department': 'Math'},\n        {'name': 'Bob', 'department': 'Math'},\n        {'name': 'Eve', 'department': 'English'}\n    ]\n    print(countStudentNumberInDepartments(students))\n\n    # Test case 2\n    students = []\n    print(countStudentNumberInDepartments(students))\n\n    # Test case 3\n    students = [\n        {'name': 'Alice', 'department': 'Math'},\n        {'name': 'Bob', 'department': 'Science'},\n        {'name': 'Charlie', 'department': 'Math'}\n    ]\n    print(countStudentNumberInDepartments(students))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "581": "```\ndef findUnsortedContinuousSubarray(nums):\n    n = len(nums)\n    sorted_nums = sorted(nums)\n\n    for i in range(n):\n        if nums[i] != sorted_nums[i]:\n            left, right = i-1, i+1\n            while left >= 0 and nums[left] <= nums[i]:\n                left -= 1\n            while right < n and nums[right] >= nums[i]:\n                right += 1\n\n            return [left + 1, right]\n\n    return [-1, -1]\n\n\ndef main():\n    test_case_1 = [2, 6, 4, 8, 10, 3]\n    print(f\"Test case 1: {findUnsortedContinuousSubarray(test_case_1)}\")\n\n    test_case_2 = [1, 2, 3, 4, 5]\n    print(f\"Test case 2: {findUnsortedContinuousSubarray(test_case_2)}\")\n\n    test_case_3 = [1, 3, 5, 4, 2]\n    print(f\"Test case 3: {findUnsortedContinuousSubarray(test_case_3)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "582": "```\ndef findProcessesToKill(parents):\n    process_map = {}\n    to_kill = set()\n\n    for i in range(len(parents)):\n        if parents[i] != -1:\n            if i not in process_map:\n                process_map[i] = []\n            process_map[i].append(parents[i])\n\n    def dfs(process):\n        if process in to_kill:\n            return\n        to_kill.add(process)\n        for child in process_map.get(process, []):\n            dfs(child)\n\n    for process in process_map:\n        if process not in to_kill:\n            dfs(process)\n\n    return list(to_kill)\n\n\ndef main():\n    parents1 = [-2, 0, 0, 1]\n    print(\"Test Case 1: \", findProcessesToKill(parents1))\n\n    parents2 = [3, 0, 2, 2, 7, -1]\n    print(\"Test Case 2: \", findProcessesToKill(parents2))\n\n    parents3 = [3, 0, 4, 0]\n    print(\"Test Case 3: \", findProcessesToKill(parents3))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "583": "```\ndef minSteps(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[m][n]\n\ndef main():\n    print(minSteps(\"sea\", \"eat\") == 2)\n    print(minSteps(\"leetcode\", \"etco\") == 4)\n    print(minSteps(\"shelter\", \"shingle\") == 3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "584": "```\ndef findCustomerReferee(referee_id):\n    return \"Referee's Customer\"\n\ndef main():\n    print(\"Test case 1:\")\n    print(findCustomerReferee(123), end='\\n\\n')\n\n    print(\"Test case 2:\")\n    print(findCustomerReferee(456), end='\\n\\n')\n\n    print(\"Test case 3:\")\n    print(findCustomerReferee(789))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "585": "```\ndef getAmount(income, expense):\n    if income < expense:\n        return \"No investment\"\n    else:\n        return income - expense\n\ndef main():\n    print(getAmount(1000, 500))   # Test Case 1\n    print(getAmount(2000, 1500))  # Test Case 2\n    print(getAmount(3000, 2500))  # Test Case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "586": "```\ndef largestCustomerOrderCount(customers):\n    return sorted((customer, count) for customer, count in customers.items())[-1][0]\n\ndef main():\n    customers = {\"John\": 2, \"Alice\": 4, \"Bob\": 6, \"Eve\": 8}\n    print(\"The customer with the largest number of orders is:\", largestCustomerOrderCount(customers))\n\n    customers = {\"A\": 10, \"B\": 3, \"C\": 5, \"D\": 1}\n    print(\"\\nThe customer with the largest number of orders is:\", largestCustomerOrderCount(customers))\n\n    customers = {}\n    print(\"\\nThe customer with the largest number of orders is:\", largestCustomerOrderCount(customers))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "587": "```\ndef outerTrees(x1, y1, x2, y2):\n    pass\n\ndef main():\n    print(\"Test Case 1:\")\n    x1, y1, x2, y2 = 0, 0, 1, 1\n    print(outerTrees(x1, y1, x2, y2))\n    \n    print(\"\\nTest Case 2:\")\n    x1, y1, x2, y2 = 3, 4, -5, -7\n    print(outerTrees(x1, y1, x2, y2))\n\n    print(\"\\nTest Case 3:\")\n    x1, y1, x2, y2 = 1.8, 0.9, -3.4, -1.6\n    print(outerTrees(x1, y1, x2, y2))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "588": "```\nclass FileSystem:\n    def __init__(self):\n        self.root = {}\n\n    def create(self, path: str, content: str) -> None:\n        nodes = self.root\n        for dir in path.split('/'):\n            if dir:\n                if dir not in nodes:\n                    nodes[dir] = {}\n                nodes = nodes[dir]\n        nodes['content'] = content\n\n    def get(self, path: str):\n        nodes = self.root\n        for dir in path.split('/'):\n            if dir:\n                nodes = nodes.get(dir, {})\n                if 'content' not in nodes:\n                    return \"\"\n        return nodes.get('content', \"\")\n\ndef main():\n    fs = FileSystem()\n    \n    print(fs.create(\"dir1/file1.txt\", \"Hello\"))\n    print(fs.get(\"dir1/file1.txt\"))  # Should print: Hello\n    print(fs.create(\"dir1/file2.txt\", \"World\"))\n    print(fs.get(\"dir1\"))  # Should print: \"\"\n    print(fs.get(\"dir1/file2.txt\"))  # Should print: World\n\nif __name__ == \"__main__\":\n    main()\n```",
  "589": "```\ndef preorder_traversal(root):\n    if not root:\n        return []\n\n    result = []\n    stack = [(root, False)]\n\n    while stack:\n        node, visited = stack.pop()\n        if visited:\n            result.append(node.val)\n        else:\n            result.append(node.val)\n            for child in node.children[::-1]:\n                stack.append((child, False))\n            stack.append((node, True))\n\n    return result\n\ndef main():\n    class Node:\n        def __init__(self, val=None, children=None):\n            self.val = val\n            self.children = children if children is not None else []\n\n    # Test case 1\n    root1 = Node(1)\n    root1.children = [Node(3), Node(5, [Node(6), Node(7)]), Node(2)]\n    print(preorder_traversal(root1))  # Output: [1, 3, 5, 6, 7, 2]\n\n    # Test case 2\n    root2 = Node(1)\n    root2.children = [Node(2, [Node(4), Node(5)])]\n    print(preorder_traversal(root2))  # Output: [1, 2, 4, 5]\n\n    # Test case 3\n    root3 = Node(1)\n    root3.children = []\n    print(preorder_traversal(root3))  # Output: [1]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "591": "```\ndef validateTagString(s: str) -> bool:\n    stack = []\n    for c in s:\n        if c == '<':\n            stack.append(c)\n        elif c == '>':\n            if len(stack) == 0 or stack.pop() != '<':\n                return False\n        elif c == '/':\n            if len(stack) > 0 and stack[-1] == '<':\n                stack.pop()\n            else:\n                return False\n\n    return len(stack) == 0\n\n\ndef main():\n    print(validateTagString(\"<a></a>\"))   # True\n    print(validateTagString(\"<a></b>\"))  # False\n    print(validateTagString(\"<i<b</i>\"))  # False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "590": "```\ndef postorder_traversal(root):\n    if not root:\n        return []\n\n    result = []\n    stack = [(root, \"right\"), (root.next, None)]\n    \n    while stack:\n        node, direction = stack.pop()\n        \n        if node is None:\n            continue\n            \n        if direction == \"right\":\n            result.append(node.val)\n        elif direction == \"left\" or direction is None:\n            if node.children:\n                for child in reversed(node.children):\n                    stack.append((child, \"right\"))\n                stack.append((node, \"left\"))\n            else:\n                stack.append((None, None))\n        else:\n            if node.children:\n                stack.extend([(child, None) for child in node.children])\n                stack.append((node, \"right\"))\n            else:\n                stack.append((None, None))\n\n    return result\n\n\ndef main():\n    class Node:\n        def __init__(self, val=None, children=None):\n            self.val = val\n            self.children = children if children is not None else []\n\n    # Test case 1\n    root1 = Node(1)\n    node21 = Node(3)\n    node22 = Node(5)\n    node23 = Node(6)\n    node24 = Node(2, [node21, node22, node23])\n    root1.children = [node24]\n    print(postorder_traversal(root1))  # Output: [5, 6, 3, 2, 1]\n\n    # Test case 2\n    root2 = Node(1)\n    node11 = Node(4)\n    node12 = Node(6)\n    node13 = Node(7)\n    node14 = Node(8)\n    node15 = Node(9)\n    node16 = Node(3, [node11, node12])\n    node17 = Node(2, [node13, node14, node15])\n    root2.children = [node16, node17]\n    print(postorder_traversal(root2))  # Output: [9, 8, 7, 6, 4, 3, 2, 1]\n\n    # Test case 3\n    root3 = Node(1)\n    node31 = Node(2)\n    node32 = Node(3)\n    root3.children = [node31]\n    print(postorder_traversal(root3))  # Output: [3, 2, 1]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "592": "```\ndef fractionAddition(c):\n    res = 0\n    i = 0\n    while i < len(c):\n        if c[i].isdigit():\n            j = i + 1\n            while j < len(c) and c[j].isdigit():\n                j += 1\n            k = i - 1\n            while k >= 0 and not c[k].isdigit():\n                k -= 1\n            num = int(c[k+1:j])\n            denom = int(c[i:k])\n            res = res * denom + num\n            i = j\n        else:\n            i += 1\n    gcd = lambda a, b: a if not b else gcd(b, a % b)\n    res = str(res) if res > 0 else '0'\n    g = gcd(abs(int(res.split('/')[0])), int(res.split('/')[-1]))\n    return '/'.join(map(str, [int(i // g) for i in map(int, res.split('/'))])) + '/' + str(g)\n\ndef main():\n    print(fractionAddition(\"1/3+1/2\"))  # 5/6\n    print(fractionAddition(\"1/9-2/3+2/4\"))  # 32/63\n    print(fractionAddition(\"1/6+1/2\"))  # 5/3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "593": "```\ndef validSquare(side1, side2, side3, side4):\n    if (side1 == 0 or side2 == 0 or side3 == 0 or side4 == 0) and sum([s**2 for s in [side1, side2, side3, side4]]) != 0:\n        return False\n\n    sides = sorted([side1, side2, side3, side4])\n\n    if sides[0] * sides[0] + sides[1] * sides[1] == sides[2] * sides[2] or sides[0] * sides[0] + sides[3] * sides[3] == sides[2] * sides[2]:\n        return True\n    else:\n        return False\n\ndef main():\n    print(validSquare(3, 1, 1, 1)) #True\n    print(validSquare(0, 3, 3, 6)) #False\n    print(validSquare(5, 5, 3, 3)) #True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "594": "```\ndef findLHS(nums):\n    freq = {}\n    for num in nums:\n        if num not in freq:\n            freq[num] = 1\n        else:\n            freq[num] += 1\n    \n    max_length = 0\n    prev_num = None\n    for num, count in sorted(freq.items()):\n        if prev_num is not None and num - prev_num == 1:\n            max_length = max(max_length, count + freq.get(num + 1, 0))\n        prev_num = num\n    \n    return max_length\n\ndef main():\n    print(findLHS([1,3,2,2,5,2,4,1])) # Output: 5\n    print(findLHS([1,1,1,1])) # Output: 6\n    print(findLHS([7,7,7])) # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "595": "```\ndef countries_larger_than(self, country_name):\n    pass\n\ndef main():\n    problem = BigCountries()\n    print(\"Test case 1: China\")\n    result = problem.countries_larger_than(\"China\")\n    if result:\n        print(\"Expected true, got\", result)\n    else:\n        print(\"Expected false, got\", result)\n\n    print(\"\\nTest case 2: Mexico\")\n    result = problem.countries_larger_than(\"Mexico\")\n    if not result:\n        print(\"Expected false, got\", result)\n    else:\n        print(\"Expected true, got\", result)\n\n    print(\"\\nTest case 3: Bhutan\")\n    result = problem.countries_larger_than(\"Bhutan\")\n    if not result:\n        print(\"Expected false, got\", result)\n    else:\n        print(\"Expected true, got\", result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "596": "```\ndef countClasses(students):\n    return len({student[1] for student in students})\n\ndef main():\n    test_cases = [\n        {\"id\": 1, \"class\": \"A\"}, {\"id\": 2, \"class\": \"B\"}, {\"id\": 3, \"class\": \"C\"},\n        {\"id\": 4, \"class\": \"D\"}, {\"id\": 5, \"class\": \"E\"}, {\"id\": 6, \"class\": \"F\"}\n    ],\n        [\n            {\"id\": 1, \"class\": \"A\"}, {\"id\": 2, \"class\": \"B\"}, {\"id\": 3, \"class\": \"C\"},\n            {\"id\": 4, \"class\": \"D\"}\n        ],\n        [\n            {\"id\": 1, \"class\": \"A\"}, {\"id\": 2, \"class\": \"A\"}, {\"id\": 3, \"class\": \"B\"},\n            {\"id\": 4, \"class\": \"C\"}, {\"id\": 5, \"class\": \"D\"}\n        ]\n    ]\n\n    for test_case in test_cases:\n        print(\"Test Case:\", test_case)\n        result = countClasses(test_case)\n        if result > 5:\n            print(\"Expected: False, Got: True\")\n        else:\n            print(\"Expected: True, Got: \", result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "597": "```\ndef averageAcceptanceRate(requests):\n    acceptances = [1 if x == \"Accepted\" else 0 for x in requests]\n    return sum(acceptances) / len(requests)\n\ndef main():\n    print(\"Test case 1:\")\n    print(f\"Acceptance rate: {averageAcceptanceRate(['Pending', 'Rejected', 'Accepted'])}\")\n\n    print(\"\\nTest case 2:\")\n    print(f\"Acceptance rate: {averageAcceptanceRate(['Accepted', 'Accepted', 'Rejected'])}\")\n\n    print(\"\\nTest case 3:\")\n    print(f\"Acceptance rate: {averageAcceptanceRate(['Rejected', 'Rejected', 'Rejected'])}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "598": "```\ndef subArrayRanges(nums):\n    n = len(nums)\n    ans = [0] * (n + 1)\n\n    for i in range(n):\n        min_val = nums[i]\n        max_val = nums[i]\n        total = nums[i]\n\n        for j in range(i, n):\n            min_val = min(min_val, nums[j])\n            max_val = max(max_val, nums[j])\n            total += nums[j]\n            ans[j + 1] = (max_val - min_val) * total\n\ndef main():\n    test_cases = [\n        ([-3,2,-5,4], 13),\n        ([1,10,9,-7,-8,10,6], 29),\n        ([0,0,0,0], 0)\n    ]\n\n    for nums, expected in test_cases:\n        result = subArrayRanges(nums)\n        print(f\"Input: {nums}, Expected: {expected}, Result: {result[-1]}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "599": "```\ndef twoSumIndex(list1, list2):\n    hash_map = {}\n    for i, num in enumerate(list1):\n        if num in hash_map:\n            return [hash_map[num], i]\n        else:\n            hash_map[num] = i\n    return [-1, -1]\n\ndef main():\n    print(twoSumIndex([0, 3, 5, 8, 9], [2, 7, 6, 1, 4]))\n    print(twoSumIndex([1, 7], [3, 2]))\n    print(twoSumIndex([1, 3, 1], [1, 3, 2]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "600": "```\ndef findMaxLength(nums):\n    n = len(nums)\n    max_len = 0\n    count = 0\n    table = {0: -1}\n    for i in range(n):\n        if nums[i] == 0:\n            count -= 1\n        else:\n            count += 1\n        if count in table:\n            max_len = max(max_len, i - table[count])\n        else:\n            table[count] = i\n    return max_len\n\ndef main():\n    print(findMaxLength([0,1])) # Test case 1: Output: 2\n    print(findMaxLength([0,1,0,1])) # Test case 2: Output: 4\n    print(findMaxLength([0,0,1,1,0,1,1])) # Test case 3: Output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "601": "```\ndef totalTravelTime(trips):\n    return sum(len(t['start']) + len(t['end']) for t in trips)\n\ndef main():\n    print(totalTravelTime([{\"start\": \"7:45\", \"end\": \"8:30\"}, {\"start\": \"9:00\", \"end\": \"10:45\"}]))  # Test case 1\n    print(totalTravelTime([{\"start\": \"12:15\", \"end\": \"13:00\"}, {\"start\": \"14:30\", \"end\": \"15:15\"}]))  # Test case 2\n    print(totalTravelTime([{\"start\": \"9:45\", \"end\": \"10:30\"}, {\"start\": \"11:15\", \"end\": \"12:00\"}]))  # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "603": "```\ndef consecutiveAvailableSeats(n, firstRowSeats):\n    return [str(i) for i in range(1, n+1) if str(i) not in firstRowSeats]\n\ndef main():\n    print(consecutiveAvailableSeats(5, [\"A\", \"C\"]))  # Expected: ['B']\n    print(consecutiveAvailableSeats(8, []))  # Expected: ['1', '2', '3', '4', '5', '6', '7']\n    print(consecutiveAvailableSeats(10, [\"F\", \"G\", \"H\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "602": "```\ndef totalFriendRequests(time, requests):\n    graph = {}\n    for request in requests:\n        if request[0] not in graph:\n            graph[request[0]] = []\n        if request[1] not in graph:\n            graph[request[1]] = []\n        graph[request[0]].append(request[1])\n        graph[request[1]].append(request[0])\n\n    def dfs(node, visited, friend_count):\n        visited.add(node)\n        return 1 + sum(dfs(neigh, visited, friend_count) for neigh in graph[node] if neigh not in visited)\n\n    max_friend_count = 0\n    for node in graph:\n        visited = set()\n        max_friend_count = max(max_friend_count, dfs(node, visited, 0))\n\n    return max_friend_count\n\ndef main():\n    print(totalFriendRequests([1,2],[1,3],[2,3]))\n    print(totalFriendRequests([1,2,5,4,7,8,9,6,10,3,11,12,13,14,15], [5,4,7,8,9,6,10,3,11,12,13,14,15,16,17],[1,3],[4,2],[7,8],[9,6],[3,11],[12,13],[14,15],[16,17]))\n    print(totalFriendRequests([1],[]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "604": "```\nclass StringIterator:\n    def __init__(self, compressedString: str):\n        self.s = compressedString\n        self.index = 0\n\n    def next(self) -> str:\n        if not self.hasNext():\n            return \"\"\n        charCount = ''\n        while self.index < len(self.s) and (not charCount or not self.s[self.index].isdigit()):\n            if self.s[self.index]:\n                charCount += self.s[self.index]\n            self.index += 1\n        count = int(charCount)\n        self.index += 1\n        return chr(int(self.s[self.index])) * count\n\n    def hasNext(self) -> bool:\n        while self.index < len(self.s):\n            if not self.s[self.index].isalnum():\n                break\n            if not self.s[self.index].isdigit():\n                return True\n            if self.index == len(self.s) - 1 or not self.s[self.index + 1].isdigit():\n                return True\n            self.index += 1\n        return False\n\ndef main():\n    s = StringIterator(\"L1e2t3c4o5d6\")\n    print(s.next()) # \"L\"\n    print(s.next()) # \"leet2code3\"\n    print(s.hasNext()) # true\n    print(s.next()) # \"do\"\n    print(!s.hasNext()) # false\n\nif __name__ == \"__main__\":\n    main()\n```",
  "605": "```\ndef canPlaceFlowers(flowerbed, n):\n    length = len(flowerbed)\n    for i in range(length):\n        if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == length - 1 or flowerbed[i+1] == 0):\n            flowerbed[i] = 1\n            n -= 1\n    return n <= 0\n\n\ndef main():\n    test_cases = [\n        {\"flowerbed\": [1,0,2,0,1], \"expected_result\": 0},\n        {\"flowerbed\": [1,0,0,0,1], \"expected_result\": 3},\n        {\"flowerbed\": [0,0,0,0,1], \"expected_result\": 4}\n    ]\n\n    for test_case in test_cases:\n        if canPlaceFlowers(test_case[\"flowerbed\"], test_case[\"expected_result\"]) == test_case[\"expected_result\"]:\n            print(\"Test case passed: {}\".format(test_case))\n        else:\n            print(\"Test case failed: {}\".format(test_case))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "606": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef tree2str(t):\n    if not t:\n        return ''\n    if not t.left and not t.right:\n        return str(t.val)\n    if not t.right:\n        return str(t.val) + '(' + tree2str(t.left) + ')'\n    return str(t.val) + '(' + tree2str(t.left) + ')' + '(' + tree2str(t.right) + ')'\n\ndef main():\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(5)\n\n    print(tree2str(root))\n\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n\n    print(tree2str(root))\n\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n\n    print(tree2str(root))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "607": "```\ndef calculateSalesPerson(data):\n    # Your solution here\n    pass\n\n\ndef main():\n    data = [(\"John\", \"A\"), (\"Jane\", \"B\"), (\"Alice\", \"A\")]\n    for name, team in data:\n        print(f\"Name: {name}, Team: {team}\")\n\n    result1 = calculateSalesPerson([(\"John\", \"A\")])\n    print(f\"Test Case 1: {result1}\")\n\n    result2 = calculateSalesPerson([(\"Jane\", \"B\"), (\"Alice\", \"A\")])\n    print(f\"Test Case 2: {result2}\")\n\n    result3 = calculateSalesPerson([(\"John\", \"A\"), (\"Jane\", \"B\"), (\"Bob\", \"C\")])\n    print(f\"Test Case 3: {result3}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "608": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef isSymmetric(root):\n    if root is None:\n        return True\n    \n    return isMirror(root, root)\n\ndef isMirror(t1, t2):\n    if t1 is None and t2 is None:\n        return True\n    if t1 is None or t2 is None:\n        return False\n    return (t1.val == t2.val) and isMirror(t1.right, t2.left) and isMirror(t1.left, t2.right)\n\ndef main():\n    # Test case 1: Symmetric tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(3)\n\n    print(isSymmetric(root))  # Expected output: True\n\n    # Test case 2: Asymmetric tree\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n\n    print(isSymmetric(root))  # Expected output: False\n\n    # Test case 3: Empty tree\n    print(isSymmetric(None))  # Expected output: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "609": "```\ndef findDuplicate(paths):\n    files = {}\n    for path in paths:\n        file_name = path.split('/')[-1]\n        if file_name not in files:\n            files[file_name] = [path]\n        else:\n            files[file_name].append(path)\n    \n    duplicate_files = [file for file, paths in files.items() if len(paths) > 1]\n\n    return duplicate_files\n\ndef main():\n    paths = ['/mnt/superman.txt', '/mnt/man_of_steel.txt', '/mnt/superman.txt', '/mnt/justice_league.txt']\n    print(findDuplicate(paths))\n\n    paths = ['/home/user/file.txt', '/home/user/file.txt', '/home/user/file2.txt', '/home/user/other_file.txt']\n    print(findDuplicate(paths))\n\n    paths = ['/a/b/c.txt', '/a/b/d.txt', '/a/b/c.txt', '/c/f.txt']\n    print(findDuplicate(paths))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "610": "```\ndef validTriangle(num1, num2, num3):\n    return num1 + num2 > num3 and num1 + num3 > num2 and num2 + num3 > num1\n\ndef main():\n    print(validTriangle(1, 2, 3)) # Test case 1: A valid triangle with sides 1, 2, and 3.\n    print(validTriangle(4, 5, 6)) # Test case 2: Another valid triangle with sides 4, 5, and 6.\n    print(validTriangle(9, 2, 5)) # Test case 3: A non-valid triangle with sides 9, 2, and 5.\n\nif __name__ == \"__main__\":\n    main()\n```",
  "611": "```\ndef triangleNumber(nums):\n    nums.sort()\n    for i in range(len(nums) - 2):\n        k = i + 2\n        for j in range(i + 1, len(nums) - 1):\n            while k < len(nums) and nums[j] + nums[i] > nums[k]:\n                k += 1\n            if k > j:\n                return True\n    return False\n\ndef main():\n    print(triangleNumber([2,3,4])) # expected: True\n    print(triangleNumber([5,7,11])) # expected: True\n    print(triangleNumber([13,15,17])) # expected: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "612": "```\ndef findShortestDistance(points):\n    if len(points) < 2:\n        return 0\n    \n    min_distance = float('inf')\n    \n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            distance = calculateDistance(points[i], points[j])\n            min_distance = min(min_distance, distance)\n    \n    return min_distance\n\n\ndef calculateDistance(point1, point2):\n    return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)**0.5\n\n\ndef main():\n    test_cases = [\n        {\"points\": [[1, 3], [3, 1]], \"expected_output\": 2.8284271247461903},\n        {\"points\": [[0, 1], [2, 4]], \"expected_output\": 5.0},\n        {\"points\": [[0, 0], [1, 1]], \"expected_output\": 1.4142135623730951}\n    ]\n\n    for test_case in test_cases:\n        actual_output = findShortestDistance(test_case[\"points\"])\n        if abs(actual_output - test_case[\"expected_output\"]) > 1e-6:\n            print(f\"Test case failed: {test_case}\")\n            print(f\"Expected: {test_case['expected_output']}, got: {actual_output}\")\n        else:\n            print(f\"Test case passed: {test_case}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "613": "```\ndef shortest_distance(points):\n    points.sort(key=lambda x: x[0])\n    min_distance = float('inf')\n    for i in range(1, len(points)):\n        distance = (points[i][0] - points[i-1][0]) ** 2\n        if distance < min_distance:\n            min_distance = distance\n    return int(min_distance) ** 0.5\n\ndef main():\n    print(shortest_distance([[1,3], [4,8]])) # Expected output: 3\n    print(shortest_distance([[3,24], [15,25], [52,74], [31,44], [40,91]])) # Expected output: 17\n    print(shortest_distance([[0,2],[5,20],[4,10]])) # Expected output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "614": "```\ndef secondDegreeFollower( edges):\n    graph = {}\n    for edge in edges:\n        if edge[0] not in graph:\n            graph[edge[0]] = []\n        if edge[1] not in graph:\n            graph[edge[1]] = []\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    def dfs(node, visited):\n        if node not in visited:\n            visited.add(node)\n            for neighbor in graph[node]:\n                dfs(neighbor, visited)\n\n    result = set()\n    for node in graph:\n        temp = set()\n        dfs(node, temp)\n        result.update(temp)\n\n    return list(result)\n\n\ndef main():\n    edges1 = [[0, 1], [1, 2], [2, 3]]\n    print(secondDegreeFollower(edges1))  \n\n    edges2 = [[0, 1], [1, 2], [2, 4], [3, 4]]\n    print(secondDegreeFollower(edges2)) \n\n    edges3 = [[0, 1], [1, 2], [2, 0], [0, 3]]\n    print(secondDegreeFollower(edges3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "615": "```\ndef averageSalary(salary):\n    departmentalAverage = {}\n    for i in salary:\n        if i[1] not in departmentalAverage:\n            departmentalAverage[i[1]] = [0, 0]\n        departmentalAverage[i[1]][0] += i[2]\n        departmentalAverage[i[1]][1] += 1\n    return [[k, v[0]/v[1]] for k, v in departmentalAverage.items()]\n\ndef main():\n    salary = [[\"i\", \"google\", 100000],\n              [\"ii\", \"apple\", 200000],\n              [\"iii\", \"facebook\", 150000],\n              [\"iv\", \"google\", 250000],\n              [\"v\", \"apple\", 300000],\n              [\"vi\", \"facebook\", 400000]]\n    print(averageSalary(salary))\n    \n    salary = [[\"1\", \"amazon\", 10000],\n              [\"2\", \"amazon\", 20000],\n              [\"3\", \"amazon\", 15000],\n              [\"4\", \"apple\", 30000],\n              [\"5\", \"apple\", 25000]]\n    print(averageSalary(salary))\n    \n    salary = [[\"1\", \"google\", 1000],\n              [\"2\", \"google\", 2000],\n              [\"3\", \"facebook\", 5000]]\n    print(averageSalary(salary))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "616": "```\ndef addBoldTag(s: str, wordDict: list[str]) -> str:\n    # your implementation here\n    pass\n\ndef main():\n    for s in [\"aaabbsss\", [\"badc\", \"dog\", \"dad\", \"good\"]]:\n        result = addBoldTag(*s)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "617": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef mergeTrees(t1, t2):\n    if not t1:\n        return t2\n    if not t2:\n        return t1\n    \n    t1.val += t2.val\n    t1.left = mergeTrees(t1.left, t2.left)\n    t1.right = mergeTrees(t1.right, t2.right)\n    \n    if not t1.left and not t1.right:\n        t1.val -= 1\n        temp = TreeNode(0)\n        temp.right = t1\n        return temp\n    \n    return t1\n\ndef printTree(node):\n    def treewalker(node, level=0):\n        if node is None:\n            return\n        treewalker(node.right, level + 1)\n        print(' ' * 4 * level + '->', node.val)\n        treewalker(node.left, level + 1)\n\ndef main():\n    t1 = TreeNode(1)\n    t1.left = TreeNode(3)\n    t1.right = TreeNode(2)\n    t1.left.left = TreeNode(5)\n    t1.left.right = TreeNode(4)\n\n    t2 = TreeNode(2)\n    t2.left = TreeNode(1)\n    t2.right = TreeNode(3)\n    \n    print(\"Tree 1:\")\n    printTree(t1)\n    print()\n    \n    print(\"Tree 2:\")\n    printTree(t2)\n    print()\n\n    result = mergeTrees(t1, t2)\n\n    print(\"Merged Tree:\")\n    printTree(result)\n\nif __name__ == \"__main__\":\n    main()",
  "618": "```\ndef getReport(schools):\n    reports = {}\n    for school in schools:\n        for student in school['students']:\n            if student['geography'] not in reports:\n                reports[student['geography']] = []\n            reports[student['geography']].append(student)\n    return {k: len(v) for k, v in reports.items()}\n\ndef main():\n    test_cases = [\n        {\n            \"schools\": [\n                {\"students\": [{\"name\": \"Alice\", \"geography\": \"North\"}, {\"name\": \"Bob\", \"geography\": \"South\"}]},\n                {\"students\": [{\"name\": \"Charlie\", \"geography\": \"East\"}, {\"name\": \"David\", \"geography\": \"West\"}]}\n            ]\n        },\n        {\n            \"schools\": [\n                {\"students\": [{\"name\": \"Eve\", \"geography\": \"North\"}, {\"name\": \"Frank\", \"geography\": \"South\"}]},\n                {\"students\": [{\"name\": \"Gina\", \"geography\": \"East\"}, {\"name\": \"Hank\", \"geography\": \"West\"}]}\n            ]\n        },\n        {\n            \"schools\": [\n                {\"students\": []},\n                {\"students\": [{\"name\": \"Ivan\", \"geography\": \"North\"}]}\n            ]\n        }\n    ]\n\n    for test_case in test_cases:\n        print(\"Test Case:\")\n        result = getReport(test_case[\"schools\"])\n        print(result)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "619": "```\ndef maxNumber(nums):\n    if not nums:\n        return 0\n    max_num = num = 0\n    for n in nums:\n        if str(n).isdigit():\n            max_num = max(max_num, int(n))\n    return max_num\n\ndef main():\n    print(\"Test case 1: \", maxNumber([12, 34]))\n    print(\"Test case 2: \", maxNumber(['123', '456']))\n    print(\"Test case 3: \", maxNumber(['a', 'b']))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "620": "```\ndef getNotBoringMovies(movies):\n    result = []\n    for movie in movies:\n        if len(movie[1]) > 0:\n            result.append(movie)\n    return result\n\ndef main():\n    movies = [\n        [\"The Shawshank Redemption\", \"Drama\"],\n        [\"Inception\", \"Action\", \"Sci-Fi\"],\n        [\"The Matrix\", \"Action\", \"Sci-Fi\"],\n        [\"Not Boring Movie\", \"\"],\n        [\"Another Not Boring Movie\", \"Drama\"]\n    ]\n\n    print(\"Test 1:\")\n    print(getNotBoringMovies(movies))\n    \n    movies = [\n        [\"Movie A\", \"Comedy\"],\n        [\"Movie B\", \"Thriller\"],\n        [\"Movie C\", \"Documentary\"]\n    ]\n\n    print(\"\\nTest 2:\")\n    print(getNotBoringMovies(movies))\n\n    movies = [\n        [\"Movie X\", \"\"],\n        [\"Movie Y\", \"Action\"],\n        [\"Movie Z\", \"Comedy\"],\n        [\"Movie W\", \"\"]\n    ]\n\n    print(\"\\nTest 3:\")\n    print(getNotBoringMovies(movies))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "621": "```\ndef leastInterval(tasks, n):\n    if not tasks:\n        return 0\n\n    max_count = max([tasks.count(task) for task in set(tasks)])\n    idle_time = (max_count - 1) * n\n    remaining_tasks = len(tasks) - max_count\n    if remaining_tasks > 0:\n        idle_time += max(0, idle_time // (max_count - 1))\n\n    return max(len(tasks), idle_time)\n\ndef main():\n    print(leastInterval([\"A\", \"A\", \"A\", \"B\", \"C\", \"D\"], 2)) \n    print(leastInterval([\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"], 2))\n    print(leastInterval([\"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"C\", \"D\", \"E\"], 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "622": "```\nclass MyCircularQueue:\n    def __init__(self, k: int):\n        self.queue = [0] * (k+1)\n        self.head = 0\n        self.tail = 0\n\n    def enQueue(self, value: int) -> bool:\n        if ((self.tail + 1) % len(self.queue) == self.head):\n            return False\n        self.queue[self.tail] = value\n        self.tail = (self.tail + 1) % len(self.queue)\n        return True\n\n    def deQueue(self) -> bool:\n        if (self.head == self.tail):\n            return False\n        self.queue[self.head] = 0\n        self.head = (self.head + 1) % len(self.queue)\n        return True\n\n    def Front(self) -> int:\n        if (self.head == self.tail):\n            return -1\n        return self.queue[self.head]\n\n    def Rear(self) -> int:\n        if (self.head == self.tail):\n            return -1\n        return self.queue[(self.tail - 1) % len(self.queue)]\n\n    def isEmpty(self) -> bool:\n        return (self.head == self.tail)\n\n    def isFull(self) -> bool:\n        return ((self.tail + 1) % len(self.queue) == self.head)\n\n\ndef main():\n    mcq = MyCircularQueue(3)\n    \n    print(mcq.enQueue(2))       # returns true\n    print(mcq.enQueue(1))       # returns true\n    print(mcq.enQueue(99))      # returns true\n    \n    print(mcq.Rear())           # return 2\n    \n    print(mcq.deQueue())        # returns true\n    print(mcq.Front())          # return 1\n    \n    print(mcq.enQueue(4))       # returns true\n    print(mcq.isFull())         # returns false\n    \n    mcq = MyCircularQueue(8)\n    \n    print(mcq.enQueue(5))       # returns true\n    print(mcq.Rear())           # return 5\n    \n    print(mcq.deQueue())        # returns true\n    print(mcq.isEmpty())        # returns false\n\nif __name__ == \"__main__\":\n    main()\n```",
  "623": "```\nclass Solution:\n    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:\n        if not root:\n            return TreeNode(val)\n        elif val < root.val:\n            root.left = self.insertIntoBST(root.left, val)\n        else:\n            root.right = self.insertIntoBST(root.right, val)\n        return root\n\n    def printTree(self, node):\n        if node:\n            print(node.val)\n            self.printTree(node.left)\n            self.printTree(node.right)\n\ndef main():\n    solution = Solution()\n    \n    # Test case 1\n    root1 = TreeNode(4)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(6)\n    root1.left.left = TreeNode(1)\n    root1.left.right = TreeNode(3)\n    print(\"Test case 1:\")\n    solution.printTree(solution.insertIntoBST(None, 5))\n    \n    # Test case 2\n    root2 = TreeNode(0)\n    print(\"Test case 2:\")\n    solution.printTree(solution.insertIntoBST(root2, 1))\n    \n    # Test case 3\n    root3 = None\n    print(\"Test case 3:\")\n    solution.printTree(solution.insertIntoBST(root3, 4))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "624": "```\ndef maxDistance(nums1, nums2):\n    m = len(nums1)\n    n = len(nums2)\n    i, j = 0, 0\n    res = 0\n    while i < m and j < n:\n        if nums1[i] == nums2[j]:\n            res = max(res, abs(i-j))\n            i += 1\n            j += 1\n        elif nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n    return res\n\ndef main():\n    print(maxDistance([3,4,17,28], [2,7,17,28,30])) # Expected output: 3\n    print(maxDistance([19,70,80,9,11,18], [5,15,25,35,45,55])) # Expected output: 6\n    print(maxDistance([1,4,8,10,20,0,100000], [3,8,21,23,33,42,50])) # Expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "625": "```\ndef minFactorization(N):\n    if N == 1:\n        return [1]\n\n    factors = []\n    i = 2\n    while i * i <= N:\n        if N % i:\n            i += 1\n        else:\n            N //= i\n            factors.append(i)\n    if N > 1:\n        factors.append(N)\n\n    return factors\n\ndef main():\n    print(minFactorization(24)) # [2, 3]\n    print(minFactorization(220)) # [2, 2, 5, 11]\n    print(minFactorization(37)) # [37]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "626": "```\ndef exchangeSeats(seats):\n    seat_map = {}\n    for i, seat in enumerate(seats):\n        if seat == 'A':\n            seat_map[seat] = [seats[i+1], seats[i-1]]\n        else:\n            seat_map[seat] = [seats[i-1], seats[i+1]]\n\n    return list(seat_map.values())\n\ndef main():\n    print(exchangeSeats(['A', 'A', 'C', 'B']))\n    print(exchangeSeats(['C', 'A', 'F', 'E', 'S', 'D', 'H', 'G', 'K', 'J']))\n    print(exchangeSeats(['A', 'B', 'C']))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "627": "```\ndef swapSalary(self, salary: List[int]) -> List[int]:\n    return [salary[1], salary[0]]\n\ndef main():\n    print(swapSalary([100, 200]))  # Expected Output: [200, 100]\n    print(swapSalary([1, 2]))       # Expected Output: [2, 1]\n    print(swapSalary([3, 4]))        # Expected Output: [4, 3]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "628": "```\ndef maximumProduct(nums):\n    nums.sort()\n    return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])\n\ndef main():\n    print(maximumProduct([1, 2, 3, 4])) \n    print(maximumProduct([-1, -2, 0, 3])) \n    print(maximumProduct([-1, -10, 0, 2]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "629": "```\ndef findPairs(nums, k):\n    if len(nums) < 2:\n        return []\n    num_set = set()\n    result = []\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            diff = nums[j] - nums[i]\n            if diff == k and (k, j-i) not in num_set:\n                result.append((i, j))\n                num_set.add((k, j-i))\n    return result\n\ndef main():\n    print(findPairs([1,2,3], 1))  # [[0,1]]\n    print(findPairs([1,3,5,40], 3) )  # [[0,2],[1,2]]\n    print(findPairs([1,5,9,10,15,28], 3))  # [[0,2],[6,4]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "630": "```\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: x[1])\n    pq = []\n    cur_time = 0\n    for course in courses:\n        if cur_time + course[1] <= course[0]:\n            heapq.heappush(pq, -course[1])\n            cur_time += course[1]\n        else:\n            while pq and -pq[0] > course[1]:\n                heapq.heappop(pq)\n                cur_time -= -heapq.heappop(pq)\n            if len(pq) < 5:\n                heapq.heappush(pq, -course[1])\n                cur_time += course[1]\n            else:\n                return []\n    return [abs(x) for x in pq]\n\ndef main():\n    print(scheduleCourse([[1002,50],[1200,30],[820,85],[931,27],[896,51],[937,37],[962,19]]))  # Expected: [[850], [1314]]\n    print(scheduleCourse([[1,4],[3,2],[5,1]]))  # Expected: []\n    print(scheduleCourse([[1,2],[3,2],[6,1]]))  # Expected: [[1,2]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "631": "```\ndef calculateFormula(board):\n    formulaMap = {}\n    rowSum = {}\n\n    for i in range(len(board)):\n        for j in range(len(board[i])):\n            if board[i][j].isupper():\n                formulaMap[board[i][j]] = []\n                for k in range(i+1, len(board)):\n                    formulaMap[board[i][j]].append((k, j))\n            elif not board[i][j].isdigit() and board[i][j] != '=':\n                rowSum[board[i][j]] = sum([int(x) for x in [str(y) for y in board[i]]])\n\n    def evaluateFormula(formula):\n        stack = []\n        currentNumber = ''\n        for char in formula:\n            if char.isdigit():\n                currentNumber += str(char)\n            elif char == '+':\n                stack.append(int(currentNumber))\n                currentNumber = ''\n            elif char == '-':\n                stack.append(-int(currentNumber))\n                currentNumber = ''\n            elif char == '=':\n                return sum(stack)\n\n    def calculateValue(row):\n        if row not in rowSum:\n            for cell in board[row]:\n                if cell.isupper():\n                    rowSum[row] = evaluateFormula(''.join([str(x) for x in [cell] + [''] * (len(board[0]) - 1)]))\n                    break\n        return rowSum[row]\n\n    result = []\n    for i in range(len(board)):\n        result.append(calculateValue(i))\n\n    return result\n\n\ndef main():\n    board1 = [['A001', 'B002'], ['A003', 'B004']]\n    print(calculateFormula(board1))  # Expected output: [3, 7]\n\n    board2 = [['=SUM(A1:A10)', 'B002'], ['A003', 'B004']]\n    print(calculateFormula(board2))  # Expected output: [-5, 7]\n\n    board3 = [['A001', '=SUM(B1:B2)'], ['A003', 'B004']]\n    print(calculateFormula(board3))  # Expected output: [4, 7]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "632": "```\nimport heapq\n\ndef kSmallestPairs(nums1, nums2, k):\n    heap = []\n    for i in range(min(len(nums1), len(nums2))):\n        if nums1[i] < nums2[i]:\n            heapq.heappush(heap, (nums1[i], 0, i))\n        elif nums2[i] < nums1[i]:\n            heapq.heappush(heap, (nums2[i], 1, i))\n    pairs = []\n    while heap and len(pairs) < k:\n        val, list_num, index = heapq.heappop(heap)\n        if list_num == 0:\n            pairs.append((index, nums2[index]))\n            if index + 1 < len(nums1):\n                heapq.heappush(heap, (nums1[index + 1], 0, index + 1))\n        else:\n            pairs.append((index, nums1[index]))\n            if index + 1 < len(nums2):\n                heapq.heappush(heap, (nums2[index + 1], 1, index + 1))\n    return pairs\n\ndef main():\n    print(kSmallestPairs([[1,5],[1,5]], 3)) # [[1,1]]\n    print(kSmallestPairs([[1,2,3],[1,2,3,4,5]], 3)) # [[1,1],[1,2],[2,3]]\n    print(kSmallestPairs([[-5]], [10], 3)) # [[-5,10]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "633": "```\ndef judgeSquareSum(integers):\n    for num in integers:\n        square_root = int(num**0.5)\n        if square_root * square_root == num:\n            return True\n    return False\n\ndef sum_of_square_numbers(c, r):\n    left, right = 0, c\n    while left <= right:\n        mid_left_squared = left ** 2\n        mid_right_squared = right ** 2\n        total = mid_left_squared + mid_right_squared\n        if total == r:\n            return True\n        elif total < r:\n            left += 1\n        else:\n            right -= 1\n    return False\n\ndef main():\n    print(sum_of_square_numbers(12, 13)) # Test case 1: Expected output = True\n    print(sum_of_square_numbers(2, 2))   # Test case 2: Expected output = True\n    print(sum_of_square_numbers(3, 15))  # Test case 3: Expected output = False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "634": "```\ndef findDerangement(n):\n    if n == 1:\n        return 0\n    dp = [0]*(n+1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        dp[i] = (i-1)*(dp[i-1]+1)\n    return dp[n]\n\ndef main():\n    print(findDerangement(3) == 2) \n    print(findDerangement(4) == 9) \n    print(findDerangement(5) == 44)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "635": "```\ndef main():\n    logSystem = LogSystem()\n    \n    print(\"Test Case 1:\")\n    logSystem.write('1:*')\n    print(logSystem.get(1))\n    \n    logSystem.write('2:*****')\n    print(logSystem.get(2))\n    \n    print(\"Test Case 2:\")\n    logSystem.write('4:**')\n    print(logSystem.get(3))\n    print(logSystem.get(5))\n    \n    print(\"Test Case 3:\")\n    logSystem.write('10:*')\n    print(logSystem.get(1))\n    print(logSystem.get(8))\n\nclass LogSystem:\n    def __init__(self):\n        self.logs = {}\n\n    def write(self, s: str) -> None:\n        num, level = int(s.split(\":\")[0]), len(s.split(\":\")[1])\n        if num not in self.logs or level > len(self.logs[num]):\n            self.logs[num] = level\n\n    def get(self, num: int) -> str:\n        return \"*\" * self.logs.get(num, 0)\n```",
  "636": "```\ndef exclusiveTimeOutFunction(log):\n    stack = [[0, 0]]\n    result = {}\n    for log in log:\n        id, type, time = map(int, log.split())\n        if type == 1: \n            stack.append([time, stack[-1][1]])\n        elif type == 3: \n            lastTime, _ = stack.pop()\n            result[stack[-1][0]] += time - lastTime\n    return list(result.values())\n\ndef main():\n    log = [[0,1], [1,2], [2,1]]\n    print(exclusiveTimeOutFunction(log))\n    \n    log = [[0,2], [5,4], [3,2], [5,3], [16,1]]\n    print(exclusiveTimeOutFunction(log))\n    \n    log = [[1,2], [2,1], [3,2], [4,3]]\n    print(exclusiveTimeOutFunction(log))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "637": "```\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef averageOfLevels(root):\n    if not root:\n        return []\n\n    res = []\n    queue = [root]\n\n    while queue:\n        levelVals = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            levelVals.append(node.val)\n\n            if node.left:\n                queue.append(node.left)\n\n            if node.right:\n                queue.append(node.right)\n\n        res.append(sum(levelVals) / len(levelVals))\n\n    return res\n\ndef main():\n    # Test case 1\n    root = TreeNode(3, TreeNode(9), TreeNode(20, TreeNode(15), TreeNode(7)))\n    print(\"Test case 1: \", averageOfLevels(root))\n    \n    # Test case 2\n    root = TreeNode(1)\n    print(\"Test case 2: \", averageOfLevels(root))\n    \n    # Test case 3\n    root = None\n    print(\"Test case 3: \", averageOfLevels(root))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "638": "```\ndef shoppingOffers(priceList, discount):\n    n = len(priceList)\n    dp = [[0] * (1 << n) for _ in range(n)]\n    for i in range(n):\n        dp[i][1 << i] = priceList[i]\n    for mask in range(1, 1 << n):\n        for i in range(n):\n            if (mask & (1 << i)):\n                new_mask = mask ^ (1 << i)\n                for j in range(n):\n                    if (new_mask & (1 << j)):\n                        dp[i][mask] = min(dp[i][mask], dp[j][new_mask] + priceList[i])\n    return max([dp[i][0] - dp[i][(1 << n) - 1] for i in range(n)])\n\ndef main():\n    test_case_1 = [[10, 5, 3], [3, 2, 4]]\n    print(shoppingOffers(test_case_1[0], test_case_1[1]))\n    \n    test_case_2 = [[2, 5, 15], [8, 9, 6]]\n    print(shoppingOffers(test_case_2[0], test_case_2[1]))\n    \n    test_case_3 = [[1, 2, 10, 4], [3, 5, 7, 2]]\n    print(shoppingOffers(test_case_3[0], test_case_3[1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "639": "```\ndef numDecodings(self, s: str) -> int:\n    if not s or s[0] == '0':\n        return 0\n    n = len(s)\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        if s[i-1] != '0':\n            dp[i] += dp[i-1]\n        if i >= 2 and '10' <= s[i-2:i] <= '26':\n            dp[i] += dp[i-2]\n    return dp[-1]\n\ndef main():\n    print(numDecodings(\"226\")) # Output: 3\n    print(numDecodings(\"0\")) # Output: 0\n    print(numDecodings(\"1234567\")) # Output: 9\n\nif __name__ == \"__main__\":\n    main()\n```",
  "640": "```\ndef calculate(s):\n    res = 0\n    i = 0\n    while i < len(s):\n        if s[i].isdigit():\n            num = int(''.join(filter(str.isdigit, s[i:])))\n            res += num if s[i-1] == '+' else -num if s[i-1] == '-' else num * (-1)\n            i += len(str(num))\n        elif s[i] in ['+', '-']:\n            i += 1\n    return res\n\ndef main():\n    test_cases = [\n        {\"s\": \"3+5II\", \"expected\": 7},\n        {\"s\": \"2*3+4\", \"expected\": 10},\n        {\"s\": \"-1-1+2\", \"expected\": 0}\n    ]\n    \n    for case in test_cases:\n        result = calculate(case[\"s\"])\n        if result == case[\"expected\"]:\n            print(f\"Test case {case['s']} passed!\")\n        else:\n            print(f\"Test case {case['s']} failed! Expected: {case['expected']}, got: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "641": "```\nclass MyCircularDeque:\n\n    def __init__(self, k: int):\n        self.k = k\n        self.rear = self.front = 0\n        self.array = [0]*k\n\n    def insertFront(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.front = (self.front - 1 + self.k) % self.k\n        self.array[self.front] = value\n        return True\n\n    def insertLast(self, value: int) -> bool:\n        if self.isFull():\n            return False\n        self.array[self.rear] = value\n        self.rear = (self.rear + 1) % self.k\n        return True\n\n    def deleteFront(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.array[self.front] = 0\n        self.front = (self.front + 1) % self.k\n        return True\n\n    def deleteLast(self) -> bool:\n        if self.isEmpty():\n            return False\n        self.array[(self.rear - 1 + self.k) % self.k] = 0\n        self.rear = (self.rear - 1 + self.k) % self.k\n        return True\n\n    def getFront(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.array[self.front]\n\n    def getRear(self) -> int:\n        if self.isEmpty():\n            return -1\n        return self.array[(self.rear - 1 + self.k) % self.k]\n\n    def isEmpty(self) -> bool:\n        return self.front == self.rear\n\n    def isFull(self) -> bool:\n        return (self.rear + 1) % self.k == self.front\n\n\ndef main():\n    my_deque = MyCircularDeque(8)\n    print(my_deque.insertFront(137)) # true\n    print(my_deque.insertLast(250))   # true\n    print(my_deque.getRear())         # 250\n\nmain()\n```",
  "642": "```\nclass AutocompleteSystem:\n\n    def __init__(self):\n        self.Trie = {}\n\n    def input(self, token: str):\n        if token == \"#\":\n            return \"AutocompleteSystem\"\n        cursor = self.Trie\n        for char in token:\n            if char not in cursor:\n                cursor[char] = {}\n            cursor = cursor[char]\n        if \"#\" in cursor:\n            return \"AutocompleteSystem\"\n\n    def search(self, sentence):\n        cursor = self.Trie\n        for char in sentence:\n            if char not in cursor:\n                return []\n            cursor = cursor[char]\n        if \"#\" in cursor:\n            return [sentence]\n        else:\n            return sorted([s + \" \" + \"# \" for s in cursor])\n\ndef main():\n    autocompleteSystem = AutocompleteSystem()\n    \n    print(autocompleteSystem.input(\"t\")) \n    print(autocompleteSystem.search(\"text\"))\n    print(autocompleteSystem.input(\"x\"))\n    print(autocompleteSystem.search(\"xhwi\"))\n    print(autocompleteSystem.input(\"#\"))\n    print(autocompleteSystem.search(\"xyzzla\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "643": "```\ndef maxAverageRatio(foods, loss):\n    total = 0.0\n    for food in foods:\n        total += (1 + loss) / food[0]\n    return total / len(foods)\n\ndef findMaxAverage(foods):\n    max_avg = -float('inf')\n    best_loss = 0\n    for i in range(10001):\n        avg = maxAverageRatio(foods, i/10000.0)\n        if avg > max_avg:\n            max_avg = avg\n            best_loss = i / 10000.0\n    return best_loss\n\ndef main():\n    test_cases = [\n        [[1, 3], [2, 8], [5, 9], [4, 30], [4, 11], [7, 16], [8, 23], [20, 5], [15, 21]],\n        [[10, 6, 12, 7, 23, 25, 38, 40]],\n        [[1, 3], [4, 5], [2, 8]]\n    ]\n\n    for test_case in test_cases:\n        print(\"Test case:\", test_case)\n        loss = findMaxAverage(test_case)\n        print(\"Expected average:\", (sum(food[1] for food in test_case) + int(loss*10000)) / len(test_case))\n        print(\"Actual answer:\", loss)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "644": "```\ndef maxAverageRatio(food1, food2):\n    for i in range(len(food1)):\n        v = (food1[i][0] - food2[i][0]) / (food1[i][1] + food2[i][1])\n        if v > 0:\n            return True\n    return False\n\ndef findMaxAverage(nums, k):\n    n = len(nums)\n    left, right = 1, sum(nums) // k\n    while left <= right:\n        mid = (left + right) // 2\n        if sum(max(0, nums[i] - mid) for i in range(n)) >= k:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n\ndef maxAverageRatioII(food):\n    n = len(food)\n    res = float('-inf')\n    for x in range(0, food[0][1] + 1):\n        if findMaxAverage([y[0] * (x + y[1]) // (y[1] + 1) for y in food], sum([y[1] for y in food])) > res:\n            res = findMaxAverage([y[0] * (x + y[1]) // (y[1] + 1) for y in food], sum([y[1] for y in food]))\n    return res\n\ndef main():\n    food1 = [[10,5],[3,2]]\n    print(maxAverageRatio(food1))\n    \n    food2 = [[1,4],[7,8]]\n    print(maxAverageRatio(food2))\n\n    food3 = [[30,20],[11,11],[12,2]]\n    print(maxAverageRatio(food3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "645": "```\ndef findErrorNums(nums):\n    d = {}\n    for num in nums:\n        if num in d:\n            d[num] += 1\n        else:\n            d[num] = 1\n    error_nums = []\n    for k, v in d.items():\n        if v > 1:\n            error_nums.append(k)\n    for i in range(1, len(nums) + 1):\n        if i not in d or d[i] == 0:\n            error_nums.append(i)\n    return sorted(error_nums)\n\ndef main():\n    print(findErrorNums([1,2,2,3])) \n    print(findErrorNums([1,1]))\n    print(findErrorNums([2,2]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "646": "```\ndef findMaxLength(pairs):\n    pairs.sort(key=lambda x: x[1])\n    dp = [1] * len(pairs)\n    \n    for i in range(1, len(pairs)):\n        for j in range(i):\n            if pairs[j][1] < pairs[i][1]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                \n    return max(dp)\n\ndef main():\n    test_cases = [\n        ([(-6,-7), (-7,-6)], 4),\n        ([(1,2), (2,3), (3,4), (4,5)], 4),\n        (([-100,-90], [-90,-80], [-80,-70], [-70,-60]), 3)\n    ]\n    \n    for pairs, expected in test_cases:\n        result = findMaxLength(pairs)\n        if result == expected:\n            print(\"Test case passed: \" + str(pairs))\n        else:\n            print(\"Test case failed: \" + str(pairs) + \". Expected \" + str(expected) + \", but got \" + str(result))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "647": "```\ndef countSubstrings(s):\n    n = len(s)\n    count = 0\n    for i in range(n):\n        count += expand_around_center(s, i, i)  # odd length\n        count += expand_around_center(s, i, i+1)  # even length\n    return count\n\ndef expand_around_center(s, left, right):\n    count = 0\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left -= 1\n        right += 1\n        count += 1\n    return count\n\n\ndef main():\n    print(countSubstrings(\"abc\")) \n    print(countSubstrings(\"aba\"))  \n    print(countSubstrings(\"babad\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "648": "```\ndef replaceWords(words, root):\n    def insert(root, word):\n        node = root\n        for ch in word:\n            if not node.children.get(ch):\n                node.children[ch] = TrieNode()\n            node = node.children[ch]\n        node.isEndOfWord = True\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.isEndOfWord = False\n\n    root = TrieNode()\n    for word in words:\n        insert(root, word)\n\n    def replace(root, sentence):\n        nodes = [root]\n        result = []\n        for ch in sentence:\n            node = next((node for node in nodes if node.children.get(ch)), None)\n            if not node:\n                return sentence\n            nodes = [node.children[ch]]\n        while nodes and len(nodes[0].children) > 1:\n            words = list(node.children.values())\n            result.append(random.choice(words))\n            nodes = [[child] for child in node.children.values()]\n        return ' '.join(result + [sentence[len(' '.join(result)):] if result else sentence])\n\n    import random\n\n    print(replace(root, \"Hello a b c\"))\n    print(replace(root, \"Foo Bar foo bar\"))\n    print(replace(root, \"a b c d e f g h i j k l m n o p q r s t u v w x y z\"))",
  "649": "```\ndef predictPartyVictory(senate):\n    red_queue = [(len(s) - i - 1, s[i]) for i in range(len(s) - 1, -1, -1)]\n    blue_queue = [(len(s) - i - 1, s[i]) for i in range(len(s))]\n\n    while red_queue or blue_queue:\n        if red_queue and (not blue_queue or red_queue[0][0] <= blue_queue[0][0]):\n            winner, target = heappop(red_queue)\n            if target == 'R':\n                return \"Radiant\"\n            else:\n                return \"Dire\"\n        elif blue_queue:\n            winner, target = heappop(blue_queue)\n            if target == 'B':\n                return \"Dire\"\n            else:\n                return \"Radiant\"\n\n    return \"Draw\"\n\n\ndef main():\n    print(predictPartyVictory(\"RRRBR\"))\n\n\nif __name__ == \"__main__\":\n    main()\n\ntest1 = predictPartyVictory(\"RDD\")\nprint(test1)\n\ntest2 = predictPartyVictory(\"RBRRB!\")\nprint(test2)\n\ntest3 = predictPartyVictory(\"RDDRRB!\")\nprint(test3)\n```",
  "650": "```\ndef minSteps(n: int) -> int:\n    res = 0\n    i = 2\n    while i <= n:\n        if n % i == 0:\n            res += i\n            n //= i\n        else:\n            i += 1\n    return res\n\n\ndef main():\n    print(minSteps(3)) # Expected output: 4 (split into [1,2])\n    print(minSteps(4)) # Expected output: 4 (split into [2,2])\n    print(minSteps(6)) # Expected output: 9 (split into [2,2,1,1])\n\nif __name__ == \"__main__\":\n    main()\n```",
  "651": "```\ndef maxA(n):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = i\n        for j in range(i // 2, 0, -1):\n            dp[i] = max(dp[i], min(j * (i // j), dp[j]) + 1)\n    return dp[n]\n\ndef main():\n    test_cases = [(3, 4), (4, 4), (5, 6)]\n    for n, expected in test_cases:\n        result = maxA(n)\n        if result == expected:\n            print(f\"Test case {n} passed: max number of A is {result}.\")\n        else:\n            print(f\"Test case {n} failed: expected {expected}, but got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "652": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef findDuplicateSubtrees(root):\n    res = []\n    memo = {}\n    \n    def collect(node):\n        if node:\n            path = str(node.val)\n            if node.left:\n                path += \",\" + str(node.left.val)\n            if node.right:\n                path += \",\" + str(node.right.val)\n            if path in memo:\n                return \"Duplicate\"\n            else:\n                memo[path] = 1\n                return path\n\n    def dfs(node):\n        if not node:\n            return \"\"\n        res_path = collect(node)\n        if res_path == \"Duplicate\":\n            res.append(node)\n        else:\n            dfs(node.left)\n            dfs(node.right)\n\n    dfs(root)\n    return [node.val for node in res]\n\ndef main():\n    # Test case 1\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    root1.left.right = TreeNode(2)\n    root1.right.right = TreeNode(2)\n    print(findDuplicateSubtrees(root1))\n\n    # Test case 2\n    root2 = TreeNode(1)\n    root2.left = TreeNode(1)\n    root2.right = TreeNode(2)\n    print(findDuplicateSubtrees(root2))\n\n    # Test case 3\n    root3 = None\n    print(findDuplicateSubtrees(root3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "653": "```\ndef rangeSumBST(root, L, R):\n    result = []\n    def dfs(node):\n        if node:\n            if node.val >= L and node.val <= R:\n                result.append(node.val)\n            dfs(node.left)\n            dfs(node.right)\n\n    dfs(root)\n    return sum(result)\n\ndef main():\n    # Test case 1\n    root = [5,3,null,[2,null,4=null,],[6,null,8,null,7,[5,null]],null,null,null]\n    L = 1\n    R = 2\n    print(rangeSumBST(root, L, R))\n\n    # Test case 2\n    root = [10,5,15,null,null,null,null,null,2,null,false,false,false]\n    L = 0\n    R = 15\n    print(rangeSumBST(root, L, R))\n\n    # Test case 3\n    root = [1,2,4,null,null,null,8,7,9,null,null]\n    L = 4\n    R = 6\n    print(rangeSumBST(root, L, R))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "654": "```\nclass Solution:\n    def maxBT(self, nodes):\n        if not nodes:\n            return None\n        \n        nodes.sort(reverse=True)\n        \n        def build_tree(nodes):\n            if len(nodes) <= 1:\n                return TreeNode(nodes[0])\n            \n            root = TreeNode(nodes.pop(0))\n            left_child = build_tree(nodes)\n            right_child = build_tree(nodes)\n            \n            root.left = left_child\n            root.right = right_child\n            \n            return root\n        \n        def maxBT_helper(root):\n            if not root:\n                return 0\n            \n            left_height = maxBT_helper(root.left)\n            right_height = maxBT_helper(root.right)\n            \n            return 1 + max(left_height, right_height)\n        \n        def maxBT_nodes(nodes):\n            tree_root = build_tree(list(nodes))\n            return maxBT_helper(tree_root)\n        \n    def main():\n        solution = Solution()\n        print(\"Test Case 1:\")\n        print(solution.maxBT([4,3,1,2])) # Expected output: 2\n        \n        print(\"\\nTest Case 2:\")\n        print(solution.maxBT([5,8,7,9])) # Expected output: 2\n        \n        print(\"\\nTest Case 3:\")\n        print(solution.maxBT([1,3,2])) # Expected output: 1\n\n    if __name__ == \"__main__\":\n        Solution().main()\n```",
  "655": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef printTree(root):\n    if not root:\n        return \"\"\n    \n    queue = [root]\n    result = []\n    \n    while queue:\n        levelSize = len(queue)\n        \n        currentLevel = []\n        \n        for _ in range(levelSize):\n            node = queue.pop(0)\n            currentLevel.append(str(node.val))\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(\" \".join(currentLevel))\n    \n    return \"\\n\".join(result)\n\ndef main():\n    # Test case 1\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    root1.left.right = TreeNode(5)\n\n    print(printTree(root1))\n\n    # Test case 2\n    root2 = TreeNode(1)\n    root2.right = TreeNode(2)\n\n    print(printTree(root2))\n\n    # Test case 3\n    root3 = TreeNode(1)\n    root3.left = TreeNode(2)\n\n    print(printTree(root3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "656": "```\ndef minCoinChanges(coins):\n    dp = [float('inf')] * (sum(coins) + 1)\n    dp[0] = 0\n    for coin in coins:\n        for i in range(coin, sum(coins) + 1):\n            dp[i] = min(dp[i], dp[i-coin] + 1)\n    return dp[-1]\n\ndef main():\n    test_cases = [\n        ([1, 2, 5], 11), \n        ([1, 3, 4], 9), \n        ([1, 3], 6)\n    ]\n\n    for coins, expected in test_cases:\n        result = minCoinChanges(coins)\n        if result == expected:\n            print(f\"Test case passed: {coins} -> {expected}\")\n        else:\n            print(f\"Test case failed: {coins} -> {result} != {expected}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "657": "```\ndef isRobotBounded(instructions):\n    x, y, dir_x, dir_y = 0, 0, 0, 1\n    for instruction in instructions:\n        if instruction == 'R':\n            dir_x, dir_y = dir_y, -dir_x\n        elif instruction == 'L':\n            dir_x, dir_y = -dir_y, dir_x\n        elif instruction == 'F':\n            x += dir_x\n            y += dir_y\n    return (x, y) == (0, 0) or dir_x != 0 and dir_y != 1\n\ndef main():\n    print(isRobotBounded(\"GRRFTFL\")) # Test case 1: False\n    print(isRobotBounded(\"FFRFTL\")) # Test case 2: True\n    print(isRobotBounded(\"FFFFF\")) # Test case 3: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "658": "```\ndef findClosestElements(arr, k, x):\n    n = len(arr)\n    left, right = 0, n - k\n    while left < right:\n        mid = (left + right) // 2\n        if x - arr[mid] > arr[mid + k] - x:\n            left = mid + 1\n        else:\n            right = mid\n    return arr[left:left + k]\n\ndef main():\n    print(findClosestElements([1,2,3,4,5], 2, 3)) # [3,4]\n    print(findClosestElements([0,0,0,0], 3, 1)) # [0,0,0]\n    print(findClosestElements([-2,-1,0,3], 2, -1) ) # [-1,0]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "659": "```\ndef consecutive_parts(nums):\n    if not nums:\n        return 0\n    \n    parts = 1\n    prev_num = nums[0]\n    \n    for num in nums[1:]:\n        if num == prev_num + 1:\n            prev_num = num\n        else:\n            parts += 1\n            prev_num = num\n            \n    return parts\n\ndef main():\n    print(consecutive_parts([1,3])) # Expected: 2\n    print(consecutive_parts([1,2,3,3,4,5,5]) # Expected: 2\n    print(consecutive_parts([1,2,3,4,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]) # Expected: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "660": "```\ndef removeNine(num):\n    return int(str(num).replace(\"9\", \"\"))\n\ndef main():\n    print(removeNine(1999)) # Test case 1\n    print(removeNine(1234567890)) # Test case 2\n    print(removeNine(999)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "661": "```\ndef imageSmoother(img):\n    m, n = len(img), len(img[0])\n    res = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            count, sum = 0, 0\n            for x in range(-1, 2):\n                for y in range(-1, 2):\n                    if 0 <= i + x < m and 0 <= j + y < n:\n                        res[i][j] += img[i+x][j+y]\n                        count += 1\n            res[i][j] //= (count or 1)\n    \n    return res\n\ndef main():\n    img = [[7,4,3],[1,5,9},{10,13,15}]\n    print(\"Test Case 1: \")\n    for row in imageSmoother(img):\n        print(row)\n\n    img2 = [[2,3],[15,11},{17,20},{23,18},{19,25],[4,33},{5,22},{14,29},{5,23},{20,7},{8,11}]\n    print(\"\\nTest Case 2: \")\n    for row in imageSmoother(img2):\n        print(row)\n\n    img3 = [[0,1},{0,0}}\n    print(\"\\nTest Case 3: \")\n    for row in imageSmoother(img3):\n        print(row)\n    \nif __name__ == \"__main__\":\n    main()\n```",
  "662": "```\ndef maxWidthRootedAtZero(root):\n    if not root:\n        return 0\n\n    queue = [(root, 0, 1)]\n    maxWidth = 0\n    while queue:\n        node, left, right = queue.pop(0)\n        if left > 0 and right < maxWidth:\n            maxWidth = right\n        elif left > 0 and right > maxWidth:\n            maxWidth = right\n        if node.left:\n            queue.append((node.left, left + 1, right))\n        if node.right:\n            queue.append((node.right, left, right + 1))\n\n    return maxWidth\n\ndef main():\n    class TreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.left = None\n            self.right = None\n\n    root = TreeNode(1)\n    root.left = TreeNode(3)\n    root.right = TreeNode(2)\n    root.left.left = TreeNode(5)\n    root.left.right = TreeNode(4)\n\n    print(maxWidthRootedAtZero(root))  # Expected output: 4\n\n    root = TreeNode(1)\n    root.left = TreeNode(3)\n    root.right = TreeNode(2)\n\n    print(maxWidthRootedAtZero(root))  # Expected output: 3\n\n    root = TreeNode(1)\n    root.left = TreeNode(3)\n    root.right = TreeNode(5)\n    root.left.left = TreeNode(6)\n    root.left.right = TreeNode(7)\n\n    print(maxWidthRootedAtZero(root))  # Expected output: 5",
  "663": "```\nclass Solution:\n    def equalTreePartition(self, root):\n        total = self.sum(root)\n        if total % 2 != 0:\n            return False\n        target = total // 2\n        return self.dfs(root, target)\n\n    def sum(self, node):\n        if not node:\n            return 0\n        return node.val + self.sum(node.left) + self.sum(node.right)\n\n    def dfs(self, node, target):\n        if not node:\n            return True\n        if node.val == target:\n            return True\n        return (self.dfs(node.left, target - node.val) and\n                self.dfs(node.right, target - node.val))\n\ndef main():\n    s = Solution()\n    root1 = TreeNode(10)\n    root1.left = TreeNode(4)\n    root1.right = TreeNode(6);\n    print(s.equalTreePartition(root1))  # Expected: True\n\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2);\n    root2.right = TreeNode(3);\n    print(s.equalTreePartition(root2))  # Expected: False\n\n    root3 = TreeNode(5)\n    root3.left = TreeNode(5);\n    print(s.equalTreePartition(root3))  # Expected: True\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "664": "```\ndef strangePrinter(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        dp[i][i] = 1\n        for j in range(i - 1, -1, -1):\n            if s[j] == s[i]:\n                dp[j][i] = dp[j + 1][i - 1] + 2\n            else:\n                dp[j][i] = max(dp[j + 1][i], dp[j][i - 1])\n    \n    return dp[0][n - 1]\n\ndef main():\n    print(strangePrinter(\"aba\")) \n    print(strangePrinter(\"aaa\")) \n    print(strangePrinter(\"abcd\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "665": "```\ndef checkPossibility(nums):\n    n = len(nums)\n    for i in range(n - 1):\n        if nums[i] > nums[i + 1]:\n            if i == 0 or nums[i-1] <= nums[i]:\n                return True\n            elif i == n - 2 or nums[i+1] >= nums[i+2]:\n                return True\n    return False\n\ndef main():\n    test_cases = [\n        [4, 2, 3], \n        [4, 2, 1, 3], \n        [3, 6, 7]\n    ]\n\n    for test_case in test_cases:\n        print(f\"Test Case: {test_case} - Result: {checkPossibility(test_case)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "666": "```\ndef sumRootToLeaf(root):\n    if not root:\n        return 0\n\n    memo = {}\n    def dfs(node, path):\n        if node.val == 0:\n            return memo.setdefault(path, path)\n\n        path += str(node.val)\n        if node.left:\n            path += '0' if node.right else '1'\n            return dfs(node.left, path) + dfs(node.right, path) if node.right else dfs(node.left, path)\n        return 0\n\n    return dfs(root, '')\n\ndef main():\n    root = TreeNode(1)\n    root.left = TreeNode(0)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(0)\n    root.left.right = TreeNode(1)\n    root.right.left = TreeNode(0)\n    root.right.right = TreeNode(1)\n\n    print(sumRootToLeaf(root))  # Output: 22\n\n    root = TreeNode(10)\n    root.left = TreeNode(5)\n    root.right = TreeNode(15)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(2)\n    root.right.left = TreeNode(12)\n    root.right.right = TreeNode(20)\n\n    print(sumRootToLeaf(root))  # Output: 112\n\n    root = TreeNode(5)\n    root.left = TreeNode(4)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(11)\n    root.left.right = TreeNode(2)\n    root.right.left = TreeNode(13)\n    root.right.right = TreeNode(4)\n\n    print(sumRootToLeaf(root))  # Output: 21\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        if not left:\n            self.left = None\n        else:\n            self.left = left\n        self.right = right\n        if not right:\n            self.right = None\n        else:\n            self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "667": "```\ndef countArrangement(N):\n    def count(i):\n        if i >= N:\n            return 1\n        res = 0\n        for d in range(1, i+2):\n            if i % d == 0:\n                res += count(i // d)\n        return res\n    return count(1)\n\ndef main():\n    print(countArrangement(2))  # Test case 1\n    print(countArrangement(3))  # Test case 2\n    print(countArrangement(5))   # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "668": "```\ndef findKthNumber(m, n, k):\n    res = 1\n    k -= 1\n    while True:\n        low, high = res * n + 1, (res + 1) * n\n        if k >= low - res * n:\n            res += 1\n        elif k < high - res * n:\n            k -= low - res * n\n            res += 1\n        else:\n            k -= high - res * n\n            res = (res + 1) << 1\n    return res\n\ndef main():\n    print(findKthNumber(3, 3, 5))\n    print(findKthNumber(2, 3, 2))\n    print(findKthNumber(3, 1, 7))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "669": "```\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef trimBST(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n\n    if root.val < low or root.val > high:\n        if root.left:\n            root.left = trimBST(root.left)\n        if root.right:\n            root.right = trimBST(root.right)\n\n        if not root.left and not root.right:\n            return None\n        return root\n\n    if root.val <= high:\n        if root.val < low:\n            return TreeNode(root.val, root.left, trimBST(root.right))\n        else:\n            return TreeNode(root.val, trimBST(root.left), root.right)\n    else:\n        return trimBST(root.left)\n\ndef main():\n    # Test case 1\n    root = TreeNode(4)\n    root.left = TreeNode(2)\n    root.right = TreeNode(7)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(3)\n    low = 2; high = 5\n    print(\"Test Case 1: \", end=\"\")\n    print(trimBST(root).val) # Output: 4\n\n    # Test case 2\n    root = TreeNode(10, None, TreeNode(12))\n    low = 11; high = 13\n    print(\"Test Case 2: \", end=\"\")\n    print(trimBST(root).val) # Output: 12\n\n    # Test case 3\n    root = TreeNode(1)\n    low = 0; high = 5\n    print(\"Test Case 3: \", end=\"\")\n    print(trimBST(root).val) # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "670": "```\ndef maximumSwap(num):\n    last_seens = {}\n    max_val = len(str(num)) - 1\n    \n    for i, digit in enumerate(str(num)):\n        if int(digit) > max_val:\n            max_val = int(digit)\n        if int(digit) != max_val:\n            last_seens[int(digit)] = i\n        else:\n            for k, v in list(last_seens.items()):\n                if int(str(num)[v]) < int(digit):\n                    return num[:i] + str(k) + num[i+1:]\n                    \n    return num\n\ndef main():\n    print(maximumSwap(2736))  # Output: 7342\n    print(maximumSwap(9973))   # Output: 9973\n    print(maximumSwap(1993))   # Output: 2993\n\nif __name__ == \"__main__\":\n    main()\n```",
  "672": "```\ndef flipLights(n):\n    if n == 1:\n        return 3\n    if n == 2:\n        return 4\n    if n == 3:\n        return 7\n    if n == 4:\n        return 8\n\n    return 0\n\n\ndef main():\n    print(flipLights(1) == 3)\n    print(flipLights(2) == 4)\n    print(flipLights(5) == 9)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "671": "```\ndef findSecondMinimumValue(root):\n    first_min = root.val\n    result = float('inf')\n    \n    def dfs(node, min_val):\n        nonlocal result\n        if node is None:\n            return\n        \n        if min_val < node.val < first_min:\n            result = min(result, node.val)\n        elif node.val < first_min:\n            first_min = node.val\n            \n        dfs(node.left, min_val)\n        dfs(node.right, min_val)\n\n    dfs(root, first_min)\n    return result if result != float('inf') else -1\n\ndef main():\n    class TreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.left = None\n            self.right = None\n    \n    root = TreeNode(2)\n    root.left = TreeNode(2)\n    root.right = TreeNode(5)\n    root.right.left = TreeNode(5)\n    root.right.right = TreeNode(6)\n    \n    print(findSecondMinimumValue(root))  # Output: 5\n\n    root = TreeNode(1)\n    root.right = TreeNode(3)\n    root.right.right = TreeNode(4)\n    root.right.right.right = TreeNode(5)\n    \n    print(findSecondMinimumValue(root))  # Output: -1\n    \n    root = TreeNode(2)\n    root.left = TreeNode(2)\n    root.right = TreeNode(4)\n    root.right.left = TreeNode(3)\n    root.right.right = TreeNode(3)\n\n    print(findSecondMinimumValue(root))  # Output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "673": "```\ndef findLengthOfLIS(nums):\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef main():\n    print(findLengthOfLIS([1,3,5,4,7])) # Expected output: 3\n    print(findLengthOfLIS([2,2,2,2,2])) # Expected output: 1\n    print(findLengthOfLIS([1,3,6,7,9])) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "674": "```\ndef findLengthOfLIS(nums):\n    if not nums:\n        return 0\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef main():\n    print(findLengthOfLIS([1,3,6,7,9])) # Expected output: 4\n    print(findLengthOfLIS([1,3,5,4,7])) # Expected output: 3\n    print(findLengthOfLIS([0,1,3,6,9,11])) # Expected output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "675": "```\nimport heapq\n\ndef cutOffTrees(grid):\n    m, n = len(grid), len(grid[0])\n    res = 0\n    pq = []\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                dist = abs(i - (m-1)) + abs(j - (n-1))\n                heapq.heappush(pq, (dist, i, j))\n    while pq:\n        d, i, j = heapq.heappop(pq)\n        if i == m - 1 and j == n - 1: break\n        for x, y in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = i + x, j + y\n            if 0 <= ni < m and 0 <= nj < n and grid[ni][nj] == 1:\n                new_dist = d + abs(ni - i) + abs(nj - j)\n                if (ni, nj) not in [(x, y) for x, y in zip(*[list(map(lambda p: list(p), [pq[i][1:] for i in range(len(pq))]))[0], [pq[i][2:] for i in range(len(pq))]))]:\n                    heapq.heappush(pq, (new_dist, ni, nj))\n    return res\n\ndef main():\n    print(cutOffTrees([[0,0,0],[0,1,0],[5,1,0]]))\n    print(cutOffTrees([[1,1],[2,2]]))\n    print(cutOffTrees([[1,2,3],[0,0,2]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "676": "```\nclass MagicDictionary:\n\n    def __init__(self):\n        self.trie = {}\n\n    def buildDict(self, words: List[str]) -> None:\n        for word in words:\n            node = self.trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['#'] = True\n\n    def search(self, queryWord: str) -> bool:\n        node = self.trie\n        for i in range(len(queryWord)):\n            char = queryWord[i]\n            if '0' not in node and any(c != char and c != '0' and (c in node or '1' in node) for c in node):\n                return True\n            if char not in node:\n                if '1' in node:\n                    return False\n                node = node['0']\n            else:\n                node = node[char]\n        return '#' in node\n\n\ndef main():\n    obj = MagicDictionary()\n    obj.buildDict([\"hello\", \"alibaba\"])\n    print(obj.search(\"hella\"))  # True\n    print(obj.search(\"hell\"))   # False\n    print(obj.search(\"hello\"))  # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "677": "```\nclass MapSum:\n\n    def __init__(self):\n        self.trie = {}\n\n    def insert(self, word: str, sum: int) -> None:\n        node = self.trie\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['#'] = sum\n\n    def sum(self, prefix: str) -> int:\n        node = self.trie\n        for char in prefix:\n            if char not in node:\n                return 0\n            node = node[char]\n        return node.get('#', 0)\n\ndef main():\n    ms = MapSum()\n    ms.insert('hello', 5)\n    ms.insert('world', 3)\n    ms.insert('leetcode', 2)\n\n    print(ms.sum('hel')) # Should print: 5\n    print(ms.sum('wor')) # Should print: 3\n    print(ms.sum('leec')) # Should print: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "678": "```\ndef checkValidString(s):\n    minLeft, maxRight = 0, 0\n    for c in s:\n        if c == '(':\n            minLeft += 1\n            maxRight += 1\n        elif c == ')':\n            minLeft -= 1\n            maxRight -= 1\n        else:\n            minLeft -= 1\n            maxRight += 1\n            if minLeft < 0 or maxRight > len(s):\n                return False\n    return minLeft == 0\n\ndef main():\n    print(checkValidString(\"*(*)*\"))  # Expected output: True\n    print(checkValidString(\"(*)\"))     # Expected output: False\n    print(checkValidString(\"(*)()\"))   # Expected output: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "679": "```\ndef findNumbers(nums):\n    def backtrack(start, path, target):\n        if target < 0:\n            return False\n        if target > 0 and start >= len(nums):\n            return False\n        for i in range(start, len(nums)):\n            if nums[i] * 1.0 == int(nums[i]):\n                if backtrack(i + 1, path + [nums[i]], target - nums[i]):\n                    return True\n        return False\n\n    res = []\n    for num in nums:\n        if num * 1.0 == int(num):\n            if backtrack(0, [num], num):\n                res.append(num)\n    return res\n\n\ndef main():\n    print(findNumbers([5,6,4,5])) # [4]\n    print(findNumbers([2,7,11,19])) # []\n    print(findNumbers([8,3,2,1,4])) # [8, 4]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "680": "```\ndef is_palindrome(s):\n    i, j = 0, len(s) - 1\n    while i < j:\n        if s[i] != s[j]:\n            return False\n        i += 1\n        j -= 1\n    return True\n\ndef valid_palindrome(s: str) -> bool:\n    s = s.lower()\n    for i in range(len(s)):\n        if not is_palindrome(s[i:]):\n            return False\n    return True\n\n\ndef main():\n    print(\"Test Case 1:\")\n    print(valid_palindrome(\"A man, a plan, a canal: Panama\")) # Expected: True\n\n    print(\"\\nTest Case 2:\")\n    print(valid_palindrome(\"Not a palindrome\")) # Expected: False\n\n    print(\"\\nTest Case 3:\")\n    print(valid_palindrome(\"Radar\")) # Expected: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "681": "```\ndef nextClosestTime(time: str) -> str:\n    # Your code here\n\ndef main():\n    print(nextClosestTime(\"01:00\")) \n    print(nextClosestTime(\"23:59\")) \n    print(nextClosestTime(\"19:34\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "682": "```\ndef calPoints(events):\n    points = []\n    for event in events:\n        if event == \"C\":\n            if len(points) > 0:\n                points.pop()\n        elif event.startswith(\"D\"):\n            points.append(int(event[1:]) * 2)\n        else:\n            points.append(int(event))\n    return sum(points)\n\ndef main():\n    test_cases = [\n        ([[\"5\", \"2\", \"C\"], [\"-10\", \"D\", \"9\"], [\"3\", \"\"], \"-1\"],\n         30),\n        ( [[\"0\" ] , \"1\" ], 1 ),\n        ( [[\"1\"] , \"\"] , 1 )\n    ]\n    \n    for test_case in test_cases:\n        events = test_case[0]\n        expected_output = test_case[1]\n        output = calPoints(events)\n        if output == expected_output:\n            print(f'Test case: {events} Passed')\n        else:\n            print(f'Test case: {events} Failed. Expected: {expected_output}, but got: {output}')\n\nif __name__ == \"__main__\":\n    main()\n```",
  "684": "```\nclass Solution:\n    def findRedundantConnection(self, edges):\n        parent = [i for i in range(len(edges) + 1)]\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            rootX = find(x)\n            rootY = find(y)\n            if rootX == rootY:\n                return [x, y]\n            parent[rootX] = rootY\n            return []\n\n        for edge in edges:\n            if not union(edge[0], edge[1]):\n                return edge\n\ndef main():\n    solution = Solution()\n    \n    print(\"Test case 1: \")\n    print(solution.findRedundantConnection([[1,2],[1,3],[2,3]])) \n\n    print(\"\\nTest case 2: \")\n    print(solution.findRedundantConnection([[1,2],[2,3],[3,4],[1,3],[2,4]]))\n\n    print(\"\\nTest case 3: \")\n    print(solution.findRedundantConnection([[1,2],[2,3]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "683": "```\ndef gardenNoAdj(n, paths):\n    graph = [[] for _ in range(n)]\n    for i, path in enumerate(paths):\n        u, v = map(int, path.split(','))\n        graph[u].append(v)\n        graph[v].append(u)\n\n    res = [[0] * 3 for _ in range(n)]\n    for i in range(n):\n        for j in range(3):\n            if not any(x == (i, j) for x in [(u, k) for u in graph[i] for k in range(4)]):\n                res[i][j] = 1\n            elif all(x != (i, j) for x in [(u, k) for u in graph[i] for k in range(4)]):\n                res[i][j] = 2\n            else:\n                for k in [x[0] for x in [(u, k) for u in graph[i] for k in range(4)]]:\n                    if (k, j) not in [(u, m) for u in graph[k] for m in range(4)] and res[k][j] == 1:\n                        res[i][j] = 3\n    return [x.index(max(x)) for x in res]\n\ndef main():\n    n = 3\n    paths = [\"0,1\",\"1,2\"]\n    print(gardenNoAdj(n, paths))\n\n    n = 4\n    paths = [\"0,1\",\"1,2\",\"2,3\",\"3,1\",\"0,3\"]\n    print(gardenNoAdj(n, paths))\n\n    n = 5\n    paths = [\"0,1\",\"0,2\",\"1,2\",\"2,3\",\"3,4\",\"4,0\"]\n    print(gardenNoAdj(n, paths))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "686": "```\ndef repeatedStringMatch(A, B):\n    while len(B) > len(A):\n        A += A\n    for i in range(len(A) - len(B) + 1):\n        if A[i:i+len(B)] == B:\n            return \"YES\"\n    return \"NO\"\n\ndef main():\n    print(repeatedStringMatch(\"abc\", \"c\"))  # Expected: YES\n    print(repeatedStringMatch(\"abaca\", \"aca\"))  # Expected: YES\n    print(repeatedStringMatch(\"a\", \"aa\"))  # Expected: NO\n\nif __name__ == \"__main__\":\n    main()\n```",
  "685": "```\ndef findRedundantConnection(edges):\n    parent = {}\n    rank = {}\n\n    def find(node):\n        if node not in parent:\n            parent[node] = node\n            rank[node] = 0\n        if parent[node] != node:\n            parent[node] = find(parent[node])\n        return parent[node]\n\n    def union(node1, node2):\n        root1 = find(node1)\n        root2 = find(node2)\n        if root1 == root2:\n            return root1\n        if rank[root1] > rank[root2]:\n            parent[root2] = root1\n        else:\n            parent[root1] = root2\n            if rank[root1] == rank[root2]:\n                rank[root2] += 1\n\n    for edge in edges:\n        union(*edge)\n\n    for node, value in parent.items():\n        if value != node:\n            return [node, value]\n\n    return []\n\ndef main():\n    print(findRedundantConnection([[1, 2], [1, 3], [2, 3]]))  # [2, 3]\n    print(findRedundantConnection([[1, 2], [2, 3], [3, 4], [1, 5]]))  # [5, 4]\n    print(findRedundantConnection([[1, 2], [2, 3], [5, 4], [1, 5]]))  # []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "687": "```\nclass Solution:\n    def maxUncrossedLines(self, points):\n        if not points:\n            return 0\n        \n        n = len(points)\n        dp = [[0] * (n + 1) for _ in range(n + 1)]\n        \n        for i in range(1, n + 1):\n            for j in range(i - 1, 0, -1):\n                if points[i-1][1] == points[j-1][1]:\n                    dp[i][j] = dp[i-1][j-1] + 2\n                else:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n                    \n        return dp[-1][-1]\n\ndef main():\n    s = Solution()\n    \n    points1 = [[0,3],[1,2],[2,5],[4,6]]\n    print(s.maxUncrossedLines(points1))  # Output: 3\n    \n    points2 = [[1,1],[4,2],[2,3]]\n    print(s.maxUncrossedLines(points2))   # Output: 0\n    \n    points3 = [[0,1],[1,2],[2,3],[3,4],[3,5],[8,9]]\n    print(s.maxUncrossedLines(points3))   # Output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "688": "```\ndef knightProbability(N, K, thor):\n    dp = [[0.0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            if thor[i][j] == 1:\n                dp[i][j] = 1\n    for k in range(K):\n        new_dp = [[0.0 for _ in range(N)] for _ in range(N)]\n        for i in range(N):\n            for j in range(N):\n                if thor[i][j] == 1:\n                    for x, y in [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]:\n                        ni, nj = i + x, j + y\n                        if 0 <= ni < N and 0 <= nj < N and thor[ni][nj] == 1:\n                            new_dp[i][j] += dp[ni][nj]\n        dp = new_dp\n    prob = 0.0\n    for i in range(N):\n        for j in range(N):\n            prob += dp[i][j]\n    return prob\n\ndef main():\n    N = 3\n    K = 2\n    thor = [[0,1],[0,0]]\n    print(knightProbability(N, K, thor))\n\n    N = 4\n    K = 2\n    thor = [[0,0,1],[0,0,0],[0,0,1],[0,1,1]]\n    print(knightProbability(N, K, thor))\n\n    N = 5\n    K = 3\n    thor = [[0,0,1,1,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,1,1]]\n    print(knightProbability(N, K, thor))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "689": "```\ndef max_sum_of_three_subarrays(nums):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i+1] = prefix_sum[i] + nums[i]\n\n    dp = [[-float('inf')] * (n + 1) for _ in range(4)]\n    dp[0][0] = 0\n    max_sum = 0\n\n    for i in range(n - 2):\n        for j in range(i + 3, n + 1):\n            current_sum = prefix_sum[j] - prefix_sum[i]\n            for k in range(3):\n                if i > dp[k][j-1]:\n                    dp[k][i] = current_sum\n                    max_sum = max(max_sum, dp[k][i])\n    return max_sum\n\n\ndef main():\n    print(\"Test Case 1:\")\n    nums = [3,2,1,4,5]\n    print(max_sum_of_three_subarrays(nums))  # Output: 15\n\n    print(\"\\nTest Case 2:\")\n    nums = [1,2,3,4,5]\n    print(max_sum_of_three_subarrays(nums))  # Output: 9\n\n    print(\"\\nTest Case 3:\")\n    nums = [-3,-2,-1,0,-1]\n    print(max_sum_of_three_subarrays(nums))  # Output: 6\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "690": "```\ndef getImportance(employees, id):\n    employeeMap = {employee.id: employee for employee in employees}\n    return employeeMap.get(id).importance\n\ndef getImportanceOfEmployee(employees):\n    importanceSum = 0\n    visited = set()\n    def dfs(employeeId):\n        nonlocal importanceSum\n        if employeeId not in visited:\n            visited.add(employeeId)\n            employee = next((emp for emp in employees if emp.id == employeeId), None)\n            importanceSum += employee.importance\n            for subordinates in employee.subordinates:\n                dfs(subordinates)\n\n    dfs(next((emp.id for emp in employees if emp.managerId is None), None))\n    return importanceSum\n\ndef main():\n    # Test Case 1\n    employees = [\n        Employee(id=1, name=\"Karl\", importance=3, subordinates=[2,3], managerId=None),\n        Employee(id=2, name=\"Bert\", importance=2, subordinates=[], managerId=1),\n        Employee(id=3, name=\"Alex\", importance=5, subordinates=[], managerId=1)\n    ]\n    print(getImportanceOfEmployee(employees))  # Expected output: 10\n\n    # Test Case 2\n    employees = [\n        Employee(id=4, name=\"Sam\", importance=7, subordinates=[5], managerId=None),\n        Employee(id=5, name=\"Liz\", importance=6, subordinates=[], managerId=4)\n    ]\n    print(getImportanceOfEmployee(employees))  # Expected output: 13\n\n    # Test Case 3\n    employees = [\n        Employee(id=6, name=\"Eve\", importance=1, subordinates=[], managerId=None),\n        Employee(id=7, name=\"John\", importance=2, subordinates=[8], managerId=6),\n        Employee(id=8, name=\"Jen\", importance=3, subordinates=[], managerId=7)\n    ]\n    print(getImportanceOfEmployee(employees))  # Expected output: 6\n\nclass Employee:\n    def __init__(self, id, name, importance, subordinates=None, managerId=None):\n        self.id = id\n        self.name = name\n        self.importance = importance\n        self.subordinates = subordinates if subordinates else []\n        self.managerId = managerId\n\nif __name__ == \"__main__\":\n    main()\n```",
  "691": "```\ndef minStickers(stickerSet, target):\n    dp = {0: 0}\n    for sticker in stickerSet:\n        next_dp = {}\n        for word in list(dp.keys()):\n            for i in range(len(target)):\n                if target[i:i+len(sticker)] == sticker:\n                    new_word = word ^ (1 << i)\n                    next_dp.setdefault(new_word, next_dp.get(new_word, float('inf')) + 1)\n        dp = next_dp\n    return min(dp.get(word, float('inf')) for word in range(2**len(target)))\n\ndef main():\n    print(minStickers([\"this\",\"that\",\"theaters\"], \"thata\"))\n    print(minStickers([\"stop\", \"tars\"], \"rats\"))\n    print(minStickers([\"note\", \"execute\", \"double\", \"triple\", \"quad\"], \"ex\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "692": "```\nfrom collections import Counter\nimport heapq\n\ndef topKFrequent(words, k):\n    word_count = Counter(words)\n    return [word[0] for word in sorted((v, k) for k, v in word_count.items())[:-k-1:-1]]\n\ndef main():\n    test_cases = [\n        {\"words\": [\"the\", \"is\", \"and\", \"that\", \"what\", \"are\", \"of\", \"my\"], \"k\": 3},\n        {\"words\": [\"apple\", \"banana\", \"cherry\", \"banana\", \"apple\"], \"k\": 2},\n        {\"words\": [\"dog\", \"cat\", \"dog\", \"fish\", \"cat\", \"bird\"], \"k\": 3}\n    ]\n\n    for test_case in test_cases:\n        words = test_case[\"words\"]\n        k = test_case[\"k\"]\n        result = topKFrequent(words, k)\n        print(f\"Top {k} frequent words: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "693": "```\ndef hasAlternatingBits(n):\n    while n:\n        remainder = n % 2\n        if remainder == n % 4 or not n % 4:\n            return False\n        n //= 2\n    return True\n\n\ndef main():\n    print(hasAlternatingBits(5))   # Expected output: True\n    print(hasAlternatingBits(7))   # Expected output: True\n    print(hasAlternatingBits(11))  # Expected output: False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "694": "```\ndef numDistinctIslands(grid):\n    if not grid:\n        return 0\n\n    islands = set()\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                island = []\n                dfs(grid, i, j, directions, island)\n                islands.add(tuple(sorted(island)))\n\n    return len(islands)\n\ndef dfs(grid, i, j, directions, island):\n    if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]) or grid[i][j] != '1':\n        return\n\n    grid[i][j] = '#'\n    island.append((i, j))\n    for direction in directions:\n        ni, nj = i + direction[0], j + direction[1]\n        dfs(grid, ni, nj, directions, island)\n\ndef main():\n    print(numDistinctIslands([[\"0\", \"0\", \"1\", \"0\"], [\"0\", \"0\", 1, 0], [1, 1, 0, 0]]))  # 1\n    print(numDistinctIslands([[0, 0, 0], [0, 1, 1], [1, 1, 0]]))  # 2\n    print(numDistinctIslands([[\"1\", \"1\"], [\"1\", \"0\"]]))  # 1\n\nmain()\n```",
  "695": "```\ndef maxAreaOfIsland(grid):\n    if not grid:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    visited = [[False]*cols for _ in range(rows)]\n    \n    def dfs(r, c):\n        if r<0 or c<0 or r>=rows or c>=cols or grid[r][c] == 0 or visited[r][c]:\n            return 0\n        visited[r][c] = True\n        return 1 + dfs(r-1, c) + dfs(r+1, c) + dfs(r, c-1) + dfs(r, c+1)\n    \n    max_area = 0\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1 and not visited[r][c]:\n                area = dfs(r,c)\n                max_area = max(max_area, area)\n    \n    return max_area\n\ndef main():\n    test_cases = [\n        # Test case 1\n        [\n            [[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,1,1,0]],[1]]\n        \n        # Test case 2\n        ,[[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0]]],[3]\n        \n        # Test case 3\n        ,[[0,0,0,0,0,0],[0,1,1,0,0,0],[0,1,1,0,0,0],[0,0,0,1,1,1]],[4]\n    ]\n    \n    for test_case in test_cases:\n        grid = test_case[0]\n        expected_output = test_case[1]\n        output = maxAreaOfIsland(grid)\n        if output == expected_output:\n            print(\"Test case passed\")\n        else:\n            print(f\"Test case failed. Expected {expected_output} but got {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "696": "```\ndef countBinarySubstrings(s: str) -> int:\n    n = len(s)\n    ans = 0\n    i = 0\n    while i < n:\n        k = 1\n        while i + k <= n and s[i] == s[i+k-1]:\n            if s[i] != s[i+k]: break\n            k += 1\n        ans += (k // 2)\n        i += k\n\n    return ans\n\n\ndef main():\n    print(countBinarySubstrings(\"100001000\")) \n    print(countBinarySubstrings(\"10101\"))  \n    print(countBinarySubstrings(\"1111\"))   \n\nif __name__ == \"__main__\":\n    main()\n```",
  "697": "```\ndef findShortestSubArray(nums):\n    first = {num: i for i, num in enumerate(nums)}\n    last = {num: i for i, num in enumerate(nums)}\n    min_len = max(last.values()) - min(first.values()) + 1\n    for k, v in sorted(last.items()):\n        if last[k] - first[k] + 1 == min_len:\n            return min_len\n\ndef main():\n    print(findShortestSubArray([2, 2, 2, 2, 3])) \n    print(findShortestSubArray([7, 8, 9, 10, 7, 7, 6])) \n    print(findShortestSubArray([1, 2, 2, 3, 5]))\n\nmain()\n```",
  "698": "```\ndef numSubarraysWithSum(target):\n    res = [0] * (target + 1)\n    res[0] = 1\n    for i in range(1, target + 1):\n        res[i] = res[i - 1] if not any(j >= i and res[j - i] else True for j in range(i, target + 1)) else 0\n    return sum(res)\n\ndef main():\n    print(numSubarraysWithSum(4) == 7)\n    print(numSubarraysWithSum(2) == 3)\n    print(numSubarraysWithSum(3) == 5)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "699": "```\ndef numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j * j] + 1)\n            j += 1\n    return dp[-1]\n\ndef main():\n    print(numSquares(2)) # Test case 1: n = 2, expected output: 1\n    print(numSquares(3)) # Test case 2: n = 3, expected output: 2\n    print(numSquares(4)) # Test case 3: n = 4, expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "700": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef searchBST(root, N):\n    if root is None or root.val == N:\n        return root\n    if root.val < N:\n        return searchBST(root.right, N)\n    return searchBST(root.left, N)\n\ndef main():\n    # Test case 1\n    root1 = TreeNode(4)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(7)\n    root1.left.left = TreeNode(1)\n    root1.left.right = TreeNode(3)\n    print(searchBST(root1, 2).val)  # Output: 2\n\n    # Test case 2\n    root2 = TreeNode(5)\n    root2.left = TreeNode(4)\n    root2.right = TreeNode(8)\n    root2.left.left = TreeNode(2)\n    root2.left.right = TreeNode(6)\n    print(searchBST(root2, 3))  # Output: None\n\n    # Test case 3\n    root3 = TreeNode(10)\n    root3.left = TreeNode(5)\n    root3.right = TreeNode(15)\n    root3.left.left = TreeNode(3)\n    root3.left.right = TreeNode(8)\n    print(searchBST(root3, 6).val)  # Output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "701": "```\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef insertIntoBST(root: TreeNode, val: int) -> TreeNode:\n    if not root:\n        return TreeNode(val)\n    elif val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n    return root\n\ndef printTree(node):\n    if node:\n        printTree(node.left)\n        print(node.val, end=' ')\n        printTree(node.right)\n\ndef main():\n    # Test case 1\n    root = TreeNode(4)\n    root.left = TreeNode(2)\n    root.right = TreeNode(7)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(3)\n    print(\"Test Case 1:\")\n    printTree(root)\n    root = insertIntoBST(root, 5)\n    print(\"\\nUpdated Tree after inserting 5:\")\n    printTree(root)\n\n    # Test case 2\n    root = None\n    print(\"Test Case 2:\")\n    printTree(root)\n    root = insertIntoBST(root, 5)\n    print(\"\\nUpdated Tree after inserting 5:\")\n    printTree(root)\n\n    # Test case 3\n    root = TreeNode(50)\n    root.left = TreeNode(30)\n    root.right = TreeNode(70)\n    root.left.left = TreeNode(20)\n    root.left.right = TreeNode(40)\n    root.right.left = TreeNode(60)\n    root.right.right = TreeNode(80)\n    print(\"Test Case 3:\")\n    printTree(root)\n    root = insertIntoBST(root, 75)\n    print(\"\\nUpdated Tree after inserting 75:\")\n    printTree(root)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "702": "```\ndef search_target(arrays, target):\n    left, right = 0, len(arrays) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arrays[mid][0] == target:\n            return mid\n        elif arrays[mid][0] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef main():\n    test_cases = [\n        [[1, 3], [6, 9]], 2, 1,\n        [[1, 3], [6, 9]], 8, -1,\n        [[5]], 5, 0\n    ]\n    \n    for arrays, target, expected in test_cases:\n        result = search_target(arrays, target)\n        if result == expected:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected {expected}, got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "703": "```\nimport heapq\n\nclass KthLargest:\n    def __init__(self, k: int):\n        self.maxHeap = []\n        self.k = k\n\n    def add(self, val: int) -> int:\n        if len(self.maxHeap) < self.k:\n            heapq.heappush(self.maxHeap, -val)\n        else:\n            if val > -self.maxHeap[0]:\n                heapq.heappop(self.maxHeap)\n                heapq.heappush(self.maxHeap, -val)\n\n    def kthLargest(self) -> int:\n        return -self.maxHeap[0] if self.maxHeap else 0\n\ndef main():\n    k = KthLargest(3)\n    \n    print(k.kthLargest()) # Output: 0\n    k.add(4); \n    print(k.kthLargest()) # Output: 4\n    k.add(2);\n    k.add(1);\n    k.add(3);\n    k.add(5);\n    print(k.kthLargest()) # Output: 4\n    k.add(0);\n    print(k.kthLargest()) # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "704": "```\ndef search(nums, target):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n\ndef main():\n    test_cases = [\n        {\"nums\": [-1, 0, 3, 5, 9, 12], \"target\": 9, \"expected_result\": 4},\n        {\"nums\": [5], \"target\": 5, \"expected_result\": 0},\n        {\"nums\": [2, 5, 8, 13, 21, 34], \"target\": 21, \"expected_result\": 4}\n    ]\n\n    for test_case in test_cases:\n        nums = test_case[\"nums\"]\n        target = test_case[\"target\"]\n        expected_result = test_case[\"expected_result\"]\n\n        actual_result = search(nums, target)\n        if actual_result == expected_result:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected {expected_result}, but got {actual_result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "705": "```\nclass MyHashSet:\n\n    def __init__(self):\n        self.array = [None] * 1009\n\n    def add(self, key: int) -> None:\n        self.array[key % 1008] = 1\n\n    def containsKey(self, key: int) -> bool:\n        return self.array[key % 1008] == 1\n\n\ndef main():\n    myHashSet = MyHashSet()\n    \n    # Test case 1\n    print(\"Test Case 1:\")\n    myHashSet.add(1)\n    myHashSet.add(2)\n    print(myHashSet.containsKey(0))  # returns false\n    print(myHashSet.containsKey(1))  # returns true\n    print(myHashSet.containsKey(3))   # returns false\n\n    # Test case 2\n    print(\"\\nTest Case 2:\")\n    myHashSet = MyHashSet()\n    myHashSet.add(5)\n    myHashSet.add(4)\n    print(myHashSet.containsKey(0))  # returns false\n    print(myHashSet.containsKey(1))  # returns false\n    print(myHashSet.containsKey(3))   # returns false\n    print(myHashSet.containsKey(4))   # returns true\n    print(myHashSet.containsKey(5))   # returns true\n\n    # Test case 3\n    print(\"\\nTest Case 3:\")\n    myHashSet = MyHashSet()\n    myHashSet.add(11)\n    print(myHashSet.containsKey(10))  # returns false\n    print(myHashSet.containsKey(11))  # returns true\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "706": "```\nclass MyHashMap:\n\n    def __init__(self):\n        self.map = [None] * 10000\n\n    def put(self, key: int, value: int) -> None:\n        index = hash(key) % len(self.map)\n        if not self.map[index]:\n            self.map[index] = [(key, value)]\n        else:\n            for k, v in self.map[index]:\n                if k == key:\n                    self.map[index][self.map[index].index((k, v))] = (key, value)\n                    return\n            self.map[index].append((key, value))\n\n    def get(self, key: int) -> int:\n        index = hash(key) % len(self.map)\n        if not self.map[index]:\n            return -1\n        for k, v in self.map[index]:\n            if k == key:\n                return v\n        return -1\n\ndef main():\n    hashmap = MyHashMap()\n    \n    # Test case 1\n    hashmap.put(1, 1)\n    hashmap.put(2, 2)\n    assert hashmap.get(1) == 1\n    \n    # Test case 2\n    hashmap.put(3, 3)\n    assert hashmap.get(3) == 3 and hashmap.get(2) == 2\n    \n    # Test case 3\n    hashmap.put(4, 4)\n    hashmap.put(1, 10)\n    assert hashmap.get(1) == 10 and hashmap.get(4) == 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "707": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef printList(head):\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\ndef generateList(valArr):\n    dummyNode = ListNode(0)\n    curr = dummyNode\n    for val in valArr:\n        curr.next = ListNode(val)\n        curr = curr.next\n    return dummyNode.next\n\ndef main():\n    # Test case 1: Empty linked list\n    head1 = generateList([])\n    print(\"Test case 1:\")\n    printList(head1)  # Expected output: []\n\n    # Test case 2: Simple linked list\n    head2 = generateList([1, 2, 3])\n    print(\"\\nTest case 2:\")\n    printList(head2)  # Expected output: 1 2 3\n\n    # Test case 3: Linked list with cycles\n    head3 = generateList([1, 2, 3, 4, 5, 6, 7])\n    print(\"\\nTest case 3:\")\n    printList(head3)  # Expected output: 1 2 3 4 5 6 7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "708": "```\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\ndef insertionSortList(head: Node) -> Node:\n    dummy = Node(0)\n    dummy.next = head\n    current = head\n    next_node = None\n    while current and current.next:\n        next_node = current.next\n        if next_node.val > current.val + 1:\n            prev = dummy\n            while prev.next and prev.next.val < next_node.val:\n                prev = prev.next\n            current.next = next_node.next\n            next_node.next = prev.next\n            prev.next = next_node\n        else:\n            current = next_node\n    return dummy.next\n\ndef main():\n    # Test case 1\n    head1 = Node(3)\n    head1.next = Node(4)\n    head1.next.next = Node(6)\n    head1.next.next.next = head1\n    print(\"Test Case 1:\")\n    new_head1 = insertionSortList(head1)\n    while new_head1:\n        print(new_head1.val, end=\" \")\n        new_head1 = new_head1.next\n    print()\n\n    # Test case 2\n    head2 = Node(5)\n    head2.next = Node(7)\n    head2.next.next = head2\n    print(\"Test Case 2:\")\n    new_head2 = insertionSortList(head2)\n    while new_head2:\n        print(new_head2.val, end=\" \")\n        new_head2 = new_head2.next\n    print()\n\n    # Test case 3\n    head3 = Node(1)\n    head3.next = Node(2)\n    head3.next.next = Node(4)\n    head3.next.next.next = head3\n    print(\"Test Case 3:\")\n    new_head3 = insertionSortList(head3)\n    while new_head3:\n        print(new_head3.val, end=\" \")\n        new_head3 = new_head3.next\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "709": "```\ndef toLowerCase(s):\n    return s.lower()\n\ndef main():\n    print(toLowerCase(\"Hello\")) \n    print(toLowerCase(\"WORLD\"))\n    print(toLowerCase(\"hElLo WoRlD\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "710": "```\nimport random\n\nclass Solution:\n\n    def __init__(self):\n        self.randoms = []\n\n    def pick(self, nums: List[int], blacklist: List[int]) -> int:\n        n = len(nums)\n        for num in blacklist:\n            if num < 0 or num >= n:\n                raise ValueError(\"blacklist must contain indices of nums\")\n        for i in range(n):\n            if i not in blacklist:\n                self.randoms.append(i)\n\n    def get_random(self, nums: List[int], blacklist: List[int]) -> int:\n        return random.choice(self.randoms)\n\n\ndef main():\n    s = Solution()\n    \n    test_case1 = [1,2,3,4,5]\n    black_list1 = [0, 1, 2]\n    print(\"Test Case 1:\")\n    for _ in range(10):\n        print(s.get_random(test_case1, black_list1))\n    \n    test_case2 = [1,2,3,4,5,6,7]\n    black_list2 = [0, 1, 2, 3, 4]\n    print(\"Test Case 2:\")\n    for _ in range(10):\n        print(s.get_random(test_case2, black_list2))\n    \n    test_case3 = []\n    black_list3 = []\n    print(\"Test Case 3:\")\n    for _ in range(10):\n        print(s.get_random(test_case3, black_list3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "711": "```\ndef numDistinctIslands(grid):\n    if not grid:\n        return 0\n\n    seen = set()\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == '1':\n                island = []\n                dfs(grid, i, j, island)\n                seen.add(tuple(sorted(map(tuple, island))))\n    \n    return len(seen)\n\n\ndef dfs(grid, x, y, island):\n    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] != '1':\n        return\n    grid[x][y] = '#'\n    island.append((x, y))\n    dfs(grid, x-1, y, island)\n    dfs(grid, x+1, y, island)\n    dfs(grid, x, y-1, island)\n    dfs(grid, x, y+1, island)\n\n\ndef main():\n    print(numDistinctIslands([[0, 0, 1], [0, 0, 1]])) \n    print(numDistinctIslands([[1, 1, 0], [0, 1, 1], [0, 0, 0]]))  \n    print(numDistinctIslands([[1, 0, 0], [1, 0, 0], [1, 1, 1]]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "713": "```\ndef numSubarrayProductLessThanK(nums, k):\n    if k <= 1:\n        return 0\n    product = 1\n    count = 0\n    left = 0\n    for right in range(len(nums)):\n        product *= nums[right]\n        while product >= k and left <= right:\n            product //= nums[left]\n            left += 1\n        count += right - left + 1\n    return count\n\ndef main():\n    print(numSubarrayProductLessThanK([10, 5, 2, 6], 100)) # Expected output: 4\n    print(numSubarrayProductLessThanK([1, 2, 3], 0)) # Expected output: 0\n    print(numSubarrayProductLessThanK([1, 1], 2)) # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "712": "```\ndef minimumDeleteSum(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(m + 1):\n        dp[i][0] = i\n    for j in range(n + 1):\n        dp[0][j] = j\n        \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])\n                \n    return sum(ord(c) - 96 for c in s1[slice(None, len(s1))]) + sum(ord(c) - 96 for c in s2[slice(None, len(s2))]) - 2 * dp[m][n]\n\ndef main():\n    print(minimumDeleteSum(\"sea\", \"eat\") == 3)\n    print(minimumDeleteSum(\"testing\", \"test\") == 4)\n    print(minimumDeleteSum(\"a\", \"b\") == 1)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "714": "```\ndef maxProfit(prices, fee):\n    if not prices:\n        return 0\n\n    buy = [0] * len(prices)\n    sell = [0] * len(prices)\n\n    buy[0] = -prices[0]\n    for i in range(1, len(prices)):\n        buy[i] = max(buy[i-1], sell[i-1] - prices[i])\n        sell[i] = max(sell[i-1], buy[i-1] + prices[i] - fee)\n\n    return sell[-1]\n\ndef main():\n    print(maxProfit([1, 2, 3, 4, 5], 1) == 5)\n    print(maxProfit([1, 3, 2, 8, 4, 9], 2) == 10)\n    print(maxProfit([1, 2], 0) == 1)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "715": "```\nclass RangeModule:\n\n    def __init__(self):\n        self.module = {}\n\n    def addRange(self, left: int, right: int) -> None:\n        for i in range(left, right + 1):\n            if str(i) not in self.module:\n                self.module[str(i)] = 'start'\n\n    def queryRange(self, left: int, right: int) -> bool:\n        for i in range(left, right + 1):\n            if str(i) not in self.module or self.module[str(i)] == 'end':\n                return False\n        return True\n\ndef main():\n    rm = RangeModule()\n    rm.addRange(0, 10)\n    print(rm.queryRange(2, 5))  # Output: True\n    print(rm.queryRange(6, 8))  # Output: False\n    rm.addRange(6, 8)\n    print(rm.queryRange(1, 10))  # Output: True\n\nif __name__ == '__main__':\n    main()\n```",
  "716": "```\nclass MaxStack:\n\n    def __init__(self):\n        self.stack = []\n        self.max_stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n        if not self.max_stack or x >= self.max_stack[-1]:\n            self.max_stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack and self.stack[-1] == self.max_stack[-1]:\n            self.max_stack.pop()\n        return self.stack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def get_max(self) -> int:\n        return self.max_stack[-1]\n\n\ndef main():\n    maxStack = MaxStack()\n    \n    print(\"Test Case 1:\")\n    maxStack.push(5)\n    maxStack.push(1)\n    print(maxStack.get_max())  # Output: 5\n    print(maxStack.top())      # Output: 1\n    \n    maxStack.pop()\n    print(\"Max stack after pop:\", maxStack.get_max())  # Output: 5\n    \n    maxStack.push(2)\n    maxStack.push(3)\n    maxStack.push(4)\n    print(\"Max stack after multiple pushes:\", maxStack.get_max())  # Output: 5\n    print(maxStack.top())      # Output: 4\n    \n    print(\"\\nTest Case 2:\")\n    maxStack = MaxStack()\n    maxStack.push(1)\n    maxStack.push(2)\n    print(maxStack.get_max())  # Output: 2\n    print(maxStack.top())      # Output: 2\n    \n    maxStack.pop()\n    print(\"Max stack after pop:\", maxStack.get_max())  # Output: 1\n    \n    print(\"\\nTest Case 3:\")\n    maxStack = MaxStack()\n    maxStack.push(10)\n    maxStack.push(5)\n    maxStack.push(11)\n    maxStack.push(2)\n    maxStack.push(6)\n    print(\"Max stack after multiple pushes:\", maxStack.get_max())  # Output: 11\n    print(maxStack.top())      # Output: 6\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "717": "```\ndef total_charspec(arr):\n    n = len(arr)\n    count_0 = 0\n    count_1 = 0\n    for i in range(n):\n        if arr[i][0] == '0':\n            if len(arr[i]) == 2:\n                count_0 += 1\n        else:\n            if len(arr[i]) == 1:\n                count_1 += 1\n\n    return count_0 + count_1\n\n\ndef main():\n    print(\"Test case 1: \", total_charspec([[\"0\"], [\"10\"]]))\n    print(\"Test case 2: \", total_charspec([[\"100\"], [\"101\"], [\"110\"], [\"111\"], [\"000\"]]))\n    print(\"Test case 3: \", total_charspec([]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "718": "```\ndef findLength(nums1, nums2):\n    if not nums1 or not nums2:\n        return 0\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    max_length = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n                max_length = max(max_length, dp[i][j])\n    return max_length\n\n\ndef main():\n    print(findLength([0,0,0,1], [1,1,1,10])) # Expected output: 4\n    print(findLength([0,9,1,2,0], [1,5,9,1,1,1])) # Expected output: 2\n    print(findLength([1,3,5,1,3,5,2,1,3,5], [1,4,7,6,7,2,0,8,4,7])) # Expected output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "719": "```\ndef kthSmallestPairDist(nums, k):\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while k > 1:\n        if (right - left) % 2 == 1:\n            right -= 1\n        else:\n            left += 1\n        k //= 2\n    return nums[right] - nums[left]\n\ndef main():\n    test_cases = [\n        {\"nums\": [3, 10, 1], \"k\": 4},\n        {\"nums\": [7, 5, 9, 6, 8], \"k\": 5},\n        {\"nums\": [2, 50, 99, 75, 37, 49, 31, 79, 62, 94], \"k\": 3}\n    ]\n    \n    for test_case in test_cases:\n        nums = test_case[\"nums\"]\n        k = test_case[\"k\"]\n        print(f\"Test case: {nums}, k = {k}\")\n        result = kthSmallestPairDist(nums, k)\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "720": "```\ndef longestWord(words):\n    words.sort(key=len)\n    for word in words:\n        if isSubsequence(word, words) and len(word) > max_len:\n            max_len = len(word)\n\ndef isSubsequence(word, words):\n    i, j = 0, 0\n    while i < len(word) and j < len(words[0]):\n        if word[i] == words[0][j]:\n            i += 1\n        j += 1\n    return i == len(word)\n\ndef main():\n    print(longestWord([\"w\",\"wo\",\"wor\",\"world\", \"word\"]))\n    print(longestWord([\"as\",\"aw\",\"aws\",\"awww\",\"awwww\",\"awwwww\",\"awwwwww\"]))\n\n    words = [\"abecfg\",\"bdfg\",\"abcd\",\"cd\"]\n    print(longestWord(words))\n    print(longestWord([\"abcw\",\"dzfxm\",\"lrzp\",\"ayxht\",\"kmjb\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "721": "```\ndef accountsMerge(accounts):\n    graph = {}\n    visited = set()\n    for account in accounts:\n        for email in account[1:]:\n            graph[email] = []\n            for other_email in account[1:]:\n                if other_email != email:\n                    graph[email].append(other_email)\n                    \n    def dfs(email, parent=None):\n        visited.add(email)\n        for neighbor in graph.get(email, []):\n            if neighbor not in visited:\n                dfs(neighbor, email)\n                \n    result = []\n    for account in accounts:\n        root = None\n        for email in account[1:]:\n            if email not in visited:\n                root = email\n                break\n        if root:\n            dfs(root)\n            result.append([root] + list(account[1:]))\n            \n    return result\n\ndef main():\n    test_cases = [\n        {\"accounts\": [[\"John\", \"johnsmith@mail.com\", \"john.newfield@mail.com\"], [\"Jane\", \"jane.doe@mailer.com\"]], \"expected_result\": [[\"John\", \"johnsmith@mail.com\", \"john.newfield@mail.com\"], [\"Jane\", \"jane.doe@mailer.com\"])},\n        {\"accounts\": [[\"Alice\", \"alice@goo.mail.com\"], [\"Bob\", \"bobcatcode@gmail.com\"], [\"Alice\", \"Alicia@goo.mail.com\"]], \"expected_result\": [[\"Alice\", \"alice@goo.mail.com\", \"Alicia@goo.mail.com\"], [\"Bob\", \"bobcatcode@gmail.com\"]]},\n        {\"accounts\": [[\"David\", \"david@leezail.com\"], [\"John\", \"johnsmith@mail.com\", \"john.newfield@mail.com\", \"johndoe@johnny.com\"]], \"expected_result\": [[\"John\", \"johnsmith@mail.com\", \"john.newfield@mail.com\", \"johndoe@johnny.com\"], [\"David\", \"david@leezail.com\"]}\n    ]\n    \n    for test_case in test_cases:\n        actual_result = accountsMerge(test_case[\"accounts\"])\n        if actual_result == test_case[\"expected_result\"]:\n            print(\"Test case passed!\")\n        else:\n            print(\"Test case failed!\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "722": "```\ndef removeComments(code):\n    result = []\n    inLineComment = False\n    inBlockComment = False\n    \n    for line in code:\n        line = line.rstrip()\n        \n        if not inBlockComment and not inLineComment:\n            i = 0\n            while i < len(line):\n                if line[i:i+2] == \"//\":\n                    break\n                i += 1\n        \n        while i < len(line):\n            if inBlockComment:\n                if line[i:i+2] == \"*/\":\n                    inBlockComment = False\n                    break\n                i += 1\n            elif line[i:i+2] == \"/*\":\n                inBlockComment = True\n            elif not inBlockComment and line[i:i+2] == \"//\":\n                inLineComment = True\n                break\n            i += 1\n        \n        if not inBlockComment and not inLineComment:\n            result.append(line)\n        \n        if inLineComment:\n            while i < len(line):\n                if line[i] == \"\\n\" or line[i] == \"\":\n                    inLineComment = False\n                    break\n                i += 1\n        \n        i = 0\n    \n    return result\n\ndef main():\n    code1 = [\"hello // world\", \"class Solution {\"]\n    print(removeComments(code1))\n    \n    code2 = [\"a // comment\", \"public void a() {\"]\n    print(removeComments(code2))\n    \n    code3 = [\"/* Stack Overflow the best place to ask for help when stuck */\", \"public class Main {\"]\n    print(removeComments(code3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "724": "```\ndef pivotIndex(nums):\n    total_sum = sum(nums)\n    left_sum = 0\n    for i in range(len(nums)):\n        if left_sum == (total_sum - left_sum):\n            return i\n        left_sum += nums[i]\n    return -1\n\n\ndef main():\n    print(pivotIndex([1, 7, 3, 6, 5, 2, 2])) \n    print(pivotIndex([1, 2, 3, 4, 5, 6])) \n    print(pivotIndex([-1,-10,-12,20]))\n\nmain()\n```",
  "723": "```\ndef sumCandy(crush):\n    rows = len(crush)\n    cols = len(crush[0])\n    res = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    for i in range(rows):\n        left, right = 1, 1\n        for j in range(cols):\n            if crush[i][j] == 1:\n                res[i][j] += 1\n                if j > 0 and crush[i][j-1] == 1: \n                    left += 1\n                if j < cols - 1 and crush[i][j+1] == 1: \n                    right += 1\n            else:\n                res[i][j] = min(left, right)\n                left, right = 0, 0\n            \n    return [i for i in zip(*res)]\n\ndef main():\n    test_cases = [\n        [[2,3,5,3], [1,1,1,5], [5,1,1,5], [10,10,10,10]],\n        [[3,1,1,2], [1,4,1,2], [1,1,4,1], [1,1,1,1]],\n        [[1,2,4,6], [2,7,8,9], [5,1,3,5], [1,1,1,1]]\n    ]\n\n    for test_case in test_cases:\n        result = sumCandy(test_case)\n        print(f\"Test case: {test_case}\")\n        print(f\"Result: {result}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "725": "```\ndef printList(head):\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def splitListToParts(self, root: Optional[ListNode]) -> List[int]:\n        dummy = ListNode()\n        current = dummy\n        length = 0\n        p = root\n        while p:\n            length += 1\n            p = p.next\n        quotient, remainder = divmod(length, 3)\n        head, tail = None, None\n        for i in range(quotient + (remainder > 0)):\n            head = current.next\n            tail = current\n            for _ in range(quotient):\n                if not head:\n                    break\n                head = head.next\n            if remainder > 0:\n                remainder -= 1\n            else:\n                for _ in range(quotient-1):\n                    head = head.next\n            tail.next = None\n            current = head\n\n        return [head.val if head else None for _ in range(length // 3 + (length % 3 > 0))]\n\ndef main():\n    s = Solution()\n\n    # Test case 1:\n    node1 = ListNode(1)\n    node2 = ListNode(2, node1)\n    node3 = ListNode(3, node2)\n    node4 = ListNode(4, node3)\n    node5 = ListNode(5, node4)\n    node6 = ListNode(6, node5)\n    node7 = ListNode(7, node6)\n    node8 = ListNode(8, node7)\n    node9 = ListNode(9, node8)\n\n    print(\"Test case 1:\")\n    printList(node9)\n    result = s.splitListToParts(node9)\n    print(\"Expected: [1, 2], [], [4, 5, 6], [], [7, 8, 9]\")\n    print(\"Actual:\", result)\n\n    # Test case 2:\n    node1 = ListNode(1)\n    node2 = ListNode(2, node1)\n    node3 = ListNode(3, node2)\n\n    print(\"\\nTest case 2:\")\n    printList(node3)\n    result = s.splitListToParts(node3)\n    print(\"Expected: [1], [], [2, 3]\")\n    print(\"Actual:\", result)\n\n    # Test case 3:\n    node1 = ListNode(1)\n    node2 = ListNode(2, node1)\n    node3 = ListNode(3, node2)\n    node4 = ListNode(4, node3)\n    node5 = ListNode(5, node4)\n    node6 = ListNode(6, node5)\n    node7 = ListNode(7, node6)\n\n    print(\"\\nTest case 3:\")\n    printList(node7)\n    result = s.splitListToParts(node7)\n    print(\"Expected: [1], [], [2], [], [3, 4, 5, 6], []\")\n    print(\"Actual:\", result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "726": "```\ndef numAtoms(formula):\n    stack = []\n    atoms = {}\n    i = 0\n    while i < len(formula):\n        if formula[i].islower():\n            j = i + 1\n            while j < len(formula) and formula[j].islower():\n                j += 1\n            atom = formula[i:j]\n            i = j\n            count = 0\n            while i < len(formula) and formula[i].isdigit():\n                i += 1\n            if i < len(formula) and formula[i] == '(':\n                stack.append((atom, int(count or 1)))\n                i += 1\n            else:\n                atoms[atom] = atoms.get(atom, 0) + count or 1\n        elif formula[i].isdigit():\n            j = i\n            while j < len(formula) and formula[j].isdigit():\n                j += 1\n            count = int(formula[i:j])\n            i = j\n            if i < len(formula) and formula[i] == '(':\n                stack.append((count, ''))\n                i += 1\n        elif formula[i] == '(':\n            stack.append(0)\n            i += 1\n        else:\n            i += 1\n    while stack:\n        count, atom = stack.pop()\n        if atom:\n            atoms[atom] = count * (atoms.get(atom, 0) + 1)\n    return sum(int(val) for val in atoms.values())\n\ndef main():\n    print(numAtoms(\"H2O\"))  # Output: 2\n    print(numAtoms(\"Ca10(P4(OH)2)2\"))  # Output: 5\n    print(numAtoms(\"(HNO3)s\"))  # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "728": "```\ndef selfDividingNumbers(left, right):\n    def is_self_dividing(num):\n        for digit in str(num):\n            if digit == '0' or num % int(digit) != 0:\n                return False\n        return True\n\n    return [num for num in range(left, right+1) if is_self_dividing(num)]\n\n\ndef main():\n    print(selfDividingNumbers(1, 22))\n    print(selfDividingNumbers(47, 85))\n    print(selfDividingNumbers(88, 91))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "727": "```\ndef min_window(s, t):\n    if not t or not s:\n        return \"\"\n\n    n, m = len(s), len(t)\n\n    if n < m:\n        return \"\"\n\n    left, right = 0, 0\n    formed = 0\n    window_counts = {}\n    target_counts = {}\n\n    for char in t:\n        target_counts[char] = target_counts.get(char, 0) + 1\n\n    while right < n:\n        if t[0] in s[right:]+s[:right]:\n            character = s[right:]\n            for char in character:\n                window_counts[char] = window_counts.get(char, 0) + 1\n                if target_counts.get(char, 0) == window_counts.get(char, 0):\n                    formed += 1\n\n        while left <= right and formed == len(target_counts):\n            if not window_counts or min(window_counts.values()) >= min(target_counts.values()):\n                return s[left:right+1]\n\n            character = s[left]\n            window_counts[character] -= 1\n            if target_counts.get(character, 0) > window_counts.get(character, 0):\n                formed -= 1\n\n            left += 1\n\n        right += 1\n\n\ndef main():\n    s1 = \"ABCWINDOW\"\n    t1 = \"BNC\"\n    print(min_window(s1, t1))\n\n    s2 = \"ADOBECODEBANC\"\n    t2 = \"ABC\"\n    print(min_window(s2, t2))\n\n    s3 = \"\"\n    t3 = \"A\"\n    print(min_window(s3, t3))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "729": "```\ndef book(availability):\n    availability.sort()\n    available_slots = []\n    \n    for start in range(len(availability)):\n        for end in range(start + 1, len(availability) + 1):\n            if availability[start:end][0] > availability[-1]:\n                break\n            if availability[start:end][-1] < availability[0]:\n                continue\n            available_slots.append((start, end))\n    \n    return available_slots\n\ndef main():\n    print(book([700,901,900])) # Expected: [[900, 901]]\n    print(book([10,50,80]))     # Expected: [[10, 50], [50, 80]]\n    print(book([1,2,3,4,5]))    # Expected: [[1, 5]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "730": "```\ndef countPalindromes(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    ans = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n + 1):\n            if s[i] == s[j - 1]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n            ans += dp[i][j]\n    return ans\n\n\ndef main():\n    print(countPalindromes(\"abc\"))  # Output: 6\n    print(countPalindromes(\"aabbaa\"))  # Output: 12\n    print(countPalindromes(\"banana\"))  # Output: 14\n\nif __name__ == \"__main__\":\n    main()\n```",
  "732": "```\nclass MyCalendar:\n\n    def __init__(self):\n        self.events = []\n\n    def book(self, start: int, end: int) -> bool:\n        i, j = 0, len(self.events)\n        while i < j:\n            mid = (i + j) // 2\n            if self.events[mid][1] <= start:\n                i = mid + 1\n            else:\n                j = mid\n        for k in range(i):\n            if self.events[k][1] > start or events[k][0] < end:\n                return False\n        self.events.insert(i, [start, end])\n        return True\n\ndef main():\n    cal = MyCalendar()\n    print(cal.book(10, 20)) # True\n    print(cal.book(5, 15))   # False\n    print(cal.book(0, 5))     # True\n\nif __name__ == '__main__':\n    main()\n```",
  "731": "```\ndef book(Start, End):\n    pass\n\ndef myCalendarTwo():\n    schedule = []\n    def insert(start, end):\n        i, j = 0, len(schedule) - 1\n        while i <= j:\n            mid = (i+j)//2\n            if schedule[mid][1] < start:\n                i = mid + 1\n            elif schedule[mid][0] > end:\n                j = mid - 1\n            else:\n                j = mid\n                break\n        schedule.insert(i, [start, end])\n        for k in range(i+1, len(schedule)):\n            if schedule[k][0] < start or schedule[k][1] > end:\n                return False\n            if schedule[k][0] <= schedule[i][1]:\n                schedule[i][1] = min(schedule[i][1], schedule[k][1])\n        return True\n\n    def count():\n        i, res = 0, 0\n        for j in range(len(schedule)):\n            while i < len(schedule) and schedule[i][0] <= schedule[j][1]:\n                i += 1\n            res += i\n            if i > 0:\n                res -= 1\n        return res\n\n    def erase(start, end):\n        i = 0\n        while i < len(schedule) and (schedule[i][0] > start or schedule[i][1] < end):\n            i += 1\n        del schedule[:i]\n\n    events = []\n    def book(start, end):\n        if insert(start, end):\n            res = count()\n            erase(start, end)\n            return res\n        return -1\n\ndef main():\n    cal = myCalendarTwo()\n    print(cal.book(47,50)) # 3\n    print(cal.book(51,55)) # 4\n    print(cal.book(45,49)) # -1\n    print(cal.book(52,58)) # 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "734": "```\ndef twoSentencesSimilar(sentence1, sentence2):\n    words1 = sentence1.split()\n    words2 = sentence2.split()\n\n    if len(words1) != len(words2):\n        return False\n\n    table = {}\n    for word in words1:\n        if word not in table:\n            table[word] = 0\n        table[word] += 1\n    for word in words2:\n        if word not in table or table[word] == 0:\n            return False\n        table[word] -= 1\n\n    return True\n\n\ndef main():\n    print(twoSentencesSimilar(\"Great job! Great job!\", \"Fine work! The job is done.\")) \n    print(twoSentencesSimilar(\"I have so many wonderful memories of her.\", \"She will always be sweet in my memory.\")) \n    print(twoSentencesSimilar(\"Do you think that they are the same?\", \"I am sure we all say the same thing.\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "733": "```\ndef floodFill(image, sr, sc, newColor):\n    if image[sr][sc] == newColor:\n        return image\n    oldColor = image[sr][sc]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for dr, dc in directions:\n        nr, nc = sr + dr, sc + dc\n        while 0 <= nr < len(image) and 0 <= nc < len(image[0]) and image[nr][nc] == oldColor:\n            image[nr][nc] = newColor\n            nr += dr\n            nc += dc\n    return image\n\ndef main():\n    test_case1()\n    test_case2()\n    test_case3()\n\ndef test_case1():\n    image = [\n        [0, 0, 0],\n        [0, 1, 1],\n        [0, 1, 0]\n    ]\n    sr = 1\n    sc = 1\n    newColor = 2\n    print(floodFill(image, sr, sc, newColor))\n\ndef test_case2():\n    image = [\n        [0, 0, 0],\n        [0, 1, 1],\n        [1, 1, 0]\n    ]\n    sr = 2\n    sc = 1\n    newColor = 3\n    print(floodFill(image, sr, sc, newColor))\n\ndef test_case3():\n    image = [\n        [0, 0, 0],\n        [0, 1, 1],\n        [1, 2, 1]\n    ]\n    sr = 0\n    sc = 0\n    newColor = 2\n    print(floodFill(image, sr, sc, newColor))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "735": "```\ndef asteroidCollision(asteroids):\n    stack = []\n    for asteroid in asteroids:\n        while stack and asteroid < 0 and stack[-1] > 0:\n            if stack[-1] == -asteroid:\n                stack.pop()\n                break\n            elif stack[-1] < -asteroid:\n                stack.pop()\n            else:\n                if asteroid < -stack[-1]:\n                    return False\n                elif asteroid == -stack[-1]:\n                    stack.pop()\n                    break\n        stack.append(asteroid)\n    return [str(a) for a in stack]\n\ndef main():\n    print(asteroidCollision([10,2,-5]))  # Expected: [\"-5\"]\n    print(asteroidCollision([-2,1,3,-2]))  # Expected: [-1,1]\n    print(asteroidCollision([-7,1,3,9,2,3,-2]))  # Expected: [9]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "736": "```\ndef parseLisp(expression):\n    if not expression:\n        return []\n\n    stack = []\n    result = []\n    i = 0\n    while i < len(expression):\n        if expression[i] == '(':\n            if expression[i+1:] and expression[i+1].isalnum():\n                stack.append('(')\n                start = i + 1\n                while expression[i+1:].startswith(' ' + str(ord(expression[i+1])-96)):\n                    i += 1\n                end = i\n                result.append((expression[start:end], True))\n            else:\n                stack.append('(')\n        elif expression[i] == ')':\n            if stack.pop() != '(':\n                return []\n        else:\n            while i < len(expression) and expression[i].isalnum():\n                i += 1\n            start = i - len(expression[:i].strip())\n            end = i\n            result.append((expression[start:end], False))\n    return result\n\ndef main():\n    print(parseLisp(\"(a (b c))\")) # [['a', False], ['(b c)', True]]\n    print(parseLisp(\"((a b) (c d e) f g h)\") )  # [['a', False], ['b', False], ['(c d e)', True], ['f', False], ['g', False], ['h', False]]\n    print(parseLisp(\"(a (b c d))\"))  # [['a', False], ['(b c d)', True]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "737": "```\ndef containsNearbyDuplicate(words):\n    word_dict = {}\n    for i in range(len(words)):\n        if words[i] in word_dict:\n            return True\n        else:\n            word_dict[words[i]] = i\n    return False\n\ndef main():\n    print(containsNearbyDuplicate([\"leetcode\", \"leet\", \"code\", \"leetcode\"]))\n    print(containsNearbyDuplicate([\"hello\", \"i\", \"love\", \"leetcode\", \"hello\", \"back\"]))\n    print(containsNearbyDuplicate([\"word1\", \"word2\", \"word3\", \"word4\", \"word5\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "738": "```\ndef monotoneIncreasingDigits(n):\n    n = list(map(int, str(n)))\n    i = 0\n    while i < len(n) - 1:\n        if n[i] == n[i + 1]:\n            n[i + 1] += 1\n            for j in range(i + 1, len(n)):\n                if n[j] > n[j - 1]:\n                    break\n                else:\n                    n[j] = n[j - 1] + 1\n            i = 0\n        else:\n            i += 1\n    return int(''.join(map(str, n)))\n\ndef main():\n    print(monotoneIncreasingDigits(1240)) # test case 1\n    print(monotoneIncreasingDigits(15323)) # test case 2\n    print(monotoneIncreasingDigits(100)) # test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "739": "```\ndef dailyTemperatures(temperatures):\n    n = len(temperatures)\n    result = [0] * n\n    stack = []\n    \n    for i in range(n):\n        while stack and temperatures[stack[-1]] < temperatures[i]:\n            last_index = stack.pop()\n            result[last_index] = i - last_index\n        stack.append(i)\n        \n    return result\n\ndef main():\n    print(dailyTemperatures([73, 74, 75, 71, 69, 72, 70])) \n    print(dailyTemperatures([30,40,60])) \n    print(dailyTemperatures([55,38,53,81,61])) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "740": "```\ndef deleteAndEarn(nums):\n    count = [0] * 10001\n    for n in nums:\n        count[n] += n\n    dp = [0] * 10001\n    dp[1] = count[1]\n    max_val = 0\n    for i in range(2, 10001):\n        dp[i] = max(dp[i-1], dp[i-1] + count[i])\n        max_val = max(max_val, count[i])\n    return dp[max_val]\n\ndef main():\n    print(deleteAndEarn([3,4,7])) # Output: 7\n    print(deleteAndEarn([1,2,3,4,5,6])) # Output: 9\n    print(deleteAndEarn([8,2,6,4])) # Output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "741": "```\ndef cherryPickup(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[[-1 for _ in range(n)] for _ in range(m)] for _ in range(m)]\n\n    def dfs(i, j, k):\n        if i == m - 1:\n            return grid[i][j] + (grid[i][n-1] if k < n else 0)\n        if dp[i][j][k] != -1:\n            return dp[i][j][k]\n        ans = 0\n        for x, y in [(i+1, j), (i+1, j+1), (i+1, k), (i, j+1)]:\n            if 0 <= x < m and 0 <= y < n:\n                ans = max(ans, grid[x][y] + dfs(x, y, k))\n        dp[i][j][k] = ans\n        return ans\n\n    return dfs(0, 0, 0)\n\n\ndef main():\n    print(cherryPickup([[1,1],[1,0]])) \n    print(cherryPickup([[0,1],[1,0]]))\n    print(cherryPickup([[1,0,1],[1,1,5],[4,3,2,1]]))\n\nmain()\n```",
  "742": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef findClosestLeaf(root: TreeNode) -> int:\n    if root is None:\n        return -1\n    \n    leaf_to_parent = {}\n    stack = [(root, None)]\n    \n    while stack:\n        node, parent = stack.pop()\n        \n        if node.left is not None or node.right is not None:\n            leaf_to_parent[node] = parent\n            stack.extend([(child, node) for child in (node.left, node.right) if child])\n        else:\n            if parent is not None:\n                return node.val\n\n    return -1\n\n\ndef main():\n    # Test case 1\n    root = TreeNode(1)\n    root.left = TreeNode(3)\n    root.right = TreeNode(2)\n    print(findClosestLeaf(root))  # Output: 2\n    \n    # Test case 2\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    leaf = TreeNode(4)\n    root.left.left = leaf\n    print(findClosestLeaf(root))  # Output: 4\n    \n    # Test case 3\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.right.left = TreeNode(5)\n    root.right.right = TreeNode(6)\n    leaf = TreeNode(7)\n    root.right.right.right = leaf\n    print(findClosestLeaf(root))  # Output: 7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "744": "```\ndef nextGreatestLetter(letters, target):\n    for i in range(len(letters)):\n        if letters[i] > target:\n            return letters[i]\n    return letters[0]\n\ndef main():\n    print(nextGreatestLetter([\"a\",\"c\",\"aa\",\"b\"], \"a\")) # Expected: 'c'\n    print(nextGreatestLetter([\"c\",\"f\",\"g\"] , \"e\")) # Expected: 'f'\n    print(nextGreatestLetter([\"h\",\"l\",\"p\"] , \"z\")) # Expected: 'h'\n\nif __name__ == \"__main__\":\n    main()\n```",
  "743": "```\ndef networkDelayTime(times, N):\n    graph = [[] for _ in range(N + 1)]\n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    heap = [(0, 1)]\n    dist = [float('inf')] * (N + 1)\n    dist[1] = 0\n    \n    while heap:\n        d, node = heapq.heappop(heap)\n        for neighbor, weight in graph[node]:\n            if d + weight < dist[neighbor]:\n                dist[neighbor] = d + weight\n                heapq.heappush(heap, (dist[neighbor], neighbor))\n    \n    return max(dist) if max(dist) != float('inf') else -1\n\ndef main():\n    times1 = [[2,1,1],[2,3,2],[3,4,5],[1,4,10]]\n    print(networkDelayTime(times1, 4)) # Expected output: 17\n\n    times2 = [[1,2,1],[2,3,7],[1,3,3]]\n    print(networkDelayTime(times2, 3)) # Expected output: 6\n\n    times3 = [[1,2,5],[2,3,4]]\n    print(networkDelayTime(times3, 3)) # Expected output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "745": "```\nclass WordFilter:\n    def __init__(self, words):\n        self.trie = {}\n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                if prefix not in self.trie:\n                    self.trie[prefix] = {}\n                if suffix not in self.trie[prefix]:\n                    self.trie[prefix][suffix] = i\n\n    def f(self, sentence: str) -> int:\n        for j in range(len(sentence) + 1):\n            prefix = sentence[:j]\n            suffix = sentence[j:]\n            if prefix in self.trie and suffix in self.trie[prefix]:\n                return self.trie[prefix][suffix]\n        return -1\n\ndef main():\n    words = [\"apple\",\"ot\"]\n    wordFilter = WordFilter(words)\n    \n    print(wordFilter.f(\"all\"))  # Output: 0\n    print(wordFilter.f(\"app\"))   # Output: 0\n    print(wordFilter.f(\"ap\"))    # Output: -1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "746": "```\ndef minCostClimbingStairs(cost):\n    n = len(cost)\n    dp = [0] * (n + 1)\n\n    for i in range(2, n):\n        dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n\n    return min(dp[-1], dp[-2])\n\ndef main():\n    testCases = [\n        {\"cost\": [10, 15, 20], \"expected\": 15},\n        {\"cost\": [1, 100, 1, 1, 1, 100, 1, 1, 1, 1, 1, 100], \"expected\": 6},\n        {\"cost\": [0, 0, 0], \"expected\": 0}\n    ]\n\n    for test in testCases:\n        result = minCostClimbingStairs(test[\"cost\"])\n        if result == test[\"expected\"]:\n            print(\"Test case passed: cost =\", test[\"cost\"], \", expected result:\", test[\"expected\"])\n        else:\n            print(\"Test case failed: cost =\", test[\"cost\"], \", expected result:\", test[\"expected\"], \"but got\", result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "747": "```\ndef dominantIndex(nums):\n    nums.sort(key=lambda x: (-x, str(x)))\n    return -1 if len(set([*filter(lambda x: x!=nums[0], nums)]))>0 else 0\n\n\ndef main():\n    print(dominantIndex([3, 6, 3])) \n    print(dominantIndex([1, 2, 3, 4]))  \n    print(dominantIndex([0, 0, 0, 1])) \n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "748": "```\ndef shortestCompletingWord(wordList, queryWord):\n    res = \"\"\n    for word in wordList:\n        if all(ch in word for ch in queryWord) and len(queryWord) - 1 <= sum(1 for ch in word if ch not in queryWord):\n            if not res or len(word) < len(res):\n                res = word\n    return min(res, key=lambda x: (len(x), x))\n\ndef main():\n    print(shortestCompletingWord([\"cats\",\"on\",\"off\"], \"bat\"))\n    print(shortestCompletingWord([\"kia\",\"ouro\",\"kour\",\"ouy\"],\"ki\"))\n    print(shortestCompletingWord([\"dog\",\"cat\",\"bat\"], \"a\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "749": "```\ndef minTime(intervals):\n    graph = {}\n    for i in range(len(intervals)):\n        for j in range(i+1, len(intervals)):\n            if intervals[i][0] <= intervals[j][1]:\n                if i not in graph:\n                    graph[i] = []\n                if j not in graph:\n                    graph[j] = []\n                graph[i].append(j)\n                graph[j].append(i)\n    visited = [False for _ in range(len(intervals))]\n    time = 0\n    for i in range(len(intervals)):\n        if not visited[i]:\n            dfs(graph, i, visited) \n            time += 1\n    return time\n\ndef dfs(graph, node, visited):\n    visited[node] = True\n    if node in graph:\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, visited)\n\ndef main():\n    test_case1 = [[0,2],[5,6]]\n    print(minTime(test_case1))  # expected output: 3\n\n    test_case2 = [[1,4],[7,8]]\n    print(minTime(test_case2))  # expected output: 2\n\n    test_case3 = [[0,10],[5,13],[16,20]]\n    print(minTime(test_case3))   # expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "750": "```\ndef countCornerRectangles(self, grid):\n    count = 0\n    m, n = len(grid), len(grid[0])\n    for i in range(m-2):\n        for j in range(n-2):\n            onesAbove = sum(grid[i+k][j:j+3] == [1]*3 for k in range(2))\n            onesLeft = sum(grid[i:i+3][j+k] == [1]*3 for k in range(2))\n            count += onesAbove * onesLeft\n    return count\n\ndef main():\n    problem = NumberOfCornerRectangles()\n    test_cases = [\n        ([{1, 0}, {0, 1}, {0, 1}], 6),\n        ([{1, 1, 1}, {1, 1, 1}, {1, 1, 1}], 9),\n        ([{1, 0}, {0, 0}, {0, 1}], 0)\n    ]\n    for grid, expected in test_cases:\n        result = problem.countCornerRectangles({*zip(*grid)})\n        if result == expected:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected {expected}, but got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "751": "```\ndef subnet_ip_to_cidr(ip):\n    parts = ip.split('.')\n    octets = [int(x) for x in parts]\n    if len(octets) != 4 or any(0 > o or o > 255 for o in octets):\n        return None\n    cidrs = []\n    for i in range(32):\n        if (octets[3] >> (31 - i)) & 1:\n            cidrs.append(str(i + 1) + '/32')\n            break\n        elif (octets[2] >> (31 - i)) & 1:\n            cidrs.append('255.255.' + str(octets[2]) + '.' + str(octets[3]) + '/' + str(24 + i)\n            if len(cidrs) == 4:\n                break\n        elif (octets[1] >> (31 - i)) & 1:\n            cidrs.append('255.255.' + str(octets[2]) + '.' + str(octets[3]) + '/' + str(16 + i)\n            if len(cidrs) == 4:\n                break\n        elif (octets[0] >> (31 - i)) & 1:\n            cidrs.append('255.' + str(octets[1]) + '.' + str(octets[2]) + '.' + str(octets[3]) + '/' + str(8 + i)\n            if len(cidrs) == 4:\n                break\n    return ','.join(cidrs)\n\ndef main():\n    print(subnet_ip_to_cidr('255.0.0.0')) \n    print(subnet_ip_to_cidr('100.0.0.0')) \n    print(subnet_ip_to_cidr('1.2.3.4'))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "752": "```\nfrom collections import deque\n\ndef openLock(deadends, your_lock):\n    dead = {int(x):1 for x in deadends}\n    queue = deque([(0, \"0000\")])\n    visited = set([0, \"0000\"])\n    for _ in range(10000):\n        (curr, curr_str) = queue.popleft()\n        if str(curr) in dead:\n            continue\n        if curr_str == your_lock:\n            return 0\n        for i in range(4):\n            for d in [-1, 1]:\n                new_str = list(curr_str)\n                new_val = (curr + d * 10**i) % 3600 + (curr // 3600) * 3600\n                if str(new_val) in dead:\n                    continue\n                if new_str[i] == '9':\n                    new_str[i] = '0'\n                else:\n                    new_str[i] = str(int(new_str[i]) + d)\n                new_str = ''.join(new_str)\n                if new_str not in visited:\n                    queue.append((new_val, new_str))\n                    visited.add(new_str)\n    return -1\n\n\ndef main():\n    deadends1 = [\"0201\"]\n    your_lock1 = \"0009\"\n    print(openLock(deadends1, your_lock1))\n\n    deadends2 = []\n    your_lock2 = \"0000\"\n    print(openLock(deadends2, your_lock2))\n\n    deadends3 = [\"0111\",\"0442\",\"0222\"]\n    your_lock3 = \"0101\"\n    print(openLock(deadends3, your_lock3))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "753": "```\ndef canCrack(safe):\n    nodes = set()\n    edges = {}\n    \n    for i in range(len(safe)):\n        if safe[i] == '0':\n            nodes.add(i)\n    \n    for i in range(len(safe)):\n        for j in range(i+1, len(safe)):\n            if (safe[i] + safe[j]) % 3 != 0:\n                edges[(i, j)] = True\n    \n    if len(edges) < len(nodes):\n        return False\n    \n    for node in nodes:\n        adjacent_nodes = [edge[1] for edge in edges.keys() if edge[0] == node]\n        \n        if len(adjacent_nodes) % 2 != 0:\n            return False\n    \n    return True\n\ndef main():\n    test_cases = [\n        {\"input\": \"11101111\", \"expected\": True},\n        {\"input\": \"00101110\", \"expected\": True},\n        {\"input\": \"11010000\", \"expected\": False}\n    ]\n    \n    for test_case in test_cases:\n        safe = test_case[\"input\"]\n        expected = test_case[\"expected\"]\n        \n        result = canCrack(safe)\n        if result == expected:\n            print(f\"Test case {safe} passed.\")\n        else:\n            print(f\"Test case {safe} failed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "754": "```\ndef min_steps_to_reach(num):\n    if num < 0:\n        return -1\n    \n    steps = 0\n    last_move = \"even\"\n    \n    while num > 0:\n        if last_move == \"odd\":\n            if num >= 3:\n                num -= 3\n                last_move = \"even\"\n            else:\n                break\n        elif last_move == \"even\":\n            if num >= 2:\n                num -= 2\n                last_move = \"odd\"\n            elif num == 1:\n                break\n            else:\n                return -1\n    \n    return steps\n\ndef main():\n    test_cases = [(14, 6), (10, 4), (15, 7)]\n    \n    for num, expected in test_cases:\n        result = min_steps_to_reach(num)\n        if result == expected:\n            print(f\"Test case {num} passed.\")\n        else:\n            print(f\"Test case {num} failed. Expected {expected}, got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "755": "```\ndef trap(height):\n    if not height:\n        return 0\n\n    left, right = 0, len(height) - 1\n    max_left, max_right = height[0], height[-1]\n    result = 0\n\n    while left <= right:\n        if height[left] < height[right]:\n            if height[left] >= max_left:\n                max_left = height[left]\n            else:\n                result += max_left - height[left]\n            left += 1\n        else:\n            if height[right] >= max_right:\n                max_right = height[right]\n            else:\n                result += max_right - height[right]\n            right -= 1\n\n    return result\n\n\ndef main():\n    print(trap([0,1,0,2,1,0,1,3,2,1,2,1,0,2])) # 6\n    print(trap([4,2,0,2,4,1,2,0])) # 32\n    print(trap([])) # 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "756": "```\ndef pyramidTransition(bottom, allowed):\n    n = len(bottom)\n    graph = {i: [] for i in range(n+1)}\n    \n    for i in range(len(allowed)):\n        u, v, p = (int(x) for x in allowed[i].split())\n        graph[u].append((v, p))\n    \n    def dfs(s):\n        if len(s) == n:\n            return [s]\n        \n        res = []\n        for i, c in enumerate(s):\n            if len(graph[int(c)]) > 0:\n                for next_node, p in graph[int(c)]:\n                    if p == bottom[i] and len(next_node) < n:\n                        res.extend(dfs(next_node + c))\n        return res\n    \n    return dfs(bottom)\n\ndef main():\n    print(pyramidTransition(\"3\", [\"34\",\"41\",\"49\",\"97\",\"25\",\"03\",\"98\",\"04\",\"75\",\"00\"])) \n    print(pyramidTransition(\"01\", [\"01\"]))\n    print(pyramidTransition(\"1\", []))\n\nmain()\n```",
  "757": "```\ndef intersectionSize(A, B):\n    A.sort()\n    B.sort()\n\n    m = len(A)\n    n = len(B)\n\n    i = j = m - 1\n    res = 0\n    \n    while i >= 0 and j >= 0:\n        if A[i] == B[j]:\n            res += 1\n            i -= 1\n            j -= 1\n        elif A[i] < B[j]:\n            i -= 1\n        else:\n            j -= 1\n\n    return res\n\n\ndef main():\n    print(intersectionSize([1,2,3], [2,4])) # Output: 1\n    print(intersectionSize([0,2,3], [1,3,5])) # Output: 2\n    print(intersectionSize([1,2],[1,3,4])) # Output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "758": "```\ndef getBoldStrings(s, words):\n    trie = {}\n    for word in words:\n        node = trie\n        for char in word:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['*'] = word\n    \n    result = []\n    node = trie\n    i = 0\n    while i < len(s):\n        temp = ''\n        while i < len(s) and s[i] != ' ':\n            temp += s[i]\n            if s[i] in node:\n                node = node[s[i]]\n                if '*' in node:\n                    result.append('**' + temp + '**')\n                    i = node['*'].index('*') + i\n                    node = trie\n                    temp = ''\n                else:\n                    node = node[temp[0]]\n            else:\n                break\n        i += 1\n    return result\n\ndef main():\n    print(getBoldStrings(\"Let loolool cool!\", [\"cool\", \"loolool\", \"Cool\"]))\n    print(getBoldStrings(\"Hello world!\", [\"world\", \"hello\"]))\n    print(getBoldStrings(\"a b c d e f g h i j k l m n o p q r s t u v w x y z\", [\"jklmn\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "759": "```\nfrom heapq import *\n\ndef findEmployeeFreeTime(schedule):\n    free_time = []\n    for emp in schedule:\n        prev_end = -1\n        for start, end in sorted((x[0], x[1]) for x in emp):\n            if start > prev_end:\n                heappush(free_time, (start, 1))\n            if start < prev_end:\n                heappush(free_time, (prev_end, -1))\n            prev_end = end\n    free_time.sort()\n    emp_free_time = []\n    current_employee = None\n    for time in range(free_time[0][0], free_time[-1][0] + 1):\n        while free_time and free_time[0][0] <= time:\n            employee, direction = heappop(free_time)\n            if direction == 1:\n                if not emp_free_time or emp_free_time[-1][2] != employee:\n                    current_employee = employee\n                    emp_free_time.append((time - (free_time[0][0] - employee), time, current_employee))\n            else:\n                for i in range(len(emp_free_time) - 1, -1, -1):\n                    if emp_free_time[i][2] == employee:\n                        emp_free_time[i] = (emp_free_time[i][0], emp_free_time[i][1], current_employee)\n                        break\n        while free_time and free_time[0][0] <= time:\n            heappop(free_time)\n\n    return emp_free_time\n\ndef main():\n    schedule1 = [[1,2],[5,6]]\n    print(findEmployeeFreeTime(schedule1))\n    \n    schedule2 = [[1,3],[4,10]]\n    print(findEmployeeFreeTime(schedule2))\n\n    schedule3 = [[0,10],[11,18]]\n    print(findEmployeeFreeTime(schedule3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "760": "```\ndef anagramMappings(strs):\n    result = []\n    for s in strs:\n        mapping = {}\n        for c in s:\n            if c not in mapping:\n                mapping[c] = i\n                i += 1\n            result.append(mapping[s[0]])\n\n    return result\n\n\ndef main():\n    test_cases = [\n        {\"strs\": [\"abc\", \"cba\", \"ta\"], \"expected\": [0, 2, -1]},\n        {\"strs\": [\"bank\", \"kanb\"], \"expected\": [0, 0]},\n        {\"strs\": [\"ea\", \"eo\"], \"expected\": [-1, -1]}\n    ]\n\n    for test_case in test_cases:\n        result = anagramMappings(test_case[\"strs\"])\n        if result != test_case[\"expected\"]:\n            print(f\"Test case failed: {test_case}\")\n        else:\n            print(f\"Test case passed: {test_case}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "761": "```\ndef specialBinaryString(S):\n    n = len(S)\n    for i in range(n // 2 + 1):\n        if S[i] == '0' or (i < n - 1 and S[i] == '1' and S[i + 1] == '0'):\n            return False\n    return True\n\ndef main():\n    print(specialBinaryString(\"111000\"))  # Expected: False\n    print(specialBinaryString(\"100010\"))  # Expected: False\n    print(specialBinaryString(\"110111011\"))  # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "762": "```\ndef findGoodStrings(w, p):\n    n = len(p)\n    count = [0] * (1 << n)\n\n    for i in range(2 ** n):\n        s = ''\n        for j in range(n):\n            if ((i >> j) & 1):\n                s += w[j]\n        if s == p:\n            continue\n        bits = 0\n        for char in s:\n            bits += (char == '1')\n        count[bits] += 1\n\n    max_prime = -1\n    prime_count = 0\n\n    for i in range(1 << n):\n        if count[i]:\n            is_prime = True\n            for j in range(2, int(i ** 0.5) + 1):\n                if i % j == 0:\n                    is_prime = False\n                    break\n            if is_prime:\n                prime_count += count[i]\n            max_prime = max(max_prime, i)\n\n    return max_prime\n\n\ndef main():\n    print(findGoodStrings(\"001\", \"011\"))  # Expected output: 3\n    print(findGoodStrings(\"01\", \"10\"))  # Expected output: 1\n    print(findGoodStrings(\"1111\", \"1100\"))  # Expected output: 4",
  "763": "```\ndef partitionLabels(S):\n    n = len(S)\n    last = {c: i for i, c in enumerate(S)}\n    anchor = cur = start = 0\n    res = []\n    \n    for end, c in enumerate(S):\n        cur = max(cur, last[c])\n        \n        if end == cur:\n            res.append(end - start + 1)\n            start = end + 1\n\ndef main():\n    print(partitionLabels(\"ababcbacadefegdehijhklij\"))\n    print(partitionLabels(\"a\"))\n    print(partitionLabels(\"ab\"))\n\nmain()\n```",
  "764": "```\ndef orderOfLargestPlusSign(n, grid):\n    dp = [[0] * n for _ in range(n)]\n    ans = 0\n    for i in range(n):\n        left = right = up = down = 0\n        for j in range(n):\n            if grid[i][j] == '+':\n                left = right = up = down = 1\n            elif grid[i][j] == 'E':\n                left += 1\n            elif grid[i][j] == 'W':\n                right += 1\n            elif grid[i][j] == 'N':\n                up += 1\n            elif grid[i][j] == 'S':\n                down += 1\n        dp[i][0] = min(left, right, up, down)\n        for j in range(1, n):\n            if grid[i][j] == '+':\n                left = right = up = down = 1\n            elif grid[i][j] == 'E':\n                left = dp[i][j-1]\n                right += 1\n            elif grid[i][j] == 'W':\n                left += 1\n                right = dp[i][j-1]\n            elif grid[i][j] == 'N':\n                up += 1\n                left = min(left, dp[i][j-1])\n                right = min(right, dp[i][j-1])\n            elif grid[i][j] == 'S':\n                down += 1\n                left = min(left, dp[i][j-1])\n                right = min(right, dp[i][j-1])\n            dp[i][j] = max(min(left, dp[i][j-1]), min(right, dp[i][j-1]), up, down)\n        ans = max(ans, dp[-1][-1])\n    return ans\n\ndef main():\n    print(orderOfLargestPlusSign(5, [\n        ['E', 'E', '+', '.', '.'],\n        ['E', 'E', 'E', 'E', '.'],\n        ['E', 'W', 'E', 'E', '.'],\n        ['R', 'R', '+', 'R', 'R'],\n        ['R', 'R', 'R', 'R', 'R']\n    ])) # Should return 2\n    print(orderOfLargestPlusSign(3, [\n        ['+', '.', '.'],\n        ['.', '+', '.'],\n        ['.', '.', '+']\n    ])) # Should return 1\n    print(orderOfLargestPlusSign(2, [\n        ['E', 'W'],\n        ['W', 'E']\n    ])) # Should return 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "765": "```\ndef mincostToHireTeam(team):\n    team.sort(key=lambda x: x[1], reverse=True)\n    total = 0\n    for i in range(0, len(team), 2):\n        if i+1 < len(team):\n            total += team[i][1]\n        else:\n            total += team[i][1]\n    return total\n\ndef main():\n    test_cases = [\n        [[16,7,5], 7],\n        [[1,2,3,4,5,6,7], 25],\n        [[10,8,5,7,7,6], 30]\n    ]\n\n    for case in test_cases:\n        print(f\"Test Case: {case[0]}\")\n        result = mincostToHireTeam(case[0])\n        print(f\"Expected Output: {case[1]}\\nActual Output: {result}\\n\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "766": "```\ndef isToeplitzMatrix(matrix):\n    rows = len(matrix)\n    cols = len(matrix[0])\n    \n    for i in range(1, rows):\n        for j in range(1, cols):\n            if matrix[i][j] != matrix[i-1][j-1]:\n                return False\n    return True\n\ndef main():\n    test_cases = [\n        {\n            \"input\": [[1,2,3],[4,5,6],[7,8,9]],\n            \"expected_output\": True\n        },\n        {\n            \"input\": [[1,2], [4,5]],\n            \"expected_output\": False\n        },\n        {\n            \"input\": [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15]],\n            \"expected_output\": True\n        }\n    ]\n\n    for test_case in test_cases:\n        input_matrix = test_case[\"input\"]\n        expected_output = test_case[\"expected_output\"]\n        \n        output = isToeplitzMatrix(input_matrix)\n        if output == expected_output:\n            print(f\"Test case {test_case} passed\")\n        else:\n            print(f\"Test case {test_case} failed\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "767": "```\ndef reorganizeString(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    max_frequency = 0\n    most_frequent_char = ''\n    for char, count in char_count.items():\n        if count > max_frequency:\n            max_frequency = count\n            most_frequent_char = char\n    if max_frequency * 2 <= len(s):\n        return s\n    result = []\n    left_to_place = {k: v for k, v in char_count.items()}\n    while left_to_place:\n        most_common = max(left_to_place, key=left_to_place.get)\n        result.append(most_common)\n        left_to_place[most_common] -= 1\n        if left_to_place[most_common] == 0:\n            del left_to_place[most_common]\n        if len(result) * 2 >= len(s):\n            for char in s:\n                if char not in result[-1]:\n                    result.append(char)\n    return ''.join(result)\n\n\ndef main():\n    print(reorganizeString(\"aaabbbcc\"))  # Expected: \"abcabc\"\n    print(reorganizeString(\"aabbaa\"))  # Expected: \"abaaba\"\n    print(reorganizeString(\"baaccceea\"))  # Expected: \"acecab\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "768": "```\ndef maxChunksToSorted(arr):\n    n = len(arr)\n    res = left = 0\n    for i in range(n):\n        right = max(right, arr[i])\n        if arr[i] <= right:\n            left += 1\n        else:\n            res += 1\n            left = i\n    return res + 1\n\ndef main():\n    print(maxChunksToSorted([0, 4, 2, 5, 3])) # Expected: 2\n    print(maxChunksToSorted([0, 1, 2, 3]) ) # Expected: 4\n    print(maxChunksToSorted([1, 2, 3, 0]))   # Expected: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "769": "```\ndef maxChunksToSorted(arr):\n    n = len(arr)\n    last = 0\n    result = 0\n    for i in range(1, n):\n        if arr[i-1] > arr[i]:\n            result += 1\n            while last < i and (last == 0 or arr[last-1] > arr[i]):\n                last += 1\n    return result + (arr[0] <= arr[-1])\n\ndef main():\n    print(maxChunksToSorted([5, 4, 3, 2, 1])) # Expected: 1\n    print(maxChunksToSorted([2, 1, 3, 10, 7, 5, 6, 4]) ) # Expected: 4\n    print(maxChunksToSorted([1, 0, 2, 5, 3, 8, 4]) ) # Expected: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "770": "```\ndef calculate(s):\n    res = 0\n    sign = 1\n    val = 0\n    stack = []\n    \n    for i in range(len(s)):\n        if s[i].isdigit():\n            val = val * 10 + int(s[i])\n        elif s[i] in {'+', '-'}:\n            res += sign * val\n            val = 0\n            sign = 1 if s[i] == '+' else -1\n        elif s[i] == '(':\n            stack.append(res)\n            stack.append(sign)\n            sign, res = 1, 0\n        elif s[i] == ')':\n            res += sign * val\n            val = 0\n            sign = stack.pop()\n            res *= stack.pop()\n\n    return res + sign * val\n\ndef main():\n    print(calculate(\"14-3/2\")) \n    print(calculate(\"(1+x)/(1-y)\")) \n    print(calculate(\"10+5*(2+3)*4\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "771": "```\ndef numJewelsInStones(jewels, stones):\n    return sum(s in jewels for s in stones)\n\ndef main():\n    print(numJewelsInStones(\"aA\", \"aEffigy\") == 3)\n    print(numJewelsInStones(\"\", \"aEffigy\") == 0)\n    print(numJewelsInStones(\"zpm\", \"ozpmqgfnpbztmtmz\") == 4)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "772": "```\ndef calculate(s):\n    def process(tokens):\n        res = stack[0]\n        while stack:\n            op, num = stack.pop()\n            if op == '+':\n                res += int(num)\n            elif op == '-':\n                res -= int(num)\n            elif op == '*':\n                res *= int(num)\n            else:  # op == '/'\n                res //= int(num)\n        return res\n\n    stack = []\n    num = 0\n    ops = '+'\n    for c in s:\n        if c.isdigit():\n            num = num * 10 + int(c)\n        elif c.isspace():\n            if ops == '+':\n                stack.append(('+', str(num)))\n            elif ops == '-':\n                stack.append(('-', str(num)))\n            elif ops == '*':\n                stack.append(('*', str(num)))\n            else:  # op == '/'\n                stack.append(('/', str(num)))\n            num = 0\n            ops = c\n        else:\n            if ops == '+':\n                stack.append(('+', str(num)))\n            elif ops == '-':\n                stack.append(('-', str(num)))\n            elif ops == '*':\n                stack.append(('*', str(num)))\n            else:  # op == '/'\n                stack.append(('/', str(num)))\n            num = 0\n    if ops == '+':\n        stack.append(('+', str(num)))\n    elif ops == '-':\n        stack.append(('-', str(num)))\n    elif ops == '*':\n        stack.append(('*', str(num)))\n    else:  # op == '/'\n        stack.append(('/', str(num)))\n    return process(stack)\n\ndef main():\n    print(calculate(\"3+2*4\"))\n    print(calculate(\"(1+(4-3) + 2)*(9-3)\"))\n    print(calculate(\"14-3/2\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "773": "```\ndef slidePuzzle(board):\n    def dfs(x, y, pre_x, pre_y):\n        if x == pre_x and y == pre_y:\n            return [board[:]]\n        if x < 0 or x >= len(board) or y < 0 or y >= len(board[0]) or (pre_x != -1 and pre_y != -1 and abs(x - pre_x) + abs(y - pre_y) > 2):\n            return []\n        ans = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < len(board) and 0 <= ny < len(board[0]):\n                board[x][y], board[nx][ny] = board[nx][ny], board[x][y]\n                ans.extend(dfs(nx, ny, x, y))\n                board[x][y], board[nx][ny] = board[nx][ny], board[x][y]\n        return ans\n\n    def slidingPuzzle(board):\n        res = set()\n        for f in dfs(0, 0, -1, -1):\n            if not any(f[i] != i + 1 for i in range(len(f) - 1)):\n                res.add(tuple(map(int, ''.join(map(str, f))))\n                         )\n        return min(res)\n\ndef main():\n    board1 = [[2,1,3],[5,4,0]]\n    print(slidePuzzle(board1))\n\n    board2 = [[1,2,3], [4,0,5]]\n    print(slidePuzzle(board2))\n\n    board3 = [[1,2],[3,0]]\n    print(slidePuzzle(board3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "774": "```\ndef minmaxGasDist(stations, capacity):\n    stations.sort()\n    max_dist = 0\n    start = 0\n    for end in range(1, len(stations)):\n        while (stations[end] - stations[start]) * capacity > (stations[end-1] - stations[0]):\n            if start == 0:\n                return float('inf')\n            start += 1\n        max_dist = max(max_dist, stations[end]-stations[start])\n    return minmaxGasDistHelper(stations[-1], stations[0], capacity)\n\ndef minmaxGasDistHelper(total_length, gas_station_distance, capacity):\n    left = 0\n    right = total_length\n    while left < right:\n        mid = (left + right) // 2\n        need_gas_stations = math.ceil((mid * 1.0) / gas_station_distance)\n        if need_gas_stations * capacity < mid:\n            right = mid\n        else:\n            left = mid + 1\n    return max(0, left)\n\ndef main():\n    stations = [[10,1000000000],[20,325l},{30,30000000}]\n    capacity = 1000000000\n    print(minmaxGasDist(stations, capacity))\n\n    stations = [[1,2},[3,4},{5,5},{7,8},{8,9}}\n    capacity = 10\n    print(minmaxGasDist(stations, capacity))\n\n    stations = [[23,48},{53,49},{63,52},{77,72],[105,120}]\n    capacity = 100\n    print(minmaxGasDist(stations, capacity))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "775": "```\ndef findInverted(intervals):\n    n = len(intervals)\n    intervals.sort(key=lambda x: (x[0], -x[1]))\n\n    res = []\n    for i in range(n-1):\n        if intervals[i][1] < intervals[i+1][0]:\n            res.append((intervals[i][0], intervals[i+1][1]))\n        elif intervals[i][1] > intervals[i+1][0]:\n            res.extend([(min(intervals[i][0], intervals[i+1][0]), max(intervals[i][1], intervals[i+1][1])))])\n\n    return res\n\n\ndef main():\n    test_cases = [\n        [[1, 3], [2, 6], [8, 10], [15, 18]], \n        [[1, 5], [4, 7], [9, 13], [20, 23]], \n        [[1, 50], [2, 25], [40, 49]]\n    ]\n\n    for test_case in test_cases:\n        result = findInverted(test_case)\n        print(f\"Test case: {test_case}, Result: {result}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "776": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef sortedArrayToBST(arr):\n    if not arr:\n        return None\n\n    mid = len(arr) // 2\n    root = TreeNode(arr[mid])\n    root.left = sortedArrayToBST(arr[:mid])\n    root.right = sortedArrayToBST(arr[mid+1:])\n    return root\n\ndef inorder(root, res):\n    if root:\n        inorder(root.left, res)\n        res.append(root.val)\n        inorder(root.right, res)\n\ndef splitBSTops(c, v):\n    res = []\n    def helper(node):\n        if not node:\n            return\n        if node.val < v:\n            res.append(node.val)\n            helper(node.right)\n        else:\n            left subtree\n            right subtree\n    root = sortedArrayToBST(c)\n    helper(root)\n\ndef main():\n    case1 = [2, 1]\n    case2 = [3, 1, 4]\n    case3 = [4, 2, 6, 1, 3, 5]\n\n    print(\"Case 1:\")\n    res1 = []\n    splitBSTops(case1, 3)\n    for i in res1:\n        print(i)\n\n    print(\"\\nCase 2:\")\n    res2 = []\n    splitBSTops(case2, 4)\n    for i in res2:\n        print(i)\n\n    print(\"\\nCase 3:\")\n    res3 = []\n    splitBSTops(case3, 5)\n    for i in res3:\n        print(i)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "777": "```\ndef swapNodes(values):\n    result = []\n    i = 0\n    while i < len(values):\n        if values[i][0] == 'L':\n            result.append(['R', values[i][1]])\n        else:\n            result.append(['L', values[i][1]])\n        i += 1\n    return result\n\ndef main():\n    print(swapNodes([[\"LR\", \"LR\"], [\"RL\", \"RR\"]])) # Expected: [[\"RL\", \"RL\"], [\"LL\", \"RR\"]]\n    print(swapNodes([[\"LR\", \"C\"]])) # Expected: [[\"RL\", \"C\"]]\n    print(swapNodes([])) # Expected: []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "778": "```\ndef maxAreaHeight(heights):\n    n = len(heights)\n    left = 0\n    right = n - 1\n    res = 0\n    \n    while left < right:\n        w = right - left\n        h = min(heights[left], heights[right])\n        res = max(res, w * h)\n        \n        if heights[left] < heights[right]:\n            left += 1\n        else:\n            right -= 1\n            \n    return res\n\ndef main():\n    test_cases = [\n        ([1,8,6,2,5,4,8,3,7], 49),\n        ([1,1,1,4,2,3,2,1,2], 4),\n        ([10,9,8,7,6,5,4,3,2,1], 1)\n    ]\n\n    for heights, expected in test_cases:\n        result = maxAreaHeight(heights)\n        if result == expected:\n            print(f\"Test case passed: {heights} -> {result}\")\n        else:\n            print(f\"Test case failed: {heights} -> {result}, Expected {expected}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "779": "```\ndef kthGrammar(N, K):\n    if N == 1:\n        return 0\n    \n    half = (1 << (N - 1))\n    \n    if K >= half:\n        return 1 - kthGrammar(N-1, K-half)\n    else:\n        return kthGrammar(N-1, K)\n\ndef main():\n    print(kthGrammar(3, 4), '\\n') # Test case 1\n    print(kthGrammar(5, 7), '\\n') # Test case 2\n    print(kthGrammar(10, 11), '\\n') # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "780": "```\ndef numSteps(out = 0):\n    return out\n\ndef reach(int m, int n):    \n    if m == 1 or n == 1:\n        return 1\n    return min(1 + numSteps(m-1) if m > 0 else 0, 1 + numSteps(n-1) if n > 0 else 0)\n\ndef main():\n    print(\"Test case 1: \")\n    print(reach(3,2)) # Expected output: 2\n\n    print(\"\\nTest case 2: \")\n    print(reach(4,2)) # Expected output: 4\n\n    print(\"\\nTest case 3: \")\n    print(reach(6,8)) # Expected output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "781": "```\ndef numRabbits(looking, delayed):\n    res = []\n    seen = {}\n    for pair in zip(looking, delayed):\n        if pair[1] not in seen:\n            seen[pair[1]] = pair[0]\n        elif seen[pair[1]] == pair[0]:\n            return 0\n        else:\n            res.append(pair[0])\n    return len(res)\n\ndef main():\n    print(numRabbits([2, 3, 4], [1, 1, 1]) == 2)\n    print(numRabbits([1, 1, 1, 5, 7], []) == 6)\n    print(numRabbits([0, 1, 1, 2, 3, 3, 4, 5, 5, 5], [1, 2, 3]) == 6)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "782": "```\ndef movesToChessboard(board):\n    n = len(board)\n    res = 0\n    for i in range(n):\n        onesInRow = sum(1 for x in board[i] if x)\n        res += abs(i - onesInRow // (n+1) * (n+1))\n        lastOne = -1\n        for j, x in enumerate(board[i]):\n            if x:\n                res += abs(j - lastOne - 1)\n                lastOne = j\n    for j in range(n):\n        onesInCol = sum(1 for x in board[col] if x for col in range(n) if x)\n        res += abs(j - onesInCol // (n+1) * (n+1))\n        lastOne = -1\n        for i, x in enumerate(board[i]):\n            if x:\n                res += abs(i - lastOne - 1)\n                lastOne = i\n    return res\n\ndef main():\n    test_cases = [\n        {'board': [[0,1],[1,0]], 'expected_result': 2},\n        {'board': [[0,1,0],[0,1,0],[0,1,0]], 'expected_result': 6},\n        {'board': [[1,1,0,0],[1,1,0,0],[1,0,1,0],[0,1,1,1]], 'expected_result': 4}\n    ]\n\n    for test_case in test_cases:\n        result = movesToChessboard(test_case['board'])\n        if result == test_case['expected_result']:\n            print(\"Test case passed.\")\n        else:\n            print(f\"Test case failed. Expected {test_case['expected_result']} but got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "783": "```\ndef minDiffTreeNodes(root):\n    if not root:\n        return 0\n\n    def dfs(node):\n        if not node:\n            return [float('inf'), float('-inf')]\n\n        left = dfs(node.left)\n        right = dfs(node.right)\n\n        res = []\n        if left[1] < node.val:\n            res.append(left[1] - node.val)\n        else:\n            res.append(0)\n\n        if right[0] > node.val:\n            res.append(right[0] - node.val)\n        else:\n            res.append(0)\n\n        return [min(node.val, left[0]), max(node.val, right[1])]\n\n    return max(0, dfs(root)[1] - dfs(root)[0])\n\ndef main():\n    root = TreeNode(4)\n    root.left = TreeNode(2)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(3)\n    print(minDiffTreeNodes(root))  # Output: 3\n\n    root = TreeNode(8)\n    root.left = TreeNode(3)\n    root.right = TreeNode(10)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(6)\n    root.right.right = TreeNode(14)\n    root.right.right.left = TreeNode(13)\n    print(minDiffTreeNodes(root))  # Output: 7\n\n    root = TreeNode(1)\n    print(minDiffTreeNodes(root))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "784": "```\ndef letterCasePermutations(s: str) -> list:\n    def backtrack(index, current):\n        if index == len(s):\n            result.append(\"\".join(current))\n            return\n        if s[index].isalpha():\n            backtrack(index + 1, current + [s[index].upper()])\n            backtrack(index + 1, current + [s[index].lower()])\n        else:\n            backtrack(index + 1, current + [s[index]])\n\n    result = []\n    backtrack(0, [])\n    return result\n\n\ndef main():\n    print(letterCasePermutations(\"a1b2\"))\n\n\ntest_case_1 = [\"a1b2\" => [\"a1b2\", \"A1b2\"]]\ntest_case_2 = [\"a1B2\" => [\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]]\ntest_case_3 = [\"0\" => [\"0\"]]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "785": "```\nclass Solution:\n    def isBipartite(self, graph):\n        color = {}\n\n        for node in graph:\n            if node not in color:\n                stack = [node]\n                color[node] = 0\n\n                while stack:\n                    curr_node = stack.pop(0)\n                    for neighbor in graph[curr_node]:\n                        if neighbor not in color:\n                            color[neighbor] = 1 - color[curr_node]\n                            stack.append(neighbor)\n                        elif color[neighbor] == color[curr_node]:\n                            return False\n        return True\n\n    def main(self):\n        graph1 = {\n            0: [1, 3],\n            1: [0, 2],\n            2: [1, 3],\n            3: [0, 2]\n        }\n        print(self.isBipartite(graph1))  # Expected output: True\n\n        graph2 = {\n            0: [1, 2],\n            1: [0, 2],\n            2: [0, 1]\n        }\n        print(self.isBipartite(graph2))  # Expected output: False\n\n        graph3 = {\n            0: [1],\n            1: [0, 2],\n            2: [1]\n        }\n        print(self.isBipartite(graph3))  # Expected output: True\n\nif __name__ == \"__main__\":\n    s = Solution()\n    s.main()\n```",
  "786": "```\ndef kthSmallestPrimeFraction(arr):\n    n = len(arr)\n    for i in range(n):\n        arr[i] *= -1\n    arr.sort()\n    \n    left, right = 0, 1\n    res = [0, 0]\n    while True:\n        if left + right > n:\n            return [0, 0]\n        k = 0\n        for i in range(left, right):\n            k += 1\n            if k == n:\n                return [(left / (right - 1), 1)]\n        res[0] = left / right\n        new_left = left + 1\n        new_right = right\n        while True:\n            new_left += 1\n            new_right += 1\n            new_k = 0\n            for i in range(new_left, new_right):\n                new_k += 1\n                if new_k == n:\n                    return [(new_left / (new_right - 1), 1)]\n        right = new_right\n        left = new_left\n\ndef main():\n    print(kthSmallestPrimeFraction([0.5, 1.0])) # [0.50000, 0.50000]\n    print(kthSmallestPrimeFraction([1/10, 1])) # [0.15000, 0.50000]\n    print(kthSmallestPrimeFraction([1/50,1])) # [0.03447, 0.56729]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "787": "```\ndef findCheapestPrice(n, flights, src, dst, k):\n    graph = [[] for _ in range(n)]\n    for flight in flights:\n        graph[flight[0]].append((flight[1], flight[2]))\n\n    queue = [(0, 0)]  # (price, stop)\n    prices = {i: float('inf') for i in range(n)}\n    prices[src] = 0\n\n    while queue:\n        price, stop = heapq.heappop(queue)\n\n        if stop > k:\n            continue\n\n        if stop == k:\n            return price\n\n        for neighbor, cost in graph[stop]:\n            if prices[neighbor] > prices[stop] + cost:\n                prices[neighbor] = prices[stop] + cost\n                heapq.heappush(queue, (price + cost, stop + 1))\n\n    return -1\n\ndef main():\n    n1 = 3\n    flights1 = [[0,1,100],[1,2,75]]\n    src1 = 0\n    dst1 = 2\n    k1 = 1\n\n    n2 = 4\n    flights2 = [[0,1,20],[1,2,50],[0,3,10]]\n    src2 = 0\n    dst2 = 2\n    k2 = 1\n\n    n3 = 5\n    flights3 = [[4,3,60],[4,2,40],[3,2,10],[2,1,20],[1,0,100],[4,0,50]]\n    src3 = 4\n    dst3 = 0\n    k3 = 2\n\n    print(findCheapestPrice(n1, flights1, src1, dst1, k1))\n    print(findCheapestPrice(n2, flights2, src2, dst2, k2))\n    print(findCheapestPrice(n3, flights3, src3, dst3, k3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "788": "```\ndef findRotatedDigits(n):\n    if n < 10:\n        return 0\n    n_str = str(n)\n    rotated_digits = set()\n    for i in range(len(n_str)):\n        for j in range(i + 1, len(n_str) + 1):\n            rotated_str = n_str[i:j]\n            if int(rotated_str) <= n:\n                rotated_digits.add(int(rotated_str))\n    return len(rotated_digits)\n\ndef main():\n    print(findRotatedDigits(83378)) # Expected: 5\n    print(findRotatedDigits(34561)) # Expected: 4\n    print(findRotatedDigits(12345)) # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "789": "```\ndef ghostEscape(ghosts, target):\n    ghosts.sort()\n    left, right = 0, len(ghosts) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if ghosts[mid] >= target:\n            right = mid - 1\n        else:\n            left = mid + 1\n    return ghostCount(ghosts, left)\n\ndef ghostCount(ghosts, idx):\n    count = 0\n    for i in range(idx, len(ghosts)):\n        if ghosts[i] <= targets[idx]:\n            count += 1\n    return count\n\ntargets = [2, 5, 10]\nprint(ghostEscape(targets, 3))  # Test Case 1: 1\nprint(ghostEscape([1, 4], 3))   # Test Case 2: 0\nprint(ghostEscape([1, 3, 7], 6)  # Test Case 3: 2\n```",
  "790": "```\ndef tilingRectangles(n: int) -> int:\n    if n == 1:\n        return 1\n    dp = [0] * (n + 1)\n    dp[1] = 2\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] * 2\n    return dp[-1]\n\ndef main():\n    print(tilingRectangles(3))  # Test case 1: Output is 10\n    print(tilingRectangles(4))  # Test case 2: Output is 22\n    print(tilingRectangles(5))  # Test case 3: Output is 44\n\nif __name__ == \"__main__\":\n    main()\n```",
  "791": "```\ndef customSortString(order, s):\n    hash_map = {char: i for i, char in enumerate(order)}\n    return ''.join([s[i] for i in sorted(hash_map.keys(), key=lambda x:hash_map[x])])\n\ndef main():\n    print(customSortString(\"cba\", \"abcd\"))  # expected output: \"cbad\"\n    print(customSortString(\"kaq\", \"mqwah\"))  # expected output: \"amqw\"\n    print(customSortString(\"owgnr\", \"rgntuoaoownnnn\")  # expected output: \"oownrtnug\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "792": "```\ndef numMatchingSubseq(s, words):\n    word_count = {}\n    for word in words:\n        if word not in word_count:\n            word_count[word] = 0\n        word_count[word] += s.count(word)\n    return sum([count for count in word_count.values()])\n\ndef main():\n    print(numMatchingSubseq(\"abc\", [\"ab\", \"bc\", \"b\"])) # Expected: 2\n    print(numMatchingSubseq(\"aa\", [\"a\", \"aa\", \"aaa\", \"aaaa\"])) # Expected: 3\n    print(numMatchingSubseq(\"bbb\", [\"a\", \"b\", \"bb\", \"bba\"])) # Expected: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "793": "```\ndef factorial_n_zeroes(n):\n    if n < 0:\n        return 0\n    count = 0\n    i = 5\n    while i <= n:\n        count += (n // i)\n        i *= 5\n    return count\n\ndef main():\n    print(\"Test case 1:\")\n    print(factorial_n_zeroes(3)) \n    print(\"Expected: 0\")\n    \n    print(\"\\nTest case 2:\")\n    print(factorial_n_zeroes(4))\n    print(\"Expected: 1\")\n    \n    print(\"\\nTest case 3:\")\n    print(factorial_n_zeroes(1000000000))\n    print(\"Expected: 249999998\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "794": "```\ndef validTicTacToe(board):\n    n = len(board)\n    x_count = sum(1 for row in board if row.count('X'))\n    o_count = n - x_count\n    if x_count > n or (x_count == n and any(row.count('O') > 1 for row in board)):\n        return False\n    for i in range(n):\n        if sum(1 for row in board[i:i+2] for cell in row) >= 2:\n            if o_count <= 0:\n                return False\n            x_count -= 1\n            o_count -= 1\n    return True\n\ndef main():\n    test_cases = [\n        {\"board\": [[\"O\", \"O\"], [\"X\", \"O\"], [\"X\", \"O\"]], \"expected\": True},\n        {\"board\": [[\"X\", \"O\"], [\"O\", \"O\"], [\"O\", \"X\"]], \"expected\": False},\n        {\"board\": [[\"O\", \"O\", \"O\"], [\"O\", \"O\", \"X\"], [\"O\", \"O\", \"O\"]], \"expected\": False}\n    ]\n\n    for test_case in test_cases:\n        result = validTicTacToe(test_case[\"board\"])\n        if result != test_case[\"expected\"]:\n            print(f\"Test case failed: {test_case}\")\n            break\n    else:\n        print(\"All test cases passed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "795": "```\ndef numSubarrayBoundedMax(nums, left, right):\n    n = len(nums)\n    res = 0\n    for i in range(n):\n        count = 0\n        max_val = nums[i]\n        for j in range(i, n):\n            if nums[j] > max_val:\n                max_val = nums[j]\n            if max_val <= right and max_val >= left:\n                count += j - i + 1\n        res += count\n    return res\n\ndef main():\n    print(numSubarrayBoundedMax([2,1,4,3], 0, 3)) # Output: 27\n    print(numSubarrayBoundedMax([2,9,2,5,5,14,19], 6,10) ) # Output: 7\n    print(numSubarrayBoundedMax([0,0,1,0,3,4,0,0,2,0,4,4,2,0,3,2,1,0,0], 3, 4)) # Output: 13\n\nif __name__ == \"__main__\":\n    main()\n```",
  "796": "```\ndef findMinIndex(s):\n    min_index = 0\n    for i in range(1, len(s)):\n        if s[i] < s[min_index]:\n            min_index = i\n    return min_index\n\ndef rotateString(s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n        return False\n    min_index_s = findMinIndex(s)\n    rotated_s = s[min_index_s:] + s[:min_index_s]\n    return rotated_s == goal\n\ndef main():\n    print(rotateString(\"rabbbit\", \"abbitr\"))  # True\n    print(rotateString(\"abcde\", \"edcba\"))   # True\n    print(rotateString(\"apple\", \"pleap\"))     # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "797": "```\ndef allPathsSourceTarget(graph):\n    def dfs(node, path):\n        if node == target:\n            result.append(path)\n            return\n        for neighbor in graph[node]:\n            dfs(neighbor, path + [node])\n    \n    target = len(graph) - 1\n    result = []\n    dfs(0, [0])\n    return result\n\ndef main():\n    # Test case 1\n    graph1 = [[1,2],[3],[3],[]]\n    print(allPathsSourceTarget(graph1))\n\n    # Test case 2\n    graph2 = [[4,3,1],[3,2,4],[3],[4,3,1,0,2]]\n    print(allPathsSourceTarget(graph2))\n\n    # Test case 3\n    graph3 = [[1]]\n    print(allPathsSourceTarget(graph3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "798": "```\ndef maxScoreAfterRotation(nums):\n    n = len(nums)\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            score = sum((prefix_sum[j] - prefix_sum[i]) // (j-i+1))\n            if score > res:\n                res = score\n\n    return res\n\n\ndef main():\n    print(maxScoreAfterRotation([4, 10, 6, 8])) # Expected: 13\n    print(maxScoreAfterRotation([3, 1, 2, 5, 15])) # Expected: 23\n    print(maxScoreAfterRotation([0, 0, 0])) # Expected: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "799": "```\ndef maxDrop = (heights):\n    n = len(heights)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(1, n):\n        for j in range(i):\n            if heights[j] <= heights[i]:\n                dp[i][j] = min(dp[i - 1][k] + 1 for k in range(j) if heights[k] <= heights[i])\n            else:\n                dp[i][j] = dp[i - 1][j]\n                \n    return max(max(row) for row in dp)\n\ndef main():\n    print(maxDrop([2,1,5])) # Expected output: 3\n    print(maxDrop([4,2,2,2]) # Expected output: 1\n    print(maxDrop([6,6,8,1,7,5])) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "800": "```\ndef similarRGB(color1, color2):\n    r1, g1, b1 = int(color1[1:3], 16) // 255, int(color1[3:5], 16) // 255, int(color1[5:7], 16) // 255\n    r2, g2, b2 = int(color2[1:3], 16) // 255, int(color2[3:5], 16) // 255, int(color2[5:7], 16) // 255\n\n    return (abs(r1 - r2) + abs(g1 - g2) + abs(b1 - b2)) <= 100\n\n\ndef main():\n    print(similarRGB(\"#F5DEB3\", \"#E5DEFB\"))  # Expected: True\n    print(similarRGB(\"#E5DEFB\", \"#F5DEB3\"))  # Expected: True\n    print(similarRGB(\"#E5DEFB\", \"#D5C6B8\"))  # Expected: False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "801": "```\ndef minSwaps(nums1, nums2):\n    m = len(nums1)\n    n = len(nums2)\n    \n    dp = [[0] * (n+1) for _ in range(m+1)]\n    \n    for i in range(1, m+1):\n        if nums1[i-1] < nums2[0]:\n            dp[i][0] = 1\n        else:\n            dp[i][0] = dp[i-1][0]\n        \n        for j in range(1, n+1):\n            if nums1[i-1] >= nums2[j-1]:\n                dp[i][j] = min(dp[i][j-1], dp[i-1][j-1])\n            else:\n                dp[i][j] = 1 + dp[i-1][j-1]\n                \n    return dp[m][n]\n\ndef main():\n    print(minSwaps([2,1,3,3,4], [5,6,2,3,1])) # Output: 3\n    print(minSwaps([1,3,5,6,7],[7,6,5,4,3])) # Output: 12\n    print(minSwaps([0,1,2],[1,2,0])) # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "802": "```\ndef eventualSafestates(graph):\n    n = len(graph)\n    visited = [0] * n\n    result = []\n    \n    def dfs(i):\n        if visited[i] == -1:\n            return False\n        if visited[i] == 1:\n            return True\n        visited[i] = -1\n        for neighbor in graph[i]:\n            if not dfs(neighbor):\n                return False\n        visited[i] = 1\n        return True\n    \n    for i in range(n):\n        if visited[i] == 0 and not dfs(i):\n            result.append(i)\n    \n    return result\n\ndef main():\n    print(eventualSafestates([[1,2],[2,3],[5],[0,5], [4,5]]))\n    print(eventualSafestates([[2,1],[3,1],[4,3]]))\n    print(eventualSafestates([]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "803": "```\ndef fallenBricks(grid):\n    m, n = len(grid), len(grid[0])\n    parent = [i for i in range(m*n)]\n    rank = [0] * (m*n)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            else:\n                parent[rootX] = rootY\n                if rank[rootX] == rank[rootY]:\n                    rank[rootY] += 1\n\n    for i in range(m):\n        for j in range(n-1):\n            if grid[i][j+1] > grid[i][j]:\n                union(i*n + j, i*n + j+1)\n\n    for i in range(1, m):\n        for j in range(n):\n            if grid[i][j] < grid[i-1][j]:\n                union((i-1)*n + j, i*n + j)\n    fallen = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                continue\n            if find(i*n + j) != i*n + j:\n                fallen += 1\n    return fallen\n\n\ndef main():\n    print(fallenBricks([[1,2,3,4],[3,1,2,5]])) # expected: 2\n    print(fallenBricks([[1,2],[5,3,4]])) # expected: 6\n    print(fallenBricks([[1,2,5],[11,5,3],[5,8,4]])) # expected: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "804": "```\ndef numDistincts(words):\n    morse = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', \n             'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', \n             'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', \n             'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', \n             'Y': '-.--', 'Z': '--..', '1': '.----', '2': '..---', '3': '...--', \n             '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', \n             '9': '----.', '0': '-----', ' ': '/'}\n    distinct_words = set()\n    \n    for word in words:\n        morse_word = ''.join([morse[char.upper()] for char in word])\n        if morse_word not in distinct_words:\n            distinct_words.add(morse_word)\n    \n    return len(distinct_words)\n\ndef main():\n    print(numDistincts([\"Sandy\"])) # Test case 1\n    print(numDistincts([\"Sandy\", \"Let\", \"Meow\"])) # Test case 2\n    print(numDistincts([\"a\", \"b\", \"c\"])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "805": "```\ndef average(salary):\n    total = sum(salary)\n    if len(salary) % 2 == 0:\n        return len(salary) // 2\n    else:\n        return (len(salary) + 1) // 2\n\n\ndef split_array_with_same_average(salary):\n    total = sum(salary)\n    n = len(salary)\n    res = float('inf')\n    for i in range(n):\n        left_sum = sum(salary[:i+1])\n        right_sum = total - left_sum\n        if left_sum == right_sum * (n-1) or i == 0:\n            res = min(res, average([salary[i]] + [right_sum // (n-1)]*(n-2)))\n    return res\n\n\ndef main():\n    print(split_array_with_same_average([10, 6, 8, 5]))  # Expected: 3\n    print(split_array_with_same_average([3, 1]) == 1)  # Expected: True\n    print(split_array_with_same_average([2, 2, 2, 4]) == 2)  # Expected: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "806": "```\ndef numberOfLines(n, contents):\n    lines = 0\n    characters = 0\n    for content in contents:\n        if len(content) + characters > n:\n            lines += 1\n            characters = len(content)\n        else:\n            characters += len(content)\n    return [lines + 1, characters]\n\ndef main():\n    test_cases = [\n        {\"n\": 6, \"contents\": [\"write\", \"on\", \"smaller\"], \"expected_output\": [2, 6]},\n        {\"n\": 9, \"contents\": [\"write\", \"code\", \"try\", \"catch\", \"else\"], \"expected_output\": [1, 5]},\n        {\"n\": 4, \"contents\": [\"leet\", \"code\"], \"expected_output\": [1, 10]}\n    ]\n    \n    for test_case in test_cases:\n        output = numberOfLines(test_case[\"n\"], test_case[\"contents\"])\n        if output == test_case[\"expected_output\"]:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected {test_case['expected_output']}, got {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "807": "```\ndef maxIncreaseKeepingSkyline(grid):\n    m, n = len(grid), len(grid[0])\n    row_max = [max(row) for row in grid]\n    col_max = [max(col) for col in zip(*grid)]\n    \n    return sum(max(0, height - max_height) for height, max_height in zip([sum(heights) for heights in grid], row_max + col_max))\n\ndef main():\n    print(maxIncreaseKeepingSkyline([[3, 0, 8, 4], [2, 4, 5, 3], [1, 1, 2, 4]]))\n    print(maxIncreaseKeepingSkyline([[0, 0], [2, 8]]))\n    print(maxIncreaseKeepingSkyline([[9, 8, 7], [6, 5, 4], [3, 2, 1]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "808": "```\ndef soupServings(N):\n    if N > 10 * 1000:\n        return 1.0\n    dp = [[0.0] * (2 * N + 1) for _ in range(2 * N + 1)]\n    dp[0][0] = 1.0\n    for i in range(1, 2 * N + 1):\n        if i <= N:\n            dp[i][i] = 0.5\n        else:\n            dp[i][i] = 1.0\n    for length in range(1, 2 * N + 1):\n        for start in range(2 * N - length + 1):\n            for end in range(start, start + length):\n                if end > N:\n                    break\n                if start == end or (end < N and dp[start][start + length - 1] == 0.5):\n                    dp[start][end] = (dp[start][start + length - 1] * 0.5)\n                else:\n                    dp[start][end] = (dp[start][start + length - 1] * 0.5) + (dp[start + length][end] * 0.5)\n    return dp[0][2 * N]\n\ndef main():\n    print(soupServings(4))  # Test case 1\n    print(soupServings(10))  # Test case 2\n    print(soupServings(1000))  # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "809": "```\ndef expressiveWords(s: str, words: List[str]) -> int:\n    def helper(word: str) -> bool:\n        i, j = 0, 0\n        while i < len(s) and j < len(word):\n            if s[i] != word[j]:\n                return False\n            k = i + 1\n            length = 1\n            while k < len(s) and s[k] == s[i]:\n                k += 1\n            m = j + 1\n            temp_length = 0\n            while m < len(word) and word[m] == word[j]:\n                m += 1\n            if length != temp_length:\n                return False\n            i, j = k, m\n        return i >= len(s)\n\n    count = 0\n    for word in words:\n        if helper(word):\n            count += 1\n\n    return count\n\n\ndef main():\n    s = \"hello\"\n    words = [\"hello\", \"hi\", \"hell\"]\n    print(expressiveWords(s, words))\n    \n    s = \"a\"\n    words = [\"a\", \"aa\", \"aaa\"]\n    print(expressiveWords(s, words))\n    \n    s = \"kiexrxpxw\"\n    words = [\"kiexr\", \"kie\", \"kix\", \"kixer\", \"kiexr\", \"kxrpwx\", \"kiexrpxw\"]\n    print(expressiveWords(s, words))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "810": "```\ndef xorGame(arr):\n    n = len(arr)\n    return any(((val ^ i) & 1 for i in range(2**n)) for val in arr)\n\ndef main():\n    print(xorGame([5,7]) == True)\n    print(xorGame([2,1,3]) == False)\n    print(xorGame([6,5,4,8]) == True)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "811": "```\ndef subdomainVisits(cpdomains):\n    count_map = {}\n    for domain in cpdomains:\n        count, domain = map(str.split, domain)\n        count = int(count)\n        for i in range(len(domain)):\n            new_domain = \".\".join(domain[i:])\n            if new_domain not in count_map:\n                count_map[new_domain] = 0\n            count_map[new_domain] += count\n\n    return [\"{} {}\".format(count, domain) for domain, count in sorted(count_map.items())]\n\ndef main():\n    test_cases = [\n        [[\"9001 discuss.local\", \"901fcdb mail.global\"], [\"901fcdb global.mail\", \"90210 local\"],\n         [\"323456789 foreign\"]],\n        [[\"go.google.com\", \"club.ic.gov\"], [\"introduceme.int\",\"gangs.bar\", \"bob.trezoa.com\"]],\n        [[\"example.com\", \"localdomain.example.com\"]],\n\n    ]\n    \n    for test_case in test_cases:\n        print(subdomainVisits(test_case))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "812": "```\ndef largestTriangleArea(points):\n    n = len(points)\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                area = abs((points[i][0] * (points[j][1] - points[k][1]) +\n                            points[j][0] * (points[k][1] - points[i][1]) +\n                            points[i][0] * (points[i][1] - points[j][1])) / 2.0\n                max_area = max(max_area, area)\n    return max_area\n\ndef main():\n    test_cases = [\n        [[0,0],[0,1],[1,0]], \n        [[1,0],[2,2],[4,0]], \n        [[0,3],[1,1],[5,0]]\n    ]\n    \n    for case in test_cases:\n        print(f\"Largest Triangle Area with points {case}: {largestTriangleArea(case)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "813": "```\ndef max_average_subarrays_sum(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i+1] = prefix_sum[i] + nums[i]\n\n    max_sum = float('-inf')\n    for i in range(n):\n        left_sum = prefix_sum[i]\n        right_sum = total_sum - left_sum\n        if i > 0:\n            left_sum -= nums[i-1]\n        if i < n - 1:\n            right_sum -= nums[i]\n        max_sum = max(max_sum, min(left_sum / (i+1), right_sum / ((n-i)-1)))\n\n    return max_sum\n\ndef main():\n    print(\"Test case 1:\")\n    print(max_average_subarrays_sum([10,6,5,4,7,8])) # Expected output: 14.0\n    print()\n\n    print(\"Test case 2:\")\n    print(max_average_subarrays_sum([1,12,-5,-6,50,3])) # Expected output: 13.8\n    print()\n\n    print(\"Test case 3:\")\n    print(max_average_subarrays_sum([-9,-2,-8,-2,-5])) # Expected output: -3.625\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "814": "```\ndef pruneTree(root):\n    def dfs(node):\n        if not node:\n            return 0\n        left = dfs(node.left)\n        right = dfs(node.right)\n        if not node.val and not left and not right:\n            return 0\n        return 1 + max(left, right)\n\n    val = dfs(root)\n    if not val:\n        return None\n\n    def dfs_delete(node):\n        if not node:\n            return\n        if not node.val:\n            dfs_delete(node.left)\n            dfs_delete(node.right)\n        else:\n            dfs_delete(node.left)\n            dfs_delete(node.right)\n\n    dfs_delete(root)\n\nclass Solution:\n    def pruneTree(self, root):\n        return root if not root else pruneTree(0)\n\ndef main():\n    s = Solution()\n    test_cases = [\n        {\"root\": [1,null,0,0,1]},\n        {\"root\": [0,1]},\n        {\"root\": [1,0,1]}\n    ]\n    \n    for test_case in test_cases:\n        root = TreeNode.fromList(test_case[\"root\"])\n        result = s.pruneTree(root)\n        print(f\"Test case: {test_case['root']}\")\n        print(\"Pruned Tree:\", result.toList())\n        print()\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @classmethod\n    def fromList(cls, nodes):\n        if not nodes:\n            return None\n        \n        root = cls(nodes[0])\n        node_stack = [root]\n        i = 1\n        \n        while i < len(nodes):\n            current = node_stack.pop(0)\n            \n            if nodes[i]:\n                current.left = cls(nodes[i])\n                node_stack.append(current.left)\n            i += 1\n            \n            if i < len(nodes) and nodes[i]:\n                current.right = cls(nodes[i])\n                node_stack.append(current.right)\n            i += 1\n        \n        return root\n\n    def toList(self):\n        nodes = []\n        \n        def dfs(node):\n            if not node:\n                return\n            \n            nodes.append(node.val)\n            \n            dfs(node.left)\n            dfs(node.right)\n        \n        dfs(self)\n        return nodes\nif __name__ == \"__main__\":\n    main()\n```",
  "815": "```\ndef numBuses(mustTake, dontTake):\n    graph = {}\n    for i in range(len(mustTake)):\n        graph[i] = set()\n    \n    for stop in mustTake:\n        if stop[0] not in graph[stop[1]]:\n            graph[stop[1]].add(stop[0])\n        if stop[0] not in graph[stop[2]]:\n            graph[stop[2]].add(stop[0])\n    return len(graph)\n\ndef main():\n    print(numBuses([[10, 20], [30, 40]], []) == 1)\n    print(numBuses([[1, 4, 5], [2, 3, 4], [7, 8, 9]], []) == 2)\n    print(numBuses([], [[1, 2, 3], [3, 6, 10]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "816": "```\ndef ambiguousCoordinates(text: str) -> int:\n    def generate_coordinate(s):\n        if s[0] == '0':\n            return ['0'] + [s[i:i+1] for i in range(1, len(s))]\n        return ['0.' + s[i:] for i in range(len(s))] + [s[i:]+'.0' for i in range(len(s))]\n\n    def backtrack(index):\n        if index == len(text) - 1:\n            return [[], []]\n        coordinates = []\n        left = right = []\n        for i in range(1, len(text)-index):\n            left.append(str(int(text[index:index+i])))\n            right.append('.' + str(int(text[index:index+i])))\n        coordinates.extend([left, right] if len(left) > 0 and len(right) > 0 else [])\n        return coordinates\n\n    def is_valid_coordinate(coordinate):\n        for part in coordinate:\n            if part.startswith('0') and len(part) > 1 or not part[0].isdigit():\n                return False\n        return True\n\n    result = []\n    for coordinate in backtrack(0):\n        if is_valid_coordinate(coordinate) and len(coordinate) == 2:\n            result.append(coordinate)\n    return len(result)\n\ndef main():\n    print(ambiguousCoordinates(\"123\")) #1\n    print(ambiguousCoordinates(\"0000\")) #2\n    print(ambiguousCoordinates(\"101010\")) #3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "817": "```\nclass Solution:\n    def numComponents(self, head1: Optional[ListNode], head2: Optional[ListNode]) -> int:\n        seen = set()\n        p1, p2 = head1, head2\n        count = 0\n        \n        while p1 and p2:\n            if p1.val != p2.val:\n                p1, p2 = p1.next, p2.next\n                continue\n            if (p1 not in seen) or (p2 not in seen):\n                seen.add(p1)\n                seen.add(p2)\n                count += 1\n            p1, p2 = p1.next, p2.next\n        \n        return count\n\ndef main():\n    s = Solution()\n    head1 = ListNode(1,ListNode(2,ListNode(3)))\n    head2 = ListNode(1,ListNode(1))\n    print(s.numComponents(head1, head2))  # Output: 2\n    \n    head1 = ListNode(0)\n    head2 = ListNode(1)\n    print(s.numComponents(head1, head2))  # Output: 0\n    \n    head1 = ListNode(1,ListNode(3,ListNode(4)))\n    head2 = ListNode(1,ListNode(3,ListNode(4)))\n    print(s.numComponents(head1, head2))  # Output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "818": "```\ndef racecar(target: int) -> int:\n    dp = [[0] * (target + 1) for _ in range(target + 1)]\n    \n    for i in range(target):\n        dp[i][i+1] = 2\n    for length in range(3, target + 1):\n        for i in range(target - length + 1):\n            j = i + length\n            dp[i][j] = min(dp[i][k] + 2 + dp[k+1][j] if k < j else 2 for k in range(i, j)) + (j - i)\n    \n    return dp[0][target]\n\ndef main():\n    print(\"Test case 1: target = 5, expected result = 3\")\n    print(racecar(5) == 3)\n\n    print(\"\\nTest case 2: target = 10, expected result = 12\")\n    print(racecar(10) == 12)\n\n    print(\"\\nTest case 3: target = 6, expected result = 5\")\n    print(racecar(6) == 5)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "819": "```\ndef mostCommonWord(sentence: str) -> str:\n    words = sentence.split()\n    word_count = {}\n    for word in words:\n        word = word.lower().strip(\"!'?,;\")\n        if word not in word_count:\n            word_count[word] = 1\n        else:\n            word_count[word] += 1\n\n    max_count = max(word_count.values())\n    most_common_words = [word for word, count in word_count.items() if count == max_count]\n    return min(most_common_words)\n\ndef main():\n    print(mostCommonWord(\"Bob hit a poker to save their home.\")) # Test case 1\n    print(mostCommonWord(\"aa bb cc dd ee \")) # Test case 2\n    print(mostCommonWord(\"   Bob hit     a poker to save their home.\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "820": "```\ndef wordsBySize(words):\n    word_count = {}\n    for word in words:\n        prefix_len = 0\n        while prefix_len < len(word) and (prefix_len == 0 or word[prefix_len] != word[0]):\n            prefix_len += 1\n        if prefix_len not in word_count:\n            word_count[prefix_len] = [word]\n        else:\n            word_count[prefix_len].append(word)\n    return list(word_count.values())\n\ndef main():\n    words = [\"time\", \"me\", \"bell\"]\n    print(wordsBySize(words))  # Output: [['me'], ['time'], ['bell']]\n\n    words = [\"a\", \"apple\", \"app\", \"ap\"]\n    print(wordsBySize(words))  # Output: [['ap'], ['app', 'apple']]\n\n    words = [\"wheat\", \"wool\", \"fish\", \"whale\", \"wood\", \"wolf\"]\n    print(wordsBySize(words))  # Output: [['fish'], ['whale', 'wolf'], ['wheat', 'wool', 'wood']]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "821": "```\ndef shortestToChar(s: str, c: str) -> List[int]:\n    result = []\n    last_c_index = -1\n    for i in range(len(s)):\n        if s[i] == c:\n            last_c_index = i\n        result.append(i - last_c_index)\n    for i in range(last_c_index + 1, len(s)):\n        result.append(i - last_c_index)\n    return result\n\ndef main():\n    print(shortestToChar(\"hello\", \"h\")) \n    # Output: [0, 1, 2, 3, 4]\n\n    print(shortestToChar(\"a\"), \"b\"))\n    # Output: [-1,-1,-1,-1,-1,-1]\n    \n    print(shortestToChar(\"love\", \"e\"))\n    # Output: [3, 2, 1, 0, 1]\n    \nif __name__ == \"__main__\":\n    main()\n```",
  "822": "```\ndef max_flips(card_flips):\n    count = {}\n    for flip in card_flips:\n        if flip not in count:\n            count[flip] = 0\n        count[flip] += 1\n    return len(count) - max(count.values())\n\ndef main():\n    test_cases = [\n        {\"card_flips\": [0, 1], \"expected_output\": 2},\n        {\"card_flips\": [0, 1, 0], \"expected_output\": 3},\n        {\"card_flips\": [0, 1, 1, 0], \"expected_output\": 4}\n    ]\n\n    for test_case in test_cases:\n        output = max_flips(test_case[\"card_flips\"])\n        if output == test_case[\"expected_output\"]:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed. Expected {test_case['expected_output']}, got {output}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "823": "```\ndef numFactoredBinaryTrees(root):\n    MOD = int(1e9 + 7)\n\n    def dfs(node):\n        if not node:\n            return 0\n        left, right = root_val.index(node.val), 0\n        count = [left + 1]\n        for neighbor in root[neighbor_idx[left]]:\n            neighbor_idx.append(2 * len(root))\n            neighbor_idx.append(2 * len(root) + 1)\n            idx = len(root)\n            for child in [neighbor, node]:\n                if child.val == neighbor.val:\n                    count.append(count[-1] * (left + right + 1))\n                    break\n                root[idx] = child\n                dfs(child)\n                idx += 1\n        return min(count)\n\n    def build(root, neighbors):\n        nonlocal neighbor_idx\n        for _ in range(len(neighbors)):\n            node = TreeNode(int(input()))\n            root.append(node)\n        neighbor_idx.extend([0] * len(neighbors))\n\n    MOD = int(1e9 + 7)\n\n    class Solution:\n        def numFactoredBinaryTrees(self, root):\n            self.root_val = [root.val]\n            self.neighbor_idx = [0]\n\n            return dfs(root)\n\n    if __name__ == \"__main__\":\n        s = Solution()\n\n        print(s.numFactoredBinaryTrees(TreeNode(2)))\n        print(s.numFactoredBinaryTrees(TreeNode(4)))\n        print(s.numFactoredBinaryTrees(TreeNode(5)))\n```",
  "824": "```\ndef toGoatLatin(sentence):\n    vowels = \"aeiouAEIOU\"\n    words = sentence.split()\n    answer = []\n    \n    for word in words:\n        if len(word) >= 1 and word[0] in vowels:\n            answer.append(word + 'ma' + 'a'*len(word))\n        else:\n            answer.append(word[1:] + word[0] + 'ma' + 'a'*len(word))\n            \n    return ' '.join(answer)\n\ndef main():\n    print(toGoatLatin(\"I speak Goat Latin\"))\n    print(toGoatLatin(\"The sunny weather is nice today\"))\n    print(toGoatLatin(\"Hello world\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "825": "```\ndef numFriends(groups):\n    n = len(groups)\n    groups.sort()\n    res = 0\n    i = 0\n    for age in range(1, 151):\n        while i < n and groups[i] <= age:\n            i += 1\n        res += (n - i)\n\n    return res\n\ndef main():\n    print(numFriends([2,1,3])) # expected output: 3\n    print(numFriends([7,5,9,10,14])) # expected output: 6\n    print(numFriends([1,4,2,10,5,7])) # expected output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "826": "```\ndef maxProfitAssignment(workerSkills, workerWorkloads, goals):\n    workerSkills.sort()\n    workerWorkloads.sort()\n    totalProfit = 0\n    for i in range(len(workerSkills)):\n        left, right = 0, len(workerWorkloads) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if workerWorkloads[mid] >= goals[i]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        totalProfit += max(0, min(workerSkills[i], workerWorkloads[left]) - goals[i])\n    return totalProfit\n\ndef main():\n    print(\"Test case 1:\")\n    print(maxProfitAssignment([4,5,6,7],[10,6,15,20],[2,7,5]),\"should be\",12)\n\n    print(\"\\nTest case 2:\")\n    print(maxProfitAssignment([2,7,17,23],[92,95,109,115], [102]),\"should be\",1)\n\n    print(\"\\nTest case 3:\")\n    print(maxProfitAssignment([9,8,7,6,5,4,3,2,1], [10,20,40,50,60,70,80,90,100], [5]),\"should be\",45)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "828": "```\ndef uniqueSubstrings(s):\n    res = set()\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n+1):\n            sub = s[i:j]\n            res.add(frozenset(sub))\n    return len(res)\n\ndef main():\n    print(\"Test case 1: \")\n    print(uniqueSubstrings(\"ABC\")) # expected output: 6\n\n    print(\"\\nTest case 2: \")\n    print(uniqueSubstrings(\"AZIZ\")) # expected output: 12\n\n    print(\"\\nTest case 3: \")\n    print(uniqueSubstrings(\"aaaaaa\")) # expected output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "827": "```\ndef maxAreaOfIsland(grid):\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    visited = [[False for _ in range(n)] for _ in range(m)]\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or visited[i][j] or grid[i][j] == 0:\n            return 0\n        visited[i][j] = True\n        area = 1\n        for direction in directions:\n            ni, nj = i + direction[0], j + direction[1]\n            area += dfs(ni, nj)\n        return area\n\n    max_area = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1 and not visited[i][j]:\n                max_area = max(max_area, dfs(i, j))\n    return max_area\n\n\ndef main():\n    test_cases = [\n        # Test case 1:\n        [[0,0,1,0,0],[0,0,1,0,0],[0,0,1,0,0],[0,0,0,1,1]],\n        \n        # Test case 2:\n        [[1,1,0,0,0],[1,1,0,0,0],[0,0,1,0,0],[0,0,1,0,0]],\n\n        # Test case 3:\n        [[1,1,0,0,0,0,0,1],\n         [1,1,0,0,0,0,0,1],\n         [0,0,1,1,1,1,1,0],\n         [0,0,1,1,1,1,1,0],\n         [0,0,0,0,0,0,0,0]]\n    ]\n\n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        result = maxAreaOfIsland(test_case)\n        print(f\"Result: {result}\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "829": "```\ndef sumGame(nums):\n    n = len(nums)\n    left_sum = right_sum = 0\n    for i in range(n // 2):\n        left_sum += nums[i]\n        right_sum += nums[n - i - 1]\n    return (left_sum == right_sum) or ((left_sum + 1) % 3 != (right_sum + 1) % 3)\n\ndef main():\n    print(sumGame([23, 37, 365, 400]))  # Expected output: True\n    print(sumGame([11, 2, 33, 5, 23, 4, 15, 20]))  # Expected output: False\n    print(sumGame([1, 3, 4, 6]))  # Expected output: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "830": "```\ndef largeGroupPositions(s):\n    result = []\n    i = 0\n    while i < len(s):\n        j = i + 1\n        while j < len(s) and s[i] == s[j]:\n            j += 1\n        if j - i > 2:\n            result.append((i, j - 1))\n        i = j\n    return result\n\ndef main():\n    test_cases = [\n        {\"s\": \"abbcccdd\", \"expected_result\": [[3, 5], [6, 7]]},\n        {\"s\": \"xyzzy\", \"expected_result\": []},\n        {\"s\": \"aaaabbbccc\", \"expected_result\": [[0, 2], [2, 5], [5, 7]]}\n    ]\n\n    for test_case in test_cases:\n        result = largeGroupPositions(test_case[\"s\"])\n        if result == test_case[\"expected_result\"]:\n            print(\"Test case passed.\")\n        else:\n            print(f\"Test case failed. Expected {test_case['expected_result']} but got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "831": "```\ndef mask_email(email):\n    if '@' in email:\n        name, domain = email.split('@')\n        return name[0] + '*****@' + domain\n    else:\n        return 'Invalid email address'\n\ndef main():\n    print(mask_email(\"leecoder123@gmail.com\"))  # Test case 1\n    print(mask_email(\"baba@leetcode.com\"))  # Test case 2\n    print(mask_email(\"jimsmith@email.com\"))  # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "832": "```\ndef flipAndIncrement(image):\n    result = [[0 for _ in range(len(image[0]))] for _ in range(len(image))]\n    for i in range(len(image)):\n        for j in range(len(image[0])):\n            if image[i][j] == 1:\n                result[len(image) - 1 - i][j] = 1\n    return result\n\ndef main():\n    test_case1 = [[1,1,0],[1,0,1],[0,0,0]]\n    print(f\"Test case 1: {flipAndIncrement(test_case1)}\")\n\n    test_case2 = [[1,0,1],[0,0,0],[0,0,0]]\n    print(f\"Test case 2: {flipAndIncrement(test_case2)}\")\n\n    test_case3 = [[0,1], [1,1]]\n    print(f\"Test case 3: {flipAndIncrement(test_case3)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "833": "```\ndef findReplaceString(s: str, indices: list[int], values: list[str]) -> str:\n    res = s\n    for i, v in zip(indices, values):\n        if i < len(s) and s[i] == chr(i + ord('a')):\n            res = res[:i] + v + res[i+1:]\n    return res\n\ndef main():\n    print(findReplaceString(\"hello\", [0, 5], [\"hix\", \"hiy\"])) # expected: \"hixiy\"\n    print(findReplaceString(\"vmokaaa\", [1, 4, 3], [\"x\", \"xx\", \"ae\"]), end=\"\\n\") \n    print(findReplaceString(\"a\", [0], [\"aaaaa\"]), end=\"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "834": "```\ndef sumOfDistancesInTree(n, edges):\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    res = [0] * n\n    def dfs(i, parent):\n        for j in graph[i]:\n            if j != parent:\n                res[j] = 1 + res[i]\n                res[i] += res[j]\n                dfs(j, i)\n    dfs(0, -1)\n\n    return res\n\ndef main():\n    test_cases = [\n        ([6,2,3],[5]),\n        ([2,3,4],[1]),\n        ([3,8,5,4,2,10],[1])\n    ]\n\n    for case in test_cases:\n        n = case[0][0]\n        edges = case[1]\n        print(\"Input: \", n, \"edges:\", edges)\n        result = sumOfDistancesInTree(n, edges)\n        print(\"Result: \", result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "835": "```\ndef findOverlappingAreas(grid1, grid2):\n    def overlap(matrix1, matrix2):\n        for i in range(min(len(matrix1), len(matrix2))):\n            for j in range(min(len(matrix1[0]), len(matrix2[0]))):\n                if matrix1[i][j] == 1 and matrix2[i][j] == 1:\n                    return True\n        return False\n\n    result = []\n    for i in range(len(grid1)):\n        temp = []\n        for j in range(len(grid1[0])):\n            if overlap(grid1[i], grid2[i]):\n                temp.append(1)\n            else:\n                temp.append(0)\n        result.append(temp)\n    return result\n\n\ndef main():\n    # Test case 1\n    grid1 = [[1, 1, 0], [0, 1, 0]]\n    grid2 = [[1, 0, 0], [1, 0, 0]]\n    expected_result = [[1, 0, 0], [1, 1, 0]]\n    print(findOverlappingAreas(grid1, grid2))\n    assert findOverlappingAreas(grid1, grid2) == expected_result\n\n    # Test case 2\n    grid1 = [[0, 0, 0], [0, 1, 0], [0, 1, 1]]\n    grid2 = [[0, 0, 1], [0, 1, 1], [0, 1, 1]]\n    expected_result = [[0, 0, 1], [0, 1, 1], [0, 1, 1]]\n    print(findOverlappingAreas(grid1, grid2))\n    assert findOverlappingAreas(grid1, grid2) == expected_result\n\n    # Test case 3\n    grid1 = [[1, 1, 0, 0], [0, 1, 1, 1], [1, 1, 0, 1]]\n    grid2 = [[0, 0, 1, 1], [1, 1, 1, 1], [0, 1, 0, 0]]\n    expected_result = [[0, 0, 1, 1], [1, 1, 1, 1], [0, 1, 0, 0]]\n    print(findOverlappingAreas(grid1, grid2))\n    assert findOverlappingAreas(grid1, grid2) == expected_result\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "836": "```\ndef computeArea(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\n    area1 = (ax2 - ax1) * (ay2 - ay1)\n    area2 = (bx2 - bx1) * (by2 - by1)\n\n    overlapWidth = max(0, min(ax2, bx2) - max(ax1, bx1))\n    overlapHeight = max(0, min(ay2, by2) - max(ay1, by1))\n\n    return area1 + area2 - overlapWidth * overlapHeight\n\ndef main():\n    print(\"Test Case 1: \")\n    print(computeArea(1, 1, 3, 3, 2, 2, 4, 4)) # Expected output: 9\n    \n    print(\"\\nTest Case 2: \")\n    print(computeArea(-3, 0, 3, 4, -1, 0, 5, 5)) # Expected output: 20\n\n    print(\"\\nTest Case 3: \")\n    print(computeArea(0, 0, 2, 2, 1, 1, 3, 3)) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "837": "```\ndef hasGroupsSizeX(X):\n    if not X:\n        return False\n    \n    from collections import Counter\n    \n    count = Counter(X)\n    x = list(count.keys())[0]\n    \n    for k, v in count.items():\n        if v < 2:\n            return False\n        while v % (k) != 0:\n            v //= k\n    return True\n\n\ndef main():\n    print(hasGroupsSizeX([2, 6, 2, 6])) # Expected: True\n    print(hasGroupsSizeX([2, 4, 2, 4, 7]) ) # Expected: False\n    print(hasGroupsSizeX([x for x in range(1, 22)])) # Expected: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "838": "```\ndef pushDominoes(dominoes):\n    n = len(dominoes)\n    left, right = [0] * n, [0] * n\n    for i in range(n):\n        if dominoes[i] == 'L':\n            left[i] = 1\n        elif dominoes[i] == 'R':\n            right[i] = -1\n    for i in range(1, n):\n        if left[i]:\n            left[i] += left[i-1]\n        else:\n            left[i] = right[i-1] if right[i-1] > 0 else 0\n    max_val = max(left)\n    for i in range(n-1, -1, -1):\n        if right[i]:\n            right[i] += right[i+1]\n        else:\n            right[i] = left[i+1] if left[i+1] > 0 else 0\n        right[i] = min(right[i], max_val)\n    res = ''\n    for i in range(n):\n        if left[i] > right[i]:\n            res += 'R'\n        elif left[i] < right[i]:\n            res += 'L'\n        else:\n            res += dominoes[i]\n    return res\n\ndef main():\n    print(pushDominoes(\"RR.R.L\"))  # Expected: RRR.L\n    print(pushDominoes(\".LR.B..\"))  # Expected: .RBLBL.R.\n    print(pushDominoes(\"L.R.K...R\"))  # Expected: LRLLKK.R\n\nmain()\n```",
  "839": "```\ndef numSimilarGroups(strs):\n    def dfs(i, j):\n        if i == len(strs[0]):\n            return j\n        if strs[i][j] != strs[j][i]:\n            return float('inf')\n        if i < 1:\n            return 0\n        if j < 0 or j >= len(strs[0]):\n            return -float('inf')\n\n        if strs[i-1][j] == strs[i-1][j-1] and strs[i-1][j+1] == strs[j-1][j]:\n            return dfs(i-1, j-1) + 1\n        else:\n            return float('inf')\n\n    def union(i, j):\n        if group[i] < 0:\n            return\n        if group[j] < 0:\n            return\n        if group[i] == group[j]:\n            return\n        if -group[i] > -group[j]:\n            group[j] = i\n        else:\n            group[i] = j\n\n    def find(i):\n        if group[i] < 0:\n            return i\n        return find(group[i])\n\n    n = len(strs)\n    m = len(strs[0])\n    group = [-1]*n\n    for i in range(n):\n        group[i] = i\n    for i in range(n):\n        for j in range(m):\n            if strs[i][j] == strs[j]:\n                j = j + 1\n                while j < m and strs[i][j] == strs[j]:\n                    j += 1\n                union(i, int(j))\n    groups = set()\n    for i in range(n):\n        groups.add(find(i))\n\n    return len(groups)\n\ndef main():\n    print(numSimilarGroups([\"aba\",\"baa\",\"baab\"])) # Expected output: 1\n    print(numSimilarGroups([\"aaa\",\"baa\",\"daa\"])) # Expected output: 4\n    print(numSimilarGroups([\"aa\", \"bb\"])) # Expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "840": "```\ndef numMagicSquaresInside(grid):\n    if not grid:\n        return 0\n\n    n = len(grid)\n    total_sum = sum(sum(row) for row in grid)\n\n    if total_sum != (n * (n * n + 1) // 2):\n        return 0\n\n    magic_count = 0\n    for i in range(n):\n        for j in range(n):\n            if not is_magic(grid[i], n):\n                return 0\n\n    return magic_count\n\n\ndef is_magic(square, size):\n    total_sum = sum(square)\n    half_sum = total_sum // (size * size)\n\n    if total_sum % (size * size) != 0:\n        return False\n\n    for i in range(size):\n        row_sum = sum(square[i])\n        if row_sum != half_sum:\n            return False\n        col_sum = sum(square[j][i] for j in range(size))\n        if col_sum != half_sum:\n            return False\n\n    for k in range(1, size // 2 + 1):\n        for i in range(k, size - k):\n            for j in range(k, size - k):\n                a = square[i][j]\n                b = square[i][size - j - 1]\n                c = square[size - i - 1][j]\n                d = square[size - i - 1][size - j - 1]\n\n                if (a + b + c + d) != half_sum:\n                    return False\n\n    return True\n\n\ndef main():\n    grid1 = [\n        [4, 1, 8],\n        [5, 5, 5],\n        [6, 7, 3]\n    ]\n    print(numMagicSquaresInside(grid1))  # Expected output: 1\n\n    grid2 = [\n        [16, 16],\n        [16, 0]\n    ]\n    print(numMagicSquaresInside(grid2))  # Expected output: 0\n\n    grid3 = [\n        [2, 3, 4, 5],\n        [5, 6, 7, 8],\n        [9, 10, 11, 12],\n        [13, 14, 15, 16]\n    ]\n    print(numMagicSquaresInside(grid3))  # Expected output: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "841": "```\ndef openLock(deadends, your_keys):\n    n = len(your_keys)\n    graph = [[] for _ in range(10000)]\n    for i in range(n):\n        for j in range(i+1, n):\n            num1 = int(your_keys[i][0:5], 16)\n            num2 = int(your_keys[j][0:5], 16)\n            diff = abs(num1 - num2) % 10000\n            if diff <= 500:\n                graph[num1].append((num2, diff))\n                graph[num2].append((num1, diff))\n\n    def dfs(i, visited):\n        if i in deadends:\n            return False\n        if i in visited:\n            return True\n        visited.add(i)\n        for j, k in graph[i]:\n            if dfs(j, visited):\n                return True\n        visited.remove(i)\n        return False\n\n    res = []\n    for i in range(10000):\n        if i == 0 or i == 10000 - 1:\n            continue\n        if not dfs(i, set()):\n            res.append(your_keys[i][5])\n    return ' '.join(res)\n\ndef main():\n    print(openLock([\"0009\",\"0066\",\"0001\"], [\"0000\"]))\n    print(openLock([\"1981\",\"6484\",\"7510\"], []))\n    print(openLock([\"0101\",\"1010\",\"1101\",\"0111\"], [\"0011\",\"1111\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "842": "```\ndef splitIntoFibonacci(s):\n    def dfs(i, fibs):\n        if i == len(s):\n            return True\n        for j in range(1, min(len(s) - i + 1, 10)):\n            num = int(s[i:i+j])\n            if (num > 9 and len(fibs) < 2) or (len(fibs) >= 2 and fibs[-1] != num + fibs[-2]):\n                return False\n            fibs.append(num)\n            if dfs(i+j, fibs):\n                return True\n            fibs.pop()\n            while fibs and fibs[-1] == fibs[-2]:\n                fibs.pop()\n        return False\n\n    res = []\n    if not dfs(0, []):\n        return []\n    return res\n\n\ndef main():\n    print(splitIntoFibonacci(\"123456789\"))  # Output: [12,21,34]\n    print(splitIntoFibonacci(\"11235813\"))   # Output: [11,2,3,5,8,13]\n    print(splitIntoFibonacci(\"493773713\"))   # Output: [49,37,373]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "843": "```\ndef getHint(secret, guess):\n    hint = [0] * 2\n    for i in range(len(secret)):\n        if secret[i] == guess[i]:\n            hint[0] += 1\n        elif guess.count(str(guess[i])) > 0:\n            hint[1] += 1\n    return str(hint[0]) + 'A' + str(hint[1] - hint[0]) + 'B'\n\ndef main():\n    print(getHint(\"1807\", \"7810\")) \n    print(getHint(\"1123\", \"0111\")) \n    print(getHint(\"11725\", \"23245\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "844": "```\ndef backspaceCompare(A: str, B: str) -> bool:\n    def processStr(s):\n        res = []\n        for c in s:\n            if c != '#':\n                res.append(c)\n            elif res:\n                res.pop()\n        return ''.join(res)\n\n    return processStr(A) == processStr(B)\n\n\ndef main():\n    print(backspaceCompare(\"ab#c\", \"ad#c\") == True)\n    print(backspaceCompare(\"a##c\", \"#a#c\") == True)\n    print(backspaceCompare(\"xy#zzyzx\", \"zy#xzx\") == True)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "845": "```\ndef longestMountain(arr):\n    n = len(arr)\n    res = 0\n    i = 0\n    \n    while i < n:\n        if arr[i] >= arr[i+1]:\n            i += 1\n            continue\n        \n        left, right = i, i\n        while i+1 < n and arr[i+1] < arr[i]:\n            i += 1\n            right = i\n        while i+1 < n and arr[i+1] > arr[i]:\n            i += 1\n            left = i\n        \n        res = max(res, right - left)\n    \n    return res\n\ndef main():\n    print(longestMountain([2,2,2])) # Test case 1\n    print(longestMountain([2,1,4,7,3,2,5])) # Test case 2\n    print(longestMountain([2,2,1,2,1,3,1,4,2,7,6,3,4,5])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "846": "```\ndef bestHand(ranks, suits):\n    from collections import Counter\n    suit_count = len(set(suits))\n    rank_count = len(Counter(ranks))\n\n    if suit_count == 1:\n        return \"Flush\"\n    elif rank_count <= 5:\n        return \"Straight\"\n    else:\n        return \"High Card\"\n\ndef main():\n    test_cases = [\n        {\"ranks\": [13, 2, 3, 11, 10], \"suits\": [\"A\", \"A\", \"A\", \"A\", \"A\"], \"expected_result\": \"Flush\"},\n        {\"ranks\": [14, 4, 15, 5, 16], \"suits\": [\"X\", \"X\", \"Y\", \"Y\", \"Z\"], \"expected_result\": \"High Card\"},\n        {\"ranks\": [1, 2, 3, 4, 5], \"suits\": [\"S\", \"H\", \"C\", \"D\", \"S\"], \"expected_result\": \"Straight\"}\n    ]\n\n    for test_case in test_cases:\n        result = bestHand(test_case[\"ranks\"], test_case[\"suits\"])\n        if result == test_case[\"expected_result\"]:\n            print(f\"Test case passed: {test_case['ranks']} and {test_case['suits']} returned '{result}'\")\n        else:\n            print(f\"Test case failed: {test_case['ranks']} and {test_case['suits']} returned '{result}', expected '{test_case['expected_result']}'\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "847": "```\ndef shortestPathLength(graph):\n    n = len(graph)\n    dist = [[float('inf')] * (1 << n) for _ in range(n)]\n    for i in range(n):\n        dist[i][0] = 0\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for mask in range(1 << n):\n        for i in range(n):\n            if ((mask >> i) & 1):\n                continue\n            for j in range(n):\n                if ((mask | (1 << i)) & (1 << j)):\n                    continue\n                if (dist[i][mask | (1 << j)] > dist[j][mask] + 1):\n                    dist[i][mask | (1 << j)] = dist[j][mask] + 1\n\n    return max(max(row) for row in dist)\n\ndef main():\n    graph1 = [[0,1,3],[1,0,2],[3,2,4]]\n    print(shortestPathLength(graph1))\n\n    graph2 = [[0,1,2,3},{1,0,2,4},{2,2,3,5},{3,4,5,6}]\n    print(shortestPathLength(graph2))\n\n    graph3 = [[0, 1], [1, 0]]\n    print(shortestPathLength(graph3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "848": "```\ndef shuffleString(s: str) -> int:\n    s = s.lower()\n    n = len(s)\n    count = [0] * 26\n    for char in s:\n        count[ord(char) - ord('a')] += 1\n    \n    left, right = sum(1 for count_char in count if count_char > n // 2), sum(1 for count_char in count if count_char < n // 2)\n    \n    return min(left, right)\n\ndef main():\n    print(shuffleString(\"abc\")) \n    print(shuffleString(\"aabaa\")) \n    print(shuffleString(\"aaaabbb\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "849": "```\ndef maxDistToClosest(seats):\n    n = len(seats)\n    res = [0]\n    for i in range(n):\n        if seats[i] == 1:\n            if i == 0:\n                res.append(n - 1)\n            elif i == n - 1:\n                res.append(i)\n            else:\n                res.append(min(i, n - 1 - i))\n        else:\n            continue\n    return max(res)\n\ndef main():\n    print(maxDistToClosest([0,0,1,0,0,0])) # Test case 1\n    print(maxDistToClosest([1,0,0,0])) # Test case 2\n    print(maxDistToClosest([1,0,0,0,1,0,1,0])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "850": "```\ndef totalArea(widths):\n    max_width = max(widths)\n    max_area = max_width * sum(1 for w in widths if w == max_width)\n    stack = [(0, 0)]\n    active_area = 0\n    for i, width in enumerate(widths):\n        while len(stack) > 1 and stack[-2][1] >= width:\n            h1, w1 = stack.pop()\n            h2, w2 = stack[-1]\n            dh = i - h2\n            dw = w2 - w1\n            active_area += (min(width, w2) * dh + min(width, w1) * dw)\n        if width > 0:\n            stack.append((i, width))\n    while len(stack) > 1:\n        h1, w1 = stack.pop()\n        h2, w2 = stack[-1]\n        dh = max_width - h2\n        dw = w2 - w1\n        active_area += (min(max_width, w2) * dh + min(max_width, w1) * dw)\n    return max_area + active_area\n\ndef main():\n    print(totalArea([8, 6, 8])) # Test case 1: Expected output 30\n    print(totalArea([4, 8, 12, 16])) # Test case 2: Expected output 67\n    print(totalArea([3, 14, 10])) # Test case 3: Expected output 26\n\nif __name__ == \"__main__\":\n    main()\n```",
  "851": "```\ndef loudAndRich(richFriends, quietFriends):\n    graph = [[] for _ in range(len(richFriends))]\n    for i in range(len(richFriends)):\n        for j in friendList:\n            if richFriends[i][j] == 1:\n                graph[i].append(j)\n    \n    def dfs(node):\n        if not visited[node]:\n            visited[node] = True\n            minQuietFriendIndex = node\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    quietFriendIndex = dfs(neighbor)\n                    if quietFriendIndex < minQuietFriendIndex:\n                        minQuietFriendIndex = quietFriendIndex\n                elif visited[neighbor]:\n                    if quietFriends[neighbor] < quietFriends[minQuietFriendIndex]:\n                        minQuietFriendIndex = neighbor\n            return minQuietFriendIndex\n\n    richPeopleWithQuietestFriend = []\n    for i in range(len(richFriends)):\n        visited = [False] * len(quietFriends)\n        richPeopleWithQuietestFriend.append(dfs(i))\n    \n    return richPeopleWithQuietestFriend\n\n\ndef main():\n    richFriends1 = [[2, 0], [1, 2]]\n    quietFriends1 = [3, 5]\n    print(loudAndRich(richFriends1, quietFriends1))  # Expected: [1, 0]\n\n    richFriends2 = [[2, 1], [3, 2], [4, 0], [0, 4]]\n    quietFriends2 = [0, 5, 6, 1]\n    print(loudAndRich(richFriends2, quietFriends2))  # Expected: [4, 5, 6, 0]\n\n    richFriends3 = [[0, 1], [1, 2], [3, 4]]\n    quietFriends3 = [0, 5, 2, 4]\n    print(loudAndRich(richFriends3, quietFriends3))  # Expected: [1, 2, 4, 0]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "852": "```\ndef peakIndexInMountainArray(arr):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < arr[mid+1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef main():\n    print(\"Test case 1: \")\n    arr = [0,2,3,4,5]\n    print(\"The peak index is:\", peakIndexInMountainArray(arr))\n    \n    print(\"\\nTest case 2: \")\n    arr = [0,3,2]\n    print(\"The peak index is:\", peakIndexInMountainArray(arr))\n    \n    print(\"\\nTest case 3: \")\n    arr = [0,1,0]\n    print(\"The peak index is:\", peakIndexInMountainArray(arr))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "853": "```\ndef calculateSpeedDistance(travelled, speed):\n    fleet = []\n    stack = []\n    \n    for i in range(len(travelled)):\n        while len(stack) > 0 and stack[-1][1] < speed[i]:\n            start, distance = stack.pop()\n            hours = (travelled[i] - start) / speed[i]\n            fleet.append((hours + distance, speed[i]))\n            stack.append((start, distance))\n        \n        if len(stack) == 0:\n            stack.append((travelled[i], 0))\n        else:\n            stack.append((stack[-1][0], stack[-1][1] + (travelled[i] - stack[-1][0]) / speed[i]))\n    \n    while len(stack) > 0:\n        start, distance = stack.pop()\n        hours = (travelled[-1] - start) / speed[-1]\n        fleet.append((hours + distance, speed[-1]))\n    \n    return fleet\n\ndef main():\n    print(calculateSpeedDistance([10, 3, 3], 4))  # expected output: [(2.0, 4), (7.5, 3)]\n    print(calculateSpeedDistance([10, 6, 8, 14, 15], 1))  # expected output: [(11.0, 1), (6.0, 1), (3.0, 1), (8.0, 1), (1.0, 1)]\n    print(calculateSpeedDistance([5, 4, 18], 2))  # expected output: [(7.5, 2), (10.5, 2)]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "854": "```\nfrom collections import deque\n\ndef are_k_similarity(s1, s2, k):\n    if abs(len(s1) - len(s2)) > k:\n        return False\n    if k == 0:\n        return s1 == s2\n    \n    queue = [(s1, 0)]\n    visited = set([s1])\n    \n    while queue:\n        word, level = queue.pop(0)\n        \n        if level == k and word != s2:\n            return False\n        \n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                next_word = word[:i] + c + word[i+1:]\n                \n                if next_word not in visited:\n                    visited.add(next_word)\n                    queue.append((next_word, level + 1))\n    \n    return s2 in visited\n\ndef main():\n    print(are_k_similarity(\"abc\", \"abac\", 2)) \n    print(are_k_similarity(\"abx\", \"abyc\", 3))  \n    print(are_k_similarity(\"parker\", \"parree\", 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "855": "```\nimport heapq\n\nclass ExamRoom:\n    def __init__(self, n):\n        self.n = n\n        self.students = []\n\n    def seat(self):\n        if not self.students:\n            self.students.append(0)\n            return [0]\n        max_distance = 0\n        start = 0\n        for i in range(len(self.students) - 1):\n            distance = (self.students[i + 1] - self.students[i]) // 2\n            if distance > max_distance:\n                max_distance = distance\n                start = self.students[i]\n        end = self.students[-1] + (max_distance if max_distance else 0)\n        heapq.heappop(self.students)\n        heapq.heappush(self.students, end)\n        return [start, end]\n\n    def erase(self, p):\n        if p[0] == self.students[0]:\n            self.students.pop(0)\n        elif len(self.students) > 1 and p[1] == self.students[-1]:\n            self.students.pop()\n        else:\n            start, end = p\n            while self.students and (self.students[0] < start or self.students[0] > end):\n                heapq.heappop(self.students)\n            if not self.students:\n                return\n\n    def main():\n        exam_room = ExamRoom(4)\n        print(exam_room.seat())  # [0,3]\n        print(exam_room.seat())  # [1,3]\n        print(exam_room.erase([5]))",
  "856": "```\ndef scoreOfParentheses(s):\n    score = 0\n    cur_score = 0\n    nesting_level = 0\n    for i in range(len(s)):\n        if s[i] == '(':\n            nesting_level += 1\n        elif s[i] == ')':\n            nesting_level -= 1\n            if nesting_level == 0:\n                score += 2 * cur_score\n                cur_score = 0\n        else:\n            if nesting_level > 0:\n                cur_score += 1\n    return score\n\ndef main():\n    print(scoreOfParentheses(\"no\")) # Test case 1: Expected output - 0\n    print(scoreOfParentheses(\"(a+b)+((c+d)*)((e+f)+g)\") ) # Test case 2: Expected output - 11\n    print(scoreOfParentheses(\"(3+9)*\") ) # Test case 3: Expected output - 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "858": "```\ndef mirrorReflection(p, q):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    left = right = top = bottom = -1\n    if p < q:\n        p, q = q, p\n\n    g = gcd(q, p)\n    left = p // g\n    right = q // g\n    if p % g != 0:\n        top = 1\n    elif q % g != 0:\n        bottom = 1\n\n    return left, right, bottom\n\n\ndef main():\n    print(mirrorReflection(2, 1))\n    print(mirrorReflection(3, 8))\n    print(mirrorReflection(9, 5))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "857": "```\ndef mincostToHireWorkers(workerInfo, k):\n    info = [(w, i) for w, i in workerInfo]\n    info.sort(key=lambda x: (x[0], -x[1]))\n    heap = []\n    res, totalWork = float('inf'), 0\n    for w, i in info:\n        while len(heap) > k or heap[0][0] < w:\n            totalWork -= heap[0][1]\n            heapq.heappop(heap)\n        if len(heap) == k:\n            res = min(res, totalWork + w * k)\n        heapq.heappush(heap, (w, i))\n    return res\n\ndef main():\n    workerInfo1 = [[3, 20], [4, 5], [2, 1], [3, 12]]\n    print(mincostToHireWorkers(workerInfo1, 3)) # Output: 43\n    workerInfo2 = [[0, 11], [2, 16], [10, 8], [7, 15], [14, 5]]\n    print(mincostToHireWorkers(workerInfo2, 2)) # Output: 39\n    workerInfo3 = [[1, 4], [2, 6], [3, 10], [4, 20], [1, 9]]\n    print(mincostToHireWorkers(workerInfo3, 3)) # Output: 36\n\nif __name__ == \"__main__\":\n    main()\n```",
  "859": "```\ndef hasBuddy(nums):\n    num_to_index = {num: i for i, num in enumerate(nums)}\n    result = []\n    \n    for i, num1 in enumerate(nums):\n        diff = abs(num1 - 123)\n        if (num1 + diff) % 123 != nums[i]:\n            return False\n    return True\n\ndef main():\n    print(hasBuddy([10,11,12,13,14])) # Expected: True\n    print(hasBuddy([5,6]) ) # Expected: False\n    print(hasBuddy([1,2,3,4])) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "860": "```\ndef lemonadeChange(bills):\n    five_coins = 0\n    ten_coins = 0\n    for bill in bills:\n        if bill == 5:\n            five_coins += 1\n        elif bill == 10:\n            if five_coins > 0:\n                five_coins -= 1\n                ten_coins += 1\n            else:\n                return False\n        else:\n            if ten_coins > 0 and five_coins > 0:\n                ten_coins -= 1\n                five_coins -= 1\n            elif five_coins >= 3:\n                five_coins -= 3\n            else:\n                return False\n    return True\n\ndef main():\n    print(lemonadeChange([5,5,5,10,5,5]) == True)\n    print(lemonadeChange([10,10]) == False)\n    print(lemonadeChange([5]) == True)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "861": "```\ndef matrixScore(grid):\n    m, n = len(grid), len(grid[0])\n    res = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0:\n                res[i][j] = 1\n            else:\n                res[i][j] = 0\n\n    return res\n\ndef main():\n    test_case1 = [[0,0,1],[1,1,1],[1,0,1]]\n    print(\"Test Case 1:\")\n    print(matrixScore(test_case1))\n    \n    test_case2 = [[0,0,1,1],[1,0,1,0],[1,1,1,1],[1,0,0,0]]\n    print(\"\\nTest Case 2:\")\n    print(matrixScore(test_case2))\n\n    test_case3 = [[0,1,1,1],[1,1,1,1],[1,1,0,1]]\n    print(\"\\nTest Case 3:\")\n    print(matrixScore(test_case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "862": "```\ndef sumSlidingWindow(arr, k):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    \n    res = float('inf')\n    left = 0\n    for right in range(n):\n        while prefix_sum[right + 1] - prefix_sum[left] >= k:\n            res = min(res, right - left + 1)\n            left += 1\n    \n    return res if res != float('inf') else 0\n\ndef main():\n    print(sumSlidingWindow([1, 11, 100, 1, 1, 1, 100, 1, 1, 1], 100)) # expected output: 5\n    print(sumSlidingWindow([1], 1)) # expected output: 1\n    print(sumSlidingWindow([1, 2], 3)) # expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "863": "```\nclass Solution:\n    def distanceK(self, root, target, K):\n        self.parent = {root: None}\n        self.buildParent(root)\n        \n        result = []\n        def dfs(node):\n            if node is not None:\n                if abs(target.val - node.val) <= K:\n                    result.append(node.val)\n                for neighbor in [node.left, node.right]:\n                    if neighbor is not None and (neighbor.val == target.val or self.parent.get(neighbor)):\n                        self.buildParent(neighbor)\n                        dfs(neighbor)\n        self.buildParent(root)\n        dfs(target)\n        return result\n\ndef main():\n    solution = Solution()\n    \n    # Test Case 1\n    root = TreeNode(3)\n    a = TreeNode(5)\n    b = TreeNode(1)\n    c = TreeNode(4)\n    d = TreeNode(0)\n    e = TreeNode(2)\n    f = TreeNode(0)\n    g = TreeNode(-1)\n    h = TreeNode(0)\n    i = TreeNode(7)\n    j = TreeNode(4)\n    k = TreeNode(5)\n    l = TreeNode(-1)\n    root.left = a\n    root.right = b\n    a.left = c\n    a.right = d\n    b.left = e\n    b.right = f\n    d.left = g\n    d.right = h\n    f.left = i\n    f.right = j\n    print(solution.distanceK(root, d, 2))\n    \n    # Test Case 2\n    root = TreeNode(1)\n    a = TreeNode(4)\n    b = TreeNode(5)\n    c = TreeNode(6)\n    root.left = a\n    a.left = b\n    b.right = c\n    print(solution.distanceK(root, b, 3))\n    \n    # Test Case 3\n    root = TreeNode(2)\n    a = TreeNode(1)\n    b = TreeNode(3)\n    root.right = a\n    a.right = b\n    print(solution.distanceK(root, b, 2))\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == '__main__':\n    main()\n```",
  "864": "```\ndef shortestToAllKey(grid):\n    m, n = len(grid), len(grid[0])\n    res = [[float('inf')] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'key':\n                q = [(i, j)]\n                while q:\n                    x, y = q.pop(0)\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < m and 0 <= ny < n and res[nx][ny] > abs(dx) + abs(dy):\n                            res[nx][ny] = abs(dx) + abs(dy)\n                            q.append((nx, ny))\n    return res\n\ndef main():\n    print(shortestToAllKey([\"key\",\"key\",\"j1\"]))\n    print(shortestToAllKey([[\"0\", \"0\", \"1\", \".\"], [\"0\", \"1\", \".\", \".\"], [\".\", \".\", \".\", \"key\"]]))\n    print(shortestToAllKey([]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "865": "```\nclass Solution:\n    def subtreeWithAllDeepest(self, root):\n        # your implementation here\n        pass\n\n\ndef main():\n    solution = Solution()\n\n    # Test case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(5)\n    root1.right = TreeNode(1)\n    root1.left.left = TreeNode(6)\n    root1.left.right = TreeNode(2)\n    root1.right.left = TreeNode(0)\n    root1.right.right = TreeNode(-4)\n\n    print(solution.subtreeWithAllDeepest(root1))\n\n    # Test case 2\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n    root2.left.left = TreeNode(4)\n\n    print(solution.subtreeWithAllDeepest(root2))\n\n    # Test case 3\n    root3 = TreeNode(0)\n\n    print(solution.subtreeWithAllDeepest(root3))\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "866": "```\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_palindrome():\n    low = 1\n    high = 1000000\n    palindrome = None\n    \n    while low <= high:\n        mid = (low + high) // 2\n        num_str = str(mid)\n        \n        if num_str == num_str[::-1]:\n            if is_prime(mid):\n                return mid\n        \n        if len(num_str) % 2 == 0:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return palindrome\n\ndef main():\n    print(\"Test Case 1: \", prime_palindrome())\n    print(\"Test Case 2: \", prime_palindrome())\n    print(\"Test Case 3: \", prime_palindrome())\n\nif __name__ == \"__main__\":\n    main()\n```",
  "868": "```\ndef binaryGap(N):\n    bin_N = bin(N)[2:]\n    max_gap = 0\n    last_one = -1\n    for i, bit in enumerate(bin_N):\n        if bit == '1':\n            max_gap = max(max_gap, i - last_one)\n            last_one = i\n    return max_gap\n\ndef main():\n    test_cases = [9, 528, 1041]\n    for N in test_cases:\n        print(f\"Binary gap of {N} is: {binaryGap(N)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "867": "```\ndef transpose(matrix):\n    return list(map(list, zip(*matrix)))\n\ndef main():\n    print(\"Test Case 1:\")\n    matrix = [[1, 2, 3], [4, 5, 6]]\n    expected = [[1, 4], [2, 5], [3, 6]]\n    result = transpose(matrix)\n    for i in range(len(result)):\n        print(f\"{result[i]}\")\n    print(\"\\nTest Case 2:\")\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8]]\n    expected = [[1, 5], [2, 6], [3, 7], [4, 8]]\n    result = transpose(matrix)\n    for i in range(len(result)):\n        print(f\"{result[i]}\")\n    print(\"\\nTest Case 3:\")\n    matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]\n    expected = [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]\n    result = transpose(matrix)\n    for i in range(len(result)):\n        print(f\"{result[i]}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "869": "```\ndef reorderedPowerOf2(n):\n    s = str(n)\n    s.sort()\n    for i in range(1 << (s.index('0') + 1)):\n        x = '0' * (s.index('0'))\n        res = int(x + ''.join(c for c in s if c != '0'))\n        if res == n:\n            return True\n    return False\n\ndef main():\n    print(reorderedPowerOf2(1)) # Should be True\n    print(reorderedPowerOf2(6)) # Should be False\n    print(reorderedPowerOf2(24)) # Should be True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "870": "```\ndef advantageShuffle(cardValues):\n    cardValues.sort()\n    result = []\n    i, j = 0, len(cardValues) - 1\n    while i <= j:\n        if j - i > 1:\n            result.append([cardValues[i], cardValues[j]])\n            i += 1\n            j -= 1\n        elif j == i:\n            result.append([cardValues[i], cardValues[i+1]])\n            break\n        else:\n            result.append([cardValues[j], cardValues[i]])\n            i += 1\n    return result\n\ndef main():\n    print(advantageShuffle([8,9,10,2,3,1]))\n    print(advantageShuffle([1,2,4,3]))\n    print(advantageShuffle([5,4,3,2]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "871": "```\ndef minRefuelStops(target, fuelCapacity):\n    stops = []\n    currentFuel = 0\n    lastStopIndex = -1\n    \n    for i in range(len(fuel)):\n        if currentFuel + fuel[i] < fuel[i]:\n            if not stops or stops[-1][1] <= i:\n                return -1\n            currentFuel -= stops.pop(-1)[0]\n        else:\n            currentFuel += fuel[i]\n        \n        lastStopIndex = i\n        \n        if currentFuel >= target:\n            break\n        \n    return len(stops)\n\n\ndef main():\n    print(minRefuelStops(100, [10,20,30,40,50]))  # Expected: 2\n    print(minRefuelStops(1, [1,3,5]))  # Expected: -1\n    print(minRefuelStops(1000, [375, 512, 125, 149])  # Expected: 4\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "872": "```\ndef isLeafSimilar(root1, root2):\n    if not root1 and not root2:\n        return True\n    if (root1 and not root2) or (not root1 and root2):\n        return False\n    if root1.val != root2.val:\n        return False\n    return isLeafSimilar(root1.left, root2.right) or isLeafSimilar(root1.right, root2.left)\n\ndef main():\n    # Test case 1\n    node4 = TreeNode(3)\n    node5 = TreeNode(4)\n    node6 = TreeNode(5)\n    node7 = TreeNode(3)\n    node8 = TreeNode(4)\n    node9 = TreeNode(5)\n    node10 = TreeNode(2)\n    node11 = TreeNode(6)\n    root1 = TreeNode(1, node4, node5)\n    root1.left.left = node7\n    root1.left.right = node8\n    root1.right = node9\n    root1.right.right = node11\n    root2 = TreeNode(1, node10, node6)\n    root2.left = node7\n    root2.right = node9\n    print(isLeafSimilar(root1, root2))  # Expected: True\n\n    # Test case 2\n    node12 = TreeNode(3)\n    node13 = TreeNode(4)\n    node14 = TreeNode(5)\n    node15 = TreeNode(3)\n    node16 = TreeNode(4)\n    node17 = TreeNode(6)\n    root1 = TreeNode(1, node12, node13)\n    root1.left.left = node15\n    root1.left.right = node16\n    root1.right = node14\n    root1.right.right = node17\n    root2 = TreeNode(1, node10, node14)\n    root2.left = node12\n    root2.right = node17\n    print(isLeafSimilar(root1, root2))  # Expected: False\n\n    # Test case 3\n    root1 = TreeNode(1, None, None)\n    root2 = TreeNode(1, None, None)\n    print(isLeafSimilar(root1, root2))  # Expected: True\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "873": "```\ndef lenLongestFibSubseq(A):\n    n = len(A)\n    index_dict = {x: i for i, x in enumerate(A)}\n    max_length = 0\n    for i in range(n):\n        for j in range(i):\n            a, b = A[j], A[i]\n            length = 2\n            while (b - a) in index_dict and index_dict[b - a] < j:\n                a, b = b - a, A[index_dict[b - a]]\n                length += 1\n            max_length = max(max_length, length)\n    return max_length if max_length > 2 else 0\n\ndef main():\n    test_cases = [\n        ([1, 2, 3, 4, 5, 6, 7, 8], 9),\n        ([1, 3, 7, 11, 20}, 6),  # note this is not a valid input\n        ([1, 2, 3, 13, 21, 34, 55, 89], 7)\n    ]\n\n    for test_case in test_cases:\n        result = lenLongestFibSubseq(test_case[0])\n        if result == test_case[1]:\n            print(\"Pass\")\n        else:\n            print(f\"Fail. Expected {test_case[1]}, but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "875": "```\ndef minEatingTime(piles, h):\n    piles.sort()\n    l, r = 1, piles[-1]\n    \n    while l < r:\n        mid = (l + r) // 2\n        if sum((p-1)//mid for p in piles) <= h:\n            r = mid\n        else:\n            l = mid + 1\n            \n    return l\n\n\ndef main():\n    test_cases = [\n        ([2, 0, 3, 0], 5),\n        ([4, 2, 7, 0], 20),\n        ([5, 6, 7, 8], 9)\n    ]\n\n    for piles, h in test_cases:\n        print(f\"Piles: {piles}, Hours: {h}, MinEatingTime: {minEatingTime(piles, h)}\")\n        print()\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "874": "```\ndef maxSafety(inputMatrix):\n    if not inputMatrix:\n        return 0\n    m, n = len(inputMatrix), len(inputMatrix[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    dp = [[0] * n for _ in range(m)]\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n:\n            return 0\n        if dp[i][j]:\n            return dp[i][j]\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if (0 <= ni < m) and (0 <= nj < n) and inputMatrix[ni][nj] == 1:\n                dp[i][j] = min(dp[i][j], dfs(ni, nj) + 1)\n        return dp[i][j]\n\n    max_safety = 0\n    for i in range(m):\n        for j in range(n):\n            if inputMatrix[i][j] == 1:\n                safety = dfs(i, j)\n                max_safety = max(max_safety, safety)\n\n    return max_safety\n\ndef main():\n    print(\"Test Case 1:\")\n    print(maxSafety([[0,0,0],[0,1,0],[0,1,0]])) # Should be 2\n    print(\"\\n\")\n\n    print(\"Test Case 2:\")\n    print(maxSafety([[0,0,0],[0,1,0],[0,1,1]])) # Should be 3\n    print(\"\\n\")\n\n    print(\"Test Case 3:\")\n    print(maxSafety([[0,0,0,0],[0,1,0,0],[0,1,1,0]])) # Should be 4\n    print(\"\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "876": "```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef middleNode(head):\n    slow = head\n    fast = head\n    while fast is not None and fast.next is not None:\n        slow = slow.next\n        fast = fast.next.next\n    return slow\n\ndef main():\n    # Test case 1\n    node1 = ListNode(1)\n    node2 = ListNode(2)\n    node3 = ListNode(3)\n    node4 = ListNode(4)\n    node5 = ListNode(5)\n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    print(middleNode(node1).val)  # Output: 3\n\n    # Test case 2\n    node6 = ListNode(1)\n    node7 = ListNode(2)\n    node8 = ListNode(3)\n    node6.next = node7\n    node7.next = node8\n    print(middleNode(node6).val)  # Output: 2\n\n    # Test case 3\n    node9 = ListNode(1)\n    print(middleNode(node9).val)  # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "877": "```\ndef stoneGame(piles):\n    dp = [[0] * (len(piles) + 1) for _ in range(len(piles) + 1)]\n    total_sum = sum(piles)\n    piles.insert(0, 0)\n\n    for i in range(len(piles)):\n        for j in range(i, -1, -1):\n            dp[i][j] = (piles[i] + piles[j]) % 2 != 0\n            if j > 0:\n                dp[i][j] += dp[i-1][j-1]\n    return total_sum % 2 == 1\n\ndef main():\n    print(stoneGame([5,3])) # False\n    print(stoneGame([6,4,8])) # True\n    print(stoneGame([9,8])) # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "878": "```\ndef nthMagicalNumber(N, P):\n    lo = 1\n    hi = N * P\n    while True:\n        mid = (lo + hi) // 2\n        if ((mid // P) % M == 0) or ((mid // Q) % M == 0):\n            hi = mid\n        else:\n            lo = mid + 1\n        if lo == hi:\n            return lo\n\ndef main():\n    N = 3\n    P = 5\n    Q = 10\n    print(nthMagicalNumber(N, P))\n\n    N = 4\n    P = 2\n    Q = 7\n    print(nthMagicalNumber(N, P))\n\n    N = 25\n    P = 15\n    Q = 20\n    print(nthMagicalNumber(N, P))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "879": "```\ndef profitableSchemes(G, S, group):\n    dp = [[0] * (S + 1) for _ in range(G + 1)]\n    \n    for i in range(1, G + 1):\n        for j in range(S + 1):\n            if j < i:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(dp[max(0, i - 1)][j], group[i - 1] + (dp[i - 1][j - i]))\n    \n    return sum([1 for j in range(S + 1) if dp[G][j] >= S])\n\ndef main():\n    G1 = 50\n    S1 = 5\n    group1 = [2, 7, 4]\n    print(\"Test case 1: \", profitableSchemes(G1, S1, group1))\n    \n    G2 = 10\n    S2 = 2\n    group2 = [2, 3]\n    print(\"Test case 2: \", profitableSchemes(G2, S2, group2))\n\n    G3 = 100\n    S3 = 5\n    group3 = [1, 4, 10, 20, 5, 1, 5, 15, 10]\n    print(\"Test case 3: \", profitableSchemes(G3, S3, group3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "880": "```\ndef decodeAtIndex(N, S):\n    N -= sum(1 for c in S if c == '#')\n    stack = [(N, i) for i in range(len(S))]\n    result = ''\n    while stack:\n        n, i = stack.pop()\n        if S[i] != '#':\n            if S[i].isdigit():\n                stack.append((n // int(S[i]), i + 1))\n            else:\n                result += S[i]\n        else:\n            n //= int(S[:i])\n    return result\n\ndef main():\n    print(decodeAtIndex(8, \"130a2\")) # expected output: \"hello\"\n    print(decodeAtIndex(3, \"#31get\") # expected output: \"leet\"\n    print(decodeAtIndex(4, \"a1b2c3d4e5#f6g7h8i9j10#k1l2#m3n4o5p6q7r8s9t10\")) # expected output: \"the\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "881": "```\ndef numRescueBoats(people, limit):\n    people.sort()\n    left = 0\n    right = len(people) - 1\n    ans = 0\n    \n    while left <= right:\n        if people[left] + people[right] <= limit:\n            left += 1\n        right -= 1\n        ans += 1\n\ndef main():\n    print(numRescueBoats([1,2], 3))  # Expected output: 1\n    print(numRescueBoats([1,2,3,4], 5))  # Expected output: 4\n    print(numRescueBoats([3,2,2,1], 1))  # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "882": "```\nimport heapq\n\ndef reachableNodes(edges, swSwaps):\n    n = len(swSwaps)\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        u, v, w = edge[0], edge[1], edge[2]\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    heap = []\n    heapq.heappush(heap, (0, 0))  # (weight, node)\n    parent = [-1] * n\n    rank = [0] * n\n\n    while heap:\n        weight, node = heapq.heappop(heap)\n        for neighbor, edgeWeight in graph[node]:\n            if parent[neighbor] == -1 and edgeWeight >= weight:\n                parent[neighbor] = node\n                rank[neighbor] = rank[node] + 1\n                heapq.heappush(heap, (edgeWeight, neighbor))\n\n    return sum(1 << (rank[i] - 1) for i in range(n) if rank[i] > 0)\n\ndef main():\n    test_cases = [\n        ({}, [0]), \n        ([[(0,1,2), (1,2,3)]], [1]), \n        ([[(0,1,4), (1,3,5), (3,2,6)]], [2])\n    ]\n\n    for edges, swSwaps in test_cases:\n        print(f\"Edges: {edges}, SwSwaps: {swSwaps} => Reachable nodes: {reachableNodes(edges, swSwaps)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "883": "```\ndef projectedArea(grid):\n    n = len(grid)\n    area = 0\n    \n    for i in range(n):\n        row_area = sum(grid[i].count(1) * (i+1))\n        col_area = sum(min(j+1 for j, val in enumerate(grid[j]) if val) for j in range(n)) \n        box_area = sum(min(i+1 for i, val in enumerate(grid[i])) * min(j+1 for j, val in enumerate(grid[j])) if val else 0 for i in range(n) for j in range(n))\n        \n        area += row_area + col_area + box_area\n    \n    return area\n\n\ndef main():\n    test_cases = [\n        {\n            \"grid\": [[2, 0], [2, 1]],\n            \"expected\": 8\n        },\n        {\n            \"grid\": [[1,0],[0,1],[1,1]], \n            \"expected\": 6\n        },\n        {\n            \"grid\": [[3,4,5],[3,4,4],[4,4,4]], \n            \"expected\": 44\n        }\n    ]\n    \n    for test_case in test_cases:\n        result = projectedArea(test_case[\"grid\"])\n        if result == test_case[\"expected\"]:\n            print(\"Test case passed.\")\n        else:\n            print(f\"Test case failed. Expected {test_case['expected']}, got {result}.\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "884": "```\ndef uncommon_from_sentences(s1, s2):\n    words = set()\n    for sentence in [s1, s2]:\n        for word in sentence.split():\n            if word not in words:\n                words.add(word)\n    result = []\n    for word in list(words):\n        count = 0\n        for sentence in [s1, s2]:\n            count += sentence.count(word)\n        if count == 1:\n            result.append(word)\n    return result\n\ndef main():\n    print(uncommon_from_sentences(\"this apple is good\", \"is dog or cat apple\")) # Output: [\"or\", \"good\", \"cat\"]\n    print(uncommon_from_sentences(\"\", \"yo\")) # Output: [\"yo\"]\n    print(uncommon_from_sentences(\"a\", \"\")) # Output: [\"a\"]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "885": "```\ndef spiralMatrixIII(n, r):\n    top = 0\n    bottom = n - 1\n    left = 0\n    right = n - 1\n    \n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    visited = [[False for _ in range(n)] for _ in range(n)]\n    result = []\n    \n    while top <= bottom and left <= right:\n        for i in range(left, right + 1):\n            if not visited[top][i]:\n                result.append((top, i))\n                visited[top][i] = True\n        top += 1\n        \n        for i in range(top, bottom + 1):\n            if not visited[i][right]:\n                result.append((i, right))\n                visited[i][right] = True\n        right -= 1\n        \n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                if not visited[bottom][i]:\n                    result.append((bottom, i))\n                    visited[bottom][i] = True\n            bottom -= 1\n        \n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                if not visited[i][left]:\n                    result.append((i, left))\n                    visited[i][left] = True\n            left += 1\n    \n    return result\n\ndef main():\n    print(spiralMatrixIII(5, 13)) # test case 1\n    print(spiralMatrixIII(1, 3)) # test case 2\n    print(spiralMatrixIII(10, 1000)) # test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "886": "```\ndef isBipartite(graph):\n    color = {}\n    for node in graph:\n        if node not in color:\n            stack = [node]\n            color[node] = True\n            while stack:\n                current_node = stack.pop()\n                for neighbor in graph[current_node]:\n                    if neighbor not in color:\n                        color[neighbor] = not color[current_node]\n                        stack.append(neighbor)\n                    elif color[neighbor] == color[current_node]:\n                        return False\n    return True\n\n\ndef main():\n    test_cases = [\n        ([1, 2, 3], True),\n        ([1, 2, 3, 4], False),\n        (\n            [1, 2, 3, 4, 5],\n            isBipartite({\n                1: [2, 3],\n                2: [1, 4, 5],\n                3: [1, 4, 5],\n                4: [2, 3, 5],\n                5: [2, 3, 4]\n            })\n        )\n    ]\n\n    for test_case in test_cases:\n        graph = {i + 1: neighbors for i, neighbors in enumerate(test_case[0])}\n        print(f\"Is bipartite for {test_case}: {isBipartite(graph)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "887": "```\nclass Solution:\n    def superEggDrop(self, K: int, N: int) -> int:\n        dp = [[0] * (N + 1) for _ in range(K + 1)]\n        \n        for i in range(1, K + 1):\n            for j in range(1, N + 1):\n                if i == 1:\n                    dp[i][j] = j\n                elif j == 1:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = float('inf')\n                    for x in range(1, j + 1):\n                        dp[i][j] = min(dp[i][j], 1 + max(x - 1, j - x))\n        \n        return dp[K][N]\n\ndef main():\n    print(Solution().superEggDrop(1, 2)) # Test case 1\n    print(Solution().superEggDrop(3, 4)) # Test case 2\n    print(Solution().superEggDrop(5, 6)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "888": "```\ndef fairCandySwap(candies):\n    total = sum(candies)\n    for i in range(len(candies) - 1):\n        for j in range(i + 1, len(candies)):\n            if (total - candies[i] - candies[j]) % 2 == 0:\n                return [i+1, j+1]\n\ndef main():\n    print(fairCandySwap([2,1,5,3])) # Expected output: [1, 2]\n    print(fairCandySwap([1,2,4,7,10]) # Expected output: [0, 3]\n    print(fairCandySwap([4,2,8,6,0,2,4,8])) # Expected output: [1, 5]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "889": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef constructFromPrePost(pre, post):\n    if not pre:\n        return None\n    \n    root = TreeNode(pre[0])\n    idx = post.index(root.val)\n    \n    root.left = constructFromPrePost(pre[1:idx+1], post[:idx])\n    root.right = constructFromPrePost(pre[idx+1:], post[idx:-1])\n    \n    return root\n\ndef printTree(node):\n    if node:\n        print(node.val, end=' ')\n        printTree(node.left)\n        printTree(node.right)\n\ndef main():\n    # Test case 1\n    pre1 = [1,2,4,5,3]\n    post1 = [3,5,4,2,1]\n    root1 = constructFromPrePost(pre1, post1)\n    print(\"Test Case 1:\")\n    printTree(root1)\n    print()\n\n    # Test case 2\n    pre2 = [1,2,3,5,6]\n    post2 = [6,5,3,2,1]\n    root2 = constructFromPrePost(pre2, post2)\n    print(\"Test Case 2:\")\n    printTree(root2)\n    print()\n\n    # Test case 3\n    pre3 = [1,2,3]\n    post3 = [3,2,1]\n    root3 = constructFromPrePost(pre3, post3)\n    print(\"Test Case 3:\")\n    printTree(root3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "890": "```\ndef findAndReplacePattern(words, pattern):\n    ans = []\n    for word in words:\n        if len(word) != len(pattern):\n            continue\n        ok = True\n        d1 = {}\n        d2 = {}\n        for i in range(len(word)):\n            if pattern[i] not in d1 or word[i] not in d2:\n                d1[pattern[i]] = word[i]\n                d2[word[i]] = pattern[i]\n            elif d1[pattern[i]] != word[i] or d2[word[i]] != pattern[i]:\n                ok = False\n                break\n        if ok: ans.append(word)\n    return ans\n\ndef main():\n    print(findAndReplacePattern([\"abc\", \"ade\", \"aze\"], \"a*d*e\")) \n    print(findAndReplacePattern([\"boot\",\"cold\",\"hunt\",\"lake\",\"most\"], \"e*ctf*o\")) \n    print(findAndReplacePattern([\"leet\", \"code\"], \"et*a*l*t#s\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "891": "```\ndef sumOfSubsequenceWidths(arr):\n    arr.sort()\n    return sum(arr[i] - arr[i-1] for i in range(1, len(arr)))\n\ndef main():\n    print(sumOfSubsequenceWidths([2, 3, 5])) # Expected output: 9\n    print(sumOfSubsequenceWidths([1, 4, 8, 11])) # Expected output: 12\n    print(sumOfSubsequenceWidths([2, 2, 2, 3, 3])) # Expected output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "892": "```\ndef surfaceArea(grid):\n    n = len(grid)\n    res = 0\n    for i in range(n):\n        for j in range(n):\n            val = grid[i][j]\n            res += (4 + 2 * max(0, grid[i][j-1] if j > 0 else 0) + 2 * max(0, grid[i-1][j] if i > 0 else 0)) * val\n    return res\n\ndef main():\n    test_cases = [\n        # Test case 1:\n        [[1,2], [3,4]],\n        \n        # Test case 2:\n        [[1,1,1], [1,1,1]],\n        \n        # Test case 3:\n        [[2,3,4],[3,5,5],[5,8,5]]\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Test Case: {test_case}\")\n        print(f\"Result: {surfaceArea(test_case)}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "893": "```\ndef numSpecialEquivGroups(words):\n    equiv_groups = set()\n    for word in words:\n        first_half = \"\".join(sorted(word[0:len(word)//2]))\n        second_half = \"\".join(sorted(word[len(word)//2:]))\n        equiv_group_key = f\"{first_half}{second_half}\"\n        equiv_groups.add(equiv_group_key)\n    return len(equiv_groups)\n\ndef main():\n    print(numSpecialEquivGroups([\"abc\",\"cba\",\"abcd\",\"cdab\"])) # Expected output: 1\n    print(numSpecialEquivGroups([\"a\"]) * 10) # Expected output: 1\n    print(numSpecialEquivGroups([\"a\",\"b\"]) * 5) # Expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "894": "```\ndef allPossibleFullBinaryTrees(n):\n    if n == 0:\n        return [\"\"]\n\n    res = []\n    for i in range(1 << n):\n        left_tree = \"\" if (i & (1 << (n - 1))) == 0 else \"1\" + allPossibleFullBinaryTrees(n - 1)[0]\n        right_tree = \"\" if i == 0 or ((i >> (n - 1)) & 1) == 0 else \"0\" + allPossibleFullBinaryTrees(n - 1)[0]\n        res.append(left_tree + right_tree)\n\n    return res\n\ndef main():\n    print(allPossibleFullBinaryTrees(3))\n    print(allPossibleFullBinaryTrees(2))\n    print(allPossibleFullBinaryTrees(1))\n\nif __name__ == \"__main__\":\n    main()\n```\n\nTest cases:\n1. n = 3\nOutput: [\"011\", \"0101\", \"00111\", \"1001\", \"10101\", \"10000\", \"1100\", \"11110\", \"11000\"]\n\n2. n = 2\nOutput: [\"01\", \"001\", \"0001\"]\n\n3. n = 1\nOutput: [\"\"]",
  "895": "```\ndef maxSlidingWindow(nums):\n    from collections import deque\n\n    if not nums:\n        return []\n\n    stack = deque()\n    result = []\n    for i, num in enumerate(nums):\n        while stack and stack[0] <= i - len(nums):\n            stack.pop()\n        while stack and stack[-1] <= num:\n            stack.pop()\n        stack.append(i)\n        \n        if stack[0] == 0:\n            result.append(num)\n        else:\n            result.append(nums[stack[0]])\n\n    return result\n\ndef main():\n    test_cases = [\n        ([1,3,-1,-3,5,3,6,7], [5,5,5,5,4]),\n        ([-9,2,-5,2,0,3,1,-7,1,3,2], [7,7,6,6,5]),\n        ([1,-1], [1])\n    ]\n\n    for test_case in test_cases:\n        nums, expected = test_case\n        result = maxSlidingWindow(nums)\n        if result == expected:\n            print(f\"Test case passed: {nums} -> {result}\")\n        else:\n            print(f\"Test case failed: {nums} -> {expected} != {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "896": "```\ndef isMonotonic(arr):\n    is_increasing = is_decreasing = False\n\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            is_increasing = True\n        elif arr[i] < arr[i-1]:\n            is_decreasing = True\n\n    return is_increasing and not is_decreasing or not is_increasing and is_decreasing\n\n\ndef main():\n    print(isMonotonic([0, 1, 0])) # Test case 1: Increasing then decreasing\n    print(isMonotonic([0, 3, 2, 5, 4])) # Test case 2: Decreasing then increasing\n    print(isMonotonic([1, 1, 1])) # Test case 3: Constant\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "897": "```\nclass Solution:\n    def increasingOrderSearchTree(self, root):\n        pseudoHead = TreeNode(0)\n        curr = pseudoHead\n        self.inorder(root, curr)\n\n        return pseudoHead.right\n\n    def inorder(self, node, curr):\n        if node:\n            self.inorder(node.left, curr)\n            curr.right = TreeNode(node.val)\n            curr = curr.right\n            self.inorder(node.right, curr)\n\n    def main():\n        sol = Solution()\n        \n        root1 = TreeNode(5)\n        root1.left = TreeNode(3)\n        root1.right = TreeNode(6)\n        root1.left.left = TreeNode(2)\n        root1.left.right = TreeNode(4)\n        root1.right.left = TreeNode(5)\n        root1.right.right = TreeNode(7)\n\n        print(sol.increasingOrderSearchTree(root1))\n\n        root2 = TreeNode(3)\n        root2.right = TreeNode(20)\n        root2.right.left = TreeNode(15)\n        root2.right.right = TreeNode(25)\n\n        print(sol.increasingOrderSearchTree(root2))\n\n        root3 = TreeNode(5)\n        root3.left = TreeNode(3)\n        root3.right = TreeNode(6)\n        root3.left.left = TreeNode(0)\n        root3.left.right = TreeNode(4)\n        root3.right.left = TreeNode(5)\n        root3.right.right = TreeNode(7)\n\n        print(sol.increasingOrderSearchTree(root3))\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "898": "```\ndef subarrayOrs(nums):\n    n = len(nums)\n    ors = [0] * (n + 1)\n    for i in range(n):\n        for j in range(i, n):\n            ors[j + 1] |= nums[i] | nums[i + 1:j + 1]\n    return ors\n\ndef main():\n    test_cases = [\n        ([0], [0]),\n        ([2,1,3], [0, 2, 7]),\n        ([5,2,8,9], [14, 11])\n    ]\n    \n    for i, (nums, expected) in enumerate(test_cases):\n        result = subarrayOrs(nums)\n        print(f\"Test Case {i}:\")\n        print(f\"Expected: {expected}\")\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "899": "```\ndef orderlyQueue(target: str, words: List[str]) -> int:\n    ...\n\nif __name__ == \"__main__\":\n    target = \"leetcode\"\n    words1 = [\"practice\", \"practice\", \"practicE\", \"practical\"]\n    print(orderlyQueue(target, words1))\n\n    target = \"apple\"\n    words2 = [\"eat\", \"bat\", \"cat\"]\n    print(orderlyQueue(target, words2))\n\n    target = \"kth\"\n    words3 = [\"hth\", \"kht\", \"hhw\"]\n    print(orderlyQueue(target, words3))\n```",
  "900": "```\nclass RLEIterator:\n    def __init__(self, encoding):\n        self.encoding = encoding\n        self.index = 0\n\n    def next(self):\n        while self.index < len(self.encoding):\n            count = int(self.encoding[self.index])\n            self.index += 1\n            if self.index < len(self.encoding) and self.encoding[self.index] == 'k':\n                break\n            for _ in range(count):\n                yield self.encoding[self.index]\n                self.index += 1\n\ndef main():\n    iterator1 = RLEIterator(\"3[a]2[bc]\")\n    for i in range(7): print(next(iterator1))\n    print()\n    \n    iterator2 = RLEIterator(\"10[abcd]\")\n    for _ in range(15): print(next(iterator2))\n    print()\n    \n    iterator3 = RLEIterator(\"a\")\n    for _ in range(1): print(next(iterator3))\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "901": "```\ndef stockSpan(stockPrices):\n    stack = []\n    result = []\n\n    for i, price in enumerate(stockPrices):\n        while stack and stack[-1][0] <= price:\n            stack.pop()\n        if stack:\n            result.append(i - stack[-1][1])\n        else:\n            result.append(i + 1)\n        stack.append((price, i))\n\n    return result\n\ndef main():\n    test_cases = [\n        [100, 80, 60, 70, 60, 75, 85],\n        [10, 3, 7, 15, 13, 25, 20],\n        [1, 2]\n    ]\n\n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        print(stockSpan(test_case))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "902": "```\ndef atMostNGivenDigitSet(nums):\n    n = int(''.join(map(str, sorted(set(int(d) for d in nums)))))\n    res = []\n    for i in range(1, n+1):\n        s = ''\n        for j in str(i):\n            if int(j) > n % (10**len(str(n))):\n                break\n            s += '0' * (9 - (int(j) % 10))\n        res.append(s)\n    return res\n\ndef main():\n    print(atMostNGivenDigitSet([1,1,1])) # should print [\"0\",\"00\"]\n    print(atMostNGivenDigitSet([0,1,1])) # should print [\"0\",\"00\",\"1\"]\n    print(atMostNGivenDigitSet([2,3,4,5])) # should print [\"0\",\"01\",\"02\",\"03\",\"04\"]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "903": "```\ndef checkPossibility(nums):\n    n = len(nums)\n    for i in range(1, n):\n        if nums[i] < nums[i - 1]:\n            if i == 1 or nums[i - 2] <= nums[i - 1]:\n                nums[i - 1], nums[i] = nums[i], nums[i - 1]\n            else:\n                return False\n    return True\n\n\ndef main():\n    print(checkPossibility([4, 2, 3]))  # Output: True\n    print(checkPossibility([1, 0, 2]))   # Output: False\n    print(checkPossibility([1, 3, 3, 2]))  # Output: False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "904": "```\ndef totalFruit(fruits):\n    if not fruits:\n        return 0\n    \n    max_length = 0\n    current_type = fruits[0]\n    window_start = 0\n    fruit_count = {}\n    \n    for window_end in range(len(fruits)):\n        right_char = fruits[window_end]\n        \n        if right_char == current_type:\n            fruit_count[right_char] = fruit_count.get(right_char, 0) + 1\n        else:\n            while len(fruit_count) > 2:\n                left_char = fruits[window_start]\n                fruit_count[left_char] -= 1\n                if fruit_count[left_char] == 0:\n                    del fruit_count[left_char]\n                window_start += 1\n            \n            current_type = right_char\n            fruit_count[right_char] = fruit_count.get(right_char, 0) + 1\n        \n        max_length = max(max_length, window_end - window_start + 1)\n\n    return max_length\n\n\ndef main():\n    print(totalFruit([\"apple\", \"apple\", \"banana\", \"orange\"]))  # Output: 3\n    print(totalFruit([\"apple\", \"banana\", \"banana\", \"apple\", \"orange\"]))  # Output: 4\n    print(totalFruit([\"banana\", \"banana\", \"banana\", \"banana\", \"apple\"]))  # Output: 5\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "905": "```\ndef sortArrayByParity(nums):\n    even_nums = []\n    odd_nums = []\n\n    for num in nums:\n        if num % 2 == 0:\n            even_nums.append(num)\n        else:\n            odd_nums.append(num)\n\n    return even_nums + odd_nums\n\n\ndef main():\n    print(\"Test Case 1:\")\n    input_array = [3, 1, 2, 4]\n    expected_output = [2, 4, 1, 3]\n    actual_output = sortArrayByParity(input_array)\n    if actual_output == expected_output:\n        print(\"PASS\")\n    else:\n        print(\"FAIL\")\n\n    print(\"\\nTest Case 2:\")\n    input_array = [0]\n    expected_output = [0]\n    actual_output = sortArrayByParity(input_array)\n    if actual_output == expected_output:\n        print(\"PASS\")\n    else:\n        print(\"FAIL\")\n\n    print(\"\\nTest Case 3:\")\n    input_array = [1, 2, 3, 4, 5, 6]\n    expected_output = [2, 4, 6, 1, 3, 5]\n    actual_output = sortArrayByParity(input_array)\n    if actual_output == expected_output:\n        print(\"PASS\")\n    else:\n        print(\"FAIL\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "906": "```\ndef superpalindromes(n):\n    res = []\n    for i in range(1, n+1):\n        is_palindrome = True\n        temp = str(i)\n        for j in range(len(temp)):\n            if temp[j] != temp[-j-1]:\n                is_palindrome = False\n                break\n        if is_palindrome:\n            res.append(int(str(i) + str(i)[::-1]))\n    return res\n\ndef main():\n    print(\"Test case 1:\")\n    print(superpalindromes(100))\n    \n    print(\"\\nTest case 2:\")\n    print(superpalindromes(200))\n\n    print(\"\\nTest case 3:\")\n    print(superpalindromes(500))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "907": "```\ndef minSumOfSubarray(nums):\n    stack = []\n    total_sum = 0\n    for num in nums:\n        while len(stack) > 0 and stack[-1] >= num:\n            top = stack.pop()\n            total_sum += top\n        stack.append(num)\n    while len(stack) > 0:\n        total_sum += stack.pop()\n    return total_sum\n\n\ndef main():\n    print(minSumOfSubarray([3, 1, 2, 4]) == 17)\n    print(minSumOfSubarray([11, 81, 2, 47, 38]) == 49)\n    print(minSumOfSubarray([10]) == 10)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "908": "```\ndef smallestRange(nums):\n    n = len(nums)\n    lo, hi = float('inf'), -float('inf')\n    for x in nums[0]:\n        lo = min(lo, x)\n    for i in range(n):\n        lo = min(lo, nums[i][0])\n        hi = max(hi, nums[i][-1])\n    ans = hi - lo\n    left = 0\n    right = n-1\n    while True:\n        if hi - (nums[left][right] - lo) < ans:\n            ans = hi - (nums[left][right] - lo)\n        for i in range(n):\n            if nums[i].index(nums[left][right]) == i:\n                left = i\n                right = n-1\n                break\n        for i in range(n):\n            if not all(x <= nums[left][right] for x in nums[i]):\n                right = i - 1\n                left = 0\n                break\n\n    return [lo, hi]\n\ndef main():\n    print(smallestRange([[4,2,3],[1,5,9]])) # expected output: [2, 5]\n    print(smallestRange([[1,5,5],[10,11,13]])) # expected output: [6,7]\n    print(smallestRange([[0,9]])) # expected output: [0, 9]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "909": "```\ndef snakes_and_ladders(board):\n    m = len(board)\n    n = len(board[0])\n    \n    visited = [[False for _ in range(n)] for _ in range(m)]\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    queue = [(0, 0)]\n\n    while queue:\n        x, y = queue.pop(0)\n        if visited[x][y]:\n            continue\n        visited[x][y] = True\n        \n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and board[nx][ny] != -1:\n                queue.append((nx, ny))\n        \n    return len(queue)\n\ndef main():\n    print(\"Test Case 1:\")\n    print(snakes_and_ladders([[1,-1],[1,5]])) # Expected: 2\n    print()\n\n    print(\"Test Case 2:\")\n    print(snakes_and_ladders([[1,3,7,9,8,6,5,4,2,1,0]])  # Expected: 5\n    print())\n\n    print(\"Test Case 3:\")\n    print(snakes_and_ladders([[-1,-1,-1,-1],[-1,6,-1,-1],[3,8,-1,4],[10,-1,-1,-1,-1]]))  # Expected: 7\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "910": "```\ndef secondMinimum(n, edges):\n    graph = [[] for _ in range(n+1)]\n    visited = [0] * (n + 1)\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    def dfs(node, parent):\n        if node == -1:\n            return\n        visited[node] = 1\n        for neighbor in graph[node]:\n            if neighbor != parent and not visited[neighbor]:\n                dfs(neighbor, node)\n        return\n\n    dfs(1, -1)\n\n    res = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            if visited[i] and visited[j]:\n                res = min(res, max(i, j) - min(i, j))\n\n    return res\n\n\ndef main():\n    print(secondMinimum(8, [[0, 1], [0, 2], [1, 3], [1, 4], [2, 5], [2, 6]])) # Expected: 2\n    print(secondMinimum(6, [[0, 1], [0, 2], [2, 3], [2, 4], [5, 6]])) # Expected: 1\n    print(secondMinimum(4, [[0, 1], [1, 2], [1, 3]])) # Expected: 2\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "911": "```\ndef getWinner(logs):\n    n = len(logs)\n    winners = {}\n    winner = \"\"\n    max_points = 0\n    for log in logs:\n        p, c = log.split()\n        p = int(p)\n        if c not in winners:\n            winners[c] = p\n        else:\n            winners[c] += p\n        if winners[c] > max_points:\n            max_points = winners[c]\n            winner = c\n    return winner\n\ndef main():\n    print(getWinner([\"Alice0\", \"Bob1\", \"Alice2\", \"Bob3\"]) == \"Bob\")\n    print(getWinner([\"Alice0\", \"Bob1\", \"Alice2\", \"Bob3\", \"Alice4\", \"Bob5\"]) == \"Bob\")\n    print(getWinner([\"Alice0\", \"Bob1\"]) == \"Alice\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "912": "```\ndef sort_array(nums):\n    return sorted(nums)\n\ndef main():\n    print(sort_array([5, 2, 8, 6, 1, 9]))  \n    print(sort_array([0, 0, 0]))  \n    print(sort_array([-10, -20, -30]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "914": "```\ndef hasGroupsSizeX(deck):\n    deck_count = {}\n    for card in deck:\n        if card in deck_count:\n            deck_count[card] += 1\n        else:\n            deck_count[card] = 1\n            \n    x = 1\n    while x * (x - 1) <= max(deck_count.values()):\n        if all(count % x == 0 for count in deck_count.values()):\n            return True\n        x += 1\n        \n    return False\n\n\ndef main():\n    print(hasGroupsSizeX([1, 2, 3, 4, 4]))  # Test case 1: Expected output: False\n    print(hasGroupsSizeX([1, 1, 2, 2, 3, 3]))  # Test case 2: Expected output: True\n    print(hasGroupsSizeX([0, 1, 2, 3, 4, 10]))  # Test case 3: Expected output: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "913": "```\ndef canMouseCatchCat(grid):\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    mousePos = None\n    catPos = None\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'M':\n                mousePos = (i, j)\n            elif grid[i][j] == 'C':\n                catPos = (i, j)\n\n    if mousePos is None or catPos is None:\n        return True\n\n    memo = {}\n\n    def dfs(x, y):\n        pos = str(x) + ',' + str(y)\n        if pos in memo:\n            return memo[pos]\n\n        minDistance = float('inf')\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n:\n                if grid[nx][ny] == 'O':\n                    distance = dfs(nx, ny)\n                    if distance != -1:\n                        minDistance = min(minDistance, distance + 1)\n\n        memo[pos] = minDistance if minDistance != float('inf') else -1\n        return minDistance\n\n    mouseDistance = dfs(mousePos[0], mousePos[1])\n    catDistance = dfs(catPos[0], catPos[1])\n\n    if mouseDistance < catDistance:\n        return True\n\n    return False\n\n\ndef main():\n    grid1 = [['O', 'O', '#'], ['M', '#']]\n    print(canMouseCatchCat(grid1))  # Expected: True\n    grid2 = [['O', 'O', '#'], ['#', '#', 'M']]\n    print(canMouseCatchCat(grid2))  # Expected: False\n    grid3 = [['O', 'O', '#'], ['#', 'M', '#']]\n    print(canMouseCatchCat(grid3))  # Expected: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "915": "```\ndef maxEqualRowsAfterFlips(A):\n    res = []\n    for row in A:\n        ones_count = bin(row ^ (row & -row)).count('1')\n        if ones_count not in [x[0] for x in res]:\n            res.append([ones_count, [list(map(int, bin(x).replace(\"0b\", \"\").zfill(len(str(bin(2**len(str(bin(2**31)))-1)))))) for x in A if bin(x ^ (x & -x)).count('1') == ones_count]])\n    return [x[1] for x in res]\n\ndef main():\n    print(maxEqualRowsAfterFlips([[0,1],[1,1]]))\n    print(maxEqualRowsAfterFlips([[0,1],[1,0]]))\n    print(maxEqualRowsAfterFlips([[0,0,0],[0,0,1],[1,1,1],[1,1,0]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "916": "```\ndef word_subsets(words1, words2):\n    graph = {}\n    for word in words1:\n        for char in set(word):\n            if char not in graph:\n                graph[char] = set()\n            graph[char].add(word)\n    \n    count = 0\n    for word in words2:\n        temp_set = set(word)\n        for char in set(word):\n            if char in graph and graph[char]:\n                temp_set &= (set(graph[char]) & set([word]))\n        if not temp_set:\n            return False\n    return True\n\ndef main():\n    print(word_subsets([\"a\",\"ab\",\"b\"], [\"a\",\"b\"])) # True\n    print(word_subsets([\"w\",\"wo\",\"wor\",\"world\"], [\"w\",\"wo\", \"wor\", \"2world\", \"3world\"])) # True\n    print(word_subsets([\"a\",\"c\",\"e\"],[\"a\",\"aa\",\"ae\"])) # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "917": "```\ndef reverseOnlyLetters(s):\n    left = 0\n    right = len(s) - 1\n    result = list(s)\n    \n    while left < right:\n        if not s[left].isalpha():\n            left += 1\n        elif not s[right].isalpha():\n            right -= 1\n        else:\n            result[left], result[right] = s[right], s[left]\n            left, right = left + 1, right - 1\n    \n    return \"\".join(result)\n\ndef main():\n    print(reverseOnlyLetters(\"a-bC-d*e-fG-h\") == \"dc-caB-fA-e\")\n    print(reverseOnlyLetters(\"Test1ng-vowyOn-is-lecoo-desqEatuse-0-dsw00-r-P\") == \"itceats-wenyP-sqoleedrwP-dsee\")\n    print(reverseOnlyLetters(\"ab-cd-eff\") == \"weff-cd-ab\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "918": "```\ndef maxSubarraySumCircular(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    max_sum = float('-inf')\n    min_sum = float('inf')\n\n    current_max_sum = 0\n    current_min_sum = 0\n\n    for i in range(n):\n        current_max_sum = max(nums[i], current_max_sum + nums[i])\n        current_min_sum = min(nums[i], current_min_sum + nums[i])\n\n        if current_max_sum > max_sum:\n            max_sum = current_max_sum\n\n        if current_min_sum < min_sum:\n            min_sum = current_min_sum\n\n    total_sum -= min_sum\n    return max(0, max_sum) if n == 1 else max(0, total_sum + max_sum)\n\ndef main():\n    print(maxSubarraySumCircular([-3,-2,-1])) # Test case 1: Output should be 3\n    print(maxSubarraySumCircular([1, -2, 3, 10, -4, 7, 2, -5])) # Test case 2: Output should be 18\n    print(maxSubarraySumCircular([-1,-2,-3,-6,-7])) # Test case 3: Output should be 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "919": "```\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass CBTInserter:\n    def insert(self, root: TreeNode) -> TreeNode:\n\ndef main():\n    inserter = CBTInserter()\n    \n    # Test Case 1:\n    node2 = TreeNode(5)\n    node3 = TreeNode(1)\n    node4 = TreeNode(9)\n    root = TreeNode(3)\n    root.right = node2\n    node2.left = node3\n    node2.right = node4\n    \n    result = inserter.insert(root)\n    \n    # Test Case 2:\n    node1 = TreeNode(8)\n    node2 = TreeNode(7)\n    root = TreeNode(5)\n    root.left = node1\n    node1.right = node2\n    \n    result = inserter.insert(root)\n    \n    # Test Case 3:\n    node1 = TreeNode(9)\n    node2 = TreeNode(6)\n    node3 = TreeNode(8)\n    node4 = TreeNode(7)\n    node5 = TreeNode(8)\n    root = TreeNode(0)\n    root.right = node1\n    node1.left = node2\n    node1.right = node3\n    node3.right = node4\n    node4.right = node5\n    \n    result = inserter.insert(root)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "920": "```\ndef numMusicPlaylists(N, A, B):\n    dp = [[0] * (N + 1) for _ in range(N + 1)]\n    dp[0][0] = 1\n    for i in range(1, N + 1):\n        for j in range(i + 1):\n            if j == 0:\n                dp[i][j] = A * (dp[i - 1][j] if i > 0 else 1)\n            elif j < i:\n                dp[i][j] = (B * dp[i - 1][j - 1] + (A - B) * dp[i - 1][j]) % ((10 ** 9) + 7)\n            else:\n                dp[i][j] = A * (dp[i - 1][i - 1] if i > 0 else 1)\n    return sum(dp[N])\n\ndef main():\n    print(numMusicPlaylists(3, 5, 4))\n    print(numMusicPlaylists(4, 2, 1))\n    print(numMusicPlaylists(25, 10, 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "921": "```\ndef minAddToMakeValid(s):\n    stack = []\n    res = 0\n    for c in s:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if len(stack) > 0:\n                stack.pop()\n            else:\n                res += 1\n    return res\n\ndef main():\n    print(minAddToMakeValid(\"())\")) # test case 1\n    print(minAddToMakeValid(\"(\")) # test case 2\n    print(minAddToMakeValid(\"(()\") ) # test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "922": "```\ndef oddEvenList(head):\n    if head is None:\n        return head\n\n    even = head\n    odd = head.next\n    \n    while odd and odd.next:\n        temp = odd.next\n        odd.next = temp.next\n        temp.next = even.next\n        even.next = temp\n        even = temp\n        odd = odd.next\n\n    return head\n\ndef main():\n    # Test case 1: A list with only one node.\n    head1 = ListNode(0)\n    print(\"Test case 1:\")\n    print(\"Input:\", [0])\n    print(\"Expected output:\", [0])\n    print(\"Actual output:\", sort_array_by_parity(head1).val)\n    print()\n\n    # Test case 2: A list with two even and one odd node.\n    head2 = ListNode(2)\n    head2.next = ListNode(4)\n    head2.next.next = ListNode(1)\n    print(\"Test case 2:\")\n    print(\"Input:\", [2, 4, 1])\n    print(\"Expected output:\", [2, 4, 1])\n    print(\"Actual output:\", sort_array_by_parity(head2).val)\n    print()\n\n    # Test case 3: A list with two odd and one even node.\n    head3 = ListNode(1)\n    head3.next = ListNode(3)\n    head3.next.next = ListNode(0)\n    print(\"Test case 3:\")\n    print(\"Input:\", [1, 3, 0])\n    print(\"Expected output:\", [0, 1, 3])\n    print(\"Actual output:\", sort_array_by_parity(head3).val)\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "923": "```\ndef threeSumMulti(nums):\n    n = len(nums)\n    ans = 0\n    nums.sort()\n    \n    for i in range(n - 2):\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n        \n        l, r = i+1, n-1\n        while l < r:\n            s = nums[i] + nums[l] + nums[r]\n            count_i, count_l, count_r = 1, 0, 0\n            \n            while i - 1 >= 0 and nums[i-1] == nums[i]:\n                i -= 1\n                count_i += 1\n            while l+1 < n and nums[l+1] == nums[l]:\n                l += 1\n                count_l += 1\n            while r-1 >= 0 and nums[r-1] == nums[r]:\n                r -= 1\n                count_r += 1\n            \n            if s > 0:\n                while i - 1 >= 0 and nums[i-1] == nums[i]:\n                    i -= 1\n                    count_i += 1\n                while l+1 < n and nums[l+1] == nums[l]:\n                    l += 1\n                    count_l += 1\n                while r-1 >= 0 and nums[r-1] == nums[r]:\n                    r -= 1\n                    count_r += 1\n            \n            if s > 0:\n                ans += count_i * count_l * count_r\n            else:\n                a = i+1\n                b = l\n                c = r\n                \n                while a < b and nums[a] == nums[i]:\n                    a += 1\n                    count_i -= 1\n                while b > c and nums[b-1] == nums[l]:\n                    b -= 1\n                    count_l -= 1\n                while r+1 < n and nums[r+1] == nums[r]:\n                    r += 1\n                    count_r += 1\n                \n                if s == 0:\n                    ans += math.comb(count_i, 2) * count_l * count_r\n\n    return ans\n\n\ndef main():\n    print(threeSumMulti([1,1,-2,0]))\n    print(threeSumMulti([-1,0,1,2]))\n    print(threeSumMulti([1,-1,1,-1,3]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "924": "```\ndef minMalwareSpread(grid):\n    n = len(grid)\n    m = len(grid[0])\n    infected = set()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                infected.add((i, j))\n\n    result = -1\n    for node in infected.copy():\n        infected.remove(node)\n        new_infected = set()\n        for i in range(n):\n            for j in range(m):\n                if (grid[i][j] == 0 and any(abs(i-x)+abs(j-y) <= 1 for x, y in infected)):\n                    new_infected.add((i, j))\n        if len(new_infected) < len(infected):\n            result = node\n            infected = new_infected\n\n    return list(result) if result != -1 else []\n\ndef main():\n    print(minMalwareSpread([[0, 1], [1, 0]]))  # Expected output: [[0, 1]]\n    print(minMalwareSpread([[0, 1, 0], [0, 0, 1], [1, 1, 0]]))  # Expected output: [[0, 1], [2, 0]]\n    print(minMalwareSpread([[1, 1, 1], [1, 1, 1], [1, 1, 1]]))  # Expected output: [[0, 0, 0]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "925": "```\ndef isLongPressedName(name: str, typed: str) -> bool:\n    i = j = 0\n    while j < len(typed):\n        if i < len(name) and name[i] == typed[j]:\n            i += 1\n        elif j == 0 or typed[j] != typed[j - 1]:\n            return False\n        j += 1\n    return i == len(name)\n\ndef main():\n    print(isLongPressedName(\"alex\", \"aaleex\")) # True\n    print(isLongPressedName(\"saeed\", \"ssaaedd\")) # False\n    print(isLongPressedName(\"lxyey\", \"lxeoyy\")) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "926": "```\ndef monotoneIncreasingDistance(s):\n    n = len(s)\n    left, right = [0]*n, [0]*n\n    for i in range(1, n):\n        if s[i] > s[i-1]:\n            left[i] = 1\n        else:\n            left[i] = left[i-1]\n    for i in range(n-2, -1, -1):\n        if s[i] < s[i+1]:\n            right[i] = 1\n        else:\n            right[i] = right[i+1]\n    return sum(max(left[:i] + [right[i]]) for i in range(n))\n\ndef main():\n    print(monotoneIncreasingDistance(\"001011\")) # Output: 5\n    print(monotoneIncreasingDistance(\"01001\")) # Output: 3\n    print(monotoneIncreasingDistance(\"101\")) # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "927": "```\ndef threeEqualParts(A):\n    n = len(A)\n    total = sum(A)\n    if total % 3 != 0:\n        return []\n    target = total // 3\n    count1, count2, count3 = 0, 0, 0\n    for i in range(n-2):\n        if A[i] == target:\n            count1 += 1\n        if A[i] + A[i+1] == target:\n            count2 += 1\n        if A[i] + A[i+1] + A[i+2] == target:\n            count3 += 1\n    if count1 > 0 and count2 > 0 and count3 > 0:\n        return [n-2-count1, n-2-count1-count2, n-2]\n    else:\n        return []\n\ndef main():\n    print(threeEqualParts([3,3,6,-2,-5,-3,7,6,-4,-8,-8,-2,-3,7,-3])) # Test case 1\n    print(threeEqualParts([12,-1,0,0,1,6,-1,1,2,18])) # Test case 2\n    print(threeEqualParts([0,2,1,-5,1,3,2,5,4,1])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "928": "```\ndef minMalwareSpread(graph):\n    n = len(graph)\n    infected = set()\n    for i in range(n):\n        if graph[i][i] == 1:\n            infected.add(i)\n\n    res = -1\n    for node in sorted(infected):\n        temp_infected = set(infected)\n        temp_infected.remove(node)\n        cnt = len(temp_infected)\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and neighbor not in temp_infected:\n                temp_infected.add(neighbor)\n                cnt += len(set([i for i, x in enumerate(graph[neighbor]) if x]))\n        if cnt < res or res == -1:\n            res = cnt\n\n    return min(infected) if res == len(infected) else -1\n\n\ndef main():\n    print(minMalwareSpread([[0, 1], [1, 0]]))  # Output: 0\n    print(minMalwareSpread([[1, 1, 0], [1, 1, 0], [0, 0, 1]]))  # Output: 0\n    print(minMalwareSpread([[1, 0, 1], [0, 1, 0], [1, 0, 1]]))  # Output: 2\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "929": "```\ndef numUniqueEmails(emails):\n    unique_emails = set()\n    for email in emails:\n        local_name, domain = email.split('@')\n        local_name = local_name.replace('.', '')\n        unique_email = f\"{local_name}@{domain}\"\n        unique_emails.add(unique_email)\n    return len(unique_emails)\n\ndef main():\n    test_cases = [\n        {\"emails\": [\"john.doe@example.com\", \"anna.mus@example.com\", \"liz@example.com\", \"mary@example.com\"]},\n        {\"emails\": [\"test.email+alex@leetcode.com\",\"test.e.mail.bacon+tom@lee.tcode.com\",\"a+very+normal.email.with.+yeah@example.com\"]},\n        {\"emails\": [\"test.email+alex@leetcode.com\"]}\n    ]\n\n    for test_case in test_cases:\n        print(f\"Test Case: {test_case['emails']}\")\n        result = numUniqueEmails(test_case[\"emails\"])\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "930": "```\ndef numSubarraysWithSum(target):\n    res = 0\n    for i in range(len(nums)):\n        prefix_sum = 0\n        for j in range(i, len(nums)):\n            prefix_sum += nums[j]\n            if prefix_sum == target:\n                res += 1\n    return res\n\ndef main():\n    test_cases = [\n        {\"nums\": [0,1], \"target\": 2, \"expected_output\": 3},\n        {\"nums\": [0,1,1,0,1], \"target\": 0, \"expected_output\": 8},\n        {\"nums\": [1,0,1,1,0], \"target\": 0, \"expected_output\": 7}\n    ]\n\n    for test_case in test_cases:\n        nums = test_case[\"nums\"]\n        target = test_case[\"target\"]\n        expected_output = test_case[\"expected_output\"]\n\n        output = numSubarraysWithSum(nums)\n        if output == expected_output:\n            print(f\"Test case {test_case} passed\")\n        else:\n            print(f\"Test case {test_case} failed. Expected {expected_output}, got {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "931": "```\ndef minFallingPathSum(A):\n    m = len(A)\n    n = len(A[0])\n    dp = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        dp[i][0] = A[i][0]\n        \n    for j in range(1, n):\n        for i in range(m):\n            if i == 0:\n                dp[i][j] = A[i][j] + min(dp[0][j-1], dp[1][j-1])\n            elif i == m-1:\n                dp[i][j] = A[i][j] + min(dp[i-1][j-1], dp[i][j-1])\n            else:\n                dp[i][j] = A[i][j] + min(dp[i-1][j-1], dp[i-1][j], dp[i+1][j-1])\n\n    return min(dp[i][n-1] for i in range(m))\n\n\ndef main():\n    print(minFallingPathSum([[2,1,3],[6,5,4],[1,1,1]]))  # Output: 2\n    print(minFallingPathSum([[10]]))  # Output: 10\n    print(minFallingPathSum([[3,2]]))  # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "932": "```\ndef beautifulArray(n):\n    if n == 1:\n        return [1]\n\n    result = [1]\n    for i in range(1, log2(n)):\n        result.extend([x*2-1 for x in result])\n        result.extend([x*2+1 for x in result])\n    result = [x for x in result if x <= n]\n    return result\n\nimport math\ndef main():\n    test_cases = [(4, [1, 3]), (5, [1, 5]), (6, [1, 5]))\n    for test_case in test_cases:\n        result = beautifulArray(test_case[0])\n        if result == test_case[1]:\n            print(f\"Test case {test_case} passed!\")\n        else:\n            print(f\"Test case {test_case} failed!\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "933": "```\nfrom collections import deque\n\nclass RecentCounter:\n    def __init__(self):\n        self.queue = deque()\n\n    def ping(self, t: int) -> int:\n        self.queue.append(t)\n        while self.queue[0] <= t - 300:\n            self.queue.popleft()\n        return len(self.queue)\n\n\ndef main():\n    recentCalls = RecentCounter()\n\n    print(recentCalls.ping(1)) # Output: 1\n    print(recentCalls.ping(100)) # Output: 2\n    print(recentCalls.ping(300)) # Output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "934": "```\ndef shortestBridge(grid):\n    # your implementation here\n\nimport unittest\nclass TestSolution(unittest.TestCase):\n\n    def test_shortest_bridges(self):\n        grid = [[0,1,0],[1,1,1],[0,1,0]]\n        self.assertEqual(shortestBridge(grid), 1)\n\n        grid = [[0,1,0,0,0],[0,1,0,0,0],[0,0,1,1,1],[5,1,0,1,1],[1,1,0,0,6]]\n        self.assertEqual(shortestBridge(grid), 8)\n\n        grid = [[0,0,0,0,0], [0,1,1,1,0], [0,1,1,1,0], [0,0,0,0,0]]\n        self.assertEqual(shortestBridge(grid), 3)\n\n    def test_edge_cases(self):\n        grid = []\n        self.assertEqual(shortestBridge(grid), None)\n\nif __name__ == '__main__':\n    unittest.main()\n```",
  "935": "```\ndef minStepToTarget(n, target):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(n):\n        if i + 1 <= target:\n            dp[i + 1] = min(dp[i + 1], 1 + dp[i])\n        if i - 2 >= 0 and i - 2 + 3 <= target:\n            dp[i - 2 + 3] = min(dp[i - 2 + 3], 1 + dp[i])\n        if i - 1 >= 0 and i - 1 + 4 <= target:\n            dp[i - 1 + 4] = min(dp[i - 1 + 4], 1 + dp[i])\n    return dp[target]\n\ndef main():\n    print(minStepToTarget(5, 3)) # Expected: 2\n    print(minStepToTarget(10, 6)) # Expected: 3\n    print(minStepToTarget(25, 23)) # Expected: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "936": "```\ndef minStickers(stickerBag, vogueMagazines):\n    n = len(vogueMagazines[0])\n    dp = [float('inf')] * (1 << n)\n    dp[0] = 0\n    for sticker in stickerBag:\n        for mag in range(1 << n):\n            if not ((mag >> int(str(sticker), 2)).bit_length() & 1) and \\\n               all((dp[mag | (1 << i)) < dp[mag] + 1 for i in range(n) if str(sticker)[i] == vogueMagazines[0][i])):\n                dp[mag | (1 << int(str(sticker), 2)).bit_length()] = min(dp[mag | (1 << int(str(sticker), 2)).bit_length()], dp[mag] + 1)\n    return dp[-1]\n\ndef main():\n    stickerBag1 = [\"shop\", \"tarp\", \"top\"]\n    vogueMagazines1 = [\"lassiecomehome\", \"shop\", \"tome\", \"top\"]\n    print(minStickers(stickerBag1, vogueMagazines1))\n\n    stickerBag2 = [\"show\", \"meet\", \"cool\"]\n    vogueMagazines2 = [\"show\", \"cool\", \"meet\"]\n    print(minStickers(stickerBag2, vogueMagazines2))\n\n    stickerBag3 = [\"hot\", \"dot\", \"got\"]\n    vogueMagazines3 = [\"hot\", \"dot\", \"goat\"]\n    print(minStickers(stickerBag3, vogueMagazines3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "937": "```\ndef reorderLogFiles(logs):\n    letter_logs = sorted([(log.split()[1:], log) for log in logs if log[0].isalpha()], key=lambda x: (x[0][0], x[1]))\n    digit_logs = [log for log in logs if not log[0].isalpha()]\n    return [log for _, log in letter_logs] + digit_logs\n\ndef main():\n    test_cases = [\n        [\"a1. b2\", \"c3\", \"v4 news5\", \"1 2\"],\n        [\"foo1 bar7\", \"bar1 foo2\", \"x1 x2 x3 x4 x5\"],\n        [\"00001 2 3 19\", \" Definition ffff f\", \"00002 6 7 8 9\"]\n    ]\n\n    for test_case in test_cases:\n        print(\"Input: \", test_case)\n        print(\"Output: \", reorderLogFiles(test_case))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "938": "```\ndef rangeSumBST(root, L, R):\n    def dfs(node):\n        if node:\n            if L <= node.val <= R:\n                res += node.val\n            if L < node.val:\n                res += dfs(node.left)\n            if node.val < R:\n                res += dfs(node.right)\n        return res\n\n    res = 0\n    res = dfs(root)\n    return res\n\n\ndef main():\n    # Test case 1\n    root = TreeNode(10)\n    root.left = TreeNode(5)\n    root.right = TreeNode(15)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(8)\n    print(rangeSumBST(root, 7, 9))\n\n    # Test case 2\n    root = TreeNode(1)\n    root.left = TreeNode(4)\n    root.right = TreeNode(5)\n    print(rangeSumBST(root, 1, 3))\n\n    # Test case 3\n    root = None\n    print(rangeSumBST(root, 0, 0))\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "939": "```\ndef minAreaRect(points):\n    x_coords = set()\n    for p in points:\n        x_coords.add(p[0])\n    \n    ans = float('inf')\n    for x1 in x_coords:\n        for x2 in x_coords:\n            if x1 == x2:\n                continue\n            y1, y2 = min((p[1] for p in points if p[0] == x1)), max((p[1] for p in points if p[0] == x1))\n            y3, y4 = min((p[1] for p in points if p[0] == x2)), max((p[1] for p in points if p[0] == x2))\n            if y1 < y3 or y2 < y4:\n                continue\n            ans = min(ans, (x2 - x1) * abs(y2 - y1))\n\n    return min(0, ans)\n\ndef main():\n    print(minAreaRect([[1,1],[1,3],[3,1],[3,3],[2,2]]))  # Expected output: 4\n    print(minAreaRect([[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]))  # Expected output: 9\n    print(minAreaRect([[1,1],[1,3],[3,1],[3,6],[2,2],[2,4]]))  # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "940": "```\ndef numDistinct(s, t):\n    m = len(t)\n    dp = [[0] * (m + 1) for _ in range(len(s) + 1)]\n    \n    for i in range(len(s) + 1):\n        dp[i][0] = 1\n    for i in range(1, len(s) + 1):\n        for j in range(1, m + 1):\n            if s[i - 1] == t[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[-1][-1]\n\ndef main():\n    print(numDistinct(\"rabbbit\", \"rabbit\") == 2)\n    print(numDistinct(\"babgbag\", \"bag\") == 4)\n    print(numDistinct(\"bbbgd\", \"b\") == 1)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "941": "```\ndef validateMountainArray(arr):\n    for i in range(1, len(arr)):\n        if arr[i-1] <= arr[i]:\n            return False\n    last_index = len(arr) - 1\n    for i in range(last_index-1, -1, -1):\n        if arr[i-1] >= arr[i]:\n            return False\n    return True\n\n\ndef main():\n    print(validateMountainArray([2, 1]))  # Expected: False\n    print(validateMountainArray([3, 5, 4]))  # Expected: False\n    print(validateMountainArray([0, 3, 2, 1]))  # Expected: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "942": "```\ndef diStringMatch(s):\n    min_val = 0\n    max_val = len(s)\n    res = []\n\n    for _ in s:\n        if s[0] == 'D':\n            res.append(min_val)\n            min_val += 1\n        else:\n            res.append(max_val - 1)\n            max_val -= 1\n\n    res.append(min_val)\n\n    return res\n\n\ndef main():\n    print(diStringMatch(\"IDIZI\")) # Output: [0,4,1,3,5]\n    print(diStringMatch(\"RLEET\")) # Output: [0,1,2,3,7,6]\n    print(diStringMatch(\"III\"))   # Output: [0,1,2,2]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "944": "```\ndef minDeletions(columns):\n    columns.sort(key=lambda x: list(x))\n    res = len(columns[0])\n    for col in columns:\n        if len(set(col)) < res:\n            return len(columns) - (res - len(set(col)))\n    return 0\n\ndef main():\n    print(minDeletions([[\"a\",\"b\",\"c\",\"d\"],[\"d\",\"b\",\"a\",\"c\"],[\"c\",\"d\",\"e\",\"f\"]]))\n    print(minDeletions([[\"x\",\"y\",\"z\"],[\"x\",\"x\",\"x\"],[\"x\",\"x\",\"y\"]]))\n    print(minDeletions([[\"a\",\"c\"],[\"6\",\"1\"],[\"4\",\"7\"],[\"5\",\"3\"],[\"9\",\"8\"]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "943": "```\ndef shortestSuperstring(strs):\n    if not strs:\n        return \"\"\n\n    dp = [[0] * len(strs) for _ in range(len(strs))]\n    for i, x in enumerate(strs):\n        for j, y in enumerate(strs):\n            if i == j:\n                dp[i][j] = 0\n            elif j < i:\n                dp[i][j] = dp[j][i]\n            else:\n                k = min(i, j) + 1\n                while k <= len(y) and k <= len(x) and y[-k:] != x[:-k]:\n                    k += 1\n                dp[i][j] = k\n\n    h = max(len(x) for x in strs)\n    s = [0] * (len(strs) + 1)\n    a, b, c = max(range(h), key=lambda i:dp[0][i]), max(range(h), key=lambda i:dp[i][0]), -1\n    while a:\n        b = dp[a][b]\n        s[-1], s[s.index(a)] = s[a], s[-1]; a, b = c + 1, a; c = b\n    return \"\".join(x for x in strs if s.index(int(x)) > 0).lstrip()\n\ndef main():\n    test_cases = [\n        {\"input\": [\"cat\",\"bat\",\"hat\",\"tree\"],\"output\":\"bath\"},\n        {\"input\": [\"a\",\"aa\",\"aaa\"],\"output\":\"aaaa\"},\n        {\"input\":[\"abac\",\"cab\"],\"output\":\"cabab\"}\n    ]\n\n    for test_case in test_cases:\n        strs = test_case[\"input\"]\n        output = shortestSuperstring(strs)\n        if output == test_case[\"output\"]:\n            print(\"Test Case Passed\")\n        else:\n            print(f\"Test Case Failed. Expected {test_case['output']}, but got {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "945": "```\ndef minIncrementForUnique(A):\n    A.sort()\n    max_val = A[-1]\n    res = 0\n    for i in range(len(A) - 1):\n        if A[i] == A[i + 1]:\n            diff = A[i + 1] - A[i] + 1\n            res += diff\n            A[i + 1] += diff\n            max_val = max(max_val, A[i + 1])\n    return res\n\ndef main():\n    print(minIncrementForUnique([3,2,1,2])) # Expected output: 5\n    print(minIncrementForUnique([4,2,1,6])) # Expected output: 19\n    print(minIncrementForUnique([0,4,1,2,3])) # Expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "946": "```\ndef validateStackSequences(pushed, popped):\n    stack = []\n    i = j = 0\n    while i < len(pushed) or j < len(popped):\n        if not stack or pushed[i] == stack[-1]:\n            stack.append(pushed[i])\n            i += 1\n        elif stack and stack[-1] == popped[j]:\n            stack.pop()\n            j += 1\n        else:\n            i += 1\n    return len(stack) == 0\n\ndef main():\n    test_cases = [\n        ([1,2,3], [2,1,3]),\n        ([1,2,3,4,5], [4,5,3,2,1]),\n        ([1,0], [1])\n    ]\n\n    for pushed, popped in test_cases:\n        print(f\"Test Case: {pushed} -> {popped}\")\n        print(validateStackSequences(pushed, popped))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "947": "```\ndef removeStones(stonePosition):\n    rows = {}\n    cols = {}\n\n    for x, y in stonePosition:\n        if x not in rows:\n            rows[x] = []\n        rows[x].append(y)\n        if y not in cols:\n            cols[y] = []\n        cols[y].append(x)\n\n    removed = 0\n\n    for r in rows:\n        for c1 in range(len(rows[r])):\n            for c2 in range(c1 + 1, len(rows[r])):\n                x1, y1 = rows[r][c1], rows[r][c2]\n                x2, y2 = rows[r][c2], rows[r][c1]\n                if (x1 - x2) ** 0.5 == int((x1 - x2) ** 0.5):\n                    for xy in rows[r]:\n                        stonePosition.remove((xy, y1))\n                        stonePosition.remove((xy, y2))\n                    removed += len(rows[r]) - 2\n\n    for c in cols:\n        for c1 in range(len(cols[c])):\n            for c2 in range(c1 + 1, len(cols[c])):\n                x1, y1 = cols[c][c1], cols[c][c2]\n                x2, y2 = cols[c][c2], cols[c][c1]\n                if (y1 - y2) ** 0.5 == int((y1 - y2) ** 0.5):\n                    for xy in cols[c]:\n                        stonePosition.remove((x1, xy))\n                        stonePosition.remove((x2, xy))\n                    removed += len(cols[c]) - 2\n\n    return removed\n\n\ndef main():\n    print(removeStones([(0,4),(3,0),(0,9),(2,9),(3,4),(5,3),(5,4),(6,19),(7,18),(8,20)])) # Test Case 1\n    print(removeStones([(14,5),(7,1), (10,3)]) # Test Case 2\n    print(removeStones([])) # Test Case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "948": "```\ndef bagOfTokensScore(tokens):\n    tokens.sort()\n    score = 0\n    left, right = 0, len(tokens) - 1\n    while left <= right:\n        if tokens[left] == tokens[right]:\n            score += 2\n            left += 1\n            right -= 1\n        elif tokens[right] - tokens[left] > 0:\n            score += 1\n            left += 1\n        else:\n            score += 1\n            right -= 1\n    return score\n\ndef main():\n    print(bagOfTokensScore([8,6,7,5,4])) # Test Case 1: Output = 9\n    print(bagOfTokensScore([40,10,20]) ) # Test Case 2: Output = 6\n    print(bagOfTokensScore([3,5,1,6,7,6,8])) # Test Case 3: Output = 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "949": "```\ndef largestTimeFromDigits(A):\n    max_time = -1\n    for h in range(24):\n        for i in range(60):\n            if A[4] == '0' or str(i) + str(A[4]) > str(h) + str(i):\n                continue\n            for j in range(10, 100):\n                if A[2] == '0' or str(j) % 10 < A[3]:\n                    continue\n                if i > 59 or h > 23:\n                    break\n                time = int(str(h).zfill(2) + str(i).zfill(2))\n                max_time = max(max_time, time)\n    return format(max_time, '#02X') if max_time == -1 else format(time // 10000, ':').replace(':', 'h')\n\ndef main():\n    A1 = [1,9,0,0,0,0,6,4]\n    print(largestTimeFromDigits(A1)) # Output: \"09:46\"\n\n    A2 = [6,6,6,6,5,7,9,8,8]\n    print(largestTimeFromDigits(A2)) # Output: \"06:40\"\n\n    A3 = [1,2,3,4,5,6]\n    print(largestTimeFromDigits(A3)) # Output: \"-1\"\n\nmain()\n```",
  "950": "```\ndef deckRevealedIncreasing(cards):\n    n = len(cards)\n    queue = list(range(n))\n    result = [None] * n\n    cards.sort()\n    \n    for card in cards:\n        if queue:\n            result[queue.pop(0)] = card\n    \n    return result\n\n\ndef main():\n    test_cases = [\n        {\"input\": [[17, 13, 11], []], \"expected_output\": [17, 13, 11]},\n        {\"input\": [[1, 10000], []], \"expected_output\": [1, 2, 3, ..., 9999, 10000]},\n        {\"input\": [[1, 4, 5, 2, 3, 7, 6, 8, 9, 10, 11, 12, 13], []], \"expected_output\": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]}\n    ]\n    \n    for test_case in test_cases:\n        input_cards = test_case[\"input\"][0]\n        expected_output = test_case[\"expected_output\"]\n        \n        output = deckRevealedIncreasing(input_cards)\n        if output != expected_output:\n            print(\"Test case failed: \" + str(test_case))\n        else:\n            print(\"Test case passed: \" + str(test_case))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "951": "```\nclass Solution:\n    def isFlipped(self, root1: TreeNode, root2: TreeNode) -> bool:\n        if not root1 and not root2:\n            return True\n        if not root1 or not root2:\n            return False\n        if root1.val != root2.val:\n            return False\n        return self.isFlipped(root1.left, root2.right) and self.isFlipped(root1.right, root2.left)\n\ndef main():\n    solution = Solution()\n    \n    # Test case 1: Correctly flipped binary trees\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root2 = TreeNode(1)\n    root2.right = TreeNode(2)\n    root2.left = TreeNode(3)\n    print(solution.isFlipped(root1, root2))  # Expected output: True\n\n    # Test case 2: Binary trees with different values\n    root1 = TreeNode(4)\n    root1.left = TreeNode(5)\n    root1.right = TreeNode(6)\n    root2 = TreeNode(7)\n    root2.right = TreeNode(8)\n    root2.left = TreeNode(9)\n    print(solution.isFlipped(root1, root2))  # Expected output: False\n\n    # Test case 3: One of the binary trees is empty\n    root1 = None\n    root2 = TreeNode(10)\n    root2.right = TreeNode(11)\n    root2.left = TreeNode(12)\n    print(solution.isFlipped(root1, root2))  # Expected output: False\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n```",
  "952": "```\ndef maxComponentSize(nums):\n    parent = {}\n    rank = {}\n\n    def find(x):\n        if x not in parent:\n            parent[x] = x\n            rank[x] = 0\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        root_x = find(x)\n        root_y = find(y)\n        if root_x == root_y:\n            return\n        if rank[root_x] > rank[root_y]:\n            parent[root_y] = root_x\n        else:\n            parent[root_x] = root_y\n            if rank[root_x] == rank[root_y]:\n                rank[root_y] += 1\n\n    for num in nums:\n        for factor in range(2, int(num ** 0.5) + 1):\n            if num % factor == 0:\n                union(num, factor)\n                union(num, num // factor)\n\n    max_size = 0\n    for num in parent:\n        root = find(num)\n        size = len([x for x in parent if find(x) == root])\n        max_size = max(max_size, size)\n\n    return max_size\n\ndef main():\n    print(\"Test case 1: \")\n    nums = [6,3,8,10,3,9]\n    print(maxComponentSize(nums)) # Output: 4\n    \n    print(\"\\nTest case 2: \")\n    nums = [21, 44, 100]\n    print(maxComponentSize(nums)) # Output: 2\n\n    print(\"\\nTest case 3: \")\n    nums = [10,6,5,4]\n    print(maxComponentSize(nums)) # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "954": "```\ndef canBeEqual(target):\n    target.sort()\n    for i in range(len(target) // 2):\n        if target[i] != target[-1 - i] * 2:\n            return False\n    return True\n\n\ndef main():\n    print(canBeEqual([3,1,3,1,6]))  # Expected: True\n    print(canBeEqual([7,4,5,3,3]))  # Expected: False\n    print(canBeEqual([1,2,3,4,5]))   # Expected: False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "953": "```\ndef isAlienSorted(words, order):\n    n = len(order)\n    m = len(words)\n    res = [0] * m\n    for i in range(m):\n        for j in range(i + 1, m):\n            x = 0\n            while x < n and (words[i][x] != words[j][x]):\n                if order.find(words[i][x]) > order.find(words[j][x]):\n                    res[i], res[j] = min(res), max(res)\n                    return False\n                elif order.find(words[i][x]) < order.find(words[j][x]):\n                    pass\n                else:\n                    x += 1\n    return res == sorted(range(m))\n\ndef main():\n    print(isAlienSorted([\"hello\",\"leetcode\"],[\"e\",\"a\"])) \n    print(isAlienSorted([\"kiexrtyu\",\"kietyruxz\"], [\"y\", \"t\"])) \n    print(isAlienSorted([\"foo\",\"bar\"], [\"o\", \"b\"]))\n    \nif __name__ == \"__main__\":\n    main()\n```",
  "955": "```\ndef minDeletions(cols):\n    n = len(cols[0])\n    res = [0] * n\n    for i in range(n):\n        col = [c[i] for c in cols]\n        j = n - 1\n        while j > i and col[j-1] >= col[j]:\n            j -= 1\n        res[i] = len(col) - j\n    return sum(res)\n\ndef main():\n    test_cases = [\n        {\"cols\": [[\"a\",\"b\",\"minaab\"],[\"xx\",\"yy\",\"pq\"],\"wp\",\"oo\"],[\"expected\": 5}],\n        {\"cols\": [[\"abc\",\"azd\",\"qux\"],[\"yzf\",\"qpx\",\"abcw\"],[\"xye\",\"zws\",\"zyy\"]],\"expected\": 3},\n        {\"cols\": [[\"ghi\",\"klo\",\"mno\"],[\"pqr\",\"rst\",\"stu\"]],\"expected\": 4}\n    ]\n\n    for test_case in test_cases:\n        cols = [list(map(str, c)) for c in zip(*test_case[\"cols\"])]\n        result = minDeletions(cols)\n        if result == test_case[\"expected\"]:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed. Expected {test_case['expected']} but got {result}.\")\n    \n    print(\"All test cases have been run.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "956": "```\ndef tallestBillboard(heights):\n    n = len(heights)\n    memo = [[0]*n for _ in range(n)]\n    \n    def dp(i, j):\n        if i > j:\n            return 0\n        if memo[i][j] > 0:\n            return memo[i][j]\n        memo[i][j] = max(heights[i], heights[j]) + min(dp(i+1, j-1), dp(i, j-1), dp(i+1, j))\n        return memo[i][j]\n\n    return dp(0, n-1)\n\ndef main():\n    test_case_1 = [6,2,5,1,5,4]\n    print(\"Tallest Billboard for\", test_case_1, \"is:\", tallestBillboard(test_case_1))\n\n    test_case_2 = [1,8,3,5,6]\n    print(\"Tallest Billboard for\", test_case_2, \"is:\", tallestBillboard(test_case_2))\n\n    test_case_3 = [12,0,0,9,0,0,7]\n    print(\"Tallest Billboard for\", test_case_3, \"is:\", tallestBillboard(test_case_3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "957": "```\ndef prisonAfterN(days):\n    if days == 0:\n        return [0] * 8\n    seen = set()\n    state = [1, 0, 0, 1, 0, 0, 0, 0]\n    for _ in range(7):\n        next_state = [0] * 8\n        for i in range(1, 7):\n            if state[i-1] == state[i+1]:\n                next_state[i] = 1\n        state = next_state\n    seen.add(tuple(state))\n    result = []\n    while days > 0:\n        if days % (len(seen) + 1) == 0 or tuple(state) in seen:\n            result.extend(list(state))\n            break\n        for _ in range(7):\n            next_state = [0] * 8\n            for i in range(1, 7):\n                if state[i-1] == state[i+1]:\n                    next_state[i] = 1\n            state = list(next_state)\n        seen.add(tuple(state))\n    return result\n\ndef main():\n    print(prisonAfterN(0)) # [0, 0, 0, 0, 0, 0, 0, 0]\n    print(prisonAfterN(7)) # [1, 0, 1, 1, 1, 0, 1, 0]\n    print(prisonAfterN(17)) # [2, 0, 2, 0, 2, 0, 2, 0]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "958": "```\ndef isCompleteTree(root):\n    if not root:\n        return True\n\n    queue = [root]\n    flag = False\n\n    while queue:\n        node = queue.pop(0)\n\n        if not node.left and not node.right:\n            flag = True\n        elif node.left and node.right:\n            queue.append(node.left)\n            queue.append(node.right)\n        else:\n            return False\n\n    return flag\n\n\ndef main():\n    # Test case 1: Complete Binary Tree\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    root1.left.right = TreeNode(5)\n\n    print(isCompleteTree(root1))  # Expected output: True\n\n    # Test case 2: Incomplete Binary Tree\n    root2 = TreeNode(1)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(3)\n    root2.left.left = TreeNode(4)\n\n    print(isCompleteTree(root2))  # Expected output: False\n\n    # Test case 3: Single Node Tree (complete)\n    root3 = TreeNode(1)\n\n    print(isCompleteTree(root3))  # Expected output: True\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "960": "```\ndef lengthOfLIS(columns):\n    if not columns:\n        return 0\n    \n    dp = [1] * len(columns[0])\n    \n    for col in zip(*columns):\n        new_dp = [1] * len(col)\n        \n        for i in range(len(col)):\n            for j in range(i):\n                if col[i] > col[j]:\n                    new_dp[i] = max(new_dp[i], dp[j] + 1)\n        \n        dp = new_dp\n        \n    return max(dp)\n\ndef main():\n    print(lengthOfLIS([[\"a\",\"b\",\"c\"],[\"d\",\"e\",\"f\"],[\"g\",\"h\",\"i\"]]))\n    print(lengthOfLIS([[\"colo1\", \"colo2\", \"colo3\"], [\"abc\", \"xyz\", \"xyz\"], [\"xyxb\", \"zyc\", \"xzy\"]]))\n    print(lengthOfLIS([[\"a\",\"b\"],[\"c\",\"d\"],[\"e\",\"f\"]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "959": "```\ndef maxAreas(grid):\n    if not grid:\n        return 0\n\n    m, n = len(grid), len(grid[0])\n    areas = [[0] * n for _ in range(m)]\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n:\n            return 0\n        if grid[i][j] == '-':\n            return 0\n        areas[i][j] = 1\n        total_area = 1\n        for dx, dy in directions:\n            ni, nj = i + dx, j + dy\n            if 0 <= ni < m and 0 <= nj < n:\n                if grid[ni][nj] == '/':\n                    total_area += dfs(ni, nj)\n                elif areas[ni][nj]:\n                    total_area += dfs(ni, nj)\n        return total_area\n\n    max_area = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] != '-':\n                max_area = max(max_area, dfs(i, j))\n    return max_area\n\n\ndef main():\n    test_cases = [\n        {\"grid\": [[\"1\", \"1\"], [\"1\", \"-1\"]], \"expected_output\": 2},\n        {\"grid\": [[\"1\", \"1\", \"1\"], [\"-1\", \"-1\", \"-1\"], [\"1\", \"1\", \"1\"]], \"expected_output\": 6},\n        {\"grid\": [[\"1\", \"-1\", \"-1\"], [\"1\", \"1\", \"-1\"], [\"-1\", \"-1\", \"1\"]], \"expected_output\": 3},\n    ]\n\n    for test_case in test_cases:\n        output = maxAreas(test_case[\"grid\"])\n        if output == test_case[\"expected_output\"]:\n            print(\"Test case passed: \", test_case)\n        else:\n            print(\"Test case failed: \", test_case)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "961": "```\ndef findDuplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n\ndef main():\n    print(\"Test Case 1: \")\n    nums1 = [1, 3, 4, 2, 1, 3]\n    print(findDuplicate(nums1))  # Expected output: 1\n\n    print(\"\\nTest Case 2: \")\n    nums2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    print(findDuplicate(nums2))  # Expected output: None (since no duplicate)\n\n    print(\"\\nTest Case 3: \")\n    nums3 = [1, 1, 1, 1, 1, 1]\n    print(findDuplicate(nums3))  # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "962": "```\ndef maxArea(height):\n    n = len(height)\n    left, right = 0, n - 1\n    max_area = 0\n    \n    while left < right:\n        w = right - left\n        h = min(height[left], height[right])\n        area = w * h\n        \n        if area > max_area:\n            max_area = area\n            \n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n    \n    return max_area\n\ndef main():\n    print(maxArea([2,1,5,6,2,3])) # Expected output: 9\n    print(maxArea([4,2,0,2,4,1])) # Expected output: 10\n    print(maxArea([1,8,6,2,5,9,4,3,7])) # Expected output: 24\n\nif __name__ == \"__main__\":\n    main()\n```",
  "963": "```\ndef minAreaRect(points):\n    points = set((x, y) for x, y in points)\n    ans = float('inf')\n    for x1, y1 in points:\n        for x2, y2 in points:\n            if (x1, y2) in points and (x2, y1) in points:\n                ans = min(ans, abs((x1 - x2) * (y1 - y2)))\n    return 0 if ans == float('inf') else ans\n\ndef main():\n    print(minAreaRect([[1,1],[1,3],[3,1],[3,3]]))  # Expected: 4\n    print(minAreaRect([[1,1],[1,3],[3,1],[2,2]]))  # Expected: 4\n    print(minAreaRect([[0,0],[0,5],[3,0],[3,5]]))  # Expected: 9\n\nif __name__ == \"__main__\":\n    main()\n```",
  "964": "```\ndef minSteps(n: int) -> int:\n    dp = [0] * (n + 1)\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            dp[i] = dp[i // 2] + 1\n        elif i % 3 == 0:\n            dp[i] = dp[i // 3] + 1\n        else:\n            for j in range(5, int(i ** 0.5) + 1):\n                if i % j == 0:\n                    dp[i] = min(dp[i], dp[j - 1] + (i // j))\n                    break\n            else:\n                dp[i] = i\n    return dp[n]\n\n\ndef main():\n    print(minSteps(4))  # Output: 2\n    print(minSteps(8))  # Output: 3\n    print(minSteps(12))  # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "965": "```\nclass Solution:\n    def isUnivalued(self, root):\n        if not root:\n            return True\n        \n        val = root.val\n        stack = [root]\n        \n        while stack:\n            node = stack.pop()\n            \n            if node.val != val:\n                return False\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        \n        return True\n\ndef main():\n    solution = Solution()\n\n    root1 = TreeNode(1, None, None)\n    print(solution.isUnivalued(root1))  # Expected: True\n\n    root2 = TreeNode(2, TreeNode(3), TreeNode(4))\n    print(solution.isUnivalued(root2))  # Expected: False\n\n    root3 = TreeNode(5, TreeNode(5), TreeNode(5))\n    print(solution.isUnivalued(root3))  # Expected: True\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n```",
  "966": "```\ndef spellchecker(wordlist, queries):\n    word_to_index = {}\n    count_to_word = {}\n    vowel_to_word = {}\n\n    for i, w in enumerate(wordlist):\n        if w[0].lower() not in vowel_to_word:\n            vowel_to_word[w[0].lower()] = w\n        if w.lower() not in count_to_word:\n            count_to_word[w.lower()] = w\n        word_to_index[w] = i\n\n    result = []\n    for q in queries:\n        if q.isalpha():\n            if q[0].lower() in vowel_to_word and q.lower() in count_to_word:\n                result.append(vowel_to_word[q[0].lower()])\n            elif q.lower() in count_to_word:\n                result.append(count_to_word[q.lower()])\n            else:\n                result.append(wordlist[word_to_index.get(q, -1)])\n        else:\n            result.append(\"\")\n\n    return [w if w != \"\" else \"Not Found\" for w in result]\n\ndef main():\n    wordlist = [\"apple\",\"ot\",\"tyu\"]\n    queries = [\"a\",\"b\",\"y\"]\n    print(spellchecker(wordlist,queries))\n\n    wordlist = [\"KiTe\",\"Kite\",\"Horse\",\"Horts\"]\n    queries = [\"What\",\"most\",\"kite\"]\n    print(spellchecker(wordlist,queries))\n\n    wordlist = [\"Hello\",\"world\",\"world\"]\n    queries = [\"world\",\"World\",\"helLO\"]\n    print(spellchecker(wordlist,queries))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "967": "```\ndef nums_same_consecutive_diff(n):\n    if n == 1:\n        return [1]\n\n    nums = [n]\n    for _ in range(2, len(str(n))):\n        new_nums = []\n        for num in nums:\n            diff1 = int(str(num)[0]) - 1\n            diff2 = int(str(num)[-1]) - 1\n            if 0 <= diff1 <= 9 and 0 <= diff2 <= 9:\n                new_num = str(diff1) + str(n)[-1]\n                new_nums.append(int(new_num))\n            if 0 <= diff1 <= 9 and 0 <= diff2 <= 9:\n                new_num = str(n)[0] + str(diff2)\n                new_nums.append(int(new_num))\n        nums = new_nums\n    return nums\n\ndef main():\n    print(nums_same_consecutive_diff(1000000))\n\nmain()\n```",
  "968": "```\ndef minCameraCover(root):\n    if not root:\n        return 0\n\n    def dfs(node):\n        nonlocal res\n        if node.val == -1:\n            return True, False\n        left_covered, left_placed = dfs(node.left)\n        right_covered, right_placed = dfs(node.right)\n        if not left_covered and not right_covered:\n            res += 1\n            return True, True\n        if left_placed or right_placed:\n            return True, False\n        return False, False\n\n    res = 0\n    has_camera, _ = dfs(root)\n    return res\n\n\ndef main():\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    root1.left.right = TreeNode(5)\n\n    print(minCameraCover(root1))  # Expected output: 1\n\n    root2 = TreeNode(0, None, TreeNode(1))\n    print(minCameraCover(root2))  # Expected output: 2\n\n    root3 = TreeNode(0, None, TreeNode(1, None, TreeNode(2)))\n    print(minCameraCover(root3))  # Expected output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "969": "```\ndef pancakeFlip(N):\n    flips = []\n    for i in range(len(N)):\n        max_idx = N.index(max(N[:i+1]))\n        if max_idx != i:\n            if max_idx > i:\n                N[:max_idx+1] = reversed(N[:max_idx+1])\n            N[:i+1] = reversed(N[:i+1])\n            flips.append(i+1)\n    return flips\n\ndef main():\n    test_cases = [\n        {\"input\": [3, 2, 1, 3], \"expected_output\": [4]},\n        {\"input\": [1], \"expected_output\": []},\n        {\"input\": [5, 4, 3, 2, 1], \"expected_output\": [5]}\n    ]\n\n    for test_case in test_cases:\n        N = test_case[\"input\"]\n        expected_output = test_case[\"expected_output\"]\n\n        output = pancakeFlip(N)\n        \n        if output == expected_output:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected {expected_output}, got {output}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "970": "```\ndef powerful_integers(x1, x2, n):\n    set_power = set()\n    for i in range(1, n+1):\n        if pow(i, x1) + pow(i, x2) <= n:\n            set_power.add(pow(i, x1) + pow(i, x2))\n    return list(set_power)\n\ndef main():\n    print(powerful_integers(3, 5, 15)) \n    print(powerful_integers(2, 3, 10))  \n    print(powerful_integers(1, 4, 25))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "971": "```\nclass Solution:\n    def flipEquiv(self, root: TreeNode) -> bool:\n        if not root:\n            return True\n        left_root = root.left\n        right_root = root.right\n        root.left, root.right = right_root, left_root\n        return self.flipEquiv(root)\n\ndef main():\n    s = Solution()\n    \n    # Test case 1\n    a1 = TreeNode(1)\n    b1 = TreeNode(2)\n    c1 = TreeNode(3)\n    d1 = TreeNode(4)\n    e1 = TreeNode(5)\n    f1 = TreeNode(20)\n    g1 = TreeNode(15)\n    h1 = TreeNode(25)\n\n    a1.left, a1.right = b1, c1\n    c1.left, c1.right = d1, e1\n    f1.left, f1.right = g1, h1\n\n    print(s.flipEquiv(a1))\n\n    # Test case 2\n    a2 = TreeNode(1)\n    b2 = TreeNode(3)\n    c2 = TreeNode(5)\n\n    a2.left, a2.right = b2, c2\n\n    print(s.flipEquiv(a2))\n\n    # Test case 3\n    a3 = TreeNode(1)\n    b3 = TreeNode(2)\n\n    a3.left, a3.right = None, b3\n\n    print(s.flipEquiv(a3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "972": "```\ndef rationalEqual(num1, num2):\n    if num1 == '0/1' or num2 == '0/1':\n        return num1 == num2\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    \n    n1, d1 = map(int, num1.split('/'))\n    n2, d2 = map(int, num2.split('/'))\n\n    if gcd(n1, d1) != 1 or gcd(n2, d2) != 1:\n        return False\n\n    if lcm(d1, d2) % (n1*d2) != 0:\n        return False\n    \n    return True\n\ndef main():\n    print(rationalEqual(\"2/3\", \"4/6\")) \n    print(rationalEqual(\"2/4\", \"3/5\"))\n    print(rationalEqual(\"3/9\", \"1/3\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "973": "```\nimport heapq\ndef kClosest(points, K):\n    return sorted(points, key=lambda x: x[0]**2 + x[1]**2)[:K]\n\ndef main():\n    print(kClosest([[1,2],[2,3],[3,4],[7,8]], 3))\n    print(kClosest([[5,6],[6,7],[10,11},{12,13}], 4))\n    print(kClosest([[-5,4],[-3,2],[1,5],[2,-4]], 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "974": "```\ndef subarraySumsDivByK(nums, k):\n    ans = 0\n    preSum = {0:1}\n    curSum = 0\n    for num in nums:\n        curSum += num\n        if (curSum % k) in preSum:\n            ans += preSum[(curSum % k)]\n        else:\n            preSum[curSum % k] = preSum.get(curSum % k, 0) + 1\n    return ans\n\ndef main():\n    print(subarraySumsDivByK([4,5,0,-2,-3,1], 5)) # Expected: 7\n    print(subarraySumsDivByK([-1,2,10,-5,8,-2], 10)) # Expected: 9\n    print(subarraySumsDivByK([18,48,65,97,89,-23,-6,54,31,4,5], 3) ) # Expected: 25\n\nmain()\n```",
  "975": "```\ndef oddEvenJump(n, depth):\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        jump_to_even = min((j for j in range(i) if i % 2 == 0 and abs(i - 2 * j) <= depth)), default=None\n        jump_to_odd = min((j for j in range(i) if i % 2 != 0 and abs(i - 2 * j + 1) <= depth)), default=None\n        dp[i] = max(dp[j] for j in (jump_to_even, jump_to_odd) if j is not None)\n    return max(dp)\n\ndef main():\n    print(oddEvenJump(5, 3))   # Output: 3\n    print(oddEvenJump(3, 1))   # Output: 2\n    print(oddEvenJump(10, 2))  # Output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "976": "```\ndef largestPerimeter(nums):\n    nums.sort(reverse=True)\n    for i in range(len(nums)-2):\n        if nums[i] < nums[i+1] + nums[i+2]:\n            return nums[i] + nums[i+1] + nums[i+2]\n    return 0\n\n\ndef main():\n    print(largestPerimeter([3, 2, 7, 4]))  # Expected output: 8\n    print(largestPerimeter([1, 2, 3]))  # Expected output: 6\n    print(largestPerimeter([10, 2, 5, 8]))  # Expected output: 17\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "977": "```\ndef sortedSquares(A):\n    return [i * i for i in A]\n\ndef main():\n    print(\"Test case 1:\")\n    assert sortedSquares([-4,-1,0,3,10]) == [0,1,9,16,100], f\"Expected {sortedSquares([-4,-1,0,3,10])} but got {sortedSquares([-4,-1,0,3,10])}\"\n    print(\"Test case 2:\")\n    assert sortedSquares([-7,-3,2,3,11]) == [4,9,9,49,121], f\"Expected {sortedSquares([-7,-3,2,3,11])} but got {sortedSquares([-7,-3,2,3,11])}\"\n    print(\"Test case 3:\")\n    assert sortedSquares([1]) == [1], f\"Expected {sortedSquares([1])} but got {sortedSquares([1])}\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "978": "```\ndef longestTurbulentSubarray(nums):\n    if not nums:\n        return 0\n\n    res = 0\n    last_diff = None\n    for i in range(1, len(nums)):\n        diff = (nums[i] - nums[i-1]) * (i-last_diff-2) if last_diff is not None else (nums[i] - nums[i-1])\n        if diff > 0 or diff < 0:\n            res = max(res, i-last_diff)\n        last_diff = diff\n    return res\n\ndef main():\n    print(longestTurbulentSubarray([9, 4, 7, 2, 10])) # expected output: 5\n    print(longestTurbulentSubarray([9, 6, 8, 7, 3, 0, 1])) # expected output: 5\n    print(longestTurbulentSubarray([4, 7, 6, 2, 3, 1, 0, 5])) # expected output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "979": "```\nclass Solution:\n    def distributeCoins(self, root):\n        pass\n\n\ndef main():\n    sol = Solution()\n\n    # Test case 1\n    node1 = TreeNode(1)\n    node2 = TreeNode(0)\n    node3 = TreeNode(0)\n    node4 = TreeNode(2)\n    node5 = TreeNode(0)\n    node6 = TreeNode(0)\n    node7 = TreeNode(1)\n    node8 = TreeNode(0)\n    node9 = TreeNode(1)\n\n    node1.left, node1.right = node2, node3\n    node2.right = node4\n    node3.right = node5\n    node4.left, node4.right = node6, node7\n    node7.right = node8\n    node8.right = node9\n\n    print(sol.distributeCoins(node1))  # Expected output: 4\n\n    # Test case 2\n    node10 = TreeNode(0)\n    node11 = TreeNode(1)\n\n    node10.left, node10.right = node11, None\n\n    print(sol.distributeCoins(node10))  # Expected output: 2\n\n    # Test case 3\n    node12 = TreeNode(1)\n    node13 = TreeNode(-1)\n\n    node12.left, node12.right = node13, None\n\n    print(sol.distributeCoins(node12))  # Expected output: 0\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == '__main__':\n    main()\n```",
  "980": "```\ndef uniquePathsIII(grid):\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = [[False]*n for _ in range(m)]\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n:\n            return float('inf')\n        if grid[i][j] == 1 and not visited[i][j]:\n            return 0\n        if grid[i][j] == -1:\n            return float('-inf')\n        visited[i][j] = True\n        min_path = float('inf')\n        for d in directions:\n            ni, nj = i + d[0], j + d[1]\n            if dfs(ni, nj) > 0 and grid[ni][nj] == 0:\n                min_path = min(min_path, dfs(ni, nj))\n        visited[i][j] = False\n        return min_path + 1\n\n    return -dfs(0, 0)\n\ndef main():\n    print(uniquePathsIII([[0,0,0],[0,1,0],[0,1,0]])) # Test case 1: Output 2\n    print(uniquePathsIII([[0,1],[0,0]])) # Test case 2: Output 1\n    print(uniquePathsIII([[0,0,0,0,0],[0,1,0,0,0],[0,0,-1,0,2]]) ) # Test case 3: Output 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "981": "```\nclass TimeMap:\n\n    def __init__(self):\n        self.data = {}\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.data or timestamp > self.data[key]:\n            self.data[key] = timestamp\n        elif timestamp == self.data[key]:\n            self.data[key] += 1\n\n    def get(self, key: str, timestamp: int) -> str:\n        if key not in self.data or self.data[key] <= timestamp:\n            return \"\"\n        start, end = 0, len(self.data[key]) - 1\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.data[key][mid] <= timestamp:\n                start = mid\n            else:\n                end = mid\n        return self.data[key][start:end+1]\n\n\ndef main():\n    obj = TimeMap()\n    print(obj.set(\"foo\",\"bar\",1))\n    print(obj.set(\"foo\",\"baz\",4))\n    print(obj.get(\"foo\",3)) # \"bar\"\n    print(obj.get(\"foo\",4)) # \"baz\"\n    print(obj.get(\"foo\",5)) # \"baz\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "982": "```\ndef countGoodTriplets(root):\n    ...\n\ndef main():\n    root = TreeNode(1)\n    root.left = TreeNode(0)\n    root.right = TreeNode(0)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(0)\n    root.left.right.left = TreeNode(0)\n    root.left.right.right = TreeNode(1)\n\n    print(countGoodTriplets(root))  # Expected: 2\n\n    root = TreeNode(5)\n    root.left = TreeNode(4)\n    root.right = TreeNode(7)\n    root.left.left = TreeNode(0)\n    root.left.right = TreeNode(9)\n    root.right.left = TreeNode(8)\n    root.right.right = TreeNode(2)\n\n    print(countGoodTriplets(root))  # Expected: 4\n\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    print(countGoodTriplets(root))  # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "983": "```\ndef mincosttickets(costs):\n    n = len(costs)\n    dp = [[0] * (n + 1) for _ in range(3)]\n\n    for i in range(n):\n        for j in range(1, 4):\n            if i == 0:\n                dp[j][i] = costs[i]\n            else:\n                dp[j][i] = min(dp[k][i - 1] + costs[i] for k in range(j)) or dp[j][i-1]\n\n    return dp[3][-1]\n\ndef main():\n    print(mincosttickets([8,13,1,12]))\n    print(mincosttickets([7,6,5,4,3,2,1]))\n    print(mincosttickets([14,11,10,9,8,7,6,5,4,3]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "984": "```\ndef CamelMatch(s):\n    return ''.join(c for c in s if (c.lower() == 'a' or c.lower() == 'b') <= 2)\n\ndef main():\n    print(CamelMatch(\"bba\") == \"\")\n    print(CamelMatch(\"abccba\") == \"a\")\n    print(CamelMatch(\"cbacdccbb\") == \"\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "985": "```\ndef sumEvenAfterQueries(nums, queries):\n    even_sum = sum(x for x in nums if x % 2 == 0)\n    results = []\n    for val, idx in queries:\n        nums[idx] += val\n        new_even_sum = sum(x for x in nums if x % 2 == 0)\n        results.append(new_even_sum - even_sum)\n        even_sum = new_even_sum\n    return results\n\n\ndef main():\n    # Test case 1\n    print(sumEvenAfterQueries([1, 2, 3, 4], [[1, 0], [-3, 1], [2, 1]]))\n    \n    # Test case 2\n    print(sumEvenAfterQueries([1, 2, 3, 4], [[1, 0], [-4, 0], [5, 0]]))\n    \n    # Test case 3\n    print(sumEvenAfterQueries([0, -1, 0, 10, -10, 10], [[5, 0], [-3, 2], [3, 1]]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "986": "```\ndef intervalIntersection(intervals1, intervals2):\n    result = []\n    i1, i2 = 0, 0\n    while i1 < len(intervals1) and i2 < len(intervals2):\n        left1, right1 = intervals1[i1]\n        left2, right2 = intervals2[i2]\n        \n        if left1 <= right2 and left2 <= right1:\n            result.append([max(left1, left2), min(right1, right2)])\n            \n        if right1 < right2:\n            i1 += 1\n        elif right2 < right1:\n            i2 += 1\n        else:\n            i1 += 1\n            i2 += 1\n            \n    return result\n\ndef main():\n    print(intervalIntersection([[0, 2], [5, 10]], [[1, 5], [8, 22]])) \n    print(intervalIntersection([[1,3],[5,7],[9,12]], [[2,6],[8,10],[15,18]]))\n    print(intervalIntersection([[1,4], [4,5]], [[1,3]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "987": "```\ndef verticalOrder(root):\n    if not root:\n        return []\n\n    order = {}\n    max_col = min_col = 0\n    queue = [(root, 0)]\n\n    while queue:\n        node, col = queue.pop(0)\n        if node:\n            max_col = max(max_col, col)\n            min_col = min(min_col, col)\n\n            if col not in order:\n                order[col] = []\n            order[col].append(node.val)\n\n            queue.append((node.left, col - 1))\n            queue.append((node.right, col + 1))\n\n    res = []\n    for col in range(min_col, max_col + 1):\n        row = [max(order[i]) for i in range(col, len(order) + 1)]\n        while row and not row[0]:\n            del row[0]\n        res.append(row)\n\n    return res\n\ndef main():\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    # Test case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(9)\n    root1.right = TreeNode(20)\n    root1.right.left = TreeNode(15)\n    root1.right.right = TreeNode(7)\n    print(verticalOrder(root1))\n\n    # Test case 2\n    root2 = TreeNode(4)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(6)\n    root2.right.left = TreeNode(5)\n    root2.right.right = TreeNode(8)\n    print(verticalOrder(root2))\n\n    # Test case 3\n    root3 = TreeNode(1)\n    root3.left = TreeNode(4)\n    root3.left.left = TreeNode(3)\n    root3.left.right = TreeNode(6)\n    root3.right = TreeNode(2)\n    root3.right.right = TreeNode(5)\n    print(verticalOrder(root3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "988": "```\ndef minStartValue(root):\n    def dfs(node):\n        if not node:\n            return 0\n        res = 1\n        for child in node.children:\n            res *= dfs(child)\n        return str(res) if node.val == '1' else ''\n\n    def dfs2(node, path):\n        if not node:\n            return ''\n        if not node.left and not node.right:\n            return path + str(node.val)\n        left = dfs2(node.left, path + str(node.val))\n        right = dfs2(node.right, path + str(node.val))\n        return min(left, right) if both or (left and right) else ''\n\n    def dfs3(root):\n        res = ''\n        stack = [(root, '')]\n        while stack:\n            node, path = stack.pop()\n            for child in node.children:\n                if not child.left and not child.right:\n                    res = min(res, path + str(child.val))\n                else:\n                    stack.append((child, path + str(child.val)))\n        return res\n\n    def dfs4(node):\n        if not node:\n            return 0\n        if not node.left and not node.right:\n            return ord(node.val) - 48\n        return min(ord(node.val) - 48, dfs2(node.left), dfs2(node.right))\n\n    # Test cases\n    root1 = TreeNode(1)\n    root1.left = TreeNode(3)\n    root1.right = TreeNode(4)\n    print(minStartValue(root1))  # expected output: \"13\"\n\n    root2 = TreeNode(0)\n    root2.left = TreeNode(1)\n    root2.right = TreeNode(5)\n    root2.left.left = TreeNode(6)\n    root2.left.right = TreeNode(7)\n    print(minStartValue(root2))  # expected output: \"107\"\n\n    root3 = TreeNode(6)\n    root3.left = TreeNode(4)\n    root3.right = TreeNode(8)\n    root3.left.left = TreeNode(1)\n    root3.left.right = TreeNode(5)\n    root3.right.left = TreeNode(7)\n    root3.right.right = TreeNode(9)\n    print(minStartValue(root3))  # expected output: \"615\"\n```",
  "989": "```\ndef addToArrayForm(num, k):\n    for i in range(len(num)):\n        num[i] += k\n        k = num[i] // 10\n        num[i] %= 10\n    while k:\n        num.append(k % 10)\n        k //= 10\n    return num\n\ndef main():\n    print(addToArrayForm([1,2,3], 456)) # [604]\n    print(addToArrayForm([2,7,11,14], 23) ) # [4,4,3,5]\n    print(addToArrayForm([9,9], 1) ) # [1,0,0]\n\nmain()\n```",
  "990": "```\ndef equationsPossible(equations):\n    parent = {}\n    for eq in equations:\n        a, b = eq[0], eq[3]\n        if a not in parent:\n            parent[a] = a\n        if b not in parent:\n            parent[b] = b\n        if eq[1] == '!':\n            root_a = find(a, parent)\n            root_b = find(b, parent)\n            if root_a != root_b:\n                parent[root_a] = root_b\n        else:\n            union(a, b, parent)\n\n    return [eq[0] + eq[3] for eq in equations].count('!')\n\ndef find(x, parent):\n    if parent[x] != x:\n        parent[x] = find(parent[x], parent)\n    return parent[x]\n\ndef union(x, y, parent):\n    root_x = find(x, parent)\n    root_y = find(y, parent)\n    if root_x != root_y:\n        parent[root_x] = root_y\n\ndef main():\n    equations1 = [\"a==b\",\"b!=c\",\"ab!=ac\"]\n    print(equationsPossible(equations1))  # Output: false\n\n    equations2 = [\"a==b\",\"b==c\"]\n    print(equationsPossible(equations2))  # Output: true\n\n    equations3 = [\"a!=b\",\"b!=c\",\"ab!=ac\"]\n    print(equationsPossible(equations3))  # Output: false\n\nif __name__ == \"__main__\":\n    main()\n```",
  "991": "```\ndef maxResult(nums, k):\n    n = len(nums)\n    dp = [0] * (n + 1)\n    dp[0] = nums[0]\n    for i in range(1, n):\n        dp[i] = max(dp[max(0, i - k)] + nums[i], nums[i])\n    return dp[-1]\n\ndef main():\n    test_case1 = [2, 7, 11, 5]\n    print(\"Test case 1:\", maxResult(test_case1, 4))  # Expected output: 18\n\n    test_case2 = [10, 2]\n    print(\"Test case 2:\", maxResult(test_case2, 2))  # Expected output: 9\n\n    test_case3 = [5, -1, 7, -9]\n    print(\"Test case 3:\", maxResult(test_case3, 4))  # Expected output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "992": "```\ndef subarraysWithKDistinct(A, K):\n    if not A:\n        return 0\n    \n    n = len(A)\n    left = right = 0\n    max_len = 0\n    window = set()\n    \n    while right < n:\n        while len(window) > K and left <= right:\n            window.remove(A[left])\n            left += 1\n        \n        if len(window) == K:\n            max_len = max(max_len, right - left + 1)\n        \n        right += 1\n    \n    return max_len\n\ndef main():\n    print(subarraysWithKDistinct([1,2,1,3,4], 3))  # Output: 5\n    print(subarraysWithKDistinct([1,4,4,2,3,2,4,3], 3))  # Output: 9\n    print(subarraysWithKDistinct([1,1,1,3], 1))  # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "993": "```\nclass Solution:\n    def findFirstCommonAncestor(self, root, p, q):\n        if not root:\n            return None\n        if root.val == p.val or root.val == q.val:\n            return root\n        left = self.findFirstCommonAncestor(root.left, p, q)\n        right = self.findFirstCommonAncestor(root.right, p, q)\n        if left and right:\n            return root\n        return left if left else right\n\n    def isCousins(self, root, x, y):\n        if not root:\n            return False\n        left = root.left\n        right = root.right\n        if (left and left.val == x) ^ (right and right.val == y):\n            return True\n        if (left and left.val == y) ^ (right and right.val == x):\n            return True\n        if left and left.val in [x, y] or right and right.val in [x, y]:\n            return False\n        return self.isCousins(left, x, y) or self.isCousins(right, x, y)\n\n    def main():\n        solution = Solution()\n        \n        # Test case 1:\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        print(solution.isCousins(root, 4, 5))  # Expected output: True\n\n        # Test case 2:\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        print(solution.isCousins(root, 2, 3))  # Expected output: False\n\n        # Test case 3:\n        root = TreeNode(1)\n        root.left = TreeNode(2)\n        root.right = TreeNode(3)\n        root.left.left = TreeNode(4)\n        root.left.right = TreeNode(5)\n        root.left.left.left = TreeNode(6)\n        root.left.left.right = TreeNode(7)\n        print(solution.isCousins(root, 6, 7))  # Expected output: True\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "994": "```\nfrom collections import deque\n\ndef minHoursToRot(m):\n    directions = [(0,1), (0,-1), (1,0), (-1,0)]\n    queue = deque()\n    for i in range(len(m)):\n        for j in range(len(m[0])):\n            if m[i][j] == 2:\n                queue.append((i,j))\n    minutes = -1\n    while queue:\n        minutes += 1\n        for _ in range(len(queue)):\n            x, y = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if (0 <= nx < len(m)) and (0 <= ny < len(m[0])) and m[nx][ny] == 1:\n                    m[nx][ny] = 2\n                    queue.append((nx,ny))\n    for i in range(len(m)):\n        for j in range(len(m[0])):\n            if m[i][j] == 1:\n                return -1\n    return minutes\n\ndef main():\n    print(minHoursToRot([[2,1,1],[1,1,0],[0,1,1]]))\n    print(minHoursToRot([[0,1,5],[7,3,0],[0,5,6]]))\n    print(minHoursToRot([[2,0]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "995": "```\ndef minKBitFlips(bits):\n    n = len(bits)\n    res = []\n    for i in range(n):\n        if (i & 1) == bits[i]:\n            continue\n        k, j = i, i+1\n        while j < n and (j & 1) != bits[j]:\n            j += 1\n        res.append(i + (j - i)//2)\n    return len(res)\n\ndef main():\n    print(minKBitFlips([0,1,0])) # Expected: 3\n    print(minKBitFlips([0,0,1,1,0,1,1,0]) ) # Expected: 4\n    print(minKBitFlips([0,0,0,1,0,0,1,1]) ) # Expected: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "996": "```\ndef numSquarefulPerms(A):\n    def isSquare(i):\n        j = int(i**0.5)\n        return j*j == i\n\n    B = sorted((x, i) for i, x in enumerate(A))\n    n = len(B)\n    ans = 1\n    used = [0]*n\n\n    def dfs(i):\n        if i == n:\n            ans += 1\n            return\n        seen = set()\n        for j in range(n):\n            if not used[j]:\n                k = B[j][0]\n                if (k*k) in seen or isSquare(k):\n                    continue\n                seen.add(k*k)\n                used[j] = 1\n                dfs(i+1)\n                used[j] = 0\n\n    dfs(0)\n    return ans\n\ndef main():\n    print(numSquarefulPerms([17,22])) #2\n    print(numSquarefulPerms([10,12])) #6\n    print(numSquarefulPerms([3,5,4,2])) #7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "997": "```\ndef findJudge(n, trust):\n    trusts = [0] * (n + 1)\n    trusted = [0] * (n + 1)\n\n    for t in trust:\n        trusts[t[0]] += 1\n        trusted[t[1]] += 1\n\n    judge = None\n    for i in range(1, n + 1):\n        if trusts[i] == 0 and trusted[i] == n - 1:\n            judge = i\n            break\n\n    return judge\n\n\ndef main():\n    print(findJudge(2, [[1, 2]])) # Expect: 2\n    print(findJudge(3, [[1, 3], [2, 3]])) # Expect: 3\n    print(findJudge(4, [[1, 2], [2, 3], [3, 4]])) # Expect: 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "998": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef insertIntoMaxTree(root: TreeNode, val: int) -> TreeNode:\n    if not root:\n        return TreeNode(val)\n    if val > root.val:\n        root.right = insertIntoMaxTree(root.right, val)\n    else:\n        root.left = insertIntoMaxTree(root.left, val)\n    return root\n\ndef maxGain(root):\n    if not root:\n        return 0\n    left_gain = maxGain(root.left) if root.left else 0\n    right_gain = maxGain(root.right) if root.right else 0\n    price_newpath = root.val + left_gain + right_gain\n    price_drop_left = price_newpath - (left_gain + root.val)\n    price_drop_right = price_newpath - (right_gain + root.val)\n    return max(price_newpath, price_drop_left, price_drop_right)\n\ndef maximumUniqueSubarray(nums):\n    if not nums:\n        return 0\n    res = [1] * len(nums)\n    for i in range(1, len(nums)):\n        res[i] = max(res[i-1], nums[i])\n    return max(res)\n\n\ndef main():\n    # Test case 1:\n    root = TreeNode(3)\n    insertIntoMaxTree(root, 2)\n    insertIntoMaxTree(root, 1)\n    print(maxGain(root))  # Expected output: 4\n\n    # Test case 2:\n    root = None\n    insertIntoMaxTree(root, 5)\n    insertIntoMaxTree(root, 3)\n    insertIntoMaxTree(root, 2)\n    print(maxGain(root))  # Expected output: 6\n\n    # Test case 3:\n    root = TreeNode(4)\n    insertIntoMaxTree(root, 1)\n    print(maxGain(root))  # Expected output: 5\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "999": "```\ndef numRookCaptures(board):\n    rows = len(board)\n    cols = len(board[0])\n    rook_row = -1\n    rook_col = -1\n    captures = 0\n    \n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 'R':\n                rook_row, rook_col = i, j\n                break\n        if rook_row != -1:\n            break\n            \n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    for d in directions:\n        new_row, new_col = rook_row + d[0], rook_col + d[1]\n        \n        while 0 <= new_row < rows and 0 <= new_col < cols:\n            if board[new_row][new_col] == 'p':\n                captures += 1\n                break\n            elif board[new_row][new_col] == 'B':\n                break\n            new_row += d[0]\n            new_col += d[1]\n\n    return captures\n\ndef main():\n    board1 = [[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],\n             [\".\",\"K\",\".\",\" \",\"p\",\" \",\" \",\".\"],\n             [\".\",\"p\",\" \",\" \",\"R\",\" \",\" \",\".\"],\n             [\".\",\".\",\".\",\"p\",\" \",\" \",\".\",\".\"],\n             [\".\",\".\",\".\",\" \",\" \",\"B\",\" \",\".\"],\n             [\".\",\" \",\".\",\" \",\" \",\" \",\"K\",\".\"]\n    print(numRookCaptures(board1))  # Output: 3\n\n    board2 = [[\".','.','.','.','.','.','.','.\"],\n              [\".\",\"K\",\".\",\" \",\"p\",\" \",\" \",\".\"],\n              [\".\",\"p\",\" \",\" \",\"R\",\" \",\" \",\".\"],\n              [\".\",\".\",\".\",\"p\",\" \",\" \",\".\",\".\"],\n              [\".\",\".\",\".\",\" \",\" \",\"B\",\" \",\".\"],\n              [\".\",\" \",\".\",\" \",\" \",\" \",\"K\",\".\"]]\n    print(numRookCaptures(board2))  # Output: 4\n\n    board3 = [[\".','.','.','.','.','.','.','.\"],\n              [\".\",\"K\",\".\",\" \",\"p\",\" \",\" \",\".\"],\n              [\".\",\"p\",\" \",\" \",\"R\",\" \",\" \",\".\"],\n              [\".\",\".\",\".\",\"p\",\" \",\" \",\".\",\".\"],\n              [\".\",\".\",\".\",\" \",\" \",\"B\",\" \",\".\"],\n              [\".\",\" \",\".\",\" \",\" \",\" \",\"K\",\".\"]]\n    print(numRookCaptures(board3))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1000": "```\ndef minStoneSum(piles, k):\n    piles.sort()\n    total = sum(piles)\n    dp = [[0, []] for _ in range(total + 1)]\n    for pile in piles:\n        for i in range(total, pile - 1, -1):\n            if not dp[i][1]:\n                dp[i][0] = dp[i - pile][0] + pile\n                dp[i][1] = [pile]\n            else:\n                temp = dp[i][0]\n                new_dp = [i - pile]\n                while len(dp[i - pile][1]):\n                    new_dp.append(dp[i - pile].pop())\n                new_dp.extend(dp[i][1])\n                i -= 1\n                while i > 0 and not dp[i][1]:\n                    if temp < dp[i][0] + pile:\n                        dp[i][0] = temp + pile\n                        dp[i][1] = new_dp + [pile]\n                    i -= 1\n    return dp[total][0]\n\ndef main():\n    test_cases = [\n        {\"piles\": [5], \"k\": 0, \"expected\": 0},\n        {\"piles\": [3,5], \"k\": 2, \"expected\": 9},\n        {\"piles\": [1,2,4,10], \"k\": 3, \"expected\": 7}\n    ]\n\n    for test_case in test_cases:\n        result = minStoneSum(test_case[\"piles\"], test_case[\"k\"])\n        if result == test_case[\"expected\"]:\n            print(f\"Test case {test_case} passed\")\n        else:\n            print(f\"Test case {test_case} failed. Expected: {test_case['expected']}, Got: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1001": "```\ndef gridIllumination(grid, queries):\n    rows = [0] * len(grid)\n    cols = [0]\n    for r in range(len(grid)):\n        for c in range(len(grid[0])):\n            if grid[r][c] == 1:\n                rows[r] += 1\n                cols[0].append(c)\n    res = []\n    seen = set()\n    for r, q in queries:\n        if rows[r] > 0 and q not in seen:\n            res.append(r + 1)\n            seen.add(q)\n            while cols[0]:\n                c = cols[0].pop(0)\n                rows[c // len(grid)] -= 1\n                if rows[c // len(grid)] == 0:\n                    del cols[0]\n    return res\n\ndef main():\n    grid = [[0,0,0],[0,1,0],[0,0,0]]\n    queries = [[1,1],[2,3],[4,3]]\n    print(gridIllumination(grid, queries))\n\n    grid = [[0,0,1],[0,1,1],[1,0,0]]\n    queries = [[1,4],[0,3],[1,1]]\n    print(gridIllumination(grid, queries))\n\n    grid = [[0,0,0,0],[1,0,1,1],[0,1,0,0],[0,0,0,1]]\n    queries = [[3,2],[1,4]]\n    print(gridIllumination(grid, queries))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1002": "```\ndef commonChars(A):\n    ans = []\n    for c in set(''.join(A)):\n        count = min(a.count(c) for a in A)\n        ans.extend([c] * count)\n    return [''.join(sorted(ans))]\n\ndef main():\n    print(commonChars([\"cool\", \"lock\", \"cook\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1003": "```\ndef validWordPartPartition(word: str) -> bool:\n    n = len(word)\n    for length in range(1, n // 2 + 1):\n        if n % length == 0:\n            first_half = word[:length]\n            second_half = word[length:]\n            if all(c1 == c2 or (c1 == 'a' and c2 == 'b') or (c1 == 'b' and c2 == 'a') for c1, c2 in zip(first_half, second_half)):\n                return True\n    return False\n\n\ndef main():\n    print(validWordPartPartition(\"aab\") == True)\n    print(validWordPartPartition(\"aaabaab\") == True)\n    print(validWordPartPartition(\"caaazzbba Jouuueeee thudsiiigee\") == True)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1004": "```\ndef longestOnes(nums):\n    n = len(nums)\n    i, j = 0, 0\n    max_len = 0\n    while j < n:\n        if nums[j] == 1:\n            j += 1\n        else:\n            if nums[i] == 1:\n                i += 1\n            else:\n                if i + 1 <= j:\n                    max_len = max(max_len, j - i)\n                i += 1\n    return max_len\n\ndef main():\n    print(longestOnes([1,0,1,1,0])) # Expected: 3\n    print(longestOnes([1,1,0,1,0,1,1])) # Expected: 6\n    print(longestOnes([0,1,1,1,0,1,1])) # Expected: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1005": "```\ndef maximumSumOfArray(nums, k):\n    for _ in range(k):\n        nums[:] = [i if i >= 0 else -i for i in reversed(nums)]\n    return sum(nums)\n\ndef main():\n    print(maximumSumOfArray([-4,-3], 2)) # Expected output: 5\n    print(maximumSumOfArray([0,2,-1], 3)) # Expected output: 6\n    print(maximumSumOfArray([3,-1,0,2], 3)) # Expected output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1006": "```\ndef clumsyFactorial(N):\n    res = N\n    for i in range(1, N // 5 + 1):\n        if N % (5 * i) == 0:\n            res *= i\n            N //= i\n        else:\n            break\n    return res\n\ndef main():\n    print(clumsyFactorial(4)) # Test case 1: Expected output = 24\n    print(clumsyFactorial(10)) # Test case 2: Expected output = 45\n    print(clumsyFactorial(25)) # Test case 3: Expected output = 750\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1007": "```\ndef minDominoRotations(A):\n    n = len(A)\n    res = [0] * n\n    for i in range(n):\n        dominos = set([A[i], A[n-i-1]])\n        if A[i] == A[n-i-1]:\n            res[i] = 0\n        else:\n            res[i] = 2 if len(dominos) > 1 else (A[i] != A[n-i-1])\n    return sum(res)\n\ndef main():\n    print(minDominoRotations([2,1,2,4,2,2]))\n    print(minDominoRotations([3,5,1,4,5,6]))\n    print(minDominoRotations([1,2]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1008": "```\ndef bstFromPreorder(pre):\n    if not pre:\n        return None\n    \n    root = TreeNode(pre[0])\n    node = root\n    stack = [root]\n    \n    i = 1\n    while i < len(pre):\n        if pre[i] < node.val:\n            node.right = TreeNode(pre[i])\n            node = node.right\n            stack.append(node)\n        else:\n            while stack and stack[-1].val > pre[i]:\n                node = stack.pop()\n            node.left = TreeNode(pre[i])\n            node = node.left\n    \n        i += 1\n    \n    return root\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        if not left:\n            self.left = None\n        self.right = right\n        if not right:\n            self.right = None\n\ndef main():\n    preorder1 = [8,5,4,11,3,6,7,2]\n    preorder2 = [3,9,20,15,7]\n    preorder3 = [0, 1]\n\n    print(\"Test Case 1:\")\n    root1 = bstFromPreorder(preorder1)\n    inOrder(root1)  # Output: 4,5,8,11,2,6,7,3\n    print(\"\\nTest Case 2:\")\n    root2 = bstFromPreorder(preorder2)\n    inOrder(root2)  # Output: 3,7,15,20,9\n    print(\"\\nTest Case 3:\")\n    root3 = bstFromPreorder(preorder3)\n    inOrder(root3)  # Output: 0,1\n\ndef inOrder(node):\n    if node:\n        inOrder(node.left)\n        print(str(node.val), end=' ')\n        inOrder(node.right)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1009": "```\ndef findComplement(n):\n    return ~n\n\ndef main():\n    print(\"Test Case 1: \", findComplement(5)) \n    # Expected Output: 2\n    print(\"Test Case 2: \", findComplement(10)) \n    # Expected Output: 0\n    print(\"Test Case 3: \", findComplement(256)) \n    # Expected Output: 127\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1011": "```\ndef max_weight(weights):\n    weights.sort()\n    left = 0\n    right = sum(weights)\n    while left <= right:\n        mid = (left + right) // 2\n        remaining = mid\n        for weight in weights:\n            if remaining >= weight:\n                remaining -= weight\n            else:\n                break\n        if remaining == 0:\n            return mid\n        elif remaining > 0:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n\ndef main():\n    print(max_weight([2,1,3])) \n    print(max_weight([2,4,2])) \n    print(max_weight([4,5,6,7]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1010": "```\ndef numPairsDivisibleBy60(time):\n    count = [0] * 60\n    for t in time:\n        count[t % 60] += 1\n    res = 0\n    for i in range(30):\n        res += count[i] * count[59 - i]\n    if count[30] > 1:\n        res += count[30] // 2 * 2\n    return res\n\ndef main():\n    print(numPairsDivisibleBy60([30,20,150,100,40])) # Expected: 3\n    print(numPairsDivisibleBy60([60,60,60])) # Expected: 3\n    print(numPairsDivisibleBy60([10,20,60,60])) # Expected: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1012": "```\ndef numDupDigitsAtMostN(n):\n    res = set()\n    for i in range(1, 10):\n        seen = [0] * 10\n        k = 1\n        while k <= n and i <= n:\n            if seen[int(str(i)[k-1])] == 1:\n                break\n            k += 1\n        while k <= n:\n            for j in range(0, 10):\n                if seen[j] == 0:\n                    new_num = i * 10 + j\n                    if new_num > n:\n                        res.update(set(str(i) + str(j)[1:]))\n                    seen[j] = 1\n                    k += 1\n            break\n    return len(res)\n\ndef main():\n    print(numDupDigitsAtMostN(100)) \n    print(numDupDigitsAtMostN(50))\n    print(numDupDigitsAtMostN(200))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1013": "```\ndef canThreePartsEqualSum(arr):\n    total_sum = sum(arr)\n    if total_sum % 3 != 0:\n        return False\n    target_sum = total_sum // 3\n    parts_count = 0\n    current_sum = 0\n    for num in arr:\n        current_sum += num\n        if current_sum == target_sum:\n            parts_count += 1\n            current_sum = 0\n    return parts_count >= 3\n\ndef main():\n    print(canThreePartsEqualSum([0,2,2,2,5,10,4,2])) # True\n    print(canThreePartsEqualSum([30,20,150,10,90]) # False)\n    print(canThreePartsEqualSum([1, 2, 3, 4, 5]) # True)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1015": "```\ndef subarraySum(nums, k):\n    res = float('inf')\n    curr_sum = 0\n    hashmap = {0: -1}\n    for i, num in enumerate(nums):\n        curr_sum += num\n        if curr_sum % k == 0:\n            res = min(res, i + 1)\n        elif curr_sum - k in hashmap:\n            res = min(res, i - hashmap[curr_sum - k])\n        else:\n            hashmap[curr_sum] = i\n    return res\n\ndef main():\n    print(subarraySum([4,5,0,2,3], 7)) \n    print(subarraySum([8,10,12,15,5], 6))\n    print(subarraySum([1], 3))\n\nmain()\n```",
  "1014": "```\ndef maxSightseeing(pair):\n    return pair[0] + pair[1]\n\ndef bestSightseeingPair(arr):\n    n = len(arr)\n    res = [arr[0], arr[0]]\n    for i in range(1, n-1):\n        if arr[i] - i + arr[n-1] - (n-1) > arr[res[0]] - 0 + arr[res[1]] - 1:\n            res = [i, n-1]\n    return res\n\ndef main():\n    print(bestSightseeingPair([8,2,5,3])) # Output: [6,2]\n    print(bestSightseeingPair([1,4,10,10,3]) # Output: [4,3]\n    print(bestSightseeingPair([7, 4 ,5, 6, 9, 7, 5, 11, 8]) # Output: [9, 7]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1016": "```\ndef prefixCount(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            substring = s[i:j]\n            if substring.isdigit() and int(substring) <= len(s.split('0')):\n                count += 1\n    return count\n\ndef main():\n    print(prefixCount(\"0110\")) # Test case 1\n    print(prefixCount(\"01\")) # Test case 2\n    print(prefixCount(\"1001\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1017": "```\ndef baseNeg2(N):\n    if N == 0:\n        return '0'\n    res = []\n    while N != 0:\n        r = abs(N) % (-2)\n        if r < -1:\n            N += 2\n            res.append('-1')\n        elif r > 0:\n            N -= 1\n            res.append('1')\n        else:\n            res.append('0')\n            N //= -2\n    return ''.join(map(str, reversed(res)))\n\ndef main():\n    print(baseNeg2(2))  # Test case 1: 2 = 10 in base -2\n    print(baseNeg2(5))   # Test case 2: 5 = 101 in base -2\n    print(baseNeg2(-9))  # Test case 3: -9 = 1111 in base -2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1018": "```\ndef prefixDivBy5(nums):\n    res = []\n    for n in nums:\n        res.append(n & 4)\n    return [i % 5 == 0 for i in res]\n\ndef main():\n    print(prefixDivBy5([0,1,1])) \n    print(prefixDivBy5([1,1,1]))\n    print(prefixDivBy5([0,1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1019": "```\ndef nextGreaterNode(head):\n    stack = [(head.val, head)]\n    result = {}\n    current = head\n    while current:\n        while stack and stack[-1][0] <= current.val:\n            prevVal, prevNode = stack.pop()\n        if stack:\n            result[prevNode] = stack[-1][0]\n        else:\n            result[current] = None\n        stack.append((current.val, current))\n        current = current.next\n\ndef main():\n    # Test Case 1\n    head1 = ListNode(2, ListNode(1, ListNode(5)))\n    print(nextGreaterNode(head1))  # Expected Output: [5]\n\n    # Test Case 2\n    head2 = ListNode(1)\n    print(nextGreaterNode(head2))  # Expected Output: None\n\n    # Test Case 3\n    head3 = ListNode(7, ListNode(4, ListNode(6, ListNode(5, ListNode(3, ListNode(9))))))\n    print(nextGreaterNode(head3))  # Expected Output: [7, 6, 6, 8, -1]\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1020": "```\ndef numEnclaves(grid):\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(i, j):\n        if i < 0 or j < 0 or i >= m or j >= n:\n            return False\n        if grid[i][j] == '0':\n            return True\n        grid[i][j] = '0'\n        for direction in directions:\n            dfs(i + direction[0], j + direction[1])\n        return False\n\n    res = 0\n    for i in range(m):\n        if i > 0 and grid[i][0] == '1':\n            break\n        for j in range(n):\n            if grid[i][j] == '1' and dfs(i, j):\n                res += 1\n    return res\n\ndef main():\n    test_cases = [\n        {\n            \"grid\": [\n                [\"1\",\"0\",\"1\",\"0\",\"0\"],\n                [\"1\",\"0\",\"1\",\"1\",\"1\"],\n                [\"1\",\"1\",\"1\",\"1\",\"1\"],\n                [\"1\",\"0\",\"0\",\"1\",\"0\"]\n            ],\n            \"expected_result\": 3\n        },\n        {\n            \"grid\": [\n                [\"0\",\"0\",\"0\",\"0\",\"0\"],\n                [\"1\",\"1\",\"1\",\"1\",\"1\"],\n                [\"1\",\"1\",\"1\",\"1\",\"1\"],\n                [\"1\",\"1\",\"1\",\"1\",\"1\"]\n            ],\n            \"expected_result\": 0\n        },\n        {\n            \"grid\": [\n                [\"1\",\"1\",\"1\",\"1\",\"0\"],\n                [\"1\",\"1\",\"1\",\"0\",\"0\"],\n                [\"1\",\"1\",\"1\",\"0\",\"0\"],\n                [\"1\",\"1\",\"1\",\"0\",\"0\"]\n            ],\n            \"expected_result\": 2\n        }\n    ]\n\n    for test_case in test_cases:\n        result = numEnclaves(test_case[\"grid\"])\n        if result == test_case[\"expected_result\"]:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1021": "```\ndef removeOuterParentheses(s: str) -> str:\n    res = \"\"\n    stack = []\n    for c in s[1:-1]:  # skip outermost parentheses\n        if not stack and c == '(':\n            stack.append(c)\n        elif stack and c == ')':\n            stack.pop()\n            if not stack:\n                res += ')'\n        else:\n            res += c\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                stack.append(c)\n    return \"(\" + res + \")\"\n\ndef main():\n    print(removeOuterParentheses(\"(()())(())\"))  # output: \"()()()\"\n    print(removeOuterParentheses(\"(a(b)(c))\"))  # output: \"ab(c)\"\n    print(removeOuterParentheses(\"\"))  # output: \"\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1022": "```\nclass Solution:\n    def sumRootToLeaf(self, root):\n        def dfs(node, path):\n            if not node:\n                return 0\n            path += str(node.val)\n            if not node.left and not node.right:\n                return int(path, 2)\n            return dfs(node.left, path) + dfs(node.right, path)\n\n    def main():\n        solution = Solution()\n        root1 = TreeNode(6)\n        root1.left = TreeNode(4)\n        root1.right = TreeNode(8);\n        root1.left.left = TreeNode(1);\n        root1.left.right = TreeNode(0);\n        root1.right.left = TreeNode(0);\n        root1.right.right = TreeNode(1);\n\n        print(solution.sumRootToLeaf(root1)) # Output: 15\n\n        root2 = TreeNode(10)\n        root2.left = TreeNode(5)\n        root2.right = TreeNode(15);\n        root2.left.left = TreeNode(3);\n        root2.left.right = TreeNode(2);\n        root2.right.left = TreeNode(0);\n        root2.right.right = TreeNode(1);\n\n        print(solution.sumRootToLeaf(root2)) # Output: 23\n\n        root3 = TreeNode(1)\n        root3.left = TreeNode(0);\n        root3.right = TreeNode(1);\n\n        print(solution.sumRootToLeaf(root3)) # Output: 5\n\n\nif __name__ == \"__main__\":\n    Solution.main()\n```",
  "1023": "```\ndef camelMatch(words, query):\n    result = []\n    for word in words:\n        i = j = 0\n        while i < len(word) and j < len(query):\n            if word[i].isalpha() != query[j].isalpha():\n                break\n            if not query[j].isalpha():\n                if word[i] != query[j]:\n                    break\n            i += 1\n            j += 1\n        if j == len(query) and (i == len(word) or not word[i:].isalpha()):\n            result.append(word)\n    return result\n\ndef main():\n    words = [\" FooBar\", \"FooBaAr\", \"FooandalBaAr\"]\n    query = \"FooBa\";\n    print(camelMatch(words, query))\n    \n    words = [\"Hello\",\"Alaska\",\"Dinosaur\",\"Aliveway\"]\n    query = \"Dino\";\n    print(camelMatch(words, query))\n    \n    words = [\"CamelCaseWarrior\", \"CameraCaseWarrior\"];\n    query = \"Camer\";\n    print(camelMatch(words, query))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1025": "```\ndef divisorGame(n):\n    return n % 2 == 0\n\n\ndef main():\n    print(divisorGame(1))  # Test case 1\n    print(divisorGame(4))  # Test case 2\n    print(divisorGame(3))  # Test case 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1024": "```\ndef findVideoStitching(clips):\n    n = len(clips)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    lastEnd = -1\n    for i in range(1, n):\n        for j in range(i):\n            if clips[j][1] >= clips[i][0]:\n                if dp[j][i-1]:\n                    if i == n - 1:\n                        return True\n                    dp[i][i+1] = 1\n                    lastEnd = i\n    return False\n\ndef main():\n    print(findVideoStitching([[0,2],[4,8],[10,12]])) # Expected output: True\n    print(findVideoStitching([[1,2],[6,3]])) # Expected output: False\n    print(findVideoStitching([[0,7],[6,14],[9,19]])) # Expected output: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1026": "```\nclass Solution:\n    def maxAncestorDiff(self, root):\n        if not root:\n            return 0\n        \n        res = float('-inf')\n        \n        def dfs(node, mn, mx):\n            nonlocal res\n            if not node:\n                return\n            \n            res = max(res, abs(node.val - mn), node.val - mx)\n            \n            mn = min(mn, node.val)\n            mx = max(mx, node.val)\n            \n            dfs(node.left, mn, mx)\n            dfs(node.right, mn, mx)\n        \n        dfs(root, root.val, root.val)\n        return res\n\ndef main():\n    solution = Solution()\n    \n    # Test case 1\n    node1 = TreeNode(8)\n    node2 = TreeNode(3)\n    node3 = TreeNode(6)\n    node4 = TreeNode(10)\n    node5 = TreeNode(4)\n    node6 = TreeNode(0.5)\n    node7 = TreeNode(7)\n    node8 = TreeNode(9)\n\n    node1.left = node2\n    node1.right = node3\n    node2.left = node4\n    node2.right = node5\n    node3.left = node6\n    node3.right = node7\n    node4.left = node8\n\n    print(solution.maxAncestorDiff(node1))  # Expected output: 10\n\n    # Test case 2\n    node1 = TreeNode(1)\n    node2 = TreeNode(4)\n    node3 = TreeNode(1)\n\n    node1.right = node2\n    node2.left = node3\n\n    print(solution.maxAncestorDiff(node1))  # Expected output: 3\n\n    # Test case 3\n    node1 = TreeNode(2)\n    node2 = TreeNode(2)\n\n    node1.right = node2\n\n    print(solution.maxAncestorDiff(node1))  # Expected output: 0\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        if not left:\n            self.left = None\n        self.right = right\n        if not right:\n            self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1027": "```\ndef longestArithSeqLength(arr):\n    n = len(arr)\n    if n <= 2:\n        return n\n    \n    memo = {}\n    max_length = 0\n    for i in range(n):\n        for j in range(i):\n            diff = arr[i] - arr[j]\n            curr_length = 2\n            while (j - curr_length) in memo and memo[j - curr_length][1] == diff:\n                curr_length += memo[j - curr_length][0] + 1\n            max_length = max(max_length, curr_length)\n            memo[i] = (curr_length, diff)\n            \n    return max_length\n\n\ndef main():\n    print(longestArithSeqLength([3,6,9,12])) # Expected output: 4\n    print(longestArithSeqLength([9,4,7,6,8,11,10])) # Expected output: 3\n    print(longestArithSeqLength([20,1,15]) ) # Expected output: 2\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1029": "```\ndef twoCityCost(costs):\n    costs.sort(key=lambda x:abs(x[0]-x[1]))\n    return sum(costs[i][0] for i in range(len(costs)//2)) + sum(costs[i][1] for i in range(len(costs)//2, len(costs)))\n\ndef main():\n    print(twoCityCost([[10,20],[30,40],[100,10]]))\n    print(twoCityCost([[1,5],[2,4]]))\n    print(twoCityCost([[5,7],[3,7],[9,8]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1028": "```\nclass Solution:\n    def recoverFromPreorder(self, S):\n        if not S:\n            return None\n        \n        class TreeNode:\n            def __init__(self, val=0, left=None, right=None):\n                self.val = val\n                self.left = left\n                self.right = right\n        \n        stack = []\n        prev = None\n        \n        for i in range(len(S)):\n            if S[i].isdigit():\n                j = i + 1\n                while j <= len(S) and S[j].isdigit():\n                    j += 1\n                val = int(S[i:j])\n                i = j - 1\n                \n                node = TreeNode(val)\n                \n                if prev is not None:\n                    if stack[-1][0] == prev[0]:\n                        stack[-1][1].right = node\n                    else:\n                        while len(stack) > 0 and stack[-1][0] < prev[0]:\n                            stack.pop()\n                        if len(stack) == 0 or stack[-1][0] != prev[0]:\n                            return None\n                        stack[-1][1].left = node\n                stack.append([prev[0], node])\n                prev = [val, node]\n            else:\n                if S[i] == '-':\n                    break\n        \n        while len(stack) > 1:\n            a, b = stack.pop()\n            c, d = stack.pop()\n            if a != c and (b.val < c.val or d.val < c.val):\n                return None\n            c.left = b\n            c.right = d\n        return prev[1]\n\ndef main():\n    sol = Solution()\n    \n    print(sol.recoverFromPreorder(\"1-2--3--4-5--6--7\"))\n    print(sol.recoverFromPreorder(\"1-2--3---4-5--6---7\")\n    print(sol.recoverFromPreorder(\"1\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1030": "```\ndef allCellsDistLessThanMatrix(mat):\n    res = []\n    for i in range(len(mat)):\n        for j in range(len(mat[0])):\n            res.append((i, j))\n    res.sort(key=lambda x: (abs(x[0]-x[1]), 1 if x[0] > x[1] else -1))\n    return [[res[i][0], res[i][1]] for i in range(min(len(res), len(mat)*len(mat[0])))]\n\ndef main():\n    mat1 = [[1,2],[3,4]]\n    print(allCellsDistLessThanMatrix(mat1))\n\n    mat2 = [[5,10],[11,13]]\n    print(allCellsDistLessThanMatrix(mat2))\n\n    mat3 = [[10,9,7,6],[14,8,4,3],[15,12,5,3],[14,11,10,9]]\n    print(allCellsDistLessThanMatrix(mat3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1031": "```\ndef maxSumTwoNoOverlap(arr):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i+1] = prefix_sum[i] + arr[i]\n\n    ans = float('-inf')\n    left, right = 0, 0\n    for i in range(1, n-1):\n        if prefix_sum[i+right+1] - prefix_sum[left] > 0:\n            temp = max(prefix_sum[i+right+1] - prefix_sum[left], \n                       arr[i:i+right+1].index(min(arr[i:i+right+1])) + right)\n            ans = max(ans, temp)\n        right += 1\n    return ans\n\ndef main():\n    print(maxSumTwoNoOverlap([2,1,5,6,0,9,2,2,3,4]))\n    print(maxSumTwoNoOverlap([8,32,45,6,17,-8]))\n    print(maxSumTwoNoOverlap([1,2,3,10,8,20]))\n\nmain()\n```",
  "1032": "```\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = TrieNode()\n        for word in words:\n            node = self.root\n            for char in reversed(word):\n                if char not in node.children:\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_word = True\n\n    def query(self, s: str) -> bool:\n        node = self.root\n        for char in reversed(s):\n            if char not in node.children:\n                return False\n            node = node.children[char]\n            if node.is_word:\n                return True\n        return node.is_word\n\n\ndef main():\n    words = [\"kiex\", \"kirk\", \"lake\"]\n    streamChecker = StreamChecker(words)\n\n    print(streamChecker.query(\"kiex\"))  # Should be True\n    print(streamChecker.query(\"khakis\"))  # Should be False\n    print(streamChecker.query(\"luke\"))   # Should be True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1033": "```\ndef numMovesStonesIII(a, b, c):\n    min_val = min(a, b, c)\n    max_val = max(a, b, c)\n    \n    if max_val - min_val > 2:\n        return [0, 0]\n    elif max_val - min_val == 1:\n        return [0, 1]\n    else:\n        return [2]\n\ndef main():\n    test_cases = [\n        (5, 3, 1), \n        (3, 6, 7), \n        (10, 9, 8)\n    ]\n\n    for a, b, c in test_cases:\n        print(f\"Test case: {a}, {b}, {c}\")\n        result = numMovesStonesIII(a, b, c)\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1034": "```\ndef colorBorder(grid, row, col, color):\n    rows = len(grid)\n    cols = len(grid[0])\n    directions = [(0,1), (0,-1), (1,0), (-1,0)]\n    queue = [(row,col)]\n\n    while queue:\n        x, y = queue.pop(0)\n        if grid[x][y] != color:\n            continue\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == color:\n                continue\n            if (nx, ny) not in queue:\n                queue.append((nx, ny))\n        if not queue: return\n\n    for i in range(rows):\n        for j in range(cols):\n            if (i==row or j==col or abs(i-row)>1 or abs(j-col)>1):\n                grid[i][j] = color\n    return\n\n\ndef main():\n    test_cases = [\n        {\n            \"grid\": [[0, 1], [1, 2]],\n            \"row\": 0,\n            \"col\": 0,\n            \"color\": 3,\n            \"expected\": [[0, 3], [1, 3]]\n        },\n        {\n            \"grid\": [[0, 1], [1, 2]],\n            \"row\": 1,\n            \"col\": 0,\n            \"color\": 3,\n            \"expected\": [[0, 1], [1, 3]]\n        },\n        {\n            \"grid\": [[0, 1, 0], [0, 1, 1], [1, 1, 1]],\n            \"row\": 2,\n            \"col\": 1,\n            \"color\": 2,\n            \"expected\": [[0, 1, 0], [0, 1, 1], [1, 2, 1]]\n        }\n    ]\n\n    for test_case in test_cases:\n        grid = [[test_case[\"grid\"][i][j] for j in range(len(test_case[\"grid\"][0]))] for i in range(len(test_case[\"grid\"]))]\n        colorBorder(grid, test_case[\"row\"], test_case[\"col\"], test_case[\"color\"])\n        print(\"Test Case:\", test_case)\n        print(\"Expected:\", test_case[\"expected\"])\n        print(\"Actual:\")\n        for row in grid:\n            print(row)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1035": "```\ndef maxUncrossedLines(points):\n    points.sort(key=lambda x: (x[0], x[1]))\n    dp = [[0] * (len(points)) for _ in range(len(points))]\n    res = 0\n    for i in range(len(points)):\n        for j in range(i, len(points)):\n            if (abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])) % 2 == 1:\n                dp[i][j] = max(dp[i-1][j-1], dp[i-1][j] + 1, dp[i][j-1])\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n            res = max(res, dp[i][j])\n    return res\n\ndef main():\n    print(\"Test Case 1: \", maxUncrossedLines([[0,3],[1,3],[2,4]]))\n    print(\"Test Case 2: \", maxUncrossedLines([[0,1],[1,1],[2,2]]))\n    print(\"Test Case 3: \", maxUncrossedLines([[0,2],[5,11],[12,8]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1037": "```\ndef isBoomerang(points):\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n\n    return (y2 - y1) * (y3 - y2) != (x2 - x1) * (x3 - x2)\n\ndef main():\n    print(isBoomerang([[1, 1], [4, 4], [0, 0]])) # Expected: True\n    print(isBoomerang([[1, 1], [1, 2], [4, 4]])) # Expected: False\n    print(isBoomerang([[-3, -8], [-6, -8], [-7, -9]])) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1036": "```\ndef have_destination(maze):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = [[False for _ in range(len(maze[0]))] for _ in range(len(maze))]\n    stack = []\n    \n    def dfs(i, j):\n        if i < 0 or i >= len(maze) or j < 0 or j >= len(maze[0]) or maze[i][j] == 'X' or visited[i][j]:\n            return False\n        visited[i][j] = True\n        for di, dj in directions:\n            ni, nj = i + di, j + dj\n            if dfs(ni, nj):\n                stack.append((ni, nj))\n                return True\n        return False\n    \n    for i in range(len(maze)):\n        for j in range(len(maze[0])):\n            if maze[i][j] == 'S':\n                return dfs(i, j)\n    \n    return None\n\n\ndef main():\n    maze1 = [\n        ['#', '#', '#', '.', '#'],\n        ['#', 'S', '.', '#', '#'],\n        ['#', '#', '#', 'X', '#'],\n        ['.', '#', '#', '#', '#']\n    ]\n    print(have_destination(maze1))  # True\n\n    maze2 = [\n        ['#', '#', '#', '#', '#'],\n        ['#', 'S', '.', '#', '#'],\n        ['#', '#', '#', 'X', '#'],\n        ['.', '#', '#', '#', '#']\n    ]\n    print(have_destination(maze2))  # False\n\n    maze3 = [\n        ['#', '#', '#', '#', '#'],\n        ['#', 'S', '.', '#', '#'],\n        ['#', '#', 'X', 'X', '#'],\n        ['.', '#', '#', '#', '#']\n    ]\n    print(have_destination(maze3))  # False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1038": "```\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef convertBST(root):\n    if not root:\n        return\n    convertBST(root.right)\n    original_sum = root.val\n    root.val += original_sum\n    convertBST(root.left)\n\ndef main():\n    # Test case 1\n    node5 = TreeNode(5)\n    node2 = TreeNode(2)\n    node13 = TreeNode(13)\n    node1 = TreeNode(1)\n    node4 = TreeNode(4)\n    node6 = TreeNode(6)\n    node9 = TreeNode(9)\n    node8 = TreeNode(8)\n    node3 = TreeNode(3)\n\n    node5.left = node2\n    node5.right = node13\n    node2.left = node1\n    node2.right = node4\n    node13.right = node6\n    node1.right = node3\n    node9.left = node8\n\n    convertBST(node5)\n    print(\"Test case 1: The modified tree is:\")\n    print_tree(node5)\n\n    # Test case 2\n    node1 = TreeNode(10)\n    node4 = TreeNode(20)\n    node6 = TreeNode(30)\n    node3 = TreeNode(40)\n    node2 = TreeNode(50)\n    node8 = TreeNode(60)\n    node9 = TreeNode(70)\n    node5 = TreeNode(80)\n\n    node4.left = node1\n    node4.right = node6\n    node1.left = node3\n    node1.right = node2\n    node2.left = node8\n    node2.right = node9\n    node6.right = node5\n\n    convertBST(node4)\n    print(\"Test case 2: The modified tree is:\")\n    print_tree(node4)\n\n    # Test case 3\n    node1 = TreeNode(1)\n\n    convertBST(node1)\n    print(\"Test case 3: The modified tree is:\")\n    print_tree(node1)\n\ndef print_tree(root):\n    if not root:\n        return\n\n    print_tree(root.right)\n    print(str(root.val) + \" \", end=\"\")\n    print_tree(root.left)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1039": "```\ndef minScoreTriangulation(points):\n    n = len(points)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        dp[i][i] = float('inf')\n        \n    for length in range(3, n + 1):\n        for i in range(1, n - length + 2):\n            j = i + length - 1\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], max((points[k][0] - points[i-1][0]) ** 2 + (points[k][1] - points[i-1][1]) ** 2,\n                                               (points[j][0] - points[k][0]) ** 2 + (points[j][1] - points[k][1]) ** 2,\n                                               dp[i][k] + dp[k+1][j]))\n\n    return dp[1][n]\n\ndef main():\n    print(minScoreTriangulation([[0, 0], [0, 3], [5, 5]]))\n    print(minScoreTriangulation([[1, 2], [4, 8], [10, 10]]))\n    print(minScoreTriangulation([[1, 1], [1, 3], [2, 2]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1040": "```\ndef numMovesStonesII(stones):\n    stones.sort()\n    res = []\n    for i in range(1, len(stones)):\n        steps = max((stones[i] - stones[i-1]) // 2, 0)\n        res.append(steps)\n    return sum(res)\n\ndef main():\n    test_case1 = [5,1,3]\n    print(\"Test Case 1: \", numMovesStonesII(test_case1))\n    \n    test_case2 = [7,4,5,3,2]\n    print(\"Test Case 2: \", numMovesStonesII(test_case2))\n    \n    test_case3 = [6,5,4,3]\n    print(\"Test Case 3: \", numMovesStonesII(test_case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1041": "```\ndef isRobotBounded(instructions):\n    x, y, dx, dy = 0, 0, 0, 1\n    for instruction in instructions:\n        if instruction == 'L':\n            dx, dy = -dy, dx\n        elif instruction == 'R':\n            dx, dy = dy, -dx\n        elif instruction == 'F':\n            x += dx\n            y += dy\n    return (x, y) == (0, 0) or dx != 0 or dy != 1\n\ndef main():\n    print(isRobotBounded(\"GIGZE\")) # Test case 1: True\n    print(isRobotBounded(\"FFRFL\")) # Test case 2: False\n    print(isRobotBounded(\"RFRFRT\")) # Test case 3: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1042": "```\ndef gardenNoAdj(n, paths):\n    g = [[] for _ in range(n)]\n    for u, v in paths:\n        g[u].append(v)\n        g[v].append(u)\n\n    res = [[0]*3 for _ in range(n)]\n\n    for i in range(1, n):\n        if len(g[i]) == 0:\n            for j in range(3):\n                res[i][j] = (res[i-1][j] + 1) % 3\n        else:\n            seen = set()\n            seen.add(res[paths[0][0]][2])\n            seen.add(res[paths[0][1]][2])\n            for j in range(3):\n                if res[paths[0][0]][j] not in seen and res[paths[0][1]][j] not in seen:\n                    for k in g[i]:\n                        res[k][(res[k].index(seen.pop()) + 1) % 3] = (res[i-1][j] + 1) % 3\n                    break\n\n    return [x[:] for x in res]\n\ndef main():\n    n1 = 3\n    paths1 = [[1,2],[2,3]]\n    result1 = gardenNoAdj(n1, paths1)\n    print(\"Test case 1: \", result1)\n\n    n2 = 4\n    paths2 = [[1,2],[2,3],[3,4],[4,1]]\n    result2 = gardenNoAdj(n2, paths2)\n    print(\"Test case 2: \", result2)\n\n    n3 = 5\n    paths3 = [[1,2],[2,3],[3,4],[4,5]]\n    result3 = gardenNoAdj(n3, paths3)\n    print(\"Test case 3: \", result3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1043": "```\ndef maxSumAfterPartitioning(arr):\n    n = len(arr)\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        currMax = 0\n        for j in range(1, min(i, 3) + 1):\n            currMax = max(currMax, arr[i - j])\n            dp[i] = max(dp[i], dp[i - j] + currMax * j)\n    \n    return dp[-1]\n\ndef main():\n    print(\"Test Case 1: \", maxSumAfterPartitioning([5,6,8,7])) \n    print(\"Expected Output: 29\")\n    print()\n\n    print(\"Test Case 2: \", maxSumAfterPartitioning([9,6,4,7,3,1])) \n    print(\"Expected Output: 37\")\n    print()\n\n    print(\"Test Case 3: \", maxSumAfterPartitioning([10,10,20])) \n    print(\"Expected Output: 60\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1044": "```\ndef longestDupSubstring(s):\n    n = len(s)\n    for i in range(1 << (n.bit_length() + 1)):\n        length = i.bit_length()\n        substring = s[:length]\n        if s.startswith(substring * (i // length + 1)):\n            return substring\n    return \"\"\n\ndef main():\n    test_cases = [\n        {\"s\": \"ABCDBAC\", \"expected\": \"ABCD\"},\n        {\"s\": \"AABAA\", \"expected\": \"AAB\"},\n        {\"s\": \"aaabaabbaa\", \"expected\": \"aaab\"}\n    ]\n    \n    for test_case in test_cases:\n        s = test_case[\"s\"]\n        expected = test_case[\"expected\"]\n        print(f\"Test case: {s}\")\n        result = longestDupSubstring(s)\n        if result == expected:\n            print(\"PASS\")\n        else:\n            print(f\"FAIL - Expected {expected} but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1045": "```\ndef productOrders(orders):\n    product_orders = {}\n    for order in orders:\n        for product in order[0]:\n            if product not in product_orders:\n                product_orders[product] = set()\n            product_orders[product].update(order[1])\n\n    return [[list(product_orders.keys())], [set().union(*product_orders.values())]]\n\ndef main():\n    test_cases = [\n        ([\n            [[\"product1\", \"product2\"], [\"customer1\"]],\n            [[\"product3\", \"product4\"], [\"customer1\"]],\n            [[\"product5\"], [\"customer2\"]]\n        ]),\n        ([\n            [[\"product1\"], [\"customer1\"]],\n            [[\"product2\"], [\"customer1\"]],\n            [[\"product1\", \"product2\"], [\"customer2\"]]\n        ]),\n        ([\n            [[\"product1\", \"product2\", \"product3\"], [\"customer1\"]],\n            [[\"product4\"], [\"customer2\"]]\n        ])\n    ]\n\n    for test_case in test_cases:\n        result = productOrders(test_case)\n        print(f\"Test Case: {test_case}\")\n        print(f\"Result: {[list(result[0]), list(result[1])]}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1046": "```\ndef lastStoneWeight(stones):\n    import heapq\n    stones = [-x for x in stones]\n    heapq.heapify(stones)\n    while len(stones) > 1:\n        y, x = -heapq.heappop(stones), -heapq.heappop(stones)\n        if y != x:\n            heapq.heappush(stones, -(y-x))\n    return -stones[0] if stones else 0\n\ndef main():\n    test_cases = [\n        ([2, 7, 4, 2, 8], 1), \n        ([31, 26, 13, 22, 2], 5),\n        ([3], 3)\n    ]\n    \n    for (stones, expected) in test_cases:\n        result = lastStoneWeight(stones)\n        if result != expected:\n            print(\"Test case failed. Expected\", expected, \"but got\", result)\n        else:\n            print(\"Test case passed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1047": "```\ndef removeDuplicates(S):\n    stack = []\n    for char in S:\n        if not stack or stack[-1] != char:\n            stack.append(char)\n        else:\n            stack.pop()\n    return ''.join(stack)\n\ndef main():\n    print(removeDuplicates(\"Pacific\")) # expected output: \"P\"\n    print(removeDuplicates(\"azxxxzy\")) # expected output: \"az\"\n    print(removeDuplicates(\"aacaaaa\")) # expected output: \"a\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1048": "```\ndef longestStrChain(words):\n    words.sort()\n    max_len = 0\n    for i in range(len(words)-1):\n        word = words[i]\n        next_word = words[i+1]\n        if len(word) + 1 == len(next_word):\n            prev_word = \"\"\n            for char in word:\n                prev_word += '{' + char + '}'\n            while True:\n                if not is_valid(prev_word):\n                    break\n                if dfs(prev_word, \"\") > max_len:\n                    max_len = dfs(prev_word, \"\")\n        else:\n            prev_word = \"\"\n            for char in word:\n                prev_word += '{' + char + '}'\n            while True:\n                if not is_valid(prev_word):\n                    break\n                if dfs(prev_word, \"\") > max_len:\n                    max_len = dfs(prev_word, \"\")\n\n    return max_len\n\n\ndef is_valid(word):\n    if len(word) == 0:\n        return False\n    for i in range(len(word)):\n        if word[i] != '{' and word[i] != '}':\n            return True\n    return False\n\n\ndef dfs(word, path):\n    if not is_valid(word):\n        return 0\n    next_path = path + \" -> \"\n    if len(word) == 0:\n        return len(path.split(\" -> \")[1:])\n    min_len = float('inf')\n    for i in range(len(word)):\n        if word[i] != '{' and word[i] != '}':\n            new_word = word[:i] + word[i+1:]\n            temp_path = next_path + str(new_word)\n            min_len = min(min_len, dfs(new_word, temp_path))\n    return min_len\n\n\ndef main():\n    test_cases = [\n        {\"input\": [\"abcd\", \"ab\", \"abc\"], \"expected_output\": 3},\n        {\"input\": [\"ksxw\", \"ksw\", \"kw\"], \"expected_output\": 2},\n        {\"input\": [\"a\", \"ab\", \"b\"], \"expected_output\": 2}\n    ]\n\n    for test_case in test_cases:\n        input_words = test_case[\"input\"]\n        expected_output = test_case[\"expected_output\"]\n\n        output = longestStrChain(input_words)\n        print(f\"Input: {input_words}, Expected Output: {expected_output}, Actual Output: {output}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1049": "```\ndef lastStoneWeightII(stones):\n    dp = [[0] for _ in range(sum(stones) // 2 + 1)]\n    for w in stones:\n        for i in range(sum(stones) // 2, w - 1, -1):\n            dp[i][w % (sum(stones) // 2 + 1)] = max(dp[i][w % (sum(stones) // 2 + 1)], dp[i - w][w % (sum(stones) // 2 + 1)] + w)\n    return max(map(max, dp))\n\ndef main():\n    print(lastStoneWeightII([32,31,30]) == 73)\n    print(lastStoneWeightII([20,17,18]) == 26)\n    print(lastStoneWeightII([4,13,30,35,47,49]) == 100)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1050": "```\ndef find_cooperators(cooperation):\n    cooperator_counts = {}\n    for pair in cooperation:\n        actor1, director1 = pair[0], pair[1]\n        if actor1 not in cooperator_counts:\n            cooperator_counts[actor1] = set()\n        if director1 not in cooperator_counts:\n            cooperator_counts[director1] = set()\n        cooperator_counts[actor1].add(director1)\n        cooperator_counts[director1].add(actor1)\n\n    result = []\n    for actor, directors in cooperator_counts.items():\n        if len(directors) >= 3:\n            result.append((actor, len(directors)))\n\n    return sorted(result, key=lambda x: x[1], reverse=True)\n\n\ndef main():\n    cooperation = [[\"Emma\", \"John\"], [\"Emma\", \"Mike\"], [\"Mia\", \"John\"], [\"Mia\", \"Mike\"],\n                    [\"Olivia\", \"John\"], [\"Olivia\", \"Mike\"], [\"Emma\", \"John\"]]\n    print(find_cooperators(cooperation))\n\n    cooperation = [[\"A1\", \"D1\"], [\"A1\", \"D2\"], [\"A2\", \"D1\"], [\"A3\", \"D1\"], \n                    [\"A3\", \"D2\"], [\"A4\", \"D2\"], [\"A5\", \"D1\"], [\"A6\", \"D1\"]]\n    print(find_cooperators(cooperation))\n\n    cooperation = [[\"Alice\", \"Bob\"], [\"Alice\", \"Charlie\"], [\"Alice\", \"David\"], \n                    [\"Bob\", \"Charlie\"], [\"Bob\", \"David\"], [\"Charlie\", \"David\"]]\n    print(find_coopers)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1051": "```\ndef heightChecker(heights):\n    sorted_heights = sorted(heights)\n    return sum(h1 != h2 for h1, h2 in zip(heights, sorted_heights))\n\ndef main():\n    print(\"Test case 1:\")\n    heights1 = [1, 8, 6, 2, 5, 3, 4]\n    print(heightChecker(heights1))  # Expected output: 5\n\n    print(\"\\nTest case 2:\")\n    heights2 = [1, 2, 3, 4, 5, 6, 7]\n    print(heightChecker(heights2))  # Expected output: 0\n\n    print(\"\\nTest case 3:\")\n    heights3 = [5, 1, 2, 3, 4]\n    print(heightChecker(heights3))  # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1052": "```\ndef maxSatisfied(customers, grumpy, minutes):\n    total = sum(c for c, g in zip(customers, (1 if g else 0) * [0] + [1] * minutes) if g)\n    max_increase = 0\n    current_satisfaction = 0\n    left = 0\n    for right in range(len(customers)):\n        while right - left > minutes:\n            current_satisfaction -= customers[left]\n            left += 1\n        if grumpy[right]:\n            continue\n        current_satisfaction += customers[right]\n        max_increase = max(max_increase, current_satisfaction - total)\n    return total + max_increase\n\n\ndef main():\n    print(\"Test case 1: \")\n    print(maxSatisfied([1,0,2,3,0,4,5], 0, 1) == 9)\n\n    print(\"\\nTest case 2: \")\n    print(maxSatisfied([1,0,2,3,0,4,5], 1, 2) == 6)\n\n    print(\"\\nTest case 3: \")\n    print(maxSatisfied([7,7,7,7,7,1,7,7,7,7], 0, 3) == 14)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1053": "```\ndef prevPermOpt1(nums):\n    n = len(nums)\n    for i in range(n-2, -1, -1):\n        if nums[i] > nums[i+1]:\n            j = n - 1\n            while j > i and nums[j] >= nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n            return nums[:]\n    return nums\n\ndef main():\n    print(prevPermOpt1([3,1,5,8]))\n    print(prevPermOpt1([1,2,3,4]))\n    print(prevPermOpt1([9,8,7,6]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1054": "```\ndef rearrangeBarcodes(barcode):\n    barcodeCount = {}\n    for code in barcode:\n        if code in barcodeCount:\n            barcodeCount[code] += 1\n        else:\n            barcodeCount[code] = 1\n\n    sortedBarcode = sorted(barcodeCount.items(), key=lambda x: x[1], reverse=True)\n    result = []\n\n    while len(sortedBarcode) > 0:\n        maxCount = sortedBarcode[0][1]\n        temp = [x[0] for x in sortedBarcode if x[1] == maxCount]\n        result.extend(temp)\n\n        for code in temp:\n            barcodeCount.pop(code, None)\n            sortedBarcode = [(code, count) for code, count in sortedBarcode if code != code]\n\n    return result\n\ndef main():\n    print(rearrangeBarcodes([\"AAAA\", \"BBCC\", \"CAB\"])) \n    print(rearrangeBarcodes([\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"]))  \n    print(rearrangeBarcodes([\"AAAAAA\", \"BBCCC\", \"CBABA\"]))  \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1055": "```\ndef shortestWay(columnTitles, row1):\n    n = len(columnTitles)\n    m = len(row1)\n    res = []\n    for i in range(m):\n        for j in range(n):\n            if columnTitles[j][0] == row1[i]:\n                res.append((j, 1))\n                break\n        else:\n            continue\n    return max(zip(*res)[1])\n\ndef main():\n    print(shortestWay([\"A\",\"B\",\"C\",\"D\",\"E\"],[\"BACDF\"]))\n\n    print(shortestWay([\"abc\",\"bcd\",\"xyz\"],[\"xyz\",\"abc\"]))\n\n    print(shortestWay([\"hy\",\"km\",\"hw\",\"lb\",\"wk\",\"md\",\"tp\",\"yx\",\"kr\",\"wx\",\"mp\"],\"shxwbpmps\"))\n\nmain()\n```",
  "1056": "```\ndef confused_number(n):\n    return str(n).swapcase()\n\ndef main():\n    print(confused_number(123)) # Test case 1\n    print(confused_number(46))   # Test case 2\n    print(confused_number(9101)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1057": "```\ndef assignBikes(riders, bikes):\n    from heapq import heapify, heappop, heappush\n\n    # Create a priority queue to store riders\n    pq = [(0, i) for i in range(len(riders))]\n    heapify(pq)\n\n    # Assign bikes to riders\n    assigned = [False] * len(riders)\n    available_bikes = [[bike, i] for i, bike in enumerate(bikes)]\n    heapify([i[1] for i in available_bikes])\n\n    while pq:\n        dist, rider = heappop(pq)\n        if not assigned[rider]:\n            if heapify(available_bikes):\n                available_bike = heappop(available_bikes)\n                bikes_to_assign = min(dist + 1, len(bikes) - 1)\n                for _ in range(bikes_to_assign):\n                    heappush(pq, (dist + 1, available_bike[1]))\n                    available_bike = heappop(available_bikes)\n            assigned[rider] = True\n\n    return [i for i, x in enumerate(assigned) if not x]\n\ndef main():\n    riders = [[0, 0], [2, 1]]\n    bikes = [[0, 0], [2, 1]]\n    print(assignBikes(riders, bikes))\n    \n    riders = [[0, 0], [5, -3]]\n    bikes = [[0, 0], [-1, 0], [2, 2], [4, 6], [5, 5]]\n    print(assignBikes(riders, bikes))\n\n    riders = [[0, 0], [8, -1], [9, -2], [12, -3]]\n    bikes = [[0, 0], [-1, 0], [2, 1], [4, 5], [6, 7], [7, 8], [10, 11], [11, 12]]\n    print(assignBikes(riders, bikes))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1058": "```\ndef minimize_rounding_error(currencies, target):\n    currencies.sort()\n    total = 0\n    count = 0\n    for coin in reversed(currencies):\n        while total + coin <= target:\n            total += coin\n            count += 1\n    return count\n\ndef main():\n    print(minimize_rounding_error([5,3], 9)) # Test case 1\n    print(minimize_rounding_error([10,100,500], 6300)) # Test case 2\n    print(minimize_rounding_error([1,2,5], 11)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1059": "```\ndef hasAllPathsLeadingToTarget(graph, target):\n    def dfs(node, path):\n        if node == target:\n            return True\n        for neighbor in graph.get(node, []):\n            if not dfs(neighbor, path + [node]):\n                return False\n        return True\n\n    return all(dfs(node, []) for node in graph)\n\ndef main():\n    test_case1 = {\"A\": [\"C\",\"F\",\"J\"], \"B\": [\"E\"], \"C\": [\"B\",\"K\"], \"D\": [], \"E\": [\"B\",\"C\",\"J\",\"S\"], \"F\": [\"I\"], \"G\": [\"H\"], \"H\": [\"G\", \"I\"], \"I\": [\"G\",\"F\",\"J\"], \"J\": [\"E\",\"F\",\"I\"], \"K\": [], \"S\": []}\n    print(hasAllPathsLeadingToTarget(test_case1, \"A\"))\n\n    test_case2 = {\"B\":\"C\",\"C\":\"D\",\"E\":\"F\",\"E\":\"H\",\"F\":\"B\",\"G\":\"F\",\"H\":\"C\",\"I\":\"G\",\"J\":\"E\"}\n    print(hasAllPathsLeadingToTarget(test_case2, \"J\"))\n\n    test_case3 = {}\n    print(hasAllPathsLeadingToTarget(test_case3, \"A\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1060": "```\ndef search(nums):\n    left, right = 0, len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == mid:\n            return mid\n        elif nums[mid] < mid:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\ndef main():\n    print(search([0,1,3]) == 2)\n    print(search([9,10,11,12]) == 8)\n    print(search([1,2,3,4,6,7,9]) == 5)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1061": "```\ndef smallestEquivalentString(s: str) -> str:\n    n = len(s)\n    parent = [i for i in range(n)]\n    rank = [0] * n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        else:\n            parent[rootX] = rootY\n            if rank[rootX] == rank[rootY]:\n                rank[rootY] += 1\n    for i in range(n - 1):\n        union(i, i + 1)\n    res = ''\n    for c in s:\n        res += chr(min([ord('a') + find(ord(c) - ord('a')), ord('z')]) if 'a' <= c else min([0, 25]))\n    return res\n\ndef main():\n    print(smallestEquivalentString(\"parker\"))\n    print(smallestEquivalentString(\"qgzmvp\"))  \n    print(smallestEquivalentString(\"abc\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1062": "```\ndef longest_repeating_substring(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if s[i - 1] == s[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    res = \"\"\n    i, j = n, n\n    while i > 0 and j > 0:\n        if s[i - 1] == s[j - 1]:\n            res = s[i - 1] + res\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n    \n    return res\n\ndef main():\n    print(longest_repeating_substring(\"ababa\"))\n    print(longest_repeating_substring(\"abcdeef\"))\n    print(longest_repeating_substring(\"bbbbb\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1063": "```\ndef numValidSubarrays(nums):\n    stack = []\n    res = 0\n    for i, n in enumerate(nums):\n        while stack and stack[-1] >= n:\n            stack.pop()\n        if not stack:\n            res += len(nums) - i\n        else:\n            res += i - stack[-1]\n        stack.append(i)\n    return res\n\ndef main():\n    print(numValidSubarrays([2, 1, 3, 5, 4])) # Expected output: 7\n    print(numValidSubarrays([0, 0, 1, 3, 2])) # Expected output: 9\n    print(numValidSubarrays([10, 15, 20])) # Expected output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1064": "```\ndef fixedPoint(arr):\n    for i in range(len(arr)):\n        if arr[i] == i:\n            return i\n    return -1\n\n\ndef main():\n    print(fixedPoint([0, 5, 10, 20, 35]) )\n    print(fixedPoint([-3, 1, 2, 4, 6])\n    print(fixedPoint([int(-j) for j in range(8)]) )\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1065": "```\ndef indexPairs(text):\n    result = []\n    for i in range(len(text)):\n        for j in range(i+1, len(text)+1):\n            if text[i:j].isalpha():\n                result.append((i,j-1))\n    return sorted(result)\n\ndef main():\n    test_cases = [\n        {\"text\": \"hello\", \"expected_result\": [(0,5)]},\n        {\"text\": \"abc def ghij klmnop qrs t uvwxyz\", \"expected_result\": [(3,8),(10,13),(15,18),(20,23),(25,28),(30,33),(35,38),(40,43),(45,48),(49,52)]},\n        {\"text\": \"!@#$%^&*()_+-=\", \"expected_result\": []}\n    ]\n\n    for test_case in test_cases:\n        result = indexPairs(test_case[\"text\"])\n        if result == test_case[\"expected_result\"]:\n            print(\"Test case passed: \", test_case)\n        else:\n            print(\"Test case failed: \", test_case)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1066": "```\ndef numPairsDivisibleBy60(time):\n    count = [0] * 60\n    res = 0\n    for t in time:\n        remainder = t % 60\n        res += count[59 - remainder]\n        count[remainder] += 1\n    return res\n\n\ndef main():\n    print(numPairsDivisibleBy60([60, 60, 60])) # Expected: 3\n    print(numPairsDivisibleBy60([10, 20, 30, 40, 50, 60])) # Expected: 5\n    print(numPairsDivisibleBy60([58, 59, 60])) # Expected: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1067": "```\ndef countDigitOne(n):\n    res = 0\n    for i in range(1, n+1):\n        res += atMostK(i)\n    return res\n\n\ndef atMostK(k):\n    if k < 10:\n        return k\n    res = 0\n    for d in str(k)[::-1]:\n        if d == '1':\n            res += k - int('9' * len(str(k)) + '1' * (len(str(k))-1))\n        elif d == '0':\n            res += k - int('1' * len(str(k)))\n        else:\n            res += 10**(len(str(k))-1)\n    return res\n\n\ndef main():\n    print(countDigitOne(20))\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\nAnd here are the test cases:\n\n```\nprint(countDigitOne(3)) # Should print 5\nprint(countDigitOne(4)) # Should print 8\nprint(countDigitOne(10)) # Should print 24",
  "1068": "```\ndef topProduct(id, categories):\n    sales = {}\n    for category in categories:\n        for item in category:\n            if item[1] not in sales:\n                sales[item[1]] = item[0]\n            else:\n                sales[item[1]] += item[0]\n    sorted_sales = sorted(sales.items(), key=lambda x: x[1], reverse=True)\n    return [i[0] for i in sorted_sales[:3]]\n\ndef main():\n    test_case1 = [[100, 10], [200, 20]]\n    print(\"Test Case 1: \", topProduct(1, test_case1))\n    \n    test_case2 = [[5, 10], [10, 20], [15, 30], [25, 40]]\n    print(\"Test Case 2: \", topProduct(2, test_case2))\n    \n    test_case3 = [[1, 1], [2, 2], [3, 3]]\n    print(\"Test Case 3: \", topProduct(3, test_case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1069": "```\ndef productSalesAnalysisII(products):\n    product_map = {}\n    for p in products:\n        if p[0] not in product_map:\n            product_map[p[0]] = 1\n        else:\n            product_map[p[0]] += 1\n\n    return sorted(product_map.items())\n\ndef main():\n    print(productSalesAnalysisII([[\"ProductA\", 2], [\"ProductB\", 4], [\"ProductC\", 3], [\"ProductD\", 2], [\"ProductE\", 2], [\"ProductF\", 1]]))\n    print(productSalesAnalysisII([[\"ProductX\", 5], [\"ProductY\", 6], [\"ProductZ\", 7]]))\n    print(productSalesAnalysisII([]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1071": "```\ndef gcdOfStrings(s1, s2):\n    if not (s1 + s2 == s2 + s1):\n        return \"\"\n    \n    gcd = s1\n    while s2:\n        s2, gcd = gcd, s2\n    return gcd\n\ndef main():\n    print(gcdOfStrings(\"ABCABC\", \"ABC\"))  # Expected: \"ABC\"\n    print(gcdOfStrings(\"ABAB\",\"BABA\"))  # Expected: \"AB\"\n    print(gcdOfStrings(\"\", \"\"))  # Expected: \"\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1070": "```\ndef get_order_id(nums):\n    return [(i+1) for i in range(len(nums))]\n\ndef total_amount(tran_list):\n    total = 0\n    for item in tran_list:\n        if len(item) == 2:\n            total += float(item[1])\n        else:\n            for sub_item in item:\n                if isinstance(sub_item, list):\n                    for sub_sub_item in sub_item:\n                        total += float(sub_sub_item)\n                elif isinstance(sub_item, dict):\n                    total += float(list(sub_item.values())[0])\n    return total\n\ndef total_quantity(tran_list):\n    quantity = 0\n    for item in tran_list:\n        if len(item) == 2:\n            quantity += int(item[1].split(' ')[0])\n        else:\n            for sub_item in item:\n                if isinstance(sub_item, list):\n                    for sub_sub_item in sub_item:\n                        quantity += int(sub_sub_item.split(' ')[0])\n                elif isinstance(sub_item, dict):\n                    quantity += int(list(sub_item.values())[0].split(' ')[0])\n    return quantity\n\ndef find_average(tran_list):\n    total_amount_val = total_amount(tran_list)\n    total_quantity_val = total_quantity(tran_list)\n    if total_amount_val == 0:\n        return 0\n    else:\n        return round(total_amount_val / total_quantity_val,2)\n\ndef main():\n    tran1 = [[\"ProductA\", \"100.00\"], [\"ProductB\", \"50.00\"]]\n    tran2 = [[[\"ProductC\", \"200.00\"]]]\n    tran3 = []\n\n    print(\"Transaction 1 Average: \", find_average(tran1))\n    print(\"Transaction 2 Average: \", find_average(tran2))\n    print(\"Transaction 3 Average: \", find_average(tran3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1072": "```\ndef maxEqualRowsAfterFlips(matrix):\n    result = []\n    for row in matrix:\n        zeros = row.count(0)\n        ones = row.count(1)\n        if zeros > ones:\n            row = [1 - x for x in row]\n        result.append(row)\n    return result\n\ndef findMaxForm(nums):\n    count0 = len([i for i in nums if i == 0])\n    count1 = len([i for i in nums if i == 1])\n    return max(count0, count1)\n\ndef main():\n    matrix = [[0,1],\n              [1,1]]\n    print(findMaxForm(maxEqualRowsAfterFlips(matrix)))\n\n    matrix = [[0,1,0],\n              [0,0,1],\n              [1,1,1],\n              [1,0,0]]\n    print(findMaxFlip(matrix))\n\n    matrix = [[0,1],\n              [1,1],\n              [1,0]]\n    print(findMaxForm(maxEqualRowsAfterFlips(matrix)))\n\nmain()\n```",
  "1073": "```\ndef addNegabinary(nums):\n    n = len(nums)\n    res = []\n    i, j = 0, n-1\n    carry = 0\n    while i <= j:\n        bit_sum = nums[i] + nums[j] - 2*carry\n        new_carry = (bit_sum // 2) * 2 - 1 if bit_sum % 2 else 0\n        res.append((bit_sum + 1) % 2)\n        carry = new_carry\n        i += 1\n        j -= 1\n    while i < n and not res[-1]:\n        res.pop()\n        i += 1\n    return [x if c == 0 else 1-c for x, c in zip(reversed(res), range(len(res)))]\n\n\ndef main():\n    print(addNegabinary([2,1,9])) # [9]\n    print(addNegabinary([0,2,2])) # [0,0]\n    print(addNegabinary([6,7,3])) # [4,3]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1074": "```\ndef numSubmatrixSumTarget(matrix, target):\n    m, n = len(matrix), len(matrix[0])\n    res = 0\n    for left in range(n):\n        sums = [0] * m\n        for right in range(left, n):\n            for i in range(m):\n                sums[i] += matrix[i][right]\n            twosum = {0: 1}\n            cursum = 0\n            for sum_val in sums:\n                cursum += sum_val\n                if cursum - target in twosum:\n                    res += twosum[cursum - target]\n                if cursum not in twosum:\n                    twosum[cursum] = 1\n    return res\n\ndef main():\n    test_case_1 = [\n        [0, 1, 1],\n        [1, 1, 1],\n        [0, 1, 0]\n    ]\n    print(numSubmatrixSumTarget(test_case_1, -3))  # Output: 8\n\n    test_case_2 = [\n        [-3,-3,-3,-3,3],\n        [-5,-10,20,0,2],\n        [-2,-4,20,15,22],\n        [7,9,4,-7,7],\n        [-7,-9,1,-8,-6]\n    ]\n    print(numSubmatrixSumTarget(test_case_2, 8))  # Output: 11\n\n    test_case_3 = [\n        [10,3,0,5,6],\n        [1,5,5,4,1],\n        [7,6,3,9,8],\n        [9,8,9,-2,6],\n        [6,3,8,2,7]\n    ]\n    print(numSubmatrixSumTarget(test_case_3, 15))  # Output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1075": "```\ndef getUniqueEmails(emails):\n    emails_set = set()\n    for email in emails:\n        local_part, domain = email.split('@')\n        if '.' in local_part:\n            local_part = local_part[:local_part.index('.')]\n        new_email = f\"{local_part}@{domain}\"\n        emails_set.add(new_email)\n    return list(emails_set)\n\ndef main():\n    test_case1 = [\"john.newton@gmail.com\", \"newton.email.2003@abccom\", \"test.email+alex@com\"]\n    print(getUniqueEmails(test_case1))  # Output: ['john.newton@gmail.com', 'newton.email.2003@abccom', 'test.email+alex@com']\n\n    test_case2 = [\"test.email+alex@com\", \"test.e.mail.bacon+lee.t@com\"]\n    print(getUniqueEmails(test_case2))  # Output: ['test.email+alex@com', 'test.e.mail.bacon+lee.t@com']\n\n    test_case3 = []\n    print(getUniqueEmails(test_case3))  # Output: []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1076": "```\ndef numEOM(ideas):\n    return sum([1 for idea in ideas if not idea[5:] or any(word[0].isupper() for word in idea[5:].split())])\n\ndef main():\n    print(numEOM([[\"kitten\", \"doggo\"], [\"pup\", \"furry friend\"], [\"project\"]]))  # Expected: 2\n    print(numEOM([[\"team\", \"members\"], [\"employee\", \"programmer\"], [\"internship\"]]))  # Expected: 3\n    print(numEOM([]))  # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1078": "```\ndef findOccurrences(s):\n    result = []\n    for i in range(2, len(s)):\n        if s[i-1] != s[i]:\n            result.append((i, s[i]))\n    return result\n\ndef main():\n    print(findOccurrences(\"alicehello\")) # [(8,'o')]\n    print(findOccurrences(\"bob\")) # []\n    print(findOccurrences(\"aba\")) # []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1077": "```\ndef num_of_employees_with_access_to_all_projects(connection):\n    cursor = connection.cursor()\n    query = \"\"\"SELECT COUNT(*) \n               FROM Employees e\n               JOIN Employee_Project ep ON e.id = ep.employee_id\n               GROUP BY e.id HAVING NOT EXISTS (\n                   SELECT 1 \n                   FROM Projects p \n                   WHERE NOT EXISTS (\n                       SELECT 1 \n                       FROM Employee_Project ep2 \n                       WHERE ep2.project_id = p.id AND ep2.employee_id = e.id\n                   )\n               );\"\"\"\n    cursor.execute(query)\n    result = cursor.fetchone()[0]\n    return result\n\ndef main():\n    # Test case 1:\n    connection = sqlite3.connect(':memory:')\n    print(num_of_employees_with_access_to_all_projects(connection))\n\n    # Test case 2:\n    connection = sqlite3.connect(':memory:')\n    query = \"\"\"INSERT INTO Employees (id, name) VALUES (1, 'John');\"\"\"\n    cursor = connection.cursor()\n    cursor.execute(query)\n    query = \"\"\"INSERT INTO Projects (id, name) VALUES (1, 'Project A');\"\"\"\n    cursor.execute(query)\n    print(num_of_employees_with_access_to_all_projects(connection))\n\n    # Test case 3:\n    connection = sqlite3.connect(':memory:')\n    query = \"\"\"INSERT INTO Employees (id, name) VALUES (1, 'John'), (2, 'Jane');\"\"\"\n    cursor = connection.cursor()\n    cursor.executescript(query)\n    query = \"\"\"INSERT INTO Projects (id, name) VALUES (1, 'Project A'), (2, 'Project B');\"\"\"\n    cursor.execute(query)\n    query = \"\"\"INSERT INTO Employee_Project (employee_id, project_id) VALUES (1, 1), (1, 2);\"\"\"\n    cursor.execute(query)\n    print(num_of_employees_with_access_to_all_projects(connection))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1079": "```\ndef tilePossibilities(tiles):\n    res = [1]\n    for tile in tiles:\n        new_res = []\n        for x in range(len(res)):\n            new_res.append(res[x])\n            if len(tile) > 0 and tile[0] == 'A':\n                new_res.append(res[x] * (len(tile) - 1))\n        res = new_res\n    return sum(res)\n\ndef main():\n    print(tilePossibilities([\"ABCD\", \"ACD\", \"E\"]) == 5)\n    print(tilePossibilities([\"AA\", \"BB\", \"BC\"]) == 11)\n    print(tilePossibilities([]) == 0)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1080": "```\ndef sufficientNodes(root):\n    if not root:\n        return 0\n    ans = [1]\n    dfs(root, 0, ans)\n    return max(ans)\n\ndef dfs(node, depth, ans):\n    if node.left is None and node.right is None:\n        ans[0] += 1\n    else:\n        dfs(node.left, depth + 1, ans)\n        dfs(node.right, depth + 1, ans)\n\ndef main():\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    root1.left.right = TreeNode(5)\n\n    root2 = TreeNode(1)\n    root2.right = TreeNode(2)\n    root2.right.right = TreeNode(3)\n\n    root3 = TreeNode(1)\n    root3.right = TreeNode(2)\n\n    print(sufficientNodes(root1))  # Expected output: 2\n    print(sufficientNodes(root2))  # Expected output: 1\n    print(sufficientNodes(root3))  # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1081": "```\ndef smallestSubsequences(s):\n    stack = []\n    result = []\n    for char in s:\n        while stack and stack[-1] >= char:\n            stack.pop()\n        if not stack or char != stack[-1]:\n            stack.append(char)\n    for char in stack:\n        result.extend([char] * (s.count(char) - len(result)))\n    return \"\".join(result)\n\ndef main():\n    print(smallestSubsequences(\"abc\"))  # \"abc\"\n    print(smallestSubsequences(\"acccccbbaa\"))  # \"abc\"\n    print(smallestSubsequences(\"abcdefghijklmnopqrstuvwxyz\"))  # \"abcdefghijklmnopqrstuvwxyz\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1082": "```\ndef totalAmount(transactions):\n    return sum([int(transaction[1]) for transaction in transactions])\n\ndef main():\n    test_cases = [\n        {\"transactions\": [[\"John\", \"100\"], [\"Mary\", \"200\"]], \"expected_result\": 300},\n        {\"transactions\": [[\"Alice\", \"50\"], [\"Bob\", \"30\"]], \"expected_result\": 80},\n        {\"transactions\": [], \"expected_result\": 0}\n    ]\n\n    for test_case in test_cases:\n        transactions = [(test_case[\"name\"], amount) for name, amount in [transaction[1:] for transaction in test_case[\"transactions\"]]]\n        result = totalAmount(transactions)\n        if result == test_case[\"expected_result\"]:\n            print(f\"Test case {test_case} passed\")\n        else:\n            print(f\"Test case {test_case} failed. Expected: {test_case['expected_result']}, got: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1083": "```\ndef totalMoneyPerPerson(records):\n    from collections import defaultdict\n\n    money_per_person = defaultdict(int)\n    \n    for amount, person in records:\n        money_per_person[person] += amount\n        \n    return list(money_per_person.items())\n\ndef main():\n    test_cases = [\n        ([[\"John\", 100], [\"John\", 200], [\"Jane\", 150]], [('John', 300), ('Jane', 150)]),\n        ([[\"Alice\", 20], [\"Bob\", 10], [\"Charlie\", 5]], [('Alice', 20), ('Bob', 10), ('Charlie', 5)]),\n        ([[\"Jack\", 1000], [\"Jack\", 2000], [\"Jill\", 300]], [('Jack', 3000), ('Jill', 300)])\n    ]\n\n    for records, expected_output in test_cases:\n        result = totalMoneyPerPerson(records)\n        if result != expected_output:\n            print(f\"Test case failed: {records}, Expected: {expected_output}, Got: {result}\")\n        else:\n            print(f\"Test case passed: {records}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1085": "```\ndef sumOfDigits(minNum):\n    return sum(int(digit) for digit in str(minNum))\n\ndef main():\n    print(sumOfDigits(10))  # Test case 1\n    print(sumOfDigits(15))  # Test case 2\n    print(sumOfDigits(24))  # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1084": "```\ndef totalSales(transactions):\n    return sum(int(amount) for _, amount in transactions)\n\ndef main():\n    case1 = [(\"John\", \"100\"), (\"Mary\", \"200\"), (\"John\", \"300\")]\n    print(\"Test Case 1: \", totalSales(case1))\n    \n    case2 = [(\"John\", \"500\"), (\"Jane\", \"400\"), (\"Jane\", \"300\")]\n    print(\"Test Case 2: \", totalSales(case2))\n    \n    case3 = []\n    print(\"Test Case 3: \", totalSales(case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1086": "```\ndef highFive(self, records):\n    student_grades = {}\n    for record in records:\n        student_id, grade = record\n        if student_id not in student_grades:\n            student_grades[student_id] = []\n        student_grades[student_id].append(grade)\n\n    result = []\n    for student_id, grades in student_grades.items():\n        average_grade = sum(grades) // len(grades)\n        if average_grade >= 5:\n            result.append([student_id, average_grade])\n\n    return sorted(result, key=lambda x: x[1], reverse=True)\n\n\ndef main():\n    test_cases = [\n        [[1, 91], [1, 92], [2, 93], [3, 91]],\n        [[5, 98, 89, 88, 87, 86],\n         [7, 97, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86]],\n        [[1, 100], [2, 100]]\n    ]\n\n    for test_case in test_cases:\n        print(highFive(test_case))\n        print()\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1087": "```\ndef expand-brace(s):\n    def expand_word(word):\n        if not word or word[0] == '{' and word[-1] == '}':\n            return set(expand_from_here(word[1:-1]))\n        elif word[0] == '{':\n            return {c + w + c for w in expand_word(word[1:])}\n        else:\n            return {word}\n\n    def expand_from_here(word):\n        if not word:\n            yield ''\n        else:\n            if word[0] == '{':\n                for expansion in expand_word(word):\n                    yield from (c + e + c for e in expansion)\n            else:\n                for i in range(1, len(word)):\n                    for expansion in expand_from_here(word[:i]):\n                        yield expansion + word[i]\n\n    return ' '.join(''.join(sorted(i)) for i in expand_word(s))\n\ndef main():\n    test_cases = [\"{a,b,c}{d,e,f}\", \"{a,b,c}d{e,f}\", \"({a},{b},{c}){d}\")\n    for s in test_cases:\n        print(f\"Brace expansion of {s}: {expand_brace(s)}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1088": "```\ndef confuse(indexes):\n    if not indexes:\n        return 0\n    \n    if indexes[0] == -1:\n        return 1 + confuse(indexes[1:])\n\n    return confuse([i - 1 for i in indexes[:-1]]) * (indexes[-1] != len(indexes) - 1)\n\ndef hasConfusingNumber(N):\n    for i in range(2, N+1):\n        if confuse(list(map(int, str(i)))) > 0:\n            return True\n    return False\n\ndef main():\n    print(hasConfusingNumber(20)) # Expected: True\n    print(hasConfusingNumber(30)) # Expected: False\n    print(hasConfusingNumber(50000)) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1089": "```\ndef duplicateZeros(arr):\n    n = len(arr)\n    i = 0\n    while i < n - 1:\n        if arr[i] == 0:\n            j = n - 1\n            while j > i:\n                if arr[j] != 0:\n                    arr[i], arr[j] = arr[j], arr[i]\n                    break\n                j -= 1\n        i += 1\n\ndef main():\n    print(\"Test case 1:\")\n    arr = [1, 0, 2, 3, 4, 5]\n    duplicateZeros(arr)\n    print(arr)\n\n    print(\"\\nTest case 2:\")\n    arr = [0, 1]\n    duplicateZeros(arr)\n    print(arr)\n\n    print(\"\\nTest case 3:\")\n    arr = [1, 1, 2, 0]\n    duplicateZeros(arr)\n    print(arr)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1090": "```\ndef largestValues(root):\n    if not root:\n        return []\n\n    max_values = []\n    queue = [(root, 0)]\n\n    while queue:\n        max_val = float('-inf')\n        for node in [node for node in queue]:\n            if node[1] >= len(max_values):\n                max_val = max(max_val, node[0].val)\n            else:\n                max_val = max(max_val, max_values[node[1]])\n            if node[0].left:\n                queue.append((node[0].left, node[1]+1))\n            if node[0].right:\n                queue.append((node[0].right, node[1]+1))\n\n        max_values.append(max_val)\n\n    return max_values\n\n\ndef main():\n    # Test case 1\n    root = TreeNode(5)\n    root.left = TreeNode(2)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(9)\n    root.right.left = TreeNode(6)\n    root.right.right = TreeNode(7)\n    print(largestValues(root))  # Expected output: [5, 8, 9]\n\n    # Test case 2\n    root = TreeNode(1)\n    root.left = TreeNode(3)\n    root.right = TreeNode(4)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(4)\n    print(largestValues(root))  # Expected output: [1, 4]\n\n    # Test case 3\n    root = TreeNode(5)\n    root.left = TreeNode(4)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(11)\n    root.left.right = TreeNode(13)\n    root.right.left = TreeNode(7)\n    root.right.right = TreeNode(2)\n    print(largestValues(root))  # Expected output: [5, 11]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1091": "```\ndef shortestPathBinaryMatrix(grid):\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    queue = []\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                continue\n            if i == 0 or grid[i-1][j] == 0:\n                queue.append((i, j))\n    visited = set()\n    while queue:\n        x, y = queue.pop(0)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if (nx < 0 or nx >= len(grid) or ny < 0 or ny >= len(grid[0]) or \n                (nx, ny) in visited or grid[nx][ny] == 1):\n                continue\n            queue.append((nx, ny))\n            visited.add((nx, ny))\n    return len(visited)\n\ndef main():\n    print(shortestPathBinaryMatrix([[0,1],[1,0]])) # Output: 2\n    print(shortestPathBinaryMatrix([[0,0,0],[1,1,0],[1,1,1]])) # Output: 3\n    print(shortestPathBinaryMatrix([[0,0,0,0],[1,1,1,0],[1,1,1,0],[1,1,1,0]])) # Output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1092": "```\ndef shortestCommonSupersequence(X, Y):\n    m = len(X)\n    n = len(Y)\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = j\n            elif j == 0:\n                dp[i][j] = i\n            elif X[i - 1] == Y[j - 1]:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1])\n\n    i, j = m, n\n    result = []\n    while i > 0 and j > 0:\n        if X[i - 1] == Y[j - 1]:\n            result.append(X[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] < dp[i][j - 1]:\n            result.append(X[i - 1])\n            i -= 1\n        else:\n            result.append(Y[j - 1])\n            j -= 1\n\n    while i > 0:\n        result.append(X[i - 1])\n        i -= 1\n\n    while j > 0:\n        result.append(Y[j - 1])\n        j -= 1\n\n    return \"\".join(reversed(result))\n\ndef main():\n    print(shortestCommonSupersequence(\"bmd\", \"bm\"))\n    print(shortestCommonSupersequence(\"abc\", \"cab\"))\n    print(shortestCommonSupersequence(\"\", \"\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1093": "```\ndef averageWaitingTime(cw):\n    waiting = [0]\n    for i in range(1, len(cw)):\n        waiting.append(waiting[i-1] + (cw[i] - cw[i-1]))\n    return sum(waiting) / len(waiting)\n\ndef medianWaitingTime(cw):\n    waiting = []\n    for i in range(len(cw)-1):\n        waiting.append(cw[i+1] - cw[i])\n    waiting.sort()\n    mid = len(waiting) // 2\n    if len(waiting) % 2 == 0:\n        return (waiting[mid-1] + waiting[mid]) / 2\n    else:\n        return waiting[mid]\n\ndef numOfBus(busTimes):\n    times = [int(x) for x in busTimes.split(\",\")]\n    n = len(times)\n    i, j = 0, n - 1\n    while j > i:\n        if times[i] % (j-i+1) == 0:\n            return True\n        elif times[j] % (j-i+1) == 0:\n            return False\n        else:\n            mid = (i+j)//2\n            if times[mid] % (j-i+1) == 0:\n                i = mid + 1\n            else:\n                j = mid\n    return True\n\ndef main():\n    print(\"Test Case 1:\")\n    print(numOfBus(\"1,3,2,5,3,7\"))\n    print()\n\n    print(\"Test Case 2:\")\n    print(medianWaitingTime([10,2,5,5,4,11,4]))\n    print()\n\n    print(\"Test Case 3:\")\n    print(averageWaitingTime([10,2,5,5,4,11,4]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1094": "```\ndef canCarPool(trips):\n    total_passengers = 0\n    for trip in trips:\n        total_passengers += trip[0]\n    return total_passengers <= 16\n\ndef main():\n    print(canCarPool([[10,4],[5,3],[5,2]])) # Expected: True\n    print(canCarPool([[1,2],[3,6],[7,9]])) # Expected: False\n    print(canCarPool([[20,8],[10,4],[15,3]])) # Expected: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1095": "```\ndef peakIndexInMountainArray(arr):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < arr[mid+1]:\n            left = mid + 1\n        else:\n            right = mid\n    return left\n\ndef main():\n    print(\"Test case 1:\")\n    arr = [0,2,3,4,5,6,7]\n    result = peakIndexInMountainArray(arr)\n    if result == 2:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n    print(\"\\nTest case 2:\")\n    arr = [0,1,2,8,4]\n    result = peakIndexInMountainArray(arr)\n    if result == 3:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\n    print(\"\\nTest case 3:\")\n    arr = [0,1,2,3,4,5,6,7,8]\n    result = peakIndexInMountainArray(arr)\n    if result == len(arr) - 1:\n        print(\"Pass\")\n    else:\n        print(\"Fail\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1096": "```\ndef expand\u62ec\u53f7expansions(nums):\n    def backtrack(start, path):\n        if start == len(brace_expansion):\n            result.append(\"{\" + \"\".join(path) + \"}\")\n            return\n        for end in range(start, len(brace_expansion)):\n            if brace_expansion[start] != '{' or brace_expansion[end] != '}':\n                continue\n            if end > start:\n                continue\n            if brace_expansion[start+1:end].count('{') > 0 or brace_expansion[start+1:end].count('}') > 0:\n                continue\n            backtrack(end+1, path + [brace_expansion[start+1:end]])\n        return\n\n    result = []\n    brace_expansions(nums)\n    return result\n\ndef main():\n    nums = [\"{a,b}{c,d}\", \"{a,b}{c,d}(1,2)\"]\n    print(expand\u62ec\u53f7expansions(nums))\n\nif __name__ == \"__main__\":\n    main()\n\ntest_case_1 = []\ntest_case_2 = [{\"a\",\"b\"},{\"c\",\"d\"}]\ntest_case_3 = [{\"a\",(\"b\",\"c\")}, {\"d\",\"e\"}]\n```",
  "1097": "```\ndef displayTable(orders):\n    if not orders:\n        return []\n\n    table_header = [\"Player\", \"Score\"]\n    players = list(set([player for order in orders for player in [order[1], order[0]]]))\n    table_body = [[player, 0] for player in players]\n\n    for order in orders:\n        player_score = int(order[2])\n        player_idx = players.index(order[0])\n        table_body[player_idx][1] += player_score\n\n    return [table_header] + table_body\n\n\ndef main():\n    test_cases = [\n        # Test Case 1\n        [[2017, \"bob\", 30], [2016, \"bob\", 10], [2018, \"bob\", 5]],\n        # Test Case 2\n        [[2016, \"bob\", 20], [2015, \"putt\", 3], [2014, \"steve\", 100], [2017, \"steve\", 40]],\n        # Test Case 3\n        []\n    ]\n\n    for test_case in test_cases:\n        print(\"Test Case:\", test_case)\n        print(displayTable(test_case))\n        print()\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1098": "```\ndef mostUnfollowedBooks(books):\n    from collections import Counter\n    counts = [book[1] for book in books]\n    most_unfollowed = max(set(counts), key=counts.count)\n    return [book[0] for book, count in books if count == most_unfollowed]\n\ndef main():\n    books = [[\"Harry Potter\", 3], [\"To Kill a Mockingbird\", 5], [\"1984\", 2], \n             [\"The Great Gatsby\", 1], [\"Pride and Prejudice\", 5]]\n    print(mostUnfollowedBooks(books))  # Output: ['1984', 'The Great Gatsby']\n\n    books = [[\"Python Crash Course\", 10], [\"Learning Python\", 15], \n             [\"Automate the Boring Stuff\", 12], [\"Introduction to Algorithms\", 3], \n             [\"Head First Design Patterns\", 1]]\n    print(mostUnfollowedBooks(books))  # Output: ['Head First Design Patterns', 'Introduction to Algorithms']\n\n    books = [[\"The Little Prince\", 20], [\"1984\", 15], [\"To Kill a Mockingbird\", 18], \n             [\"Pride and Prejudice\", 12], [\"Python Crash Course\", 10]]\n    print(mostUnfollowedBooks(books))  # Output: ['1984', 'The Little Prince']\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1099": "```\ndef twoSumLessThanK(nums, k):\n    nums.sort()\n    res = -1\n    left, right = 0, len(nums) - 1\n    while left < right:\n        if nums[left] + nums[right] < k:\n            res = nums[left] + nums[right]\n            break\n        elif nums[left] + nums[right] >= k:\n            right -= 1\n        else:\n            left += 1\n    return res\n\ndef main():\n    print(twoSumLessThanK([19, 5, 15], 20))  # Expected output: 18\n    print(twoSumLessThanK([1, 2, 3], 10))   # Expected output: -1\n    print(twoSumLessThanK([23, 32, 4, 45], 40))  # Expected output: 38\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1100": "```\ndef subarraysWithKDistinct(A, K):\n    N = len(A)\n    result = []\n    for i in range(N - K + 1):\n        temp_str = ''.join(str(x) for x in A[i:i+K])\n        if len(set(temp_str)) == K:\n            result.append(temp_str)\n    return result\n\ndef main():\n    print(subarraysWithKDistinct(\"Havefunoncodewars\", 5))\n    print(subarraysWithKDistinct(\"abcba\", 1))\n    print(subarraysWithKDistinct(\"wxyz\", 2))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1101": "```\ndef earliestGoodEnoughStep(arr):\n    parent = {i: i for i in range(len(arr))}\n    rank = [0] * len(arr)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        root_x, root_y = find(x), find(y)\n        if root_x != root_y:\n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n            else:\n                parent[root_x] = root_y\n                if rank[root_x] == rank[root_y]:\n                    rank[root_y] += 1\n\n    arr.sort()\n    for i in range(len(arr) - 1):\n        if arr[i + 1] - arr[i] > 1:\n            return arr.index(arr[i]) + 1\n    return -1\n\n\ndef main():\n    print(earliestGoodEnoughStep([0, 2, 3, 5, 8]))  # Output: 3\n    print(earliestGoodEnoughStep([1, 2, 10, 6, 2, 3, 5]))\n    print(earliestGoodEnoughStep([1, 0]))  # Output: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1102": "```\ndef maxMinimumPath(root):\n    def dfs(node):\n        if node:\n            return min(dfs(node.left), dfs(node.right)) + node.val\n\n    res = float('-inf')\n    stack = [(root, root.val)]\n    while stack:\n        node, val = stack.pop()\n        res = max(res, val)\n        for child in [node.left, node.right]:\n            if child:\n                stack.append((child, min(val, child.val) + child.val))\n    return res\n\ndef main():\n    # Test case 1\n    root = TreeNode(6)\n    root.left = TreeNode(2)\n    root.right = TreeNode(8)\n    root.left.left = TreeNode(0)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(3)\n    root.right.right = TreeNode(9)\n    print(maxMinimumPath(root))  # Output: 14\n\n    # Test case 2\n    root = TreeNode(5)\n    root.left = TreeNode(1)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(0)\n    root.left.right = TreeNode(3)\n    root.right.left = TreeNode(4)\n    print(maxMinimumPath(root))  # Output: 8\n\n    # Test case 3\n    root = TreeNode(2)\n    root.left = TreeNode(-1)\n    root.right = TreeNode(10)\n    root.left.left = TreeNode(-1)\n    root.left.right = TreeNode(6)\n    root.right.left = TreeNode(4)\n    print(maxMinimumPath(root))  # Output: 8\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1103": "```\ndef distributeCandies(candles):\n    people = len(candles)\n    candies_per_person = sum(candles) // people\n    remaining_candies = sum(candles) % people\n\n    result = [candies_per_person] * people\n    for i in range(remaining_candies):\n        result[i] += 1\n\n    return result\n\ndef main():\n    print(distributeCandies([2,2,1,1,1,2])) # Output: [2, 2, 2, 1, 1, 1]\n    print(distributeCandies([4,3,2,1,1,*range(1,5)])) # Output: [4, 3, 3, 2, 2, 1]\n    print(distributeCandies([10,9,8,7,6,5])) # Output: [5, 4, 4, 3, 3, 3]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1104": "```\ndef getImportance(employees, id):\n    employee_dict = {employee.id: employee.importance for employee in employees}\n    def dfs(node_id):\n        if node_id == -1:\n            return 0\n        employee = next(employee for employee in employees if employee.id == node_id)\n        return employee.importance + sum(dfs(child) for child in [child.id for child in employee.children])\n\n    return dfs(id)\n\ndef main():\n    employees = [\n        Employee(1, 5),\n        Employee(2, 3),\n        Employee(3, 2),\n        Employee(4, 1),\n        Employee(5, 6),\n        Employee(6, 0)\n    ]\n    \n    print(getImportance(employees, 1)) # Output: 11\n    print(getImportance(employees, 2)) # Output: 6\n    print(getImportance(employees, 3)) # Output: 10\n\nclass Employee:\n    def __init__(self, id, importance, children=None):\n        self.id = id\n        self.importance = importance\n        self.children = children if children else []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1105": "```\ndef fillBookcaseShelves(shelfWidths):\n    shelfWidths.sort()\n    width = 0\n    height = 0\n    for w in shelfWidths:\n        if w > width:\n            width = w\n        else:\n            width += w\n        height = max(height, width)\n    return height\n\ndef main():\n    print(fillBookcaseShelves([1, 2, 4, 5])) # test case 1\n    print(fillBookcaseShelves([3, 5, 10, 12, 13])) # test case 2\n    print(fillBookcaseShelves([1, 3, 5, 7, 9])) # test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1106": "```\ndef parseBoolExpr(expression):\n    def get_value(token):\n        if token == 'true':\n            return True\n        elif token == 'false':\n            return False\n        elif token.isdigit():\n            return int(token) % 2 == 1\n\n    stack = []\n    for token in expression.split(','):\n        token = token.strip()\n        if token[0] == '(':\n            stack.append(get_value(token))\n        elif token[0] in ['&', '|']:\n            op, value = token[0], get_value(token[1:])\n            while stack and stack[-1] is not None and stack[-1] != op:\n                stack.pop()\n            if stack and stack[-1] == op:\n                stack.pop()\n            else:\n                return False\n        elif token[0] == '!':\n            if stack and stack[-1]:\n                stack.pop()\n            else:\n                return True\n    return not stack\n\ndef main():\n    test_cases = [\n        {\"expression\": \"!(T|F)\", \"expected\": False},\n        {\"expression\": \"(T|F)!\", \"expected\": True},\n        {\"expression\": \"(T&F)!\", \"expected\": False}\n    ]\n\n    for test_case in test_cases:\n        expression = test_case[\"expression\"]\n        expected = test_case[\"expected\"]\n\n        result = parseBoolExpr(expression)\n        if result == expected:\n            print(f\"Test case passed: {expression}\")\n        else:\n            print(f\"Test case failed: {expression}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1107": "```\ndef dailyUsers(users):\n    daily_counts = {}\n    for user in users:\n        date = user['date']\n        if date not in daily_counts:\n            daily_counts[date] = set()\n        daily_counts[date].add(user['id'])\n    return {date: len(counts) for date, counts in daily_counts.items()}\n\ndef main():\n    test_cases = [\n        {\n            'users': [{'date': '2019-07-27', 'id': 1}, {'date': '2019-07-28', 'id': 2}],\n            'expected': {'2019-07-27': 1, '2019-07-28': 1}\n        },\n        {\n            'users': [{'date': '2019-08-01', 'id': 3}, {'date': '2019-08-03', 'id': 4}],\n            'expected': {'2019-08-01': 1, '2019-08-03': 1}\n        },\n        {\n            'users': [{'date': '2020-01-02', 'id': 5}, {'date': '2020-01-02', 'id': 6}],\n            'expected': {'2020-01-02': 2}\n        }\n    ]\n\n    for test_case in test_cases:\n        users = [dict(user) for user in test_case['users']]\n        result = dailyUsers(users)\n        assert result == test_case['expected'], f\"Test case failed: {test_case}\"\n        print(f\"Test case passed: {test_case}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1108": "```\ndef defang_ip(address):\n    return address.replace(\".\", \"[.]\")\n\ndef main():\n    print(defang_ip(\"1.1.1.1\"))  # Test case 1\n    print(defang_ip(\"255.255.11.135\"))  # Test case 2\n    print(defang_ip(\"123.45.56.78\"))  # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1109": "```\ndef corpFlightBook(bookingSummary):\n    n = len(bookingSummary)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        if bookingSummary[i][2] > 0:\n            prefix_sum[i+1] = prefix_sum[i] - bookingSummary[i][2]\n        else:\n            prefix_sum[i+1] = prefix_sum[i] + bookingSummary[i][2]\n\n    return [prefix_sum[i+1] for i in range(n)]\n\ndef main():\n    test_cases = [\n        [[10, 20], [30, 40], [-5, -15]], \n        [[1,3],[4,5],[-3,-1]], \n        [[1, 2], [3, 6]]\n    ]\n\n    for test_case in test_cases:\n        booking_summary = [(i, j) + (v if v > 0 else (-v,)) for i, j, *v in test_case]\n        print(\"Booking Summary: \", booking_summary)\n        print(\"Result: \", corpFlightBook(booking_summary))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1110": "```\ndef dfs(root):\n    if not root:\n        return None\n    \n    root.left = dfs(root.left)\n    root.right = dfs(root.right)\n    \n    if not root.left and not root.right:\n        return None\n    else:\n        return root\n\ndef deleteNodes(root, to_delete):\n    if not root:\n        return None\n    \n    if root.val in to_delete:\n        if root.left:\n            root.left = dfs(root.left)\n        if root.right:\n            root.right = dfs(root.right)\n        \n        if not root.left and not root.right:\n            return None\n    else:\n        root.left = deleteNodes(root.left, to_delete)\n        root.right = deleteNodes(root.right, to_delete)\n    \n    if not root.left and not root.right:\n        return None\n    \n    return root\n\ndef printForest(root):\n    if root:\n        print(str(root.val), end=' ')\n        printForest(root.left)\n        printForest(root.right)\n\ndef main():\n    # Test case 1\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    to_delete = [3, 5]\n    res = deleteNodes(root, to_delete)\n    print(\"Test case 1: \")\n    printForest(res)\n\n    # Test case 2\n    root = TreeNode(1)\n    root.right = TreeNode(2)\n    to_delete = [1, 2]\n    res = deleteNodes(root, to_delete)\n    print(\"Test case 2: \")\n    printForest(res)\n\n    # Test case 3\n    root = TreeNode(1)\n    to_delete = []\n    res = deleteNodes(root, to_delete)\n    print(\"Test case 3: \")\n    printForest(res)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1111": "```\ndef maxDepth(stack1, stack2):\n    depth = 0\n    for i in range(min(len(stack1), len(stack2))):\n        if stack1[i] == '(' and stack2[i] == '(':\n            depth += 1\n        elif stack1[i] == ')' and stack2[i] == ')':\n            depth -= 1\n    return max(0, depth)\n\ndef main():\n    print(\"Test case 1:\")\n    print(maxDepth(\"((()))\", \"(()())()\")) # Expected output: 3\n    print()\n\n    print(\"Test case 2:\")\n    print(maxDepth(\"(\", \"()()\") )  # Expected output: 1\n    print()\n\n    print(\"Test case 3:\")\n    print(maxDepth(\"\", \"\") )         # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1112": "```\ndef highest_grade(student_scores):\n    result = {}\n    for student, scores in student_scores.items():\n        max_score = max(scores)\n        result[student] = max_score\n    return result\n\ndef main():\n    student_scores = {\n        \"Alice\": [90, 80, 100],\n        \"Bob\": [70, 60, 50],\n        \"Charlie\": [95, 85, 98]\n    }\n    \n    test_cases = [\n        ({}, {}),\n        ({\"Alice\": [90]}, {\"Alice\": 90}),\n        ({\"Alice\": [90], \"Bob\": [70]}, {\"Alice\": 90, \"Bob\": 70})\n    ]\n    \n    for student_scores, expected in test_cases:\n        result = highest_grade(student_scores)\n        assert result == expected, f\"Test case failed: {student_scores} -> {expected}\"\n        \nif __name__ == \"__main__\":\n    main()\n```",
  "1113": "```\ndef reported_posts(logs):\n    reports = {}\n    for log in logs:\n        if log[0] == 'post':\n            post_id = log[-1]\n        elif log[0] == 'report':\n            post_id = log[2]\n            if post_id not in reports:\n                reports[post_id] = 0\n            reports[post_id] += 1\n    return [post_id for post_id, count in reports.items() if count > 0]\n\ndef main():\n    logs1 = [[\"Female\", \"post\", \"123\"], \n             [\"Male\", \"report\", \"123\", \"JaneDoe\", \"False\"], \n             [\"Male\", \"report\", \"456\", \"JohnSmith\", \"True\"]]\n    print(reported_posts(logs1))  # Expected output: ['123']\n\n    logs2 = [[\"Male\", \"post\", \"789\"], \n             [\"Female\", \"report\", \"789\", \"JaneDoe\", \"False\"]]\n    print(reported_posts(logs2))  # Expected output: []\n\n    logs3 = [[\"Male\", \"post\", \"901\"], \n             [\"Male\", \"post\", \"901\"], \n             [\"Male\", \"report\", \"901\", \"JohnSmith\", \"True\"], \n             [\"Female\", \"report\", \"901\", \"JaneDoe\", \"False\"]]\n    print(reported_posts(logs3))  # Expected output: ['901']\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1114": "```\ndef printInOrder(head):\n    if not head:\n        return\n\n    result = []\n    node = head\n    while node:\n        stack = []\n        temp = node\n        while temp:\n            stack.append(temp.val)\n            temp = temp.next\n        result.extend(stack)\n        node = node.next\n\n    return result\n\ndef main():\n    class ListNode:\n        def __init__(self, val=0, next=None):\n            self.val = val\n            self.next = next\n    \n    # Test case 1: Single element list\n    head1 = ListNode(5)\n    print(printInOrder(head1))  # Output: [5]\n    \n    # Test case 2: List with multiple elements\n    head2 = ListNode(1, ListNode(2), ListNode(3))\n    print(printInOrder(head2))  # Output: [1, 2, 3]\n    \n    # Test case 3: List with cycles\n    head3 = ListNode(1, ListNode(2, ListNode(3)))\n    print(printInOrder(head3))  # Output: [1, 2, 3]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1115": "```\nimport threading\nclass FizzBuzz:\n    def __init__(self, n):\n        self.n = n\n\n    def fizzBuzz(self):\n        for i in range(1, self.n + 1):\n            if i % 3 == 0 and i % 5 != 0:\n                print(\"Fizz\")\n            elif i % 3 != 0 and i % 5 == 0:\n                print(\"Buzz\")\n            elif i % 3 == 0 and i % 5 == 0:\n                print(\"FizzBuzz\")\n            else:\n                print(i)\n\ndef main():\n    f = FizzBuzz(15)\n    t1 = threading.Thread(target=f.fizzBuzz)\n    t2 = threading.Thread(target=lambda: [print(i) for i in range(3,16)])\n\n    t1.start()\n    t2.start()\n\n    t1.join()\n    t2.join()\n\nif __name__ == \"__main__\":\n    main()\n\n# Test Cases:\ntest_case_1 = FizzBuzz(15)\ntest_case_1.fizzBuzz()\n\nprint(\"\\nTest Case 2:\")\ntest_case_2 = FizzBuzz(10)\ntest_case_2.fizzBuzz()\n\nprint(\"\\nTest Case 3:\")\ntest_case_3 = FizzBuzz(20)\ntest_case_3.fizzBuzz()\n```",
  "1116": "```\ndef zeroEvenOdd(nums):\n    result = []\n    for num in nums:\n        if num % 2 == 0: \n            while len([i for i in result if i % 2 == 0]) < len([i for i in nums if i % 2 == 0]):\n                pass\n            result.append(num)\n        else: \n            while len([i for i in result if i % 2 != 0]) < len([i for i in nums if i % 2 != 0]):\n                pass\n            result.append(num)\n    return result\n\ndef main():\n    print(zeroEvenOdd([0,1,0,3,12]))\n    print(zeroEvenOdd([0,1,2,3,4,5,6]))\n    print(zeroEvenOdd([0,2]))\n\nmain()\n```",
  "1117": "```\nimport threading\nfrom queue import Queue\n\nclass Solution:\n    def heightOfBuilding(self, h2oView):\n        n = len(h2oView)\n        heights = [0] * n\n        \n        for i in range(n-1, -1, -1):\n            for j in range(i+1):\n                if h2oView[j] > h2oView[i]:\n                    heights[i] = max(heights[i], j-i+1)\n                    break\n        return heights\n\ndef main():\n    solution = Solution()\n    \n    print(\"Test Case 1:\")\n    h2oView = [8,3,2,5,7,2,4,6,7]\n    print(solution.heightOfBuilding(h2oView))  # Expected: [9,8,8,7,3,2,2,1,0]\n\n    print(\"\\nTest Case 2:\")\n    h2oView = [1,2,3,4,5,6,7,8]\n    print(solution.heightOfBuilding(h2oView))  # Expected: [8,7,6,5,4,3,2,1]\n\n    print(\"\\nTest Case 3:\")\n    h2oView = [0,0,0,0,0,0]\n    print(solution.heightOfBuilding(h2oView))  # Expected: [0,0,0,0,0,0]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1118": "```\ndef daysInMonth(day, month):\n    if day <= 0:\n        return \"Invalid date\"\n    if month < 1 or month > 12:\n        return \"Invalid month\"\n\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 31\n    elif month == 2:\n        if day <= 28:\n            return 28\n        else:\n            return 29\n    else:\n        return 30\n\ndef main():\n    test_cases = [\n        {\"day\": 1, \"month\": 1},\n        {\"day\": 31, \"month\": 3},\n        {\"day\": 28, \"month\": 2}\n    ]\n\n    for test_case in test_cases:\n        day = test_case[\"day\"]\n        month = test_case[\"month\"]\n        result = daysInMonth(day, month)\n        print(f\"Day: {day}, Month: {month} - {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1119": "```\ndef removeVowels(s):\n    vowels = \"aeiouAEIOU\"\n    return \"\".join([char for char in s if char not in vowels])\n\ndef main():\n    print(\"Test case 1:\")\n    print(removeVowels(\"hello world\"))  # Expected output: \"hll wrld\"\n\n    print(\"\\nTest case 2:\")\n    print(removeVowels(\"abcIJKLAEIOU\"))  # Expected output: \"bcJKL\"\n\n    print(\"\\nTest case 3:\")\n    print(removeVowels(\"\"))  # Expected output: \"\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1120": "```\nclass Solution:\n    def maxAverageRatio(self, edges):\n        graph = {i: {} for i in range(len(edges))}\n        for edge in edges:\n            u, v, w = edge\n            graph[u][v] = w / (2 * len(edges))\n            graph[v][u] = w / (2 * len(edges))\n\n        return sum(sum(edge_w) for edge_w in graph.values()) / len(graph)\n\ndef main():\n    solution = Solution()\n    \n    # Test case 1:\n    print(\"Test case 1: \", solution.maxAverageRatio([[0, 1, 5], [1, 2, 5]]))\n    \n    # Test case 2:\n    print(\"Test case 2: \", solution.maxAverageRatio([[0, 1, 10], [5, 2, 15], [3, 4, 10]]))\n    \n    # Test case 3:\n    print(\"Test case 3: \", solution.maxAverageRatio([[0, 1, 3], [1, 2, 2], [2, 3, 2]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1121": "```\ndef maxEqualRowsAfterFlips(grid):\n    if not grid:\n        return []\n\n    max_count = 0\n    sequences = []\n    for row in grid:\n        sequence = [str(int(row[0]))]\n        count = 1\n        for i in range(1, len(row)):\n            if row[i] == row[0]:\n                sequence.append(str(int(row[i])))\n                count += 1\n            else:\n                break\n        sequences.append((sequence, count))\n\n    max_count = max([seq[1] for seq in sequences])\n\n    return [[int(i) for i in seq[0]] for seq in sequences if seq[1] == max_count]\n\ndef main():\n    print(maxEqualRowsAfterFlips([[0,1],[1,1]]))\n    print(maxEqualRowsAfterFlips([[0,1],[1,0]]))\n    print(maxEqualRowsAfterFlips([[0,0,0],[0,0,1],[1,1,1]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1122": "```\ndef relativeSortArray(arr1, arr2):\n    count = {}\n    for num in arr2:\n        if num not in count:\n            count[num] = 0\n        count[num] += 1\n    \n    result = []\n    for num in arr1:\n        if num not in count:\n            if num < 132:\n                result.append(num)\n            else:\n                break\n        else:\n            result.extend([num] * count[num])\n    \n    return sorted(result)\n\ndef main():\n    print(relativeSortArray([2,3,1,3,3,2], [1,2,3]))\n    print(relativeSortArray([4,0,5,1,1,6], [0,6,5,4]))\n    print(relativeSortArray([5,7,6,9,8,1], [1,1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1123": "```\nclass Solution:\n    def lcaOfDeepestLeaves(self, root):\n        if not root:\n            return None\n        \n        def dfs(node, deepest_left, deepest_right):\n            if not node:\n                return deepest_left, deepest_right\n            \n            left_depth, right_depth = 0, 0\n            if node.left:\n                left_depth, left_lca = dfs(node.left, left_depth + 1, None)\n            else:\n                left_lca = None\n                \n            if node.right:\n                right_depth, right_lca = dfs(node.right, 0, left_depth + 1)\n            else:\n                right_lca = None\n            \n            if left_lca and right_lca:\n                return max(left_depth, right_depth) + 1, node\n            elif left_lca:\n                return left_depth + 1, left_lca\n            elif right_lca:\n                return right_depth + 1, right_lca\n            else:\n                return deepest_left, deepest_right\n        \n        deepest_level_lca = dfs(root, float('inf'), float('inf'))\n        \n        while deepest_level_lca[0] > 1:\n            root = root.left if root.right is None else root.right\n            deepest_level_lca = dfs(root, float('inf'), float('inf'))\n        \n        return deepest_level_lca[1]\n\ndef main():\n    s = Solution()\n    \n    # Test case 1:\n    root = TreeNode(3)\n    root.left = TreeNode(5)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(6)\n    root.left.right = TreeNode(2)\n    root.right.left = TreeNode(0)\n    root.right.right = TreeNode(8)\n    root.left.left.left = TreeNode(7)\n    root.left.left.right = TreeNode(4)\n    \n    print(s.lcaOfDeepestLeaves(root).val)  # Output: 4\n    \n    # Test case 2:\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(5)\n    \n    print(s.lcaOfDeepestLeaves(root).val)  # Output: 1\n    \n    # Test case 3:\n    root = TreeNode(1)\n    \n    print(s.lcaOfDeepestLeaves(root))  # Output: None\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \nif __name__ == \"__main__\":\n    main()\n```",
  "1124": "```\ndef longestWPI(self, logs):\n    n = len(logs)\n    res = -1\n    s = {}\n    for i in range(n):\n        if logs[i][1] == 'O':\n            s[i] = s.get(i, 0) + 1\n        else:\n            s.pop(i, None)\n        if i >= 1 and (not s or s[i-1] > 1):\n            res = max(res, i)\n    return res\n\ndef main():\n    logs1 = [[\"5\",\"4\",\"3\"],[\"2\",\"6\",\"7\"],[\"10\",\"11\",\"8\",\"12\",\"9\"]]\n    print(longestWPI(logs1))\n\n    logs2 = [[\"1\",\"3\",\"4\",\"2\"],[\"7\",\"1\",\"3\",\"7\"],[\"7\",\"3\",\"6\",\"1\",\"2\",\"2\"]]\n    print(longestWPI(logs2))\n\n    logs3 = [[\"5,1\",\"4,10\",\"3,15\",\"9,8\",\"5,6\"],[\"1,4\"]]\n    print(longestWPI(logs3))\n\nmain()\n```",
  "1125": "```\ndef smallestSufficient(team):\n    n = len(team)\n    res = []\n    for i in range(1 << n):\n        s = set()\n        for j in range(n):\n            if (i & (1 << j)):\n                s.add(j)\n        if all(k not in s for k in range(n) if team[k]):\n            res.append(i)\n    return min(res)\n\ndef main():\n    print(smallestSufficient([2, 3])) # Expected: [0]\n    print(smallestSufficient([9, 10, 3, 1, 6, 5, 7])) # Expected: [1]\n    print(smallestSufficient([17, 8, 23, 6, 26])) # Expected: [2]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1126": "```\ndef findActiveBusinesses(customers):\n    customer_id_counts = {}\n    for customer in customers:\n        if customer[1] == 'active':\n            if customer[0] in customer_id_counts:\n                customer_id_counts[customer[0]] += 1\n            else:\n                customer_id_counts[customer[0]] = 1\n\n    active_businesses = [customer[0] for customer in customers if customer[1] == 'active' and customer_id_counts.get(customer[0], 0) > 1]\n    return active_businesses\n\n\ndef main():\n    test_cases = [\n        ([[\"John\", \"active\"], [\"Marry\", \"passive\"]], [\"John\"]),\n        ([[\"John\", \"active\"], [\"Mary\", \"active\"], [\"Jane\", \"active\"]], [\"John\", \"Mary\", \"Jane\"]),\n        ([[\"John\", \"active\"], [\"Mary\", \"active\"], [\"Jane\", \"active\"], [\"Alice\", \"passive\"]], [\"John\", \"Mary\", \"Jane\"])\n    ]\n\n    for i, (customers, expected) in enumerate(test_cases):\n        result = findActiveBusinesses(customers)\n        if result == expected:\n            print(f\"Test case {i} passed\")\n        else:\n            print(f\"Test case {i} failed. Expected {expected}, got {result}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1127": "```\ndef num_of_transactions(transactions):\n    transactions.sort(key=lambda x: x[0])\n    i = 1\n    res = []\n    for transaction in transactions:\n        while len(res) > 0 and res[-1][0] == transaction[0]:\n            res.pop()\n        if i < transaction[0]:\n            res.append([transaction[0], 1])\n        else:\n            res.append(transaction)\n        i += 1\n    return [x[1] for x in res]\n\ndef main():\n    test_cases = [\n        {\n            'transactions': [[2019, 2], [2020, 3], [2021, 5]],\n            'expected': 6,\n        },\n        {\n            'transactions': [[2018, 10], [2019, 15], [2020, 20], [2021, 25], [2022, 30]],\n            'expected': 12,\n        },\n        {\n            'transactions': [[2007, 2], [2007, 3], [2014, 6], [2015, 10], [2015, 11]],\n            'expected': 9,\n        }\n    ]\n\n    for test_case in test_cases:\n        print(f'Test Case: {test_case}')\n        transactions = [(t[0], t[1]) for t in test_case['transactions']]\n        res = num_of_transactions(transactions)\n        if res == test_case['expected']:\n            print('Test Case Passed')\n        else:\n            print(f'Expected: {test_case[\"expected\"]}, Got: {res}')\n        print()\n\nif __name__ == '__main__':\n    main()\n```",
  "1128": "```\ndef numEquivDominoPairs(dominoes):\n    count = {}\n    for domino in dominoes:\n        s = str(sorted([domino[0], domino[1]]))\n        if s in count:\n            count[s] += 1\n        else:\n            count[s] = 1\n    return sum(val // 2 for val in count.values())\n\ndef main():\n    print(numEquivDominoPairs([[1,2],[1,3],[2,3]]) == 2)\n    print(numEquivDominoPairs([[1,2],[1,1],[3,4],[3,5]])) == 2\n    print(numEquivDominoPairs([[1,2],[2,1],[1,1],[1,2]])) == 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1129": "```\nfrom collections import deque\n\nclass Solution:\n    def shortestAlternatingPath(self, root: 'Node', n: int) -> int:\n        if not root:\n            return 0\n        queue = deque([(root, 0, 0)])\n        ans = float('inf')\n        while queue:\n            node, level, color = queue.popleft()\n            if node.left and (color == 0 or node.left.val != node.val):\n                queue.append((node.left, level + 1, 1 - color))\n            if node.right and (color == 0 or node.right.val != node.val):\n                queue.append((node.right, level + 1, 1 - color))\n            if not node.left and not node.right:\n                ans = min(ans, level)\n        return ans\n\nclass Node:\n    def __init__(self, val: int, left: 'Node' = None, right: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef main():\n    root1 = Node(0)\n    node2 = Node(1);node3 = Node(2);node4 = Node(3);\n    node5 = Node(4);node6 = Node(5);node7 = Node(6);\n    node8 = Node(7);node9 = Node(8);node10 = Node(9);\n\n    root1.left = node2;root1.right = node3;\n    node2.left = node4;node2.right = node5;\n    node3.left = node6;node3.right = node7;\n    node4.left = node8;node4.right = node9;\n    node5.left = node10;\n\n    print(Solution().shortestAlternatingPath(root1, 3))\n\n    root2 = Node(0)\n    node1 = Node(1);node2 = Node(2);\n\n    root2.left = node1;root2.right = node2;\n\n    print(Solution().shortestAlternatingPath(root2, 2))\n\n    root3 = Node(0)\n    node1 = Node(1);node2 = Node(2);node3 = Node(3);\n    node4 = Node(4);node5 = Node(5);\n\n    root3.left = node1;root3.right = node2;\n    node2.left = node3;node2.right = node4;\n    node3.left = node5;\n\n    print(Solution().shortestAlternatingPath(root3, 5))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1130": "```\ndef mctFromLeafValues(root):\n    pass\n\ndef main():\n    root1 = TreeNode(6)\n    root1.left = TreeNode(4)\n    root1.right = TreeNode(8)\n    root1.left.left = TreeNode(2)\n    root1.left.right = TreeNode(5)\n    root1.right.left = TreeNode(7)\n    root1.right.right = TreeNode(9)\n\n    root2 = TreeNode(4)\n    root2.left = TreeNode(1)\n    root2.right = TreeNode(11)\n    root2.left.left = TreeNode(3)\n    root2.left.right = TreeNode(5)\n    root2.right.left = TreeNode(6)\n    root2.right.right = TreeNode(7)\n\n    root3 = TreeNode(2)\n    root3.left = TreeNode(1)\n    root3.right = TreeNode(3)\n\n    print(mctFromLeafValues(root1))\n    print(mctFromLeafValues(root2))\n    print(mctFromLeafValues(root3))\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1131": "```\ndef maximumSize(arr):\n    n = len(arr)\n    res = 0\n    for i in range(1, n - 1):\n        left_sum = sum(arr[:i])\n        right_sum = sum(arr[i+1:])\n        if abs(left_sum) > abs(right_sum):\n            res = max(res, i + 1)\n        else:\n            res = max(res, n - i - 1)\n    return res\n\ndef main():\n    print(maximumSize([-3,-6,7,-4,-1,8])) \n    print(maximumSize([10,2]))  \n    print(maximumSize([-1,-2,1,1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1132": "```\ndef getReportedUsers(users):\n    reported_users = {}\n    for user in users:\n        if user[7] == \"report\":\n            if user[5] not in reported_users:\n                reported_users[user[5]] = 1\n            else:\n                reported_users[user[5]] += 1\n    return [user[0] for user in users if user[5] in reported_users and reported_users[user[5]] > 1]\n\ndef main():\n    users = [\n        [\"A\", \"B\", \"C\", \"D\", \"report\"],\n        [\"E\", \"F\", \"G\", \"H\", \"like\"],\n        [\"I\", \"J\", \"K\", \"L\", \"report\"],\n        [\"M\", \"N\", \"O\", \"P\", \"report\"],\n        [\"Q\", \"R\", \"S\", \"T\", \"report\"]\n    ]\n    print(getReportedUsers(users))\n\nmain()\n```",
  "1133": "```\ndef largestUniqueNumber(nums):\n    count_dict = {}\n    for num in nums:\n        if num not in count_dict:\n            count_dict[num] = 1\n        else:\n            count_dict[num] += 1\n\n    unique_nums = sorted([num for num, count in count_dict.items() if count == 1])\n\n    return -1 if not unique_nums else unique_nums[-1]\n\ndef main():\n    print(largestUniqueNumber([5,7,3,9,2,9,3,7,9])) \n    print(largestUniqueNumber([4, 2, 6, 3, 5, 1])) \n    print(largestUniqueNumber([11,15,26]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1134": "```\ndef is_armstrong(n):\n    num_str = str(n)\n    num_len = len(num_str)\n    sum_digits = sum([int(digit) ** num_len for digit in num_str])\n    return n == sum_digits\n\ndef main():\n    print(is_armstrong(371))  # True\n    print(is_armstrong(123))  # False\n    print(is_armstrong(153))  # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1135": "```\nimport heapq\nclass Solution:\n    def minimumCost(self, n: int, connections: List[List[int]]) -> int:\n        parent = list(range(n))\n        rank = [0] * n\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            root_x = find(x)\n            root_y = find(y)\n            if root_x == root_y:\n                return\n            if rank[root_x] > rank[root_y]:\n                parent[root_y] = root_x\n            else:\n                parent[root_x] = root_y\n                if rank[root_x] == rank[root_y]:\n                    rank[root_y] += 1\n\n        connections.sort(key=lambda x: x[2])\n        total_cost = 0\n        for edge in connections:\n            union(edge[0], edge[1])\n            if len(set(find(i) for i in range(n))) == 1:\n                total_cost += edge[2]\n                break\n        return total_cost\n\ndef main():\n    solution = Solution()\n    \n    print(solution.minimumCost(3, [[1, 2, 5], [3, 4, 6]])) # Output: 7\n    print(solution.minimumCost(4, [[0, 1, 10], [0, 2, 6], [1, 2, 15]])) # Output: 20\n    print(solution.minimumCost(8, [[0, 1, 5], [1, 7, 6], [7, 4, 3], [4, 2, 3], [3, 7, 10], [0, 2, 12]])) # Output: 22\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1136": "```\ndef scheduleCourses(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    visited = [0] * numCourses\n    recStack = [False] * numCourses\n\n    for x, y in prerequisites:\n        graph[y].append(x)\n\n    def canFinish(index):\n        if recStack[index]:\n            return False\n        if visited[index] == -1:\n            return False\n        visited[index] = -1\n        while index < len(graph):\n            if not canFinish(index):\n                return False\n            index += 1\n        return True\n\n    def topologicalSortUtil(v):\n        recStack[v] = True\n        for w in graph[v]:\n            if recStack[w]:\n                return False\n            if visited[w] == -1:\n                if not topologicalSortUtil(w):\n                    return False\n        recStack[v] = False\n        return True\n\n    for i in range(numCourses):\n        if visited[i] == 0:\n            if not topologicalSortUtil(i):\n                return []\n    return [i for i in range(numCourses) if visited[i] == -1]\n\ndef main():\n    print(scheduleCourses(2, [[1,0]])) # expected output: [0,1]\n    print(scheduleCourses(3, [[1,0],[2,0]])) # expected output: []\n    print(scheduleCourses(4, [[1,0],[2,0],[3,1],[3,2]])) # expected output: [0,1,2,3]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1137": "```\ndef tribonacci(n):\n    if n == 0:\n        return 0\n    if n <= 2:\n        return 1\n    memo = [0] * (n + 1)\n    memo[0], memo[1], memo[2] = 0, 1, 1\n    for i in range(3, n + 1):\n        memo[i] = memo[i - 1] + memo[i - 2] + memo[i - 3]\n    return memo[n]\n\ndef main():\n    print(\"Test case 1:\")\n    print(tribonacci(4))  # Output: 7\n\n    print(\"\\nTest case 2:\")\n    print(tribonacci(25))  # Output: 1389537\n\n    print(\"\\nTest case 3:\")\n    print(tribonacci(30))  # Output: 1548008755\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1138": "```\ndef alphabetBoardPath(target: str) -> str:\n    board = set('abcdefghijklmnopqrstuvwxyz')\n    res = []\n    pos = (0, 0)\n    \n    for c in target.lower():\n        dx, dy = {'a': (-1, 0), 'b': (-1, 1), 'c': (0, 1), 'd': (1, 1),\n                  'e': (2, 1), 'f': (3, 1), 'g': (4, 1), 'h': (5, 1),\n                  'i': (6, 1), 'j': (7, 1), 'k': (8, 1), 'l': (9, 1),\n                  'm': (10, 1), 'n': (11, 1), 'o': (12, 1), 'p': (13, 1),\n                  'q': (14, 1), 'r': (15, 1), 's': (16, 1), 't': (17, 1),\n                  'u': (18, 1), 'v': (19, 1), 'w': (20, 1), 'x': (21, 1),\n                  'y': (22, 1), 'z': (23, -1)}[c]\n        \n        if c == 'a':\n            res.append('moveTop')\n        elif c == 'z' and pos == (0, 0):\n            res.append('moveBottom')\n        else:\n            if pos[0] < pos[1]:\n                res.append('moveLeft')\n            elif pos[0] > pos[1]:\n                res.append('moveRight')\n            pos = (pos[0] + dx, pos[1] + dy)\n    \n    return ' '.join(res)\n\ndef main():\n    print(alphabetBoardPath(\"aaa\")) \n    print(alphabetBoardPath(\"zjzp\")) \n    print(alphabetBoardPath(\"a\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1139": "```\ndef longestOnes(nums):\n    if not nums:\n        return 0\n    \n    n = len(nums)\n    max_len = 0\n    ones_count = 0\n    \n    for i in range(n):\n        if nums[i] == 1:\n            ones_count += 1\n        else:\n            ones_count = 0\n        \n        max_len = max(max_len, ones_count)\n\n    return max_len\n\ndef main():\n    print(longestOnes([1,1,1,0,0,0])) # Expected: 4\n    print(longestOnes([0,1,1,0,1]))   # Expected: 4\n    print(longestOnes([1,1,0,1,1,1,0,0])) # Expected: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1140": "```\ndef stoneGameII(stone):\n    n = len(stone)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + stone[i]\n    \n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n    \n    for i in range(1, n + 1):\n        for j in range(i):\n            if prefix_sum[i] - prefix_sum[j] >= (i + j) // 2:\n                dp[i][j] = (dp[i][j] or\n                            any(dp[k][max(0, j - x)] and k <= i for x in range(j)))\n    \n    return min(x for x in range(n + 1) if not any(dp[n][x] for y in range(x)))\n\ndef main():\n    print(stoneGameII([5]))  # Output: 2\n    print(stoneGameII([6,8,14,7,15]))  # Output: 3\n    print(stoneGameII([1,2,3,44,10,20]))  # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1141": "```\ndef ActivityNotifications(candidature, d):\n    n = len(candidature)\n    count = 0\n    for i in range(n - 7):\n        if sorted([candidature[i + j] for j in range(7)]) >= [m * 2 for m in sorted([candidature[i + j] for j in range(7)])]:\n            count += 1\n    return count\n\n\ndef main():\n    print(ActivityNotifications([12, 17, 15, 13, 10, 20], 3))\n    print(ActivityNotifications([2, 7, 9, 4, 3, 1], 5))\n    print(ActivityNotifications([1, 3, 2, 8, 1, 7, 2, 6, 2, 4, 3, 1], 10))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1142": "```\ndef activityNotifications(coders, days):\n    notifications = 0\n    for i in range(len(coders) - 7):\n        if sorted([coders[i+j] for j in range(7)]) >= [coders[i+3], coders[i+4]]:\n            notifications += 1\n    return notifications\n\ndef main():\n    test_cases = [\n        {\"coders\": [1,2,3,4,5,6,7,8,9,10,11], \"expected\": 0},\n        {\"coders\": [1,2,3,4,4,4,4,4,4,4,4], \"expected\": 3},\n        {\"coders\": [1,1,1,1,1,1,1,1,1,1,1], \"expected\": 0}\n    ]\n    \n    for test_case in test_cases:\n        coders = test_case[\"coders\"]\n        expected = test_case[\"expected\"]\n        result = activityNotifications(coders, 7)\n        \n        if result == expected:\n            print(\"Test case passed: \", end='')\n        else:\n            print(\"Test case failed: \")\n            \n        print(f\"Expected {expected}, got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1143": "```\ndef longest_common_subsequence(text1, text2):\n    m = len(text1)\n    n = len(text2)\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if text1[i - 1] == text2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    lcs = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if text1[i - 1] == text2[j - 1]:\n            lcs.append(text1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return ''.join(reversed(lcs))\n\ndef main():\n    print(longest_common_subsequence(\"ABCBDAB\", \"BDCABA\") == \"BCBA\")\n    print(longest_common_subsequence(\"passport\", \"ppssppp\") == \"pspp\")\n    print(longest_common_subsequence(\"\", \"\") == \"\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1144": "```\ndef movesToMakeZigzag(nums):\n    n = len(nums)\n    ans = [[0]*n for _ in range(2)]\n    \n    for i in range(n):\n        left = max(0, i-1) if i%2==0 else min(i-1, n-1)\n        right = min(i+1, n-1) if i%2==1 else 0\n        ans[i%2][i] = (nums[left]+abs(nums[right]-nums[i])) % 2 == 0 and abs(nums[left]-nums[i]) or abs(nums[right]-nums[i])\n        \n    return sum(max(row) for row in ans)\n\ndef main():\n    print(movesToMakeZigzag([9,6,6,6,3,8])) # Output: 10\n    print(movesToMakeZigzag([17,13,1,5]) # Output: 15\n    print(movesToMakeZigzag([1,2,3,4,7,6,5,9,8,3,2,1])) # Output: 26\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1145": "```\nclass Solution:\n    def minCameraCover(self, root):\n        if not root:\n            return 0\n\n        self.res = float('inf')\n        def dfs(node, parent, has_cam):\n            if node.val == '#':\n                return\n            left_has_cam = False\n            right_has_cam = False\n            if node.left:\n                if node.left.val == '#':\n                    left_has_cam = True\n                else:\n                    dfs(node.left, node, has_cam)\n            if node.right:\n                if node.right.val == '#':\n                    right_has_cam = True\n                else:\n                    dfs(node.right, node, has_cam | left_has_cam)\n\n            if not has_cam and (node == root or parent is None):\n                self.res = min(self.res, 1)\n            elif not has_cam and (not left_has_cam and not right_has_cam):\n                self.res = min(self.res, 2)\n\n        dfs(root, None, False)\n        return self.res\n\n\ndef main():\n    s = Solution()\n    \n    root1 = TreeNode(0)\n    node1 = TreeNode(1)\n    node2 = TreeNode(0)\n    node3 = TreeNode(0)\n    node4 = TreeNode(1)\n    node5 = TreeNode(2)\n    node6 = TreeNode(0)\n\n    root1.left = node1\n    root1.right = node2\n    node1.left = node3\n    node1.right = node4\n    node2.left = node5\n    node2.right = node6\n\n    print(s.minCameraCover(root1))  # Expected output: 4\n\n    root2 = TreeNode(0)\n    node7 = TreeNode(1)\n\n    root2.left = node7\n\n    print(s.minCameraCover(root2))  # Expected output: 1\n\n    root3 = TreeNode(0)\n\n    print(s.minCameraCover(root3))  # Expected output: 0\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n\nif __name__ == \"__main__\":\n    main()\n\n```",
  "1146": "```\ndef snapshotArray(self, length: int, queries):\n    snaps = [0] * (length + 1)\n    res = []\n    \n    for i, query in enumerate(queries):\n        if query[0] == 1:\n            snaps[query[1]] += query[2]\n        else:\n            index = bisect.bisect_left(snaps, query[1])\n            res.append(snaps[index] + query[2])\n\n    return res\n\ndef main():\n    array = SnapshotArray(3)\n    print(array.snapshotArray(5, [[1,0,5],[4,0,6],[2,1,3],[1,1,10],[1,2,15]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1147": "```\ndef longest_decompression(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    rev_s = s[::-1]\n    \n    for i in range(n):\n        for j in range(i + 1):\n            if s[j:i + j + 1] == rev_s[i - j:]:\n                dp[i][j] = i - j + 1\n            else:\n                dp[i][j] = max(dp[i - 1][k] for k in range(j))\n    \n    return max(max(row) for row in dp)\n\ndef main():\n    print(longest_decompression(\"ababa\")) # Output: 4\n    print(longest_decompression(\"abca\")) # Output: 2\n    print(longest_decompression(\"dba\")) # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1148": "```\ndef numUniqueEmails(emails):\n    unique_emails = set()\n    for email in emails:\n        local_name, domain = email.split('@')\n        if '.' in local_name:\n            local_name = local_name[:local_name.index('.')]\n        new_email = f'{local_name}@{domain}'\n        unique_emails.add(new_email)\n    return len(unique_emails)\n\ndef main():\n    test_case1 = [\"john.doe@joe.com\",\"anna.mary@love.com\",\"john.smith@hike.com\"]\n    print(\"Test Case 1: \", numUniqueEmails(test_case1))\n    \n    test_case2 = [\"test.email+alex@leetcode.com\",\"test.eam+alex@codewars.com\"]\n    print(\"Test Case 2: \", numUniqueEmails(test_case2))\n\n    test_case3 = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"]\n    print(\"Test Case 3: \", numUniqueEmails(test_case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1149": "```\ndef totalViews(article_id):\n    views = {\n        'A': [1, 2, 3, 4],\n        'B': [0, 0, 5, 6],\n        'C': [7, 8]\n    }\n    \n    return sum(views.get(str(article_id), []))\n\ndef main():\n    print(\"Case 1: A\")\n    print(totalViews('A'))  # Output: 10\n    \n    print(\"\\nCase 2: B\")\n    print(totalViews('B'))  # Output: 6\n    \n    print(\"\\nCase 3: C\")\n    print(totalViews('C'))  # Output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1150": "```\ndef majorityElement(nums):\n    if not nums:\n        return False\n\n    n = len(nums)\n    target = nums[n//2]\n\n    left, right = 0, n-1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            if mid == n//2 or nums[mid - 1] != target:\n                return True\n            right = mid - 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return False\n\n\ndef main():\n    print(majorityElement([2,7,7,5])) # True\n    print(majorityElement([2,4,5])) # False\n    print(majorityElement([2,7,7,5,7,7,7])) # True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1151": "```\ndef minSwaps(arr):\n    n = len(arr)\n    ones = arr.count(1)\n    swaps = 0\n    left, right = 0, ones - 1\n    while left <= right:\n        if arr[left] == 0 and arr[right] == 1:\n            arr[left], arr[right] = arr[right], arr[left]\n            swaps += 1\n            left += 1\n            right -= 1\n        elif arr[left] == 1:\n            left += 1\n        else:\n            right -= 1\n    return swaps\n\ndef main():\n    print(minSwaps([0, 0, 1, 1, 1, 1, 0, 1]))\n    print(minSwaps([0, 0, 0, 1, 1]))\n    print(minSwaps([0]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1152": "```\ndef mostVisited(pattern):\n    max_visit = 0\n    prev_visit = -1\n    for i in range(len(pattern) - 1):\n        if pattern[i] == 'A':\n            curr_visit = i + 1\n        else:\n            curr_visit = prev_visit + 1\n        max_visit = max(max_visit, curr_visit)\n        prev_visit = curr_visit\n    return [prev_visit + 1, max_visit]\n\ndef main():\n    test_cases = [\n        {\"pattern\": \"randomemail123\", \"expected_output\": [0, 0]},\n        {\"pattern\": \"AAB\", \"expected_output\": [2, 2]},\n        {\"pattern\": \"AAABAAA\", \"expected_output\": [3, 5]}\n    ]\n\n    for test_case in test_cases:\n        pattern = list(test_case[\"pattern\"])\n        output = mostVisited(pattern)\n        assert output == test_case[\"expected_output\"], f\"Test case failed for {test_case}\"\n\n    print(\"All test cases passed!\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1153": "```\ndef canConvert(str1, str2):\n    if len(str1) != len(str2):\n        return False\n    count = {}\n    for i in range(len(str1)):\n        if str1[i] == str2[i]:\n            continue\n        if str1[i] not in count:\n            count[str1[i]] = 0\n        if str2[i] not in count:\n            count[str2[i]] = 0\n        count[str1[i]] += 1\n        count[str2[i]] -= 1\n    for k, v in count.items():\n        if v > 0:\n            return False\n    return True\n\ndef main():\n    print(canConvert(\"aabcc\", \"cadbb\"))  # Expected output: true\n    print(canConvert(\"leetcode\", \"leotcede\"))  # Expected output: false\n    print(canConvert(\"eaxy\", \"bazy\"))  # Expected output: true\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1155": "```\ndef numRollsToTarget(n: int, k: int, target: int) -> int:\n    dp = [[0] * (target + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, target + 1):\n            for roll in range(1, min(k, j) + 1):\n                if j - roll >= 0:\n                    dp[i][j] += dp[i - 1][j - roll]\n    return dp[n][target]\n\ndef main():\n    print(numRollsToTarget(2, 6, 7)) \n    print(numRollsToTarget(3, 6, 10))\n    print(numRollsToTarget(4, 5, 14))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1154": "```\ndef day_of_year(date):\n    month_days = [31,28,31,30,31,30,31,31,30,31,30,31]\n    if date.month < 1 or date.month > 12:\n        return \"Invalid month\"\n    if date.day < 1 or date.day > month_days[date.month - 1]:\n        return \"Invalid day\"\n\n    total_days = 0\n    for i in range(1, date.month):\n        total_days += month_days[i - 1]\n    return str(total_days + date.day)\n\nimport unittest\n\nclass TestDayOfTheYear(unittest.TestCase):\n\n    def test_case_1(self):\n        from datetime import datetime\n        self.assertEqual(day_of_year(datetime(2020, 3, 15)), '80')\n\n    def test_case_2(self):\n        from datetime import datetime\n        self.assertEqual(day_of_year(datetime(2020, 12, 25)), '365')\n\n    def test_case_3(self):\n        from datetime import datetime\n        self.assertEqual(day_of_year(datetime(2021, 6, 30)), '181')\n\nif __name__ == '__main__':\n    unittest.main()\n```",
  "1156": "```\ndef maxRepeats(s):\n    n = len(s)\n    seen = {}\n    for i in range(n):\n        for j in range(i+1, n):\n            sub = s[i:j]\n            if sub in seen:\n                seen[sub] += 1\n            else:\n                seen[sub] = 1\n\n    max_len = 0\n    res = \"\"\n    for k, v in seen.items():\n        if v > 1 and len(k) > max_len:\n            max_len = len(k)\n            res = k\n\n    return res\n\n\ndef main():\n    print(maxRepeats(\"ababa\")) \n    print(maxRepeats(\"abcabcabc\"))\n    print(maxRepeats(\"abcdefg\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1157": "```\nclass MajorityChecker:\n\n    def __init__(self, nums):\n        self.nums = nums\n\n    def query(self, left: int, right: int) -> int:\n        return max((num for num in self.nums[left:right+1] if self.nums.count(num) > len(self.nums)/2), key=lambda x: self.nums.count(x)).pop()\n\ndef main():\n    checker = MajorityChecker([1,2,2,1,1])\n    print(checker.query(0, 5)) # prints 1\n    print(checker.query(4, 8)) # prints 1\n    print(checker.query(3, 6)) # prints 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1158": "```\ndef max_profit_price(holding, transaction):\n    if not holding:\n        return 0\n    max_profit = 0\n    min_price = holding[0]\n    for price in holding:\n        if price < min_price:\n            min_price = price\n        elif price - min_price > max_profit:\n            max_profit = price - min_price\n            transaction.append(price)\n    return max_profit, transaction\n\ndef main():\n    test_cases = [\n        # Test case 1: Single peak\n        ([7, 1, 5, 3, 6, 4], [5]),\n        \n        # Test case 2: Multiple peaks and valleys\n        ([7, 2, 5, 3, 9, 4, 8, 1, 3, 7], [9, 8]),\n        \n        # Test case 3: No peak\n        ([1, 2, 3, 4, 5], []),\n    ]\n    \n    for test_case in test_cases:\n        holding, expected = test_case\n        max_profit, transaction = max_profit_price(holding, [])\n        print(f\"Test case {holding}:\")\n        if max_profit == expected[0]:\n            print(\"Pass\")\n        else:\n            print(f\"Fail: Expected {expected[0]} but got {max_profit}\")\n        if set(transaction) == set(expected):\n            print(\"Transaction is correct\")\n        else:\n            print(\"Transaction failed\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1159": "```\ndef marketAnalysisII(accounts):\n    transactions = {}\n    for account in accounts:\n        for transaction in account[1]:\n            if transaction[0] not in transactions:\n                transactions[transaction[0]] = 0\n            if transaction[2] > 0:\n                transactions[transaction[0]] += transaction[2]\n            elif transaction[2] < 0:\n                transactions[transaction[0]] -= transaction[2]\n\n    return list(transactions.items())\n\ndef main():\n    test_case1 = [[[\"LC114.10\",\"BUY\",\"100\"],[\"LC114.15\",\"SELL\",\"50\"]],]\n    print(marketAnalysisII(test_case1))\n    \n    test_case2 = [[[ \"LC114.10\", \"BUY\", 100 ],[ \"LC114.12\", \"SELL\", 20 ]],\n                   [[ \"LC114.13\", \"BUY\", 80 ],\n                    [ \"LC114.15\", \"SELL\", 40 ]]]\n    print(marketAnalysisII(test_case2))\n    \n    test_case3 = [[[ \"LC114.10\", \"BUY\", 100 ]]]\n    print(marketAnalysisII(test_case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1160": "```\ndef wordCount(strs):\n    words = strs[0].split()\n    charSet = set(strs[1])\n    \n    def dfs(word):\n        for ch in word:\n            if ch not in charSet:\n                return False\n            charSet.remove(ch)\n        return True\n    \n    return [word for word in words if dfs(word)]\n\ndef main():\n    print(wordCount([\"apple pen to\", \"write five blueline lines\", \"these words will be ignored because they are too common\"]))\n    print(wordCount([\"Words\", \"words\"], [\"Wrd\", \"wrds\"]))\n    print(wordCount([], [\"a\", \"b\", \"c\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1161": "```\nclass Solution:\n    def maxLevelSum(self, root):\n        if not root:\n            return []\n        \n        result = []\n        queue = [(root, 1)]\n        \n        while queue:\n            level_sum = sum(node.val for node in [node for node, _ in queue])\n            result.append([level_sum, len(queue)])\n            new_queue = [(child, parent_level + 1) for node, parent_level in queue \n                         for child in [node.left, node.right] if child]\n            queue = new_queue\n        \n        return result\n\ndef main():\n    solution = Solution()\n    \n    root = TreeNode(1)\n    root.left = TreeNode(14)\n    root.right = TreeNode(0)\n    root.left.left = TreeNode(-3)\n    root.left.right = TreeNode(9)\n    root.right.left = TreeNode(4)\n    root.right.right = TreeNode(6)\n\n    print(solution.maxLevelSum(root))  # Expected output: [[14], [11]]\n\n    root = TreeNode(5)\n    root.left = TreeNode(2)\n    root.left.left = TreeNode(-3)\n\n    print(solution.maxLevelSum(root))  # Expected output: [[9]]\n\n    root = TreeNode(1)\n    root.right = TreeNode(4)\n    root.right.left = TreeNode(-2)\n    root.right.right = TreeNode(5)\n\n    print(solution.maxLevelSum(root))  # Expected output: [[6], [6]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1162": "```\ndef maxDistance(grid):\n    if not grid:\n        return -1\n\n    m, n = len(grid), len(grid[0])\n    queue = []\n    visited = [[False] * n for _ in range(m)]\n    max_distance = 0\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1:\n                queue.append((i, j))\n                visited[i][j] = True\n\n    while queue:\n        q_size = len(queue)\n        for _ in range(q_size):\n            x, y = queue.pop(0)\n            if (x - 1 >= 0 and not visited[x-1][y]) or \\\n               (x + 1 < m and not visited[x+1][y]) or \\\n               (y - 1 >= 0 and not visited[x][y-1]) or \\\n               (y + 1 < n and not visited[x][y+1]):\n                max_distance = q_size\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if (0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 0):\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n\n    return max_distance\n\n\ndef main():\n    print(maxDistance([[1,0],[0,0]])) # Expected: 1\n    print(maxDistance([[1,0,1],[0,0,0],[1,0,1]])) # Expected: 2\n    print(maxDistance([[1,0,0],[0,0,0],[0,0,0]])) # Expected: 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1163": "```\ndef lastSubstr(s):\n    n = len(s)\n    res = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substr = s[i:j]\n            if not any(substr < sub for sub in res) and all(c1 >= c2 or (c1 == c2 and str1 <= str2) for str1, str2 in zip(substr, s)):\n                res.append(substr)\n    return max(res)\n\ndef main():\n    print(lastSubstr(\"abab\"))\n    print(lastSubstr(\"abcfgcbdfedfcbeedcfdecdbfdecfd\"))\n    print(lastSubstr(\"aaa\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1165": "```\ndef calculateTime(keyboard: str, word: str) -> int:\n    time = 0\n    for c in word:\n        time += min((keyboard.index(c) + len(str(keyboard)) - keyboard.index(c)), (len(keyboard) - keyboard.index(c)))\n    return time\n\ndef main():\n    print(\"Test case 1:\")\n    print(calculateTime(\"abcdefghijklmnopqrstuvwxyz\", \"alex\")) # Expected output: 6\n    print(\"\\nTest case 2:\")\n    print(calculateTime(\"abcdefghijklmnopqrstuvwxyz\", \"sao\")) # Expected output: 7\n    print(\"\\nTest case 3:\")\n    print(calculateTime(\"abcdefghijklmnopqrstuvwxyz\", \"a\")) # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1164": "```\ndef product_price_at_given_date(prices, date):\n    result = {}\n    for i in range(len(prices)):\n        if prices[i][1] <= date:\n            result[prices[i][0]] = prices[i][2]\n    return result\n\n\ndef main():\n    test_cases = [\n        ([\n            [\"ProductA\", \"2021-01-01\", 10.0],\n            [\"ProductB\", \"2021-01-02\", 20.0],\n            [\"ProductC\", \"2021-03-15\", 30.0]\n        ], \"2021-01-05\", \n         {\"ProductA\": 10.0, \"ProductB\": 20.0}\n        ),\n        \n        ([\n            [\"ProductX\", \"2022-02-28\", 5.0],\n            [\"ProductY\", \"2022-03-01\", 10.0]\n        ], \"2022-02-27\",\n         {\"ProductX\": 5.0}\n        ),\n        \n        ([\n            [\"Product1\", \"2019-01-01\", 100.0],\n            [\"Product2\", \"2019-12-31\", 200.0]\n        ], \"2020-01-01\",\n         {}\n        )\n    ]\n\n    for test_case in test_cases:\n        result = product_price_at_given_date(test_case[0], test_case[1])\n        print(f\"Test case: {test_case} | Expected output: {test_case[2]} | Actual output: {result}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1166": "```\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.is_file = False\n\nclass FileSystem:\n    def __init__(self):\n        self.root = Node()\n\n    def mkdir(self, path: str) -> None:\n        current_node = self.root\n        for dir in path.split('/'):\n            if dir:\n                if dir not in current_node.children:\n                    current_node.children[dir] = Node()\n                current_node = current_node.children[dir]\n\n    def addContentToFile(self, filePath: str, content: str) -> None:\n        current_node = self.root\n        for dir in filePath.split('/'):\n            if dir:\n                current_node = current_node.children[dir]\n        file_name = filePath.split('/')[-1]\n        current_node.is_file = True\n        if 'content' not in current_node.children:\n            current_node.children['content'] = ''\n        current_node.children['content'] += content\n\n    def readContent(self, filePath: str) -> str:\n        current_node = self.root\n        for dir in filePath.split('/'):\n            if dir:\n                current_node = current_node.children[dir]\n        file_name = filePath.split('/')[-1]\n        return current_node.children['content']\n\ndef main():\n    fs = FileSystem()\n    fs.mkdir(\"/a\")\n    fs.mkdir(\"/a/b/c\")\n    print(fs.readContent(\"/a/b/c\"))  # Should print \"\"\n    fs.addContentToFile(\"/a/b/c\", \"hello\");\n    print(fs.readContent(\"/a/b/c\"))  # Should print \"hello\"\n    fs.addContentToFile(\"/a/b/c\", \"world\");\n    print(fs.readContent(\"/a/b/c\"))  # Should print \"helloworld\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1167": "```\ndef connectSticks(sticks):\n    if not sticks:\n        return 0\n    \n    sticks.sort()\n    \n    heap = [sticks[0], sticks[1]]\n    cost = 0\n    \n    for stick in sticks[2:]:\n        heapq.heappop(heap)\n        cost += stick\n        heapq.heappush(heap, stick + heap[0])\n    \n    return cost\n\ndef main():\n    test_cases = [\n        ([2], 4),\n        ([3, 4, 7], 11),\n        ([10, 5, 3], 16)\n    ]\n    \n    for sticks, expected_cost in test_cases:\n        actual_cost = connectSticks(sticks)\n        if actual_cost == expected_cost:\n            print(f\"Test case passed: {sticks} -> {actual_cost}\")\n        else:\n            print(f\"Test case failed: {sticks} expected {expected_cost}, got {actual_cost}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1168": "```\ndef minCostToSupplyWater(n, wells):\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            else:\n                parent[rootX] = rootY\n                if rank[rootX] == rank[rootY]:\n                    rank[rootY] += 1\n\n    heap = [(wells[i], i) for i in range(n, -1, -1)]\n    minCost = 0\n    for _ in range(n):\n        w, well = heapq.heappop(heap)\n        if find(well) != find(0):\n            union(0, well)\n            minCost += w\n\n    return minCost\n\n\ndef main():\n    print(minCostToSupplyWater(3, [1, 2, 2, 3]))  # Expected: 4\n    print(minCostToSupplyWater(4, [1, 2, 3, 4]))  # Expected: 6\n    print(minCostToSupplyWater(5, [3, 4, 2, 1, 3]))  # Expected: 7\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1169": "```\ndef findInvalidTransactions(transactions):\n    transactions_dict = {}\n    for transaction in transactions:\n        tid, _ ,amount = transaction.split(',')\n        if tid not in transactions_dict:\n            transactions_dict[tid] = int(amount)\n        else:\n            transactions_dict[tid] += int(amount)\n\n    invalid_transactions = []\n    for tid, total_amount in transactions_dict.items():\n        if total_amount != 1500:\n            for transaction in transactions:\n                t_tid, t_amount = transaction.split(',')[0], transaction.split(',')[2]\n                if t_tid == tid and int(t_amount) != total_amount:\n                    invalid_transactions.append(transaction)\n                    break\n\n    return invalid_transactions\n\n\ndef main():\n    # Test case 1\n    print(findInvalidTransactions([\"2019-01-01 12:45:56,John,5\",\"2019-01-02 10:15:20,Peter,14\",\"2019-01-03 11:00:30,John,3\",\"2019-01-04 10:00:20,Peter,3\"]))\n\n    # Test case 2\n    print(findInvalidTransactions([\"2018-03-08 09:45:54,Chris,5\",\"2018-03-09 12:15:20,John,14\",\"2019-01-04 10:00:20,Peter,3\"]))\n\n    # Test case 3\n    print(findInvalidTransactions([\"2018-03-08 09:45:54,Chris,5\",\"2018-03-09 12:15:20,John,14\",\"2019-01-04 10:00:20,Peter,1000\"]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1170": "```\ndef frequencySort(s):\n    if not s:\n        return s\n    \n    char_freq = {}\n    for char in s:\n        if char not in char_freq:\n            char_freq[char] = 1\n        else:\n            char_freq[char] += 1\n            \n    sorted_chars = sorted(char_freq.items(), key=lambda x: x[0])\n    \n    result = []\n    while sorted_chars:\n        char, freq = sorted_chars.pop(0)\n        result.append(char * freq)\n        \n    return ''.join(result)\n\ndef main():\n    test_cases = [\n        {\"s\": \"tree\", \"expected\": \"eertt\"},\n        {\"s\": \"cccaaa\", \"expected\": \"ccaa\"},\n        {\"s\": \"Aa\"}, \n    ]\n    \n    for test_case in test_cases:\n        s = test_case[\"s\"]\n        expected = test_case[\"expected\"]\n        output = frequencySort(s)\n        \n        if output == expected:\n            print(f\"Test case passed: {s} -> {output}\")\n        else:\n            print(f\"Test case failed: {s} -> Expected {expected}, got {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1171": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef removeZeroSumConsecutiveNodes(head: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    dummy.next = head\n    curr_sum = 0\n    prev_node = dummy\n    curr_node = head\n    while curr_node:\n        if curr_sum == 0:\n            prev_node = curr_node\n        elif curr_sum < 0:\n            curr_sum += curr_node.val\n            curr_node = curr_node.next\n        else:\n            curr_sum -= curr_node.val\n            curr_node = curr_node.next\n            prev_node.next = None\n    return dummy.next\n\ndef print_list(head):\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\ndef main():\n    # Test case 1:\n    head = ListNode(3)\n    head.next = ListNode(-1)\n    head.next.next = ListNode(1)\n    head.next.next.next = ListNode(3)\n    head.next.next.next.next = ListNode(-4)\n    expected = [3, 1]\n    actual = print_list(removeZeroSumConsecutiveNodes(head))\n    assert actual == \" \".join(map(str, expected))\n\n    # Test case 2:\n    head = ListNode(5)\n    head.next = ListNode(-5)\n    expected = [5]\n    actual = print_list(removeZeroSumConsecutiveNodes(head))\n    assert actual == \" \".join(map(str, expected))\n\n    # Test case 3:\n    head = ListNode(0)\n    head.next = ListNode(1)\n    head.next.next = ListNode(1)\n    head.next.next.next = ListNode(-5)\n    head.next.next.next.next = ListNode(0)\n    expected = [0, 1]\n    actual = print_list(removeZeroSumConsecutiveNodes(head))\n    assert actual == \" \".join(map(str, expected))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1172": "```\ndef maxVowels(wordList, queries):\n    vowels = set('aeiou')\n    res = []\n    for i, word in enumerate(wordList):\n        count = sum(1 for char in word if char.lower() in vowels)\n        res.append(count)\n\n    for query in queries:\n        res.append(sum(1 for char in wordList[query[0]:query[1]+1] if char.lower() in vowels))\n\n    return res\n\ndef main():\n    wordList = [\"apple\", \"apr\",\"banana\"]\n    queries = [[0, 5], [3, 7], [2, 8]]\n    print(maxVowels(wordList, queries))\n\n    wordList = [\"abb\", \"cdn\"]\n    queries = [[0, 1], [1, 2]]\n    print(maxVowels(wordList, queries))\n\n    wordList = [\"a\"]\n    queries = []\n    print(maxVowels(wordList, queries))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1173": "```\ndef orderFood(customerOrder: str) -> str:\n    # implement your logic here\n    return \"\"\n\ndef main():\n    test_cases = [\n        {\"input\": \"John Smith | 123 Main St, New York NY 10001 | (212) 123-4567 | 2022-09-25 12:30:00\", \n         \"expected_output\": \"Immediate Delivery\"},\n        {\"input\": \"Jane Doe | 456 Elm St, Los Angeles CA 90001 | (213) 789-0123 | 2022-10-15 14:30:00\", \n         \"expected_output\": \"Immediate Delivery\"},\n        {\"input\": \"John Smith | 123 Main St, New York NY 10001 | (212) 123-4567 | 2024-09-25 12:30:00\", \n         \"expected_output\": \"Not Eligible\"}\n    ]\n\n    for test_case in test_cases:\n        input_str = test_case[\"input\"]\n        expected_output = test_case[\"expected_output\"]\n\n        actual_output = orderFood(input_str)\n\n        if actual_output == expected_output:\n            print(f\"Test case passed: {test_case['input']}\")\n        else:\n            print(f\"Test case failed: {test_case['input']}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1174": "```\ndef countOrders(capacity):\n    MOD = 10**9 + 7\n    res = [0] * (capacity + 1)\n    for i in range(1, capacity + 1):\n        for j in range(i, capacity + 1):\n            if i % 2 == 0 and j % 2 == 1:\n                continue\n            res[j] += res[i - 1]\n            res[j] %= MOD\n    return sum(res)\n\ndef main():\n    print(countOrders(3))  # Expected output: 6\n    print(countOrders(4))  # Expected output: 14\n    print(countOrders(5))  # Expected output: 30\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1175": "```\ndef primeArrangements(n):\n    primes = [i for i in range(2, n+1) if all(i%j>0 for j in range(2, int(i**0.5)+1))]\n    return sum((10**len(str(p))-1)//p + 1 for p in primes)\n\ndef main():\n    print(primeArrangements(10))  # Expected output: 12\n    print(primeArrangements(14))  # Expected output: 24\n    print(primeArrangements(18))  # Expected output: 60\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1176": "```\ndef maxPerformance(n, speed, hours):\n    speeds = [(i, s) for i, s in enumerate(speed)]\n    speeds.sort()\n    \n    min_s = speeds[0][1]\n    total_s = sum([s for _, s in speeds])\n    res = total_s\n    left = 0\n    \n    for right in range(n):\n        while total_s - (speeds[right][1] - min_s) >= hours:\n            total_s -= speeds[left][1] - min_s\n            min_s = speeds[left][1]\n            left += 1\n        \n        res = max(res, total_s)\n    \n    return int(10e9 * res % 10e9)\n\n\ndef main():\n    n1 = 4\n    speed1 = [4, 4, 7, 6]\n    hours1 = 2\n    print(f\"Test case 1: {maxPerformance(n1, speed1, hours1)}\")\n\n    n2 = 5\n    speed2 = [2, 9, 3, 5, 8]\n    hours2 = 3\n    print(f\"Test case 2: {maxPerformance(n2, speed2, hours2)}\")\n\n    n3 = 6\n    speed3 = [1, 4, 7, 10, 5, 8]\n    hours3 = 1\n    print(f\"Test case 3: {maxPerformance(n3, speed3, hours3)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1177": "```\ndef canMakePalindrome(substrings):\n    prefix_sum = [0] * (len(substrings) + 1)\n    for i in range(len(substrings)):\n        if substrings[i][0] == substrings[i][-1]:\n            prefix_sum[i+1] = prefix_sum[i] + 1\n        else:\n            prefix_sum[i+1] = prefix_sum[i]\n    for i in range(1, len(substrings)):\n        if (prefix_sum[i-1] - prefix_sum[i]) % 2 != 0 and substrings[i][0] == substrings[i][-1]:\n            return False\n    return True\n\ndef main():\n    print(canMakePalindrome([\"a\",\"b\",\"aca\",\"cba\"])) # Expected: True\n    print(canMakePalindrome([\"abca\",\"cabac\",\"more\"])) # Expected: True\n    print(canMakePalindrome([\"abc\",\"abad\",\"cbcx\",\"xbad\"])) # Expected: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1178": "```\ndef numMatchingSubseq(s, words):\n    word_to_index = {}\n    for i, c in enumerate(s):\n        if c not in word_to_index:\n            word_to_index[c] = [i]\n        else:\n            word_to_index[c].append(i)\n\n    count = [0] * len(words)\n    for i, w in enumerate(words):\n        first_occurrence = None\n        for c in w:\n            if c in word_to_index and (first_occurrence is None or word_to_index[c][0] > first_occurrence):\n                first_occurrence = word_to_index[c][0]\n            else:\n                break\n        else:\n            count[i] += 1\n\n    return count\n\n\ndef main():\n    print(numMatchingSubseq(\"abc\", [\"ab\", \"bc\", \"b\"])) \n    print(numMatchingSubseq(\"aa\", [\"a\", \"aa\"])) \n    print(numMatchingSubseq(\"cba\", [\"a\", \"aa\", \"aaa\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1179": "```\ndef reformatDepartmentColumn(departments):\n    result = []\n    for department in departments:\n        split_department = department.split('-')\n        name = ' '.join(split_department[1:])\n        result.append([split_department[0], name])\n    return result\n\ndef main():\n    test_cases = [\n        {\n            \"input\": [\"E-C-R\", \"A-S-K\", \"E-F-G\"],\n            \"expected_output\": [[\"Employment\", \"C-R\"], [\"Accounting\", \"A-S\"], [\"Engineering\", \"F-G\"]]\n        },\n        {\n            \"input\": [\"M-G-N\", \"E-A-D\", \"B-A-L\"],\n            \"expected_output\": [[\"Marketing\", \"G-N\"], [\"Engineering\", \"A-D\"], [\"Business\", \"A-L\"]]\n        },\n        {\n            \"input\": [\"Sales-P-R\"],\n            \"expected_output\": [[\"Sales\", \"P-R\"]]\n        }\n    ]\n    \n    for test_case in test_cases:\n        input_departments = test_case[\"input\"]\n        expected_output = test_case[\"expected_output\"]\n        \n        output = reformatDepartmentColumn(input_departments)\n        \n        if output == expected_output:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1180": "```\ndef countHues(s):\n    n = len(s)\n    ans = 0\n    for i in range(n):\n        one_distinct = True\n        hue = set()\n        for j in range(i, n):\n            if s[j] not in hue:\n                hue.add(s[j])\n            else:\n                one_distinct = False\n                break\n        if one_distinct:\n            ans += 1\n    return ans\n\ndef main():\n    print(countHues(\"abc\")) # Test case 1\n    print(countHues(\"aaabaabbbcc\")) # Test case 2\n    print(countHues(\"aaa\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1181": "```\ndef countPairs(nums):\n    count_map = {}\n    for num in nums:\n        if num not in count_map:\n            count_map[num] = 0\n        count_map[num] += 1\n    \n    pairs = 0\n    for count in count_map.values():\n        pairs += count * (count - 1) // 2\n    \n    return pairs\n\ndef main():\n    print(countPairs([x for x in range(5)]))  # Test case 1: [0, 1, 2, 3, 4]\n    print(countPairs(['a', 'b', 'c', 'd']))  # Test case 2: ['a', 'b', 'c', 'd']\n    print(countPairs([1, 3, 5, 7]))  # Test case 3: [1, 3, 5, 7]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1182": "```\ndef targetIndices(nums, target):\n    left = 0\n    right = len(nums) - 1\n    result = []\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n        else:\n            left, right = mid, mid\n\n    for i in range(left):\n        if nums[i] == target:\n            result.append(i)\n    for i in range(right+1, len(nums)):\n        if nums[i] == target:\n            result.append(i)\n\n    return result\n\n\ndef main():\n    test_cases = [\n        # Test case 1\n        ([34,23,3,43,7], 24),\n        # Test case 2\n        ([5,6,20,7,24,25], 23),\n        # Test case 3\n        ([0,2,3,10,4,8], 9)\n    ]\n\n    for nums, target in test_cases:\n        print(f\"Input: {nums}, Target: {target}\")\n        result = targetIndices(nums, target)\n        print(f\"Output: {result}\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1183": "```\ndef max_ones(nums):\n    nums.sort(reverse=True)\n    ones = [num for num in nums if num == 1]\n    return len(ones)\n\ndef main():\n    print(max_ones([0,1,0])) # Test case 1\n    print(max_ones([1,1,1,0])) # Test case 2\n    print(max_ones([0,0,0,0])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1184": "```\ndef distanceBetweenBusStops(distance, start, destination):\n    if start > destination:\n        start, destination = destination, start\n    return min(sum(distance[start:start+length]) for length in range(destination-start+1))\n\ndef main():\n    print(\"Test 1:\")\n    print(distanceBetweenBusStops([1,2,3,4], 0, 2))  \n    print()\n\n    print(\"Test 2:\")\n    print(distanceBetweenBusStops([1,5,35,13,15,45], 6, 7)) \n    print()\n\n    print(\"Test 3:\")\n    print(distanceBetweenBusStops([10,2,5,4], 0, 7)) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1185": "```\ndef day_of_week(day, month, year):\n    t = [0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4]\n    year -= min(1, year // 100) * 100 + year % 100\n    return [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"][day + ((13 * (month + 1)) // 5 + year + int(year / 4) - int((year / 100) * 2) + t[month-1]) % 7]\n\ndef main():\n    print(day_of_week(12, 31, 1999), \"is\", day_of_week(12, 31, 1999))\n    print(day_of_week(10, 5, 1900), \"is\", day_of_week(10, 5, 1900))\n    print(day_of_week(8, 27, 1984), \"is\", day_of_week(8, 27, 1984))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1186": "```\ndef maximumSum(i):\n    if not i:\n        return 0\n    dp1 = [0] * len(i)\n    dp2 = [0] * len(i)\n\n    dp1[0] = i[0]\n    for j in range(1, len(i)):\n        dp1[j] = max(dp1[j-1], 0) + i[j]\n\n    dp2[-1] = i[-1]\n    for j in range(len(i)-2, -1, -1):\n        dp2[j] = max(dp2[j+1], 0) + i[j]\n\n    max_sum = 0\n    for k in range(1, len(i)-1):\n        if i[k-1] < 0:\n            max_sum = max(max_sum, dp1[k-1])\n        else:\n            max_sum = max(max_sum, dp1[k])\n\n    return max_sum\n\ndef main():\n    test_cases = [\n        [[1,-2,3,10,-4,8],11],\n        [[-1,-2,-3,1,2,3],9],\n        [[0,-1,5,-3,2,7],12]\n    ]\n\n    for i in range(len(test_cases)):\n        result = maximumSum(test_cases[i][0])\n        print(f'Test case {i+1}: The maximum subarray sum with one deletion is {result}')\n        \nif __name__ == \"__main__\":\n    main()\n```",
  "1187": "```\ndef countArrangement(N):\n    res = 0\n    for i in range(1, N+1):\n        arr = [i]\n        temp = list(range(1, N+1))\n        while temp:\n            j = (temp[0] + i - 1) % N // i\n            if j == 0: \n                return len(arr)\n            for k in range(len(temp)):\n                if temp[k] > j: break\n            temp.pop(k-1) if k>1 else temp.pop(0)\n            arr.append(temp[0])\n    return res\n\ndef main():\n    print(countArrangement(2))  # Output: 2\n    print(countArrangement(3))  # Output: 3\n    print(countArrangement(4))  # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1189": "```\ndef maxNumberOfBalloons(text):\n    text = text.lower()\n    count = [0, 0, 0, 0, 0]\n    \n    for char in text:\n        if char == 'b':\n            count[0] += 1\n        elif char == 'a':\n            count[1] += 1\n        elif char == 'l':\n            count[2] += 1\n        elif char == 'o':\n            count[3] += 1\n        elif char == 'n':\n            count[4] += 1\n            \n    min_count = float('inf')\n    for i in range(5):\n        if count[i] > 0:\n            min_count = min(min_count, count[i])\n            \n    return min_count\n\ndef main():\n    print(maxNumberOfBalloons(\"loonbalxballpoon\"))\n    print(maxNumberOfBalloons(\"nlaebolacoading\"))\n    print(maxNumberOfBalloons(\"balloonal\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1188": "```\nfrom queue import LifoQueue\nimport threading\n\nclass BoundedBlockingQueue:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.queue = LifoQueue(maxsize=capacity)\n        self.lock = threading.Lock()\n\n    def enqueue(self, item):\n        with self.lock:\n            if not self.is_full():\n                self.queue.put(item)\n            else:\n                raise Exception(\"Queue is full\")\n\n    def dequeue(self):\n        with self.lock:\n            if not self.is_empty():\n                return self.queue.get()\n            else:\n                raise Exception(\"Queue is empty\")\n\n    def size(self):\n        with self.lock:\n            return self.queue.qsize()\n\n    def is_full(self):\n        return self.size() >= self.capacity\n\n    def is_empty(self):\n        return self.size() == 0\n\n\ndef main():\n    queue = BoundedBlockingQueue(3)\n\n    # Test Case 1: Enqueue and Dequeue\n    for i in range(4):\n        queue.enqueue(i)\n    print(\"Test Case 1:\")\n    while not queue.is_empty():\n        print(queue.dequeue())\n\n    # Test Case 2: Check Size and Is Full/Is Empty\n    for i in range(3):\n        queue.enqueue(i)\n    print(\"\\nTest Case 2:\")\n    print(f\"Size: {queue.size()}\")\n    print(f\"Is Full: {queue.is_full()}\")\n    print(f\"Is Empty: {queue.is_empty()}\")\n\n    # Test Case 3: Enqueue when full\n    try:\n        for i in range(4):\n            queue.enqueue(i)\n    except Exception as e:\n        print(f\"\\nTest Case 3: {e}\")\n\n    print(\"\\nAll test cases passed.\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1190": "```\ndef reverseParentheses(s):\n    stack = []\n    res = []\n    temp = ''\n    for c in s:\n        if c == '(':\n            stack.append(temp)\n            temp = ''\n        elif c == ')':\n            while len(stack) > 0 and stack[-1] != '(':\n                temp += stack.pop()\n            if len(stack) > 0:\n                stack.pop()\n            res.append(temp[::-1])\n            temp = ''\n        else:\n            temp += c\n    while len(stack) > 0 and stack[-1] != '(':\n        temp += stack.pop()\n    if len(stack) > 0:\n        temp += stack.pop()[::-1]\n    return ''.join(res + [temp])\n\ndef main():\n    print(reverseParentheses(\"(abcd)\")) # \"dcba\"\n    print(reverseParentheses(\"(u(lovepython))\")) # \"itopsevole(uol)\"\n    print(reverseParentheses(\"a(bc(d(e(f(g)?)))\") # \"eggf(fed(cb)a\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1191": "```\ndef maxSumKConcat(arr, K):\n    n = len(arr)\n    dp = [0] * (K + 1)\n    for i in range(1, K + 1):\n        for j in range(i):\n            dp[i] = max(dp[i], dp[j] + arr[j])\n    return dp[K]\n\ndef main():\n    print(maxSumKConcat([1,2,3,4,5], 2)) # Test case 1\n    print(maxSumKConcat([-1,-2,1,2], 0)) # Test case 2\n    print(maxSumKConcat([1,2,3], 3)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1193": "```\ndef totalMoney(spent):\n    return sum(i*(i+1)//2 for i in range(1, spent+1))\n\ndef main():\n    print(totalMoney(4))  # Expected output: 10\n    print(totalMoney(5))  # Expected output: 15\n    print(totalMoney(20))  # Expected output: 210\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1192": "```\nclass Solution:\n    def findCriticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:\n        pass\n\ndef main():\n    solution = Solution()\n    \n    print(solution.findCriticalConnections(4, [[0,1],[1,2],[2,3]]))\n    print(solution.findCriticalConnections(6, [[0,1],[1,2],[2,3],[3,4],[4,5]]))\n    print(solution.findCriticalConnections(8, [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6],[7,0],[7,6]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1194": "```\ndef findWinners(logs):\n    players = {}\n    for log in logs:\n        winner, loser = log[0], log[1]\n        if winner not in players:\n            players[winner] = True\n        else:\n            players[winner] += 1\n        if loser not in players:\n            players[loser] = False\n\n    winners = [player for player, won in players.items() if won]\n\n    return sorted([player for player, status in players.items() if status])\n\ndef main():\n    logs = [[\"Peter\",\"Alice\"], [\"Alice\",\"Bob\"],[\"Bob\",\"John\"]]\n    print(findWinners(logs))  \n\n    logs2 = [[\"Alice\",\"Bob\"],[\"Bob\",\"John\"],[\"John\",\"Alice\"]]\n    print(findWinners(logs2))\n\n    logs3 = [[\"Alice\",\"Bob\"], [\"Bob\",\"Alice\"] ]\n    print(findWinners(logs3))\n    \nif __name__ == \"__main__\":\n    main()\n```",
  "1195": "```\nimport threading\nfrom queue import Queue\n\nclass FizzBuzz:\n    def __init__(self, n):\n        self.n = n\n        self.q = Queue()\n        for i in range(1, n+1):\n            self.q.put(i)\n\n    def fizz_buzz(self):\n        while not self.q.empty():\n            num = self.q.get()\n            if num % 3 == 0 and num % 5 == 0:\n                print(\"FizzBuzz\")\n            elif num % 3 == 0:\n                print(\"Fizz\")\n            elif num % 5 == 0:\n                print(\"Buzz\")\n            else:\n                print(num)\n\ndef main():\n    for i in [15, 30, 100]:\n        fb = FizzBuzz(i)\n        t = threading.Thread(target=fb.fizz_buzz)\n        t.start()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1196": "```\ndef maxApples(apples):\n    apples.sort(reverse=True)\n    basket = [0, 0]\n    for apple in apples:\n        if apple > basket[1]:\n            basket[1] += apple\n        else:\n            basket[0] += apple\n            basket[1] = 0\n    return min(basket)\n\ndef main():\n    testCases = [\n        ([5, 3], 4),\n        ([10, 10, 20], 30),\n        ([1, 2, 3, 4, 5], 5)\n    ]\n    \n    for (apples, expected) in testCases:\n        print(f\"Testing with apples = {apples}, expected = {expected}\")\n        result = maxApples(apples)\n        if result == expected:\n            print(\"PASS\")\n        else:\n            print(f\"FAIL: expected {expected} but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1197": "```\ndef minKnightMoves(targetX, targetY):\n    dir = [(2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)]\n    queue = [(0, 0, 0)]\n    visited = {(0, 0)}\n    while queue:\n        x, y, step = queue.pop(0)\n        if (x, y) == (targetX, targetY):\n            return step\n        for dx, dy in dir:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and 1 <= nx <= targetX and 1 <= ny <= targetY:\n                queue.append((nx, ny, step + 1))\n                visited.add((nx, ny))\n\ndef main():\n    print(minKnightMoves(2, 1)) # Expected output: 5\n    print(minKnightMoves(4, 3)) # Expected output: 5\n    print(minKnightMoves(97, 101)) # Expected output: 12\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1198": "```\ndef findSmallestCommonElement(matrix):\n    if not matrix or not matrix[0]:\n        return None\n    m, n = len(matrix), len(matrix[0])\n    row_set = set()\n    for i in range(m):\n        row_set.add(min(matrix[i]))\n    common_elements = []\n    for j in range(n):\n        elements = [x[j] for x in matrix]\n        while True:\n            if all(num in elements for num in common_elements):\n                return min(common_elements)\n            if not common_elements:\n                common_elements.append(elements[0])\n            else:\n                left, right = 0, len(common_elements) - 1\n                while right - left > 1:\n                    mid = (left + right) // 2\n                    if elements.count(common_elements[mid]) >= m:\n                        right = mid\n                    else:\n                        left = mid\n                common_elements = [common_elements[left]]\n\ndef main():\n    matrix1 = [[1,2,3],[1,4,5],[6,7,8]]\n    print(findSmallestCommonElement(matrix1))  # Output: 1\n\n    matrix2 = [[1,2],[1,3]]\n    print(findSmallestCommonElement(matrix2))   # Output: 1\n\n    matrix3 = [[1,2,3,4},{5,6},{7,8}]\n    print(findSmallestCommonElement(matrix3))   # Output: None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1199": "```\nimport heapq\n\ndef minTimeToBuildBlocks(blocks):\n    blocks.sort()\n    pq = []\n    ans = 0\n    for i in range(len(blocks)):\n        if not pq or pq[0] < blocks[i]:\n            heapq.heappush(pq, -blocks[i])\n            if len(pq) > i + 1:\n                ans += -heapq.heappop(pq)\n        else:\n            while pq and -pq[0] <= blocks[i]:\n                heapq.heappop(pq)\n            heapq.heappush(pq, -blocks[i])\n    return ans\n\ndef main():\n    print(minTimeToBuildBlocks([1,2,3,4,5]))  # Output: 3\n    print(minTimeToBuildBlocks([5,3,2,7,4]))  # Output: 11\n    print(minTimeToBuildBlocks([10,6,8,20]))  # Output: 21\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1200": "```\ndef minimumAbsoluteDifference(arr):\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(1, len(arr)):\n        diff = arr[i] - arr[i-1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n\n\ndef main():\n    print(minimumAbsoluteDifference([3, 2, 1]))  # Expected: 1\n    print(minimumAbsoluteDifference([-1, 5, 15, 20, 4, 3, 0]))  # Expected: 1\n    print(minimumAbsoluteDifference([1, 3, 6]))  # Expected: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1201": "```\ndef nthUglyNumber(n):\n    if n == 1:\n        return 1\n    dp = [i for i in range(1, 120)]\n    i = 0\n    while len(dp) > 1:\n        ugly = dp[i]\n        dp = [j for j in dp if j % ugly != 0 or j < ugly]\n        i += 1\n    return dp[0]\n\ndef main():\n    print(nthUglyNumber(9)) # Output: 36\n    print(nthUglyNumber(10)) # Output: 60\n    print(nthUglyNumber(12)) # Output: 68\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1202": "```\ndef smallest_string_with_swaps(s: str) -> str:\n    ...\n\ndef main():\n    print(smallest_string_with_swaps(\"dcce\")) \n    print(smallest_string_with_swaps(\"caaabbb\")) \n    print(smallest_string_with_swaps(\"dabcdbf\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1203": "```\ndef sortItemsByGroups(respectDependencies):\n    pass\n\n\nimport unittest\n\nclass TestSortItemsByGroups(unittest.TestCase):\n\n    def test_sort_items_by_groups(self):\n        # Test Case 1\n        dependencies = [[1,2],[2,3]]\n        groupA = [1,3]\n        groupB = [2]\n        self.assertEqual(sortItemsByGroups(dependencies, groupA, groupB), [[0,1,-1], [0,1,0]])\n\n    def test_sort_items_by_groups_2(self):\n        # Test Case 2\n        dependencies = [[1,2],[2,3],[4,5]]\n        groupA = [1,3]\n        groupB = [2,4]\n        self.assertEqual(sortItemsByGroups(dependencies, groupA, groupB), [[0,1,-1],[0,1,0],[2,3,-1]])\n\n    def test_sort_items_by_groups_3(self):\n        # Test Case 3\n        dependencies = []\n        groupA = [1]\n        groupB = []\n        self.assertEqual(sortItemsByGroups(dependencies, groupA, groupB), [[-1]])\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
  "1204": "```\ndef maxPassengers(rides):\n    max_passengers = 0\n    for ride in rides:\n        if ride[1] + ride[2] > ride[0]:\n            return ride[1]\n        else:\n            max_passengers += ride[1]\n    return max_passengers\n\ndef main():\n    print(maxPassengers([[60,10,10],[100,5,20]])) # Test case 1\n    print(maxPassengers([[60,10,10],[30,40,50]])) # Test case 2\n    print(maxPassengers([[30,20,20],[60,10,10]])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1205": "```\ndef totalMoney(totalTransactions):\n    return (totalTransactions * (1 + totalTransactions)) // 2\n\n\ndef main():\n    print(\"Test case 1: \")\n    print(f\"Expected output: {totalMoney(5)}, Actual output: {totalMoney(5)}\")\n    \n    print(\"\\nTest case 2: \")\n    print(f\"Expected output: {totalMoney(3)}, Actual output: {totalMoney(3)}\")\n\n    print(\"\\nTest case 3: \")\n    print(f\"Expected output: {totalMoney(10)}, Actual output: {totalMoney(10)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1206": "```\nclass Node:\n    def __init__(self, val=0, height=1):\n        self.val = val\n        self.next = [None]*(height)\n\nclass Skiplist:\n    def __init__(self):\n        self.head = [Node()]\n\n    def random(self, n: int) -> list[int]:\n        return [random.randint(0, 10**9) for _ in range(n)]\n\n    def search(self, num: int) -> bool:\n        node = self.head[1]\n        while True:\n            for h in range(len(self.head)):\n                if not node.next[h] or node.next[h].val < num:\n                    return False\n                node = node.next[h]\n                if node.val == num:\n                    return True\n\n    def add(self, num: int) -> None:\n        height = 1\n        while random.random() < 0.5 and height <= len(self.head):\n            height += 1\n        new_node = Node(num, height)\n        for h in range(height):\n            if not self.head[h+1] or self.head[h+1].val < num:\n                break\n            self.head[h] = new_node\n\ndef main():\n    skiplist = Skiplist()\n\n    test_case_1 = [8, 2, 9, 5, 6]\n    for num in test_case_1:\n        skiplist.add(num)\n    print(skiplist.search(2)) # Expected: True\n    print(skiplist.search(7)) # Expected: False\n\n    test_case_2 = [4, 3, 7, 5, 8]\n    for num in test_case_2:\n        skiplist.add(num)\n    print(skiplist.search(6)) # Expected: True\n    print(skiplist.search(1)) # Expected: False\n\n    test_case_3 = [1, 10, 11, 14, 13]\n    for num in test_case_3:\n        skiplist.add(num)\n    print(skiplist.search(15)) # Expected: False\n    print(skiplist.search(12)) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1207": "```\ndef uniqueOccurrences(arr):\n    count = {}\n    for num in arr:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n            \n    return len(set(count.values())) == len(count)\n\ndef main():\n    print(uniqueOccurrences([4,3,2,3,5,2,1,1,3])) # Expected: True\n    print(uniqueOccurrences([1,2]) # Expected: True\n    print(uniqueOccurrences([1,2,3,4,5])) # Expected: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1208": "```\ndef maxEqualFreq(nums):\n    count = {}\n    pref_sum = {}\n    for i, num in enumerate(nums):\n        if num not in count:\n            count[num] = []\n        count[num].append(i)\n    \n    for num, indices in count.items():\n        pref_sum[num] = [(i - j) * (j + 1) // 2 for j in range(len(indices))]\n    \n    last_num = None\n    max_len = 0\n    min_pref_sum = float('inf')\n    for i in range(102):\n        while len(set(pref_sum.get(num, []) for num in count)) <= i:\n            min_num = min((num for num, indices in count.items() if pref_sum[num][i] == min_pref_sum), key=lambda x: len(count[x]))\n            last_len = len(count[min_num])\n            max_len = max(max_len, last_len)\n            last_num = min_num\n            min_pref_sum = sum(pref_sum.get(num, []) for num in count) - pref_sum[last_num][i]\n    return [last_num, max_len]\n\ndef main():\n    print(maxEqualFreq([2,3,1,1,1,2])) # Expected: [2, 3]\n    print(maxEqualFreq([9,12,5,11,13,14]) # Expected: [14, 6]\n    print(maxEqualFreq([15,15,15])) # Expected: [15, 3]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1209": "```\ndef removeDuplicates(S: str) -> str:\n    stack = []\n    for char in S:\n        if stack and stack[-1] == char:\n            stack.pop()\n        else:\n            stack.append(char)\n    return ''.join(stack)\n\ndef main():\n    print(removeDuplicates(\"abcdefebcz\") == \"abcdef\")\n    print(removeDuplicates(\"azaeb\") == \"aeb\")\n    print(removeDuplicates(\"aoaotolee\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1210": "```\ndef minTime(intervals, target):\n    res = float('inf')\n    for _ in range(4):\n        t = max((x[1] - x[0]) // (2 * target) + 1 for x in intervals)\n        s = sum(t for _, t in intervals)\n        if s <= target:\n            return min(s, target)\n    return res\n\ndef main():\n    print(minTime([[5,13,15], [23,26,27], [18,19,20]], 6))\n    print(minTime([[1,4,5], [3,7,8], [11,14,16]], 2))\n    print(minTime([[1,2,3], [1,3,5], [2,3,4]], 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1211": "```\ndef qualityOfItems(weights):\n    n = len(weights)\n    total = sum(weights)\n    return [(weight / total) * 100 for weight in weights]\n\ndef findPercentage(queries, weights):\n    percentages = [qualityOfItems([weights]) for weights in zip(*[query[1:] for query in queries])]\n    return [[query[0], percentage] for query, percentage in zip(queries, percentages)]\n\ndef main():\n    test_cases = [\n        ([(100, [10]), (50, [5, 20]), (30, [30])],),\n        ([(200, [100, 50, 20, 10]), (150, [70, 40, 20, 20])],),\n        ([(1, [2]), (3, [4, 5]), (6, [7, 8, 9])],)\n    ]\n\n    for test_case in test_cases:\n        queries = test_case[0]\n        result = findPercentage(queries, [query[1] for query in queries])\n        print(\"Test case: \", queries)\n        print(\"Result: \", result)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1212": "```\ndef calculateTeamPoints(record):\n    total_points = 0\n    wins, draws, losses = record[0], record[2], record[4]\n    total_points += (wins * 3) + (draws * 1)\n    return total_points\n\n\ndef calculateAveragePoints(team_records):\n    total_points = sum([calculateTeamPoints(record) for record in team_records])\n    return total_points / len(team_records)\n\n\ndef averageTeamPointsByGroup(grouped_scores):\n    result = []\n    for group in grouped_scores:\n        result.append(calculateAveragePoints(group))\n    return result\n\n\ndef main():\n    test_cases = [\n        [[1, 0, 2, 3], [2, 1, 3, 1], [0, 3, 1, 4]],  # Case 1\n        [[1, 1, 1, 2], [2, 0, 2, 2], [1, 1, 1, 1]],  # Case 2\n        [[5, 1, 3, 7], [4, 2, 1, 6], [2, 1, 1, 5]]   # Case 3\n    ]\n\n    for i, test_case in enumerate(test_cases):\n        print(f\"Test Case {i+1}:\")\n        group_records = [[record[:3], record[3:]] for record in test_case]\n        grouped_scores = [row[0] for row in group_records], [row[1] for row in group_records]\n        average_points = averageTeamPointsByGroup(grouped_scores)\n        print(f\"Average points per team: {average_points}\")\n        print()\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1213": "```\ndef threeSum(nums1, nums2, nums3):\n    result = []\n    i = j = k = 0\n    while i < len(nums1) and j < len(nums2) and k < len(nums3):\n        if nums1[i] == nums2[j] == nums3[k]:\n            result.append((nums1[i], nums2[j], nums3[k]))\n            i += 1\n            j += 1\n            k += 1\n        elif nums1[i] <= nums2[j] and nums1[i] <= nums3[k]:\n            i += 1\n        elif nums2[j] <= nums3[k]:\n            j += 1\n        else:\n            k += 1\n    return result\n\ndef main():\n    test_cases = [\n        ([1, 5, 10], [1, 6, 8], [1, 8, 15]),\n        ([0, 2, 4, 6], [-1, -2, -3, -4], [-1, -3, -5]),\n        ([-1, 0, 3, 7, 10], [-1, -2, -3, -4, -5, -6], [1, 2, 3, 4, 5])\n    ]\n\n    for test_case in test_cases:\n        print(f\"Test Case: {test_case}\")\n        print(threeSum(*test_case))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1214": "```\nclass Solution:\n    def closestLeaf(node):\n        if not node:\n            return None\n        \n        stack = [node]\n        \n        while stack:\n            curr = stack.pop()\n            \n            if not curr.left and not curr.right:\n                return curr.val\n            \n            if curr.right:\n                stack.append(curr.right)\n            if curr.left:\n                stack.append(curr.left)\n                \n    def twoSumBSTs(root1, root2):\n        result = []\n        \n        while True:\n            leftmostInRoot1 = root1\n            leftmostInRoot2 = root2\n            \n            while leftmostInRoot1 and leftmostInRoot1.left:\n                leftmostInRoot1 = leftmostInRoot1.left\n                \n            while leftmostInRoot2 and leftmostInRoot2.right:\n                leftmostInRoot2 = leftmostInRoot2.right\n                \n            if leftmostInRoot1 and leftmostInRoot2:\n                if leftmostInRoot1.val + leftmostInRoot2.val in result:\n                    return True\n                else:\n                    result.append(leftmostInRoot1.val + leftmostInRoot2.val)\n            elif not root1 and not root2:\n                return False\n            elif not root1:\n                return True\n            elif not root2:\n                return True\n\n    def main():\n        # Test case 1\n        root1 = TreeNode(10, None, TreeNode(5, TreeNode(3), TreeNode(7)))\n        root2 = TreeNode(6, None, TreeNode(15, TreeNode(14), TreeNode(20)))\n        print(twoSumBSTs(root1, root2))  # Expected: True\n\n        # Test case 2\n        root1 = TreeNode(5, None, TreeNode(3, None, TreeNode(7)))\n        root2 = TreeNode(6, None, TreeNode(15, None, TreeNode(20)))\n        print(twoSumBSTs(root1, root2))  # Expected: True\n\n        # Test case 3\n        root1 = TreeNode(5, None, TreeNode(3, None, TreeNode(7)))\n        root2 = None\n        print(twoSumBSTs(root1, root2))  # Expected: True\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "1215": "```\ndef countSteppingNumbers(left, right):\n    def dfs(num, step):\n        if num > right:\n            return False\n        if num >= right:\n            return True\n        for i in range(10):\n            if abs(i - step) != 1 and (step == 0 or i == 0):\n                continue\n            newNum = num * 10 + i\n            yield from dfs(newNum, i)\n\n    return len(list(dfs(left, left)))\n\ndef main():\n    print(countSteppingNumbers(1, 21))\n    print(countSteppingNumbers(100, 200))\n    print(countSteppingNumbers(0, 9))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1216": "```\ndef isPalindrome(s):\n    s = ''.join(char.lower() for char in s if char.isalnum())\n    return s == s[::-1]\n\ndef main():\n    print(isPalindrome(\"A man, a plan, a canal: Panama\")) # True\n    print(isPalindrome(\"Not a palindrome\")) # False\n    print(isPalindrome(\"Radar\")) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1217": "```\ndef minCostToMoveChips(position):\n    cost = 0\n    for i in range(len(position)):\n        cost += abs(position[i] - (target := position[-1] % 2 == 0 and 0 or 1))\n    return cost\n\n\ndef main():\n    print(minCostToMoveChips([1, 2, 3]))  # Output: 2\n    print(minCostToMoveChips([2, 2, 2, 3, 3]))  # Output: 2\n    print(minCostToMoveChips([1, 1000]))  # Output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1218": "```\ndef longestArithSeqLength(arr):\n    n = len(arr)\n    max_length = 0\n    for i in range(n):\n        seen = {}\n        for j in range(i + 1, n):\n            diff = arr[j] - arr[i]\n            if diff < 0:\n                break\n            if diff not in seen:\n                seen[diff] = 2\n            else:\n                seen[diff] += 1\n            max_length = max(max_length, sum(seen.values()))\n    return max_length\n\ndef main():\n    print(longestArithSeqLength([3,6,9,12])) # Expected output: 4\n    print(longestArithSeqLength([9,4,7,2,10])) # Expected output: 5\n    print(longestArithSeqLength([20,1,15]) # Expected output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1219": "```\ndef getMaximumGold(grid):\n    m, n = len(grid), len(grid[0])\n    golds = [[grid[i][j] for j in range(n)] for i in range(m)]\n    max_gold = [0]\n    \n    def dfs(i, j):\n        if 1 <= i < m and 1 <= j < n and grid[i][j]:\n            x, y = i, j\n            g = grid[i][j]\n            grid[i][j] = 0\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ni, nj = i + dx, j + dy\n                if 1 <= ni < m and 1 <= nj < n and not grid[ni][nj]:\n                    dfs(ni, nj)\n            max_gold[0] += g\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ni, nj = i + dx, j + dy\n                if 1 <= ni < m and 1 <= nj < n and grid[ni][nj]:\n                    dfs(ni, nj)\n            grid[x][y] = g\n    \n    for i in range(m):\n        for j in range(n):\n            if golds[i][j]:\n                dfs(i, j)\n    \n    return max(max_gold)\n\ndef main():\n    print(getMaximumGold([[0,6,0],[7,8,1],[0,9,0]]))  # Output: 24\n    print(getMaximumGold([[1,0,7],[2,0,5],[3,0,4]]))  # Output: 12\n    print(getMaximumGold([[10,30,20,15],[25,25,20,10],[15,20,40,35],[30,40,60,50]]))  # Output: 75\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1220": "```\ndef countVowelPermutations(n):\n    MOD = 10**9 + 7\n    dp = [[0] * (n+1) for _ in range(5)]\n    dp[0][0] = 1\n    for i in range(n):\n        for j in range(5):\n            if j == 0:\n                dp[j][i+1] = (dp[j][i] * (4 - sum(dp[k][i] for k in range(1, 5))) % MOD)\n            elif j == 1:\n                dp[j][i+1] = (dp[j][i] * (dp[0][i] + dp[2][i]) % MOD)\n            elif j == 2:\n                dp[j][i+1] = (dp[j][i] * (dp[1][i] + dp[3][i]) % MOD)\n            else:\n                dp[j][i+1] = (dp[j][i] * (dp[0][i] + dp[1][i] + dp[2][i] + dp[4][i]) % MOD)\n    return sum(dp[i][-1] for i in range(5)) % MOD\n\n\ndef main():\n    print(countVowelPermutations(1))  # Output: 5\n    print(countVowelPermutations(2))  # Output: 16\n    print(countVowelPermutations(3))  # Output: 40\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1221": "```\ndef balanced_string(s):\n    n = len(s)\n    result = [[] for _ in range(n)]\n    left_count = right_count = res = 0\n    for i in range(n):\n        if s[i] == 'L':\n            left_count += 1\n        else:\n            right_count += 1\n        if left_count == right_count:\n            res = i + 1\n            break\n        elif left_count > right_count:\n            result[2 * left_count - 2].append('R')\n            result[2 * right_count - 1].append('L')\n    return [''.join(x) for x in result]\n\n\ndef main():\n    print(balanced_string(\"RLRRLL\"))\n    print(balanced_string(\"RLLLLLRLL\"))\n    print(balanced_string(\"LLLL\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1222": "```\ndef queensAttacktheKing(queens, king):\n    board = [[0 for _ in range(8)] for _ in range(8)]\n    for queen in queens:\n        board[queen[0]][queen[1]] = 1\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (-1, -1), (1, -1), (-1, 1)]\n    count = 0\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 1:\n                continue\n            for d in directions:\n                new_i, new_j = i + d[0], j + d[1]\n                while 0 <= new_i < 8 and 0 <= new_j < 8:\n                    if board[new_i][new_j] == 1:\n                        count += 1\n                        break\n                    new_i, new_j = new_i + d[0], new_j + d[1]\n\n    return count\n\n\ndef main():\n    print(queensAttacktheKing([[5, 6], [5, 7]], [4, 3]))  # Expected output: 3\n    print(queensAttacktheKing([[0, 0], [2, 4]], [1, 1]))  # Expected output: 3\n    print(queensAttacktheKing([[6, 4], [5, 7], [4, 8], [2, 4]], [4, 5]))  # Expected output: 5\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1223": "```\ndef dieSimulate(n):\n    dp = [[0] * (n + 1) for _ in range(6)]\n    MOD = 10**9 + 7\n    for i in range(6):\n        dp[i][1] = 1\n    for lenRoll in range(2, n + 1):\n        for face in range(6):\n            if face == 0:\n                dp[face][lenRoll] = (dp[1][lenRoll - 1] + dp[2][lenRoll - 1] + dp[3][lenRoll - 1] + dp[4][lenRoll - 1] + dp[5][lenRoll - 1]) % MOD\n            elif face == 1:\n                dp[face][lenRoll] = (dp[0][lenRoll - 1] + dp[2][lenRoll - 1] + dp[3][lenRoll - 1] + dp[4][lenRoll - 1]) % MOD\n            elif face == 2:\n                dp[face][lenRoll] = (dp[0][lenRoll - 1] + dp[1][lenRoll - 1] + dp[3][lenRoll - 1] + dp[5][lenRoll - 1]) % MOD\n            elif face == 3:\n                dp[face][lenRoll] = (dp[0][lenRoll - 1] + dp[1][lenRoll - 1] + dp[2][lenRoll - 1] + dp[4][lenRoll - 1]) % MOD\n            elif face == 4:\n                dp[face][lenRoll] = (dp[0][lenRoll - 1] + dp[1][lenRoll - 1] + dp[2][lenRoll - 1] + dp[3][lenRoll - 1]) % MOD\n            else:\n                dp[face][lenRoll] = (dp[0][lenRoll - 1] + dp[1][lenRoll - 1] + dp[2][lenRoll - 1] + dp[3][lenRoll - 1] + dp[4][lenRoll - 1]) % MOD\n    return max(dp[i][n] for i in range(6))\n\ndef main():\n    print(dieSimulate(3)) # Test case 1: n = 3, Expected output: 5\n    print(dieSimulate(2)) # Test case 2: n = 2, Expected output: 3\n    print(dieSimulate(4)) # Test case 3: n = 4, Expected output: 7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1224": "```\ndef maxEqualFrequency(nums):\n    frequency = {}\n    for num in nums:\n        frequency[num] = frequency.get(num, 0) + 1\n    max_length = 0\n    for k, v in frequency.items():\n        if len(v) == v[0]:\n            max_length = max(max_length, len(v))\n    return max_length\n\ndef main():\n    print(\"Test case 1: \")\n    print(maxEqualFrequency([2,1,5,3])) \n\n    print(\"\\nTest case 2: \")\n    print(maxEqualFrequency([3,6,7,10]))\n\n    print(\"\\nTest case 3: \")\n    print(maxEqualFrequency([0,1,2,3,4,5]))\n\nmain()\n```",
  "1225": "```\ndef findContigousDates(result):\n    result.sort()\n    contiguous_dates = []\n    i = 0\n    while i < len(result) - 1:\n        if (result[i][2] + 1 == result[i+1][2]):\n            start_date = result[i][0]\n            end_date = result[i+1][1]\n            contiguous_dates.append([start_date, end_date])\n            i += 1\n            while i < len(result) - 1 and (result[i][2] + 1 == result[i+1][2]):\n                i += 1\n        else:\n            i += 1\n    return contiguous_dates\n\ndef main():\n    result = [[\"2020-01-15\", \"2020-01-18\", 1], \n              [\"2020-01-19\", \"2020-01-22\", 2],\n              [\"2020-01-23\", \"2020-01-25\", 3], \n              [\"2020-01-26\", \"2020-02-05\", 4]]\n\n    print(findContigousDates(result))\n\nif __name__ == \"__main__\":\n    main()\n\ntest_case1 = [[\"1995-06-19\",\"1995-08-03\",2]]\nprint(\"\\nTest Case 1: \", findContigousDates(test_case1))\n    \ntest_case2 = [[ \"2019-01-23\", \"2019-02-01\", 4 ]]\nprint(\"\\nTest Case 2: \", findContigousDates(test_case2))\n\ntest_case3 = [[\"2005-12-08\",\"2006-06-15\",7]]\nprint(\"\\nTest Case 3: \", findContigousDates(test_case3))\n```",
  "1226": "```\nimport threading\nimport time\nfrom queue import Queue\n\nclass Chopstick:\n    def __init__(self):\n        self.lock = threading.Lock()\n\nclass Philosopher(threading.Thread):\n    def __init__(self, name, left_chopstick, right_chopstick):\n        super().__init__()\n        self.name = name\n        self.left_chopstick = left_chopstick\n        self.right_chopstick = right_chopstick\n\n    def run(self):\n        while True:\n            with self.left_chopstick.lock:\n                with self.right_chopstick.lock:\n                    print(f'{self.name} is eating.')\n                    time.sleep(1)\n\ndef main():\n    queues = [Queue() for _ in range(5)]\n    chopsticks = [Chopstick() for _ in range(5)]\n\n    philosophers = ['Philosopher 1', 'Philosopher 2', 'Philosopher 3', 'Philosopher 4', 'Philosopher 5']\n    left_chopsticks = []\n    right_chopsticks = []\n\n    for i, philosopher in enumerate(philosophers):\n        if i % 2 == 0:\n            left_chopsticks.append(chopsticks[i])\n            right_chopsticks.append(chopsticks[(i+1)%5])\n        else:\n            left_chopsticks.append(chopsticks[i])\n            right_chopsticks.append(chopsticks[(i-1)%5])\n\n    threads = []\n\n    for i, philosopher in enumerate(philosophers):\n        thread = Philosopher(philosopher, left_chopsticks[i], right_chopsticks[i])\n        thread.start()\n        threads.append(thread)\n\n    for thread in threads:\n        thread.join()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1227": "```\ndef pov(x):\n    return [1, 0][x]\n\ndef baggage(boo): \n    if boo:\n        return \"Boeing\"\n    else:\n        return \"Airbus\"\n\ndef probability(n, middle, first):\n    if n == 1:\n        return 1\n    p = [[0. for _ in range(2)] for _ in range(n)]\n    p[0][0] = 0.5\n    p[0][1] = 0.5\n\n    for i in range(1, n):\n        p[i][0] = (pov(middle) * p[i - 1][0]) + ((1 - pov(middle)) * p[i - 1][1])\n        p[i][1] = (1 - pov(first)) * p[i - 1][0]\n\n    return [2*p[n-1][0], 2*(p[n-1][1]-p[n-1][0])]\n\n\ndef main():\n    print(\"Test Case 1: Boeing seats and no first class.\")\n    print(f\"Expected result: {probability(3, True, False)}\")\n    \n    print(\"\\nTest Case 2: Airbus seats and some first class.\")\n    print(f\"Expected result: {probability(5, False, True)}\")\n\n    print(\"\\nTest Case 3: Mixed seats and only one first class.\")\n    print(f\"Expected result: {probability(4, True, True)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1228": "```\ndef missing_number(nums):\n    n = len(nums)\n    total_sum = (n * (n + 1)) // 2\n    arithmetic_sum = sum(nums)\n    return total_sum - arithmetic_sum\n\n\ndef main():\n    print(\"Test Case 1:\")\n    nums1 = [2,3]\n    expected_output1 = 0\n    actual_output1 = missing_number(nums1)\n    if actual_output1 == expected_output1:\n        print(f\"Pass: {expected_output1} == {actual_output1}\")\n    else:\n        print(f\"Fail: Expected {expected_output1}, got {actual_output1}\")\n\n    print(\"Test Case 2:\")\n    nums2 = [0,1,3]\n    expected_output2 = 2\n    actual_output2 = missing_number(nums2)\n    if actual_output2 == expected_output2:\n        print(f\"Pass: {expected_output2} == {actual_output2}\")\n    else:\n        print(f\"Fail: Expected {expected_output2}, got {actual_output2}\")\n\n    print(\"Test Case 3:\")\n    nums3 = [0,1,2]\n    expected_output3 = 3\n    actual_output3 = missing_number(nums3)\n    if actual_output3 == expected_output3:\n        print(f\"Pass: {expected_output3} == {actual_output3}\")\n    else:\n        print(f\"Fail: Expected {expected_output3}, got {actual_output3}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1229": "```\ndef meetrooms(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort(key=lambda x: (x[0], x[1]))\n\n    result = [intervals[0]]\n    for i in range(1, len(intervals)):\n        if intervals[i][0] >= result[-1][1]:\n            result.append(intervals[i])\n        else:\n            result[-1][1] = max(result[-1][1], intervals[i][1])\n\n    return result\n\ndef main():\n    print(meetrooms([[0, 30],[5, 10],[15, 20]]))\n    print(meetrooms([[7,10],[2,4]]))\n    print(meetrooms([]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1230": "```\ndef numWays(nums):\n    n = len(nums)\n    total_heads, total_tails = nums.count(0), nums.count(1)\n    heads, tails = total_heads, total_tails\n    res = [0] * (n + 1)\n    res[0] = 1\n\n    for i in range(n):\n        if i % 2 == 0:\n            heads, tails = tails, heads\n        res[i+1] = res[i] * min(heads, tails)\n\n    return sum(res[-3:])\n\ndef main():\n    print(numWays([0, 1])) # Test case 1\n    print(numWays([0, 1, 1, 0, 1])) # Test case 2\n    print(numWays([1, 1, 1, 0, 0, 1])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1231": "```\ndef findSeeds(grid):\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                return binarySearch(grid, i, j)\n\ndef binarySearch(grid, x, y):\n    m, n = len(grid), len(grid[0])\n    low, high = 0, (m * n) // 2\n    while low <= high:\n        mid = (low + high) // 2\n        if canPlace(x, y, grid, mid):\n            return mid\n        elif canPlace(x, y, grid, mid - 1):\n            return mid - 1\n        else:\n            low += 1\n\ndef canPlace(x, y, grid, k):\n    for i in range(k):\n        ni = (x + i) % len(grid)\n        if not grid[ni][y] == '0':\n            return False\n    return True\n\ndef main():\n    print(findSeeds([[\"1\",\"0\",\"1\",\"0\",\"0\"],\n                     [\"1\",\"0\",\"1\",\"1\",\"0\"],\n                     [\"1\",\"1\",\"1\",\"1\",\"0\"],\n                     [\"1\",\"0\",\"0\",\"0\",\"0\"]])) # 6\n    print(findSeeds([[\"0\",\"7\",\"8\"],[\"1\",\"2\",\"9\"],[\"4\",\"5\",\"0\"]])) # 25\n    print(findSeeds([[\"1\",\"0\",\"0\"],[\"0\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]])) # 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1233": "```\ndef removeSubfolders(folderPath):\n    folders = folderPath.split('/')\n    res = []\n    for i in range(len(folders)):\n        if i > 0:\n            if res[-1] + '/' + folders[i].replace('..', '') not in res:\n                res.append(res[-1] + '/' + folders[i].replace('..', ''))\n        else:\n            res.append(folders[i])\n    return '/'.join(res)\n\ndef main():\n    print(removeSubfolders(\"/a/aa/bb\")) \n    print(removeSubfolders(\"/a/*\")) \n    print(removeSubfolders(\"/a//x/y/\",\"/a/x\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1232": "```\ndef maxPoints(points):\n    n = len(points)\n    if n <= 2:\n        return n\n    max_count = 0\n    for i in range(n):\n        slope_map = {}\n        same_points = 1\n        for j in range(i + 1, n):\n            if points[i][0] == points[j][0]:\n                same_points += 1\n                continue\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            if dx == 0:\n                slope = float('inf')\n            else:\n                slope = dy / dx\n            if slope not in slope_map:\n                slope_map[slope] = 1\n            else:\n                slope_map[slope] += 1\n        max_count = max(max_count, max(slope_map.values(), default=0) + same_points)\n    return max_count\n\ndef main():\n    print(\"Test case 1:\")\n    points = [[1, 1], [2, 2], [3, 3], [4, 4]]\n    print(maxPoints(points))  # Output: 3\n    print()\n\n    print(\"Test case 2:\")\n    points = [[0, 0], [1, 0], [2, 0], [3, 0]]\n    print(maxPoints(points))  # Output: 4\n    print()\n\n    print(\"Test case 3:\")\n    points = [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [5, 0]]\n    print(maxPoints(points))  # Output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1234": "```\ndef balanced_string(s: str) -> int:\n    n = len(s)\n    total_sum = sum(1 for c in s if c == 'a' or c == 'b' or c == 'c')\n    left, right = 0, 0\n    min_len = float('inf')\n    \n    for right in range(n):\n        while right - left + 1 > (total_sum // 3) and left <= right:\n            if s[left] in 'abc':\n                total_sum -= 1\n            left += 1\n        \n        if right - left + 1 >= n // 3 and total_sum == (n - right) * (1 if s[right] in 'abc' else 0):\n            min_len = min(min_len, right - left + 1)\n    \n    return n - min_len\n\ndef main():\n    print(balanced_string(\"a\")) \n    print(balanced_string(\"aab\")) \n    print(balanced_string(\"aaabaaaaaba\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1235": "```\ndef maxProfitAssignment(arr, start, end):\n    arr.sort()\n    res = 0\n    last_end = -1\n    for i in range(len(arr)):\n        if arr[i] > end:\n            break\n        if arr[i] >= start and arr[i] <= end:\n            res = max(res, arr[i])\n        if arr[i] < start:\n            continue\n        if arr[i] < last_end:\n            continue\n        while i < len(arr) - 1 and arr[i+1] > end:\n            i += 1\n        for j in range(i, -1, -1):\n            if arr[j] <= end:\n                res = max(res, start + end - (end - start) * (end - arr[j]) // (arr[j] - start))\n                break\n    return res\n\ndef main():\n    print(maxProfitAssignment([100,200,300,400], 250, 300))  # Output: 350\n    print(maxProfitAssignment([1,2,3,4,5], 1, 5))  # Output: 10\n    print(maxProfitAssignment([8,9,10,11,12,13,14,15], 10, 15))  # Output: 20\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1236": "```\ndef crawl(url):\n    visited = set()\n    result = []\n    \n    def dfs(node):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in [\"http://\" + node + \"/a\", \"http://\" + node + \"/b\", \"http://\" + node + \"/c\"]:\n            if neighbor not in visited and neighbor != url:\n                result.append(neighbor)\n                dfs(neighbor.split(\"/\")[-1])\n                \n    dfs(url.split(\"/\")[-1])\n    return result\n\ndef main():\n    urls = [\"http://www.example.com\"]\n    print(crawl(urls[0]))\n\n    urls = [\"http://www.a.com/level1/a1\", \"http://www.a.com/level1/a2\"]\n    print(crawl(urls[0]))\n\n    urls = [\"http://www.b.com/level1/b1\", \"http://www.b.com/level1/b2\", \"http://www.b.com/level1/b3\"]\n    print(crawl(urls[0]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1237": "```\ndef mySqrt(x):\n    if x == 0:\n        return 0\n    left, right = 1, x\n    while left <= right:\n        mid = (left + right) // 2\n        mid_squared = mid * mid\n        if mid_squared == x:\n            return mid\n        elif mid_squared < x:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return right\n\ndef main():\n    print(mySqrt(16)) # Test case 1: Expected output is 4\n    print(mySqrt(25)) # Test case 2: Expected output is 5\n    print(mySqrt(36)) # Test case 3: Expected output is 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1238": "```\ndef circularPermutations(n):\n    def backtrack(start, path):\n        if len(path) == n:\n            res.append(path)\n            return\n        for i in range(start, start + (n - len(path)) % 2 + 1):\n            if (i & 1) ^ (len(path) & 1):\n                continue\n            backtrack(i, path + [1 << i])\n    res = []\n    backtrack(0, [])\n    return res\n\ndef main():\n    n = 3\n    print(circularPermutations(n))\n\n    n = 2\n    print(circularPermutations(n))\n\n    n = 5\n    print(circularPermutations(n))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1239": "```\ndef maximumUniqueSubarray(nums):\n    n = len(nums)\n    res = 0\n    used = [False] * 128\n    \n    for i in range(n):\n        c = nums[i]\n        while used[c]:\n            for j in range(i):\n                if not used[nums[j]]:\n                    nums[j] = '1'\n                    used[ord(nums[j])] = True\n                    res += 1\n                    break\n                if not used[c]:\n                    return res + i - j\n        used[c] = True\n\n    return n\n\ndef main():\n    print(maximumUniqueSubarray([\"a\",\"abc\",\"cd\",\"def\"])) #3\n    print(maximumUniqueSubarray([\"abc\",\"bcd\",\"cef\"])) #4\n    print(maximumUniqueSubarray([\"aaaa\",\"aaa\"])) #1",
  "1241": "```\ndef num_comments_per_post(comments):\n    result = {}\n    for c in comments:\n        post_id = c[0]\n        if post_id not in result:\n            result[post_id] = 1\n        else:\n            result[post_id] += 1\n    return result\n\n\ndef main():\n    # Test case 1\n    comments = [(1, ), (2, ), (3, )]\n    print(num_comments_per_post(comments))  # {1: 1, 2: 1, 3: 1}\n\n    # Test case 2\n    comments = [(1, ), (1, ), (2, ), (2, ), (3, ), (4, )]\n    print(num_comments_per_post(comments))  # {1: 2, 2: 2, 3: 1, 4: 1}\n\n    # Test case 3\n    comments = []\n    print(num_comments_per_post(comments))  # {}\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1240": "```\ndef minStepsToCover(squares):\n    dp = [[float('inf')] * (len(squares) + 1) for _ in range(len(squares) + 1)]\n    dp[0][0] = 0\n    for i in range(1, len(squares) + 1):\n        dp[i][0] = i\n    for j in range(1, len(squares) + 1):\n        dp[0][j] = j\n\n    for i in range(1, len(squares) + 1):\n        for j in range(1, len(squares) + 1):\n            if squares[i-1][j-1] == 1:\n                dp[i][j] = min(dp[i][j], dp[i-1][j-1] + 2)\n            else:\n                dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1)\n\n    return dp[-1][-1]\n\n\ndef main():\n    print(minStepsToCover([[0, 0, 1], [1, 1, 0]]))  # Test case 1: Output should be 2\n    print(minStepsToCover([[1, 1, 0], [1, 0, 1]]))  # Test case 2: Output should be 3\n    print(minStepsToCover([[1, 0, 1, 0], [1, 1, 0, 1], [0, 1, 0, 1]]))  # Test case 3: Output should be 4\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1242": "```\nfrom threading import Thread\nfrom queue import Queue\nfrom collections import defaultdict\n\nclass WebCrawler:\n    def __init__(self, startURL):\n        self.visited = set()\n        self.graph = defaultdict(list)\n        self.startURL = startURL\n\n    def crawl(self):\n        visited = set()\n        graph = defaultdict(list)\n        queue = Queue()\n\n        def helper(url):\n            if url in visited:\n                return\n            visited.add(url)\n\n            for neighbor in self.graph[url]:\n                if neighbor not in visited:\n                    queue.put(neighbor)\n\n        thread_queue = Queue()\n\n        def worker():\n            while True:\n                url = queue.get()\n                if url is None:\n                    break\n                helper(url)\n                queue.task_done()\n\n        for _ in range(5):\n            t = Thread(target=worker)\n            t.daemon = True\n            t.start()\n\n        queue.put(self.startURL)\n\n        while not queue.empty():\n            url = queue.get().decode('utf-8')\n            print(f\"Crawling {url}\")\n\n        print(\"Done\")\n\ndef main():\n    test_cases = [\n        WebCrawler(\"https://leetcode.com\"),\n        WebCrawler(\"http://www.google.com\"),\n        WebCrawler(\"https://en.wikipedia.org\")\n    ]\n\n    for case in test_cases:\n        case.crawl()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1243": "```\ndef arrayTransform(a):\n    result = []\n    for num in a:\n        if num % 2 == 0:\n            result.append(num // 2)\n        else:\n            result.append(num * 3 + 1)\n    return result\n\n\ndef main():\n    print(\"Test Case 1:\")\n    print(arrayTransform([20,10,6])) # expected output: [10,5,3]\n\n    print(\"\\nTest Case 2:\")\n    print(arrayTransform([100,4,16])) # expected output: [50,2,4]\n\n    print(\"\\nTest Case 3:\")\n    print(arrayTransform([1, 2, 3])) # expected output: [4,6,9]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1244": "```\nclass Leaderboard:\n    def __init__(self):\n        self.score_dict = {}\n\n    def addScore(self, playerId: int, score: int) -> None:\n        if playerId in self.score_dict:\n            self.score_dict[playerId] += score\n        else:\n            self.score_dict[playerId] = score\n\n    def top(self, k: int) -> List[int]:\n        return sorted([playerId for playerId, score in self.score_dict.items()], key=lambda x: -self.score_dict[x])[:k]\n\ndef main():\n    lb = Leaderboard()\n    \n    lb.addScore(1, 5)\n    lb.addScore(2, 3)\n    print(lb.top(10)) # [1, 2]\n    \n    lb.addScore(3, 19)\n    lb.addScore(1, -2)\n    print(lb.top(10)) # [3, 1]\n\n    lb.addScore(4, 5)\n    print(lb.top(10)) # [3, 1, 4]\n```",
  "1245": "```\nclass Solution:\n    def treeDiameter(self, edges):\n        graph = {}\n        for edge in edges:\n            if edge[0] not in graph:\n                graph[edge[0]] = []\n            if edge[1] not in graph:\n                graph[edge[1]] = []\n            graph[edge[0]].append(edge[1])\n            graph[edge[1]].append(edge[0])\n\n        maxDepth = 0\n        farthestNode = None\n        queue = [0]\n        visited = set()\n        while queue:\n            node = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph.get(node, []):\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n                if len(visited) > maxDepth:\n                    maxDepth = len(visited)\n                    farthestNode = node\n\n        treeDiameter = 0\n        queue = [farthestNode]\n        visited = set()\n        while queue:\n            node = queue.pop(0)\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph.get(node, []):\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n                treeDiameter = max(treeDiameter, len(visited))\n\n        return [maxDepth - 1, treeDiameter - 1]\n\ndef main():\n    solution = Solution()\n    print(solution.treeDiameter([[0,1],[1,2],[2,3],[1,3]])) # Expected output: [4, 4]\n    print(solution.treeDiameter([[0,1],[1,2],[2,3],[3,4],[1,4]])) # Expected output: [5, 5]\n    print(solution.treeDiameter([[0,1],[0,2],[0,3]])) # Expected output: [4, 3]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1246": "```\ndef minSteps(s: str) -> int:\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(i, -1, -1):\n            if s[j - 1] == s[i - 1]:\n                dp[j][i] = dp[j - 1][i - 1] + 2\n            else:\n                dp[j][i] = min(dp[j - 1][i], dp[j][i - 1]) + (s[j - 1] != s[i - 1])\n\n    return dp[0][n]\n\ndef main():\n    print(minSteps(\"abccba\"))  # 4\n    print(minSteps(\"aab\"))     # 2\n    print(minSteps(\"able was able was i able was able\"))  # 7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1247": "```\ndef minSwaps(s1, s2):\n    if len(s1) != len(s2):\n        return -1\n\n    swaps = 0\n    for c1, c2 in zip(s1, s2):\n        if c1 != c2:\n            if c1 == '1':\n                s2 = list(s2)\n                i = s2.index('0')\n                s2[i], s2[s2.index(c2)] = c2, '0'\n                swaps += 1\n            else:\n                s2 = list(s2)\n                i = s2.index('1')\n                s2[i], s2[s2.index(c2)] = c2, '1'\n                swaps += 1\n\n    return swaps\n\n\ndef main():\n    test_cases = [\n        {\"s1\": \"XXX01\", \"s2\": \"XXX11\", \"expected\": 3},\n        {\"s1\": \"110010\", \"s2\": \"111011\", \"expected\": 0},\n        {\"s1\": \"101\", \"s2\": \"001\", \"expected\": 4}\n    ]\n\n    for test_case in test_cases:\n        s1 = test_case[\"s1\"]\n        s2 = test_case[\"s2\"]\n        expected = test_case[\"expected\"]\n\n        actual = minSwaps(s1, s2)\n        print(f\"Test case: {s1} and {s2}, Expected: {expected}, Actual: {actual}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1248": "```\ndef numberOfSubarrays(nums, k):\n    n = len(nums)\n    res = 0\n    for i in range(n):\n        count = 0\n        for j in range(i, n):\n            if nums[j] % 2 == 1:\n                count += 1\n            if count == k:\n                res += 1\n    return res\n\ndef main():\n    print(numberOfSubarrays([1, 1, 2, 1, 1], 3)) # Test case 1: Expected output 2\n    print(numberOfSubarrays([2, 4, 6], 1)) # Test case 2: Expected output 8\n    print(numberOfSubarrays([0, 0, 0], 1)) # Test case 3: Expected output 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1249": "```\ndef minRemoveToMakeValid(s):\n    stack = []\n    to_remove = set()\n    \n    for i in range(len(s)):\n        if s[i] == '(':\n            stack.append(i)\n        elif s[i] == ')':\n            if not stack:\n                to_remove.add(i)\n            else:\n                stack.pop()\n\n    to_remove = set(stack) | to_remove\n    return ''.join([c for c in s if i not in to_remove])\n\ndef main():\n    print(minRemoveToMakeValid(\"lee(t(c)o(de)ta))\")) \n    print(minRemoveToMakeValid(\"a)b(c)d\")) \n    print(minRemoveToMakeValid(\"(a(b(c))d\") )\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1250": "```\ndef isGoodArray(nums):\n    gcd = lambda x, y: x if not y else gcd(y, x % y)\n    for num in nums:\n        if num < 1 or gcd(num, max(nums)) != 1:\n            return False\n    return True\n\n\ndef main():\n    print(isGoodArray([16, 28]) == True)\n    print(isGoodArray([4, 6]) == False)\n    print(isGoodArray([10, 2, 8, 9, 3])) == True)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1251": "```\ndef averagePrice(soldAt, prices):\n    total = sum(price for price in prices)\n    return total / len(prices)\n\ndef main():\n    print(\"Test Case 1:\")\n    print(averagePrice([100, 200, 300], [1, 2, 3]))  # Expected output: 200.0\n    print()\n\n    print(\"Test Case 2:\")\n    print(averagePrice([100, 150, 50], [1, 2, 3]))  # Expected output: 133.33\n    print()\n\n    print(\"Test Case 3:\")\n    print(averagePrice([20, 40, 60, 80, 100], [5, 10, 15, 20, 25]))  # Expected output: 60.0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1252": "```\ndef oddCells(n, m, indices):\n    rows = [0] * n\n    cols = [0] * m\n    for i in range(len(indices)):\n        row = indices[i][0]\n        col = indices[i][1]\n        rows[row] += 1\n        cols[col] += 1\n    count = sum(1 for r in rows if r % 2 != 0)\n    return count\n\ndef main():\n    print(oddCells(3, 3, [[0,1],[1,0]])) # Test case 1: Expected output is 2\n    print(oddCells(2, 3, [[1,1],[1,0]])) # Test case 2: Expected output is 1\n    print(oddCells(5, 4, [[1,2],[4,0],[4,2],[3,1],[3,4]])) # Test case 3: Expected output is 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1253": "```\ndef reconstructMatrix(r, c, colsum):\n    res = [[0]*c for _ in range(r)]\n    \n    if sum(colsum) != r*c:\n        return []\n        \n    for i in range(c):\n        x = 0\n        while x < r and colsum[i] > 0:\n            if (i & 1) == 0: \n                res[x][i] = 1\n                colsum[i] -= 1\n            else: \n                res[r-1-x][i] = 1\n                colsum[i] -= 1\n            x += 1\n        \n    return res\n\ndef main():\n    print(reconstructMatrix(2,3,[1,1,1]))\n    print(reconstructMatrix(2,3,[1,0,1]))\n    print(reconstructMatrix(5,5,[5,5]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1254": "```\ndef closedIsland(grid):\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    \n    def dfs(i, j):\n        if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 1:\n            return\n        grid[i][j] = 1\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            dfs(i+dx, j+dy)\n    \n    def checkIsland(i, j):\n        if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 1:\n            return False\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if not checkIsland(i+dx, j+dy):\n                return False\n        return True\n    \n    closed = 0\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 0 and checkIsland(i, j):\n                dfs(i, j)\n                closed += 1\n    return closed\n\ndef main():\n    test_cases = [\n        # Test case 1:\n        [[0,0,1,0,0],\n         [0,1,0,1,0],\n         [0,1,1,1,0],\n         [0,0,0,0,0]],\n\n        # Test case 2:\n        [[1,1,1,1,1],\n         [1,0,0,0,1],\n         [1,0,1,0,1],\n         [1,0,0,0,1],\n         [1,1,1,1,1]],\n\n        # Test case 3:\n        [[0,0,0,1,0],\n         [0,0,0,1,0],\n         [0,0,0,1,0],\n         [0,0,0,1,0],\n         [0,0,0,0,0]]\n    ]\n\n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        result = closedIsland(test_case)\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1255": "```\ndef maxScoreWords(words, charSet):\n    words.sort(key=len)\n    dp = [[0] * (len(charSet) + 1) for _ in range(len(words) + 1)]\n    usedChar = [False] * (1 << len(charSet))\n    max_score = 0\n\n    for i in range(1, len(words) + 1):\n        score = 0\n        for j in range(len(words[i - 1])):\n            charBit = 1 << ord(words[i - 1][j]) - ord('a')\n            if not usedChar[charBit]:\n                usedChar[charBit] = True\n                score += 1\n            else:\n                break\n        dp[i][score + 1] = dp[i - 1][score]\n        for j in range(score, -1, -1):\n            if dp[i - 1][j] > dp[i][j]:\n                dp[i][j] = dp[i - 1][j]\n\n    for i in range(1, len(words) + 1):\n        score = 0\n        for j in range(len(words[i - 1])):\n            charBit = 1 << ord(words[i - 1][j]) - ord('a')\n            if usedChar[charBit]:\n                usedChar[charBit] = False\n                score += 1\n            else:\n                break\n        max_score = max(max_score, dp[i][score])\n\n    return max_score\n\ndef main():\n    print(maxScoreWords([\"hello\", \"world\", \"leetcode\"], \"a\"))  # Output: 2\n    print(maxScoreWords([\"fram\",\"frame\",\"fire\"], \"r\"))   # Output: 5\n    print(maxScoreWords([\"dog\",\"cat\",\"dodge\",\"trainee\"], \"b\"))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1256": "```\ndef encode(number):\n    if number < 0:\n        return \"Error: Number is negative.\"\n    result = \"\"\n    while number > 0:\n        digit = number % 2\n        if digit == 1:\n            result = '1' + result\n        else:\n            result = '0' + result\n        number //= 2\n    return \"1\" + result\n\ndef main():\n    print(encode(5))  # Test case 1: encode 5\n    print(encode(10))  # Test case 2: encode 10\n    print(encode(15))  # Test case 3: encode 15\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1257": "```\ndef SmallestCommonRegion(grid):\n    m = len(grid)\n    n = len(grid[0])\n    res = []\n    for i in range(m):\n        for j in regionSearch(i, j, grid):\n            if all(grid[x][y] == '1' for x in range(i-1, i+2) for y in range(j-1, j+2)):\n                res.append((i, j))\n    return res\n\ndef regionSearch(i, j, grid):\n    m = len(grid)\n    n = len(grid[0])\n    if 0 <= i < m and 0 <= j < n and grid[i][j] == '1':\n        grid[i][j] = '-'\n        yield from regionSearch(i-1, j, grid)\n        yield from regionSearch(i+1, j, grid)\n        yield from regionSearch(i, j-1, grid)\n        yield from regionSearch(i, j+1, grid)\n\ndef main():\n    test_cases = [\n        {\"grid\": [[\"0\", \"0\", \"0\", \"0\"], [\"1\", \"\", \"1\", \"\"], [\"0\", \"1\", \"1\", \"0\"], [\"0\", 0, 0, 0]], \n        \"expected\": [(2, 3)]},\n        {\"grid\": [[0, 1, 0], [0, 0, 0], [0, 0, 0]], \n        \"expected\": []},\n        {\"grid\": [[\"0\", \"0\", \"0\"], [\"1\", \"1\", \"0\"], [\"0\", \"0\", \"0\"]], \n        \"expected\": [(2, 1)]}\n    ]\n\n    for test_case in test_cases:\n        actual = SmallestCommonRegion(test_case[\"grid\"])\n        if actual == test_case[\"expected\"]:\n            print(\"Test case passed\")\n        else:\n            print(f\"Test case failed. Expected {test_case['expected']} but got {actual}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1258": "```\ndef countSynonyms(sentence, words):\n    n = len(words)\n    res = set()\n    \n    def dfs(i, path):\n        if i == n:\n            res.add(' '.join(path))\n            return\n        for j in range(len(sentence)):\n            if sentence[j] == ' ' or j == 0:\n                continue\n            k = j\n            while k > 0 and sentence[k-1] == sentence[0]:\n                k -= 1\n            dfs(k, path + [words[i-1]] + list(sentence[:k].split()))\n    \n    dfs(n, [])\n    return len(res)\n\ndef main():\n    print(countSynonyms(\"abc\", [\"a\", \"bc\", \"b c\", \"ab c\"])) # Output: 4\n    print(countSynonyms(\"abbcccd\", [\"a\", \"ab\", \"c\", \"d\", \"e\"])) # Output: 5\n    print(countSynonyms(\"aab\", [\"aa\", \"ba\", \"ab\"])) # Output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1259": "```\ndef numberOfWays(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    ways = [0] * (n + 1)\n    ways[1] = 1\n    ways[2] = 2\n    for i in range(3, n + 1):\n        ways[i] = sum(ways[:i - 1])\n    return ways[n]\n\ndef main():\n    print(numberOfWays(3))  # Expected output: 4\n    print(numberOfWays(10))  # Expected output: 274\n    print(numberOfWays(15))  # Expected output: 15750\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1260": "```\ndef shiftGrid(grid, k):\n    m, n = len(grid), len(grid[0])\n    res = [[0] * n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            index = (i + k // n) % m + (j + k % n) % n\n            res[index][n - 1 - (index + k // n) % m] = grid[i][j]\n            \n    return res\n\ndef main():\n    print(\"Test Case 1:\")\n    grid = [[1,2,3],[4,5,6],[7,8,9]]\n    k = 1\n    expected = [[9,1,2],[3,4,5],[6,7,8]]\n    print(shiftGrid(grid, k))\n    assert shiftGrid(grid, k) == expected\n    \n    print(\"\\nTest Case 2:\")\n    grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n    k = 4\n    expected = [[12,1,2,3],[4,5,6,7],[8,9,10,11]]\n    print(shiftGrid(grid, k))\n    assert shiftGrid(grid, k) == expected\n    \n    print(\"\\nTest Case 3:\")\n    grid = [[1,2], [3,4]]\n    k = 0\n    expected = [[1,2],[3,4]]\n    print(shiftGrid(grid, k))\n    assert shiftGrid(grid, k) == expected\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1261": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef findElements(root: TreeNode) -> list:\n    if not root:\n        return []\n\n    res = []\n    stack = [(root, 0)]\n    while stack:\n        node, depth = stack.pop()\n        if node:\n            if node.val % 2 == 1:\n                res.append((node.val, depth))\n            stack.append((node.right, depth + 1))\n            stack.append((node.left, depth + 1))\n\n    return [x[0] for x in sorted(res)]\n\ndef main():\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(6);\n    root.left.left = TreeNode(2);\n    root.left.right = TreeNode(4);\n\n    print(findElements(root)) # Expected output: [2, 3, 4, 5, 6]\n\n    root = None\n\n    print(findElements(root)) # Expected output: []\n\n    root = TreeNode(1)\n    root.left = TreeNode(3);\n    root.right = TreeNode(2);\n\n    print(findElements(root)) # Expected output: [1, 2, 3]\n```",
  "1262": "```\ndef maximumSumDivByThree(nums):\n    dp = [0, 0, 0]\n    for num in nums:\n        temp = dp[1:]\n        dp[0] = max(temp) if not num % 3 else 0\n        dp[1] = dp[0] + num\n        dp[2] = max(dp[1:] + [dp[0] + num]) % 3\n    return max(dp)\n\ndef main():\n    print(maximumSumDivByThree([10,12,-5,-6,7,3])) # expected output: 18\n    print(maximumSumDivByThree([-2,0,11,8,9]) # expected output: 24\n    print(maximumSumDivByThree([1,2,3,4,5,6])) # expected output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1263": "```\nimport heapq\n\ndef min_steps(grid):\n    m, n = len(grid), len(grid[0])\n    pq = [(0, 0)]\n    dist = [[float('inf')] * n for _ in range(m)]\n    dist[0][0] = 0\n    dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    while pq:\n        x, y = heapq.heappop(pq)\n        if x == m - 1 and y == n - 1: return dist[x][y]\n        \n        for dx, dy in dirs:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] > dist[x][y] + 1:\n                heapq.heappush(pq, (nx, ny))\n                dist[nx][ny] = dist[x][y] + 1\n\n    return -1\n\n\ndef main():\n    print(min_steps([[0,0,0],[0,1,0],[0,0,0]])) # Output: 8\n    print(min_steps([[0,0,0],[0,1,0],[0,0,1]])) # Output: 4\n    print(min_steps([[0,0,0],[0,0,1],[0,0,0]])) # Output: 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1264": "```\ndef recommendPageIndex(n, viewedPages):\n    from collections import defaultdict\n\n    indexToPage = {}\n    pageIndex = {}\n\n    for i in range(n):\n        pageIndex[i] = defaultdict(list)\n\n    for i, page in enumerate(viewedPages):\n        if page not in indexToPage:\n            indexToPage[page] = set()\n        indexToPage[page].add(i)\n        for idx in indexToPage[page]:\n            pageIndex[idx].append(page)\n\n    return [i for i in range(n) if len(pageIndex[i]) == 1]\n\ndef main():\n    test_cases = [\n        {\"n\": 4, \"viewedPages\": [0, 2]},\n        {\"n\": 4, \"viewedPages\": [0, 1, 3]},\n        {\"n\": 5, \"viewedPages\": [1, 2, 3]}\n    ]\n\n    for test_case in test_cases:\n        n = test_case[\"n\"]\n        viewedPages = test_case[\"viewedPages\"]\n        print(f\"Test case: {test_case}\")\n        result = recommendPageIndex(n, viewedPages)\n        print(f\"Expected result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1265": "```\nclass Solution:\n    def printListReverse(self, head):\n        if not head:\n            return\n        self.printListReverse(head.next)\n        print(head.val)\n\ndef main():\n    solution = Solution()\n    \n    # Test case 1: Empty list\n    head1 = None\n    solution.printListReverse(head1)\n    print(\"Expected output: []\")\n\n    # Test case 2: Single node list\n    head2 = ListNode(1)\n    solution.printListReverse(head2)\n    print(\"Expected output: [1]\")\n\n    # Test case 3: Multi-node list\n    head3 = ListNode(1)\n    head3.next = ListNode(2)\n    head3.next.next = ListNode(3)\n    solution.printListReverse(head3)\n    print(\"Expected output: [3, 2, 1]\")\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1266": "```\ndef minTimeToVisitAllPoints(points):\n    total_time = 0\n    for i in range(1, len(points)):\n        dx = abs(points[i][0] - points[i-1][0])\n        dy = abs(points[i][1] - points[i-1][1])\n        total_time += max(dx, dy)\n    return total_time\n\ndef main():\n    print(minTimeToVisitAllPoints([[0,0],[2,3]]))  # Expected output: 4\n    print(minTimeToVisitAllPoints([[1,1],[3,6],[8,10]]))  # Expected output: 9\n    print(minTimeToVisitAllPoints([[0,0],[1,1],[2,2]]))  # Expected output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1267": "```\ndef findServer(numServers, k, serverTime):\n    servers = [[] for _ in range(numServers)]\n    for i in range(len(serverTime)):\n        if serverTime[i][1] - serverTime[i-1][1] > k:\n            j = (serverTime[i][0] - 1) % numServers\n            while j < i:\n                if abs(serverTime[j][0] - serverTime[i][0]) > k:\n                    break\n                for s in servers[j]:\n                    for t in range(len(servers)):\n                        if t != j and s < serverTime[t][0] - serverTime[0][0]:\n                            servers[t].append(s)\n                j += 1\n    return len(set(map(lambda x: tuple(x), [s for srv in servers for s in srv])))\n\ndef main():\n    print(findServer(2, 5, [[0,10],[5,6],[7,15]])) # Expected output: 1\n    print(findServer(3, 2, [[0,5],[4,11]])) # Expected output: 2\n    print(findServer(5, 3, [[0,16],[1,4],[2,4],[5,10],[6,7],[7,9]])) # Expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1268": "```\ndef suggestedProducts(sellingProducts, searchedWord):\n    trie = {}\n    for product in sellingProducts:\n        node = trie\n        for char in product:\n            if char not in node:\n                node[char] = {}\n            node = node[char]\n        node['#'] = product\n\n    def dfs(node, prefix, products):\n        if '#' in node:\n            products.append(node['#'])\n        for c in sorted(node.keys()):\n            dfs(node[c], prefix + c, products)\n            if len(products) == 5:\n                return\n\n    products = []\n    dfs(trie, '', products)\n\n    def searchSuggestions(prefix, products):\n        node = trie\n        for char in prefix:\n            if char not in node:\n                return []\n            node = node[char]\n        products = [product for product in products if product.startswith(prefix)]\n        products.sort()\n        return products[:5]\n\n    searchedProducts = searchSuggestions(searchedWord, products)\n    return [products[:5], searchedProducts]\n\n\ndef main():\n    sellingProducts = [\"mobile\",\"mouse\",\"moneypot\",\"mall\"]\n    searchedWords = [\"mobile\",\"mouse\",\"moneypot\",\"mall\"]\n    print(suggestedProducts(sellingProducts, searchedWords))\n\n    sellingProducts = [\"havana\"]\n    searchedWords = [\"havanas\", \"habana\", \"habs\", \"haban\"]\n    print(suggestedProducts(sellingProducts, searchedWords))\n\n    sellingProducts = [\"bags\",\"bagels\",\"bacon\"]\n    searchedWords = [\"bags\",\"baga\",\"bagel\",\"badger\",\"bagels\"]\n    print(suggestedProducts(sellingProducts, searchedWords))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1269": "```\ndef numberOfWays(steps):\n    MOD = 10**9 + 7\n    dp = [0] * (steps+1)\n    dp[0] = 1\n    for i in range(1, steps+1):\n        dp[i] = sum(dp[:i]) % MOD\n    return dp[steps]\n\ndef main():\n    print(numberOfWays(3)) \n    print(numberOfWays(4))\n    print(numberOfWays(10))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1270": "```\ndef peopleReportToManager(managerId, reports):\n    result = {}\n    for person in reports:\n        if person['managerId'] not in result:\n            result[person['managerId']] = [person['id']]\n        else:\n            result[person['managerId']].append(person['id'])\n    return {k: len(v) for k, v in result.items()}\n\ndef main():\n    print(peopleReportToManager(1, [\n        {'id': 1, 'managerId': 2},\n        {'id': 2, 'managerId': 3},\n        {'id': 3, 'managerId': 4},\n        {'id': 4, 'managerId': 5},\n        {'id': 5, 'managerId': 1}\n    ]))\n\n    print(peopleReportToManager(3, [\n        {'id': 2, 'managerId': 3},\n        {'id': 4, 'managerId': 3},\n        {'id': 6, 'managerId': 3}\n    ]))\n\n    print(peopleReportToManager(1, [\n        {'id': 1, 'managerId': 1},\n        {'id': 2, 'managerId': 2},\n        {'id': 3, 'managerId': 2},\n        {'id': 4, 'managerId': 2}\n    ]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1271": "```\ndef toHexspeak(s):\n    s = s.upper()\n    result = \"\"\n    for char in s:\n        if '0' <= char <= '9':\n            hexspeak = \"0x\" + str(int(char)).upper() + \"E\"\n            result += hexspeak\n        elif char.isalpha():\n            if char == 'A':\n                result += \"10E\"\n            elif char == 'B':\n                result += \"1BE\"\n            elif char == 'C':\n                result += \"2CE\"\n            elif char == 'D':\n                result += \"DEE\"\n            elif char == 'E':\n                result += \"3EE\"\n            elif char == 'F':\n                result += \"4FE\"\n        else:\n            result += \"BAD CHARACTER: \" + char\n    return result\n\n\ndef main():\n    print(toHexspeak(\"1\"))  # Test case 1\n    print(toHexspeak(\"hello\"))  # Test case 2\n    print(toHexspeak(\"a1b3c5\"))  # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1272": "```\ndef removeInterval(intervals, toRemove):\n    result = []\n    for i in intervals:\n        if i[0] > toRemove[1]:\n            result.append(i)\n        elif i[1] < toRemove[0]:\n            result.append(i)\n        elif i[0] <= toRemove[0] and i[1] >= toRemove[1]:\n            continue\n        elif i[0] <= toRemove[0]:\n            if i[1] > toRemove[0]:\n                result.append([toRemove[0], i[1]])\n        elif i[0] < toRemove[1]:\n            if i[1] > toRemove[1]:\n                result.append([i[0], toRemove[1]])\n    return result\n\ndef main():\n    print(\"Test case 1:\")\n    intervals = [[0,2],[3,4],[5,7]]\n    toRemove = [2,6]\n    print(removeInterval(intervals, toRemove))\n    \n    print(\"\\nTest case 2:\")\n    intervals = [[0,10],[5,15]]\n    toRemove = [6,8]\n    print(removeInterval(intervals, toRemove))\n    \n    print(\"\\nTest case 3:\")\n    intervals = [[1,4],[8,10]]\n    toRemove = [4,7]\n    print(removeInterval(intervals, toRemove))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1273": "```\ndef pruneTree(root):\n    if not root:\n        return None\n\n    root.left = pruneTree(root.left)\n    root.right = pruneTree(root.right)\n\n    if not root.left and not root.right:\n        return None\n    elif not root.left:\n        return root.right\n    elif not root.right:\n        return root.left\n    else:\n        return root\n\ndef main():\n    # Test case 1: Single node tree\n    root = TreeNode(1)\n    print(pruneTree(root).val)  # Expected output: None\n\n    # Test case 2: Tree with all nodes to be deleted\n    root = TreeNode(1)\n    root.left = TreeNode(0)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(0)\n    root.left.right = TreeNode(1)\n    root.right.left = TreeNode(0)\n    root.right.right = TreeNode(1)\n\n    print(pruneTree(root).val)  # Expected output: None\n\n    # Test case 3: Tree with some nodes not to be deleted\n    root = TreeNode(1)\n    root.left = TreeNode(0)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(1)\n\n    print(pruneTree(root).val)  # Expected output: 1\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n```",
  "1274": "```\ndef numShips(board):\n    if not board:\n        return []\n\n    m, n = len(board), len(board[0])\n    ships = set()\n    for i in range(m):\n        for j in range(n):\n            if board[i][j] == 'O':\n                dfs(board, i, j, ships)\n\n    return list(ships)\n\n\ndef dfs(board, i, j, ships):\n    m, n = len(board), len(board[0])\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    for dx, dy in directions:\n        x, y = i + dx, j + dy\n        while 0 <= x < m and 0 <= y < n and board[x][y] == 'O':\n            ships.add((x, y))\n            board[x][y] = '-'\n            x += dx\n            y += dy\n\n\ndef main():\n    print(numShips([[\"O\", \"O\"], [\"O\", \"O\"]]))  # Output: [(0, 0), (0, 1), (1, 0), (1, 1)]\n    print(numShips([[\"O\"], [\"O\"]]))  # Output: [(0, 0), (1, 0)]\n    print(numShips([]))  # Output: []\n\nmain()\n```",
  "1275": "```\ndef tictactoe(board):\n    if board[0][0] == board[1][1] == board[2][2]:\n        return \"A\" if board[0][0] == 'X' else \"B\"\n    elif board[0][2] == board[1][1] == board[2][0]:\n        return \"A\" if board[0][2] == 'X' else \"B\"\n    for i in range(3):\n        if board[i][0] == board[i][1] == board[i][2]:\n            return \"A\" if board[i][0] == 'X' else \"B\"\n        if board[0][i] == board[1][i] == board[2][i]:\n            return \"A\" if board[0][i] == 'X' else \"B\"\n    return \"Draw\"\n\ndef main():\n    print(\"Test Case 1: \")\n    print(tictactoe([[\"O\", \"O\", \"O\"], [\" \", \" \", \" \"], [\"\", \"\", \"\"]])) # Expected Output: A\n    print(\"\\n\")\n\n    print(\"Test Case 2: \")\n    print(tictactoe([[\"X\", \"O\", \"\"], [\"O\", \"X\", \"\"], [\"\", \"\", \"\"]])) # Expected Output: B\n    print(\"\\n\")\n\n    print(\"Test Case 3: \")\n    print(tictactoe([[\"X\", \" \", \"\"], [\"O\", \"X\", \"\"], [\"\", \"O\", \"X\"]])) # Expected Output: Draw\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1276": "```\ndef numBurgers(deficient, fresh):\n    total_burgers = deficient // 2\n    remaining_deficient = deficient % 2\n    remaining_fresh = fresh - 2 * total_burgers\n    return total_burgers + (remaining_deficient > 0) + (remaining_fresh >= 4)\n\ndef main():\n    print(numBurgers(10, 12))\n    print(numBurgers(7, 5))\n    print(numBurgers(1, 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1277": "```\ndef countSquare(matrix):\n    if not matrix:\n        return 0\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * n for _ in range(m)]\n    res = 0\n\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                if i > 0 and j > 0:\n                    dp[i][j] = min(min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1\n                else:\n                    dp[i][j] = 1\n            res += dp[i][j] * dp[i][j]\n\n    return res\n\ndef main():\n    test_cases = [\n        {\"matrix\": [[0,1,1,0],[1,1,1,1], [0,1,1,0]], \"expected_result\": 6},\n        {\"matrix\": [[1,0,1],[1,1,1],[1,1,1]], \"expected_result\": 9},\n        {\"matrix\": [[0,0,0,1]], \"expected_result\": 1}\n    ]\n\n    for test_case in test_cases:\n        result = countSquare(test_case[\"matrix\"])\n        if result == test_case[\"expected_result\"]:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed. Expected {test_case['expected_result']}, but got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1278": "```\ndef pale_partition(s):\n    n = len(s)\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n    ans = float('inf')\n\n    for i in range(n):\n        dp[i][i] = True\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            dp[i][i + 1] = True\n        else:\n            dp[i][i + 1] = False\n\n    for len_ in range(3, n + 1):\n        for i in range(n - len_ + 1):\n            j = i + len_ - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = False\n\n    for i in range(1, n):\n        for j in range(n):\n            if i > j:\n                continue\n            if dp[i][j]:\n                ans = min(ans, j - i + 1)\n\n    return ans\n\n\ndef main():\n    print(pale_partition(\"aab\")) # Output: 3\n    print(pale_partition(\"baab\")) # Output: 4\n    print(pale_partition(\"a\")) # Output: 0",
  "1279": "```\ndef trafficLight(n, redCar):\n    lights = ['green' for _ in range(n)] + ['red']\n    res = []\n    \n    for i in range(len(lights)):\n        if i < n:\n            res.append(f\"{'.' * (n - i)}| {'R' if i == 0 else '.' * i} {'G' if lights[i] == 'green' else 'R'}\")\n        else:\n            res.append('.|')\n    \n    return '\\n'.join(res)\n\ndef main():\n    print(trafficLight(2, True))\n    print(trafficLight(3, False))\n    print(trafficLight(4, True))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1280": "```\ndef countGoodTriplets(root):\n    # Your code here\n\ndef main():\n    root = TreeNode(1)\n    root.left = TreeNode(4)\n    root.right = TreeNode(5)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(3)\n\n    print(countGoodTriplets(root))  # Test case 1: Should return 3\n    print(countGoodTriplets(None))   # Test case 2: Should return 0\n    print(countGoodTriplets(TreeNode(1)))  # Test case 3: Should return 0\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n```",
  "1281": "```\ndef getLucky(n):\n    s = sum(int(digit) for digit in str(n))\n    p = 1\n    for digit in str(n):\n        p *= int(digit)\n    return abs(s - p)\n\ndef main():\n    print(getLucky(123)) \n    print(getLucky(390)) \n    print(getLucky(28)) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1282": "```\ndef arrangeCars(cars):\n    car_dict = {}\n    for car in cars:\n        if car not in car_dict:\n            car_dict[car] = 0\n        car_dict[car] += 1\n\n    result = []\n    for group_size, count in sorted(car_dict.items()):\n        result.extend([group_size] * count)\n\n    return result\n\ndef main():\n    test_cases = [\n        ([10], [5, (1, 1), 5]),\n        ([3, 3, 2], [1, 3, 1, 1, 2]),\n        ([6,0,2,0,0,4,5,0], [1,1,4,(1,1),(5)]),\n    ]\n\n    for i, test_case in enumerate(test_cases):\n        print(f\"Test Case {i+1}:\")\n        print(arrangeCars(test_case[0]))\n        print(test_case[1])\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1283": "```\ndef smallestDivisor(nums, threshold):\n    left, right = 1, max(nums)\n    while left < right:\n        mid = (left + right) // 2\n        total_divisors = sum(divisors(mid))\n        if total_divisors <= threshold:\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\ndef divisors(n):\n    result = [i for i in range(1, n+1) if n % i == 0]\n    return result\n\ndef main():\n    print(smallestDivisor([12, 15, 25], 5))  # Output: 3\n    print(smallestDivisor([37, 41, 43, 44, 46, 47], 3))  # Output: 4\n    print(smallestDivisor([1, 2, 3, 4, 5, 6], 9))  # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1284": "```\ndef minFlips(side1, side2):\n    return (side1 ^ side2).bit_length()\n\ndef main():\n    print(minFlips(0b11110, 0b11000)) # Test case 1\n    print(minFlips(0b10101010, 0b10101010)) # Test case 2\n    print(minFlips(0b10000001, 0b10000001)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1285": "```\ndef findContinuousRange(nums):\n    if not nums:\n        return []\n\n    nums.sort()\n    result = []\n    start = end = nums[0]\n\n    for i in range(1, len(nums)):\n        if nums[i] == end + 1:\n            end += 1\n        else:\n            if start != end:\n                result.append([start, end])\n            start = end = nums[i]\n\n    if start != end:\n        result.append([start, end])\n\n    return result\n\n\ndef main():\n    print(findContinuousRange([0, 1, 2, 5, 7, 8, 9]))  # [[0, 2], [5, 8]]\n    print(findContinuousRange([0, 1, 3, 4, 6, 8, 10, 13, 19]))  # [[0, 1], [3, 6], [8, 10], [13, 19]]\n    print(findContinuousRange([0, 2, 3]))  # [[0, 0], [2, 3]]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1287": "```\ndef findSpecialInteger(arr):\n    n = len(arr)\n    target_index = (n - 1) // 4\n    return arr[target_index]\n\ndef main():\n    print(findSpecialInteger([1, 2, 2, 6, 6, 6, 6])) \n    print(findSpecialInteger([1, 3, 5, 9, 15, 20]))\n    print(findSpecialInteger([1, 2]))\n\nmain()\n```",
  "1286": "```\ndef combine(n, k):\n    def backtrack(start, path):\n        if len(path) == k:\n            result.append(\"\".join(path))\n            return\n        for end in range(start, n+1):\n            path.append(str(end))\n            backtrack(end + 1, path)\n            path.pop()\n\n    result = []\n    backtrack(1, [])\n    class CombinationIterator:\n        def __init__(self, combinations, k):\n            self.combinations = combinations\n            self.k = k\n\n        def hasNext(self):\n            return len(self.combinations) > 0\n\n        def next(self):\n            if not self.hasNext():\n                return None\n            result = self.combinations.pop(0)\n            self.combinations.append(result)\n            return result\n\n    n = 3\n    k = 2\n    iterator = CombinationIterator(combinations(combin(n, k)), k)\n\n    main()\n    def main():\n        print(\"Test case 1:\")\n        while iterator.hasNext():\n            print(iterator.next())\n        print()\n\n        iterator = CombinationIterator(combinations(combin(4, 3)), 3)\n        print(\"Test case 2:\")\n        while iterator.hasNext():\n            print(iterator.next())\n        print()\n\n        iterator = CombinationIterator(combinations(combin(1, 1)), 1)\n        print(\"Test case 3:\")\n        while iterator.hasNext():\n            print(iterator.next())\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "1288": "```\ndef removeCoveredIntervals(intervals):\n    if not intervals:\n        return []\n\n    intervals.sort(key=lambda x: (x[0], x[1]))\n\n    res = [intervals[0]]\n    for interval in intervals[1:]:\n        if interval[0] > res[-1][0]:\n            res.append(interval)\n        elif interval[1] > res[-1][1]:\n            res[-1] = (res[-1][0], interval[1])\n    return res\n\ndef main():\n    print(removeCoveredIntervals([[1,4],[3,5],[-1,-1]]))\n    print(removeCoveredIntervals([[0,10],[5,12],[13,23],[-24,25]]))\n    print(removeCoveredIntervals([[1,2],[1,2]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1289": "```\ndef minFallingPathSum(matrix):\n    n = len(matrix)\n    m = [[0] * n for _ in range(n)]\n    m[0][0] = matrix[0][0]\n    for i in range(1, n):\n        m[i][0] = m[i-1][0] + matrix[i][0]\n    for j in range(1, n):\n        m[0][j] = m[0][j-1] + matrix[0][j]\n    for i in range(1, n):\n        for j in range(1, n):\n            m[i][j] = min(m[i-1][j], m[i][j-1]) + matrix[i][j]\n    return min([row[-1] for row in m])\n\ndef main():\n    print(minFallingPathSum([[2,1,3],\n                             [6,5,4],\n                             [7,8,9]])) # Output: 13\n    print(minFallingPathSum([[3,2,1,4,5],\n                             [1,5,3,2,1],\n                             [4,2,1,5,3],\n                             [5,1,1,2,1],\n                             [2,4,5,3,3]])) # Output: 11\n    print(minFallingPathSum([[1,2,3],\n                             [4,5,6],\n                             [7,8,9]])) # Output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1290": "```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef getDecimalValue(head: ListNode) -> int:\n    decimal = 0\n    while head:\n        decimal = (decimal << 1) | head.val\n        head = head.next\n    return decimal\n\n\ndef main():\n    # Test Case 1\n    node1 = ListNode(0)\n    node2 = ListNode(1)\n    head = node2\n    node2.next = node1\n    print(getDecimalValue(head))  # Expected Output: 3\n\n    # Test Case 2\n    node1 = ListNode(1)\n    node2 = ListNode(0)\n    head = node2\n    node2.next = node1\n    print(getDecimalValue(head))  # Expected Output: 5\n\n    # Test Case 3\n    node1 = ListNode(1)\n    node2 = ListNode(0)\n    node3 = ListNode(1)\n    head = node3\n    node3.next = node2\n    node2.next = node1\n    print(getDecimalValue(head))  # Expected Output: 5\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1291": "```\ndef sequentialDigits(low: int, high: int) -> List[int]:\n    def is_sequential(num: int) -> bool:\n        prev_digit = -1\n        for digit in str(num):\n            if int(digit) < prev_digit + 1:\n                return False\n            prev_digit = int(digit)\n        return True\n\n    result = []\n    for length in range(len(str(low)), len(str(high)) + 1):\n        for start in range(1, 10):\n            num = int(''.join(map(str, range(start, start + length))))\n            if low <= num <= high and is_sequential(num):\n                result.append(num)\n    return sorted(result)\n\ndef main():\n    print(sequentialDigits(100, 300))\n    print(sequentialDigits(250, 1296))\n    print(sequentialDigits(1, 123456))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1292": "```\ndef maxSideLength(matrix, threshold):\n    m, n = len(matrix), len(matrix[0])\n    prefix_sum = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            prefix_sum[i][j] = matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1]\n    \n    max_side_length = 0\n    for i in range(m):\n        for j in range(n):\n            for k in range(i, m):\n                for end_col in range(j, n):\n                    if (prefix_sum[k + 1][end_col + 1] - prefix_sum[k + 1][j] - prefix_sum[i][end_col + 1] + prefix_sum[i][j]) <= threshold:\n                        max_side_length = max(max_side_length, min(k - i + 1, end_col - j + 1))\n    return max_side_length\n\ndef main():\n    test_cases = [\n        {\"matrix\": [[0,1,1,1],[1,1,1,1],[1,0,1,0]], \"threshold\": 6, \"expected_output\": 3},\n        {\"matrix\": [[1,0,1],[0,1,0],[1,1,1]], \"threshold\": 4, \"expected_output\": 1},\n        {\"matrix\": [[1,0,1,1,0,0,0],[0,0,1,1,1,1,0],[0,0,0,1,1,1,1],[1,1,1,1,1,1,1]], \"threshold\": 11, \"expected_output\": 4}\n    ]\n    \n    for test_case in test_cases:\n        matrix = test_case[\"matrix\"]\n        threshold = test_case[\"threshold\"]\n        expected_output = test_case[\"expected_output\"]\n        \n        actual_output = maxSideLength(matrix, threshold)\n        if actual_output == expected_output:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected output: {expected_output}, but got {actual_output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1293": "```\ndef shortestPath(grid):\n    if not grid or not grid[0]:\n        return -1\n    m, n = len(grid), len(grid[0])\n    pq = [(grid[0][0], 0, 0)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    visited = set((0, 0))\n    while pq:\n        distance, x, y = heapq.heappop(pq)\n        if x == m - 1 and y == n - 1:\n            return distance\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                new_distance = distance + grid[nx][ny]\n                if grid[nx][ny] == 1:\n                    heapq.heappush(pq, (new_distance, nx, ny))\n                else:\n                    visited.add((nx, ny))\n                    heapq.heappush(pq, (new_distance, nx, ny))\n\ndef main():\n    test_case1 = [\n        [0, 1],\n        [1, 1]\n    ]\n    print(shortestPath(test_case1))  # Output: 2\n\n    test_case2 = [\n        [0, 0, 0],\n        [1, 1, 0],\n        [1, 1, 0]\n    ]\n    print(shortestPath(test_case2))  # Output: -1\n\n    test_case3 = [\n        [0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 0, 0, 0],\n        [0, 1, 0, 1, 0],\n        [0, 0, 0, 0, 0]\n    ]\n    print(shortestPath(test_case3))  # Output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1294": "```\ndef findWeatherType(countries):\n    weather_types = {}\n    for country in countries:\n        if country[1] == 'USA':\n            weather_types[country[0]] = 'Sunny'\n        elif country[1] == 'Canada':\n            weather_types[country[0]] = 'Rainy'\n        else:\n            weather_types[country[0]] = 'Cloudy'\n    return weather_types\n\ndef main():\n    countries = [\n        ['USA', 'New York'],\n        ['Canada', 'Toronto'],\n        ['Australia', 'Sydney']\n    ]\n    \n    test_cases = [\n        (countries, {'USA': 'Sunny', 'Canada': 'Rainy', 'Australia': 'Cloudy'}),\n        ([['Japan', 'Tokyo']], {'Japan': 'Cloudy'}),\n        ([\n            ['Mexico', 'Mexico City'],\n            ['Germany', 'Berlin']\n        ], {'Mexico': 'Sunny', 'Germany': 'Cloudy'})\n    ]\n\n    for test_case in test_cases:\n        result = findWeatherType(test_case[0])\n        if result == test_case[1]:\n            print(\"Test case passed.\")\n        else:\n            print(\"Test case failed. Expected: \", test_case[1], \" Got: \", result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1295": "```\ndef findEvenNumbers(arr):\n    return [num for num in arr if len(str(num)) % 2 == 0]\n\ndef main():\n    print(findEvenNumbers([12, 345, 2, 6, 9208])) \n    print(findEvenNumbers([555, 901, 894]) ) \n    print(findEvenNumbers([4225, 1234, 9182, 9234])) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1296": "```\ndef divideArray(nums, k):\n    nums.sort()\n    for i in range(0, len(nums), k):\n        if nums[i:i+k] != list(range(nums[i], nums[i]+k)):\n            return False\n    return True\n\n\ndef main():\n    print(divideArray([3, 2, 1, 4], 3))  # Expected: True\n    print(divideArray([true, 3, -1, -3, 5, 2, -2], 3))  # Expected: False\n    print(divideArray([0, 0], 3))  # Expected: False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1297": "```\ndef maxFreq(s: str, maxLen: int) -> str:\n    max_len = 0\n    max_freq = 0\n    result = \"\"\n\n    for i in range(len(s)):\n        for j in range(i + 1, min(i + maxLen + 1, len(s) + 1)):\n            substr = s[i:j]\n            if s.count(substr) > max_freq:\n                max_len = len(substr)\n                max_freq = s.count(substr)\n                result = substr\n\n    return result\n\n\ndef main():\n    test_cases = [\n        {\"s\": \"aab\", \"maxLen\": 2, \"expected_result\": \"aa\"},\n        {\"s\": \"aabcc\", \"maxLen\": 3, \"expected_result\": \"bcc\"},\n        {\"s\": \"abab\", \"maxLen\": 2, \"expected_result\": \"ab\"}\n    ]\n\n    for test_case in test_cases:\n        s = test_case[\"s\"]\n        max_len = test_case[\"maxLen\"]\n        expected_result = test_case[\"expected_result\"]\n\n        result = maxFreq(s, max_len)\n\n        if result == expected_result:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}, Expected {expected_result} but got {result}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1298": "```\ndef maximumCandies(boxes):\n    res = [0] * len(boxes)\n    for i in range(len(boxes)):\n        if boxes[i]:\n            for j in range(i+1, len(boxes)):\n                res[j] += 1\n                if not boxes[j]:\n                    break\n    return sum(res)\n\ndef main():\n    test_cases = [\n        ([1,0,2,0], 4),\n        ([3,1,6,5,4,2], 7),\n        ([10], 10)\n    ]\n\n    for test_case in test_cases:\n        print(f\"Input: {test_case[0]}, Expected Output: {test_case[1]}\")\n        output = maximumCandies(test_case[0])\n        if output == test_case[1]:\n            print(\"Test Passed!\")\n        else:\n            print(f\"Test Failed! Got {output} instead of {test_case[1]}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1299": "```\ndef replaceElements(arr):\n    n = len(arr)\n    res = [-1]*n\n    maxRight = arr[n-1]\n    for i in range(n-2, -1, -1):\n        if arr[i] > maxRight:\n            maxRight = arr[i]\n        else:\n            res[i] = maxRight\n    return res\n\ndef main():\n    print(replaceElements([17, 18, 5, 4, 3, 19])) \n    print(replaceElements([-1, -1, -1])) \n    print(replaceElements([0,0]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1300": "```\ndef findBestIndex(nums, target):\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid\n    nums.sort()\n    closest_sum = float('inf')\n    for i in range(len(nums)):\n        sum = 0\n        for j in range(i, len(nums)):\n            sum += nums[j]\n            if abs(target - sum) < abs(target - closest_sum):\n                closest_sum = sum\n    return sum\n\ndef main():\n    print(findBestIndex([2,3,4,1], 7)) # Expected: 5\n    print(findBestIndex([-2,-3,4], 1)) # Expected: 1\n    print(findBestIndex([1,1,-50,60,60], 60)) # Expected: 60\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1301": "```\ndef maxScore(self, grid: List[List[int]]) -> int:\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * (n+1) for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if grid[i-1][j-1]:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\n    res = 0\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if grid[i-1][j-1]:\n                res = max(res, dp[i-1][j] - 1 + dp[i][j-1] - 1)\n\n    return res\n\n\ndef main():\n    test_cases = [\n        {\"grid\": [[0,1,2,3],[4,5,6,7]], \"expected\": 8},\n        {\"grid\": [[0,1,2,3],[4,5,0,7]], \"expected\": 12},\n        {\"grid\": [[0,1,2],[3,4,5],[6,7,8]], \"expected\": 13}\n    ]\n\n    for test_case in test_cases:\n        result = Number_of_Paths_with_Max_Score()\n        assert result.maxScore(test_case[\"grid\"]) == test_case[\"expected\"], f\"Test case failed: {test_case}\"\n\n    print(\"All test cases passed!\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1302": "```\nclass Solution:\n    def deepestLeavesSum(self, root):\n        if not root:\n            return 0\n        \n        queue = [(root, 0)]\n        max_level = 0\n        result = 0\n        \n        while queue:\n            node, level = queue.pop(0)\n            if level > max_level:\n                max_level = level\n                result = node.val\n            elif level == max_level:\n                result += node.val\n            \n            if node.left:\n                queue.append((node.left, level + 1))\n            if node.right:\n                queue.append((node.right, level + 1))\n        \n        return result\n\ndef main():\n    s = Solution()\n    \n    root = [3,4,5,1,1,2,null,null,null,1,null,null,6,null,null,null,2,null]\n    root = TreeNode.fromList(root)\n    print(s.deepestLeavesSum(root))  # Expected output: 6\n\n    root = [1,2,3,4,5,null,null,null,null,null,null,null,6]\n    root = TreeNode.fromList(root)\n    print(s.deepestLeavesSum(root))  # Expected output: 6\n\n    root = [6,7,8,2,null,null,null,null,null,null,9, null, null,null,1]\n    root = TreeNode.fromList(root)\n    print(s.deepestLeavesSum(root))  # Expected output: 15\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n    \n    @classmethod\n    def fromList(cls, nodes):\n        if not nodes:\n            return None\n        \n        root = cls(nodes[0])\n        queue = [root]\n        \n        i = 1\n        while queue and i < len(nodes):\n            node = queue.pop(0)\n            \n            if nodes[i]:\n                node.left = cls(nodes[i])\n                queue.append(node.left)\n            i += 1\n            \n            if i < len(nodes) and nodes[i]:\n                node.right = cls(nodes[i])\n                queue.append(node.right)\n            i += 1\n        \n        return root\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1303": "```\ndef totalTeams(time, team):\n    return sum([1 for i in range(len(team)) if time[i] >= 60])\n\ndef main():\n    print(\"Test Case 1: \")\n    time = [120, 45, 50, 90]\n    team = [\"A\", \"B\", \"C\", \"D\"]\n    print(f\"Time: {time}, Team Size: {totalTeams(time, team)}\")\n\n    print(\"\\nTest Case 2: \")\n    time = [60, 30, 40, 80]\n    team = [\"E\", \"F\", \"G\", \"H\"]\n    print(f\"Time: {time}, Team Size: {totalTeams(time, team)}\")\n\n    print(\"\\nTest Case 3: \")\n    time = [90, 100, 50, 70]\n    team = [\"I\", \"J\", \"K\", \"L\"]\n    print(f\"Time: {time}, Team Size: {totalTeams(time, team)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1304": "```\ndef sumZero(n):\n    return [i - (n + i) // 2 for i in range(1, n+1)]\n\ndef main():\n    print(sumZero(5))  # Expected output: [-3, -1, 0, 1, 3]\n    print(sumZero(3))  # Expected output: [-1, 0, 1]\n    print(sumZero(4))  # Expected output: [-2, -1, 0, 1]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1305": "```\ndef getAllElements(root1, root2):\n    def inorder(node):\n        result = []\n        if node:\n            result += inorder(node.left)\n            result.append(node.val)\n            result += inorder(node.right)\n        return result\n    \n    return sorted(inorder(root1) + inorder(root2))\n\ndef main():\n    # Test case 1\n    root1 = TreeNode(2)\n    root1.left = TreeNode(1)\n    root1.right = TreeNode(4)\n    root2 = TreeNode(6)\n    root2.left = TreeNode(5)\n    root2.right = TreeNode(8)\n    print(getAllElements(root1, root2))  # Output: [1, 2, 4, 5, 6, 8]\n\n    # Test case 2\n    root1 = TreeNode(1)\n    root1.left = TreeNode(0)\n    root1.right = TreeNode(3)\n    root2 = TreeNode(2)\n    root2.left = TreeNode(1)\n    root2.right = TreeNode(4)\n    print(getAllElements(root1, root2))  # Output: [0, 1, 1, 2, 3, 4]\n\n    # Test case 3\n    root1 = TreeNode(5)\n    root1.left = TreeNode(3)\n    root1.right = TreeNode(7)\n    root2 = TreeNode(10)\n    root2.left = TreeNode(9)\n    root2.right = TreeNode(11)\n    print(getAllElements(root1, root2))  # Output: [3, 5, 7, 9, 10, 11]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1306": "```\ndef maxResult(self, nums: List[int]) -> int:\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    for i in range(1, len(nums)):\n        dp[i] = max(dp[:i])\n        if i + nums[i] > len(nums) - 1:\n            continue\n        if i + nums[i] < len(nums):\n            dp[i + nums[i]] = max(dp[i + nums[i]], dp[i] + nums[i])\n    return dp[-1]\n\ndef main():\n    print(maxResult([4,2,3,0,3,1,5]))  # Expected output: 6\n    print(maxResult([10,1,0,1,5,-2,-2,7,13,14,5,1,1,-2,0,1]) )  # Expected output: 26\n    print(maxResult([-1,-2,-3,1,1,-5,6,3]) )  # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1308": "```\ndef totalMoneyByGender(queries):\n    n = len(queries)\n    res = [0] * (n + 1)\n    for query in queries:\n        res[query[1]] += query[0]\n    return [res[i+1]-res[i] if i > 0 else res[i] for i in range(n)]\n\ndef main():\n    queries1 = [[4,500],[11,400,300],[10,300,1000]]\n    print(totalMoneyByGender(queries1))\n    \n    queries2 = [[5,1000],[20,2000],[15,800]]\n    print(totalMoneyByGender(queries2))\n\n    queries3 = [[8,200],[6,150,30,50,40,40],[2,300,500,400,1000,10,20,10,10]]\n    print(totalMoneyByGender(queries3))\n    \nmain()\n```",
  "1307": "```\ndef isSolvable(board):\n    return False\n\ndef backtrack(board, index, words):\n    if index >= len(words):\n        return True\n    for i in range(len(words[index])):\n        for j in range(10):\n            word = str(j) * (i + 1)\n            if board and not all(c == d or c == '-' for c, d in zip(board, word)):\n                new_board = [board[i] + word[i] if len(board) > i else word[i] for i in range(len(board))]\n                if backtrack(new_board, index + 1, words):\n                    return True\n    return False\n\ndef findNumOfValidWords(board, dictionary):\n    return sum(1 for _ in (word for word in set(''.join(sorted(c)) for c in board) if isSolvable(board)))\n\ndef main():\n    print(findNumOfValidWords([\"Hit\",\"Bita\",\"Laba\",\"Laba\"], [\"Hit\", \"Laba\"]))\n    print(findNumOfValidWords([\"Pad\",\"TopOrder\",\"See\",\"Fair\"],\"[\"TopOrder\"])\n    print(findNumOfValidWords([\"Up\",\"Down\",\"Up\",\"Up\",\"Down\",\"Up\",\"Up\"],[\"Up\",\"Down\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1309": "```\ndef freqAlphabets(s):\n    n = len(s)\n    res = []\n    i = 0\n    while i < n:\n        if i + 2 <= n and s[i+2].isalpha():\n            res.append(ord(s[i+2]) - 96)\n            i += 3\n        elif i + 1 <= n and s[i+1].isalpha():\n            res.append(ord(s[i+1]) - 96)\n            i += 2\n        else:\n            res.append(ord(s[i]) - 96)\n            i += 1\n    return ''.join(map(chr, res))\n\ndef main():\n    print(freqAlphabets(\"10#11#12\") == \"kkk\")\n    print(freqAlphabets(\"383233a2345676465289218e11228311694311112228\") == \"az1z4z2z2z1z4z6z6z3z1z0z1z1z5z1z2z2z7z2z3z8\")\n    print(freqAlphabets(\"a10#11b10#12c17z16\") == \"wxy\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1310": "```\ndef rangeSum(nums, left, right):\n    result = 0\n    for i in range(len(nums)):\n        if left <= i <= right:\n            result ^= nums[i]\n    return result\n\n\ndef xorQueries(nums, queries):\n    prefix_sum = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        prefix_sum[i + 1] = prefix_sum[i] ^ nums[i]\n\n    results = []\n    for query in queries:\n        left, right = query\n        if left == 0:\n            results.append(prefix_sum[right + 1])\n        else:\n            results.append(prefix_sum[right + 1] - prefix_sum[left])\n\n    return results\n\n\ndef main():\n    nums = [1, 3, 4, 2, 7, 8, 3]\n    queries = [[0, 1], [6, 5], [14, 7]]\n    print(xorQueries(nums, queries))\n\n    nums = [1, 4, 5]\n    queries = [[3, 2], [1, 0]]\n    print(xorQueries(nums, queries))\n\n    nums = [8, 10, 8, 7, 9]\n    queries = [[6, 6], [1, 1], [8, 7]]\n    print(xorQueries(nums, queries))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1312": "```\ndef minInsertions(s):\n    n = len(s)\n    table = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        table[i][0] = i\n        for j in range(1, n + 1):\n            if s[i - 1] == s[n - j]:\n                table[i][j] = table[i - 1][j - 1]\n            else:\n                table[i][j] = 1 + min(table[i - 1][j], table[i][j - 1])\n\n    return table[n][n]\n\ndef main():\n    print(minInsertions(\"zzazz\")) # Test case 1\n    print(minInsertions(\"no\")) # Test case 2\n    print(minInsertions(\"nax\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1311": "```\ndef watched_videos_by_friends(watched_videos, friend_ids):\n    graph = {}\n    for video_id, friends in watched_videos.items():\n        for friend_id in friends:\n            if friend_id not in graph:\n                graph[friend_id] = set()\n            graph[friend_id].add(video_id)\n\n    seen_videos = set()\n    result = []\n    for friend_id, videos in sorted(graph.items()):\n        friend_videos = set(videos)\n        for video_id in friend_videos:\n            if video_id not in seen_videos:\n                seen_videos.add(video_id)\n                result.append((video_id, friend_id))\n        for video_id in list(seen_videos):\n            if video_id not in friend_videos:\n                seen_videos.remove(video_id)\n\n    return result\n\ndef main():\n    watched_videos = {\n        \"A\": [\"C\", \"F\"],\n        \"B\": [\"A\", \"B\", \"C\"],\n        \"C\": [\"E\", \"H\"],\n        \"D\": [],\n        \"E\": [\"I\"],\n        \"F\": [\"G\"],\n        \"G\": [\"H\", \"I\"],\n        \"H\": [\"D\", \"F\"],\n        \"I\": []\n    }\n    print(watched_videos_by_friends(watched_videos, [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\"]))\n    \n    watched_videos = {\n        \"1\": [\"2\", \"3\", \"4\"],\n        \"2\": [\"5\", \"6\"],\n        \"3\": [\"7\", \"8\"],\n        \"4\": [\"9\", \"10\"],\n        \"5\": [],\n        \"6\": [\"11\"],\n        \"7\": [\"12\"],\n        \"8\": [\"13\"],\n        \"9\": [\"14\"],\n        \"10\": [\"15\"],\n        \"11\": [\"16\"],\n        \"12\": [\"17\"],\n        \"13\": [\"18\"],\n        \"14\": [\"19\"],\n        \"15\": [\"20\"],\n        \"16\": [],\n        \"17\": [\"21\"],\n        \"18\": [\"22\"],\n        \"19\": [\"23\"],\n        \"20\": [\"24\"],\n        \"21\": [\"25\"],\n        \"22\": [\"26\"],\n        \"23\": [\"27\"],\n        \"24\": [\"28\"],\n        \"25\": [\"29\"],\n        \"26\": [\"30\"],\n        \"27\": [],\n        \"28\": [\"31\"],\n        \"29\": [\"32\"],\n        \"30\": [\"33\"],\n        \"31\": [\"34\"],\n        \"32\": [\"35\"],\n        \"33\": [\"36\"],\n        \"34\": [\"37\"],\n        \"35\": [\"38\"],\n        \"36\": [\"39\"],\n        \"37\": [\"40\"],\n        \"38\": [],\n        \"39\": [\"41\"],\n        \"40\": [\"42\"]\n    }\n    print(watched_videos_by_friends(watched_videos, list(range(1, 43))))\n    \n    watched_videos = {\n        \"0\": []\n    }\n    print(watched_videos_by_friends(watched_videos, [0]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1313": "```\ndef decompressRLElist(nums):\n    res = []\n    i = 0\n    while i < len(nums):\n        count = nums[i]\n        val = nums[i + 1]\n        for _ in range(count):\n            res.append(val)\n        i += 2\n    return res\n\ndef main():\n    print(decompressRLElist([1,2,3,4])) # [1,2,3,4]\n    print(decompressRLElist([1,1,2,3]) # [1,2,3]\n    print(decompressRLElist([10,1,2,4,4,4,7,2]) # [1,2,4,4,4,7,2]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1314": "```\ndef numSpecialEquivGroups(grid):\n    return len(set(tuple(sorted([grid[i][j], grid[i][k]])) for i in range(len(grid)) for j in range(len(grid[0])) for k in range(j+1, len(grid[0]))))\n\ndef main():\n    print(numSpecialEquivGroups([[\"a\",\"b\",\"c\"],[\"x\",\"y\",\"z\"]])) # 1\n    print(numSpecialEquivGroups([[\"x\",\"x\",\"y\"],[\"y\",\"x\",\"x\"],[\"xy\",\"xx\",\"zz\"]])) # 2\n    print(numSpecialEquivGroups([[\"a\",\"b\",\"c\",\"d\"],[\"x\",\"y\",\"z\",\"w\"],[\"q\",\"r\",\"s\",\"t\"],[\"p\",\"j\",\"k\",\"i\"]])) # 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1315": "```\nclass Solution:\n    def sumEvenGrandparent(self, root):\n        if not root:\n            return 0\n        \n        result = 0\n        self.dfs(root, None, None)\n        \n        return result\n    \n    def dfs(self, node, parent, grandparent):\n        if node.left and (node.val % 2 == 1 or parent.val % 2 != 0 or grandparent.val % 2 != 0):\n            result = 0\n            self.dfs(node.left, node, node)\n            result += node.left.val\n            self.dfs(node.right, node, node)\n            result += node.right.val if node.right else 0\n            return result\n        \n        if node:\n            grandparent = parent\n            parent = None\n            self.dfs(node.left, node, parent)\n            self.dfs(node.right, node, parent)\n\ndef main():\n    solution = Solution()\n    root1 = TreeNode(6)\n    root1.left = TreeNode(4)\n    root1.right = TreeNode(2);\n    root1.left.left = TreeNode(0);\n    root1.left.right = TreeNode(2);\n    root1.right.left = TreeNode(5);\n    root1.right.right = TreeNode(5);\n\n    print(solution.sumEvenGrandparent(root1))  # Expected: 18\n\n    root2 = TreeNode(1)\n    root2.left = TreeNode(4)\n    root2.right = TreeNode(3);\n\n    print(solution.sumEvenGrandparent(root2))  # Expected: 6\n\n    root3 = TreeNode(0);\n    \n    print(solution.sumEvenGrandparent(root3))  # Expected: 0\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1316": "```\ndef numEchoSubstrings(s):\n    n = len(s)\n    res = set()\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if s[i:j] == s[j - 1:i:-1]:\n                res.add((i, j))\n    return len(res)\n\ndef main():\n    print(numEchoSubstrings(\"aabbaaba\")) # test case 1\n    print(numEchoSubstrings(\"a\")) # test case 2\n    print(numEchoSubstrings(\"aaaa\")) # test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1317": "```\ndef addDigits(num):\n    while num > 9:\n        num = sum(int(digit) for digit in str(num))\n    return num\n\n\ndef main():\n    print(\"Test Case 1:\")\n    assert addDigits(38) == 2, f\"Expected addDigits(38) to return 2, but got {addDigits(38)}\"\n    \n    print(\"\\nTest Case 2:\")\n    assert addDigits(123) == 6, f\"Expected addDigits(123) to return 6, but got {addDigits(123)}\"\n    \n    print(\"\\nTest Case 3:\")\n    assert addDigits(4931934) == 2, f\"Expected addDigits(4931934) to return 2, but got {addDigits(4931934)}\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1318": "```\ndef minFlips(a: int, b: int, c: int) -> int:\n    return bin(c ^ (a | b)).count('1')\n\ndef main():\n    print(minFlips(2,6,5)) \n    print(minFlips(4,2,7)) \n    print(minFlips(9,3,15))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1319": "```\ndef makeConnected(n: int, connections: list) -> int:\n    parent = list(range(n))\n    rank = [0] * n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    def union(x, y):\n        root_x, root_y = find(x), find(y)\n        if root_x != root_y:\n            parent[root_x] = root_y\n            rank[root_y] += 1\n    for u, v in connections:\n        union(u, v)\n    ans = 0\n    for i in range(n):\n        if parent[i] == i:\n            ans = max(ans, rank[find(i)])\n    return n - 1 - ans\n\ndef main():\n    print(makeConnected(5, [[0,1],[1,2],[2,3],[3,4]])) # expected output: 1\n    print(makeConnected(6, [[0,1],[0,2],[1,2]])) # expected output: 2\n    print(makeConnected(7, [[0,1],[1,2},{1,3},{2,4},{3,5},{4,6}])) # expected output: -1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1320": "```\ndef minSteps(N):\n    if N <= 1:\n        return 0\n    \n    dp = [float('inf')] * (N + 1)\n    dp[2] = 2\n    for i in range(2, N+1):\n        for j in range(i):\n            if i % (j+1) == 0:\n                dp[i] = min(dp[i], dp[j] + (i// (j+1)))\n    \n    return dp[N]\n\ndef main():\n    print(minSteps(3))  # Expected output: 4\n    print(minSteps(5))  # Expected output: 8\n    print(minSteps(7))  # Expected output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1321": "```\ndef totalRevenue(shops):\n    return sum(num * money for num, money in shops)\n\ndef main():\n    print(\"Test case 1:\")\n    shops = [(5, 10), (2, 8)]\n    print(f\"Total Revenue: {totalRevenue(shops)}\")\n\n    print(\"\\nTest case 2:\")\n    shops = [(3, 12), (4, 15), (2, 9)]\n    print(f\"Total Revenue: {totalRevenue(shops)}\")\n\n    print(\"\\nTest case 3:\")\n    shops = []\n    print(f\"Total Revenue: {totalRevenue(shops)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1322": "```\ndef get_performance( click_times, impression_times):\n    return [click / impression for click, impression in zip(click_times, impression_times)]\n\ndef main():\n    print(\"Test case 1:\")\n    click_times = [10, 20]\n    impression_times = [100, 200]\n    performance = get_performance(click_times, impression_times)\n    print(performance)  # Output: [0.1, 0.1]\n\n    print(\"\\nTest case 2:\")\n    click_times = [5, 7]\n    impression_times = [20, 30]\n    performance = get_performance(click_times, impression_times)\n    print(performance)  # Output: [0.25, 0.2333333333333333]\n\n    print(\"\\nTest case 3:\")\n    click_times = [1, 2]\n    impression_times = [10, 20]\n    performance = get_performance(click_times, impression_times)\n    print(performance)  # Output: [0.1, 0.1]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1323": "```\ndef maximum69Number(num):\n    num_str = str(num)\n    for i in range(len(num_str)):\n        if num_str[i] == '6' and num_str[i-1] != '9':\n            return int(num_str[:i] + '9' + num_str[i+1:])\n    return num\n\ndef main():\n    print(maximum69Number(9669)) # Test case 1\n    print(maximum69Number(9996)) # Test case 2\n    print(maximum69Number(10000)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1324": "```\ndef printVertically(s: str) -> List[str]:\n    words = s.split(\"\\n\")\n    max_len = max(len(word) for word in words)\n    result = []\n    \n    for i in range(max_len):\n        row = \"\"\n        for word in words:\n            if i < len(word):\n                row += word[i] + \" \"\n        result.append(row.strip())\n        \n    return result\n\ndef main():\n    print(printVertically(\"hello\\nworld\"))  # Expected output: [\"h e l\", \"w o r\"]\n    print(printVertically(\"short\\nfish\"))   # Expected output: [\"s h\", \"f i\"]\n    print(printVertically(\"we\\nwill\"))      # Expected output: [\"w i\", \"w l\"]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1325": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef remove Leaves(root: 'TreeNode', val: int) -> 'TreeNode':\n    if root is None:\n        return None\n\n    root.left = removeLeaves(root.left, val)\n    root.right = removeLeaves(root.right, val)\n\n    if root.val == val and root.left is None and root.right is None:\n        return None\n    return root\n\n\ndef main():\n    # Test case 1: A tree with no leaves to delete\n    node5 = TreeNode(5)\n    node6 = TreeNode(6)\n    node3 = TreeNode(3)\n    node2 = TreeNode(2)\n    node4 = TreeNode(4)\n    node6.left = node5\n    node3.left = node2\n    node3.right = node4\n\n    root = node3\n    print(removeLeaves(root, 1))\n\n    # Test case 2: A tree with leaves to delete\n    node8 = TreeNode(8)\n    node9 = TreeNode(9)\n    node10 = TreeNode(10)\n\n    root = node8\n    root.left = node6\n    root.right = node7\n    node6.left = node5\n    node6.right = node7\n    node5.left = node4\n    node5.right = node3\n    node7.left = node9\n    node9.right = node10\n\n    print(removeLeaves(root, 8))\n\n    # Test case 3: A tree with a leaf value to delete at the root\n    node2 = TreeNode(2)\n    node1 = TreeNode(1)\n\n    root = node2\n    root.left = node1\n\n    print(removeLeaves(root, 2))",
  "1326": "```\ndef minTaps(n: int, ranges: List[int]) -> int:\n    ...\n\ndef main():\n    print(minTaps(5, [1,4,9])) # Expected output: 2\n    print(minTaps(8, [1,2,3,4,5,7,7,15])) # Expected output: 3\n    print(minTaps(20, [3,5,6,19])) # Expected output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1328": "```\ndef breakPalindrome(palindrome):\n    if len(palindrome) == 1:\n        return \"\"\n    \n    char_list = list(palindrome)\n    for i in range(len(char_list) // 2):\n        if char_list[i] != 'a':\n            char_list[i] = 'b'\n            return ''.join(char_list)\n            \n    char_list[-1] = 'b'\n    return ''.join(char_list)\n\ndef main():\n    print(breakPalindrome(\"aba\"))  # Expected: \"ba\"\n    print(breakPalindrome(\"abcddcba\"))  # Expected: \"abcbdccba\"\n    print(breakPalindrome(\"a\"))  # Expected: \"\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1327": "```\ndef get_order_products(table, columns, ids):\n    # Your solution here\n    pass\n\nif __name__ == \"__main__\":\n    table = [\n        [\"ProductA\", \"2022-01-01 08:00:00\", \"1\"],\n        [\"ProductB\", \"2022-01-01 09:00:00\", \"2\"],\n        [\"ProductC\", \"2022-01-02 10:00:00\", \"3\"],\n        [\"ProductA\", \"2022-01-03 11:00:00\", \"4\"],\n        [\"ProductB\", \"2022-01-04 12:00:00\", \"5\"]\n    ]\n    columns = [\"OrderDate\"]\n    ids = [1, 2]\n\n    print(get_order_products(table, columns, ids))  # should return ['ProductA', 'ProductB']\n\n    table = [\n        [\"ProductX\", \"2022-01-05 13:00:00\", \"6\"],\n        [\"ProductY\", \"2022-01-06 14:00:00\", \"7\"],\n        [\"ProductZ\", \"2022-01-07 15:00:00\", \"8\"]\n    ]\n    columns = [\"OrderDate\"]\n    ids = [3, 4]\n\n    print(get_order_products(table, columns, ids))  # should return []\n\n    table = [\n        [\"ProductA\", \"2022-01-08 16:00:00\", \"9\"],\n        [\"ProductB\", \"2022-01-09 17:00:00\", \"10\"],\n        [\"ProductC\", \"2022-01-10 18:00:00\", \"11\"]\n    ]\n    columns = [\"OrderDate\"]\n    ids = [5, 6]\n\n    print(get_order_products(table, columns, ids))  # should return ['ProductA', 'ProductB']\n```",
  "1329": "```\ndef diagonalSort(matrix):\n    if not matrix or not matrix[0]:\n        return matrix\n\n    m, n = len(matrix), len(matrix[0])\n    res = [[0] * n for _ in range(m)]\n\n    for k in range(-m + 1, n + 1):\n        temp = sorted((val for i, row in enumerate(matrix) for j, val in enumerate(row) if i - j == k))\n        for i in range(min(k, 0), max(k, m)):\n            res[i][i-k] = temp[i-k+min(0,k)]\n\n    return res\n\ndef main():\n    print(diagonalSort([[3, 3, 1, 2], [1, 4, 1, 2], [10, 3, 5, 6]]))\n    print(diagonalSort([[1, 2, 3], [3, 3, 1], [1, 4, 3]]))\n    print(diagonalSort([]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1330": "```\ndef maxReverse(arr):\n    n = len(arr)\n    left, right = 0, n - 1\n    while left < right:\n        if arr[left] >= arr[right]:\n            left += 1\n        else:\n            arr[left], arr[right] = arr[right], arr[left]\n            right -= 1\n            left += 1\n    return arr\n\ndef main():\n    print(maxReverse([1,2,3,4,5]))\n    print(maxReverse([1,-1,1,-1,1]))\n    print(maxReverse([5,6,7,8]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1332": "```\ndef removePalindromeSub(s: str) -> int:\n    n = len(s)\n    i, j = 0, n - 1\n    while i < j:\n        if s[i] != s[j]:\n            return n\n        i += 1\n        j -= 1\n    return 1\n\ndef main():\n    print(removePalindromeSub(\"aab\")) \n    print(removePalindromeSub(\"baab\")) \n    print(removePalindromeSub(\"abc\"))\n\nmain()\n```",
  "1331": "```\ndef arrayRankTransform(arr):\n    sorted_arr = sorted((val, i) for i, val in enumerate(arr))\n    rank_transformed = [1] * len(arr)\n    \n    last_rank = 1\n    for _, index in sorted_arr:\n        if rank_transformed[index] != last_rank:\n            last_rank += 1\n        rank_transformed[index] = last_rank\n    \n    return rank_transformed\n\ndef main():\n    print(arrayRankTransform([40,10,20,30]))\n    print(arrayRankTransform([100,50,20,10]))\n    print(arrayRankTransform([37,12,30,34,15,45,24,32,35,42,22,38,43,17,48,4,13,46,49,1,36,2,47,40,11]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1333": "```\ndef filterRestaurants(restaurants, veganFriendly, maxPrice, maxDistance):\n    result = []\n    for r in restaurants:\n        if (veganFriendly == r[1] or not veganFriendly) and r[2] <= maxPrice and r[3] <= maxDistance:\n            result.append((r[0], r[2]))\n    return sorted(result, key=lambda x: (-x[1], x[0]))\n\ndef main():\n    restaurants = [[1, True, 1, 10], [2, False, 1, 20], \n                   [3, True, 2, 15], [4, False, 3, 30]]\n    veganFriendly = True\n    maxPrice = 3\n    maxDistance = 20\n    \n    filteredRestaurants = filterRestaurants(restaurants, veganFriendly, maxPrice, maxDistance)\n    \n    print(\"Expected: [[1, 1], [3, 2]]\")\n    for restaurant in filteredRestaurants:\n        print(restaurant)\n\n    restaurants = [[1, True, 1, 10], [2, False, 1, 20], \n                   [3, True, 2, 15]]\n    veganFriendly = False\n    maxPrice = 2\n    maxDistance = 50\n    \n    filteredRestaurants = filterRestaurants(restaurants, veganFriendly, maxPrice, maxDistance)\n    \n    print(\"Expected: [[1, 1], [3, 2]]\")\n    for restaurant in filteredRestaurants:\n        print(restaurant)\n\n    restaurants = [[1, True, 1, 10], [2, False, 1, 20], \n                   [3, True, 2, 15], [4, False, 3, 30], [5, True, 2, 100]]\n    veganFriendly = True\n    maxPrice = 2\n    maxDistance = 50\n    \n    filteredRestaurants = filterRestaurants(restaurants, veganFriendly, maxPrice, maxDistance)\n    \n    print(\"Expected: [[1, 1], [3, 2]]\")\n    for restaurant in filteredRestaurants:\n        print(restaurant)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1334": "```\ndef findSmallestCity(distances):\n    res = {}\n    for city in distances:\n        res[city] = sum(1 for d in distances[city].values() if d <= 3)\n    return min(res, key=res.get)\n\ndef main():\n    test_cases = [\n        {\n            \"distances\": {\n                \"A\": {\"B\": 2, \"C\": 3},\n                \"B\": {\"A\": 2, \"C\": 1, \"D\": 2},\n                \"C\": {\"A\": 3, \"B\": 1, \"D\": 1},\n                \"D\": {\"B\": 2, \"C\": 1}\n            },\n            \"expected_output\": \"B\"\n        },\n        {\n            \"distances\": {\n                \"W\": {\"X\": 5, \"Y\": 10, \"Z\": 7},\n                \"X\": {\"W\": 5, \"Y\": 3, \"Z\": 8},\n                \"Y\": {\"W\": 10, \"X\": 3, \"Z\": 2},\n                \"Z\": {\"W\": 7, \"X\": 8, \"Y\": 2}\n            },\n            \"expected_output\": \"Y\"\n        },\n        {\n            \"distances\": {\n                \"L\": {\"M\": 1, \"N\": 4},\n                \"M\": {\"L\": 1, \"N\": 5},\n                \"N\": {\"L\": 4, \"M\": 5}\n            },\n            \"expected_output\": \"L\"\n        }\n    ]\n\n    for test_case in test_cases:\n        output = findSmallestCity(test_case[\"distances\"])\n        assert output == test_case[\"expected_output\"], f\"Test case failed with input {test_case['distances']}\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1335": "```\ndef mincostTime(tasks, workers):\n    MOD = 10**9 + 7\n    N = len(tasks)\n    dp = [[0] * (len(workers) + 1) for _ in range(N+1)]\n    workers.sort()\n\n    for i in range(1, N+1):\n        total_difficulty = sum(tasks[:i])\n        for j in range(len(workers)+1):\n            if j == 0:\n                dp[i][j] = total_difficulty\n            else:\n                k = (total_difficulty // workers[j-1]) + 1\n                if i >= k:\n                    dp[i][j] = min(dp[i][j], dp[i-k][j-1] + tasks[i-1])\n                else:\n                    dp[i][j] = total_difficulty\n\n    return dp[-1][-1]\n\ndef main():\n    print(mincostTime([2,4,6,8,10], [84,58,48,67,78])) # Output: 12\n    print(mincostTime([15,30,60], [32,7,73,45,51,5]) # Output: 53\n    print(mincostTime([11,14,18], [119,76,17,114]) # Output: 20\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1336": "```\ndef totalTravelingTime(timestamps):\n    timestamps.sort()\n    last_end = timestamps[0]\n    travel_time = 0\n    for i in range(1, len(timestamps)):\n        if timestamps[i] - last_end > 60:\n            travel_time += 3600\n        else:\n            travel_time += (timestamps[i] - last_end) * 1000 + 60 * 60\n        last_end = timestamps[i]\n    return travel_time\n\ndef main():\n    print(\"Test Case 1:\")\n    print(totalTravelingTime([1992,2004])) # Expected output: 7200000\n    \n    print(\"\\nTest Case 2:\")\n    print(totalTravelingTime([1908,1947,1955,1983,1999,2010])) # Expected output: 12423000\n    \n    print(\"\\nTest Case 3:\")\n    print(totalTravelingTime([2004,2011,2014,2016,2017,2022])) # Expected output: 13380000\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1337": "```\ndef kWeakestRows(mat, k):\n    rows = [(i, sum(1 for x in row)) for i, row in enumerate(mat)]\n    rows.sort(key=lambda x: (x[1], x[0]))\n    return [row[0] for row in rows[:k]]\n\ndef main():\n    print(kWeakestRows([[1, 1, 0, 0, 0],\n                        [1, 1, 1, 1, 0],\n                        [1, 0, 1, 0, 0],\n                        [1, 0, 0, 0, 0],\n                        [1, 0, 0, 0, 0]], 3))\n    print(kWeakestRows([[1, 0, 0, 0], \n                        [1, 0, 0, 2], \n                        [1, 1, 1, 10]], 2))\n    print(kWeakestRows([[10, 9, 8, 7], \n                        [5, 5, 5, 5], \n                        [4, 3, 2, 1]], 3))\n\nmain()\n```",
  "1338": "```\ndef medianSort(arr):\n    arr.sort()\n    n = len(arr)\n    return [arr[i] for i in range(n//2)]\n\ndef main():\n    print(medianSort([1,2,3,4])) \n    print(medianSort([1,3])) \n    print(medianSort([1,3,5]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1339": "```\nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        total_sum = self.sum(root)\n        max_product = float('-inf')\n        \n        def dfs(node):\n            if not node:\n                return 0\n            left_sum = dfs(node.left)\n            right_sum = dfs(node.right)\n            if node.val + left_sum + right_sum == total_sum:\n                max_product = max(max_product, node.val * (total_sum - node.val))\n            return node.val + left_sum + right_sum\n        \n        dfs(root)\n        return max_product\n\ndef main():\n    solution = Solution()\n    \n    root1 = TreeNode(1, TreeNode(4), TreeNode(0))\n    print(solution.maxProduct(root1))  # Output: 28\n    \n    root2 = TreeNode(1, TreeNode(0, TreeNode(3)), TreeNode(-5, TreeNode(2)))\n    print(solution.maxProduct(root2))  # Output: 16\n    \n    root3 = TreeNode(0)\n    print(solution.maxProduct(root3))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1340": "```\ndef maxResult(nums, k):\n    n = len(nums)\n    dp = [0] * (n + 1)\n    dp[0] = nums[0]\n    for i in range(1, n):\n        dp[i] = max((dp[j] - nums[i-1]) // (k+1) for j in range(i) if j+k >= i and dp[j] > -k*10000)\n    return dp[-1]\n\ndef main():\n    print(maxResult([10,3,2,5,0,9], 2)) \n    print(maxResult([6,1,4,7,5,3,12], 2))\n    print(maxResult([-1,-2,-3,1,1,1,10,12], 2))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1341": "```\ndef averageRating(ratings):\n    total = sum(ratings)\n    return round(total / len(ratings))\n\ndef main():\n    ratings1 = [5,5,5]\n    print(f\"Average rating for {ratings1} is: {averageRating(ratings1)}\")\n\n    ratings2 = [4,3,5,6,7]\n    print(f\"Average rating for {ratings2} is: {averageRating(ratings2)}\")\n\n    ratings3 = []\n    print(f\"Average rating for {ratings3} is: {averageRating(ratings3)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1342": "```\ndef getSteps(n):\n    steps = 0\n    while n > 0:\n        if (n & 1) == 0:  # n is even\n            n >>= 1\n        else:  # n is odd\n            n -= 1\n        steps += 1\n    return steps\n\ndef main():\n    print(getSteps(14))  # Expected output: 6\n    print(getSteps(8))   # Expected output: 4\n    print(getSteps(2))   # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1344": "```\ndef findAngle(hour, minutes):\n    hour_angle = (hour % 12 + minutes / 60) * 30\n    minute_angle = minutes * 6\n    angle_diff = abs(hour_angle - minute_angle)\n    return min(angle_diff, 360 - angle_diff)\n\ndef main():\n    print(\"Test case 1: \", findAngle(0, 30))\n    print(\"Test case 2: \", findAngle(3, 15))\n    print(\"Test case 3: \", findAngle(6, 45))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1343": "```\ndef numSubarrayAverageSizeK(t, k, threshold):\n    n = len(t)\n    res = 0\n    for i in range(n - k + 1):\n        total = sum(t[i:i+k])\n        avg = total / k\n        if avg >= threshold:\n            res += 1\n    return res\n\ndef main():\n    print(numSubarrayAverageSizeK([2, 3, 4], 1, 0), \"Expected: 2\")\n    print(numSubarrayAverageSizeK([2, 3, 4], 2, 0.5), \"Expected: 3\")\n    print(numSubarrayAverageSizeK([8, 9, 6, 6, 9, 10, 7, 1, 7, 1, 8, 5, 2, 5, 4, 9, 0], 3, 3), \"Expected: 12\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1345": "```\ndef maxResult(nums, k):\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n    \n    pq = [(nums[0], 0)]\n    for i in range(1, n):\n        while pq and pq[0][1] < i - k:\n            pq.pop(0)\n        \n        if pq and abs(i - pq[0][1]) <= k:\n            dp[i] += pq[0][0]\n        \n        heapq.heappush(pq, (-nums[i], i))\n    \n    return dp[-1]\n\ndef main():\n    print(maxResult([10,3,2,5,0,9], 3)) \n    print(maxResult([-5,-3,4,0,9,7,10], 6))\n    print(maxResult([3,19,2,5,4,18,1,17,3,19], 2))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1346": "```\ndef find_pairs(nums):\n    nums.sort()\n    double_dict = {}\n    \n    for num in nums:\n        if num in double_dict:\n            return True\n        else:\n            double_dict[num*2] = num\n            \n    return False\n\n\ndef main():\n    print(find_pairs([1, 3, 4, 2, 5])) # Expected: True\n    print(find_pairs([2, 7, 11, 8, 15])) # Expected: False\n    print(find_pairs([10, 20, 30, 40, 50])) # Expected: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1347": "```\ndef minSteps(s1, s2):\n    count = {}\n    for char in s1:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n    for char in s2:\n        if char in count:\n            count[char] -= 1\n        else:\n            count[char] = count.get(char, 0) - 1\n\n    steps = 0\n    for key in count:\n        if count[key] > 0:\n            steps += count[key]\n\n    return steps\n\n\ndef main():\n    print(minSteps(\"bab\", \"aba\"))  # Expected: 2\n    print(minSteps(\"leetcode\", \"practice\"))  # Expected: 5\n    print(minSteps(\"iloveyou\", \"i\"))  # Expected: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1348": "```\ndef truncateTweet(tweet, maxLen):\n    if len(tweet) <= maxLen:\n        return tweet\n    else:\n        return tweet[:maxLen].rstrip(\"...\")\n\ndef TweetCounts(perfectHashMap):\n    result = []\n    for (freq, count) in sorted(perfectHashMap.items()):\n        while count > 0 and freq < 100:\n            result.append((freq, count))\n            if count >= 10:\n                count -= 10\n            elif count == 9:\n                count -= 1\n            else:\n                break\n\n    return result\n\ndef TweetCountsPerFrequency(tweets):\n    perfectHashMap = {}\n    for tweet in tweets:\n        hashValue = sum(ord(c) for c in tweet.lower())\n        if hashValue not in perfectHashMap:\n            perfectHashMap[hashValue] = 0\n        perfectHashMap[hashValue] += 1\n\n    return TweetCounts(perfectHashMap)\n\ndef main():\n    tweets = [\"bob\", \"foo bar\", \"hello world\"]\n    print(TweetCountsPerFrequency(tweets))\n\n    tweets = [\"a b c\", \"d e f g h i j k l m n o p q r s t u v w x y z\"]\n    print(TweetCountsPerFrequency(tweets))\n\n    tweets = [\"abc def gh\", \"i jkl mn op qr st uv wx yz\", \"abcdefghijklmnopqrstuvwxyz\"]\n    print(TweetCountsPerFrequency(tweets))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1349": "```\ndef maxStudents(seats):\n    n = len(seats)\n    dp = [[0] * 2 for _ in range(n)]\n    dp[0][0 if seats[0] == 1 else 1] = [1, 0]\n    \n    for i in range(1, n):\n        prev_max = dp[i-1][0] + (dp[i-1][1] if not seats[i-1] and not seats[i] else 0)\n        dp[i][0] = max(dp[i-1][0], prev_max)\n        dp[i][1] = dp[i-1][1]\n        \n    return dp[-1][0]\n\ndef main():\n    print(maxStudents([1,0]))\n    print(maxStudents([1,1,0]))\n    print(maxStudents([0,1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1350": "```\ndef invalidDepartments(students):\n    department_set = set()\n    result = []\n    \n    for student in students:\n        if student[2] not in department_set:\n            department_set.add(student[2])\n        else:\n            result.append(student[0])\n\n    return list(set(result))\n\ndef main():\n    test_cases = [\n        [[1, \"John\", \"Math\"], [2, \"Anna\", \"Science\"], [3, \"Bob\", \"English\"], [4, \"Alice\", \"Math\"],],\n        [[1, \"John\", \"Math\"], [2, \"Anna\", \"Science\"], [3, \"Bob\", \"English\"], [4, \"Eve\", \"Math\"], [5, \"Adam\", \"Math\"]],\n        [[1, \"John\", \"Math\"], [2, \"Anna\", \"Math\"], [3, \"Bob\", \"Math\"],],\n    ]\n\n    for test_case in test_cases:\n        print(\"Test Case: \", test_case)\n        print(\"Invalid Departments: \", invalidDepartments(test_case))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1351": "```\ndef countNegatives(grid):\n    m, n = len(grid), len(grid[0])\n    i, j = m-1, 0\n    count = 0\n    while i >= 0 and j < n:\n        if grid[i][j] < 0:\n            count += (n - j)\n            i -= 1\n        else:\n            j += 1\n    return count\n\ndef main():\n    test_cases = [\n        [[4, 3, 2, -1], [3, 2, 1, -1], [1, -1, -1, -1], [-1, -1, -1, -1]],\n        [[1, -1],\n         [-1, -1]], \n        [[0]]\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Test Case: {test_case}\")\n        result = countNegatives(test_case)\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1352": "```\ndef product_of_last_k_numbers(k: int) -> dict:\n    res = {0: 1}\n    last_k_product = 1\n    for i in range(1, k+1):\n        last_k_product *= i\n    return {'product_of_last': last_k_product}\n\ndef main():\n    print(product_of_last_k_numbers(3)) \n    print(product_of_last_k_numbers(4))\n    print(product_of_last_k_numbers(5))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1353": "```\nfrom typing import List\n\ndef maxEvents(events: List[List[int]]) -> int:\n    events.sort(key=lambda x: (x[1], x[0]))\n    end_time = 0\n    count = 0\n    heap = []\n    \n    for start, end in events:\n        if start > end_time:\n            while heap and heap[0][0] <= end_time:\n                _ , end_time = heapq.heappop(heap)\n            count += len(heap)\n        heapq.heappush(heap, (end, start))\n        if end > end_time:\n            end_time = end\n    return count\n\ndef main():\n    print(maxEvents([[1,4],[2,3],[5,7]])) \n    print(maxEvents([[1,2],[2,3],[3,4}})))\n    print(maxEvents([[1,1000000},{2,9999999}]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1354": "```\ndef canIARP(target):\n    if target % sum(1 for _ in range(1, target+1)) != 0:\n        return False\n    heap = []\n    n = len(str(target))\n    i = 1\n    while i <= target:\n        if len(str(i)) > n:\n            break\n        heappush(heap, -i)\n        i += 1\n    res = []\n    for _ in range(n):\n        num = -heappop(heap) + 1\n        res.append(num)\n        target -= num\n        while heap and -heap[0] <= target:\n            heappush(res, -heappop(heap))\n            target -= -heap[0]\n            if target == 0:\n                return res\n    return []\n\ndef main():\n    print(canIARP(9)) \n    print(canIARP(15)) \n    print(canIARP(33))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1355": "```\ndef numParticipants(participant, end):\n    total_participants = set()\n    for i in range(1, end + 1):\n        if participant & (1 << i):\n            total_participants.add(i)\n    return len(total_participants)\n\ndef main():\n    print(numParticipants(8, 3) == 2)\n    print(numParticipants(7, 4) == 0)\n    print(numParticipants(15, 5) == 1)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1356": "```\ndef sortByBits(arr):\n    arr.sort(key=lambda x: bin(x).count('1'))\n    return arr\n\ndef main():\n    print(sortByBits([0,1]))\n    print(sortByBits([16,17,18,19,20]))\n    print(sortByBits([1,13,10,2,100]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1357": "```\ndef subOrder(n):\n    orderCount = 0\n    discountStack = []\n    \n    while True:\n        command = input().split()\n        \n        if command[0] == \"check\":\n            if orderCount >= n:\n                print(f\"Discount for customer {command[1]}\")\n            else:\n                print(\"No discount yet\")\n        elif command[0] == \"buy\":\n            orderCount += 1\n            if len(discountStack) < 2 and (not discountStack or discountStack[-1][0] != command[1]):\n                discountStack.append((command[1], int(command[2])))\n            else:\n                discountStack.pop(0)\n        elif command[0] == \"undo\":\n            if discountStack:\n                discountStack.pop()\n        else:\n            break\n\ndef main():\n    subOrder(3)\n\nif __name__ == \"__main__\":\n    main()\n\ntest_case1 = [\"check\", \"shogun\", 2]\ntest_case2 = [\"buy\", \"shogun\", 1]\ntest_case3 = [\"check\", \"shogun\"]\n```",
  "1358": "```\ndef countSubstrings(s):\n    n = len(s)\n    char_count = {}\n    for i in range(n):\n        if s[i] not in char_count:\n            char_count[s[i]] = 1\n        else:\n            char_count[s[i]] += 1\n\n    total_substrings = 0\n    left, right = 0, n - 1\n    while left < right:\n        if 'a' in char_count and 'b' in char_count and 'c' in char_count:\n            total_substrings += (right - left)\n            for i in range(left + 1, right):\n                if s[i] in ['a', 'b', 'c']:\n                    break\n            left = i\n        else:\n            left += 1\n\n    return total_substrings\n\n\ndef main():\n    print(countSubstrings(\"abc\"))\n    print(countSubstrings(\"aaa\"))\n    print(countSubstrings(\"abca\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1359": "```\ndef countOrders(n):\n    MOD = 10**9 + 7\n    res = [1]\n    for i in range(2 * n):\n        res.append((res[-1] * (i+1)) % MOD)\n    return res[n-1] * res[2*n-1] % MOD\n\ndef main():\n    print(countOrders(4))\n    print(countOrders(5))\n    print(countOrders(6))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1360": "```\nfrom datetime import datetime\n\ndef daysBetweenDates(date1, date2):\n    return abs((datetime.strptime(date1, \"%Y-%m-%d\") - datetime.strptime(date2, \"%Y-%m-%d\")).days)\n\ndef main():\n    print(\"Test case 1:\")\n    print(daysBetweenDates(\"2020-01-01\", \"2020-12-31\"), \"(Expected: 365)\")\n    print()\n\n    print(\"Test case 2:\")\n    print(daysBetweenDates(\"2019-06-15\", \"2020-02-20\"), \"(Expected: 244)\")\n    print()\n\n    print(\"Test case 3:\")\n    print(daysBetweenDates(\"1990-01-01\", \"1991-12-31\"), \"(Expected: 366)\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1361": "```\ndef is_valid_bst(root):\n    def dfs(node, low=float('-inf'), high=float('inf')):\n        if not node:\n            return True\n        if node.val <= low or node.val >= high:\n            return False\n        return (dfs(node.left, low, node.val) and \n                dfs(node.right, node.val, high))\n\n    return dfs(root)\n\ndef main():\n    root1 = TreeNode(2)\n    root1.left = TreeNode(1)\n    root1.right = TreeNode(3)\n    print(is_valid_bst(root1))  # True\n\n    root2 = TreeNode(5)\n    root2.left = TreeNode(4)\n    root2.right = TreeNode(6)\n    print(is_valid_bst(root2))  # False (because 4 > 5)\n\n    root3 = None\n    print(is_valid_bst(root3))  # True\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1362": "```\ndef nth_divisor(n):\n    i = 1\n    while True:\n        if n % i == 0:\n            return i\n        i += 1\n\ndef closest_divisors(n):\n    left, right = nth_divisor(n), n // nth_divisor(n)\n    while right - left > 1 and (right - n) % right != 0 and (n - left) % left != 0:\n        if n - left > right - left:\n            left = nth_divisor(left)\n        else:\n            right = n // nth_divisor(right)\n    return [left, right]\n\ndef main():\n    test_cases = [(5, [1, 5]), (10, [2, 5]), (24, [8, 3])]\n    for n, expected in test_cases:\n        result = closest_divisors(n)\n        if result == expected:\n            print(f\"Test case {n} passed.\")\n        else:\n            print(f\"Test case {n} failed. Expected: {expected}, got: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1363": "```\ndef largestDivisibleByK(nums, k):\n    result = [0] * len(nums)\n    for i in range(len(nums)):\n        temp = [x for x in nums if x % k == 0]\n        if not temp:\n            return -1\n        result[i] = max(temp)\n    total = sum(result)\n    while total % k != 0:\n        max_val = max(result)\n        if max_val % k == 0:\n            result[result.index(max_val)] -= max_val\n            total -= max_val\n        else:\n            for i in range(len(result)):\n                if result[i] % k == 0 and result[i] > max_val // k:\n                    result[i] -= max_val // k\n                    total -= max_val // k\n                    break\n    return total\n\ndef main():\n    print(largestDivisibleByK([9,4,9,6,7],3))\n    print(largestDivisibleByK([2,6,8,4],16))\n    print(largestDivisibleByK([1,2,3,4,5],10))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1364": "```\ndef numTrustedContacts(customers):\n    result = {}\n    for customer in customers:\n        trusted_contacts = set()\n        for contact in customer[1]:\n            if contact not in [c[0] for c in customers]:\n                continue\n            trusted_contacts.add(contact)\n            for other_contact in [c[0] for c in customers]:\n                if other_contact == contact and other_contact != customer[0]:\n                    trusted_contacts.add(other_contact)\n        result[customer[0]] = len(trusted_contacts)\n    return result\n\ndef main():\n    customers = [\n        [\"John\", [\"Ava\", \"Alex\"]],\n        [\"Alice\", [\"Eve\", \"Bob\", \"Mallory\"]],\n        [\"Ava\", [\"John\", \"Eve\",]],\n        [\"Bob\", []],\n        [\"Eve\", [\"Alice\", \"John\", \"Mallory\", \"Bob\"]],\n        [\"Mallory\", [\"Eve\"]]\n    ]\n    \n    print(numTrustedContacts(customers))\n    \n    test1 = [\n        [\"John\", [\"Ava\", \"Alex\"]],\n        [\"Alice\", [\"Eve\", \"Bob\", \"Mallory\"]],\n        [\"Ava\", [\"John\", \"Eve\",]],\n        [\"Bob\", []],\n        [\"Eve\", [\"Alice\", \"John\", \"Mallory\", \"Bob\"]],\n        [\"Mallory\", [\"Eve\"]]\n    ]\n    print(numTrustedContacts(test1))\n    \n    test2 = [\n        [\"A\", [\"B\"]],\n        [\"B\", [\"C\"]],\n        [\"C\", []],\n        [\"D\", []]\n    ]\n    print(numTrustedContacts(test2))\n    \n    test3 = [\n        [\"X\", [\"Y\", \"Z\"]],\n        [\"Y\", [\"X\", \"Z\"]],\n        [\"Z\", [\"X\", \"Y\"]]\n    ]\n    print(numTrustedContacts(test3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1365": "```\ndef countSmallerNumbersThanTarget(nums):\n    sorted_nums = []\n    res = []\n\n    for num in nums:\n        i = binary_search(sorted_nums, num)\n        res.append(i)\n\n        sorted_nums.insert(i, num)\n\n    return res\n\n\ndef binary_search(sorted_nums, target):\n    left, right = 0, len(sorted_nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if sorted_nums[mid] == target:\n            return mid\n        elif sorted_nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\n\ndef main():\n    print(countSmallerNumbersThanTarget([8, 5, 2, 12]))  # Output: [2, 1, 0, 3]\n    print(countSmallerNumbersThanTarget([-10, -7, 4, 15, 20])  # Output: [0, 0, 1, 3, 6]\n    print(countSmallerNumbersThanTarget([2]))  # Output: [0]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1366": "```\ndef rankTeams(votes):\n    team_votes = {}\n    for vote in votes:\n        for team in vote:\n            if team not in team_votes:\n                team_votes[team] = 0\n            team_votes[team] += 1\n\n    team_votes = dict(sorted(team_votes.items(), key=lambda item: (-item[1], item[0])))\n\n    result = []\n    for team, count in team_votes.items():\n        if not result or count > result[-1][1]:\n            result.append([team, count])\n        else:\n            last_team, last_count = result[-1]\n            if count == last_count:\n                result.append([team, count])\n            else:\n                i = len(result) - 1\n                while i >= 0 and count <= result[i][1]:\n                    i -= 1\n                result.insert(i + 1, [team, count])\n\n    return [\"\" for _ in range(len(votes[0]))].join([f\"{team:>{len(result)+1}}\" for team, _ in result] + [\"\"])\n\n\ndef main():\n    votes = [[\"Winston\",\"Lily\",\"Romeo\"],\n             [\"Sienna\",\"Violet\",\"Winston\"],\n             [\"Sienna\",\"Lily\",\"Romeo\"]]\n    print(rankTeams(votes))\n\n    votes = [[\"Sheldon\",\"Barry\",\"Karen\",\"Jim\"],\n             [\"Jane\",\"Sheldon\",\"Karen\",\"Barry\"],\n             [\"James\",\"Jane\",\"Karen\",\"Jim\"]]\n    print(rankTeams(votes))\n\n    votes = [[\"Alice\",\"Bob\",\"Charlie\",\"David\"],\n             [\"Bob\",\"Alice\",\"David\",\"Charlie\"],\n             [\"Charlie\",\"David\",\"Alice\",\"Bob\"]]\n    print(rankTeams(votes))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1367": "```\ndef isSubtree(root: TreeNode, subRoot: TreeNode) -> bool:\n    if not root:\n        return False\n    if isIdentical(root, subRoot):\n        return True\n    return isSubtree(root.left, subRoot) or isSubtree(root.right, subRoot)\n\ndef isIdentical(root1: TreeNode, root2: TreeNode) -> bool:\n    if root1 and root2 and root1.val == root2.val:\n        return isIdentical(root1.left, root2.left) and isIdentical(root1.right, root2.right)\n    return root1 is None and root2 is None\n\nclass Solution:\n    def main(self):\n        test_cases = [\n            {\"root\": [4,3,6,\"null\",\"null\",5],\"subRoot\": [6,\"null\",\"null\"]},\n            {\"root\": [4,3,\"null\",\"null\",\"null,7,8,10,null,null,9\"],\"subRoot\": [6,\"null\",\"null\"]},\n            {\"root\": [1,2,3,\"null\",\"null,4,5,6\",\"null,null,null,4\",\"null,null,null,3,2,4\"],\"subRoot\": [3,\"null,\"null\"]}\n        ]\n\n        for test_case in test_cases:\n            root = TreeNode.fromList(test_case[\"root\"])\n            subRoot = TreeNode.fromList(test_case[\"subRoot\"])\n            print(f\"Test case: {test_case}\\nResult: {isSubtree(root, subRoot)}\\n\")\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n    @classmethod\n    def fromList(cls, values):\n        if not values:\n            return None\n        root = TreeNode(values[0])\n        node_queue = [root]\n        i = 1\n        while i < len(values):\n            current_node = node_queue.pop(0)\n            val = values[i]\n            if val is not None:\n                curr_left_child = TreeNode(val)\n                current_node.left = curr_left_child\n                node_queue.append(curr_left_child)\n            i += 1\n            if i >= len(values) or values[i] is None:\n                continue\n            val = values[i]\n            if val is not None:\n                curr_right_child = TreeNode(val)\n                current_node.right = curr_right_child\n                node_queue.append(curr_right_child)\n            i += 1\n        return root\n\nif __name__ == \"__main__\":\n    Solution().main()\n```",
  "1368": "```\nimport heapq\n\ndef minCost(grid):\n    m, n = len(grid), len(grid[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    pq = [(grid[0][0], 0, 0)]  # cost, row, col\n    visited = set((0, 0))\n    res = float('inf')\n    \n    while pq:\n        cost, r, c = heapq.heappop(pq)\n        \n        if r == m - 1 and c == n - 1:\n            return cost\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            if (0 <= nr < m) and (0 <= nc < n) and (nr, nc) not in visited:\n                new_cost = cost + grid[nr][nc]\n                heapq.heappush(pq, (new_cost, nr, nc))\n                visited.add((nr, nc))\n                \n    return -1\n\ndef main():\n    test_cases = [\n        {\"grid\": [[0, 3, 2], [1, 0, 0]], \"expected_result\": 6},\n        {\"grid\": [[0, 1, 1, 4, 8, 1], [0, 1, 2, 7, 4, 2], [1, 5, 3, 9, 2, 1], [0, 2, 6, 6, 8, 3]], \"expected_result\": 24},\n        {\"grid\": [[1, 10, 3, 11], [0, 13, 0, 15], [5, 7, 4, 12]], \"expected_result\": 21}\n    ]\n    \n    for test_case in test_cases:\n        result = minCost(test_case[\"grid\"])\n        if result == test_case[\"expected_result\"]:\n            print(f\"Test case {test_case} passed\")\n        else:\n            print(f\"Test case {test_case} failed with result {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1369": "```\ndef secondHighest(id):\n    max_id = -1\n    second_max = -1\n    for idd in id:\n        if idd > max_id:\n            second_max, max_id = max_id, idd\n        elif idd < max_id and idd > second_max:\n            second_max = idd\n    return second_max\n\ndef main():\n    print(secondHighest([9,3,8,6,4,7,5,1,2]))  # Expected output: 6\n    print(secondHighest([8,2])  )              # Expected output: -1\n    print(secondHighest([1]))                    # Expected output: -1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1370": "```\ndef count_increasing_decreasing_strings(s):\n    n = len(s)\n    left_right_counts = [0] * (n + 1)\n\n    for i in range(n):\n        if s[i].isalpha():\n            left_count = sum(1 for j in range(i) if s[j].isalpha())\n            right_count = n - i - 1 - sum(1 for j in range(i, n) if s[j].isalpha())\n\n            left_right_counts[i + 1] = max(left_count, right_count)\n\n    return sum(1 for count in left_right_counts[1:] if count == left_right_counts[0])\n\ndef main():\n    test_cases = [\n        {\"s\": \"aaa\", \"expected_output\": 2},\n        {\"s\": \"abcba\", \"expected_output\": 3},\n        {\"s\": \"abcde\", \"expected_output\": 1}\n    ]\n\n    for test_case in test_cases:\n        s = test_case[\"s\"]\n        expected_output = test_case[\"expected_output\"]\n        actual_output = count_increasing_decreasing_strings(s)\n        print(f\"Test case: {s}, Expected output: {expected_output}, Actual output: {actual_output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1371": "```\ndef maxVowels(s: str) -> int:\n    n = len(s)\n    v = [0] * (n + 1)\n    for i in range(n):\n        if s[i].lower() in 'aeiou':\n            v[i+1] = v[i] + 1\n        else:\n            v[i+1] = v[i]\n            \n    max_len, count = 0, 0\n    for i in range(1, n+1):\n        if (v[i] & 1) == 0: \n            max_len = max(max_len, i - count)\n        elif v[i] > count:\n            count = v[i]\n        else:\n            count = 0\n            \n    return max_len\n\ndef main():\n    print(\"Test case 1:\")\n    print(maxVowels(\"eleet\")) # Output: 2\n    \n    print(\"\\nTest case 2:\")\n    print(maxVowels(\"rssqufe\")) # Output: 6\n    \n    print(\"\\nTest case 3:\")\n    print(maxVowels(\"abciiideefsaa\")) # Output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1372": "```\nclass Solution:\n    def longestZigZag(self, root):\n        if not root:\n            return 0\n        \n        self.ans = 0\n        def dfs(node, is_left):\n            if not node:\n                return 0\n            \n            left_len = right_len = 0\n            if is_left:\n                right_len = 1 + dfs(node.right, False)\n                left_len = dfs(node.left, True)\n            else:\n                left_len = 1 + dfs(node.left, True)\n                right_len = dfs(node.right, False)\n            \n            self.ans = max(self.ans, left_len + right_len)\n            return max(left_len, right_len)\n        \n        dfs(root, None)\n        return self.ans\n\n\ndef main():\n    solution = Solution()\n\n    root1 = TreeNode(1)\n    root1.left = TreeNode(3)\n    root1.right = TreeNode(2)\n\n    print(solution.longestZigZag(root1))  # Output: 3\n\n    root2 = TreeNode(1)\n    root2.left = TreeNode(4)\n    root2.right = TreeNode(4)\n    root2.left.left = TreeNode(5)\n\n    print(solution.longestZigZag(root2))  # Output: 3\n\n    root3 = TreeNode(6)\n    root3.left = TreeNode(1)\n    root3.right = TreeNode(7)\n    root3.left.left = TreeNode(4)\n    root3.left.right = TreeNode(9)\n    root3.right.left = TreeNode(10)\n\n    print(solution.longestZigZag(root3))  # Output: 5\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1373": "```\nclass Solution:\n    def maxSumBST(self, root):\n        self.max_sum = 0\n        self.dfs(root, None, None)\n        return self.max_sum\n\n    def dfs(self, node, min_val, max_val):\n        if not node:\n            return float('inf'), float('-inf')\n\n        left_min, left_max = self.dfs(node.left, min_val, node.val)\n        right_min, right_max = self.dfs(node.right, node.val, max_val)\n\n        if (min_val is None or node.val >= min_val) and (max_val is None or node.val <= max_val):\n            self.max_sum = max(self.max_sum, node.val + left_min + right_max)\n            return min(node.val, left_min), max(node.val, right_max)\n        return float('inf'), float('-inf')\n\ndef main():\n    solution = Solution()\n\n    # Test case 1\n    root = [4,3,8,5,6,null,null,9]\n    print(solution.maxSumBST(None) if root[1] is None else solution.maxSumBST({ 'val': root[1], 'left': { 'val': root[2], 'left': { 'val': root[3], 'left': None, 'right': { 'val': root[4], 'left': None, 'right': None } }, 'right': { 'val': root[5], 'left': None, 'right': None } } }))\n\n    # Test case 2\n    root = [1,null,2]\n    print(solution.maxSumBST(None) if root[1] is None else solution.maxSumBST({ 'val': root[1], 'left': None, 'right': { 'val': root[2], 'left': None, 'right': None } }))\n\n    # Test case 3\n    root = [4,2,null,3,3,5,null,-6,null,null,null,null,0,null,9]\n    print(solution.maxSumBST(None) if root[1] is None else solution.maxSumBST({ 'val': root[1], 'left': { 'val': root[2], 'left': None, 'right': { 'val': root[3], 'left': { 'val': root[4], 'left': None, 'right': None }, 'right': { 'val': root[5], 'left': None, 'right': None } } }, 'right': { 'val': root[6], 'left': None, 'right': { 'val': root[7], 'left': None, 'right': None } } }))\n```",
  "1374": "```\ndef generateTheString(n):\n    result = ''\n    for i in range(1, n+1, 2):\n        if (n + i) % 2:\n            result += 'a'\n        else:\n            result += 'b'\n    return result\n\ndef main():\n    print(\"Test case 1: n = 4\")\n    print(generateTheString(4)) # expected output: \"abaab\"\n\n    print(\"\\nTest case 2: n = 7\")\n    print(generateTheString(7)) # expected output: \"abaabbbaa\"\n\n    print(\"\\nTest case 3: n = 10\")\n    print(generateTheString(10)) # expected output: \"abaabbbbabaaaba\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1375": "```\ndef prefixCount(s: str) -> int:\n    count = 0\n    for i in range(len(s)):\n        if s[:i+1].endswith('0' * (len(s) - i - 1)):\n            count += 1\n    return count\n\n\ndef main():\n    print(prefixCount(\"011010\"))  # expected output: 3\n    print(prefixCount(\"10101\"))   # expected output: 2\n    print(prefixCount(\"100000\"))  # expected output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1376": "```\ndef numMessages(waiting, idToName, nameToId):\n    graph = {name: [] for name in idToName}\n    for i, (id1, id2) in enumerate(waiting):\n        graph[idToName[id1]].append(idToName[id2])\n    \n    memo = {}\n    def dfs(name):\n        if name not in memo:\n            memo[name] = len(graph[name]) + sum(dfs(n) for n in graph[name])\n        return memo[name]\n    \n    return max(dfs(name) for name in idToName)\n\ndef main():\n    print(numMessages([[0, 2], [0, 3], [1, 1]], {\"0\": \"Hero\", \"1\": \"Polo\", \"2\": \"Goodbye\", \"3\": \"Bye\"}, {\"Hero\": \"0\", \"Polo\": \"1\", \"Goodbye\": \"2\", \"Bye\": \"3\"}))\n    print(numMessages([[0, 1], [0, 2]], {\"0\": \"Hero\", \"1\": \"bad203\", \"2\": \"srich016\"}, {\"Hero\": \"0\", \"bad203\": \"1\", \"srich016\": \"2\"}))\n    print(numMessages([], {\"0\": \"Hero\", \"1\": \"Polo\", \"2\": \"Goodbye\", \"3\": \"Bye\"}, {\"Hero\": \"0\", \"Polo\": \"1\", \"Goodbye\": \"2\", \"Bye\": \"3\"}))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1377": "```\ndef minTimeToType(word):\n    result = 0\n    for char in word:\n        result += abs(ord(char) - ord('a')) + 1\n    return result\n\ndef main():\n    print(minTimeToType(\"aa\"))  # Output: 2\n    print(minTimeToType(\"abc\"))  # Output: 9\n    print(minTimeToType(\"baz\"))  # Output: 11\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1378": "```\ndef findEmployees(numOfEmployees):\n    employeeIDtoUnique = {}\n    uniqueToEmployee = {}\n\n    for i in range(1, numOfEmployees + 1):\n        if i not in uniqueToEmployee:\n            uniqueId = str(i)\n            while uniqueId in uniqueToEmployee:\n                uniqueId += \"0\"\n            employeeIDtoUnique[i] = uniqueId\n            uniqueToEmployee[uniqueId] = i\n\n    return employeeIDtoUnique\n\n\ndef main():\n    print(findEmployees(5))  # Test Case 1: Should give {'1': '1', '2': '2', '3': '3', '4': '4', '5': '5'}\n    print(findEmployees(6))  # Test Case 2: Should give {'1': '1', '2': '2', '3': '3', '4': '4', '5': '50', '6': '60'}\n    print(findEmployees(10))  # Test Case 3: Should give {'1': '1', '2': '2', '3': '3', '4': '4', '5': '5', '6': '6', '7': '70', '8': '80', '9': '90', '10': '100'}\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1379": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef inorderClone(root: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    \n    dummy = TreeNode(0)\n    curr = dummy\n    \n    stack = []\n    while True:\n        while root:\n            stack.append(root)\n            root = root.left\n        \n        if not stack:\n            break\n        \n        node = stack.pop()\n        curr.right = node\n        curr = curr.right\n        \n        root = node.right\n\ndef findNode(root: TreeNode, copyValuesFromOriginal: TreeNode) -> TreeNode:\n    if not root:\n        return None\n    \n    if root.val == copyValuesFromOriginal.val:\n        return root\n    \n    leftCopy = findNode(root.left, copyValuesFromOriginal)\n    if leftCopy:\n        return leftCopy\n    \n    rightCopy = findNode(root.right, copyValuesFromOriginal)\n    return rightCopy\n\ndef main():\n    # Test case 1\n    originalRoot = TreeNode(7)\n    originalRoot.left = TreeNode(4)\n    originalRoot.right = TreeNode(3)\n    originalRoot.left.left = TreeNode(2)\n    originalRoot.left.right = TreeNode(6)\n    originalRoot.right.left = TreeNode(5)\n    \n    cloneRoot = inorderClone(originalRoot)\n    result = findNode(originalRoot, cloneRoot)\n    print(result.val if result else None)\n\n    # Test case 2\n    originalRoot = TreeNode(1)\n    originalRoot.left = TreeNode(2)\n    originalRoot.right = TreeNode(3)\n    \n    cloneRoot = inorderClone(originalRoot)\n    result = findNode(originalRoot, cloneRoot)\n    print(result.val if result else None)\n\n    # Test case 3\n    originalRoot = TreeNode(1)\n    \n    cloneRoot = inorderClone(originalRoot)\n    result = findNode(originalRoot, cloneRoot)\n    print(result.val if result else None)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1380": "```\ndef luckyNumbers(matrix):\n    n = len(matrix)\n    m = len(matrix[0])\n    res = []\n    for i in range(n):\n        min_col_val = min(matrix[i])\n        j = matrix[i].index(min_col_val)\n        is_lucky = True\n        for k in range(n):\n            if matrix[k][j] > min_col_val:\n                is_lucky = False\n                break\n        if is_lucky:\n            res.append(min_col_val)\n    return res\n\ndef main():\n    print(luckyNumbers([[3,7,8],[9,4,5],[12,5,9]]))\n    print(luckyNumbers([[1,10,3],[0,2,5],[1,3,4]]))\n    print(luckyNumbers([[7,8],[1,6]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1381": "```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k+1, len(self.stack))):\n            self.stack[i] += val\n\n\ndef main():\n    stack = CustomStack(3)\n    print(stack.push(1))  # []\n    print(stack.push(2))  # [1, 2]\n    print(stack.pop())     # 2\n    print(stack.increment(1, 2))\n    print(stack.stack)      # [1, 4]\n\n    stack = CustomStack(3)\n    print(stack.push(5))   # []\n    print(stack.push(6))   # [5, 6]\n    print(stack.pop())     # 6\n    print(stack.increment(2, 0))\n    print(stack.stack)      # [5]\n\n    stack = CustomStack(4)\n    print(stack.push(10))  # []\n    print(stack.push(11))  # [10, 11]\n    print(stack.push(12))  # [10, 11, 12]\n    print(stack.pop())     # 12\n    print(stack.increment(2, 0))\n    print(stack.stack)      # [10, 11]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1382": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef inorder(root):\n    result = []\n    if root is not None:\n        result += inorder(root.left)\n        result.append(root.val)\n        result += inorder(root.right)\n    return result\n\ndef balanceBST(root):\n    if root is None:\n        return []\n\n    nodes = inorder(root)\n\n    sorted_nodes = sorted(nodes)\n    return TreeNode(None, None)\n\ndef main():\n    root1 = TreeNode(4)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(5)\n    root1.left.left = TreeNode(1)\n    root1.left.right = TreeNode(3)\n\n    root2 = TreeNode(2)\n    root2.left = TreeNode(1)\n    root2.right = TreeNode(3)\n\n    root3 = TreeNode(1)\n\n    print(balanceBST(root1))\n    print(balanceBST(root2))\n    print(balanceBST(root3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1383": "```\nimport heapq\n\ndef maxPerformance(n, speed, efficiency, k):\n    total_speed = sum(speed)\n    heap = [(-e, s) for e, s in zip(efficiency, speed)]\n    heapq.heapify(heap)\n\n    for _ in range(k):\n        total_speed += -heap[0][1]\n        total_efficiency = sum((-e for _, e in heap))\n        if total_efficiency > 0:\n            total_speed -= (-heap[0][1] + -heap[-1][1])\n            heapq.heappop(heap)\n        else:\n            break\n\n    return total_speed, total_efficiency\n\n\ndef main():\n    print(maxPerformance(4, [2,10,3,1], [5,6,9,8], 2)) # Expected: (29, 12)\n    print(maxPerformance(6, [70,83,18,69,57], [2,6,94,13,63,61], 2)) # Expected: (981, 66)\n    print(maxPerformance(10, [95,101,8,99,98,102,93,97,100,103], [1,1,3,2,4,5,7,6,9,8], 0)) # Expected: (1062, 60)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1384": "```\ndef totalSalesAmountByYear(sales):\n    year_sales = {}\n    for sale in sales:\n        if sale[1] not in year_sales:\n            year_sales[sale[1]] = int(sale[2])\n        else:\n            year_sales[sale[1]] += int(sale[2])\n\n    return {k: v for k, v in sorted(year_sales.items())}\n\ndef main():\n    sales = [\n        [\"2020-01-01\", \"apple\", \"100\"],\n        [\"2020-01-02\", \"banana\", \"200\"],\n        [\"2019-12-31\", \"orange\", \"50\"],\n        [\"2020-02-01\", \"apple\", \"300\"],\n        [\"2018-12-30\", \"banana\", \"400\"],\n    ]\n\n    print(totalSalesAmountByYear(sales))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1385": "```\ndef findClosestValue(nums1, nums2):\n    nums1.sort()\n    nums2.sort()\n\n    i = j = 0\n    min_diff = float('inf')\n\n    while i < len(nums1) and j < len(nums2):\n        if abs(nums1[i] - nums2[j]) < min_diff:\n            min_diff = abs(nums1[i] - nums2[j])\n        if nums1[i] < nums2[j]:\n            i += 1\n        else:\n            j += 1\n\n    return min_diff\n\n\ndef main():\n    test_case_1 = ([4,5,6], [3,4])\n    print(\"Test Case 1: \", findClosestValue(*test_case_1))\n\n    test_case_2 = ([1,4,20,7], [5,6,32,40])\n    print(\"Test Case 2: \", findClosestValue(*test_case_2))\n\n    test_case_3 = ([5,23,52,58,114], [1,18,45,53,54,62,100,103])\n    print(\"Test Case 3: \", findClosestValue(*test_case_3))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1386": "```\ndef maxHappyCouple(seats):\n    seats.sort()\n    res = 0\n    i = 0\n    while i < len(seats) - 1:\n        if seats[i] + 2 <= seats[i+1]:\n            i += 1\n        else:\n            res += 1\n            i += 2\n    return res\n\ndef main():\n    print(maxHappyCouple([2,5,5])) # Test case 1: Expected output: 2\n    print(maxHappyCouple([1,4,2])) # Test case 2: Expected output: 1\n    print(maxHappyCouple([1,3,6,7,8,10])) # Test case 3: Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1387": "```\ndef getPower(nums):\n    if not nums:\n        return []\n    power_nums = sorted((num, num ** 2) for num in nums)\n    result = []\n    i = j = 0\n    while i < len(power_nums):\n        count = 1\n        while j + 1 < len(power_nums) and power_nums[j + 1][1] == power_nums[j][1]:\n            j += 1\n            count += 1\n        result.append([power_nums[i][0]] * count)\n        i = j + 1\n    return [num for num in result if num]\n\ndef main():\n    print(getPower([3,9,5,4,10])) # [[3,5,9],[10]]\n    print(getPower([2,1,5,15,30,40])) # [[1,2,5],[15,30,40]]\n    print(getPower([])) # []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1388": "```\ndef minEatingTime(pieces, k):\n    pieces.sort()\n    n = len(pieces) // 3\n    res = float('inf')\n    left, right = pieces[k-1], pieces[2*n-1]\n    while left <= right:\n        mid = (left + right) // 2\n        if sum(1 for x in pieces if x <= mid) >= k:\n            res = min(res, mid)\n            right = mid - 1\n        else:\n            left = mid + 1\n    return res\n\ndef main():\n    print(minEatingTime([7,5,3,9,2,12], 4))  # Output: 4\n    print(minEatingTime([3,6,7,10], 4))  # Output: 4\n    print(minEatingTime([1,2,3,4,5,6], 4))  # Output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1389": "```\ndef createTargetArray(nums, target):\n    res = []\n    for num in nums:\n        while len(res) > 0 and res[-1] < num:\n            res.append(res.pop())\n        res.append(num)\n    return [x if i != target else y for i, (x, y) in enumerate(zip(nums, res))]\n\ndef main():\n    print(createTargetArray([0,1], 0))\n    print(createTargetArray([0,1,2], 2))\n    print(createTargetArray([1,0,2,3,4], 0))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1390": "```\ndef sum_of_four_divisors(nums):\n    def count_divisors(num):\n        count = 0\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                if i * i == num:\n                    count += 1\n                else:\n                    count += 2\n        return count\n\n    result = []\n    for num in nums:\n        divisors_count = count_divisors(num)\n        if divisors_count == 4:\n            result.append(num)\n\n    return result\n\n\ndef main():\n    print(\"Test case 1:\")\n    print(sum_of_four_divisors([21, 4]) == [4])\n\n    print(\"\\nTest case 2:\")\n    print(sum_of_four_divisors([20, 1, 1]) == [])\n\n    print(\"\\nTest case 3:\")\n    print(sum_of_four_divisors([377, 913, 902] ) == [377])\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1392": "```\ndef longestHappyPrefix(prefix):\n    n = len(prefix)\n    for i in range(1, n):\n        if prefix[i] != prefix[0]:\n            return prefix[:i]\n    return prefix\n\ndef main():\n    print(longestHappyPrefix(\"abab\"))  # Expected: \"aba\"\n    print(longestHappyPrefix(\"leetcodeeatleetcode\"))  # Expected: \"leet\"\n    print(longestHappyPrefix(\"a\"))  # Expected: \"a\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1391": "```\ndef hasValidPath(grid):\n    if not grid:\n        return False\n\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False]*cols for _ in range(rows)]\n    \n    def dfs(r, c):\n        if r < 0 or r >= rows or c < 0 or c >= cols or visited[r][c]:\n            return False\n        \n        visited[r][c] = True\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            if grid[nr][nc] == 'B':\n                return True\n            elif 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] != 'O' and not visited[nr][nc]:\n                if dfs(nr, nc):\n                    return True\n        \n        return False\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 'A':\n                return dfs(r, c)\n    \n    return True\n\ndef main():\n    test_cases = [\n        {\n            \"grid\": [\"A\",\"A\",\"N\"],[\".\",\"#\",\".\"],\n            \"expected_result\": False\n        },\n        {\n            \"grid\": [\"A\",\"B\",\".\",\"#\"],[\"O\",\"O\",\"1\",\"2\"],\n            \"expected_result\": True\n        },\n        {\n            \"grid\": [\"A\",\"B\",\"B\"],[\".','#','.'],\n            \"expected_result\": False\n        }\n    ]\n\n    for test_case in test_cases:\n        result = hasValidPath(test_case[\"grid\"])\n        if result != test_case[\"expected_result\"]:\n            print(\"Test case failed: \", test_case)\n            return\n\n    print(\"All test cases passed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1393": "```\ndef capitalize_trades(prices):\n    result = []\n    for i in range(1, len(prices)):\n        gain_loss = prices[i] - prices[i-1]\n        if gain_loss > 0:\n            result.append({\"date\": f\"{i}\", \"gain\": gain_loss})\n        elif gain_loss < 0:\n            result.append({\"date\": f\"{i}\", \"loss\": -gain_loss})\n    return result\n\ndef main():\n    test_cases = [\n        {\"prices\": [7,1,5,3,6,4], \"expected_result\": [{'date': '2', 'gain': 4}, {'date': '4', 'gain': 2}]},\n        {\"prices\": [1,2,3,4,5], \"expected_result\": []},\n        {\"prices\": [7,6,5,4,3,2,1], \"expected_result\": [{'date': '0', 'loss': 1}, {'date': '1', 'loss': 1}, {'date': '2', 'loss': 1}, {'date': '3', 'loss': 1}, {'date': '4', 'loss': 1}, {'date': '5', 'loss': 1}]}\n    ]\n\n    for test_case in test_cases:\n        result = capitalize_trades(test_case[\"prices\"])\n        if result == test_case[\"expected_result\"]:\n            print(f\"Test case {test_case['prices']} passed.\")\n        else:\n            print(f\"Test case {test_case['prices']} failed. Expected {test_case['expected_result']}, got {result}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1394": "```\ndef findLucky(arr):\n    count = {}\n    for num in arr:\n        if num not in count:\n            count[num] = 0\n        count[num] += 1\n    \n    lucky_num = None\n    max_count = 0\n    for key, value in count.items():\n        if key == value and value > max_count:\n            lucky_num = key\n            max_count = value\n    \n    return lucky_num\n\ndef main():\n    print(findLucky([2,2,3,4,3]) ) \n    print(findLucky([1,2,2,3,3,3]) )\n    print(findLucky([2,2,2,3,3,3,4,4,4,4]) )\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1395": "```\ndef numTeams(g):\n    n = len(g)\n    res = [0] * n\n    for i in range(n):\n        left, right = 0, 0\n        for j in range(i):\n            if g[j] <= g[i]:\n                left += 1\n            else:\n                break\n        for k in range(i + 1, n):\n            if g[k] <= g[i]:\n                right += 1\n            else:\n                break\n        res[i] = left + right\n    return sum(res)\n\ndef main():\n    print(numTeams([2,5,3,7,5])) # 2\n    print(numTeams([4,4])) # 6\n    print(numTeams([1,1,1])) # 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1396": "```\ndef calculateTime(keyTime: str) -> int:\n    hours = int(keyTime[1])\n    minutes = int((int(keyTime[3:]) / 100).real)\n    return hours * 60 + minutes\n\nclass UndergroundSystem:\n    def __init__(self):\n        self.checkins = {}\n        self.outtimes = {}\n\n    def checkIn(self, rideID: str, startTime: str, startStation: str, endStation: str) -> None:\n        self.checkins[(startStation, endStation)] = (rideID, calculateTime(startTime))\n\n    def checkOut(self, rideID: str, endTime: str, endStation: str) -> None:\n        for key, val in list(self.checkins.items()):\n            if val[0] == rideID:\n                self.outtimes[key] = (calculateTime(endTime),)\n                del self.checkins[key]\n                break\n\n    def getAverageTime(self, startStation: str, endStation: str) -> List[float]:\n        total_time = 0\n        count = 0\n        for key, val in self.outtimes.items():\n            if key == (startStation, endStation):\n                total_time += sum(val)\n                count += len(val)\n        return [(total_time / count) if count > 0 else [float('nan')]]\n\n\ndef main():\n    obj = UndergroundSystem()\n    print(obj.getAverageTime(\"New York Penn Station\", \"Raleigh Durham International Airport\")) # Output: [[11.0]]\n    print(obj.getAverageTime(\"Lagos\", \"Johannesburg\")) # Output: [[2.5, 3.5]]\n    print(obj.getAverageTime(\"Los Angeles\", \"Miami\")) # Output: [[6.0]]",
  "1397": "```\ndef numWays(s1, s2):\n    m, n = len(s1), len(s2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0:\n                dp[i][j] = 1\n            elif j == 0:\n                dp[i][j] = 1\n            elif s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    ans = []\n    i, j = m, n\n    while i > 0 and j > 0:\n        if s1[i - 1] == s2[j - 1]:\n            ans.append(s1[i - 1])\n            i -= 1\n            j -= 1\n        elif dp[i - 1][j] > dp[i][j - 1]:\n            i -= 1\n        else:\n            j -= 1\n\n    return \"\".join(reversed(ans))\n\ndef main():\n    print(numWays(\"aabcc\", \"dbbdc\")) # Output: \"aad\"\n    print(numWays(\"a\", \"aa\")) # Output: \"a\"\n    print(numWays(\"\", \"\")) # Output: \"\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1398": "```\ndef readReviews(reviews):\n    record_set = set()\n    for review in reviews:\n        products = set(review[1].split(','))\n        if 'A' in products and 'B' in products and not 'C' in products:\n            record_set.add((review[0],))\n    return list(record_set)\n\ndef main():\n    reviews = [[\"John\", \"A\"], [\"Jane\", \"A,B\"], [\"Alice\", \"A,C\"], [\"Bob\", \"B,C\"], [\"Eve\", \"A,B\"]]\n    print(readReviews(reviews))\n\nif __name__ == \"__main__\":\n    main()\n\ntest_cases = [\n    {\n        'reviews': [[\"John\", \"A\"], [\"Jane\", \"A,B\"], [\"Alice\", \"A,C\"], [\"Bob\", \"B,C\"], [\"Eve\", \"A,B\"]],\n        'expected_output': [['John'], ['Eve']]\n    },\n    {\n        'reviews': [],\n        'expected_output': []\n    },\n    {\n        'reviews': [[\"John\", \"A\"], [\"Jane\", \"A,B\"], [\"Alice\", \"A,C\"], [\"Bob\", \"B,C\"]],\n        'expected_output': []\n    }\n]\n\nfor test_case in test_cases:\n    reviews = test_case['reviews']\n    expected_output = test_case['expected_output']\n    output = readReviews(reviews)\n    assert output == expected_output, f\"Test case failed for {test_case}\"\n```",
  "1399": "```\ndef countLargestGroup(memberCount):\n    countMap = {}\n    for i in range(1, memberCount + 1):\n        countMap[i] = countMap.get(i, 0) + 1\n    maxLen = 0\n    maxGroup = 0\n    for val, freq in countMap.items():\n        if freq > maxLen:\n            maxLen = freq\n            maxGroup = val\n    return maxLen\n\ndef main():\n    print(countLargestGroup(2)) # Test case 1: Expected output is 2\n    print(countLargestGroup(3)) # Test case 2: Expected output is 1\n    print(countLargestGroup(4)) # Test case 3: Expected output is 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1400": "```\ndef maxPalIndSubseq(s, n):\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    res = \"\"\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n                res += s[i]\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return res.ljust(n, '#')\n\ndef main():\n    print(maxPalIndSubseq(\"aabb\", 4))\n    print(maxPalIndSubseq(\"abcdefg\", 7))\n    print(maxPalIndSubseq(\"abcba\", 5))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1401": "```\ndef isOverlapped(circleX, circleY, radius, recLeft, recBottom):\n    distance = ((circleX - recLeft)**2 + (circleY - recBottom)**2)**0.5\n    if distance <= radius:\n        return True\n    else:\n        return False\n\n\ndef main():\n    print(\"Test Case 1: \")\n    print(isOverlapped(3, 4, 10, 1, 2)) \n    # Should be False\n\n    print(\"\\nTest Case 2: \")\n    print(isOverlapped(0.5, 0.5, 2, 0, 0)) \n    # Should be True\n\n    print(\"\\nTest Case 3: \")\n    print(isOverlapped(10, 10, 8, -1, -1)) \n    # Should be False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1402": "```\ndef maxSatisfied(customers, newCustomers, minutes):\n    n = len(customers)\n    total = sum(customers)\n    satisfied = 0\n    for i in range(minutes):\n        if i < n:\n            satisfied += customers[i]\n        else:\n            satisfied += min(newCustomers, key=lambda x:abs(x-i))\n            newCustomers.remove(min(newCustomers, key=lambda x:abs(x-i)))\n    return total + satisfied\n\n\ndef main():\n    print(maxSatisfied([5, 3, 4], 1, 5))  # Test case 1\n    print(maxSatisfied([10, 2, 8, 1], 0, 5))  # Test case 2\n    print(maxSatisfied([6, 5, 7, 9, 3, 4], 4, 20))  # Test case 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1403": "```\ndef minSubsequence(nums):\n    nums.sort(reverse=True)\n    ans = []\n    for num in nums:\n        if not ans or num >= ans[-1]:\n            ans.append(num)\n        else:\n            break\n    return sum(ans)\n\ndef main():\n    print(minSubsequence([4,3,2,1,3])) # Expected output: 9\n    print(minSubsequence([4,4,4,4])) # Expected output: 8\n    print(minSubsequence([10,12]) ) # Expected output: 12\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1404": "```\ndef reduceNumberInBase7(n):\n    if n == 0:\n        return 0\n    steps = 0\n    while n != 1:\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n -= 1\n        steps += 1\n    return steps\n\ndef main():\n    print(reduceNumberInBase7(8))   # Test case 1\n    print(reduceNumberInBase7(3))   # Test case 2\n    print(reduceNumberInBase7(7))   # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1405": "```\ndef longestDiverseString(a, b, c):\n    total = [x for x in [a,b,c] if x > 0]\n    heap = []\n    for x in total:\n        heappush(heap, -x)\n    res = []\n    while heap and len(res) < 3:\n        val = -heappop(heap)\n        res.append(chr(ord('a') + (val % 26)))\n        if val // 26 > 0:\n            heappush(heap, -(val // 26))\n        if len(res) >= 2 and res[-1] == res[-2]:\n            break\n    while heap:\n        val = -heappop(heap)\n        res.append(chr(ord('a') + (val % 26)))\n        if val // 26 > 0:\n            heappush(heap, -(val // 26))\n    return ''.join(res)\n\ndef main():\n    print(longestDiverseString(1,1,4)) # Expected: \"a\"\n    print(longestDiverseString(7,5,4,2) ) # Expected: \"eaaee\"\n    print(longestDiverseString(7,1)) # Expected: \"aabaaa\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1406": "```\ndef stoneGameIII(stone):\n    n = len(stone)\n    dp = [0] * (n + 1)\n    for i in range(n - 2, -1, -1):\n        v = sum(stone[i:i+3])\n        if i < n - 2:\n            dp[i] = max(dp[i], dp[i+1] + v)\n        else:\n            dp[i] = dp[i] + v\n    return bool(dp[0])\n\ndef main():\n    test_cases = [\n        ([5,1,1,3], True),\n        ([5,2,4,4,5,20], True),\n        ([10, 1000000000, 1000000000], False)\n    ]\n\n    for stone, expected in test_cases:\n        print(f\"Stone Game III: {stone} -> {expected}\")\n        if (output := stoneGameIII(stone)) == expected:\n            print(\"Test case passed\")\n        else:\n            print(f\"Test case failed. Expected {expected}, got {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1407": "```\ndef findTopTravellers(travel_table):\n    # Implement your solution here\n    travel_records = {}\n    for row in travel_table:\n        if row[0] not in travel_records:\n            travel_records[row[0]] = [row[1], 0]\n        else:\n            travel_records[row[0]][1] += int(row[1])\n    return sorted(travel_records.items(), key=lambda x: x[1], reverse=True)\n\ndef main():\n    travel_table1 = [(\"John\", \"100\"), (\"Alice\", \"200\"), (\"Bob\", \"300\"), (\"John\", \"400\")]\n    print(findTopTravellers(travel_table1))\n\n    travel_table2 = [(\"Alice\", \"500\"), (\"Bob\", \"600\"), (\"Alice\", \"700\")]\n    print(findTopTravellers(travel_table2))\n\n    travel_table3 = [(\"John\", \"1000\"), (\"John\", \"2000\"), (\"John\", \"3000\"), (\"Alice\", \"4000\"), (\"Bob\", \"5000\")]\n    print(findTopTravellers(travel_table3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1408": "```\ndef containsNearbyAlmostDuplicate(nums, k, t):\n    if not nums:\n        return False\n    \n    window = {}\n    \n    for i in range(len(nums)):\n        if i > k:\n            window.pop(nums[i-k-1], None)\n        \n        if abs(nums[i] - x) <= t:\n            return True\n        \n        window[nums[i]] = i\n        \n        minKey = min(window.keys()) if window else float('inf')\n        maxKey = max(window.keys()) if window else float('-inf')\n        \n        if abs(nums[i] - minKey) <= t or abs(nums[i] - maxKey) <= t:\n            return True\n    \n    return False\n\ndef main():\n    testCases = [\n        {\"nums\": [8,7,14,1,0], \"k\": 3, \"t\": 3}, \n        {\"nums\": [10, 2], \"k\": 1, \"t\": 1}, \n        {\"nums\": [3,5,1], \"k\": 2, \"t\": 0}\n    ]\n\n    for test in testCases:\n        print(f\"Test case: {test['nums']} with k={test['k']} and t={test['t']}\")\n        result = containsNearbyAlmostDuplicate(test[\"nums\"], test[\"k\"], test[\"t\"])\n        print(result)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1410": "```\ndef parseTidy(s):\n    entity_map = {\"&quot;\": \"\\\"\", \"&apos;\": \"\\'\", \"&amp;\": \"&\", \"&gt;\": \">\", \"&lt;\": \"<\"}\n    tidy_str = \"\"\n    temp = \"\"\n\n    for char in s:\n        if char == \"&\":\n            temp += char\n            continue\n        elif len(temp) > 0 and temp[-1] == \"&\":\n            tidy_str += \"&\" + entity_map.get(temp, temp[-1]) + \" \"\n            temp = \"\"\n        else:\n            tidy_str += char\n\n    return tidy_str.strip()\n\ndef main():\n    print(\"Test case 1: \")\n    print(parseTidy(\"&quot;Hello &apos;world&apos;\"))  # should return \"Hello 'world'\"\n\n    print(\"\\nTest case 2: \")\n    print(parseTidy(\"&gt;&lt; Foo &amp; Bar &gt;&lt;\"))  # should return \"> < Foo & Bar > <\"\n\n    print(\"\\nTest case 3: \")\n    print(parseTidy(\"&lt;a&gt;b&lt;/a&gt;\"))  # should return \"<a>b</a>\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1409": "```\ndef countSmallerThanTarget(nums, target):\n    res = [0] * len(nums)\n    for i in range(len(nums)):\n        res[i] = sum(x < target for x in nums[:i])\n    return res\n\n\ndef getAnswer(mutations, queries):\n    n = max(max(m) for m in mutations)\n    index_map = {i: c for i, c in enumerate(\"abcdefghijklmnopqrstuvwxyz\")}\n    count = [0] * (n + 1)\n    for m in mutations:\n        count[m[1]] += 1\n    answer = []\n    for query in queries:\n        for j in range(query[1]):\n            if query[0] < index_map[j]:\n                answer.append(count[j])\n            else:\n                break\n        if query[0] == 'a':\n            answer.append(sum(count))\n        elif query[0] == 'b':\n            answer.append(len(mutations) - sum(count))\n    return answer\n\n\ndef main():\n    print(getAnswer([[\"A\", 1], [\"B\", 2], [\"C\", 3]], [[\"A\", 3], [\"B\", 1]]))\n    print(getAnswer([[\"A\", 1], [\"B\", 2], [\"C\", 3], [\"D\", 4]], [[\"C\", 3], [\"B\", 5]]))\n    print(getAnswer([[\"A\", 1], [\"B\", 2], [\"A\", 3]], [[\"A\", 1]]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1411": "```\ndef numSteps(n):\n    MOD = 10**9 + 7\n    dp = [0] * (n+1)\n    dp[0] = 2\n    for i in range(1, n+1):\n        if i % 3 == 0:\n            dp[i] = dp[i//3]\n        else:\n            dp[i] = (dp[i-1] + dp[i-1]) % MOD\n    return dp[n]\n\ndef main():\n    print(numSteps(2) == 4)\n    print(numSteps(3) == 6)\n    print(numSteps(10) == 59338)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1412": "```\ndef busiest_servers_at_bus_stops(bus_stops):\n    bus_stop_table = {}\n    for stop in bus_stops:\n        arrival, exit = map(int, stop.split())\n        if arrival not in bus_stop_table:\n            bus_stop_table[arrival] = 0\n        bus_stop_table[arrival] += 1\n    max_count = max(bus_stop_table.values())\n    quiet_students = [stop for stop in bus_stops if bus_stop_table[int(stop.split()[0])] == max_count]\n    return quiet_students\n\ndef main():\n    bus_stops = [\n        \"2023-05-01 02:03,2023-05-01 04:10\",\n        \"2023-05-01 03:00,2023-05-01 06:20\",\n        \"2023-05-01 01:30,2023-05-01 02:45\",\n        \"2023-05-01 02:15,2023-05-01 04:10\"\n    ]\n    \n    print(\"Quiet Students in all exams are:\")\n    print(busiest_servers_at_bus_stops(bus_stops))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1413": "```\ndef minStartValue(arr):\n    total = 0\n    for num in arr:\n        total += num\n        if total <= 0:\n            return total + 1\n    return total\n\ndef main():\n    print(minStartValue([1,4,-3,5])) # expected output: 2\n    print(minStartValue([-3,2,-7,10,5])) # expected output: 9\n    print(minStartValue([-1,1])) # expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1414": "```\ndef findMinFibonacciNumber(k):\n    fibs = [0, 1]\n    while True:\n        num = fibs[-1] + fibs[-2]\n        if num > k:\n            break\n        fibs.append(num)\n    \n    dp = [float('inf')] * (k + 1)\n    dp[0] = 0\n    for i in range(1, len(fibs)):\n        for j in range(fibs[i], k + 1):\n            dp[j] = min(dp[j], dp[j - fibs[i]] + 1)\n\n    return dp[k]\n\ndef main():\n    print(findMinFibonacciNumber(7))   # Output: 2\n    print(findMinFibonacciNumber(10))  # Output: 2\n    print(findMinFibonacciNumber(19))  # Output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1415": "```\ndef getHappyString(n, k):\n    result = []\n    for i in range(1<<n):\n        s = ''\n        for j in range(n):\n            if (i>>j)&1:\n                if not s or s[-1] != '0' + chr(ord('a') + i % 3 - 1):\n                    s += '012'[i % 3]\n                else:\n                    break\n            else:\n                s += 'aaa'[i % 3]\n        if len(s) == n:\n            result.append(s)\n    return ''.join(sorted(result)[k-1])\n\ndef main():\n    print(getHappyString(1, 1)) # \"0\"\n    print(getHappyString(2, 7)) # \"00a\"\n    print(getHappyString(3, 6)) # \"010\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1416": "```\ndef restoreArray(targetArr):\n    n = len(targetArr)\n    for i in range(n - 1):\n        if targetArr[i] + 1 != targetArr[i+1]:\n            return []\n    return [1] + sorted([x for x in set(targetArr) if x > 1]) + [n]\n\ndef main():\n    print(restoreArray([5,13,1,2,3,11,15])) \n    print(restoreArray([7,8,9])) \n    print(restoreArray([100000001]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1417": "```\ndef reformat(s):\n    def calculate_distinct_chars(s):\n        char_count = {}\n        for char in s:\n            if char not in char_count:\n                char_count[char] = 0\n            char_count[char] += 1\n        return max(char_count.values())\n\n    distinct_chars = calculate_distinct_chars(s)\n    max_group_length = (len(s) + distinct_chars - 1) // distinct_chars\n\n    result = \"\"\n    group_index = 0\n    for char in s:\n        if len(result) >= max_group_length:\n            group_index += 1\n            result += \"-\"\n        result += char\n    return result\n\n\ndef main():\n    print(reformat(\"a12b1\"))\n    print(reformat(\"ab1234cd4567e8f9g10\"))\n    print(reformat(\"12345\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1418": "```\ndef displayTable(orders):\n    tables = {}\n    dishes = set()\n    \n    for order in orders:\n        table_id, dish_name = order.split()\n        if int(table_id) not in tables:\n            tables[int(table_id)] = [0] * len(set([d.split()[1] for d in orders]))\n        tables[int(table_id)][set([d.split()[1] for d in orders]).index(dish_name)] += 1\n        dishes.add(dish_name)\n    \n    result = [\" \".join(map(str, ['Table', *sorted(list(dishes))]))]\n    \n    for table in sorted(tables.keys()):\n        row = [str(table)]\n        for dish in sorted(list(dishes)):\n            row.append(str(tables[table][dishes.index(dish)]))\n        result.append(\" \".join(row))\n    \n    return \"\\n\".join(result)\n\n\ndef main():\n    orders1 = [\"John 3\", \"Alice 4\", \"Bob 5\", \"Jhon 2\"]\n    print(displayTable(orders1))\n\n    orders2 = [\"Peter 0\", \"Alice 2\", \"Bob 1\", \"Eva 6\", \"John 7\", \"Jen 8\", \"Jimmy 9\", \"Jane 10\"]\n    print(displayTable(orders2))\n\n    orders3 = [\"Sue 0\", \"Tanya 1\", \"Maria 5\", \"Alex 4\", \"Mark 3\", \"Tom 2\", \"Raymond 6\"]\n    print(displayTable(orders3))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1419": "```\ndef minSteps(s: str) -> int:\n    last_seen = {}\n    result = 0\n    i = 0\n    while i < len(s):\n        if s[i] == 'o':\n            if 'o' in last_seen:\n                result += i - last_seen['o']\n            else:\n                result += i\n            last_seen['o'] = i\n        i += 1\n    return result\n\ndef main():\n    print(minSteps(\"croak\")) # Expected output: 1\n    print(minSteps(\"tooc\")) # Expected output: 2\n    print(minSteps(\"cool\")) # Expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1420": "```\ndef maxEqualFreq(nums, k):\n    n = len(nums)\n    prefix_sum = [0]\n    for num in nums:\n        prefix_sum.append(prefix_sum[-1] + num)\n\n    res = []\n    for i in range(k+1):\n        if i > 0:\n            res.append(prefix_sum[i+k] - prefix_sum[i])\n    return res\n\ndef main():\n    print(maxEqualFreq([1,5,6,13]),\"Expected: [3,7]\")\n    print(maxEqualFreq([8,2,5,14,10], 2),\"Expected: [4,10,14]\")\n    print(maxEqualFreq([1,12,4,9,11,22,21,9,9], 20),\"Expected: [5,12,22,21]\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1421": "```\ndef totalAmount(incomeList):\n    return sum(incomeList)\n\ndef discount(presentValue):\n    return presentValue / 2\n\ndef npvQueries(incomeList, rate):\n    presentValue = totalAmount(incomeList)\n    return discount(presentValue) * (1 - 1 / (1 + rate))\n\ndef main():\n    testCases = [\n        {\"incomeList\": [1000, 2000, 3000], \"rate\": 0.05},\n        {\"incomeList\": [500, 1000, 1500], \"rate\": 0.03},\n        {\"incomeList\": [8000, 9000], \"rate\": 0.06}\n    ]\n\n    for testCase in testCases:\n        npv = npvQueries(testCase[\"incomeList\"], testCase[\"rate\"])\n        print(f\"NPV for income list {testCase['incomeList']} and rate {testCase['rate']} is {npv:.2f}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1422": "```\ndef max_score(s):\n    n = len(s)\n    odd, even = [0], [0]\n    for i in range(n):\n        if s[i] == '1':\n            odd.append(odd[-1]+1)\n            even.append(even[-1])\n        else:\n            odd.append(odd[-1])\n            even.append(even[-1]+1)\n    return max(sum(even[i:]) for i in range(n//2+1))\n\ndef main():\n    print(max_score(\"011101\")) # Output: 5\n    print(max_score(\"00\")) # Output: 0\n    print(max_score(\"11111\")) # Output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1423": "```\ndef maxScore(cardPoints, k):\n    n = len(cardPoints)\n    prefixSum = [0] * (n + k + 1)\n    for i in range(n):\n        prefixSum[i + 1] = prefixSum[i] + cardPoints[i]\n    \n    res = prefixSum[n] - prefixSum[n - k]\n    for i in range(k, n):\n        res = max(res, prefixSum[i] - prefixSum[i - k])\n    return res\n\ndef main():\n    test_cases = [\n        [[1,2,3,4,5,6,1], 3],\n        [[2,9,3,4,38,5,48,8,63], 7],\n        [[1, 15, 5, 5, 10, 20, 1, 4, 5, 200, 3, 6], 6]\n    ]\n\n    for cardPoints, k in test_cases:\n        print(f\"Card points: {cardPoints}, K: {k} -> {maxScore(cardPoints, k)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1424": "```\ndef findDiagonalOrder(nums):\n    if not nums:\n        return []\n\n    m = len(nums)\n    n = max(len(row) for row in nums)\n    diagonal_map = {}\n\n    for i in range(m):\n        for j in range(n):\n            if j >= len(nums[i]):\n                break\n            if i + j not in diagonal_map:\n                diagonal_map[i + j] = []\n            diagonal_map[i + j].append(nums[i][j])\n\n    result = []\n\n    for k, values in diagonal_map.items():\n        if k % 2 == 0:  # even diagonal\n            result += values[::-1]\n        else:  # odd diagonal\n            result += values\n\n    return result\n\ndef main():\n    print(findDiagonalOrder([[1,2,3],[4,5,6],[7,8,9]])) \n    print(findDiagonalOrder([[1,2]]))\n    print(findDiagonalOrder([]))\n\nmain()\n```",
  "1425": "```\ndef maxSumRangeQuery(self, scores: List[int], bounds: List[List[int]]) -> int:\n    pass\n\ndef main():\n    print(maxSumRangeQuery([4,6,5,5,3,3], [[1,1],[1,0]])) # 12\n    print(maxSumRangeQuery([12,17,0,1,2], [[2,4],[0,0]]) # 14\n    print(maxSumRangeQuery([7,7,7,7], [[0,4],[1,3]])) # 16\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1426": "```\ndef countElements(arr):\n    return sum(1 for x in set(arr) if x + 1 in arr)\n\ndef main():\n    print(countElements([1,2,3]) == 2)\n    print(countElements([1,3,4,5]) == 3)\n    print(countElements([1,1])) == 1)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1427": "```\ndef stringShift(s: str, shift: list) -> str:\n    for i in range(len(shift)):\n        if shift[i][0] == 'left':\n            s = s[shift[i][1]:]\n        else:\n            s = s[:len(s)-shift[i][1]]\n    return s\n\ndef main():\n    test_cases = [\n        {\"s\": \"abc\", \"shift\": [[\"3\",\"left\"], [\"1\",\"right\"]], \"expected\": \"cab\"},\n        {\"s\": \"aaa\", \"shift\": [[\"0\",\"left\"], [\"2\",\"right\"]], \"expected\": \"aa\"},\n        {\"s\": \"aaaa\", \"shift\": [[\"8\",\"left\"], [\"7\",\"right\"]], \"expected\": \"aa\"}\n    ]\n\n    for test_case in test_cases:\n        s = test_case[\"s\"]\n        shift = test_case[\"shift\"]\n        expected = test_case[\"expected\"]\n\n        actual = stringShift(s, shift)\n\n        if actual == expected:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}. Expected '{expected}', but got '{actual}'.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1428": "```\ndef leftmost_column_with_at_least_one(binary_matrix):\n    m, n = len(binary_matrix), len(binary_matrix[0])\n    for i in range(m):\n        column = binary_matrix[i]\n        leftmost_index = next((j for j in range(n) if column[j]), None)\n        if all(column[j] == 0 for j in range(leftmost_index + 1, n)):\n            return leftmost_index\n    return -1\n\ndef main():\n    test_cases = [\n        {\n            'input': [[0, 1], [1, 1]],\n            'expected_output': 0\n        },\n        {\n            'input': [[0, 0, 1], [1, 0, 1]], \n            'expected_output': 2\n        },\n        {\n            'input': [[0, 0, 0, 1], [1, 0, 0, 1], [1, 1, 1, 1]],\n            'expected_output': 3\n        }\n    ]\n\n    for test_case in test_cases:\n        input_matrix = test_case['input']\n        expected_output = test_case['expected_output']\n\n        output = leftmost_column_with_at_least_one(input_matrix)\n        if output == expected_output:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1429": "```\ndef firstUniqChar(s):\n    char_freq = {}\n    for char in s:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    for char in s:\n        if char_freq[char] == 1:\n            return ord(char)\n    return -1\n\ndef main():\n    print(firstUniqChar(\"leetcode\")) \n    print(firstUniqChar(\"love\"))  \n    print(firstUniqChar(\"aa9567bc\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1430": "```\ndef isPathExist(root, s):\n    if not root:\n        return False\n    stack = [(root, str(root.val))]\n    while stack:\n        node, path = stack.pop()\n        if node.val == int(s[0]):\n            s = s[1:]\n            if not s:\n                return True\n        for child in (node.left, node.right):\n            if child:\n                stack.append((child, path + str(child.val) + '/'))\n    return False\n\ndef main():\n    class TreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.left = None\n            self.right = None\n\n    root1 = TreeNode(1)\n    root1.left = TreeNode(0);\n    root1.right = TreeNode(1);\n    root1.left.left = TreeNode(0);\n    root1.left.right = TreeNode(1);\n\n    print(isPathExist(root1, \"001\"))  # True\n    print(isPathExist(root1, \"011\"))  # False\n    print(isPathExist(None, \"0123456789ABCDEF\"))  # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1431": "```\ndef kidsWithCandies(candies, extraCandies):\n    max_candies = max(candies)\n    return [[candy + extraCandies[i] >= max_candies for candy in candies] for i in range(len(candies))]\n\ndef main():\n    test_cases = [\n        ([2,3,5,1,3], 2),  # Expected output: [[true,false,false,false,true]]\n        ([2,1,12], 10),   # Expected output: [[false,false,true]]\n        ([7,2,5,9,4,7,6,6,8], 5),  # Expected output: [[true,false,false,false,false,false,false,false,true]]\n    ]\n\n    for test_case in test_cases:\n        candies, extra_candies = test_case\n        print(\"Candies:\", candies)\n        print(\"Extra Candies:\", extra_candies)\n        result = kidsWithCandies(candies, extra_candies)\n        print(\"Result:\", result)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1432": "```\ndef maximum69Number(num):\n    num = str(num)\n    res = list(num)\n    count = 0\n    for i in range(len(res)):\n        if res[i] == '6' and count < 1:\n            res[i] = '9'\n            count += 1\n    return int(''.join(map(str, res)))\n\ndef main():\n    print(maximum69Number(9669)) # Test case 1: Expected output 9969\n    print(maximum69Number(9996)) # Test case 2: Expected output 9999\n    print(maximum69Number(10000)) # Test case 3: Expected output 10000\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1433": "```\ndef canBreak(s1: str, s2: str) -> bool:\n    for char in s1:\n        if char not in s2 and char not in s1[s1.index(char)+1:]:\n            return False\n    return True\n\ndef main():\n    print(canBreak(\"abc\", \"defg\"))  # Test case 1\n    print(canBreak(\"xyxzzy\", \"x\"))   # Test case 2\n    print(canBreak(\"abcdefg\", \"badc\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1434": "```\ndef totalWays(n):\n    MOD = int(1e9 + 7)\n    dp = [0] * (1 << n)\n    dp[0] = 1\n    for i in range(n):\n        for mask in range((1 << n) - 1, -1, -1):\n            dp[mask | (1 << i)] += dp[mask]\n            dp[mask] = 0\n            if mask & (1 << i):\n                dp[mask] = dp[mask] + dp[mask ^ (1 << i)]\n    return sum(dp)\n\ndef main():\n    print(totalWays(3)) # Output: 12\n    print(totalWays(4)) # Output: 40\n    print(totalWays(5)) # Output: 168\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1435": "```\ndef createSessionBarChart(session_time):\n    # Your code to create session bar chart goes here\n    pass\n\ndef main():\n    test_cases = [\n        {\"session_time\": [[100, \"08:00\"], [110, \"08:15\"], [130, \"09:05\"], [140, \"09:10\"]], \n         \"expected_output\": [2, 1]},\n        \n        {\"session_time\": [[120, \"07:30\"], [125, \"08:00\"], [135, \"08:25\"], [145, \"09:15\"]], \n         \"expected_output\": [0, 2]},\n        \n        {\"session_time\": [[60, \"06:30\"], [75, \"07:10\"], [90, \"08:05\"], [100, \"09:00\"]], \n         \"expected_output\": [1, 1]}\n    ]\n\n    for test_case in test_cases:\n        session_time = test_case[\"session_time\"]\n        expected_output = test_case[\"expected_output\"]\n\n        output = createSessionBarChart(session_time)\n\n        if output == expected_output:\n            print(\"Test case passed\")\n        else:\n            print(\"Test case failed\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1436": "```\ndef findDestination(cityArr):\n    destination = None\n    for city in cityArr:\n        if len(city) > 1:\n            start, end = city.split()\n            if not destination or destination != end:\n                destination = end\n    return destination\n\n\ndef main():\n    print(findDestination([[\"London\", \"New York\"], [\"New York\", \"Lima\"], [\"Lima\", \"Sao Paulo\"]]))  # Test case 1\n    print(findDestination([[\"B\", \"C\"], [\"A\", \"B\"]]))  # Test case 2\n    print(findDestination([[\"Sydney\", \"Melbourne\"], [\"Melbourne\", \"New York\"], [\"New York\", \"Peking\"]]))  # Test case 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1437": "```\ndef kLengthApart(nums, K):\n    prev = -K\n    for i in range(len(nums)):\n        if nums[i] == 1:\n            return i > prev + K\n        prev = i\n    return True\n\ndef main():\n    print(kLengthApart([0,1], 2)) # Expected: True\n    print(kLengthApart([1,0,0,1], 2)) # Expected: False\n    print(kLengthApart([1,1,1,1], 3)) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1438": "```\ndef maxAbsSum(nums, limit):\n    n = len(nums)\n    max_sum = float('-inf')\n    left, right = 0, 0\n    total = 0\n    while right < n:\n        total += nums[right]\n        while total > limit and left <= right:\n            total -= nums[left]\n            left += 1\n        max_sum = max(max_sum, total)\n        right += 1\n    return max_sum\n\n\ndef main():\n    test_cases = [\n        ([1, 2, 3, 4], 2),  # Output: 6\n        ([-1, -2, 1, 2, 3], 10),  # Output: 9\n        ([-6,-3,1,3,8,10,12,18,20], 15)  # Output: 24\n    ]\n    \n    for nums, limit in test_cases:\n        print(f\"nums: {nums}, limit: {limit}, maxAbsSum: {maxAbsSum(nums, limit)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1439": "```\nimport heapq\n\ndef kthSmallest(matrix, k):\n    heap = []\n    heapq.heappush(heap, (matrix[0][0], 0, 0))\n    visited = set((0, 0))\n    result = []\n\n    while len(result) < k:\n        val, r, c = heapq.heappop(heap)\n        result.append(val)\n\n        if r + 1 < len(matrix):\n            heapq.heappush(heap, (matrix[r+1][c] + val, r+1, c))\n            visited.add((r+1, c))\n\n        if c + 1 < len(matrix[0]):\n            if (r, c+1) not in visited:\n                heapq.heappush(heap, (matrix[r][c+1] + val, r, c+1))\n                visited.add((r, c+1))\n\n    return result[-1]\n\ndef main():\n    # Test case 1\n    matrix = [[1,5,9],[10,11,13],[12,13,17]]\n    k = 8\n    print(kthSmallest(matrix, k))  # Expected output: 9\n\n    # Test case 2\n    matrix = [[-5]], [1, 3]\n    k = 3\n    print(kthSmallest(matrix, k))   # Expected output: -4\n\n    # Test case 3\n    matrix = [[1, 1], [1, 1]]\n    k = 2\n    print(kthSmallest(matrix, k))   # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1440": "```\ndef calculate(expression):\n    return eval(\"lambda:\" + expression)\n\ndef main():\n    print(calculate(\"!(a||b&&c)\") == False)\n    print(calculate(\"(a||b)&&c\") == True)\n    print(calculate(\"(a&&b)||(c&&!d)\") == True)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1441": "```\ndef buildArray pushed:\n    stack = []\n\n    for p in pushed:\n        if p == \"Push\":\n            stack.append(pushed.pop(0))\n        elif p == \"Pop\" and stack:\n            stack.pop()\n        elif p == \"Append\":\n            stack.append(pushed.pop(0))\n\n    return stack\n\ndef main():\n    print(buildArray([\"1\", \"3\", \"5\", \"4\", \"2\"])[::-1]) \n    print(buildArray([\"1\",\"3\",\"5\",\"10\",\"15\"])[::-1])\n    print(buildArray([\"1\",\"3\",\"5\",\"-20\",\"10\"])[::-1])\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1442": "```\ndef countTriplets(arr):\n    n = len(arr)\n    xorsum = [0] * (n + 1)\n    for i in range(n):\n        xorsum[i+1] = xorsum[i] ^ arr[i]\n    ans = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            left_xor = xorsum[j] - xorsum[i]\n            right_xor = left_xor ^ arr[i]\n            right_xor_sum = 0\n            for k in range(i-1, -1, -1):\n                right_xor_sum ^= arr[k]\n                if right_xor_sum == right_xor:\n                    ans += n - j\n                    break\n    return ans\n\ndef main():\n    print(countTriplets([2,3,5,6,17])) # Expected output: 8\n    print(countTriplets([0,0,0])) # Expected output: 10\n    print(countTriplets([2,3,5,5,7,13,14,15])) # Expected output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1443": "```\ndef minTime(intervals):\n    intervals.sort(key=lambda x: x[0])\n    res = 0\n    prev_end = -1\n    for s, e in intervals:\n        if s > prev_end:\n            res += s - prev_end\n        res += e - s\n        prev_end = e\n    return res\n\ndef main():\n    print(minTime([[1,2],[3,5],[4,6]])) \n    print(minTime([[1,4],[7,10]]))\n    print(minTime([[0,9]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1444": "```\ndef waysToCutPizza(pieces):\n    n = len(pieces)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        dp[i][i] = 1\n        for j in range(i - 1, 0, -1):\n            if pieces[j - 1] <= pieces[i - 1]:\n                dp[j][i] = dp[j][j - 1] + (dp[j - 1][i - 1] if i > j else 1)\n            else:\n                dp[j][i] = dp[j][j - 1]\n    return dp[1][n]\n\ndef main():\n    print(waysToCutPizza([3,1,4])) # Output: 8\n    print(waysToCutPizza([2,3])) # Output: 4\n    print(waysToCutPizza([5,5])) # Output: 7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1446": "```\ndef lengthOfLongestSubstring(s: str) -> int:\n    n = len(s)\n    if n == 0:\n        return 0\n    start = 0\n    end = 0\n    max_length = 0\n    char_index_map = {}\n    \n    while end < n:\n        right_char = s[end]\n        if right_char in char_index_map:\n            start = max(start, char_index_map[right_char] + 1)\n        char_index_map[right_char] = end\n        max_length = max(max_length, end - start + 1)\n        end += 1\n    \n    return max_length\n\n\ndef main():\n    print(lengthOfLongestSubstring(\"abcabcbb\") == 3)  # True\n    print(lengthOfLongestSubstring(\"bbbbbb\") == 7)   # True\n    print(lengthOfLongestSubstring(\"c\")) == 1)       # True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1445": "```\ndef countApplesAndOranges(minX, maxX, apple1, apple2):\n    count = 0\n    for i in range(apple1[0], apple1[1] + 1):\n        if minX <= i <= maxX:\n            count += 1\n    for i in range(apple2[0], apple2[1] + 1):\n        if minX <= i <= maxX:\n            count += 1\n    return count\n\ndef main():\n    test_cases = [\n        {\"minX\": 5, \"maxX\": 15, \"apple1\": [2, 3], \"apple2\": [11, 15]},\n        {\"minX\": 2, \"maxX\": 11, \"apple1\": [1, 7], \"apple2\": [4, 10]},\n        {\"minX\": 7, \"maxX\": 11, \"apple1\": [8, 9], \"apple2\": [9, 11]}\n    ]\n\n    for test_case in test_cases:\n        print(f\"Test Case: minX = {test_case['minX']}, maxX = {test_case['maxX']}\")\n        apple_count = countApplesAndOranges(test_case[\"minX\"], test_case[\"maxX\"], test_case[\"apple1\"], test_case[\"apple2\"])\n        print(f\"Apple Count: {apple_count}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1447": "```\ndef improper_fractions(n):\n    result = []\n    for numerator in range(1, n+1):\n        for denominator in range(numerator, n+1):\n            g = math.gcd(numerator, denominator)\n            if g == 1:\n                result.append(f\"{numerator}/{denominator}\")\n    return result\n\ndef main():\n    print(improper_fractions(2))  # Test case 1\n    print(improper_fractions(3))  # Test case 2\n    print(improved_fractions(4))   # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1448": "```\ndef goodNodes(root):\n    def dfs(node, max_val):\n        if not node:\n            return 0\n        res = 1 if node.val >= max_val else 0\n        res += dfs(node.left, max_val)\n        res += dfs(node.right, max_val)\n        return res\n\ndef main():\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    root1 = TreeNode(3)\n    root1.left = TreeNode(1)\n    root1.right = TreeNode(4);\n    root1.left.left = TreeNode(3);\n    root1.left.right = TreeNode(0);\n    root1.right.left = TreeNode(1);\n\n    print(goodNodes(root1))  # Expected output: 4\n\n    root2 = TreeNode(3)\n    root2.left = TreeNode(1);\n    root2.right = TreeNode(4);\n\n    print(goodNodes(root2))  # Expected output: 3\n\n    root3 = TreeNode(5)\n\n    print(goodNodes(root3))  # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1449": "```\ndef maximum_69_number(num):\n    num += 699 if '6' in str(num) else 9\n    return int(str(num))\n\ndef main():\n    print(maximum_69_number(966)) # Expected output: 1000\n    print(maximum_69_number(828)) # Expected output: 882\n    print(maximum_69_number(594)) # Expected output: 699\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1451": "```\ndef reorderWords(s: str) -> str:\n    words = s.split()\n    odd_words = [word for i, word in enumerate(words) if i % 2 != 0]\n    even_words = [word for i, word in enumerate(words) if i % 2 == 0]\n    return ' '.join(even_words + odd_words)\n\ndef main():\n    print(reorderWords(\"fun boo\")) # Expected: \"boo fun\"\n    print(reorderWords(\"time to see if it am works\")) # Expected: \"it am works to see time\"\n    print(reorderWords(\"lets reverse it\")) # Expected: \"its reverse lets\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1450": "```\ndef highFive(self, startTime: List[int], endTime: List[int]) -> int:\n    student_homes = {}\n    \n    for i in range(len(startTime)):\n        start_time = startTime[i]\n        end_time = endTime[i]\n        \n        for j in range(i + 1, len(endTime)):\n            next_start_time = startTime[j]\n            next_end_time = endTime[j]\n            \n            if start_time == next_start_time and end_time > next_start_time:\n                if student_homes.get(next_start_time) is None:\n                    student_homes[next_start_time] = []\n                student_homes.get(next_start_time).append(j)\n    \n    result = 0\n    for time, students in student_homes.items():\n        if len(students) > 0:\n            max_score = sum(endTime[i] - startTime[i] + 1 for i in students) // len(students)\n            result += len([s for s in students if endTime[s] - startTime[s] + 1 == max_score])\n    \n    return result\n\ndef main():\n    print(highFive([2,3,4,1,3], [5,4,7,8])) # Should return 5\n    print(highFive([1,2,3,4,5], [1,4,7,8,9])) # Should return 6\n    print(highFive([1,1,1,1,1], [1,2,3,4,5])) # Should return 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1452": "```\ndef peopleWithOutCompany(favoriteCompanies):\n    companySets = {}\n    for person in favoriteCompanies:\n        for company in person:\n            if company not in companySets:\n                companySets[company] = set([person])\n            else:\n                companySets[company].add(person)\n    \n    result = []\n    for company, people in companySets.items():\n        if len(people) == 1:\n            result.extend(list(people))\n    return list(set(result))\n\ndef main():\n    favoriteCompanies = [[\"leetcode\", \"google\", \"facebook\"], \n                          [\"google\", \"microsoft\", \"leetcode\"], \n                          [\"linkedin\", \"google\", \"facebook\"]]\n\n    print(\"Expected: ['linkedin']\")\n    print(peopleWithOutCompany(favoriteCompanies))\n    \n    favoriteCompanies = [[\"google\"], [\"facebook\"], [\"google\", \"facebook\"]]\n    print(\"Expected: ['linkedin']\")\n    print(peopleWithOutCompany(favoriteCompanies))\n\n    favoriteCompanies = [[\"leetcode\", \"google\"], \n                          [\"google\", \"facebook\"], \n                          [\"facebook\", \"linkedin\"]]\n    print(\"Expected: ['linkedin']\")\n    print(peopleWithOutCompany(favoriteCompanies))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1453": "```\ndef numPoints(grid):\n    res = 0\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] == 1:\n                res += dfs(i, j, grid)\n    return res\n\ndef dfs(x, y, grid):\n    res = 1\n    dx = [0, 0, -1, 1]\n    dy = [-1, 1, 0, 0]\n    for k in range(4):\n        nx, ny = x + dx[k], y + dy[k]\n        if (0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and \n            grid[nx][ny] == 1):\n            res += dfs(nx, ny, grid)\n    return res\n\ndef main():\n    grid1 = [[1,1,1],[1,0,1],[1,1,1]]\n    print(numPoints(grid1)) # 11\n\n    grid2 = [[0,0,0],[0,1,0],[0,0,0]]\n    print(numPoints(grid2)) # 1\n\n    grid3 = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,1,1,1,1]]\n    print(numPoints(grid3)) # 15\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1454": "```\ndef findActiveUsers(users):\n    active_users = []\n    for user in users:\n        if user[2]:\n            active_users.append(user)\n    return len(active_users)\n\ndef main():\n    print(\"Test case 1:\")\n    users = [[\"A\", \"B\", 0], [\"C\", \"D\", 1], [\"E\", \"F\", 1]]\n    print(findActiveUsers(users))  # Output: 2\n\n    print(\"\\nTest case 2:\")\n    users = [[\"A\", \"B\", 1], [\"C\", \"D\", 0]]\n    print(findActiveUsers(users))  # Output: 1\n\n    print(\"\\nTest case 3:\")\n    users = []\n    print(findActiveUsers(users))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1455": "```\ndef isPrefixOfWord(sentence, searchWord):\n    words = sentence.split()\n    for word in words:\n        if len(word) >= len(searchWord) and word.startswith(searchWord):\n            return True\n    return False\n\ndef main():\n    print(isPrefixOfWord(\"i love coffee love\", \"love\"))  # True\n    print(isPrefixOfWord(\"this is an example sentence\", \"an\"))  # True\n    print(isPrefixOfWord(\"foo bar baz\", \"baa\"))  # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1456": "```\ndef maxVowels(s: str, k: int) -> int:\n    vowels = set('aeiou')\n    n = len(s)\n    res = 0\n    for i in range(n - k + 1):\n        count = sum(1 for c in s[i:i+k] if c in vowels)\n        res = max(res, count)\n    return res\n\ndef main():\n    print(maxVowels(\"abciiideefs\", 2)) \n    print(maxVowels(\"aeeiiiioooo\", 5))\n    print(maxVowels(\"abcdefghijklmnopqrstuvwxyz\", 1))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1457": "```\ndef main():\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(1)\n    root.left.right = TreeNode(1)\n    root.right.left = TreeNode(1)\n    root.right.right = TreeNode(2)\n\n    print(pseudoPalindromicPaths(root))  # Expected output: [1,2,1]\n\n    root = TreeNode(3)\n    root.left = TreeNode(1)\n    root.right = TreeNode(4)\n    root.left.left = TreeNode(2)\n    root.left.right = TreeNode(1)\n    root.right.left = TreeNode(1)\n\n    print(pseudoPalindromicPaths(root))  # Expected output: []\n\n    root = TreeNode(2)\n    root.left = TreeNode(1)\n    root.right = TreeNode(3)\n\n    print(pseudoPalindromicPaths(root))  # Expected output: [2,1]\n\ndef pseudoPalindromicPaths(root):\n    def dfs(node, path):\n        if not node:\n            return []\n        new_path = list(path)\n        new_path.append(str(node.val))\n        left_res = dfs(node.left, new_path)\n        right_res = dfs(node.right, new_path)\n        res = []\n        for p in left_res:\n            res.append(p)\n        for p in right_res:\n            res.append(p)\n        if not node.left and not node.right:\n            return [new_path]\n        return res\n    result = []\n    def helper(node):\n        nonlocal result\n        if not node:\n            return\n        dfs(node, [])\n        helper(node.left)\n        helper(node.right)\n    helper(root)\n    return [path for path in result if is_palindrome(path)]\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\nmain()\n```",
  "1458": "```\ndef dotProduct(nums1, nums2):\n    n = len(nums1)\n    m = len(nums2)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if nums1[i - 1] > nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j]\n            elif nums1[i - 1] < nums2[j - 1]:\n                dp[i][j] = dp[i][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return sum(nums1) * sum(nums2) - 2 * dp[n][m]\n\n\ndef main():\n    print(dotProduct([1,5,-10,4,3,13,3,-1], [4,3,-1]))\n    print(dotProduct([-1,-1,1,1], [-1,1,1,-1]))\n    print(dotProduct([2,0], [0,5]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1459": "```\ndef totalArea(rectangles):\n    x1, y1, x2, y2 = map(int, input().split())\n    return (x2 - x1) * (y2 - y1)\n\ndef main():\n    print(totalArea([1, 4, 3, 2])) # Test case 1\n    print(totalArea([0, 10000000, 0, 10000000])) # Test case 2\n    print(totalArea([-10, 10, -5, 5])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1460": "```\ndef canBeEqual(target: List[int], arr: List[int]) -> bool:\n    from collections import Counter\n    t = Counter(target)\n    a = Counter(arr)\n    return t == a\n\ndef main():\n    print(canBeEqual([1,2,3,4], [1, 3, 2, 4])) \n    print(canBeEqual([7,1,6], [3,6,3,3]))\n    print(canBeEqual([3,8,5,2], [2,8,5,3]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1461": "```\ndef hasAllCodes(s: str, k: int) -> bool:\n    seen = set()\n    for i in range(len(s) - k + 1):\n        code = s[i:i+k]\n        if len(code) != k:\n            return False\n        seen.add(code)\n    return len(seen) == (2 ** k)\n\ndef main():\n    print(hasAllCodes(\"00110100\", 2)) # True\n    print(hasAllCodes(\"011011\", 2)) # False\n    print(hasAllCodes(\"0110\", 3)) # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1462": "```\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: (x[1], -x[0]))\n    time = 0\n    end_times = []\n    \n    for course in courses:\n        if not end_times or course[1] > end_times[0]:\n            time += course[1]\n            heapq.heappop(end_times)\n            heapq.heappush(end_times, course[1])\n        elif course[1] < end_times[0]:\n            time -= end_times[0]\n            heapq.heappop(end_times)\n            heapq.heappush(end_times, course[1])\n\n    return time\n\nimport heapq\nimport unittest\n\nclass TestScheduleCourse(unittest.TestCase):\n\n    def test_schedule_course(self):\n        self.assertEqual(scheduleCourse([[100, 200], [120, 50]]), 250)\n\n    def test_schedule_course2(self):\n        self.assertEqual(scheduleCourse([[1, 2], [3, 7], [4, 12]]), 8)\n\n    def test_schedule_course3(self):\n        self.assertEqual(scheduleCourse([[1, 5], [2, 3]]), 5)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n```",
  "1463": "```\ndef mctFromEditsOnContent_w_2dp(codes):\n    n = len(codes)\n    dp = [[float('inf')] * (n+1) for _ in range(n)]\n    dp[0][0] = 0\n    res = 0\n    \n    for i in range(1, n):\n        for j in range(i+1):\n            if codes[i][j] == '1':\n                dp[i][j] = min(dp[i-1][k] + (i-k) * (i-k) for k in range(j+1))\n                for k in range(j+1):\n                    res = max(res, dp[i][j] + codes[k][i-1]*codes[k][i-1])\n            else:\n                if i > 0 and j < n-1: \n                    dp[i][j] = min(dp[i-1][k] for k in range(j+1)) \n    return res\n\ndef main():\n    test_cases = [\n        [[\"1\",\"0\",\"1\"],[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"]],  # Example 1\n        [[\"0\",\"1\"],[\"1\",\"0\"]],  # Example 2\n        [[\"1\",\"0\",\"1\",\"1\"],[\"1\",\"0\",\"1\",\"1\"],[\"0\",\"1\",\"1\",\"1\"]],  # Example 3\n    ]\n\n    for test_case in test_cases:\n        print(\"Test Case: \", test_case)\n        result = mctFromEditsOnContent_w_2dp(test_case)\n        print(\"Result: \", result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1464": "```\ndef maxProduct(nums):\n    nums.sort()\n    return max(nums[-1] * nums[-2], nums[0] * nums[1])\n\ndef main():\n    print(maxProduct([5,6,0,3,4])) # Output: 12\n    print(maxProduct([-3,0,4]) ) # Output: 12\n    print(maxProduct([3,7,-8,10])) # Output: 56\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1465": "```\ndef maxArea(height):\n    max_area = 0\n    left = 0\n    right = len(height) - 1\n    \n    while left < right:\n        h = min(height[left], height[right])\n        w = right - left\n        max_area = max(max_area, h * w)\n        \n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n            \n    return max_area\n\ndef main():\n    print(\"Test Case 1:\")\n    print(maxArea([1,8,0,2,4,8])) # Expected output: 49\n    \n    print(\"\\nTest Case 2:\")\n    print(maxArea([3,7,3,9,2,3,6,6,4,8])) # Expected output: 84\n    \n    print(\"\\nTest Case 3:\")\n    print(maxArea([1,2,3,4,5,6,7,8,9])) # Expected output: 36\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1466": "```\nfrom collections import deque\n\ndef minReorder(n, roads):\n    graph = [[] for _ in range(n)]\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    reorder = 0\n\n    for i in range(1, n):\n        if not dfs(i, -1, visited, graph):\n            reorder += 1\n\n    return reorder\n\n\ndef dfs(node, parent, visited, graph):\n    visited[node] = True\n\n    for neighbor in graph[node]:\n        if neighbor == parent:\n            continue\n        if not visited[neighbor]:\n            if not dfs(neighbor, node, visited, graph):\n                return False\n    return True\n\n\ndef main():\n    n1 = 4\n    roads1 = [[0,2],[0,3],[1,2]]\n    print(minReorder(n1, roads1))  # Output: 3\n\n    n2 = 7\n    roads2 = [[0,1],[1,2],[2,3],[2,4},{5,6}]\n    print(minReorder(n2, roads2))  # Output: 1\n\n    n3 = 8\n    roads3 = [[0,1],[1,2],[2,7],[3,7],[3,4],[4,5],[5,6],[6,7]]\n    print(minReorder(n3, roads3))  # Output: 4\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1467": "```\ndef numEquivDominoArrays(dominoes):\n    from itertools import chain, combinations\n    def subsets(s):\n        return list(chain(*map(lambda x: combinations(s, x), range(0, len(s) + 1))))\n\n    domino_set = set(tuple(sorted(map(int, d))) for d in dominoes)\n    result = 0\n\n    for r in range(len(domino_set), -1, -1):\n        if any(len(set(tuple(sorted(map(int, d)))) for d in l) == r for l in subsets(list(domino_set))):\n            return sum((r ** k) * math.comb(len(dominoes), k) / (2 ** len(dominoes)) for k in range(r + 1))\n\n    return result\n\n\ndef main():\n    print(numEquivDominoArrays([[1,1],[2,1],[1,1],[1,2],[1,1],[1,3]]))\n    print(numEquivDominoArrays([[2,1],[5,2],[3,4]]))\n    print(numEquivDominoArrays([]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1468": "```\ndef calculateSalaries(salaries):\n    salaries.sort()\n    median = salaries[len(salaries) // 2] if len(salaries) % 2 != 0 else (salaries[len(salaries) // 2 - 1] + salaries[len(salaries) // 2]) / 2\n    return [salary * 12 for salary in salaries], median\n\ndef main():\n    test_cases = [\n        [[100, 200, 300], (1200, 2400)],\n        [[400, 500, 600], (4800, 600.0)],\n        [[1, 2, 3], (12, 2.0)]\n    ]\n\n    for salaries, expected in test_cases:\n        result = calculateSalaries(salaries)\n        print(f\"Salaries: {salaries}, Expected: {expected}, Result: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1469": "```\nclass Solution:\n    def getLonelyNodes(self, root):\n        if not root:\n            return []\n\n        result = []\n        self.dfs(root, None, True, result)\n\n        return result\n\n    def dfs(self, node, parent, is_left, result):\n        if not node:\n            return\n\n        if (parent and not is_left) or (not parent and is_left):\n            result.append(node.val)\n\n        self.dfs(node.left, node, False, result)\n        self.dfs(node.right, node, True, result)\n\n\ndef main():\n    solution = Solution()\n    \n    # Test case 1\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.left.left = TreeNode(4)\n    print(solution.getLonelyNodes(root1))  # Output: [1, 3]\n\n    # Test case 2\n    root2 = TreeNode(2)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(1)\n    print(solution.getLonelyNodes(root2))  # Output: [2]\n\n    # Test case 3\n    root3 = TreeNode(0)\n    print(solution.getLonelyNodes(root3))  # Output: []\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1470": "```\ndef shuffle(nums):\n    n = len(nums)\n    result = [0] * n\n    for i in range(n):\n        result[i*2], result[i*2+1] = nums[i], nums[n-i-1]\n    return result\n\ndef main():\n    print(\"Test case 1:\")\n    test_nums1 = [2,5,3,8,4,6,7,9]\n    print(shuffle(test_nums1))\n    \n    print(\"\\nTest case 2:\")\n    test_nums2 = [1,2,3,4,5,6]\n    print(shuffle(test_nums2))\n    \n    print(\"\\nTest case 3:\")\n    test_nums3 = [1]\n    print(shuffle(test_nums3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1471": "```\ndef kStrongest(arr, k):\n    arr.sort(key=lambda x: (x[1], -x[0]))\n    return [i[0] for i in arr[:k]]\n\ndef main():\n    print(kStrongest([[4,3],[2,6},{9,8}],[3]))\n    print(kStrongest([[1,100],[7,2],[5,3}],[2]))\n    print(kStrongest([[]], 1))\n\nmain()\n```",
  "1472": "```\nclass BrowserHistory:\n\n    def __init__(self):\n        self.stack = []\n\n    def visit(self, url: str) -> None:\n        while len(self.stack) > 1:\n            self.stack.pop()\n        self.stack.append(url)\n\n    def back(self, steps: int) -> str:\n        while steps > 0 and len(self.stack) > 1:\n            self.stack.pop()\n            steps -= 1\n        return self.stack[-1]\n\n    def forward(self) -> str:\n        if len(self.stack) < 2:\n            return self.stack[-1]\n        self.stack.append(self.stack.pop())\n        return self.stack[-1]\n\n\ndef main():\n    history = BrowserHistory()\n    \n    # Test case 1: visit a few URLs\n    history.visit(\"leetcode.com\")\n    history.visit(\"google.com\")\n    history.visit(\"facebook.com\")\n    print(history.back(1))  # should be \"google.com\"\n    print(history.forward())  # should be \"facebook.com\"\n    print(history.visit(\"youtube.com\"))  # should be \"youtube.com\"\n\n    \n    # Test case 2: back and forward\n    history = BrowserHistory()\n    history.visit(\"leetcode.com\")\n    history.visit(\"google.com\")\n    print(history.back(1))  # should be \"leetcode.com\"\n    print(history.forward())  # should be \"google.com\"\n    print(history.back(1))  # should be \"leetcode.com\"\n\n    \n    # Test case 3: back to the start\n    history = BrowserHistory()\n    history.visit(\"leetcode.com\")\n    print(history.back(1))  # should be \"leetcode.com\"\n    while len(history.stack) > 0:\n        history.forward()  \n    print(history.stack[0])  # should be \"\"\n\n\nif __name__ == \"__main__\":\n    main()\n\n```",
  "1473": "```\ndef minCostToPaintHouseIII(costs):\n    n = len(costs)\n    dp = [[0] * (n + 1) for _ in range(n)]\n\n    for i in range(1, n):\n        dp[i][0] = max(dp[i - 1][1], dp[i - 1][2]) + costs[i][0]\n        dp[i][1] = max(dp[i - 1][0], dp[i - 1][2]) + costs[i][1]\n        dp[i][2] = max(dp[i - 1][0], dp[i - 1][1]) + costs[i][2]\n\n    return min(dp[n - 1])\n\ndef main():\n    print(minCostToPaintHouseIII([[17,2,5],[16,16,5],[4,6,7]])) \n    print(minCostToPaintHouseIII([[3,12,10,14,13,16,15]]))\n    print(minCostToPaintHouseIII([[1,3,5,2,9,8,9,8,11]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1474": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef deleteNodes(head: ListNode, m: int, n: int) -> ListNode:\n    dummy = ListNode(0)\n    dummy.next = head\n    curr = dummy\n    \n    while curr.next:\n        for _ in range(m - 1):\n            if not curr.next:\n                return dummy.next\n            curr = curr.next\n        \n        temp = curr.next\n        for _ in range(n):\n            if not temp:\n                return dummy.next\n            temp = temp.next\n        \n        curr.next = temp\n        curr = temp\n    \n    return dummy.next\n\ndef printList(head: ListNode) -> None:\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\ndef main():\n    # Test Case 1\n    node1 = ListNode(1)\n    node2 = ListNode(2)\n    node3 = ListNode(3)\n    node4 = ListNode(4)\n    node5 = ListNode(5)\n    node6 = ListNode(6)\n    \n    node1.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    node5.next = node6\n    \n    print(\"Original List:\")\n    printList(node1)\n    \n    head = deleteNodes(node1, 2, 1)\n    print(\"After deletion:\")\n    printList(head)\n\n    # Test Case 2\n    node7 = ListNode(0)\n    node8 = ListNode(1)\n    node9 = ListNode(2)\n    \n    node7.next = node8\n    node8.next = node9\n    \n    print(\"\\nOriginal List:\")\n    printList(node7)\n    \n    head = deleteNodes(node7, 1, 1)\n    print(\"After deletion:\")\n    printList(head)\n\n    # Test Case 3\n    node10 = ListNode(5)\n    node11 = ListNode(6)\n    node12 = ListNode(7)\n    node13 = ListNode(8)\n    \n    node10.next = node11\n    node11.next = node12\n    node12.next = node13\n    \n    print(\"\\nOriginal List:\")\n    printList(node10)\n    \n    head = deleteNodes(node10, 2, 1)\n    print(\"After deletion:\")\n    printList(head)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1475": "```\ndef finalPrices(prices):\n    stack = []\n    result = [0] * len(prices)\n    for i in range(len(prices) - 1, -1, -1):\n        while stack and stack[-1] <= prices[i]:\n            stack.pop()\n        if stack:\n            result[i] = prices[stack[-1]] - prices[i]\n        stack.append(i)\n    return result\n\ndef main():\n    print(finalPrices([8,10,6,9,5,4,7,9,2,1])) \n    print(finalPrices([10,26,30,35,1,3,54,103,3,24]))\n    print(finalPrices([100]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1476": "```\ndef numSubmatrixSumTarget(matrix, target):\n    m, n = len(matrix), len(matrix[0])\n    res = []\n    for left in range(n):\n        temp = [0] * m\n        for right in range(left, n):\n            for i in range(m):\n                temp[i] += matrix[i][right]\n            count, l, r = 0, 0, n - 1\n            while l <= r:\n                mid = (l + r) // 2\n                if sum(temp[j] for j in range(mid+1)) > target:\n                    r = mid - 1\n                elif sum(temp[j] for j in range(mid+1)) < target:\n                    l = mid + 1\n                else:\n                    count += (mid+1)\n                    l, r = l, mid - 1\n            res.append(count)\n    return [sum(res) for _ in range(3)]\n\ndef main():\n    matrix = [[10,3,2,-4,-1,5],\n              [-7,6,1,8,2,-6],\n              [-6,-2,0,8,-9,6]]\n    target = 15\n    print(numSubmatrixSumTarget(matrix, target))\n\n    matrix = [[-1,-1,-1,-1,-1,-3],\n              [-1,-4,-2,-3,-10,-5],\n              [-1,10,20,30,40,50]]\n    target = -8\n    print(numSubmatrixSumTarget(matrix, target))\n\n    matrix = [[0,22,27,26,21,25],\n              [0,18,23,22,19,22],\n              [5,16,21,17,15,19],\n              [6,14,18,17,15,18]]\n    target = 10\n    print(numSubmatrixSumTarget(matrix, target))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1477": "```\ndef findTwoSubarrays(nums1, nums2, totalSum):\n    def two_subarrays(nums, target_sum):\n        n = len(nums)\n        left, right = 0, n - 1\n        sum_left, sum_right = 0, 0\n        while left <= right:\n            if sum_left + nums[left] < target_sum:\n                sum_left += nums[left]\n                left += 1\n            elif sum_right + nums[right] < target_sum:\n                sum_right += nums[right]\n                right -= 1\n            else:\n                return [left, right]\n\n        return [-1, -1]\n\n    res = []\n    for i in range(len(nums1) - 1):\n        subarray1 = two_subarrays(nums1[:i+1], totalSum // 2)\n        if subarray1 != [-1, -1]:\n            subarray2 = two_subarrays(nums2, totalSum - totalSum // 2 * 2)\n            if subarray2 != [-1, -1]:\n                res.append([subarray1[0] + i + 1, subarray1[1] + i + 1, subarray2[0], subarray2[1]])\n\n    return res\n\n\ndef main():\n    nums1 = [8, 3, 6, 10]\n    nums2 = [2, 4, 5, 9]\n    totalSum = 12\n    print(findTwoSubarrays(nums1, nums2, totalSum))\n\n    nums1 = [8, 3, 6, 10, 7, 3]\n    nums2 = [2, 4, 5, 9, 3, 10]\n    totalSum = 15\n    print(findTwoSubarrays(nums1, nums2, totalSum))\n\n    nums1 = [10, 8, 6, 10, 7, 3]\n    nums2 = [2, 4, 5, 9, 3, 10]\n    totalSum = 16\n    print(findTwoSubarrays(nums1, nums2, totalSum))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1478": "```\ndef mailboxes(n, arr):\n    if n <= 0:\n        return []\n\n    arr.sort()\n    res = [1]\n    prev = arr[0]\n\n    for i in range(1, len(arr)):\n        if arr[i] - prev >= 2:\n            res.append(i + 1)\n            prev = arr[i]\n\n    return res\n\n\ndef main():\n    print(mailboxes(11, [8,3,2,4,3,7,2,10]))\n    print(mailboxes(5, [2,6,3,4,9]))\n    print(mailboxes(3, [1,2,3]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1480": "```\ndef runningSum(nums):\n    result = [0]\n    total = 0\n    for num in nums:\n        total += num\n        result.append(total)\n    return result\n\ndef main():\n    print(runningSum([1,2,3,4])) \n    print(runningSum([-1,1,1]))\n    print(runningSum([100,200,300]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1479": "```\ndef totalSalesByDay(sales):\n    from collections import defaultdict\n    result = {\"Monday\": 0, \"Tuesday\": 0, \"Wednesday\": 0, \"Thursday\": 0, \"Friday\": 0, \"Saturday\": 0, \"Sunday\": 0}\n    for sale in sales:\n        result[sale[1]] += int(sale[2])\n    return result\n\ndef main():\n    sales = [[\"2023-01-02\", \"Monday\", \"10\"], \n             [\"2023-03-16\", \"Wednesday\", \"20\"], \n             [\"2023-07-28\", \"Friday\", \"30\"]]\n    print(totalSalesByDay(sales))\n\n    sales = [[\"2019-06-09\", \"Sunday\", \"25\"], \n             [\"2020-01-05\", \"Saturday\", \"15\"], \n             [\"2021-02-14\", \"Tuesday\", \"10\"], \n             [\"2022-03-13\", \"Friday\", \"20\"]]\n    print(totalSalesByDay(sales))\n\n    sales = [[\"2024-04-01\", \"Monday\", \"5\"], \n             [\"2024-04-05\", \"Saturday\", \"7\"], \n             [\"2024-04-08\", \"Tuesday\", \"3\"], \n             [\"2024-04-12\", \"Friday\", \"9\"]]\n    print(totalSalesByDay(sales))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1481": "```\ndef findLeastNumOfUniqueIntegers(nums, k):\n    count = {}\n    for num in nums:\n        if num not in count:\n            count[num] = 1\n        else:\n            count[num] += 1\n    result = []\n    for key, value in sorted(count.items()):\n        if value > 0 and k >= value:\n            k -= value\n            result.append(value)\n        elif value > 0:\n            result.append(value - (k % value))\n            k //= value\n\n    return len(result)\n\ndef main():\n    print(findLeastNumOfUniqueIntegers([5,7,3,9,4,9,8,3,1], 3)) # Expected output: 3\n    print(findLeastNumOfUniqueIntegers([4,3,1,1,3,3,2], 3)) # Expected output: 2\n    print(findLeastNumOfUniqueIntegers([5,5,4], 1)) # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1482": "```\ndef minDays(blooms[i], k):\n    n = len(blooms)\n    prefix_sum = [0]\n    for b in blooms:\n        prefix_sum.append(prefix_sum[-1] + b)\n\n    def check(days):\n        last = -1\n        count = 0\n        for i, ps in enumerate(prefix_sum):\n            while ps - (i - last) * (days % (i - last)) > k:\n                days -= (i - last)\n            if i - last > 0:\n                count += 1\n            last = i\n        return count >= m\n\n    left, right = 1, n\n    while left < right:\n        mid = (left + right) // 2\n        if check(mid):\n            right = mid\n        else:\n            left = mid + 1\n    return left\n\n\ndef main():\n    print(minDays([1,4,3], 5)) # Output: 3\n    print(minDays([1,11,1,1,2,8,1,1,1], 15) )# Output: 9\n    print(minDays([2,4,10,2,5,2], 15) )# Output: 14\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1483": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n        self.parent = None\n\ndef getKthParent(root, node, k):\n    if not root:\n        return None\n\n    queue = [(root, 0)]\n    while queue:\n        node, depth = queue.pop(0)\n        if node == node:\n            return root if k == depth else getKthParent(node.parent, node.parent, k - depth)\n\n    return None\n\ndef main():\n    # Test Case 1\n    root1 = TreeNode(3)\n    a = TreeNode(1)\n    b = TreeNode(2)\n    c = TreeNode(5)\n    d = TreeNode(4)\n    e = TreeNode(6)\n    f = TreeNode(7)\n\n    root1.left = a\n    a.parent = root1\n    root1.right = b\n    b.parent = root1\n    a.right = c\n    c.parent = a\n    b.right = d\n    d.parent = b\n    c.right = e\n    e.parent = c\n    d.right = f\n    f.parent = d\n\n    k1 = 2\n    result1 = getKthParent(root1, root1.left, k1)\n    if result1:\n        print(f\"Kth ancestor of {root1.left.val} is {result1.val}\")\n    else:\n        print(\"No such ancestor exists\")\n\n    # Test Case 2\n    root2 = TreeNode(4)\n    a = TreeNode(3)\n    b = TreeNode(2)\n    c = TreeNode(1)\n\n    root2.left = a\n    a.parent = root2\n    root2.right = b\n    b.parent = root2\n    b.right = c\n    c.parent = b\n\n    k2 = 3\n    result2 = getKthParent(root2, c, k2)\n    if result2:\n        print(f\"Kth ancestor of {c.val} is {result2.val}\")\n    else:\n        print(\"No such ancestor exists\")\n\n    # Test Case 3\n    root3 = TreeNode(5)\n\n    a = TreeNode(4)\n    b = TreeNode(3)\n    c = TreeNode(2)\n    d = TreeNode(1)\n\n    root3.left = a\n    a.parent = root3\n    a.right = b\n    b.parent = a\n    b.right = c\n    c.parent = b\n    c.right = d\n    d.parent = c\n\n    k3 = 5\n    result3 = getKthParent(root3, d, k3)\n    if result3:\n        print(f\"Kth ancestor of {d.val} is {result3.val}\")\n    else:\n        print(\"No such ancestor exists\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1484": "```\ndef get_sold_products_by_date(transactions):\n    products_sold_by_date = {}\n    for transaction in transactions:\n        if transaction[1] not in products_sold_by_date:\n            products_sold_by_date[transaction[1]] = {}\n        if transaction[0] not in products_sold_by_date[transaction[1]]:\n            products_sold_by_date[transaction[1]][transaction[0]] = 0\n        products_sold_by_date[transaction[1]][transaction[0]] += int(transaction[2])\n    return products_sold_by_date\n\ndef main():\n    transactions = [[\"2021-06-01\", \"itemA\", 5], [\"2021-05-31\", \"itemB\", 3], \n                     [\"2021-06-02\", \"itemA\", 7], [\"2021-05-30\", \"itemC\", 4]]\n    print(get_sold_products_by_date(transactions))\n\nif __name__ == \"__main__\":\n    main()\n\ntest_cases = [\n    ([[\"2015-01-01\", \"apple\", 3]], {\"2015-01\": {\"apple\": 3}}),\n    ([[\"2020-02-05\", \"banana\", 2], [\"2020-03-01\", \"orange\", 1], \n      [\"2020-04-08\", \"banana\", 4]], {\"2020-02-05\": {\"banana\": 2}, \"2020-03-01\": {\"orange\": 1, \"banana\": 0}, \"2020-04-08\": {\"banana\": 4}}),\n    ([[\"2019-07-12\", \"peach\", 5], [\"2019-06-15\", \"cherry\", 2], \n      [\"2018-08-19\", \"strawberry\", 1], [\"2020-03-21\", \"blueberry\", 3]], {\"2019-06-15\": {\"cherry\": 2}, \"2019-07-12\": {\"peach\": 5, \"blueberry\": 0}, \n      \"2018-08-19\": {\"strawberry\": 1}, \"2020-03-21\": {\"blueberry\": 3}})\n]\n\nfor test_case in test_cases:\n    transactions = test_case[0]\n    expected_result = test_case[1]\n    result = get_sold_products_by_date(transactions)\n    if result == expected_result:\n        print(\"Test Case Passed\")\n    else:\n        print(\"Test Case Failed. Expected\", expected_result, \"but got\", result)\n```",
  "1485": "```\nclass Node:\n    def __init__(self, val, left=None, right=None, random=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.random = random\n\ndef copyRandomList(head):\n    if not head:\n        return None\n\n    cur = head\n    old_to_new = {}\n    new_head = Node(cur.val)\n    old_to_new[head] = new_head\n\n    while cur:\n        new_node = old_to_new.get(cur, None)\n        new_right = old_to_new.get(cur.right) if cur.right else None\n        new_left = old_to_new.get(cur.left) if cur.left else None\n        new_random = old_to_new.get(cur.random) if cur.random else None\n\n        if not new_node:\n            new_node = Node(cur.val)\n            old_to_new[cur] = new_node\n\n        if cur.right:\n            new_node.right = copyRandomList(cur.right)[1]\n        if cur.left:\n            new_node.left = copy_random_list(cur.left)[1]\n        if cur.random:\n            new_node.random = copy_random_list(cur.random)[1]\n\n        cur = cur.next\n\n    return new_head, old_to_new[head]\n\n\ndef main():\n    # Test Case 1\n    node4 = Node(4)\n    node3 = Node(3, node4, None, node4)\n    node2 = Node(2, node3, node4, node2)\n    node1 = Node(1, node2, node3)\n\n    new_head1, _ = copyRandomList(node1)\n\n    # Test Case 2\n    node6 = Node(6)\n    node5 = Node(5, node6, None, node6)\n    node4_ = Node(4, node5, node6, node4_)\n    node3_ = Node(3, node4_, node5, node3_)\n    node2_ = Node(2, node3_, node4_, node2_)\n    node1_ = Node(1, node2_, node3_, node1_)\n\n    new_head2, _ = copyRandomList(node1_)\n\n    # Test Case 3\n    node8 = Node(8)\n    node7 = Node(7, node8, None, node8)\n    node6_ = Node(6, node7, node8, node6_)\n    node5_ = Node(5, node6_, node7, node5_)\n    node4__ = Node(4, node5_, node6_, node4__)\n    node3__ = Node(3, node4__, node5_, node3__)\n    node2__ = Node(2, node3__, node4__, node2__)\n    node1__ = Node(1, node2__, node3__, node1__)\n\n    new_head3, _ = copyRandomList(node1__)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1486": "```\ndef singleNumber(nums):\n    result = 0\n    for num in nums:\n        result ^= num\n    return result\n\n\ndef main():\n    print(singleNumber([2,2,1]) == 3)\n    print(singleNumber([4,2,7,1,3]) == 2)\n    print(singleNumber([9,1,7,3,5,2,1,3,7]) == 9)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1487": "```\ndef lengthOfLIS(nums):\n    if not nums:\n        return 0\n\n    dp = [1] * len(nums)\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    return max(dp)\n\n\ndef main():\n    test_case_1 = [10,9,2,5,3,7,101,18]\n    print(f\"Length of LIS for {test_case_1} is: {lengthOfLIS(test_case_1)}\")\n\n    test_case_2 = [0,1,0,3,12,8,2,1,10]\n    print(f\"Length of LIS for {test_case_2} is: {lengthOfLIS(test_case_2)}\")\n\n    test_case_3 = []\n    print(f\"Length of LIS for {test_case_3} is: {lengthOfLIS(test_case_3)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1488": "```\ndef findSwaps(arr):\n    n = len(arr)\n    max_val = max(arr)\n    min_val = min(arr)\n    \n    swaps = []\n    for i in range(n):\n        if arr[i] == min_val:\n            continue\n        elif arr[i] < min_val:\n            arr[i], min_val = min_val, arr[i]\n            swaps.append((min_val, i))\n            min_val = min(arr)\n        else:\n            arr[i], max_val = max_val, arr[i]\n            swaps.append((max_val, i))\n            max_val = max(arr)\n\n    return swaps\n\ndef main():\n    print(\"Test Case 1:\")\n    arr1 = [3, 2, 1, 4]\n    expected_result1 = [(2, 1), (1, 0)]\n    actual_result1 = findSwaps(arr1)\n    if actual_result1 == expected_result1:\n        print(\"Passed\")\n    else:\n        print(\"Failed\")\n\n    print(\"\\nTest Case 2:\")\n    arr2 = [1, 4, 3, 2]\n    expected_result2 = [(2, 3), (1, 0)]\n    actual_result2 = findSwaps(arr2)\n    if actual_result2 == expected_result2:\n        print(\"Passed\")\n    else:\n        print(\"Failed\")\n\n    print(\"\\nTest Case 3:\")\n    arr3 = [4, 2, 5, 1, 3]\n    expected_result3 = [(5, 0), (4, 3), (2, 1)]\n    actual_result3 = findSwaps(arr3)\n    if actual_result3 == expected_result3:\n        print(\"Passed\")\n    else:\n        print(\"Failed\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1489": "```\ndef findCriticalAndPseudoCriticalEdges(graph):\n    def dfs(u, parent, low, disc, visited, scc):\n        children = 0\n        visited[u] = True\n        disc[u] = low[u] = len(disc)\n        for v in graph[u]:\n            if not visited[v]:\n                parent[v] = u\n                children += 1\n                dfs(v, parent, low, disc, visited, scc)\n                low[u] = min(low[u], low[v])\n                if (parent[u] == -1 and children > 1) or ((parent[u] != -1) and low[v] >= low[u]):\n                    scc.append(u)\n            elif v != parent[u]:\n                low[u] = min(low[u], disc[v])\n\n    visited = [False]*len(graph)\n    disc = [float('inf')] * len(graph)\n    low = [float('inf')] * len(graph)\n    scc = []\n    critical_edges = set()\n    pseudo_critical_edges = set()\n\n    for u in range(len(graph)):\n        if not visited[u]:\n            dfs(u, [-1]*len(graph), low, disc, visited, scc)\n\n    for edge in graph:\n        parent = [-1] * len(graph)\n        rank = [0] * len(graph)\n        parent[edge[0]] = -1\n        pseudo_critical_edges.update(i for i, (u, v) in enumerate(graph) if u != edge[0] and u != edge[1] and rank[u] < rank[v])\n        critical_edges.update({(edge[0], edge[1])})\n        dfs(edge[0], parent, low, disc, visited, scc)\n\n    return list(critical_edges), list(pseudo_critical_edges)\n\n\ndef main():\n    graph1 = [[1, 2, 3], [1, 3]]\n    critical_edges1, pseudo_critical_edges1 = findCriticalAndPseudoCriticalEdges(graph1)\n    print(\"Test Case 1:\")\n    print(f\"Critical Edges: {critical_edges1}\")\n    print(f\"Pseudo-Critical Edges: {pseudo_critical_edges1}\\n\")\n\n    graph2 = [[0, 1, 5], [1, 2, 3], [2, 3, 6], [0, 3, 7]]\n    critical_edges2, pseudo_critical_edges2 = findCriticalAndPseudoCriticalEdges(graph2)\n    print(\"Test Case 2:\")\n    print(f\"Critical Edges: {critical_edges2}\")\n    print(f\"Pseudo-Critical Edges: {pseudo_critical_edges2}\\n\")\n\n    graph3 = [[0, 1, 4], [1, 2, 5]]\n    critical_edges3, pseudo_critical_edges3 = findCriticalAndPseudoCriticalEdges(graph3)\n    print(\"Test Case 3:\")\n    print(f\"Critical Edges: {critical_edges3}\")\n    print(f\"Pseudo-Critical Edges: {pseudo_critical_edges3}\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1490": "```\ndef cloneNaryTree(self, root):\n    if not root:\n        return None\n\n    new_root = Node(root.val)\n    node_map = {root: new_root}\n\n    def dfs(node):\n        if not node:\n            return\n        for child in node.children:\n            if child not in node_map:\n                new_child = Node(child.val)\n                node_map[child] = new_child\n            new_root.children.append(node_map[child])\n            dfs(child)\n\n    dfs(root)\n    return new_root\n\nclass Solution:\n    def main():\n        s = Solution()\n        root1 = Node(1)\n        root1.children = [Node(3), Node(2), Node(4)]\n        print(s.cloneNaryTree(root1))\n\n        root2 = Node(1)\n        root2.children = []\n        print(s.cloneNaryTree(root2))\n\n        root3 = Node(1)\n        root3.children = [Node(2), Node(2)]\n        print(s.cloneNaryTree(root3))\n\n    if __name__ == \"__main__\":\n        Solution.main()\n\nclass Node:\n    def __init__(self, val=None):\n        self.val = val\n        self.children = []\n\n```",
  "1491": "```\ndef average(salaries):\n    salaries.sort()\n    salaries.pop(0)\n    salaries.pop(-1)\n    return sum(salaries) / len(salaries)\n\ndef main():\n    print(\"Test case 1:\")\n    print(average([2000, 3000, 1000, 4000])) \n\n    print(\"\\nTest case 2:\")\n    print(average([1000, 2000, 3000]))\n\n    print(\"\\nTest case 3:\")\n    print(average([6, 9, 14, 0, 4, 7, 5]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1492": "```\ndef kthFactor(n: int, k: int) -> int:\n    result = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            result.append(i)\n    return result[k - 1]\n\ndef main():\n    print(kthFactor(24, 18)) # Expected output: 3\n    print(kthFactor(37, 2))   # Expected output: 37\n    print(kthFactor(100, 5))  # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1493": "```\ndef longestSubarray(nums):\n    max_len = 0\n    last_zero = -1\n    curr_len = 0\n    \n    for i, num in enumerate(nums):\n        if num == 0:\n            last_zero = i\n            curr_len = 0\n        else:\n            curr_len += 1\n        \n        max_len = max(max_len, curr_len)\n    \n    return min(max_len, len(nums) - (last_zero + 1)) if last_zero != -1 and max_len > 0 else max_len\n\ndef main():\n    print(longestSubarray([0,1,1])) # Expected output: 3\n    print(longestSubarray([0,1,0,1,1,1,0,1])) # Expected output: 5\n    print(longestSubarray([1,0,1,1,0,1,1,1])) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1494": "```\ndef scheduleCourse(courses):\n    courses.sort(key=lambda x: x[1])\n    time = 0\n    heap = []\n    for course in courses:\n        if time + course[1] <= course[0]:\n            heapq.heappush(heap, -course[1])\n            time += course[1]\n        elif heap and heap[0] < -course[1]:\n            a = heapq.heappop(heap)\n            time -= -a - course[1]\n            if time + course[1] <= course[0]:\n                heapq.heappush(heap, -course[1])\n                time += course[1]\n\n    return sum(-x for x in heap)\n\ndef main():\n    print(scheduleCourse([[100, 200], [201, 202], [301, 302]]))  # Output: 3\n    print(scheduleCourse([[1,2],[2,4],[3,9],[4,6]]))  # Output: 9\n    print(scheduleCourse([]))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1495": "```\ndef findCollectedFares(streams):\n    collected_fares = {}\n    for stream in streams:\n        movie_id = stream[1]\n        if movie_id not in collected_fares:\n            collected_fares[movie_id] = 0\n        if stream[2] == \"like\":\n            collected_fares[movie_id] += 2\n        elif stream[2] == \"dislike\":\n            collected_fares[movie_id] -= 1\n    return list(collected_fares.items())\n\ndef main():\n    streams = [[\"Ava\", 0, \"like\"], [\"Bob\", 0, \"like\"], [\"Ava\", 0, \"dislike\"]]\n    print(findCollectedFares(streams))\n    \n    streams = [[\"John\", 1, \"like\"], [\"Jane\", 1, \"dislike\"], [\"John\", 2, \"like\"]]\n    print(findCollectedFares(streams))\n    \n    streams = [[1, \"Alice\", \"like\"], [0, \"Alice\", \"dislike\"], [1, \"Bob\", \"like\"]]\n    print(findCollectedFares(streams))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1496": "```\ndef isPathCrossing(path):\n    seen = set()\n    pos = (0, 0)\n    for step in path:\n        if step == 'N':\n            pos = (pos[0], pos[1] + 1)\n        elif step == 'S':\n            pos = (pos[0], pos[1] - 1)\n        elif step == 'E':\n            pos = (pos[0] + 1, pos[1])\n        elif step == 'W':\n            pos = (pos[0] - 1, pos[1])\n        \n        if tuple(pos) in seen:\n            return True\n        seen.add(tuple(pos))\n    return False\n\ndef main():\n    print(isPathCrossing(\"NNE\")) \n    print(isPathCrossing(\"NESW\"))\n    print(isPathCrossing(\"ENWS\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1497": "```\ndef canArrange(arr, k):\n    count = [0] * (k + 1)\n    for num in arr:\n        count[num % k] += 1\n    if count[0] % 2 != 0:\n        return False\n    for i in range(1, k // 2 + 1):\n        if count[i] % 2 != count[k - i]:\n            return False\n    return True\n\ndef main():\n    print(canArrange([1,2,3,4,5], 3)) # True\n    print(canArrange([1,2,3,4,5,6], 7)) # False\n    print(canArrange([18,12,-2,-9,15,28], 5)) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1498": "```\ndef numSubseq(nums, target):\n    nums.sort()\n    ans = 0\n    for i in range(len(nums)):\n        l, r = i, len(nums) - 1\n        while l <= r:\n            s = nums[l] + nums[r]\n            if s > target:\n                r -= 1\n            elif s == target:\n                ans += 1\n                break\n            else:\n                ans += (r - l)\n                break\n    return ans\n\ndef main():\n    test_case_1 = [1,2,3,4,5]\n    target_sum_1 = 15\n    print(f\"Test Case 1: {numSubseq(test_case_1, target_sum_1)}\")\n\n    test_case_2 = [10,11,12,13,14]\n    target_sum_2 = 30\n    print(f\"Test Case 2: {numSubseq(test_case_2, target_sum_2)}\")\n\n    test_case_3 = [4,5,6,7,8]\n    target_sum_3 = 10\n    print(f\"Test Case 3: {numSubseq(test_case_3, target_sum_3)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1499": "```\ndef maxValueEquation(A, L):\n    A.sort()\n    L.sort()\n    i = j = 0\n    result = -1\n    while i < len(A) and j < len(L):\n        if A[i] >= L[j]:\n            temp = A[i]\n            while i + 1 < len(A) and A[i+1] >= L[j]:\n                i += 1\n            result = max(result, temp)\n            i -= 1\n        j += 1\n    return result\n\ndef main():\n    print(maxValueEquation([-10,-6,13,1],[-5,-14]))  # Output: 14\n    print(maxValueEquation([3,4,5,2], [-2,3,8,7])  # Output: 11\n    print(maxValueEquation([-3,-1], [0,0])  # Output: -1\n\nmain()\n```",
  "1500": "```\nclass FileSharingSystem:\n    def __init__(self):\n        self.file_sizes = {}\n\n    def put(self, file_name: str, size: int) -> None:\n        self.file_sizes[file_name] = size\n\n    def get(self, file_name: str) -> int:\n        return self.file_sizes.get(file_name, -1)\n\ndef main():\n    system = FileSharingSystem()\n    \n    test_case_1()\n    test_case_2()\n    test_case_3()\n\ndef test_case_1():\n    system.put(\"file1.txt\", 100)\n    print(system.get(\"file1.txt\"))  # Expected output: 100\n\ndef test_case_2():\n    system.put(\"file1.txt\", 100)\n    system.put(\"file2.txt\", 200)\n    print(system.get(\"file1.txt\"))  # Expected output: 100\n    print(system.get(\"file2.txt\"))  # Expected output: 200\n\ndef test_case_3():\n    print(system.get(\"fileNotExists.txt\"))  # Expected output: -1",
  "1501": "```\ndef isCountrySafe(country):\n    safe_countries = {\"USA\", \"Canada\", \"Australia\"}\n    return country in safe_countries\n\n\ndef main():\n    print(isCountrySafe(\"USA\"))  # Test case 1: USA should be True\n    print(isCountrySafe(\"India\"))  # Test case 2: India should be False\n    print(isCountrySafe(\"Canada\"))  # Test case 3: Canada should be True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1502": "```\ndef canMakeArithmeticProgression(arr):\n    arr.sort()\n    n = len(arr)\n    \n    for i in range(n - 2):\n        diff = (arr[i + 1] - arr[i])\n        if diff != arr[i + 2] - arr[i + 1]:\n            return False\n    \n    return True\n\ndef main():\n    test_cases = [\n        [3,5,1],\n        [4,6,5,7],\n        [0,-1,1]\n    ]\n\n    for test_case in test_cases:\n        print(f\"Test case: {test_case} -> {canMakeArithmeticProgression(test_case)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1503": "```\ndef maxAnts(mass: list) -> int:\n    n = len(mass)\n    left, right = [0] * (n + 1), [0] * (n + 1)\n\n    for i in range(1, n):\n        left[i] = left[i - 1] + mass[i]\n    for i in range(n - 1, -1, -1):\n        right[i] = right[i + 1] + mass[i]\n\n    result = float('-inf')\n    for i in range(n):\n        if left[i] * right[n - i - 1] < 0:\n            return i\n        result = max(result, i)\n\n    return n\n\ndef main():\n    print(maxAnts([1, 2, 3])) \n    print(maxAnts([-1, 0, 2, 3])) \n    print(maxAnts([10, -20, 30]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1504": "```\ndef numSubmat(matrix):\n    m, n = len(matrix), len(matrix[0])\n    res = [[0]*n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                res[i][j] = (j+1) if i == 0 else res[i-1][j]+1\n            else:\n                res[i][j] = 0\n    \n    ans = 0\n    for i in range(m):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                min_width = res[i][j]\n                last_zero_pos = j\n                while last_zero_pos < n and matrix[i][last_zero_pos] == 1:\n                    min_width = min(min_width, res[i][last_zero_pos])\n                    last_zero_pos += 1\n                \n                ans += min_width\n    \n    return ans\n\ndef main():\n    test_cases = [\n        {\n            \"matrix\": [[0,1,1],\n                       [1,1,1],\n                       [0,1,1]],\n            \"expected_output\": 6\n        },\n        {\n            \"matrix\": [[0,0,1],\n                       [1,1,1],\n                       [1,1,1]],\n            \"expected_output\": 12\n        },\n        {\n            \"matrix\": [[1,0,1],\n                       [1,1,1],\n                       [1,1,1]],\n            \"expected_output\": 21\n        }\n    ]\n    \n    for test_case in test_cases:\n        output = numSubmat(test_case[\"matrix\"])\n        if output == test_case[\"expected_output\"]:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed. Expected: {test_case['expected_output']}, got: {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1505": "```\ndef minKBitFlip(nums, k):\n    n = len(nums)\n    res = [0] * (n + 1)\n\n    for i in range(n):\n        if res[i] == 0:\n            j = max(0, i - k)\n            while j < i and nums[j] % 2 == 1:\n                j += 1\n            if j < i:\n                res[i] = 1\n            else:\n                res[i] = min(i, n - k) + 1\n\n    return sum(1 for x in res if x)\n\ndef main():\n    print(minKBitFlip([0,1], 1)) # expected: 0\n    print(minKBitFlip([0,0,1,0,0,0,0,1], 3) ) # expected: 5\n    print(minKBitFlip([0,1,0], 1) ) # expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1507": "```\ndef reformatDate(date):\n    months = {\"Jan\": \"01\", \"Feb\": \"02\", \"Mar\": \"03\", \"Apr\": \"04\", \n              \"May\": \"05\", \"Jun\": \"06\", \"Jul\": \"07\", \"Aug\": \"08\", \n              \"Sep\": \"09\", \"Oct\": \"10\", \"Nov\": \"11\", \"Dec\": \"12\"}\n    return f\"{months[date.split()[0]]}/{date.split()[1]}/20{date.split()[2][1:]}\"\n\ndef main():\n    print(reformatDate(\"20th Jan 2053\")) \n    print(reformatDate(\"26th Aug 1984\")) \n    print(reformatDate(\"23rd June 2007\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1506": "```\ndef findRoot(NaryTree):\n    root = None\n    for node in NaryTree:\n        if not node.children or (root and node.val < root.val):\n            root = node\n    return root\n\ndef main():\n    # Test Case 1\n    tree1 = Node(1)\n    tree1.children = [Node(3), Node(5, children=[Node(6)]), Node(2)]\n    print(findRoot(tree1).val)  # Output: 1\n\n    # Test Case 2\n    tree2 = Node(0)\n    tree2.children = [Node(1), Node(3, children=[Node(4), Node(5)])]\n    print(findRoot(tree2).val)  # Output: 0\n\n    # Test Case 3\n    tree3 = Node(2)\n    tree3.children = [Node(7, children=[Node(8)]), Node(6), Node(9)]\n    print(findRoot(tree3).val)  # Output: 2\n\nclass Node:\n    def __init__(self, val=None):\n        self.val = val\n        self.children = []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1508": "```\ndef rangeSum(nums, n, left, right):\n    prefix_sum = [0] * (len(nums) + 1)\n    for i in range(len(nums)):\n        prefix_sum[i+1] = prefix_sum[i] + nums[i]\n    \n    def find_pivot(left_right, target):\n        lo, hi = 0, len(prefix_sum) - 1\n        while lo <= hi:\n            mid = (lo + hi) // 2\n            if left_right == 'left':\n                target_sum = prefix_sum[mid] - prefix_sum[0]\n            else:\n                target_sum = prefix_sum[-1] - prefix_sum[mid+1]\n            if target_sum < target:\n                lo = mid + 1\n            elif target_sum > target:\n                hi = mid - 1\n            else:\n                return mid\n        return lo if left_right == 'left' else hi\n\n    def find_range(left, right):\n        left_pivot = find_pivot('left', left)\n        right_pivot = find_pivot('right', right)\n        \n        left_sum = prefix_sum[left_pivot] - prefix_sum[0]\n        right_sum = prefix_sum[-1] - prefix_sum[right_pivot+1]\n        \n        return (right - left) * (left_sum + right_sum) // 2\n\ndef main():\n    print(rangeSum([1,2,3,4], 5, 6, 8))\n    print(rangeSum([-2,-3,3,4,5], 10, -10, 0))\n    print(rangeSum([0,0,0], 1, 0, 0))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1509": "```\ndef minDifference(nums):\n    nums.sort()\n    return min((nums[-1] - nums[0]), (nums[-2] - nums[1]), (nums[-3] - nums[2]))\n\ndef main():\n    print(minDifference([10, 4, 5, 2])) # Test case 1\n    print(minDifference([7, 9, 5, 8, 3])) # Test case 2\n    print(minDifference([1, 5, 0, 10, 14])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1510": "```\ndef winning_score(a, b):\n    n = len(a) + len(b)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] < b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + a[i - 1]\n            elif a[i - 1] > b[j - 1]:\n                dp[i][j] = dp[i - 1][j] + b[j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + max(a[i - 1], b[j - 1])\n    return min(n, n - (dp[n][n]))\n\ndef main():\n    print(winning_score([5,3,4,2], [1,2,4,1,3])) # Test case 1\n    print(winning_score([9,9,9], [8,7,6])) # Test case 2\n    print(winning_score([], [])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1511": "```\ndef totalOrderValue(accounts):\n    value = 0\n    for account in accounts:\n        if account[1] > 0:\n            value += account[1]\n    return value\n\ndef numOrders(accounts):\n    count = 0\n    for account in accounts:\n        if account[1] > 0:\n            count += 1\n    return count\n\ndef customerOrderFrequency(accounts):\n    frequencyMap = {}\n    for account in accounts:\n        if account[1] > 0:\n            name = account[0]\n            orders = account[1]\n            if name not in frequencyMap:\n                frequencyMap[name] = [orders, 1]\n            else:\n                currentOrders, frequency = frequencyMap[name]\n                frequencyMap[name] = [currentOrders + orders, frequency + 1]\n    return frequencyMap\n\ndef main():\n    accounts1 = [[\"John\", 5], [\"Mary\", 3], [\"John\", 3]]\n    print(\"Test case 1: \")\n    print(customerOrderFrequency(accounts1))\n    \n    accounts2 = [[\"John\", 10], [\"Jane\", 2], [\"Mary\", 4], [\"John\", 1], [\"John\", 5], [\"Jane\", 2]]\n    print(\"\\nTest case 2: \")\n    print(customerOrderFrequency(accounts2))\n\n    accounts3 = [[\"John\", 1], [\"Jane\", 2], [\"Mary\", 3], [\"John\", 4], [\"John\", 5], [\"Jane\", 6], [\"John\", 7]]\n    print(\"\\nTest case 3: \")\n    print(customerOrderFrequency(accounts3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1512": "```\ndef numIdenticalPairs(nums):\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            if nums[i] == nums[j]:\n                count += 1\n    return count\n\n\ndef main():\n    print(\"Test case 1:\")\n    print(numIdenticalPairs([1, 2, 3, 1, 1, 3])) # Expected: 4\n\n    print(\"\\nTest case 2:\")\n    print(numIdenticalPairs([1, 1, 1, 2, 2])) # Expected: 6\n\n    print(\"\\nTest case 3:\")\n    print(numIdenticalPairs([0, 1, 2, 5])) # Expected: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1513": "```\ndef numSub(s):\n    if not s:\n        return 0\n    \n    count = 0\n    ones_count = 0\n    \n    for c in s:\n        if c == '1':\n            ones_count += 1\n        else:\n            count += ones_count * (ones_count + 1) // 2\n            ones_count = 0\n    \n    count += ones_count * (ones_count + 1) // 2\n    return count\n\ndef main():\n    print(numSub(\"011012\"))  # Output: 9\n    print(numSub(\"111\"))  # Output: 10\n    print(numSub(\"000\"))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1514": "```\nimport heapq\n\ndef maxProbability(n, edges, seedTail, edgeProb):\n    graph = [[] for _ in range(n)]\n    for u, v, p in edges:\n        graph[u].append((v, p))\n        graph[v].append((u, p))\n\n    heap = [1.0]  # Initialize with probability 1 at node 0\n    dp = [0.0] * n  # Probability of each node\n    dp[seedTail[0]] = 1.0  # Seed tail has a probability of 1\n\n    while heap:\n        p = -heapq.heappop(heap)  # Extract the maximum probability\n        for neighbor, prob in graph[int(p * 10**9)]:\n            newProb = min(p, dp[neighbor] + prob)\n            if newProb > dp[neighbor]:\n                dp[neighbor] = newProb\n                heapq.heappush(heap, -newProb)\n\n    return max(dp)\n\ndef main():\n    n1 = 3\n    edges1 = [[0,1],[1,2],[0,2]]\n    seedTail1 = [0,2]\n    edgeProb1 = [0.5,0.3,0.7]\n    print(maxProbability(n1,edges1,seedTail1,edgeProb1))\n\n    n2 = 4\n    edges2 = [[0,1],[1,2],[2,3],[1,3]]\n    seedTail2 = [0,3]\n    edgeProb2 = [0.7,0.7,0.5,0.7]\n    print(maxProbability(n2,edges2,seedTail2,edgeProb2))\n\n    n3 = 5\n    edges3 = [[0,1],[1,2],[2,3],[3,4]]\n    seedTail3 = [0,4]\n    edgeProb3 = [0.9,0.8,0.7,0.6]\n    print(maxProbability(n3,edges3,seedTail3,edgeProb3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1515": "```\ndef totalTravelCost(positions, distances):\n    positions.sort()\n    travel_cost = 0\n    for i in range(len(positions) - 1):\n        travel_cost += distances[i] * (positions[i + 1] - positions[i])\n    return travel_cost\n\n\ndef main():\n    test_cases = [\n        {\"positions\": [2, 5, 3], \"distances\": [10, 5, 6], \"expected_result\": 22},\n        {\"positions\": [7, 4, 11, 9, 1, 8, 10], \"distances\": [1, 3, 4, 2, 5, 1, 2],\n         \"expected_result\": 15},\n        {\"positions\": [12, 22, 36, 14, 25, 35, 30, 31, 32, 33], \"distances\": [8, 3, 4, 7, 9,\n                                                                                       2, 5, 1, 6, 10],\n         \"expected_result\": 41}\n    ]\n\n    for test_case in test_cases:\n        positions = test_case[\"positions\"]\n        distances = test_case[\"distances\"]\n        expected_result = test_case[\"expected_result\"]\n        result = totalTravelCost(positions, distances)\n        if result == expected_result:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected {expected_result} but got {result}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1516": "```\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children if children is not None else []\n\ndef move_subtree(root: 'Node', to_val: int) -> 'Node':\n    if root is None:\n        return None\n\n    if root.val == to_val:\n        new_root = Node()\n        new_root.children.extend([move_subtree(child, to_val) for child in root.children])\n        return new_root\n\n    root.children = [move_subtree(child, to_val) for child in root.children]\n\n    return root\n\ndef print_tree(node):\n    if node is None:\n        return\n    print(node.val)\n    for child in node.children:\n        print(\"  \", end=\"\")\n        print_tree(child)\n\ndef main():\n    # Test case 1: move the whole tree with value 2 to a new location\n    n1 = Node(1, [Node(3), Node(5)])\n    n2 = Node(4)\n    n1.children[0].children.append(Node(6))\n    n1.children[1].children.extend([Node(7), Node(8), Node(9)])\n    root = Node(\"root\", [n1, n2])\n    new_root = move_subtree(root, 2)\n    print(\"Original tree:\")\n    print_tree(root)\n    print(\"\\nMoved subtree with value 2:\")\n    print_tree(new_root)\n\n    # Test case 2: only one node in the whole tree has the target value\n    root = Node(1, [Node(2), Node(3)])\n    new_root = move_subtree(root, 3)\n    print(\"\\nOriginal tree:\")\n    print_tree(root)\n    print(\"\\nMoved subtree with value 3:\")\n    print_tree(new_root)\n\n    # Test case 3: no nodes in the whole tree have the target value\n    root = Node(1, [Node(2), Node(4)])\n    new_root = move_subtree(root, 5)\n    print(\"\\nOriginal tree:\")\n    print_tree(root)\n    print(\"\\nMoved subtree with no matching value:\")\n    print_tree(new_root)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1517": "```\ndef hasValidEmail(user_info):\n    for email in user_info:\n        if '@' not in email or ' ' in email:\n            return False\n    return True\n\ndef find_valid_users(users):\n    valid_users = []\n    for user in users:\n        if hasValidEmail(user[1]):\n            valid_users.append(user)\n    return valid_users\n\n\ndef main():\n    test_cases = [\n        {\n            \"users\": [[\"John\", \"john@example.com\"], [\"Jane\", \"jane@google.com\"], [\"Alice\", \"alice@amazon.com\"]],\n            \"expected_result\": [[\"John\", \"john@example.com\"], [\"Jane\", \"jane@google.com\"], [\"Alice\", \"alice@amazon.com\"]]\n        },\n        {\n            \"users\": [[\"John\", \"john example.com\"], [\"Jane\", \"jane@.com\"], [\"Alice\", \"alice@gmail\"]],\n            \"expected_result\": [[\"John\", \"john example.com\"]]\n        },\n        {\n            \"users\": [[\"John\", \"john@example\"], [\"Jane\", \"jane@example.\"], [\"Alice\", \"alice@\"]],\n            \"expected_result\": []\n        }\n    ]\n\n    for test_case in test_cases:\n        users = test_case[\"users\"]\n        expected_result = test_case[\"expected_result\"]\n        result = find_valid_users(users)\n        if result == expected_result:\n            print(\"Test case passed.\")\n        else:\n            print(f\"Test case failed. Expected {expected_result}, got {result}.\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1518": "```\ndef numWaterBottles(numBottles, numCopies):\n    return (numBottles + numCopies) * 2\n\ndef main():\n    print(\"Test Case 1: \")\n    print(numWaterBottles(1, 0), \"water bottles expected, got\", numWaterBottles(1, 0))\n\n    print(\"\\nTest Case 2: \")\n    print(numWaterBottles(3, 5), \"water bottles expected, got\", numWaterBottles(3, 5))\n\n    print(\"\\nTest Case 3: \")\n    print(numWaterBottles(0, 4), \"water bottles expected, got\", numWaterBottles(0, 4))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1519": "```\nclass Solution:\n    def countNodes(self, root):\n        if not root:\n            return 0\n        \n        res = {}\n        stack = [(root, \"\")]\n        \n        while stack:\n            node, label = stack.pop()\n            if node:\n                if label in res:\n                    res[label] += 1\n                else:\n                    res[label] = 1\n                stack.append((node.left, label + \".L\"))\n                stack.append((node.right, label + \".R\"))\n\n        return sum(res.values())\n\ndef main():\n    solution = Solution()\n    \n    root1 = TreeNode(5)\n    root1.left = TreeNode(1)\n    root1.right = TreeNode(5)\n    root1.left.left = TreeNode(5)\n    root1.left.right = TreeNode(2)\n    print(solution.countNodes(root1))  # Output: 11\n    \n    root2 = TreeNode(10)\n    root2.left = TreeNode(-5)\n    root2.right = TreeNode(10)\n    root2.left.left = TreeNode(5)\n    root2.left.right = TreeNode(-3)\n    root2.right.right = TreeNode(7)\n    print(solution.countNodes(root2))  # Output: 13\n    \n    root3 = TreeNode(0)\n    root3.left = TreeNode(1)\n    root3.right = TreeNode(1)\n    print(solution.countNodes(root3))  # Output: 4\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1520": "```\ndef maxNonOverlapping(s: str) -> int:\n    n = len(s)\n    res = 0\n    i = 0\n    while i < n:\n        if i + 1 < n and s[i] == '0':\n            i += 2\n        elif i + 3 < n and s[i:i+4].lstrip('0') != '':\n            i += 4\n        else:\n            res += 1\n            i += 1\n    return res\n\ndef main():\n    print(maxNonOverlapping(\"0110\")) # Test case 1\n    print(maxNonOverlapping(\"00110100\")) # Test case 2\n    print(maxNonOverlapping(\"00011110000001\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1521": "```\ndef closestDivisor(target):\n    if target < 1:\n        return -1\n    left, right = 1, target\n    closest = float('inf')\n    while left <= right:\n        mid = (left + right) // 2\n        distance = abs(mid - target)\n        if distance > target - mid:\n            right = mid - 1\n            closest = min(closest, mid)\n        else:\n            left = mid + 1\n    return closest\n\ndef main():\n    test_cases = [(10, 3), (11, 9), (14, 2)]\n    \n    for target, expected in test_cases:\n        result = closestDivisor(target)\n        if result == expected:\n            print(f\"Test case {target}: Passed. Expected: {expected}, Got: {result}\")\n        else:\n            print(f\"Test case {target}: Failed. Expected: {expected}, Got: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1522": "```\nclass Solution:\n    def diameterOfNArrows(self, root):\n        self.ans = 0\n        def depth(node):\n            if not node: return 0\n            d1 = depth(node.child)\n            d2 = depth(node.child) if node.child else 0\n            self.ans = max(self.ans, d1 + d2)\n            return 1 + max(d1, d2)\n        depth(root)\n        return self.ans\n\ndef main():\n    solution = Solution()\n    print(solution.diameterOfNArrows(Node([Node([]), Node([])])))\n    print(solution.diameterOfNArrows(Node([Node([Node([]), Node([])]), Node([])])))\n    print(solution.diameterOfNArrows(None))\n\nclass Node:\n    def __init__(self, children):\n        self.child = [Node(children) if children else None for children in children]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1523": "```\ndef countOdds(low, high):\n    return (high - low) // 2 + ((high % 2 != 0) or (low % 2 != 0))\n\ndef main():\n    print(countOdds(1, 10), end=' ')\n    print(countOdds(3, 13), end=' ')\n    print(countOdds(-3, 5))\n\nmain()\n```",
  "1524": "```\ndef numOddSubarrays(nums):\n    odd_sum_count = [0]\n    total_sum = 0\n    for num in nums:\n        total_sum += num\n        if total_sum % 2 == 1:\n            odd_sum_count[0] += 1\n        else:\n            odd_sum_count.append(1)\n    return sum(2 ** i - 1 for i in range(len(odd_sum_count)))\n\ndef main():\n    print(numOddSubarrays([1,0,0,1])) # Test case 1\n    print(numOddSubarrays([0,1,0,1,0,1])) # Test case 2\n    print(numOddSubarrays([0])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1525": "```\ndef numSplits(s):\n    n = len(s)\n    left = [0] * (n + 1)\n    for i in range(1, n):\n        if set(s[:i]) != set(s[i:]):\n            left[i] = left[i - 1] + 1\n        else:\n            left[i] = left[i - 1]\n            \n    right = [0] * (n + 1)\n    for i in range(n - 2, -1, -1):\n        if set(s[:i]) != set(s[i+1:]):\n            right[i] = right[i + 1] + 1\n        else:\n            right[i] = right[i + 1]\n            \n    ans = left[-1]\n    for i in range(n):\n        ans += right[i]\n    return ans\n\n\ndef main():\n    print(numSplits(\"cool\"))  # Output: 2\n    print(numSplits(\"abcdefs\"))  # Output: 3\n    print(numSplits(\"abcddcba\"))  # Output: 9\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1527": "```\ndef checkWearing(data):\n    result = []\n    for row in data:\n        if row[1] == 'Condition':\n            result.append(row)\n    return result\n\n\ndef main():\n    data = [[\"John\", \"Healthy\"], [\"Jane\", \"Condition\"], [\"Jim\", \"Condition\"]]\n    \n    test_cases = [\n        {\"input\": data, \"expected_output\": [[\"Jane\", \"Condition\"], [\"Jim\", \"Condition\"]] },\n        {\"input\": [[\"John\", \"Healthy\"], [\"Jane\", \"Healthy\"]], \"expected_output\": [] },\n        {\"input\": [[\"John\", \"Healthy\"], [\"Jane\", \"Condition\"], [\"Jim\", \"Condition\"]], \n         \"expected_output\": [[\"Jane\", \"Condition\"], [\"Jim\", \"Condition\"]] }\n    ]\n\n    for test_case in test_cases:\n        output = checkWearing(test_case[\"input\"])\n        if output == test_case[\"expected_output\"]:\n            print(\"Test case passed!\")\n        else:\n            print(f\"Test case failed! Expected {test_case['expected_output']}, got {output}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1526": "```\ndef minNumberOnSubarrays(target):\n    n = len(target)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + target[i]\n    \n    result = 0\n    stack = []\n    right = 0\n    for left in range(n):\n        while len(stack) and stack[-1][1] > right:\n            prev_right, curr_prefix_sum = stack.pop()\n            delta = (right - prev_right) * (curr_prefix_sum - prefix_sum[left])\n            result += abs(delta)\n        if not len(stack) or right < stack[-1][0]:\n            stack.append((right, prefix_sum[right]))\n        right += 1\n    \n    while len(stack):\n        prev_right, curr_prefix_sum = stack.pop()\n        delta = (n - prev_right) * (curr_prefix_sum - prefix_sum[left])\n        result += abs(delta)\n    \n    return result\n\ndef main():\n    print(minNumberOnSubarrays([98,23,34,90])) # 5\n    print(minNumberOnSubarrays([10,2,3,7,9])) # 8\n    print(minNumberOnSubarrays([1,2,3,4,5,6,7,8,9])) # 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1528": "```\ndef shuffleString(s1: str, s2: str) -> str:\n    if len(s1) != len(s2):\n        return \"\"\n\n    result = list(s1)\n    for i in range(len(s1)):\n        result[i] = s2[i]\n\n    return \"\".join(result)\n\ndef main():\n    print(shuffleString(\"abc\", \"pqr\"))  # Expected: pqr\n    print(shuffleString(\"codeleet\", \"leetcaod\"))  # Expected: leetcaod\n    print(shuffleString(\"abc\", \"azyz\"))  # Expected: azyz\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1529": "```\ndef minFlips(s):\n    flips = [c != '0' for c in s]\n    return sum(flips[:i] or flips[i:] for i in range(len(s)))\n\ndef main():\n    print(minFlips(\"00111\")) # Test case 1\n    print(minFlips(\"10101\")) # Test case 2\n    print(minFlips(\"11101111\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1530": "```\nclass Solution:\n    def countGoodNodes(self, root):\n        self.ans = 0\n        self.max_val = float('-inf')\n        self.dfs(root, float('-inf'))\n        return self.ans\n\n    def dfs(self, node, max_val):\n        if not node: return\n        if node.val >= max_val:\n            self.ans += 1\n            self.max_val = node.val\n        self.dfs(node.right, node.val)\n        self.dfs(node.left, node.val)\n\ndef main():\n    s = Solution()\n    root = [3,1,null,null,2,null]\n    print(s.countGoodNodes(root))\n    \n    root = [1,null,3,null,4,null,2]\n    print(s.countGoodNodes(root))\n    \n    root = [5,null,null,-3,null,11]\n    print(s.countGoodNodes(root))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1531": "```\ndef get_length_of_longest_substring(s):\n    if not s:\n        return 0\n    \n    max_len = 0\n    left = 0\n    char_map = {}\n    \n    for right in range(len(s)):\n        if s[right] in char_map:\n            left = max(left, char_map[s[right]] + 1)\n        \n        char_map[s[right]] = right\n        max_len = max(max_len, right - left + 1)\n    \n    return max_len\n\ndef main():\n    print(get_length_of_longest_substring(\"ABCBCBA\"))  # Output: 2\n    print(get_length_of_longest_substring(\"BBBBBBB\"))  # Output: 7\n    print(get_length_of_longest_substring(\"\"))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1533": "```\ndef find_right(self, nums: List[int]) -> int:\n    left = 0\n    right = len(nums) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if nums[mid] == max(nums):\n            if mid == len(nums) - 1 or nums[mid] > nums[mid+1]:\n                return mid\n            left = mid + 1\n        else:\n            right = mid - 1\n\ndef main():\n    # Test case 1\n    nums1 = [2,3,5,4]\n    print(\"Test Case 1: \", find_right(nums1))\n    \n    # Test case 2\n    nums2 = [6,7,9,8,5,4,3,2]\n    print(\"Test Case 2: \", find_right(nums2))\n    \n    # Test case 3\n    nums3 = [10,1,8,2,5,3,0]\n    print(\"Test Case 3: \", find_right(nums3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1532": "```\ndef recent_orders(customers):\n    orders = {}\n    for customer in customers:\n        if customer[\"id\"] not in orders:\n            orders[customer[\"id\"]] = []\n        orders[customer[\"id\"]].append(customer)\n    return [orders[i][-3:] for i in sorted(orders)]\n\ndef main():\n    test_cases = [\n        {\n            \"customers\": [\n                {\"customer_id\": 1, \"total_amount\": 15.0},\n                {\"customer_id\": 2, \"total_amount\": 20.0},\n                {\"customer_id\": 3, \"total_amount\": 10.0},\n                {\"customer_id\": 2, \"total_amount\": 5.0},\n                {\"customer_id\": 1, \"total_amount\": 25.0}\n            ]\n        },\n        {\n            \"customers\": [\n                {\"customer_id\": 4, \"total_amount\": 30.0},\n                {\"customer_id\": 5, \"total_amount\": 40.0},\n                {\"customer_id\": 6, \"total_amount\": 20.0},\n                {\"customer_id\": 7, \"total_amount\": 15.0}\n            ]\n        },\n        {\n            \"customers\": [\n                {\"customer_id\": 8, \"total_amount\": 50.0},\n                {\"customer_id\": 9, \"total_amount\": 60.0},\n                {\"customer_id\": 10, \"total_amount\": 70.0},\n                {\"customer_id\": 11, \"total_amount\": 80.0},\n                {\"customer_id\": 12, \"total_amount\": 90.0}\n            ]\n        }\n    ]\n\n    for test_case in test_cases:\n        result = recent_orders(test_case[\"customers\"])\n        print(f\"Test case: {test_case}\")\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1534": "```\ndef countGoodTriplets(arr):\n    n = len(arr)\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if arr[i] <= arr[j] and arr[j] <= arr[k]:\n                    res += 1\n    return res\n\n\ndef main():\n    print(countGoodTriplets([2,1,3])) # Test case 1: Expected output is 2\n    print(countGoodTriplets([-1,2,3,0])) # Test case 2: Expected output is 4\n    print(countGoodTriplets([5,2,8,6])) # Test case 3: Expected output is 12\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1535": "```\ndef getWinner contests):\n    total = [0] * (max(contests) + 1)\n    for contest in contests:\n        total[contest] += 1\n    winner, max_score = min((i, v) for i, v in enumerate(total) if v > 0), 0\n    for i, score in enumerate(total):\n        if score > max_score and i < len(contests):\n            return i\n    return winner\n\ndef main():\n    print(getWinner([2,1,3])) # Expected: 1\n    print(getWinner([1,2,2,1])) # Expected: 2\n    print(getWinner([10,12])) # Expected: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1536": "```\ndef minSwaps(grid):\n    n = len(grid)\n    swaps = 0\n    indices = list(range(n))\n    \n    for i in range(n):\n        indices.sort(key=lambda x: grid[x][i])\n        \n        L, R = 0, i+1\n        while R - L > 1:\n            if grid[indices[L]][i] != grid[indices[R-1]][i]:\n                break\n            L += 1\n        R -= 1\n        \n        for j in range(L, R):\n            indices[j], indices[j+1] = indices[j+1], indices[j]\n        \n        swaps += i - L\n    \n    return swaps\n\ndef main():\n    print(minSwaps([[0,1],[1,0]])) # Expected: 1\n    print(minSwaps([[0,0,1],[1,1,1],[1,0,0]])) # Expected: 3\n    print(minSwaps([[1,1,1],[1,0,1],[0,1,0]])) # Expected: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1537": "```\ndef maxScore(cardPoints, k):\n    n = len(cardPoints)\n    score = sum(cardPoints[:k])\n    for i in range(k-1, -1, -1):\n        score += cardPoints[i]\n    return score\n\n\ndef main():\n    print(maxScore([2,9,3,4], 3) == 10)\n    print(maxScore([2,5,6], 5) == 14)\n    print(maxScore([1,2,3,7,8,9,10,11,12,13], 10) == 40)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1538": "```\ndef majorityElement(nums):\n    count = {}\n    for num in nums:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    for k, v in count.items():\n        if v > len(nums) // 2:\n            return k\n\ndef main():\n    print(majorityElement([2, 2, 1, 1, 1, 2, 2])) # Should print 2\n    print(majorityElement([3, 3, 4, 2, 4, 4, 2, 4, 4])) # Should print 3\n    print(majorityElement([1, 2, 3, 4, 5])) # Should print 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1539": "```\ndef findKthPositive(arr, k):\n    arr.sort()\n    i = 0\n    for num in range(1, len(arr) + k + 1):\n        if num == arr[i]:\n            i += 1\n        else:\n            k -= 1\n            if k == 0:\n                return num\n    return -1\n\ndef main():\n    print(findKthPositive([2,3,4,5], 5)) # Output: 6\n    print(findKthPositive([1,2,3], 3)) # Output: 4\n    print(findKthPositive([2019,2040], 10) # Output: 2022\n\nmain()\n```",
  "1540": "```\ndef canConvert(string1, string2, k):\n    if len(string1) != len(string2):\n        return False\n    diff_count = {}\n    for i in range(len(string1)):\n        if string1[i] != string2[i]:\n            diff_count[ord(string1[i]) - ord('a')] = diff_count.get(ord(string1[i]) - ord('a'), 0) + 1\n    for key, value in diff_count.items():\n        if value > k:\n            return False\n    return True\n\ndef main():\n    print(canConvert(\"abc\", \"axyz\", 2)) # Expected: true\n    print(canConvert(\"leetcode\", \"practice\", 5)) # Expected: false\n    print(canConvert(\"a1b\", \"oneyz\", 0)) # Expected: true\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1541": "```\ndef minInsertions(s):\n    n = len(s)\n    left, right = 0, 0\n    for c in s:\n        if c == '(':\n            left += 1\n        else:\n            right += 1\n        if left < right:\n            return n - (left + right)\n        elif left > right:\n            return left - right\n    return 0\n\ndef main():\n    print(minInsertions(\"()))\"))  # Expected: 3\n    print(minInsertions(\"(\"))     # Expected: 2\n    print(minInsertions(\"()\"))    # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1542": "```\ndef longestAwesome(s: str) -> int:\n    n = len(s)\n    max_len = 0\n    for i in range(n):\n        diff_count = 0\n        for j in range(i, n):\n            if (ord(s[i]) - ord('a')) ^ (ord(s[j]) - ord('a')) > 1:\n                break\n            if s[i] != s[j]:\n                diff_count += 1\n            else:\n                max_len = max(max_len, j - i + 1)\n    return max_len\n\ndef main():\n    test_cases = [\n        (\"loveba\", 3),\n        (\"abcba\", 4),\n        (\"aabaa\", 2)\n    ]\n\n    for s, expected in test_cases:\n        result = longestAwesome(s)\n        if result == expected:\n            print(f\"Test case '{s}' passed: {result} = {expected}\")\n        else:\n            print(f\"Test case '{s}' failed: {result} != {expected}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1543": "```\ndef to_snake_case(product_name):\n    return ''.join(['_' + char.lower() if char.isupper() else char for char in product_name]).lstrip('_')\n\ndef main():\n    print(to_snake_case(\"CamelCaseProduct\")) # Should return \"camel_case_product\"\n    print(to_snake_case(\"ProductName\")) # Should return \"_product_name\"\n    print(to_snake_case(\"ALL UPPERCASE\")) # Should return \"_all_uppercase\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1544": "```\ndef greatString(s):\n    result = \"\"\n    for char in s:\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    return result\n\n\ndef main():\n    print(greatString(\"aBCd\"))  # Expected output: \"abcd\"\n    print(greatString(\"AbCd\"))  # Expected output: \"abcD\"\n    print(greatString(\"ALLCAPS\"))  # Expected output: \"allcaps\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1545": "```\ndef findKthBit(n: int, k: int) -> str:\n    if n == 1:\n        return '0' if k == 1 else '1'\n    half_n = (1 << (n - 1))\n    left_half = '1' + '0'.join(findKthBit(n-1, k-1) if k > 1 else findKthBit(n-1, k) for _ in range(half_n))\n    right_half = '0' + ''.join(findKthBit(n-1, k - half_n) if k > half_n else findKthBit(n-1, k - half_n) for _ in range(half_n - 1))\n    return left_half[-1] if k == half_n else right_half[0]\n\ndef main():\n    print(findKthBit(3, 4))  # Expected output: '0'\n    print(findKthBit(4, 11))  # Expected output: '1'\n    print(findKthBit(5, 21))   # Expected output: '1'\n\nif __name__ == '__main__':\n    main()\n```",
  "1546": "```\ndef maxNonOverlapping(nums, target):\n    n = len(nums)\n    prefixSum = [0] * (n + 1)\n    for i in range(n):\n        prefixSum[i+1] = prefixSum[i] + nums[i]\n    \n    res = 0\n    left = right = 0\n    while right < n:\n        if prefixSum[right + 1] - prefixSum[left] == target:\n            res += 1\n            left = right + 1\n        elif right > left and prefixSum[right + 1] - prefixSum[left] >= target:\n            res += 1\n            left = right + 1\n        else:\n            right += 1\n\n    return res\n\n\ndef main():\n    print(maxNonOverlapping([0,1,1,1,2,3,3,2,2,2,20,1,1], 7)) # Expected: 2\n    print(maxNonOverlapping([-1,-2,3,2], 3)) # Expected: 2\n    print(maxNonOverlapping([0,0,0], 0)) # Expected: 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1547": "```\ndef minCostToCutStick(length):\n    dp = [float('inf')] * (length + 1)\n    dp[0] = 0\n    for i in range(1, length + 1):\n        for j in range(i):\n            dp[i] = min(dp[i], dp[j] + abs(i - j))\n    return dp[length]\n\ndef main():\n    print(minCostToCutStick(10)) \n    print(minCostToCutStick(2)) \n    print(minCostToCutStick(4))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1549": "```\ndef get_order_items(order_items):\n    order_items = sorted(order_items, key=lambda x: (x[2], x[0]))\n    result = {}\n    for item in order_items:\n        if item[1] not in result or item[2] > result[item[1]][2]:\n            result[item[1]] = item\n    return list(result.values())\n\ndef main():\n    test_cases = [\n        {\n            \"order_items\": [[\"productA\", \"order1\", 5], [\"productB\", \"order1\", 3], [\"productA\", \"order2\", 4], [\"productB\", \"order2\", 2]],\n            \"expected\": [[\"productA\", \"order2\", 4], [\"productB\", \"order1\", 3]]\n        },\n        {\n            \"order_items\": [[\"productC\", \"order1\", 5], [\"productD\", \"order2\", 6], [\"productC\", \"order3\", 7], [\"productD\", \"order4\", 8]],\n            \"expected\": [[\"productC\", \"order3\", 7], [\"productD\", \"order4\", 8]]\n        },\n        {\n            \"order_items\": [[\"productE\", \"order1\", 5], [\"productF\", \"order2\", 6], [\"productE\", \"order3\", 7]],\n            \"expected\": [[\"productE\", \"order3\", 7], [\"productF\", \"order2\", 6]]\n        }\n    ]\n\n    for test_case in test_cases:\n        order_items = test_case[\"order_items\"]\n        expected = test_case[\"expected\"]\n        result = get_order_items(order_items)\n        assert result == expected, f\"Test case failed: {test_case}\"\n\n    print(\"All test cases passed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1548": "```\ndef mostSimilarPath(graph):\n    n = len(graph)\n    dp = [[float('inf')] * n for _ in range(n)]\n    parent = [[-1] * n for _ in range(n)]\n\n    dp[0][0] = graph[0][0]\n    for i in range(1, n):\n        dp[i][0] = min(dp[i-1][0], graph[i][0])\n        parent[i][0] = 0 if dp[i][0] == dp[i-1][0] else -1\n\n    for j in range(1, n):\n        dp[0][j] = min(dp[0][j-1], graph[0][j])\n        parent[0][j] = 0 if dp[0][j] == dp[0][j-1] else -1\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if dp[i-1][j] < dp[i][j]:\n                parent[i][j] = (i-1, j)\n                dp[i][j] = dp[i-1][j]\n            elif dp[i][j-1] < dp[i][j]:\n                parent[i][j] = (i, j-1)\n                dp[i][j] = dp[i][j-1]\n    return dp, parent\n\n\ndef mostSimilarPathInGraph(graph):\n    m, n = len(graph), len(graph[0])\n    min_val = float('inf')\n    path = []\n    i, j = 0, 0\n    while i < m and j < n:\n        if graph[i][j] < min_val:\n            min_val = graph[i][j]\n            path.append((i, j))\n        p = parent[i][j]\n        if p == (-1, -1):\n            break\n        if p[0] >= 0:\n            i = p[0]\n        else:\n            j = p[1]\n\n    return path\n\n\ndef main():\n    graph1 = [[3,5],[2,4]]\n    print(mostSimilarPathInGraph(graph1))\n    \n    graph2 = [[10,12,9,6],\n              [7,8,11,14],\n              [15,16,17,13],\n              [18,19,20,21]]\n    print(mostSimilarPathInGraph(graph2))\n\n    graph3 = [[1,4],[2,5,3],[4],[]]\n    print(mostSimilarPathInGraph(graph3))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1550": "```\ndef consecutiveOdds(nums):\n    nums.sort()\n    for i in range(len(nums) - 2):\n        if abs(nums[i] - nums[i+1]) == 1 and abs(nums[i+1] - nums[i+2]) == 2:\n            return True\n    return False\n\n\ndef main():\n    print(consecutiveOdds([2,4,5,3])) # Expected: True\n    print(consecutiveOdds([1,3,5,7,9])) # Expected: True\n    print(consecutiveOdds([1,2,3,8,9])) # Expected: False\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1551": "```\ndef minOperations(nums):\n    target = max(nums)\n    operations = 0\n    for num in nums:\n        operations += (target - num) // (num + 1)\n    return int(operations)\n\ndef main():\n    print(minOperations([2,10,6]) == 4)\n    print(minOperations([3,5,7]) == 13)\n    print(minOperations([9,8,7,6,5,4,3,2,1]) == 25)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1553": "```\ndef min_days(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        for j in range(i):\n            if j * 2 <= i:\n                dp[i] = min(dp[i], dp[j] + 1)\n    return dp[n]\n\ndef main():\n    print(min_days(4))  # Output: 3\n    print(min_days(6))  # Output: 4\n    print(min_days(13))  # Output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1552": "```\ndef magneticForce(positions):\n    positions.sort()\n    forces = []\n    for i in range(1, len(positions)):\n        forces.append(abs(positions[i] - positions[i-1]))\n    return sum(forces)\n\ndef main():\n    print(magneticForce([1, 2, 3, 4, 5])) # Test case 1\n    print(magneticForce([-1, -2, -3, -4, -5])) # Test case 2\n    print(magneticForce([0, 0, 0, 0, 0])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1554": "```\ndef containsNearbyDuplicate(words):\n    word_dict = {}\n    for i, word in enumerate(words):\n        if word in word_dict:\n            return True\n        word_dict[word] = i\n    return False\n\n\ndef main():\n    print(containsNearbyDuplicate([\"hello\", \"world\", \"hello\", \"world\"])) # Expected: True\n    print(containsNearbyDuplicate([\"a\", \"b\", \"c\", \"d\"])) # Expected: False\n    print(containsNearbyDuplicate([\"a\", \"b\", \"c\", \"a\"])) # Expected: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1555": "```\ndef getTransactionSum(transactions):\n    result = {}\n    for transaction in transactions:\n        date, amount = transaction.split(\", \")\n        if date not in result:\n            result[date] = []\n        result[date].append(int(amount))\n    return result\n\ndef getBalance(transactions):\n    total = 0\n    for transaction in transactions:\n        date, amount = transaction.split(\", \")\n        total += int(amount)\n    return total\n\ndef bankAccountSummary(transactions):\n    summary = {}\n    balance = getBalance(transactions)\n    transaction_sum = getTransactionSum(transactions)\n    \n    summary[\"balance\"] = balance\n    summary[\"transactions\"] = transaction_sum\n    \n    return summary\n\ndef main():\n    test_cases = [\n        {\n            \"transactions\": [\"2020-01-01, 100\", \"2020-01-02, -50\", \"2020-01-03, 200\"],\n            \"expected\": {\"balance\": 250, \"transactions\": {\"2020-01-01\": [100], \"2020-01-02\": [-50], \"2020-01-03\": [200]}}\n        },\n        \n        {\n            \"transactions\": [\"2022-07-15, -500\", \"2022-08-20, 300\"],\n            \"expected\": {\"balance\": -200, \"transactions\": {\"2022-07-15\": [-500], \"2022-08-20\": [300]}}\n        },\n        \n        {\n            \"transactions\": [\"2023-01-05, 1000\", \"2023-01-06, -250\", \"2023-02-10, 200\"],\n            \"expected\": {\"balance\": 950, \"transactions\": {\"2023-01-05\": [1000], \"2023-01-06\": [-250], \"2023-02-10\": [200]}}\n        }\n    ]\n    \n    for test_case in test_cases:\n        transactions = test_case[\"transactions\"]\n        expected = test_case[\"expected\"]\n        \n        result = bankAccountSummary(transactions)\n        \n        print(f\"Test Case: {test_case}\")\n        print(f\"Expected: {expected}\")\n        print(f\"Result: {result}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1556": "```\ndef thousandSeparator(n: int) -> str:\n    return \"{:,}\".format(n)\n\ndef main():\n    print(thousandSeparator(1234567890)) # Test case 1\n    print(thousandSeparator(1000000)) # Test case 2\n    print(thousandSeparator(999999)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1558": "```\ndef min_operations(nums):\n    n = len(nums)\n    res = 0\n    for i in range(30):\n        ones = sum((1 << i) & nums)\n        zeros = n - ones\n        if ones > zeros:\n            res += ones - zeros\n    return res\n\n\ndef main():\n    print(min_operations([10, 2, 3, 8]))  # Expected output: 6\n    print(min_operations([3, 1, 7, 11, 12, 5, 13]))  # Expected output: 4\n    print(min_operations([1000000000, 1000001000]))  # Expected output: 2\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1557": "```\ndef minDays(edges):\n    graph = {}\n    for edge in edges:\n        if edge[0] not in graph:\n            graph[edge[0]] = []\n        if edge[1] not in graph:\n            graph[edge[1]] = []\n        graph[edge[0]].append(edge[1])\n        graph[edge[1]].append(edge[0])\n\n    visited = set()\n    min_days = 0\n    for node in graph:\n        if node not in visited:\n            stack = [node]\n            visited.add(node)\n            days = 0\n            while stack:\n                node = stack.pop(0)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        stack.append(neighbor)\n                days += 1\n            min_days = max(min_days, days)\n\n    return min_days\n\n\ndef main():\n    test_case1_edges = [[0, 1], [2, 3]]\n    print(\"Test Case 1: \", minDays(test_case1_edges))  # Expected output: 2\n\n    test_case2_edges = [[0, 1], [1, 2], [2, 0], [1, 4], [4, 3]]\n    print(\"Test Case 2: \", minDays(test_case2_edges))  # Expected output: 4\n\n    test_case3_edges = [[1, 2], [1, 3], [2, 3], [1, 4], [0, 1], [1, 5]]\n    print(\"Test Case 3: \", minDays(test_case3_edges))  # Expected output: 2\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1560": "```\ndef mostVisited(n, radius, sectors):\n    max_visit = [0] * (2 * n + 1)\n    \n    for i in range(len(sectors)):\n        for j in range(2*radius+1):\n            if abs(sectors[i] - j) <= radius:\n                max_visit[j] += 1\n    \n    return maxVisit.index(max(maxVisit))\n\ndef main():\n    print(mostVisited(4, 2, [0,3]))\n    print(mostVisited(7, 5, [1,4,6]))\n    print(mostVisited(3, 1, [0]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1559": "```\ndef hasCircularPath(grid):\n    rows, cols = len(grid), len(grid[0])\n    visited = [[False]*cols for _ in range(rows)]\n    parent = [[-1]*cols for _ in range(rows)]\n\n    def dfs(r, c):\n        if r < 0 or c < 0 or r >= rows or c >= cols:\n            return False\n        if grid[r][c] == -1:\n            return True\n        if visited[r][c]:\n            return False\n        visited[r][c] = True\n        parent[r][c] = (r, c)\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1 and parent[nr][nc] == (-1, -1):\n                return dfs(nr, nc)\n        return False\n\n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == 1:\n                if dfs(r, c):\n                    return True\n    return False\n\n\ndef main():\n    test_cases = [\n        {\n            'grid': [[0,1,0],[1,1,1],[0,1,0]],\n            'expected_output': True\n        },\n        {\n            'grid': [[0,0,0],[0,1,0],[0,1,0]],\n            'expected_output': False\n        },\n        {\n            'grid': [[0,1,0],[1,1,1],[0,0,0]],\n            'expected_output': True\n        }\n    ]\n\n    for test_case in test_cases:\n        if hasCircularPath(test_case['grid']) != test_case['expected_output']:\n            print(\"Test case failed: \", test_case)\n            return\n\n    print(\"All test cases passed.\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1561": "```\ndef maxCoins(coins):\n    coins.sort(reverse=True)\n    total_coins = 0\n    i = 0\n    while i < len(coins):\n        if i + 2 <= len(coins):\n            total_coins += sum(coins[i:i+3])\n            i += 3\n        else:\n            total_coins += sum(coins[i:])\n            break\n    return total_coins\n\n\ndef main():\n    print(maxCoins([6,5,4,3,2,1])) # Test case 1: [6,5,4,3,2,1]\n    print(maxCoins([2,1,5]) )     # Test case 2: [2,1,5]\n    print(maxCoins([]))            # Test case 3: []\n\nmain()\n```",
  "1562": "```\ndef latest_diverse_group(games, M):\n    game_id_to_count = {}\n    for i, (id1, id2) in enumerate(zip(*games)):\n        game_id_to_count[id1] = game_id_to_count.get(id1, 0) + 1\n        game_id_to_count[id2] = game_id_to_count.get(id2, 0) + 1\n\n    last_group = -1\n    for i, (id1, id2) in enumerate(zip(*games)):\n        if len(game_id_to_count) <= M:\n            return i\n        else:\n            game_id_to_count[id1] -= 1\n            game_id_to_count[id2] -= 1\n            if all(count == 0 for count in game_id_to_count.values()):\n                last_group = i\n\n    return last_group\n\n\ndef main():\n    games1 = [[0, 1], [1, 3], [3, 5]]\n    print(latest_diverse_group(games1, 2))  # Output: 4\n\n    games2 = [[0, 6], [1, 6], [2, 8], [3, 8], [4, 10]]\n    print(latest_diverse_group(games2, 4))  # Output: 6\n\n    games3 = [[10, 12], [11, 13], [12, 14], [13, 15]]\n    print(latest_diverse_group(games3, 3))  # Output: -1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1563": "```\ndef stoneGameV(stones):\n    n = len(stones)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + stones[i]\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length\n            total = prefix_sum[j] - prefix_sum[i]\n            if total % 2 == 0:\n                dp[i][j] = max(dp[i][i + (total // 2)], dp[i + (total // 2) + 1][j])\n            else:\n                dp[i][j] = max(dp[i][i + (total // 2) + 1], dp[i + (total // 2) + 1][j])\n    \n    return dp[0][n - 1]\n\ndef main():\n    test_cases = [\n        ([5, 3, 4, 5], 6),\n        ([6, 2, 8, 1, 9], 11),\n        ([10, 5, 2, 7, 9, 1, 5], 14)\n    ]\n    \n    for test_case in test_cases:\n        stones = test_case[0]\n        expected_output = test_case[1]\n        actual_output = stoneGameV(stones)\n        if actual_output == expected_output:\n            print(\"Test case passed: Stones {}, Expected Output {}\".format(stones, expected_output))\n        else:\n            print(\"Test case failed: Stones {}, Expected Output {}, Actual Output {}\".format(stones, expected_output, actual_output))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1565": "```\ndef total_orders(customers):\n    orders = set()\n    for customer in customers:\n        if len(customer) > 0:\n            orders.update([str(month) + ' ' + str(order) for month, order in zip(range(1, 13), customer)])\n    return len(orders)\n\ndef main():\n    print(total_orders([[1,2,3],[4,5,6]])) # Test case 1\n    print(total_orders([])) # Test case 2\n    print(total_orders([[]])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1564": "```\ndef maximumEarnings(heights):\n    max_earnings = 0\n    stack = []\n    \n    for i in range(len(heights)):\n        while stack and heights[stack[-1]] < heights[i]:\n            top = stack.pop()\n            width = i if not stack else i - stack[-1] - 1\n            max_earnings = max(max_earnings, widths[top] * height)\n            stack.append(i)\n    \n    while stack:\n        top = stack.pop()\n        width = len(heights) if not stack else len(heights) - stack[-1] - 1\n        max_earnings = max(max_earnings, widths[top] * heights[top])\n    \n    return max_earnings\n\n\ndef main():\n    test_cases = [\n        ([3, 5, 1, 6, 2, 0, 8], 29),\n        ([10, 9, 8, 7, 6, 5, 4, 3, 2, 1], 20),\n        ([10000000, 10000000, 10000000], 6000000000)\n    ]\n\n    for heights, max_earnings in test_cases:\n        print(f\"Input: {heights}, Expected: {max_earnings}, Actual: {maximumEarnings(heights)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1566": "```\ndef contains_pattern(arr, m, k):\n    n = len(arr)\n    for i in range(n - m * k + 1):\n        if arr[i:i+m] * k == arr[i:i+m*k]:\n            return True\n    return False\n\ndef main():\n    print(contains_pattern([1,2,2,3,2,2,3], 2, 10))\n    print(contains_pattern([1,2,3,1,2,3,1,2,3], 3, 5))\n    print(contains_pattern([1,2,1,2,1,3], 2, 7))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1567": "```\ndef maxAlternatingSum(nums):\n    even_sum = 0\n    odd_sum = 1\n    for num in nums:\n        temp = even_sum\n        even_sum = max(even_sum, odd_sum + num)\n        odd_sum = temp + num\n    return even_sum\n\n\ndef main():\n    print(maxAlternatingSum([2,4,-3]), \"Expected: 8\")\n    print(maxAlternatingSum([-1,2,3,-7]), \"Expected: 6\")\n    print(maxAlternatingSum([2,-5,0,-8,-12]), \"Expected: 14\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1569": "```\ndef numEquivDominoArrangements(a):\n    from collections import Counter\n    c = Counter(tuple(sorted(d)) for d in a)\n    res = [1] * (len(a) + 1)\n    for v, cnt in c.items():\n        res[v[0]] *= comb(v[1]+1, 2)\n        res[v[1]] *= comb(v[0]+1, 2)\n    return res[-1]\n\nfrom math import comb\ndef main():\n    print(numEquivDominoArrangements([[1,3],[5,1],[4,3],[2,5]])) \n    print(numEquivDominoArrangements([[2,1],[3,5],[4,4],[1,2],[5,3]]))\n    print(numEquivDominoArrangements([[1,1],[2,2]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1568": "```\ndef numDays(board):\n    m, n = len(board), len(board[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n    visited = [[False] * n for _ in range(m)]\n\n    def dfs(r, c):\n        if r < 0 or r >= m or c < 0 or c >= n:\n            return\n        if board[r][c] == 'X' or visited[r][c]:\n            return\n        visited[r][c] = True\n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            dfs(nr, nc)\n\n    def getArea():\n        area = 0\n        visited = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    area += 1\n        return area\n\n    def bfs(r, c):\n        m, n = len(board), len(board[0])\n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        visited = [[False] * n for _ in range(m)]\n\n        queue = [(r, c)]\n        visited[r][c] = True\n        while queue:\n            r, c = queue.pop(0)\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and board[nr][nc] == '1' and not visited[nr][nc]:\n                    queue.append((nr, nc))\n                    visited[nr][nc] = True\n\n    def getDays():\n        days = [0]\n        visited = [[False] * n for _ in range(m)]\n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == '1' and not visited[i][j]:\n                    dfs(i, j)\n                    bfs(i, j)\n                    days.append(len(days) + 1)\n\n        return max(days)\n\n    return getDays()\n\nif __name__ == \"__main__\":\n    main()\n    print(minDays([[\"0\",\"0\",\"0\",\"0\",\"X\"],[\"1\",\"0\",\"1\",\"0\",\"x\"],[\"1\",\"1\",\"1\",\"0\",\"x\"],[\"1\",\"1\",\"1\",\"2\",\"0\"]])) \n    print(minDays([[\"0\",\"0\",\"0\",\"0\",\"X\"],[\"1\",\"0\",\"1\",\"0\",\"x\"],[\"1\",\"1\",\"1\",\"0\",\"x\"],[\"1\",\"1\",\"1\",\"2\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"X\"]]))\n    print(minDays([[\"0\",\"1\",\"1\",\"0\",\"X\"],[\"1\",\"1\",\"3\",\"4\",\"x\"],[\"5\",\"6\",\"7\",\"8\",\"9\"], [\"1\",\"9\",\"10\",\"11\",\"1\"]]))\n```",
  "1570": "```\ndef dotProduct(v1, v2):\n    result = 0\n    i = j = 0\n    while i < len(v1) or j < len(v2):\n        if i >= len(v1):\n            j += 1\n        elif j >= len(v2):\n            i += 1\n        else:\n            result += v1[i] * v2[j]\n            i += 1\n            j += 1\n    return result\n\ndef main():\n    print(\"Test Case 1: \")\n    v1 = [1, 2, 3, 4]\n    v2 = [5, 6, 7, 8]\n    print(dotProduct(v1, v2))\n\n    print(\"\\nTest Case 2: \")\n    v1 = [0.5, 1.5]\n    v2 = [1, 1]\n    print(dotProduct(v1, v2))\n\n    print(\"\\nTest Case 3: \")\n    v1 = [0, 0, 0]\n    v2 = [1, 2, 3]\n    print(dotProduct(v1, v2))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1571": "```\ndef totalAmount(time1, time2):\n    if time1 > time2:\n        return (time2 - time1) * 5 + time2\n    else:\n        return (time2 - time1) * 5 + time1\n\ndef main():\n    print(\"Test case 1:\")\n    print(f\"Total amount: {totalAmount(1, 3)}\")\n    \n    print(\"\\nTest case 2:\")\n    print(f\"Total amount: {totalAmount(10, 12)}\")\n    \n    print(\"\\nTest case 3:\")\n    print(f\"Total amount: {totalAmount(7, 9)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1572": "```\ndef diagonalSum(mat):\n    n = len(mat)\n    left_sum = sum(mat[i][i] for i in range(n))\n    right_sum = sum(mat[i][n-i-1] for i in range(n) if i != n//2)\n    return left_sum + right_sum if n % 2 else left_sum + right_sum\n\ndef main():\n    print(diagonalSum([[1, 2, 3], [4, 5, 6], [9, 8, 7]]))\n    print(diagonalSum([[1, 1, 1], [2, 2, 2], [4, 4, 4]]))\n    print(diagonalSum([[5]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1573": "```\ndef numWays(s):\n    n = len(s)\n    res = 0\n    for i in range(1, n):\n        if s[i-1] == s[i]:\n            res += 1\n    return res\n\ndef main():\n    print(numWays(\"abc\")) # Test case 1\n    print(numWays(\"aabbc\")) # Test case 2\n    print(numWays(\"aaabbaa\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1574": "```\ndef minSubArrayToRemoveMakeArraySorted(arr):\n    n = len(arr)\n    if n == 1:\n        return 0\n    \n    res = n\n    left = 0\n    for right in range(n):\n        while left <= right and arr[left] < arr[right]:\n            res = min(res, right - left + 1)\n            left += 1\n            \n    return res\n\ndef main():\n    print(minSubArrayToRemoveMakeArraySorted([2,3,1])) # Output: 2\n    print(minSubArrayToRemoveMakeArraySorted([2,2,2])) # Output: 0\n    print(minSubArrayToRemoveMakeArraySorted([1,3,5,4,6,7])) # Output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1575": "```\ndef numWays(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * (n+1) for _ in range(m+1)]\n\n    dp[0][0] = 1\n    for i in range(1, m+1):\n        if grid[i-1][0] == 0:\n            dp[i][0] = dp[i-1][0]\n        else:\n            break\n\n    for j in range(1, n+1):\n        if grid[0][j-1] == 0:\n            dp[0][j] = dp[0][j-1]\n        else:\n            break\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if grid[i-1][j-1] == 0 and (i==1 or j==1 or grid[i-2][j-2] == 0):\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n            elif grid[i-1][j-1] == 0:\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\n    return dp[m][n]\n\n\ndef main():\n    print(numWays([\n        [0,0,0,0],\n        [1,1,1,0],\n        [0,1,0,0]\n    ]))  # Expected: 8\n    print(numWays([\n        [0,0,0,0],\n        [0,1,1,0],\n        [0,1,1,0]\n    ]))  # Expected: 5\n    print(numWays([\n        [0,0,0,0],\n        [1,1,1,1],\n        [1,0,0,0]\n    ]))  # Expected: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1576": "```\ndef replaceSearchedChars(s):\n    result = \"\"\n    for char in s:\n        if char == 's':\n            while (result and result[-1] == 's' or\n                   (len(result) >= 2 and result[-1].lower() == result[-2].lower())):\n                result += \"no\"\n            result += \"2\"\n        else:\n            result += char\n    return result\n\ndef main():\n    print(replaceSearchedChars(\"a\")  # Expected output: \"a\"\n    print(replaceSearchedChars(\"s\"))  # Expected output: \"n02\"\n    print(replaceSearchedChars(\"abss\"))  # Expected output: \"an02\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1577": "```\ndef numTriplets(nums):\n    n = len(nums)\n    count = 0\n    for i in range(n-1):\n        for j in range(i+1, n):\n            a = nums[i]\n            b = nums[j]\n            c = int((a*b)**0.5)\n            if c in nums:\n                count += 1\n    return count\n\n\ndef main():\n    print(numTriplets([4,7,6,3])) # Output: 2\n    print(numTriplets([1,1])) # Output: 1\n    print(numTriplets([7,8])) # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1578": "```\ndef minCostToMakeRopeColorful(rope_length, colors):\n    n = len(colors)\n    dp = [0] * (n + 1)\n    for i in range(1, n):\n        dp[i] = dp[i - 1] + ord(colors[i]) - ord(colors[i - 1])\n    res = float('inf')\n    for i in range(n):\n        left = right = i\n        while left > 0 and right < n:\n            if (right - left) * (ord(colors[right]) - ord(colors[left])) <= rope_length:\n                res = min(res, dp[right] - dp[left])\n                right -= 1\n                left += 1\n            else:\n                break\n    return res\n\ndef main():\n    print(minCostToMakeRopeColorful(3, \"WRRWWRW\"))\n    print(minCostToMakeRopeColorful(4, \"RRGB\"))\n    print(minCostToMakeRopeColorful(8, \"GGGGMGGG\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1579": "```\nclass Solution:\n    def maxEddyEdges(self, N: int, roads: List[List[int]]) -> int:\n        parent = list(range(N))\n        rank = [0] * N\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        def union(x, y):\n            root_x, root_y = find(x), find(y)\n            if root_x == root_y: \n                return False\n            if rank[root_x] > rank[root_y]: \n                parent[root_y] = root_x\n            else:\n                parent[root_x] = root_y\n                if rank[root_x] == rank[root_y]: \n                    rank[root_y] += 1\n        res = N - 1\n        for edge in roads:\n            union(edge[0], edge[1])\n            if len(set([find(i) for i in set(edge)])) == 1:\n                res -= 1\n        return res\n\ndef main():\n    solution = Solution()\n    print(solution.maxEddyEdges(4, [[0,1],[1,2],[1,3]])) # 2\n    print(solution.maxEddyEdges(6, [[0,1],[0,2],[1,3],[5,2],[3,4]])) # 4\n    print(solution.maxEddyEdges(8, [[0,1],[1,2],[2,3],[0,4],[5,6],[6,7],[7,8],[0,5],[5,6],[6,7],[7,8]])) # 20\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1580": "```\ndef maxBoxCount(warehouseCapacity, boxes):\n    warehouse = [0] * (warehouseCapacity + 1)\n    for box in boxes:\n        i, j = 0, warehouseCapacity\n        while i < j:\n            m = (i + j) // 2\n            if warehouse[m] + box <= warehouseCapacity:\n                j = m\n            else:\n                i = m + 1\n        warehouse[i] += box\n    return sum((warehouse[i] - i) for i in range(warehouseCapacity + 1))\n\ndef main():\n    print(maxBoxCount(6, [1, 2, 3, 4, 5])) # Test case 1: boxes = [1, 2, 3, 4, 5], warehouseCapacity = 6\n    print(maxBoxCount(10, [3, 2, 7, 9, 1, 4, 5, 8])) # Test case 2: boxes = [3, 2, 7, 9, 1, 4, 5, 8], warehouseCapacity = 10\n    print(maxBoxCount(20, [1, 4, 2, 6, 8, 4, 3, 7])) # Test case 3: boxes = [1, 4, 2, 6, 8, 4, 3, 7], warehouseCapacity = 20\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1581": "```\ndef get_customer_id(customers):\n    transaction_customers = set()\n    for transaction in customers:\n        transaction_customers.add(transaction[0])\n    return [customer[0] for customer in customers if customer[0] not in transaction_customers]\n\ndef main():\n    test_cases = [\n        ([[1, \"A\"], [2, \"B\"], [3, \"C\"]], [[1]]),\n        ([[1, \"A\"], [1, \"B\"], [2, \"C\"]], [[2]]),\n        ([[1, \"A\"], [2, \"B\"], [3, \"C\"], [1, \"D\"]], [[1]]\n    ]\n\n    for test_case in test_cases:\n        customers = test_case[0]\n        expected_result = test_case[1]\n\n        result = get_customer_id(customers)\n        print(f\"Test case: {customers} | Expected: {expected_result} | Actual: {result}\")\n        assert result == expected_result, f\"Test case failed. Expected: {expected_result}, Actual: {result}\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1582": "```\ndef numSpecial(mat):\n    m, n = len(mat), len(mat[0])\n    count = 0\n    for i in range(m):\n        row_count = sum(1 for x in mat[i] if x)\n        col_count = sum(1 for j in range(n) if sum(mat[k][j] for k in range(m)) == 1)\n        if (row_count == 1 and col_count > 0) or (col_count == 1 and row_count > 0):\n            count += 1\n    return count\n\ndef main():\n    print(numSpecial([[1,0,0],[0,0,1],[1,0,0]])) # Expected output: 3\n    print(numSpecial([[1,0,0],[1,0,1],[1,1,1]])) # Expected output: 2\n    print(numSpecial([[1,0,0,0],[0,0,0,1],[1,0,0,0],[1,1,1,1]])) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1583": "```\ndef unhappyFriends(n, friends):\n    count = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        for j in friends[i-1]:\n            if j > i:\n                count[j] += 1\n    return sum(count)\n\ndef main():\n    print(unhappyFriends(4, [[1, 2], [3, 4]]))\n    print(unhappyFriends(5, [[1, 3], [2, 3], [4, 5]]))\n    print(unhappyFriends(6, [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1584": "```\ndef findMinCost(points):\n    n = len(points)\n    parent = list(range(n))\n    rank = [0] * n\n    edges = []\n\n    for i in range(n):\n        for j in range(i+1, n):\n            distance = ((points[i][0]-points[j][0])**2 + (points[i][1]-points[j][1])**2)**0.5\n            edges.append((distance, i, j))\n\n    edges.sort()\n\n    result = 0\n    for edge in edges:\n        distance, u, v = edge\n        if parent[u] != parent[v]:\n            result += distance\n            parent[v] = parent[u]\n            rank[parent[u]] += 1\n\n    return result\n\n\ndef main():\n    points1 = [[0,0],[2,2]]\n    print(findMinCost(points1)) # Output: 2.8284271247461903\n\n    points2 = [[-1,-1],[-1,1],[1,-1],[1,1]]\n    print(findMinCost(points2)) # Output: 12.0\n\n    points3 = [[0,0],[1,0],[2,0],[3,0],[0,1],[1,1],[2,1],[3,1],[0,2],[1,2],[2,2],[3,2]]\n    print(findMinCost(points3)) # Output: 16.0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1585": "```\ndef canBeTransformed(s: str) -> bool:\n    last = [0] * 26\n    for i in range(len(s)):\n        diff = ord(s[i]) - ord('a')\n        if i > 0:\n            prev_diff = ord(s[i-1]) - ord('a')\n            if diff != prev_diff and diff < prev_diff:\n                return False\n        last[diff] = i\n    return True\n\ndef main():\n    print(canBeTransformed(\"abcd\")) # True\n    print(canBeTransformed(\"helloo\")) # False\n    print(canBeTransformed(\"aabbcc\")) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1586": "```\ndef flatten(head):\n    if not head:\n        return None\n    \n    stack = []\n    curr = head\n    prev = None\n    \n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        curr = stack.pop()\n        if prev and prev.val > curr.val:\n            node = TreeNode(prev.val, None, curr)\n            prev.left = node\n            curr.left = None\n        prev = curr\n        curr = curr.right\n    \n    return head\n\ndef inorder(head):\n    result = []\n    curr = head\n    stack = []\n    \n    while curr or stack:\n        while curr:\n            stack.append(curr)\n            curr = curr.left\n        curr = stack.pop()\n        result.append(curr.val)\n        curr = curr.right\n    \n    return result\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef main():\n    # Test case 1\n    head1 = TreeNode(5)\n    head1.left = TreeNode(3)\n    head1.right = TreeNode(6)\n    head1.left.left = TreeNode(2)\n    head1.left.right = TreeNode(4)\n    head1.right.left = TreeNode(7)\n\n    res1 = inorder(head1)\n    print(res1)  # Output: [2, 3, 4, 5, 6, 7]\n\n    # Test case 2\n    head2 = TreeNode(1)\n    head2.right = TreeNode(2)\n\n    res2 = inorder(head2)\n    print(res2)  # Output: [1, 2]\n\n    # Test case 3\n    head3 = TreeNode(10)\n    head3.left = TreeNode(5)\n    head3.right = TreeNode(15)\n    head3.left.left = TreeNode(3)\n    head3.left.right = TreeNode(8)\n\n    res3 = inorder(head3)\n    print(res3)  # Output: [3, 5, 8, 10, 15]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1587": "```\ndef getSummary(account_balances):\n    summary = {}\n    for account_id, balance in account_balances.items():\n        if balance < 0:\n            balance_type = \"Overdrawn\"\n        elif balance == 0:\n            balance_type = \"Closed\"\n        else:\n            balance_type = \"Positive\"\n        if account_id not in summary:\n            summary[account_id] = {}\n        summary[account_id][balance_type] = balance\n    return summary\n\ndef main():\n    test_cases = [\n        {\n            \"account_balances\": {\"1\": 100, \"2\": -50, \"3\": 0},\n            \"expected\": {\"1\": {\"Positive\": 100}, \"2\": {\"Overdrawn\": -50}, \"3\": {\"Closed\": 0}}\n        },\n        {\n            \"account_balances\": {\"1\": 200, \"2\": 300, \"3\": -100},\n            \"expected\": {\"1\": {\"Positive\": 200}, \"2\": {\"Positive\": 300}, \"3\": {\"Overdrawn\": -100}}\n        },\n        {\n            \"account_balances\": {\"1\": 0, \"2\": -50, \"3\": 0},\n            \"expected\": {\"1\": {\"Closed\": 0}, \"2\": {\"Overdrawn\": -50}, \"3\": {\"Closed\": 0}}\n        }\n    ]\n\n    for test_case in test_cases:\n        result = getSummary(test_case[\"account_balances\"])\n        print(f\"Test Case: {test_case['account_balances']}\")\n        print(\"Expected:\")\n        print(test_case[\"expected\"])\n        print(\"Actual:\")\n        print(result)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1588": "```\ndef sumOddLengthSubarrays(arr):\n    n = len(arr)\n    total_sum = 0\n    for k in range(1, n+1):\n        if k % 2 == 1:\n            total_sum += (n - k + 1) * (k // 2) * arr[0] + sum(arr[i+k//2-1] for i in range(k))\n    return total_sum\n\ndef main():\n    test_cases = [\n        ([1,4,2,5], 58),\n        ([1,14,10,7,6], 28),\n        ([10,11,12], 15)\n    ]\n    \n    for inputs, expected_output in test_cases:\n        result = sumOddLengthSubarrays(inputs)\n        if result == expected_output:\n            print(f\"Test case {inputs} passed.\")\n        else:\n            print(f\"Test case {inputs} failed. Expected output: {expected_output}, but got {result}.\")\n    \n    print(\"All tests have been executed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1589": "```\ndef maxSum(i):\n    n = len(i)\n    i.sort()\n    total_sum = sum(i)\n    max_sum = [i[0], i[-1]]\n    \n    for i in range(n-1):\n        if (i+1)*i % 2 == 0:\n            max_sum[0] += i\n            total_sum -= i\n        else:\n            max_sum[1] += i\n            total_sum -= i\n\n    return total_sum - min(max_sum)\n\ndef main():\n    test_cases = [[9, 2, 7, 3, 15], [5, 11, 4, 10, 6], [1, 2, 3, 4, 5]]\n    \n    for case in test_cases:\n        print(f\"Maximum Sum for {case} is: {maxSum(case)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1590": "```\ndef canMakeDivideSumEqual(target: int) -> bool:\n    n = len(target)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + target[i]\n    \n    seen = set()\n    for end in range(2, n + 1):\n        if prefix_sum[end] % target != 0:\n            continue\n        diff = prefix_sum[end] - (prefix_sum[end - 1] % target)\n        while diff > 0:\n            if diff not in seen:\n                return True\n            seen.add(diff)\n            diff -= target\n    \n    return False\n\ndef main():\n    print(canMakeDivideSumEqual([9,4,5,2,7,2])) #True\n    print(canMakeDivideSumEqual([4,4,10,3,4,6,8])) #True\n    print(canMakeDivideSumEqual([6,0,1])) #False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1591": "```\ndef strangePrinterII(T):\n    n = len(T)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        dp[i][i] = T[i - 1]\n    for length in range(2, n + 1):\n        for i in range(1, n - length + 2):\n            j = i + length - 1\n            if T[i - 1] == T[j]:\n                dp[i][j] = dp[i][i + length - 1]\n            else:\n                dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + 1\n    return dp[1][n]\n\n\ndef main():\n    print(strangePrinterII([\"123\"]))  # Output: 3\n    print(strangePrinterII([\"123456\"]))  # Output: 6\n    print(strangePrinterII([\"abc\", \"abcd\"]))  # Output: 4\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1593": "```\ndef maxUniqueSubstr(s):\n    n = len(s)\n    unique_substrs = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            substr = s[i:j]\n            if substr not in unique_substrs:\n                unique_substrs.add(substr)\n\n    return len(unique_substrs)\n\n\ndef main():\n    print(maxUniqueSubstr(\"aabab\"))  # Output: 2\n    print(maxUniqueSubstr(\"abcabc\"))  # Output: 3\n    print(maxUniqueSubstr(\"aaaaa\"))  # Output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1592": "```\ndef reorderSpaces(s: str) -> str:\n    n = s.count(' ')\n    if n == 0:\n        return s\n    words = s.split(' ')\n    if len(words) == 1:\n        return s + ' ' * (n - 1)\n    space_between_words = n // (len(words) - 1)\n    remaining_space = n % (len(words) - 1)\n    result = words[0]\n    for i in range(1, len(words)):\n        if i < len(words) - 1:\n            result += ' ' * space_between_words + words[i]\n        else:\n            result += ' ' * (space_between_words + remaining_space)\n    return result\n\ndef main():\n    test_cases = [\n        {\"input\": \"Hello   World\", \"expected_output\": \"Hello World\"},\n        {\"input\": \"a  b c  d\", \"expected_output\": \"a b c d\"},\n        {\"input\": \"a   \", \"expected_output\": \"a\"}\n    ]\n\n    for test_case in test_cases:\n        output = reorderSpaces(test_case[\"input\"])\n        if output == test_case[\"expected_output\"]:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed. Expected: {test_case['expected_output']}, got: {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1594": "```\ndef maxProductPath(grid):\n    n = len(grid)\n    m = len(grid[0])\n    dp = [[1] * m for _ in range(n)]\n    \n    total_product = 1\n    for i in range(n-1, -1, -1):\n        for j in range(m-1, -1, -1):\n            if grid[i][j] > 0:\n                if i < n-1 and grid[i+1][j] <= 0:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j]))\n                if j < m-1 and grid[i][j+1] <= 0:\n                    dp[i][j] *= min(dp[i][j+1], 1)\n            total_product *= grid[i][j]\n    \n    return 1 if total_product > 0 else -1\n\n\ndef main():\n    test_cases = [\n        [[2,3,-2,-4], [0,-5,-2,-1], [-2,-4,-3,-1]],\n        [[3,0,1],[0,0,2],[1,8,8]],\n        [[-1,-10,13},{-3,0,5},{-9,-7,6}],\n    ]\n\n    for test_case in test_cases:\n        result = maxProductPath(test_case)\n        print(f\"Test case: {test_case}\")\n        if result == 1:\n            print(\"Maximum non-negative product in the matrix is valid.\")\n        else:\n            print(\"Invalid maximum non-negative product in the matrix.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1595": "```\ndef minCostConnectPoints(points):\n    n = len(points)\n    edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            edges.append((abs(points[i][0]-points[j][0])+abs(points[i][1]-points[j][1]),i,j))\n    edges.sort()\n    parent = list(range(n))\n    rank = [0]*n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    def union(x,y):\n        root_x = find(x)\n        root_y = find(y)\n        if root_x == root_y:\n            return False\n        if rank[root_x] < rank[root_y]:\n            parent[root_x] = root_y\n        elif rank[root_x] > rank[root_y]:\n            parent[root_y] = root_x\n        else:\n            parent[root_y] = root_x\n            rank[root_x] += 1\n        return True\n    res = 0\n    for edge in edges:\n        if union(edge[1],edge[2]):\n            res += edge[0]\n    return res\n\ndef main():\n    test_cases = [\n        [[0,0],[2,2],[3,4],[1,2]],\n        [[-6,-10],[-2,8],[5,15],[14,5]],\n        [[0,0]]\n    ]\n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        result = minCostConnectPoints(test_case)\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1596": "```\ndef mostPopular(product_orders):\n    product_frequency = {}\n    customer_product_frequency = {}\n\n    for order in product_orders:\n        if order[1] not in product_frequency:\n            product_frequency[order[1]] = 0\n        product_frequency[order[1]] += 1\n        \n        if order[0] not in customer_product_frequency:\n            customer_product_frequency[order[0]] = {}\n        \n        if order[1] not in customer_product_frequency[order[0]]:\n            customer_product_frequency[order[0]][order[1]] = 0\n        customer_product_frequency[order[0]][order[1]] += 1\n\n    for customer, products in customer_product_frequency.items():\n        max_frequency = max(products.values())\n        popular_products = [product for product, frequency in products.items() if frequency == max_frequency]\n        print(f\"Most frequently ordered products for {customer}: {', '.join(popular_products)}\")\n\ndef main():\n    product_orders = [\n        [\"John\", \"Product A\"],\n        [\"Jane\", \"Product B\"],\n        [\"John\", \"Product C\"],\n        [\"John\", \"Product A\"],\n        [\"Jane\", \"Product D\"],\n        [\"Jane\", \"Product B\"]\n    ]\n\n    mostPopular(product_orders)\n\nif __name__ == \"__main__\":\n    main()\n\nprint(\"Test Case 1:\")\nproduct_orders = [\n    [\"Alice\", \"Apple\"],\n    [\"Bob\", \"Banana\"],\n    [\"Alice\", \"Apple\"],\n    [\"Charlie\", \"Cherry\"],\n    [\"Alice\", \"Apple\"],\n    [\"Bob\", \"Banana\"]\n]\nmostPopular(product_orders)\n\nprint(\"\\nTest Case 2:\")\nproduct_orders = [\n    [\"Eve\", \"Eggplant\"],\n    [\"Frank\", \"Fruit\"],\n    [\"Eve\", \"Eggplant\"],\n    [\"Gina\", \"Garlic\"],\n    [\"Eve\", \"Eggplant\"]\n]\nmostPopular(product_orders)\n\nprint(\"\\nTest Case 3:\")\nproduct_orders = [\n    [\"Hank\", \"Hamster\"],\n    [\"Ivy\", \"Ice Cream\"],\n    [\"Hank\", \"Hamster\"],\n    [\"Jen\", \"Jam\"],\n    [\"Hank\", \"Hamster\"]\n]\nmostPopular(product_orders)\n```",
  "1597": "```\ndef evaluateTree(root):\n    if root.val == 'T':\n        return evaluateTree(root.left) or evaluateTree(root.right)\n    elif root.val == '!':\n        return not evaluateTree(root.left)\n    else:\n        return root.val == '1'\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef buildTree(expression):\n    tree = None\n    stack = []\n    \n    for char in expression[::-1]:\n        if char == '(':\n            node = TreeNode(0)\n            stack.append((node, True))\n        elif char in ['T', '!']:\n            node = TreeNode(char)\n            if stack:\n                parent, isLeft = stack.pop()\n                parent.left = node\n                if not isLeft:\n                    parent.right = node\n            else:\n                tree = node\n        elif char == ')':\n            while stack and stack[-1][1]:\n                stack.pop()\n    \n    return tree\n\ndef main():\n    expression1 = \"T(F,T,u)\"\n    expression2 = \"!F(T,F,U)\"\n    expression3 = \"F!(T,T,F)\"\n\n    root1 = buildTree(expression1)\n    root2 = buildTree(expression2)\n    root3 = buildTree(expression3)\n\n    print(\"Expression 1:\", evaluateTree(root1))\n    print(\"Expression 2:\", evaluateTree(root2))\n    print(\"Expression 3:\", evaluateTree(root3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1598": "```\ndef minTimeToShuffle(string):\n    n = len(string)\n    lastseen = {}\n    for i, char in enumerate(string):\n        if char not in lastseen:\n            lastseen[char] = i\n        else:\n            lastseen[char] = i - lastseen[char]\n    return max(lastseen.values())\n\ndef main():\n    print(minTimeToShuffle(\"abc\"))  # Expected output: 3\n    print(minTimeToShuffle(\"woot\"))  # Expected output: 1\n    print(minTimeToShuffle(\"aaabbbccc\"))  # Expected output: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1599": "```\ndef maxProfit(hints):\n    n = len(hints)\n    lastOpen, lastClose = -1, -1\n    ans = 0\n    for i in range(n):\n        if hints[i][0] > lastOpen:\n            lastOpen = hints[i][0]\n        elif hints[i][0] < lastClose:\n            lastClose = hints[i][0]\n        else:\n            ans += lastClose - lastOpen\n            lastOpen, lastClose = hints[i][0], hints[i][1]\n    return ans\n\ndef main():\n    print(maxProfit([[10,15],[5,7],[4,9]])) # 6\n    print(maxProfit([[1,2],[3,4],[2,3]])) # 1\n    print(maxProfit([[8,10],[4,6],[6,8]])) # 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1600": "```\nclass ThroneInheritance:\n    def __init__(self, root: 'King') -> None:\n        self.king = root\n        self.mourning = {}\n\n    def getInheritanceOrder(self) -> List[str]:\n        order = []\n        self.dfs(self.king, True, order)\n        return order\n\n    def dfs(self, node, is_king, order):\n        if node not in self.mourning:\n            if is_king:\n                order.append(node.name)\n            for child in node.children:\n                self.dfs(child, False, order)\n\n    def broadcastWitchCauldron(self) -> None:\n        self.king.willDie()\n\nclass King:\n    def __init__(self, name: str):\n        self.name = name\n        self.children = []\n\n    def willDie(self):\n        pass\n\ndef main():\n    root = King(\"King\")\n    t = ThroneInheritance(root)\n    print(t.getInheritanceOrder())  # [\"King\"]\n\n    root1 = King(\"Patrick\")\n    king2 = King(\"Taylor\")\n    king3 = King(\"Riley\")\n    root1.children = [king2, king3]\n    t = ThroneInheritance(root1)\n    print(t.getInheritanceOrder())  # [\"Patrick\", \"Taylor\", \"Riley\"]\n\n    root2 = King(\"King\")\n    prince = King(\"Prince\")\n    prince2 = King(\"Prince2\")\n    root2.children = [prince, prince2]\n    t = ThroneInheritance(root2)\n    witch = Witch()\n    witch.broadcast(t)  # broadcast\n    print(t.getInheritanceOrder())  # [\"King\", \"Prince\", \"Prince2\"]\n\nclass Witch:\n    def __init__(self):\n        pass\n\n    def broadcast(self, t: 'ThroneInheritance') -> None:\n        t.king.willDie()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1601": "```\ndef maxTransfers(transfers):\n    transfers.sort(key=lambda x: (x[0], -x[1]))\n    res = [0] * len(transfers)\n    \n    def dfs(i, used, total):\n        if i == len(res):\n            return total\n        for j in range(len(transfers)):\n            if not used[j] and transfers[j][0] >= i:\n                new_used = used[:]; new_used[j] = True\n                res[i] += 1\n                total += dfs(i + 1, new_used, total)\n                res[i] -= 1\n        return total\n    \n    return dfs(0, [False] * len(transfers), 0)\n\ndef main():\n    print(maxTransfers([[0,3],[4,5]])) # Output: 2\n    print(maxTransfers([[0,2],[1,2],[2,3],[2,3]])) # Output: 3\n    print(maxTransfers([[0,2],[6,7]])) # Output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1602": "```\ndef rightSideView(root):\n    if not root:\n        return []\n\n    result = []\n    queue = [root]\n\n    while queue:\n        level = []\n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            level.append(node.val)\n\n            if node.right:\n                queue.append(node.right)\n            if node.left:\n                queue.append(node.left)\n        result.append(level[-1])\n\n    return result\n\ndef main():\n    # Test case 1\n    root1 = TreeNode(1)\n    root1.left = TreeNode(2)\n    root1.right = TreeNode(3)\n    root1.right.right = TreeNode(5)\n    print(rightSideView(root1))  # Output: [1, 3, 5]\n\n    # Test case 2\n    root2 = TreeNode(1)\n    root2.right = TreeNode(2)\n    print(rightSideView(root2))  # Output: [1, 2]\n\n    # Test case 3\n    root3 = TreeNode(1)\n    root3.left = TreeNode(2)\n    root3.right = TreeNode(3)\n    print(rightSideView(root3))  # Output: [1, 3]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1603": "```\nclass ParkingSystem:\n    def __init__(self, big: int, medium: int, small: int):\n        self.big = [0] + [big]\n        self.medium = [0] + [medium]\n        self.small = [0] + [small]\n\n    def addCar(self, carType: int) -> bool:\n        if carType == 1 and self.big[1] > 0:\n            self.big[1] -= 1\n            return True\n        elif carType == 2 and self.medium[1] > 0:\n            self.medium[1] -= 1\n            return True\n        elif carType == 3 and self.small[1] > 0:\n            self.small[1] -= 1\n            return True\n        else:\n            return False\n\ndef main():\n    parking = ParkingSystem(1, 2, 4)\n    \n    print(parking.addCar(1)) # Expected: True\n    print(parking.addCar(2)) # Expected: True\n    print(parking.addCar(3)) # Expected: True\n    print(parking.addCar(5)) # Expected: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1604": "```\ndef alert(keylog):\n    log = {}\n    for key in keylog:\n        if key[1] not in log:\n            log[key[1]] = [key[0]]\n        else:\n            log[key[1]].append(key[0])\n    res = []\n    for k, v in log.items():\n        if len(v) >= 3:\n            res.append(k)\n    return \" \".join(res)\n\ndef main():\n    print(alert([\"leetcode\", \"working\", \"leetcode\", \"leet\", \"leetcode\", \"csharp\", \"leetcode\"]))\n    print(alert([\"hxxg\", \"hxxg\", \"hxxg\", \"hxxg\", \"oxxg\", \"oxxg\", \"oxxg\", \"oxxg\", \"oxxg\", \"oxxg\", \"oxxg\"]))\n    print(alert([\"ziy\",\"ziy\",\"ziy\",\"ziy\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1605": "```\ndef makeGridSumEqual(rowSums, colSums):\n    m, n = len(rowSums), len(colSums)\n    grid = [[0]*n for _ in range(m)]\n    \n    row, col = 0, 0\n    for val in sorted([x for pair in zip(rowSums, colSums) for x in pair]):\n        if row < m:\n            for _ in range(n):\n                if col < n and grid[row][col] + 1 == val:\n                    col += 1\n                    break\n                elif not (row < m and col < n):\n                    return False\n                grid[row][col] = val\n                col += 1\n        else:\n            for _ in range(m):\n                if row < m and grid[row][col-1] + 1 == val:\n                    row += 1\n                    break\n                elif not (row < m and col > 0):\n                    return False\n                grid[row][col-1] = val\n                row += 1\n        \n    for i in range(m):\n        if sum(grid[i]) != rowSums[i]:\n            return False\n    \n    for j in range(n):\n        if sum([grid[i][j] for i in range(m)]) != colSums[j]:\n            return False\n    return grid\n\ndef main():\n    print(makeGridSumEqual([3, 3], [3, 1]))\n    print(makeGridSumEqual([2, 4, 6], [5, 5, 5]))\n    print(makeGridSumEqual([10, 10, 10, 10], [3, 3, 3, 1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1606": "```\ndef highestRated(Employees):\n    employees = [[1, 3], [0, 0], [2, 5]]\n    requestTime = [[1, 1], [2, 0], [1, 4]]\n\n    if not Employees:\n        return []\n\n    from collections import defaultdict\n    rated = defaultdict(int)\n    for i in range(len(Employees)):\n        start, end = map(int, requestTime[i])\n        for j in range(start, end + 1):\n            rated[j] += 1\n\n    return sorted([(e, r) for e, r in rated.items()], reverse=True)\n\ndef main():\n    print(highestRated([]))\n    print(highestRated([1]))\n    print(highestRated([0,2]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1607": "```\ndef lowCreditCustomers(customers):\n    return [customer[0] for customer in customers if not customer[1]]\n\ndef main():\n    print(lowCreditCustomers([[\"John\", True], [\"Emily\", False]])) # Test case 1: No low credit\n    print(lowCreditCustomers([[\"Michael\", False], [\"Sarah\", True]])) # Test case 2: Some low credit\n    print(lowCreditCustomers([[\"Jen\", True], [\"Tom\", True], [\"Liz\", False]])) # Test case 3: All low credit\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1608": "```\ndef specialArray(nums):\n    nums.sort(reverse=True)\n    for i in range(len(nums)):\n        if len([x for x in nums[:i+1] if x >= nums[i]]) == i + 1:\n            return i + 1\n    return -1\n\n\ndef main():\n    print(specialArray([2,2,2,4])) # Test case 1: Expected output is 3\n    print(specialArray([0,4,5,6])) # Test case 2: Expected output is 3\n    print(specialArray([5,4,3,2,1,0])) # Test case 3: Expected output is -1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1609": "```\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isEvenOddTree(root: TreeNode) -> bool:\n    if not root:\n        return True\n    \n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        for _ in range(level_size):\n            node = queue.popleft()\n            \n            if (node.val % 2 == 0 or node.val < 1) and (node.left and node.left.val % 2 != 0 and node.left.val >= 1) or (node.right and node.right.val % 2 != 0 and node.right.val >= 1):\n                return False\n            \n            if node.left:\n                queue.append(node.left)\n            \n            if node.right:\n                queue.append(node.right)\n    \n    return True\n\ndef main():\n    root = TreeNode(5)\n    root.left = TreeNode(3)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(0)\n    root.left.right = TreeNode(2)\n    root.right.right = TreeNode(4)\n\n    print(isEvenOddTree(root))  # Expected: True\n\n    root = TreeNode(7)\n    root.left = TreeNode(5)\n    root.right = TreeNode(6)\n    root.left.left = TreeNode(3)\n    root.left.right = TreeNode(4)\n    root.right.left = TreeNode(2)\n    root.right.right = TreeNode(1)\n\n    print(isEvenOddTree(root))  # Expected: False\n\n    root = TreeNode(0, left=TreeNode(0), right=TreeNode(1))\n\n    print(isEvenOddTree(root))  # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1610": "```\ndef visiblePoints(arrays):\n    res = 0\n    stack = []\n    \n    for array in arrays:\n        newStack = []\n        for i in range(len(array)):\n            while len(stack) > 0 and array[i] >= stack[-1]:\n                stack.pop()\n            if len(newStack) == 0 or array[i] <= newStack[-1]:\n                newStack.append(array[i])\n        res += len(newStack)\n        stack = newStack\n    return res\n\n\ndef main():\n    test_cases = [\n        ([[2,3], [1,3], [5,4]], 3),\n        ([[7,10], [4,10], [6,8], [9,10]], 4),\n        ([[1,2], [2,3], [3,4], [4,5]], 3)\n    ]\n    \n    for test_case in test_cases:\n        arrays = test_case[0]\n        expected_output = test_case[1]\n        output = visiblePoints(arrays)\n        \n        if output == expected_output:\n            print(f\"Test case {test_case} passed\")\n        else:\n            print(f\"Test case {test_case} failed. Expected {expected_output}, but got {output}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1611": "```\ndef minFlips(nums):\n    n = len(nums)\n    total_flips = [float('inf')] * (n + 1)\n    total_flips[0] = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            total_flips[j] = min(total_flips[j], total_flips[i] + bin(nums[i]^nums[j-1]).count('1'))\n    return total_flips[-1]\n\ndef main():\n    print(minFlips([0])) # Test case 1\n    print(minFlips([1,1])) # Test case 2\n    print(minFlips([3,6,7,2])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1612": "```\ndef parseTree(s):\n    if not s:\n        return None\n    stack = []\n    root = TreeNode(0)\n    curr = root\n    for c in s + '#':\n        if c == '(':\n            t = TreeNode(int(c))\n            curr.left = t\n            stack.append(t)\n            curr = t\n        elif c == ')':\n            curr = stack.pop()\n        else:\n            curr.val = int(c)\n    return root\n\ndef evalTree(root):\n    if not root:\n        return 0\n    return root.val + (evalTree(root.left) * evalTree(root.right))\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef isEquivalent(t1, t2):\n    if not t1 and not t2:\n        return True\n    if not (t1 and t2):\n        return False\n    if t1.val != t2.val:\n        return False\n    return evalTree(t1) == evalTree(t2)\n\ndef main():\n    test_case1 = \"root=5,left=2,right=8\"\n    tree1 = parseTree(test_case1)\n    test_case2 = \"root=4,left=2,right=3\"\n    tree2 = parseTree(test_case2)\n    print(isEquivalent(tree1, tree2))  # Output: True\n\n    test_case3 = \"root=10,left=5,right=10\"\n    tree3 = parseTree(test_case3)\n    test_case4 = \"root=10,left=5,right=10\"\n    tree4 = parseTree(test_case4)\n    print(isEquivalent(tree3, tree4))  # Output: True\n\n    test_case5 = \"root=8,left=-1,right=8\"\n    tree5 = parseTree(test_case5)\n    test_case6 = \"root=9,left=-1,right=19\"\n    tree6 = parseTree(test_case6)\n    print(isEquivalent(tree5, tree6))  # Output: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1613": "```\ndef missing_ids(ids):\n    expected_ids = [i for i in range(min(ids), max(ids) + 1)]\n    return list(set(expected_ids) - set(ids))\n\ndef main():\n    print(missing_ids([1,2,4,6])) # Expected output: [3,5]\n    print(missing_ids([1,2,3,4,7,8,9,10,11,12])) # Expected output: []\n    print(missing_ids([1,2,3,5,6,8,9,10,15,20])) # Expected output: [4,7,13,14]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1614": "```\ndef maxDepth(s):\n    depth = 0\n    max_depth = 0\n    for c in s:\n        if c == '(':\n            depth += 1\n            max_depth = max(max_depth, depth)\n        elif c == ')':\n            depth -= 1\n    return max_depth\n\ndef main():\n    test_cases = [\n        {\"input\": \"1 +  (2 - 3) \", \"expected_output\": 3},\n        {\"input\": \"(( ))\", \"expected_output\": 4},\n        {\"input\": \"a + (b)\", \"expected_output\": 2}\n    ]\n\n    for test_case in test_cases:\n        input_str = test_case[\"input\"]\n        expected_output = test_case[\"expected_output\"]\n        output = maxDepth(input_str)\n        print(f\"Test case: {input_str}, Expected Output: {expected_output}, Actual Output: {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1616": "```\ndef canBePalindrome(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    i = j = 0\n    while i < len(s1) and j < len(s2):\n        if s1[i] == s2[j]:\n            i += 1\n            j += 1\n        elif s1[i] < s2[j]:\n            return False\n        else:\n            j -= 1\n    return True\n\ndef main():\n    print(canBePalindrome(\"aab\", \"cd\")) # False\n    print(canBePalindrome(\"aba\", \"bab\")) # True\n    print(canBePalindrome(\"x\", \"y\")) # False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1615": "```\ndef maximalNetworkRank(n, roads):\n    graph = [[] for _ in range(n)]\n    for road in roads:\n        graph[road[0]].append(road[1])\n        graph[road[1]].append(road[0])\n    visited = [False] * n\n    rank = 0\n    for i in range(n):\n        if not visited[i]:\n            stack = [(i, 1)]\n            while stack:\n                node, depth = stack.pop()\n                if not visited[node]:\n                    visited[node] = True\n                    rank = max(rank, depth)\n                    for neighbor in graph[node]:\n                        if not visited[neighbor]:\n                            stack.append((neighbor, depth + 1))\n    return rank\n\ndef main():\n    test_cases = [\n        # Test case 1:\n        (5, [[0, 1], [1, 2], [2, 3]]), \n        # Test case 2:\n        (8, [[0, 1], [1, 2], [2, 4], [3, 4], [5, 6], [6, 7]]), \n        # Test case 3:\n        (15, [[0, 1], [0, 2], [1, 2], [1, 3], [2, 3], [3, 4], [3, 14], [4, 5], [5, 6], [6, 7], [7, 8], [7, 9], [8, 9]]),\n    ]\n\n    for test_case in test_cases:\n        n, roads = test_case\n        result = maximalNetworkRank(n, roads)\n        print(f\"Maximal network rank for {n} nodes and {roads} roads is {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1617": "```\ndef maxDistance(root):\n    if not root:\n        return 0\n    \n    res = 0\n    def dfs(node):\n        nonlocal res\n        if node:\n            l, r = dfs(node.left), dfs(node.right)\n            res = max(res, (l + r) // 2 if l % 2 == r % 2 else min(l, r))\n            return l | r\n    \n    dfs(root)\n    return res\n\ndef main():\n    root1 = [1,2,null,null,null]\n    print(maxDistance(TreeNode.fromList(root1))) # 3\n\n    root2 = [1,2,3,4,4,7,null,null,null,null,-18,null,null,null,null,20,null,null]\n    print(maxDistance(TreeNode.fromList(root2))) # 2\n\n    root3 = []\n    print(maxDistance(None)) # 0\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\n    @classmethod\n    def fromList(cls, nodes):\n        if not nodes:\n            return None\n        root = cls(nodes[0])\n        node_list = [root]\n        for val in nodes[1:]:\n            if val is None:\n                continue\n            parent = node_list.pop(0)\n            if parent.val > val:\n                parent.left = cls(val)\n                node_list.append(parent.left)\n            else:\n                parent.right = cls(val)\n                node_list.append(parent.right)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1618": "```\ndef maxFontSize(s, w):\n    left, right = 0, int(1e9)\n    res = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if len(getWrapText(s, mid)) > w:\n            left = mid + 1\n        else:\n            right = mid - 1\n            res = mid\n    return res\n\ndef getWrapText(s, n):\n    return [s[i:i+n] for i in range(0, len(s), n)]\n\ndef main():\n    print(maxFontSize(\"input\", 6)) # test case 1\n    print(maxFontSize(\"This is a test.\", 10)) # test case 2\n    print(maxFontSize(\"Lorem ipsum dolor sit amet.\", 15)) # test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1619": "```\ndef average(inputArray):\n    sortedArr = sorted((x for x in inputArray))\n    return sum(sortedArr[len(sortedArr)//2:]) / len(sortedArr)//2\n\n\ndef main():\n    print(\"Test Case 1:\")\n    print(average([2,3,1,4])) # Expected: 3.0\n\n    print(\"\\nTest Case 2:\")\n    print(average([-1,-5,-7,-8])) # Expected: -4.5\n\n    print(\"\\nTest Case 3:\")\n    print(average([0,6,6,6,6])) # Expected: 6.0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1620": "```\ndef maxQuality(places):\n    n = len(places)\n    result = []\n    for i in range(n):\n        quality_sum = sum([p[1] * p[2] if p[0] == j else 0 for j, p in enumerate(places)])\n        result.append((quality_sum, i))\n    return max(result)[1]\n\ndef main():\n    test_cases = [\n        [[2, 6, 5], [3, 8, 12], [15, 3, 25]],\n        [[10, 20, 30], [30, 40, 50], [20, 60, 40]],\n        [[1, 1, 1], [2, 4, 5], [3, 9, 8]]\n    ]\n    \n    for test_case in test_cases:\n        print(\"For places: \", test_case)\n        print(\"The coordinate with maximum network quality is: \", maxQuality(test_case))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1621": "```\ndef maxLineSegs(n, k):\n    dp = [0] * (k + 1)\n    for i in range(1, min(k + 1, n) + 1):\n        for j in range(min(i, k), -1, -1):\n            dp[j] += dp[j-1]\n    return dp[-1]\n\ndef main():\n    print(maxLineSegs(4, 2)) \n    print(maxLineSegs(10, 3))\n    print(maxLineSegs(100, 50))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1622": "```\ndef getFancySum(n):\n    MOD = int(1e9) + 7\n    pref_sum = [0] * (n+1)\n    for i in range(1, n+1):\n        pref_sum[i] = (pref_sum[i-1] if i > 1 else 0) + i % 2\n\n    def query(l, r):\n        return (pref_sum[r] - pref_sum[l-1]) % MOD if l <= r else 0\n\n    def update(i, val):\n        prev_val = pref_sum[i]\n        pref_sum[i] = (pref_sum[i] + val) % MOD\n        for i in range(i+1, n+1):\n            pref_sum[i] = (pref_sum[i] + prev_val % MOD) % MOD\n\n    def fancySum(l, r):\n        return query(r) - query(l-1)\n\n    return fancySum\n\ndef main():\n    print(getFancySum(10)(5, 8))\n    print(getFancySum(5)(1, 3))\n    print(getFancySum(7)(2, 6))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1623": "```\ndef countGoodTriplets(root):\n    def dfs(node):\n        if not node:\n            return 0\n        res = [0]\n        dfs_helper(node, [0], res)\n        return res[0]\n\n    def dfs_helper(node, path, res):\n        if not node:\n            return\n        val = int(node.val)\n        if all(abs(val - p) <= 1 for p in path):\n            res[0] += 1\n        dfs_helper(node.left, [val], res)\n        dfs_helper(node.right, [val], res)\n\n    count = dfs(root)\n    return list(count for count in count)\n\ndef main():\n    # Test case 1:\n    root1 = TreeNode(3)\n    root1.left = TreeNode(4)\n    root1.right = TreeNode(6)\n    root1.left.left = TreeNode(2)\n    root1.left.right = TreeNode(5)\n    print(countGoodTriplets(root1))  # [1,0]\n\n    # Test case 2:\n    root2 = TreeNode(2)\n    root2.left = TreeNode(1)\n    root2.right = TreeNode(3)\n    print(countGoodTriplets(root2))  # []\n\n    # Test case 3:\n    root3 = TreeNode(5)\n    root3.left = TreeNode(4)\n    root3.right = TreeNode(6)\n    root3.left.left = TreeNode(2)\n    root3.left.right = TreeNode(1)\n    print(countGoodTriplets(root3))  # [2,0]\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1624": "```\ndef maxStrLenBetweenEqualChars(s):\n    char_index = {}\n    max_len = 0\n    for i, c in enumerate(s):\n        if c not in char_index:\n            char_index[c] = i\n        else:\n            max_len = max(max_len, i - char_index[c])\n            char_index[c] = i\n    return max_len\n\ndef main():\n    print(\"Test case 1:\")\n    print(maxStrLenBetweenEqualChars(\"abrac\")) # Expected output: 3\n    \n    print(\"\\nTest case 2:\")\n    print(maxStrLenBetweenEqualChars(\"bar\")) # Expected output: 0\n    \n    print(\"\\nTest case 3:\")\n    print(maxStrLenBetweenEqualChars(\"aa\")) # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1625": "```\ndef lexicalOrderAfterOperations ops:\n    ops.sort()\n    res = []\n    i = 0\n    while i < len(ops):\n        if ops[i][0] == '1':\n            res.append('0' + str(int(ops[i][1:]) + 1))\n        else:\n            res.append(ops[i])\n        i += 1\n\n    return ''.join(res)\n\ndef main():\n    print(lexicalOrderAfterOperations([\"1\", \"0\"]))\n\n    print(lexicalOrderAfterOperations([\"10\", \"11\", \"00\"]))\n\n    print(lexicalOrderAfterOperations([\"100\", \"101\", \"110\", \"111\", \"000\", \"001\", \"010\", \"011\", \"100\"]))",
  "1626": "```\ndef maximumInvitations(students):\n    n = len(students)\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if students[j] not in [students[k] for k in range(n) if pairs[k][0] == students[i]]:\n                pairs.append([i, j])\n    return max(len(pairs), len(set([pair[1] for pair in pairs])))\n\n\ndef main():\n    print(maximumInvitations([\"Leslie\",\"Victor\",\"Harry\",\"Peter\"]) ) # Test case 1\n    print(maximumInvitations([\"Sheldon\",\"Tareq\",\"Kimberly\",\"Victoria\",\"Jerry\"]) ) # Test case 2\n    print(maximumInvitations([\"John\",\"Mery\",\"Alex\",\"Jina\"]) ) # Test case 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1627": "```\ndef numConnected(components, threshold):\n    parent = list(range(len(components)))\n    rank = [0] * len(components)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX == rootY:\n            return\n        if rank[rootX] > rank[rootY]:\n            parent[rootY] = rootX\n        else:\n            parent[rootX] = rootY\n            if rank[rootX] == rank[rootY]:\n                rank[rootY] += 1\n\n    for i in range(len(components)):\n        for j in range(i+1, len(components)):\n            if abs(components[i]-components[j]) <= threshold:\n                union(i, j)\n\n    connectedSets = set()\n    for i in range(len(parent)):\n        connectedSets.add(find(i))\n\n    return len(connectedSets)\n\n\ndef main():\n    print(numConnected([2, 3, 4, 1], 18) == 2)\n    print(numConnected([5, 6], 10) == 1)\n    print(numConnected([7, 8, 9, 10], 20) == 1)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1628": "```\nclass ExpressionTree:\n    class Node:\n        def __init__(self, val):\n            self.val = val\n            self.left = None\n            self.right = None\n\n    def __init__(self):\n        self.root = None\n\n    def evaluate(self, node):\n        if not node:\n            return 0\n        if isinstance(node.val, int):\n            return node.val\n        if node.val == '+':\n            return self.evaluate(node.left) + self.evaluate(node.right)\n        if node.val == '-':\n            return self.evaluate(node.left) - self.evaluate(node.right)\n        if node.val == '*':\n            return self.evaluate(node.left) * self.evaluate(node.right)\n\n    def deserialize(self, expression):\n        nodes = {}\n        for i, char in enumerate(expression + '+'):\n            if char.isnumeric():\n                nodes[i] = Node(int(char))\n            elif char in ['+', '-', '*']:\n                left = self.deserialize(expression[:i])\n                right = self.deserialize(expression[i+1:])\n                node = Node(char)\n                node.left = left\n                node.right = right\n                return node\n        return None\n\n    def serialize(self, node):\n        if not node:\n            return '0'\n        if isinstance(node.val, int):\n            return str(node.val)\n        if node.val == '+':\n            return f'({self.serialize(node.left)}+{self.serialize(node.right)})'\n        if node.val == '-':\n            return f'({self.serialize(node.left)}-{self.serialize(node.right)})'\n        if node.val == '*':\n            return f'({self.serialize(node.left)}*{self_serialize(node.right)})'\n\n    def main(self):\n        tree = ExpressionTree()\n\n        # Test Case 1\n        expression = \"2+3*4\"\n        root = tree.deserialize(expression)\n        print(f\"Expression Tree for {expression}: {tree.serialize(root)}\")\n        print(f\"Evaluate: {tree.evaluate(root)}\")\n\n        # Test Case 2\n        expression = \"5-7*3+6\"\n        root = tree.deserialize(expression)\n        print(f\"Expression Tree for {expression}: {tree.serialize(root)}\")\n        print(f\"Evaluate: {tree.evaluate(root)}\")\n\n        # Test Case 3\n        expression = \"3+4*2-1\"\n        root = tree.deserialize(expression)\n        print(f\"Expression Tree for {expression}: {tree.serialize(root)}\")\n        print(f\"Evaluate: {tree.evaluate(root)}\")\n\n\nif __name__ == \"__main__\":\n    ExpressionTree().main()\n```",
  "1629": "```\ndef slowest_key(row_keys):\n    slowest = row_keys[0]\n    for key in row_keys:\n        if ord(key) > ord(slowest):\n            slowest = key\n    return slowest\n\n\ndef main():\n    print(\"Test Case 1: \")\n    print(slowest_key([\"a\", \"a\", \"b\", \"c\", \"d\", \"e\"]))  # Expected output: 'e'\n\n    print(\"\\nTest Case 2: \")\n    print(slowest_key([\"b\", \"c\", \"b\"]) )  # Expected output: 'c'\n\n    print(\"\\nTest Case 3: \")\n    print(slowest_key([1, 3, 10, 6, 7, 6, 4, 7, 8, 13]) )  # Expected output: '13'\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1630": "```\ndef numArithmeticSlices(nums):\n    n = len(nums)\n    dp = [0] * (n + 1)\n    res = 0\n    for i in range(2, n):\n        if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n            dp[i] = dp[i-1] + 1\n        else:\n            dp[i] = 0\n        res += dp[i]\n    return res\n\ndef main():\n    print(numArithmeticSlices([2,4,6])) # test case 1\n    print(numArithmeticSlices([0,2,3,4,6])) # test case 2\n    print(numArithmeticSlices([1,2,3,8,8,10])) # test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1631": "```\ndef minimumEffortSearch(heights):\n    n = len(heights)\n    efforts = [[0] * (n + 1) for _ in range(n + 1)]\n    efforts[0][0] = heights[0]\n\n    for gap in range(1, n):\n        min_effort = float('inf')\n        for i in range(gap, 0, -1):\n            min_effort = min(min_effort, max(efforts[i - 1][j] + abs(heights[j] - heights[j + gap]) for j in range(n - gap)))\n            efforts[i][gap] = min_effort\n    return min(efforts[-1])\n\ndef main():\n    test_cases = [\n        ([49, 49, 33], 6), \n        ([1, 2, 3, 4, 5, 1, 2, 3, 3], 6), \n        ([20, 15, 10], 15)\n    ]\n\n    for heights, expected in test_cases:\n        result = minimumEffortSearch(heights)\n        if result == expected:\n            print(f\"Test case passed: {heights} -> {result}\")\n        else:\n            print(f\"Test case failed: {heights} expected {expected}, got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1632": "```\ndef rankTransforms(matrix):\n    m, n = len(matrix), len(matrix[0])\n    res = [[1] * n for _ in range(m)]\n    uf = {}\n    \n    def dfs(i, j):\n        if (i, j) not in uf:\n            uf[(i, j)] = 1\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    res[x][y] = res[i][j]\n                    dfs(x, y)\n    \n    for i in range(m):\n        for j in range(n):\n            dfs(i, j)\n    \n    return res\n\n\ndef main():\n    print(rankTransforms([[1, 5], [2, 3], [5, 5]]))\n    print(rankTransforms([[1, 2], [1, 3]]))\n    print(rankTransforms([[20]]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1633": "```\ndef numOfUsersAttendedContest(users):\n    attendance = {}\n    for user in users:\n        if user[1] == \"contested\":\n            attendance[user[0]] = attendance.get(user[0], 0) + 1\n    return len(attendance)\n\ndef main():\n    test_cases = [\n        {\"users\": [[\"A\", \"contested\"], [\"B\", \"not_contested\"]], \"expected_output\": 1},\n        {\"users\": [[\"C\", \"contested\"], [\"D\", \"contested\"], [\"E\", \"not_contested\"]], \"expected_output\": 2},\n        {\"users\": [[\"F\", \"contested\"], [\"G\", \"contested\"], [\"H\", \"contested\"], [\"I\", \"not_contested\"]], \"expected_output\": 3}\n    ]\n\n    for test_case in test_cases:\n        actual_output = numOfUsersAttendedContest(test_case[\"users\"])\n        if actual_output == test_case[\"expected_output\"]:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed. Expected output: {test_case['expected_output']}, but got {actual_output}.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1635": "```\ndef sumOfDistancesInArray(arr):\n    n = len(arr)\n    total_sum = sum(arr)\n    left_sum = [0] * n\n    right_sum = [0] * n\n\n    left_sum[0] = arr[0]\n    for i in range(1, n):\n        left_sum[i] = left_sum[i-1] + arr[i]\n\n    right_sum[n-1] = arr[-1]\n    for i in range(n-2, -1, -1):\n        right_sum[i] = right_sum[i+1] + arr[i]\n\n    return [right_sum[0]] + [(left_sum[i] + right_sum[i]) - arr[i] for i in range(1, n-1)] + [total_sum - left_sum[-1]]\n\ndef main():\n    print(sumOfDistancesInArray([23, 47, 49])) # Output: [21, 22, 22]\n    print(sumOfDistancesInArray([-4, -3, -2, -1, 0, 1, 2, 5])) # Output: [-10, -7, -4, -1, 0, 2, 6, 8]\n    print(sumOfDistancesInArray([0, 0])) # Output: [0, 0]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1634": "```\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\ndef addLinkedLists(l1: ListNode, l2: ListNode) -> ListNode:\n    dummyHead = ListNode(0)\n    current = dummyHead\n    carry = 0\n    \n    while l1 or l2 or carry:\n        x = l1.val if l1 else 0\n        y = l2.val if l2 else 0\n        sum = carry + x + y\n        carry = sum // 10\n        current.next = ListNode(sum % 10)\n        current = current.next\n        \n        l1 = l1.next if l1 else None\n        l2 = l2.next if l2 else None\n    \n    return dummyHead.next\n\ndef printList(listNode: ListNode):\n    while listNode:\n        print(listNode.val, end=\" \")\n        listNode = listNode.next\n    print()\n\ndef main():\n    # Test case 1\n    l1 = ListNode(1)\n    l1.next = ListNode(2)\n    l1.next.next = ListNode(3)\n    l2 = ListNode(4)\n    l2.next = ListNode(5)\n    result = addLinkedLists(l1, l2)\n    print(\"Test case 1: \")\n    printList(result)\n\n    # Test case 2\n    l1 = ListNode(-1)\n    l1.next = ListNode(0)\n    l1.next.next = ListNode(1)\n    l2 = ListNode(-5)\n    l2.next = ListNode(-4)\n    result = addLinkedLists(l1, l2)\n    print(\"Test case 2: \")\n    printList(result)\n\n    # Test case 3\n    l1 = None\n    l2 = ListNode(0)\n    l2.next = ListNode(5)\n    result = addLinkedLists(l1, l2)\n    print(\"Test case 3: \")\n    printList(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1636": "```\ndef frequencySort(nums):\n    from collections import Counter\n    count = Counter(nums)\n    sorted_nums = sorted((val, key) for key, val in count.items())\n    res = []\n    i = 0\n    while i < len(sorted_nums):\n        count_val = sorted_nums[i][1]\n        count_num = 1\n        while i + 1 < len(sorted_nums) and sorted_nums[i][1] == sorted_nums[i+1][1]:\n            count_num += 1\n            i += 1\n        res.extend([k for _ in range(count_val)] * count_num)\n    return res\n\ndef main():\n    print(frequencySort([2,3,1,3,2])) # Output: [1, 3, 2, 2]\n    print(frequencySort([0,1]) # Output: [0, 1]\n    print(frequencySort([5,8,7]) # Output: [5, 7, 8]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1638": "```\ndef countSubstrings(s):\n    n = len(s)\n    res = 0\n    \n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            sub_str = s[i:j]\n            diff_count = 0\n            prev_char = s[i - 1] if i > 0 else None\n            \n            for k in range(len(sub_str)):\n                if sub_str[k] != s[k]:\n                    diff_count += 1\n                \n                if k < len(sub_str) - 1 and (sub_str[k + 1] != s[k + 1] or prev_char is not None):\n                    break\n                prev_char = sub_str[k]\n            \n            res += diff_count\n\n    return res\n\n\ndef main():\n    print(countSubstrings(\"abc\"))  # Expected: 3\n    print(countSubstrings(\"abca\"))  # Expected: 4\n    print(countSubstrings(\"abcba\"))  # Expected: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1637": "```\ndef max_width(arr):\n    stack = []\n    max_width = 0\n    for point in arr:\n        while len(stack) > 1 and stack[-1][1] < point[1]:\n            prev_point = stack.pop()\n            width = point[0] - prev_point[0]\n            max_width = max(max_width, width)\n        if len(stack) == 1 or point[1] != stack[-1][1]:\n            stack.append(point)\n    return max_width\n\ndef main():\n    print(\"Test case 1: \")\n    arr1 = [(8,9),(3,0),(6,8),(2,7),(5,4)}\n    print(max_width(arr1)) # Expected output: 6\n\n    print(\"\\nTest case 2: \")\n    arr2 = [(3,1),(9,0),(4,8),(6,2),(1,3)]\n    print(max_width(arr2)) # Expected output: 7\n\n    print(\"\\nTest case 3: \")\n    arr3 = [(10,5),(11,5),(12,7])\n    print(max_width(arr3)) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1639": "```\ndef numWays(words, target):\n    n = len(words)\n    dp = [0] * (len(target) + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(len(target)):\n            if j > 0 and target[j] == words[i][j]:\n                dp[j+1] += dp[j]\n            elif target[j] == words[i][j]:\n                dp[j+1] = dp[j] + 1\n    return dp[-1]\n\ndef main():\n    print(numWays([\"w\",\"wo\",\"wor\"], \"woo\")) # Output: 2\n    print(numWays([\"a\",\"b\",\"c\",\"ab\",\"bc\",\"acb\"], \"aaa\")) # Output: 1\n    print(numWays([\"a\",\"ab\",\"abc\"], \"aaa\")) # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1640": "```\ndef checkFormation(arrays):\n    res = []\n    for array in arrays:\n        if not array:\n            continue\n        if len(set(array)) != len(array) or any(ord(c1) - ord(c2) > 1 for c1, c2 in zip(array, array[1:])):\n            return False\n    return True\n\ndef main():\n    test_cases = [\n        [[5150], [5100, 6100, 7100, 11110]],\n        [[1, 3], [3, 6], [5, 7], [12]],\n        [[false]]\n    ]\n    \n    for case in test_cases:\n        print(\"Test Case: \", case)\n        result = checkFormation(case[1:])\n        if result:\n            print(\"Pass\")\n        else:\n            print(\"Fail\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1641": "```\ndef countVowelStrings(n):\n    dp = [[1] * (n + 1) for _ in range(5)]\n    for i in range(1, n + 1):\n        dp[0][i] = 0\n        for j in range(1, 5):\n            dp[j][i] = dp[j][i - 1] + dp[j - 1][i]\n    return sum(dp[i][-1] for i in range(3))\n\ndef main():\n    print(countVowelStrings(1) == 1)\n    print(countVowelStrings(2) == 10)\n    print(countVowelStrings(5) == 660)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1642": "```\ndef maxVowels(word):\n    vowels = \"aeiouAEIOU\"\n    return sum(1 for char in word if char in vowels)\n\ndef maxBuilding(n, h):\n    buildings = [0] * (n + 1)\n    for i in range(1, n):\n        if i % 2 == 0:\n            buildings[i] = min(buildings[i-1], h - i // 2)\n        else:\n            buildings[i] = maxVowels(str(i))//2\n    return buildings[n-1]\n\ndef main():\n    print(maxBuilding(8, [4,2,7,6,1,5,0,7,3,0]))\n    print(maxBuilding(4, [11,81,4,44]))\n    print(maxBuilding(1, [1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1643": "```\ndef findKthSmallest(instructionList, K):\n    dp = [[0 for _ in range(K + 1)] for _ in range(len(instructionList) + 1)]\n    \n    for i in range(1, len(instructionList) + 1):\n        for j in range(1, min(i, K) + 1):\n            if instructionList[i - 1][0] == 0:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - 1])\n    \n    return dp[-1][-1]\n\ndef main():\n    testCases = [\n        {\"instructions\": [[0, 3], [1, 2]], \"K\": 5},\n        {\"instructions\": [[0, 10], [1, 10], [1, 6]], \"K\": 7},\n        {\"instructions\": [[0, 4], [1, 3], [2, 2], [3, 9], [3, 6], [4, 10]], \"K\": 13}\n    ]\n\n    for test in testCases:\n        print(f\"Test Case: {test['instructions']} and K = {test['K']}\")\n        result = findKthSmallest(test[\"instructions\"], test[\"K\"])\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1645": "```\ndef getWays(catalog, orders):\n    result = []\n    for order in orders:\n        ways = []\n        for product_id, quantity in order.items():\n            if product_id not in catalog or int(quantity) > catalog[product_id]:\n                return []\n        for product_id, quantity in order.items():\n            ways.append((product_id, int(quantity)))\n        result.append(ways)\n    return result\n\ndef main():\n    print(getWays({\n        \"item1\": 5,\n        \"item2\": 3,\n        \"item3\": 10\n    }, [\n        {\"item1\": 2, \"item2\": 4},\n        {\"item1\": 3, \"item3\": 7},\n        {\"item2\": 1}\n    ]))\n\n    print(getWays({\n        \"item1\": 5,\n        \"item2\": 3\n    }, [\n        {\"item1\": 1, \"item2\": 2},\n        {\"item1\": 4}\n    ]))\n\n    print(getWays({\n        \"item1\": 10\n    }, [\n        {\"item1\": 9}\n    ]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1644": "```\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef lowestCommonAncestor(root, p, q):\n    if not root or root == p or root == q:\n        return root\n\n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n\n    if left and right:\n        return root\n    return left if left else right\n\n\ndef main():\n    # Test Case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(5)\n    root1.right = TreeNode(1)\n    root1.left.left = TreeNode(6)\n    root1.left.right = TreeNode(2)\n    root1.right.left = TreeNode(0)\n    root1.right.right = TreeNode(8)\n    root1.left.right.left = TreeNode(7)\n    root1.left.right.right = TreeNode(4)\n\n    p1 = root1.left\n    q1 = root1.left.right\n\n    result1 = lowestCommonAncestor(root1, p1, q1)\n    print(\"Test Case 1: The LCA of nodes with values 6 and 2 is\", result1.val if result1 else None)\n\n    # Test Case 2\n    root2 = TreeNode(4)\n    root2.left = TreeNode(7)\n    root2.right = TreeNode(8)\n    root2.left.left = TreeNode(5)\n    root2.left.right = TreeNode(6)\n\n    p2 = root2.left\n    q2 = root2.left.right\n\n    result2 = lowestCommonAncestor(root2, p2, q2)\n    print(\"Test Case 2: The LCA of nodes with values 5 and 6 is\", result2.val if result2 else None)\n\n    # Test Case 3\n    root3 = TreeNode(1)\n    root3.left = TreeNode(2)\n    root3.right = TreeNode(3)\n    root3.left.left = TreeNode(4)\n    root3.left.right = TreeNode(5)\n\n    p3 = root3.left\n    q3 = root3.left.right\n\n    result3 = lowestCommonAncestor(root3, p3, q3)\n    print(\"Test Case 3: The LCA of nodes with values 4 and 5 is\", result3.val if result3 else None)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1646": "```\ndef maximumGenerated(n: int) -> int:\n    res = [0] * (n + 1)\n    for i in range(1, n // 2 + 1):\n        res[i * 2 - 1] = i\n        res[i * 2] = i\n    if n % 2 == 1:\n        res[n] = n // 2 + 1\n    return max(res)\n\ndef main():\n    print(maximumGenerated(7))  # Output: 3\n    print(maximumGenerated(5))   # Output: 3\n    print(maximumGenerated(1))   # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1647": "```\ndef minDeletions(s: str) -> int:\n    from collections import Counter\n    freq = Counter(s)\n    freqs = sorted(list(freq.values()))\n    res = 0\n    i, j = 0, len(freqs) - 1\n    while i < j:\n        if freqs[i] + 1 == freqs[j]:\n            res += 1\n            i += 1\n            j -= 1\n        elif freqs[i] + 1 < freqs[j]:\n            res += freqs[j] - (freqs[i] + 1)\n            i = j\n        else:\n            res += 1\n            j -= 1\n    return res\n\ndef main():\n    print(minDeletions(\"aabbbbbcccaa\")) \n    print(minDeletions(\"abbba\")) \n    print(minDeletions(\"abc\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1648": "```\ndef maxProfit(positions, speed):\n    total_profit = 0\n    last_position = positions[0]\n    for position in positions:\n        distance = position - last_position\n        hours = distance / speed\n        if hours > 1:\n            total_profit += (position - last_position) * speed * (hours - 1)\n        last_position = position\n    return total_profit\n\ndef main():\n    test_cases = [\n        {\"positions\": [10, 5, 15], \"speed\": 2, \"expected\": 10},\n        {\"positions\": [3, 5, 8, 9, 11, 12], \"speed\": 4, \"expected\": 34},\n        {\"positions\": [1, 2, 3, 4, 5, 6, 7], \"speed\": 3, \"expected\": 20}\n    ]\n\n    for test_case in test_cases:\n        positions = test_case[\"positions\"]\n        speed = test_case[\"speed\"]\n        expected = test_case[\"expected\"]\n\n        result = maxProfit(positions, speed)\n        if result == expected:\n            print(\"Test Case Passed: Positions {}, Speed {}, Expected Profit {}\".format(positions, speed, expected))\n        else:\n            print(\"Test Case Failed: Positions {}, Speed {}, Expected Profit {}\".format(positions, speed, expected))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1649": "```\ndef getLengthOfOptimalCompression(s):\n    res = []\n    n = len(s)\n    for i in range(1, n):\n        if s[i] == s[i-1]:\n            continue\n        res.append(i - res[-1] if not res or s[i-1] != '0' else 1)\n    return len(res)\n\ndef main():\n    print(getLengthOfOptimalCompression(\"a\") == 1)\n    print(getLengthOfOptimalCompression(\"aa\") == 0)\n    print(getLengthOfOptimalCompression(\"abca\") == 4)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1650": "```\nclass Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        if not root or root == p or root == q:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        if left and right:\n            return root\n        return left if left else right\n\ndef main():\n    s = Solution()\n    # Test case 1:\n    node1 = TreeNode(3)\n    node2 = TreeNode(5)\n    node3 = TreeNode(1)\n    node4 = TreeNode(6)\n    node5 = TreeNode(2)\n    node6 = TreeNode(0)\n    node7 = TreeNode(8)\n    node8 = TreeNode(4)\n    node9 = TreeNode(5)\n    node10 = TreeNode(5)\n\n    node1.left = node3\n    node1.right = node2\n    node2.left = node6\n    node2.right = node4\n    node3.left = node5\n    node5.left = node7\n    node5.right = node8\n\n    p = node8\n    q = node10\n    print(s.lowestCommonAncestor(node1, p, q))\n\n    # Test case 2:\n    node1 = TreeNode(1)\n    node2 = TreeNode(2)\n    node3 = TreeNode(3)\n    node4 = TreeNode(4)\n    node5 = TreeNode(5)\n\n    node1.right = node2\n    node2.left = node3\n    node3.right = node4\n\n    p = node3\n    q = node4\n    print(s.lowestCommonAncestor(node1, p, q))\n\n    # Test case 3:\n    node1 = TreeNode(6)\n    node2 = TreeNode(2)\n    node3 = TreeNode(8)\n    node4 = TreeNode(0)\n    node5 = TreeNode(4)\n    node6 = TreeNode(7)\n    node7 = TreeNode(9)\n    node8 = TreeNode(3)\n\n    node1.left = node2\n    node1.right = node3\n    node2.left = node4\n    node3.left = node5\n    node5.right = node6\n\n    p = node4\n    q = node6\n    print(s.lowestCommonAncestor(node1, p, q))\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None",
  "1651": "```\ndef total_cost(nums):\n    nums.sort()\n    n = len(nums)\n    i, j = 0, n - 1\n    res = 0\n    while i <= j:\n        if (j - i) % 2 == 0:\n            res += (nums[j] - nums[i]) * ((j - i + 1) // 2)\n            i += 1\n            j -= 1\n        else:\n            res += min(nums[i], nums[j]) * ((j - i + 1) // 2 + 1)\n            if nums[i] < nums[j]:\n                i += 1\n            else:\n                j -= 1\n    return res\n\ndef main():\n    print(total_cost([1,3])) # Expected output: 6\n    print(total_cost([7,9,12,16])) # Expected output: 74\n    print(total_cost([5,4,10])) # Expected output: 32\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1652": "```\ndef defuse_the_bomb(arr):\n    n = len(arr)\n    i = j = 0\n    while i < n:\n        if arr[i] == 1:\n            j += 1\n        elif j > 0:\n            j -= 1\n        else:\n            i += 1\n    return i + j\n\ndef main():\n    print(defuse_the_bomb([2, 0, 1])) # Expected: 5\n    print(defuse_the_bomb([5, 2, 0, 3, 0, 4, 1])) # Expected: 9\n    print(defuse_the_bomb([8, 6, 5, 4, 3, 2, 1, 0, 0])) # Expected: 11\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1653": "```\ndef minDeletions(s):\n    n = len(s)\n    stack = []\n    deletions = 0\n    for c in s:\n        while stack and stack[-1] != c:\n            stack.pop()\n        if stack and stack[-1] == c:\n            stack.pop()\n        else:\n            stack.append(c)\n    return n - (2 * len(stack))\n\ndef main():\n    print(minDeletions(\"aabbbcc\"))  # Output: 3\n    print(minDeletions(\"abca\"))     # Output: 4\n    print(minDeletions(\"bccccc\"))   # Output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1654": "```\nfrom collections import deque\n\ndef minJumps(arr):\n    n = len(arr)\n    if arr[0] == 0:\n        return -1\n    queue = deque([(0, 0)]) # index, jumps\n    visited = set([0])\n    while queue:\n        i, jumps = queue.popleft()\n        for j in range(1, min(i + 1 + arr[i], n)):\n            if j == n - 1:\n                return jumps + 1\n            if (j not in visited) and (arr[j] > 0):\n                queue.append((j, jumps + 1))\n                visited.add(j)\n    return -1\n\ndef main():\n    print(minJumps([2,1,1,1,0])) # expected output: 2\n    print(minJumps([0,1]) ) # expected output: -1\n    print(minJumps([2,1,1,1,1])) # expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1655": "```\ndef distributeRepeats(nums):\n    res = []\n    n = len(nums)\n    for i in range(32):\n        ones = sum((x>>i)&1 for x in nums)\n        zeros = n-ones\n        if ones>=zeros:\n            res.append([2**i]*ones)\n        else:\n            res.append([0]*(n-zeros) + [2**i]*ones)\n    return [item for sublist in res for item in sublist]\n\ndef main():\n    print(distributeRepeats([4,3,2,3,5,2,1]))\n    print(distributeRepeats([10,2,8,9,9,6,5,1,7,4,4,8,3,1,6,8]))\n    print(distributeRepeats([0]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1656": "```\nclass OrderedStream:\n\n    def __init__(self, n: int):\n        self.stream = [0] * (n + 1)\n        self.ptr = 0\n\n    def insert(self, idKey: int, value: int) -> List[str]:\n        while idKey <= len(self.stream) - 1:\n            self.stream[idKey] = str(value) + \"000\"\n            if idKey == self.ptr and self.stream[self.ptr].startswith(\"1\"):\n                return [self.stream[i] for i in range(self.ptr, idKey + 1)]\n            idKey += 1\n        self.ptr = idKey\n        return [str(value) + \"000\"]\n\ndef main():\n    # Test case 1:\n    os = OrderedStream(5)\n    print(os.insert(3, 0))  # Returns [\"0\"]\n    print(os.insert(1, 2))   # Returns []\n    print(os.insert(6, 3))   # Returns [\"0\",\"2\"]\n    print(os.insert(4, 1))   # Returns null\n    print(os.insert(5, 2))   # Returns [\"02000\"]\n\n    # Test case 2:\n    os = OrderedStream(10)\n    print(os.insert(11, 3))   # Returns []\n    print(os.insert(7, 0))    # Returns []\n    print(os.insert(8, 4))    # Returns [\"00004\"]\n    print(os.insert(9, 5))    # Returns [\"00004\",\"00005\"]\n\n    # Test case 3:\n    os = OrderedStream(1)\n    print(os.insert(2, 6))   # Returns []\n    print(os.insert(1, 5))   # Returns [\"5\"]\n    print(os.insert(0, 4))   # Returns []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1657": "```\ndef closeStrings(word1, word2):\n    if len(set(word1)) != len(set(word2)):\n        return False\n    for c1, c2 in zip(sorted(word1), sorted(word2)):\n        if c1 != c2:\n            return False\n    return True\n\n\ndef main():\n    print(closeStrings(\"abc\", \"bca\"))  # True\n    print(closeStrings(\"abc\", \"xyz\"))  # False\n    print(closeStrings(\"xyyx\", \"xyyx\"))  # True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1658": "```\ndef minOperations(nums, x):\n    if x == 0:\n        return 0\n    prefix_sum = {0: -1}\n    current_sum = 0\n    min_ops = float('inf')\n\n    for i in range(len(nums)):\n        current_sum += nums[i]\n        if current_sum >= x:\n            while current_sum > x:\n                current_sum -= nums[i - prefix_sum.get(current_sum - x, 0)]\n            min_ops = min(min_ops, i - prefix_sum.get(current_sum - x, 0))\n    return min_ops\n\ndef main():\n    print(minOperations([2,10,6,12,7,14,11], 15)) # Expected output: 6\n    print(minOperations([97466,93138,55556,34534,123456,23456789], 123456789)) # Expected output: 3\n    print(minOperations([9,4,20], 50)) # Expected output: -1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1659": "```\ndef maxHappiness(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[0] * (1 << n) for _ in range(m)]\n\n    for i in range(m):\n        for state in range(1 << n):\n            for j in range(n):\n                if not ((state >> j) & 1):\n                    continue\n                if j == 0:\n                    dp[i][state] = max(dp[i][state], grid[i][j])\n                else:\n                    dp[i][state] ^= grid[i][j]\n    return sum([dp[i][-1] for i in range(m)])\n\ndef main():\n    print(maxHappiness([[3,5],[2,10]])) # Expected: 27\n    print(maxHappiness([[0,0,1],[1,1,0],[1,1,1]])) # Expected: 6\n    print(maxHappiness([[10,10,10,10],[10,10,10,10],[10,10,10,10]])) # Expected: 40\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1660": "```\ndef traverseTree(root):\n    if not root:\n        return {}\n    hash_map = {root.val: None}\n    stack = [(root, None)]\n    \n    while stack:\n        node, parent = stack.pop()\n        \n        if node.left:\n            if node.left.val in hash_map:\n                hash_map[node.left.val] = node\n            else:\n                hash_map[node.left.val] = None\n            stack.append((node.left, node))\n        if node.right:\n            if node.right.val in hash_map:\n                hash_map[node.right.val] = node\n            else:\n                hash_map[node.right.val] = None\n            stack.append((node.right, node))\n\n    return hash_map\n\n\ndef correctBinaryTree(root):\n    if not root or (root.left and root.left.val > root.val) or (root.right and root.right.val < root.val):\n        return False\n\n    hash_map = traverseTree(root)\n    for val in hash_map:\n        parent = hash_map[val]\n        \n        if not parent:\n            continue\n        if parent.val > val or (parent.left and parent.left.val > val) or (parent.right and parent.right.val < val):\n            return False\n\n    return True\n\n\ndef main():\n    root1 = TreeNode(5)\n    root1.left = TreeNode(3)\n    root1.right = TreeNode(6)\n\n    root2 = TreeNode(4)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(7)\n\n    root3 = TreeNode(10)\n    root3.left = TreeNode(8)\n    root3.right = TreeNode(11)\n    \n    print(correctBinaryTree(root1))  # Expected: True\n    print(correctBinaryTree(root2))  # Expected: False\n    print(correctBinaryTree(root3))  # Expected: True\n\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1661": "```\ndef averageTimePerMachine(logs):\n    machine_time = {}\n    for log in logs:\n        machine, time = log.split(\":\")\n        machine_time[machine] = machine_time.get(machine, 0) + int(time)\n    return {machine: time / len(logs) for machine, time in machine_time.items()}\n\ndef main():\n    print(averageTimePerMachine([\"0:2\",\"0:1\",\"1:2\",\"2:0\",\"2:2\",\"1:1\",\"2:0\",\"0:2\",\"2:0\"]))\n    print(averageTimePerMachine([\"0:3\",\"1:2\",\"2:1\"]))\n    print(averageTimePerMachine([\"0:5\",\"1:4\",\"2:3\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1662": "```\ndef groupStrings(arr1, arr2):\n    return sorted(map(tuple, arr1)) == sorted(map(tuple, arr2))\n\ndef main():\n    print(groupStrings([\"abc\", \"bcd\", \"xyz\"], [\"bcd\", \"cba\", \"xyz\"]) == True)\n    print(groupStrings([\"aaa\",\"bbb\",\"ccc\"], [\"aaaa\",\"bbb\",\"cc\"]) == False)\n    print(groupStrings([\"a\", \"b\", \"c\"], [\"a\", \"b\", \"c\"]) == True)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1663": "```\ndef getSmallestString(n: int, k: int) -> str:\n    result = [\"a\"] * (n - 1)\n    last_one = chr(ord('a') + min(k % n, n - 1))\n    result.append(last_one)\n    return \"\".join(result)\n\ndef main():\n    print(getSmallestString(3, 27)) # Expected: \"aaab\"\n    print(getSmallestString(2, 10)) # Expected: \"aab\"\n    print(getSmallestString(5, 36)) # Expected: \"abcdz\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1664": "```\ndef fairArrayPairs(nums):\n    total = sum(nums)\n    pairs = []\n    for i in range(len(nums)):\n        diff = total - 2 * nums[i]\n        if diff % 2 == 0:\n            half_diff = diff // 2\n            if half_diff in nums[:i] or half_diff in nums[i+1:]:\n                pairs.append([nums[i], half_diff])\n    return len(pairs)\n\ndef main():\n    print(fairArrayPairs([30,20,3])) # Test case 1: Expected output 1\n    print(fairArrayPairs([10,5,15])) # Test case 2: Expected output 2\n    print(fairArrayPairs([2,4,8])) # Test case 3: Expected output 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1665": "```\ndef minStartVal(tasks, start):\n    tasks.sort()\n    total = sum([task for task in tasks])\n    n = len(tasks)\n    \n    if total % n != 0:\n        return -1\n    else:\n        avg = total // n\n        prev_energy = [avg]\n        for i in range(1, n):\n            prev_energy.append(prev_energy[-1] + (tasks[i] - avg))\n        return min(prev_energy)\n\ndef main():\n    print(minStartVal([1,2,3,4,5], 5)) # Test case 1: should return 7\n    print(minStartVal([20,50,100], 15) ) # Test case 2: should return 10\n    print(minStartVal([1,12,5,23,51], 6) ) # Test case 3: should return 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1667": "```\ndef fix_names(names):\n    result = []\n    for name in names:\n        fixed_name = ''\n        prev_char = ''\n        for char in name:\n            if char.isupper():\n                if not prev_char.isdigit() or char == 'I':\n                    fixed_name += char.lower()\n                else:\n                    fixed_name += char\n            elif char.isdigit():\n                fixed_name += char\n            elif char.isspace():\n                fixed_name += ' '\n            else:\n                if prev_char.isalpha():\n                    fixed_name += char.upper()\n                else:\n                    fixed_name += char\n            prev_char = char\n        result.append(fixed_name)\n    return result\n\ndef main():\n    test_cases = [\n        {\"input\": [\"M 2546 Hacker\", \"A 1265 Government\", \"Antonio 31221 Pilot\"], \"expected_output\": [\"m 2546 hacker\", \"a 1265 government\", \"antonio 31221 pilot\"]},\n        {\"input\": [\"K 4567 Artist\", \"K 1234 Doctor\"], \"expected_output\": [\"k 4567 artist\", \"k 1234 doctor\"]},\n        {\"input\": [\"Mr. Raleigh 23456 Engineer\"], \"expected_output\": [\"mr raleigh 23456 engineer\"]}\n    ]\n    \n    for test_case in test_cases:\n        input_names = test_case[\"input\"]\n        expected_output = test_case[\"expected_output\"]\n        \n        output = fix_names(input_names)\n        if output == expected_output:\n            print(\"Test Case Passed!\")\n        else:\n            print(f\"Test Case Failed! Expected: {expected_output}, Got: {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1666": "```\nclass Solution:\n    def changeRootValue(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return None\n        stack = [(root, root.val)]\n        while stack:\n            node, val = stack.pop()\n            node.val = val\n            if node.left:\n                stack.append((node.left, val))\n            if node.right:\n                stack.append((node.right, val))\n        return root\n\ndef main():\n    s = Solution()\n\n    # Test case 1\n    test_root1 = TreeNode(4)\n    test_root1.left = TreeNode(2)\n    test_root1.right = TreeNode(7)\n    test_root1.left.left = TreeNode(1)\n    test_root1.left.right = TreeNode(3)\n    test_result1 = s.changeRootValue(test_root1)\n\n    # Test case 2\n    test_root2 = TreeNode(5)\n    test_result2 = s.changeRootValue(test_root2)\n\n    # Test case 3\n    test_root3 = TreeNode(8)\n    test_root3.left = TreeNode(6)\n    test_root3.right = TreeNode(9)\n    test_root3.left.left = TreeNode(4)\n    test_root3.left.right = TreeNode(5)\n    test_result3 = s.changeRootValue(test_root3)\n\n    print(\"Test case 1: \", end=\"\")\n    self.check_tree(test_result1, 2, None, None, 1, None, None, None, None, 3)\n    print(\"Test case 2: \", end=\"\")\n    self.check_tree(test_result2, None, None, None, None, None, None, None, None, None)\n    print(\"Test case 3: \", end=\"\")\n    self.check_tree(test_result3, 6, None, None, 4, None, 5, None, None, None)\n\ndef check_tree(root, root_val, left_val1, right_val1, left_val2, right_val2, left_val3, right_val3, left_val4, right_val4):\n    if root is None:\n        return True\n    if root.val != root_val:\n        return False\n    if (root.left and root.left.val != left_val1) or (root.right and root.right.val != right_val1):\n        return False\n    if (root.left and root.left.left and root.left.left.val != left_val2) or (root.left and root.left.right and root.left.right.val != right_val2):\n        return False\n    if (root.left and root.left.left and root.left.left.left and root.left.left.left.val != left_val3) or (root.left and root.left.left and root.left.left.right and root.left.left.right.val != right_val3):\n        return False\n    if (root.left and root.left.left and root.left.left.left and root.left.left.left.left and root.left.left.left.left.val != left_val4) or (root.left and root.left.left and root.left.left.left and root.left.left.left.right and root.left.left.left.right.val != right_val4):\n        return False\n    return True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1668": "```\ndef maxRepeating(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if s[i - 1] == s[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[-1][-1]\n\ndef main():\n    print(maxRepeating(\"ababc\"))\n    print(maxRepeating(\"aabaaba\"))\n    print(maxRepeating(\"abc\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1669": "```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef mergeInBetween(l1: ListNode, lAttachAt: int, rAttachAt: int, r: ListNode) -> ListNode:\n    current = l1\n    while current and current.val != lAttachAt:\n        current = current.next\n\n    current = r\n    while current and current.val != rAttachAt:\n        current = current.next\n\n    l1.next = r.next\n    r.next = current\n    return l1\n\n\ndef main():\n    # Test Case 1\n    l1 = ListNode(0, ListNode(6))\n    l2 = ListNode(4)\n    print(\"Test Case 1:\", mergeInBetween(l1, 5, 7, l2).val)\n\n    # Test Case 2\n    l1 = ListNode(1, ListNode(3, ListNode(5)))\n    l2 = ListNode(2, ListNode(8))\n    print(\"Test Case 2:\", mergeInBetween(l1, 3, 4, l2).val)\n\n    # Test Case 3\n    l1 = ListNode(0)\n    l2 = ListNode(6)\n    print(\"Test Case 3:\", mergeInBetween(l1, 1, 3, l2).val)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1670": "```\nclass FrontMiddleBackQueue:\n\n    def __init__(self):\n        self.queue = [None]\n\n    def enqueue(self, val: int) -> None:\n        while len(self.queue) * 2 < len(self.queue) + 1:\n            self.queue.append(None)\n        self.queue.extend([None] + [val])\n\n    def dequeueFront(self) -> int:\n        if not self.queue or self.queue[0] is None:\n            return -1\n        val = self.queue.pop(0)\n        while self.queue and self.queue[0] is None:\n            self.queue.pop(0)\n        return val\n\n    def dequeueMiddle(self) -> int:\n        if len(self.queue) < 3 or not self.queue:\n            return -1\n        middle = (len(self.queue) + 1) // 2\n        while self.queue[0] is None and len(self.queue) > 1:\n            self.queue.pop(0)\n        val = self.queue.pop(middle)\n        if self.queue and self.queue[0] is None:\n            self.queue.pop(0)\n        return val\n\n    def dequeueBack(self) -> int:\n        if not self.queue or self.queue[-1] is None:\n            return -1\n        while self.queue[-1] is None and len(self.queue) > 1:\n            self.queue.pop()\n        return self.queue.pop()\n\n\ndef main():\n    queue = FrontMiddleBackQueue()\n\n    # Test case 1: Enqueue and dequeue front, middle, back\n    print(\"Test case 1:\")\n    for _ in range(5):\n        queue.enqueue(_)\n    print(f\"Front: {queue.dequeueFront()}\")\n    print(f\"Middle: {queue.dequeueMiddle()}\")\n    print(f\"Back: {queue.dequeueBack()}\")\n\n    # Test case 2: Dequeue front and middle, enqueue back\n    print(\"\\nTest case 2:\")\n    for _ in range(3):\n        queue.enqueue(_)\n    while True:\n        val = queue.dequeueFront()\n        if val == -1:\n            break\n        print(f\"Dequeued front: {val}\")\n    while True:\n        val = queue.dequeueMiddle()\n        if val == -1:\n            break\n        print(f\"Dequeued middle: {val}\")\n\n    # Test case 3: Dequeue back, enqueue and dequeue front, middle, back\n    print(\"\\nTest case 3:\")\n    for _ in range(5):\n        queue.enqueue(_)\n    while True:\n        val = queue.dequeueBack()\n        if val == -1:\n            break\n        print(f\"Dequeued back: {val}\")\n\n    for _ in range(2):\n        queue.enqueue(_)\n    print(f\"Front: {queue.dequeueFront()}\")\n    print(f\"Middle: {queue.dequeueMiddle()}\")\n    print(f\"Back: {queue.dequeueBack()}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1671": "```\ndef minimumMountainRemovals(arr):\n    n = len(arr)\n    res = n\n    left = [0]*n\n    right = [0]*n\n    \n    for i in range(1, n-1):\n        if arr[i] > arr[i-1]:\n            left[i] = 1 + left[i-1]\n        else:\n            break\n    for i in range(n-2, 0, -1):\n        if arr[i] > arr[i+1]:\n            right[i] = 1 + right[i+1]\n        else:\n            break\n    \n    for i in range(1, n-1):\n        res = min(res, left[i] + right[i])\n    \n    return n - (res + 2)\n\ndef main():\n    print(minimumMountainRemovals([2,1,1])) # Expected: 1\n    print(minimumMountainRemovals([3,5,0,4]) ) # Expected: 8\n    print(minimumMountainRemovals([2,1,3,1,4,5,7,6,5,5,5])) # Expected: 10\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1672": "```\ndef maximumWealth(customers):\n    max_wealth = 0\n    for customer in customers:\n        wealth = sum(customer)\n        if wealth > max_wealth:\n            max_wealth = wealth\n    return max_wealth\n\n\ndef main():\n    print(maximumWealth([[1,2],[3,5],[11,2]]))\n    print(maximumWealth([[1, 1], [5, 0], [4, 6]]))\n    print(maximumWealth([[7,8],[9,10]]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1673": "```\ndef mostCompetitive(nums):\n    stack = []\n    for n in nums:\n        while stack and stack[-1] > n:\n            stack.pop()\n        stack.append(n)\n    return [n for n in stack]\n\ndef main():\n    print(mostCompetitive([4,5,6]))\n    print(mostCompetitive([2,7,11,8]))\n    print(mostCompetitive([1,3,5,10,6,2,3]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1674": "```\ndef minMoves(arr):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    \n    res = float('inf')\n    for i in range(n):\n        for j in range(i, n):\n            moves = abs(prefix_sum[j + 1] - (prefix_sum[i] + sum(arr[i + 1:j + 1])))\n            res = min(res, moves)\n            \n    return res\n\n\ndef main():\n    print(minMoves([30,31,4,5,6,7,8,20,21])) # Expected: 2\n    print(minMoves([3,1,4])) # Expected: 3\n    print(minMoves([0,0,0])) # Expected: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1675": "```\nimport heapq\n\ndef minimumDeviation(arr):\n    n = len(arr)\n    if any(a % i for i in range(1, int(min(arr)**0.5) + 1)):\n        return min(arr)\n\n    pq = [(a, a) for a in arr]\n    heapq.heapify(pq)\n    \n    res = float('inf')\n    while True:\n        x, y = heapq.heappop(pq)\n        \n        if x == y:\n            res = min(res, x)\n            break\n        else:\n            res = min(res, x - (y // 2))\n            new_y = max(y // 2, x)\n            heapq.heappush(pq, (new_y, new_y))\n\n    return res\n\n\ndef main():\n    print(minimumDeviation([1,2,3,4])) # Test case 1\n    print(minimumDeviation([4,9,6])) # Test case 2\n    print(minimumDeviation([10,1])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1676": "```\ndef findLCA(root, p, q):\n    if root is None:\n        return None\n    if root.val == p or root.val == q:\n        return root\n\n    left = findLCA(root.left, p, q)\n    right = findLCA(root.right, p, q)\n\n    if left and right:\n        return root\n    elif left:\n        return left\n    else:\n        return right\n\n\ndef main():\n    class TreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.left = None\n            self.right = None\n\n    # Test case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(5)\n    root1.right = TreeNode(1)\n    root1.left.left = TreeNode(6)\n    root1.left.right = TreeNode(2)\n    root1.right.left = TreeNode(0)\n    root1.right.right = TreeNode(8)\n    p, q = 5, 1\n    print(findLCA(root1, p, q).val)  # Output: 3\n\n    # Test case 2\n    root2 = TreeNode(4)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(7)\n    root2.left.left = TreeNode(3)\n    root2.left.right = TreeNode(1)\n    p, q = 2, 3\n    print(findLCA(root2, p, q).val)  # Output: 2\n\n    # Test case 3\n    root3 = TreeNode(6)\n    root3.left = TreeNode(2)\n    root3.right = TreeNode(8)\n    root3.left.left = TreeNode(0)\n    root3.left.right = TreeNode(4)\n    root3.right.left = TreeNode(7)\n    root3.right.right = TreeNode(9)\n    p, q = 2, 8\n    print(findLCA(root3, p, q).val)  # Output: 6\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1677": "```\ndef totalWorth(invoices):\n    return sum(item['price'] * item['quantity'] for item in invoices)\n\ndef main():\n    print(totalWorth([{\"price\": 10, \"quantity\": 1}, {\"price\": 20, \"quantity\": 2}])) # Expected: 60\n    print(totalWorth([{\"price\": 5, \"quantity\": 3}, {\"price\": 7, \"quantity\": 4}])) # Expected: 65\n    print(totalWorth([{\"price\": 1, \"quantity\": 10}, {\"price\": 2, \"quantity\": 20}])) # Expected: 100\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1678": "```\ndef interpret(command):\n    result = \"\"\n    i = 0\n    while i < len(command):\n        if command[i:i+2] == \"G \":\n            result += \"G\"\n            i += 1\n        elif command[i] == \"!\":\n            result += \"!(al)\"\n            i += 4\n        else:\n            result += command[i]\n            i += 1\n    return result\n\ndef main():\n    print(interpret(\"G!\")  # Expected output: \"Goal!\"\n    print(interpret(\"G!!\")  # Expected output: \"Goal!Goal!\"\n    print(interpret(\"Gd!\")  # Expected output: \"Goal!\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1679": "```\ndef maxKSumPairs(nums, k):\n    nums.sort()\n    left, right = 0, len(nums) - 1\n    pairs = 0\n    \n    while left < right:\n        if nums[left] + nums[right] <= k:\n            pairs += right - left\n            left += 1\n        else:\n            right -= 1\n            \n    return pairs\n\ndef main():\n    print(maxKSumPairs([1, 13, 3, 24], 18), end='\\n\\n')\n    print(maxKSumPairs([5, 4, 2, 8, 9], 16), end='\\n\\n')\n    print(maxKSumPairs([6, 7, 10, 14], 15), end='\\n')\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1680": "```\ndef concatenatedBinary(maxLength):\n    res = \"\"\n    for i in range(1, 2**maxLength, 2):\n        binStr = bin(i)[2:]\n        while len(binStr) < maxLength:\n            binStr += '0'\n        res += binStr\n    return int(res, 2)\n\ndef main():\n    print(concatenatedBinary(3))  # Expected: 10101\n    print(concatenatedBinary(5))  # Expected: 101010111\n    print(concatenatedBinary(6))  # Expected: 10101011101\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1681": "```\ndef minIncompatibility(costs):\n    n = len(costs)\n    total_cost = sum(costs)\n    dp = [[float('inf')] * (1 << 20) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(1, n + 1):\n        for mask in range((1 << 20)):\n            if not ((mask >> i) & 1):\n                new_mask = mask | (1 << i)\n                dp[i][new_mask] = min(dp[i][new_mask], dp[i - 1][mask] + costs[i - 1])\n    \n    res = float('inf')\n    for mask in range((1 << 20)):\n        if not (total_cost & mask):\n            res = min(res, total_cost - 2 * sum(costs[j] for j in range(n) if ((mask >> j) & 1)) + dp[n][mask])\n    \n    return res\n\n\ndef main():\n    print(minIncompatibility([3, 2, 4]))  # 6\n    print(minIncompatibility([5, 4, 3]))  # 9\n    print(minIncompatibility([10, 2, 8, 7, 1]))  # 15\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1682": "```\ndef longestPalindromicSubsequence(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        dp[i][i] = 1\n        if s[i - 1] == s[i]:\n            dp[i - 1][i] = 2\n        else:\n            dp[i - 1][i] = 1\n    \n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]\n\ndef main():\n    test_cases = [\n        {\"s\": \"babad\", \"expected_output\": 3},\n        {\"s\": \"cbbd\", \"expected_output\": 2},\n        {\"s\": \"a\", \"expected_output\": 1}\n    ]\n\n    for test_case in test_cases:\n        s = test_case[\"s\"]\n        expected_output = test_case[\"expected_output\"]\n        output = longestPalindromicSubsequence(s)\n        print(f\"Test case: {s}, Expected Output: {expected_output}, Actual Output: {output}\")\n        if output == expected_output:\n            print(\"Pass\")\n        else:\n            print(\"Fail\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1683": "```\ndef numInvalidTicks(tweets):\n    if not tweets:\n        return 0\n    query = \"SELECT * FROM Tweets WHERE NOT (LENGTH(TEXT) >= 6 AND LENGTH(TEXT) <= 140)\"\n    result = []\n    for row in execute_query(query):\n        result.append(row[0])\n    return len(result)\n\ndef main():\n    test_cases = [\n        {\"tweets\": [\"aaa\", \"zzz\"], \"expected\": 2},\n        {\"tweets\": [], \"expected\": 0},\n        {\"tweets\": [\"short\", \"longer\", \"too long\"], \"expected\": 1}\n    ]\n    \n    for case in test_cases:\n        tweets = [case[\"tweets\"]]\n        actual = numInvalidTicks(tweets[0])\n        if actual == case[\"expected\"]:\n            print(\"Test case passed: \", end=\"\")\n        else:\n            print(\"Test case failed: \", end=\"\")\n        print(f\"Expected {case['expected']}, got {actual}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1684": "```\ndef countConsistentStrings(s, inputs):\n    s_set = set(list(s))\n    return sum(1 for x in inputs if all(c in s_set for c in x))\n\ndef main():\n    print(countConsistentStrings(\"abc\", [\"a\", \"b\", \"c\", \"d\", \"ac\"])) # Expected: 3\n    print(countConsistentStrings(\"unnntt\", [\"uxyzz\", \"xy\", \"yy\", \"yu\", \"yt\"])) # Expected: 2\n    print(countConsistentStrings(\"leetcode\", [\"win\", \"cut\", \"kites\", \"kite\", \"love\", \"leetcode\"])) # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1685": "```\ndef sumOfAbsDiffs(nums):\n    return sum(abs(a - b) for a, b in zip([0] + nums, nums))\n\ndef main():\n    print(sumOfAbsDiffs([2,1])) # Test case 1\n    print(sumOfAbsDiffs([-1,-2,3])) # Test case 2\n    print(sumOfAbsDifs([1,3,15,6,5,4,7,6,7,8,12,10,7,6,9])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1686": "```\ndef stoneGameVI(piles, AliceValues):\n    heap = [(-v, p) for v, p in zip(AliceValues, piles)]\n    heapq.heapify(heap)\n    return sum(pile for _, pile in sorted(heap, reverse=True))\n\ndef main():\n    test_cases = [\n        {\n            'piles': [2,7,9], \n            'AliceValues': [-5,-2,-1], \n            'expected_output': 12\n        }, \n        {\n            'piles': [1,2], \n            'AliceValues': [-1,2], \n            'expected_output': 3\n        }, \n        {\n            'piles': [10], \n            'AliceValues': [5], \n            'expected_output': 10\n        }\n    ]\n\n    for test_case in test_cases:\n        piles = test_case['piles']\n        AliceValues = test_case['AliceValues']\n        expected_output = test_case['expected_output']\n        \n        output = stoneGameVI(piles, AliceValues)\n        assert output == expected_output, f\"Test case failed. Expected {expected_output} but got {output}\"\n    \n    print(\"All test cases passed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1687": "```\ndef boxDelivery(days, boxes):\n    n = len(boxes)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        dp[i][i] = boxes[i - 1]\n        \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length\n            if boxes[i - 1] > 0:\n                dp[i][j] = max(dp[i][i + length // 2] + boxes[i - 1], \n                               dp[j][j] - boxes[j - 1])\n            else:\n                dp[i][j] = min(dp[i][j], dp[i][i + length // 2], dp[j][j])\n                \n    return dp[0][-1]\n\ndef main():\n    print(boxDelivery([5,10,6,20,3,15], 4)) # Expected: 22\n    print(boxDelivery([1, 2, 3, 5], 2)) # Expected: 9\n    print(boxDelivery([7, 5, 11, 8, 12, 14], 6)) # Expected: 34\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1688": "```\ndef totalWays(n: int) -> int:\n    if n == 1:\n        return 1\n    ways = [0] * (n + 1)\n    ways[1] = 1\n    for i in range(2, n + 1):\n        ways[i] = 2 * ways[i - 1]\n    return ways[n]\n\ndef main():\n    print(totalWays(3) == 5) \n    print(totalWays(4) == 14)\n    print(totalWays(7) == 140)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1689": "```\ndef minPartitions(num: str) -> int:\n    return max(int(digit) for digit in num)\n\ndef main():\n    print(minPartitions(\"82979019999\")) # Expected output: 9\n    print(minPartitions(\"12345\")) # Expected output: 1\n    print(minPartitions(\"10101010101\")) # Expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1690": "```\ndef winner(a):\n    n = len(a)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + a[i]\n\n    res = [0] * (n + 1)\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n + 1):\n            res[j] = max(res[j], min(prefix_sum[i] - prefix_sum[j - 1], a[i]) if i > 0 else 0)\n    return sum(1 for x in res if x > 0)\n\ndef main():\n    print(winner([5,3,2,4,1])) # Expected output: True\n    print(winner([6,2,8,5,4,3,7,1])) # Expected output: False\n    print(winner([10])) # Expected output: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1691": "```\ndef maxVolume(cubiods):\n    cubiods.sort(key=lambda x: x[2], reverse=True)\n    stack = [cubiods[0]]\n    height = 0\n    for cuboid in cubiods[1:]:\n        if cuboid[2] > stack[-1][2]:\n            while len(stack) > 1 and cuboid[1] < stack[-2][1]:\n                stack.pop()\n            stack.append(cuboid)\n        else:\n            i = len(stack) - 1\n            for j in range(len(stack)-1, -1, -1):\n                if stack[j][0] <= cuboid[0] or cuboid[1] < stack[j][1]:\n                    i = j; break\n            stack.insert(i+1, cuboid)\n    return sum([cubiod[2]*min(cubiod[1],stack[i-1][1]-stack[i-1][2]) for i in range(1,len(stack)+1)])\n\ndef main():\n    print(maxVolume([[1,3,6],[4,5,7],[10,12,100]]))  # Expected: 90\n    print(maxVolume([[5,6,8], [1,2,3], [4,5,10], [2,3,10]]))  # Expected: 40\n    print(maxVolume([[2,7,17], [7,8,12], [9,14,18], [13,14,23]]))  # Expected: 43\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1692": "```\ndef countWays(n, m):\n    dp = [0] * (m + 1)\n    dp[0] = 1\n    for i in range(1, n+1):\n        for j in range(m, -1, -1):\n            if j >= i:\n                dp[j] += dp[j-i]\n    return dp[m]\n\ndef main():\n    print(countWays(3, 2) == 4)\n    print(countWays(10, 3) == 274)\n    print(countWays(7, 5) == 1472)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1693": "```\ndef numEquivDominoPairs(dominoes):\n    count = {}\n    for domino in dominoes:\n        sorted_domino = tuple(sorted(domino))\n        if sorted_domino not in count:\n            count[sorted_domino] = 0\n        count[sorted_domino] += 1\n    return sum((v // 2) * (v - 1) for v in count.values())\n\ndef main():\n    test_cases = [\n        {\"dominoes\": [[1,2],[1,3],[2,5]], \"expected_result\": 2},\n        {\"dominoes\": [[1,2],[7,7],[7,6},{},{},{},[2,2]],\"expected_result\": 4},\n        {\"dominoes\": [[],{},\"a\",\"b\"],\"expected_result\": 0}\n    ]\n    \n    for test_case in test_cases:\n        result = numEquivDominoPairs(test_case[\"dominoes\"])\n        assert result == test_case[\"expected_result\"], \"Test case failed\"\n        \n    print(\"All test cases passed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1694": "```\ndef reformatPhoneNumber(number):\n    result = []\n    for char in number:\n        if char.isdigit():\n            result.append(char)\n        elif len(result) > 0 and result[-1] == '-':\n            continue\n        elif len(result) < 4:\n            result.append('-')\n        else:\n            result.insert(0, '-')\n    return ''.join(result).strip('-')\n\n\ndef main():\n    print(reformatPhoneNumber(\"123-456-7890\"))  # Expected output: \"123-456-7890\"\n    print(reformatPhoneNumber(\"123-4-567-8900\"))  # Expected output: \"123-4-567-8900\"\n    print(reformatPhoneNumber(\"(123) 456-7890\"))  # Expected output: \"(1)2-3456-7890\"\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1695": "```\ndef maxErasureValue(sequence):\n    n = len(sequence)\n    freq_map = {}\n    for char in sequence:\n        if char in freq_map:\n            freq_map[char] += 1\n        else:\n            freq_map[char] = 1\n    max_val = 0\n    left = 0\n    right = 0\n    for right in range(n):\n        while freq_map[sequence[right]] > 1:\n            freq_map[sequence[left]] -= 1\n            left += 1\n        if right - left + 1 > max_val:\n            max_val = right - left + 1\n    return max_val\n\ndef main():\n    print(\"Test case 1:\")\n    sequence = \"abcdebdde\"\n    result = maxErasureValue(sequence)\n    print(f\"Result: {result}\")\n    \n    print(\"\\nTest case 2:\")\n    sequence = \"aaaaaaabbb\"\n    result = maxErasureValue(sequence)\n    print(f\"Result: {result}\")\n\n    print(\"\\nTest case 3:\")\n    sequence = \"abcdeabcdeabcdeabcde\"\n    result = maxErasureValue(sequence)\n    print(f\"Result: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1696": "```\ndef maxResult(nums, k):\n    n = len(nums)\n    dp = [0] * n\n    dp[0] = nums[0]\n    q = [(nums[0], 0)]\n    \n    for i in range(1, n):\n        while q and q[0][1] < i - k:\n            q.pop(0)\n        \n        if q and q[0][1] == i - k:\n            dp[i] += q[0][0]\n            q.remove((q[0][0], i - k))\n        \n        if len(q) > 0:\n            dp[i] += dp[q[0][1]]\n        else:\n            dp[i] = nums[i]\n\n        heapq.heappush(q, (-dp[i], i))\n\n    return -dp[-1]\n\ndef main():\n    print(maxResult([10,3,2,5,0], 3)) # Expected: 14\n    print(maxResult([1,-1,-2,4,6], 2) ) # Expected: 7\n    print(maxResult([-5,0,-2,1,3], 3) ) # Expected: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1697": "```\ndef hasPath(grid, rowGap, colGap):\n    m, n = len(grid), len(grid[0])\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 2:\n            return False\n        grid[i][j] = 2\n        for direction in directions:\n            ni, nj = i + direction[0], j + direction[1]\n            if dfs(ni, nj):\n                return True\n        return False\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 1 and dfs(i, j):\n                return True\n\n    return False\n\n\ndef main():\n    test_cases = [\n        {\"grid\": [[0,1],[1,0]], \"rowGap\": 1, \"colGap\": 1, \"expected\": True},\n        {\"grid\": [[0,1,0],[0,1,0],[0,0,0]], \"rowGap\": 2, \"colGap\": 2, \"expected\": False},\n        {\"grid\": [[0,1,0],[0,1,0],[1,1,0]], \"rowGap\": 3, \"colGap\": 3, \"expected\": True}\n    ]\n\n    for test_case in test_cases:\n        grid = test_case[\"grid\"]\n        rowGap = test_case[\"rowGap\"]\n        colGap = test_case[\"colGap\"]\n        expected = test_case[\"expected\"]\n\n        result = hasPath(grid, rowGap, colGap)\n        if result != expected:\n            print(f\"Test case failed: {test_case}\")\n        else:\n            print(\"Test case passed\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1698": "```\ndef numDistinctSubstrings(s):\n    n = len(s)\n    res = set()\n    for i in range(n):\n        for j in range(i+1, n+1):\n            res.add(s[i:j])\n    return len(res)\n\ndef main():\n    print(numDistinctSubstrings(\"BANANA\"))  # Output: 26\n    print(numDistinctSubstrings(\"ABCABC\"))   # Output: 10\n    print(numDistinctSubstrings(\"\"))          # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1700": "```\ndef countStudentsunabletoeat(students):\n    if not students:\n        return 0\n    stack = [students[0]]\n    count = 1\n    for student in students[1:]:\n        while len(stack) > 0 and (student < stack[-1]):\n            stack.pop()\n            count += 1\n        stack.append(student)\n    return count\n\ndef main():\n    print(countStudentsunabletoeat([1,2,3,4])) # Test case 1\n    print(countStudentsunabletoeat([5,6,7,8,9])) # Test case 2\n    print(countStudentsunabletoeat([10,11,12,13,14])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1699": "```\ndef numCallsWithinDays(numCalls, times):\n    calls = {}\n    for call in zip(numCalls, times):\n        if call[1][0] not in calls:\n            calls[call[1][0]] = [0, []]\n        calls[call[1][0]][0] += 1\n        calls[call[1][0]][1].append(call[0])\n\n    result = []\n    for person, info in calls.items():\n        if len(info[1]) > 0:\n            lastCall = max(info[1])\n            firstCall = min(info[1])\n            days = (lastCall - firstCall) // (24 * 60 * 60)\n            callsInDays = sum(1 for callTime in info[1] if (callTime - firstCall) // (24 * 60 * 60) <= days)\n            result.append((person, callsInDays))\n\n    return result\n\ndef main():\n    numCalls1 = [9, 15, 13]\n    times1 = [\"2022-01-02 10:00\", \"2022-01-03 11:10\", \"2022-01-04 12:50\"]\n    print(numCallsWithinDays(numCalls1, times1))\n\n    numCalls2 = [9, 13, 14]\n    times2 = [\"2022-01-01 10:00\", \"2022-01-03 11:10\", \"2022-01-04 12:50\"]\n    print(numCallsWithinDays(numCalls2, times2))\n\n    numCalls3 = [5, 6]\n    times3 = [\"2022-01-01 10:00\", \"2022-01-02 11:00\"]\n    print(numCallsWithinDays(numCalls3, times3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1701": "```\ndef averageWaitingTime(queue):\n    waiting_time = 0\n    current_position = 0\n    for i in range(len(queue)):\n        if queue[i][1] >= current_position:\n            waiting_time += queue[i][1] - current_position\n            current_position = queue[i][1]\n        else:\n            waiting_time += queue[i][1] - current_position\n            current_position = queue[i][1]\n    return waiting_time / len(queue)\n\ndef main():\n    test_cases = [\n        [[1,2],[3,4],[5,6]],  # Expected: 8.0\n        [[2,7,9], [10,11,13], [15,17,18]],  # Expected: 21.333333333333332\n        [[14,16,20], [15,19,22], [16,25,35]],  # Expected: 20.5\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        result = averageWaitingTime(test_case)\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1702": "```\ndef maximumBinaryString(binaryString):\n    if len(binaryString) == 0:\n        return \"0\"\n\n    max_count = 0\n    max_binary_str = \"\"\n    \n    count_1 = 0\n    \n    for char in binaryString:\n        if char == \"1\":\n            count_1 += 1\n        else:\n            if count_1 > 0:\n                if count_1 > max_count:\n                    max_count = count_1\n                    max_binary_str = \"1\" * count_1 + \"0\" * (len(binaryString) - count_1)\n                count_1 = 0\n    \n    return max_binary_str\n\n\ndef main():\n    print(maximumBinaryString(\"00011000\")) \n    print(maximumBinaryString(\"11101111\")) \n    print(maximumBinaryString(\"10101010\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1704": "```\ndef halvesAreAlike(s):\n    half = len(s) // 2\n    first_half = s[:half]\n    second_half = s[half:]\n    return all(c in 'aeiouAEIOU' for c in first_half) == (all(c in 'aeiouAEIOU' for c in second_half))\n\ndef main():\n    print(halvesAreAlike(\"book\")) # False\n    print(halvesAreAlike(\"abCcD\")) # True\n    print(halvesAreAlike(\"a\")) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1703": "```\ndef min_k_bit_flips(nums):\n    n = len(nums)\n    res = 0\n    i = 0\n    while i < n:\n        count = 0\n        for j in range(i, n):\n            if nums[j] == 1:\n                count += 1\n            else:\n                break\n        res = max(res, (count // k) + ((count % k) > 0))\n        i += count\n    return res\n\ndef main():\n    print(min_k_bit_flips([0,1,0])) # Output: 4\n    print(min_k_bit_flips([1,0,1,0,1])) # Output: 3\n    print(min_k_bit_flips([0,1,0,1,1,1])) # Output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1705": "```\nimport heapq\n\ndef maxEatingApples(apples):\n    pq = []\n    for i in range(len(apples)):\n        if apples[i] > 0:\n            if pq and pq[0][0] < i:\n                eaten_apples, _ = heapq.heappop(pq)\n                eaten_apples += min(apples[i], 2)\n                if eaten_apples > 0:\n                    heapq.heappush(pq, (eaten_apples + i, eaten_apples))\n            else:\n                heapq.heappush(pq, (apples[i] + i, apples[i]))\n    return sum(heapq.nsmallest(len(pq), pq))\n\ndef main():\n    test_cases = [\n        ([1, 2], 3),\n        ([0, 0], 0),\n        ([5, 3, 10, 8, 2], 9)\n    ]\n\n    for apples, expected in test_cases:\n        result = maxEatingApples(apples)\n        if result == expected:\n            print(f\"Test case passed: {apples} -> {result}\")\n        else:\n            print(f\"Test case failed: {apples} -> {result} (Expected {expected})\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1706": "```\ndef whereWillTheBallFall(heights):\n    res = []\n    for h in heights:\n        if h > 0:\n            res.append(h)\n        else:\n            res.append(1)\n    return res\n\ndef main():\n    print(whereWillTheBallFall([4,2,0,3,2,5])) # [4,2,1,3,2,5]\n    print(whereWillTheBallFall([1,5,3,4,2,1])) # [1,2,3,4,2,1]\n    print(whereWillTheBallFall([9,8,7,6,5,4,3,2,1,0])) # [9,8,7,6,5,4,3,2,1,0]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1707": "```\ndef findMaximumXOR(root, n):\n    max_xor = float('-inf')\n    for i in range(n):\n        xor = root\n        for j in range(31,-1,-1):\n            bit = (nums[i] >> j) & 1 \n            if not xor&(1<<j):\n                xor |= 1<<j\n            else:\n                xor ^= 1<<j\n        max_xor = max(max_xor, nums[i]^xor)\n    return max_xor\n\ndef TrieNode():\n    return {\"val\":0,\"children\":{}}\n\ndef insert(root,val):\n    curr=root\n    for i in range(31,-1,-1):\n        bit = (val >> i) & 1 \n        if not curr[\"children\"].get(bit):\n            curr[\"children\"][bit]={\"val\":0,\"children\":{}}\n        curr=curr[\"children\"][bit]\n    curr[\"val\"]=val\n\ndef search(root,xor):\n    curr=root\n    for i in range(31,-1,-1):\n        bit = (xor >> i) & 1 \n        if \"0\" in curr[\"children\"]:\n            xor ^= 1<<i\n            curr=curr[\"children\"][\"0\"]\n        else:\n            xor ^= 1<<i\n            curr=curr[\"children\"][\"1\"]\n    return curr[\"val\"]\n\ndef main():\n    nums = [3,10,5,25,2,8]\n    n = len(nums)\n    root=TrieNode()\n    for i in range(n):\n        insert(root,nums[i])\n    \n    print(findMaximumXOR(root,n))\n\nif __name__ == \"__main__\":\n    main()\n\ntest_case_1 = [3,10,5,25,2,8]\nprint(\"Test Case 1:\", findMaximumXOR(TrieNode(), len(test_case_1)))\n\ntest_case_2 = [14,70,107,139]\nprint(\"Test Case 2:\", findMaximumXOR(TrieNode(), len(test_case_2)))\n\ntest_case_3 = [0]\nprint(\"Test Case 3:\", findMaximumXOR(TrieNode(), len(test_case_3)))\n```",
  "1708": "```\ndef maxEqualFrequency(nums, k):\n    if not nums:\n        return 0\n    \n    nums.sort()\n    left = 0\n    right = 0\n    max_len = 0\n    while right < len(nums) and (right - left + 1 <= k or right + 1 < len(nums)):\n        if right == len(nums)-1:\n            break\n        if nums[right+1] - nums[left] > 1:\n            left += 1\n        elif right - left + 1 == k:\n            max_len = max(max_len, k)\n            right += 1\n        else:\n            right += 1\n            \n    return max_len\n\ndef main():\n    print(maxEqualFrequency([5,3], 2)) # expected output: 2\n    print(maxEqualFrequency([6,1,2,5,4,3,7], 2)) # expected output: 2\n    print(maxEqualFrequency([1,17,5], 2)) # expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1709": "```\ndef largestTimeFromDigits(A):\n    max_time = -1\n    for h1, h2, i1, i2 in itertools.permutations(A):\n        if h2 == 5 or i2 == 9:\n            continue\n        hour = h1 * 10 + h2\n        minute = i1 * 10 + i2\n        if hour < 24 and minute < 60:\n            max_time = max(max_time, hour * 60 + minute)\n    return -1 if max_time == -1 else \"{:02d}:{:02d}\".format(*divmod(max_time, 60))\n\nimport itertools\n\ndef main():\n    print(largestTimeFromDigits([2,1,7,5])) \n    print(largestTimeFromDigits([9,8,7,6])) \n    print(largestTimeFromDigits([6,6,6,4]))\n\nmain()\n```",
  "1710": "```\ndef maximumUnits(boxTypes, truckSize):\n    boxTypes.sort(key=lambda x: x[1], reverse=True)\n    totalUnits = 0\n    for i in range(min(truckSize, len(boxTypes))):\n        totalUnits += boxTypes[i][1]\n    return totalUnits\n\ndef main():\n    print(\"Test Case 1:\")\n    print(maximumUnits([[1,3],[2,2],[3,1]], 4)) # Expected Output: 8\n    \n    print(\"\\nTest Case 2:\")\n    print(maximumUnits([[5,10],[2,5],[4,7],[3,9]], 10)) # Expected Output: 22\n    \n    print(\"\\nTest Case 3:\")\n    print(maximumUnits([[1,15],[2,12],[5,10],[4,8],[7,1]], 15)) # Expected Output: 32\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1711": "```\ndef countGoodMeals(timestamps, deadlines):\n    timestamps.sort()\n    deadlines.sort()\n    i, j = 0, 0\n    good_meals = 0\n    while i < len(timestamps) and j < len(deadlines):\n        if timestamps[i] <= deadlines[j]:\n            good_meals += 1\n            i += 1\n        j += 1\n    return good_meals\n\ndef main():\n    print(\"Test Case 1:\")\n    print(countGoodMeals([1,2,3,5], [1,4])) # Expected output: 3\n    print(\"\\nTest Case 2:\")\n    print(countGoodMeals([1,4,8,10], [5,6,7,9])) # Expected output: 2\n    print(\"\\nTest Case 3:\")\n    print(countGoodMeals([1,2,3,9], [2,5,13,15])) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1712": "```\ndef threeEqualParts(arr):\n    n = len(arr)\n    total_sum = sum(arr)\n    \n    if total_sum % 3 != 0:\n        return []\n    \n    target_sum = total_sum // 3\n    left, right = 0, n - 1\n    \n    while left < right:\n        if arr[left] + arr[right] == target_sum:\n            right -= 1\n        elif arr[left] + arr[right] > target_sum:\n            right -= 1\n        else:\n            left += 1\n    \n    if sum(arr[:left]) != target_sum:\n        return []\n    \n    return [left, n - right]\n\ndef main():\n    print(threeEqualParts([3,3,6,-2,-2]))\n    print(threeEqualParts([1,2,2,3]))\n    print(threeEqualParts([0,2,1,-6,6,-7,9,1,2,2]))\n\nmain()\n```",
  "1713": "```\ndef minOperations(nums):\n    n = len(nums)\n    for i in range(1, n):\n        if nums[i] <= nums[i-1]:\n            diff = nums[i-1] - nums[i] + 1\n            nums[i] += diff\n    return sum(nums) - max(nums)\n\ndef main():\n    print(minOperations([2,3,10,5,3]) == 2)\n    print(minOperations([7,8,9,11,12]) == 4)\n    print(minOperations([8,6,7,1,7]) == 0)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1714": "```\ndef sumOfSpecialEvenlySpacedElements(nums):\n    n = len(nums)\n    if n < 2:\n        return 0\n    ans = 0\n    for i in range(n):\n        if (i+1) % (n//2 + 1) == 0 and nums[i] % 2 == 0:\n            ans += nums[i]\n    return ans\n\ndef main():\n    print(sumOfSpecialEvenlySpacedElements([3, -2, 0, 1, -4])) # Test case 1\n    print(sumOfSpecialEvenlySpacedElements([-200, -92, 11, 5, -8, -9])) # Test case 2\n    print(sumOfSpecialEvenlySpacedElements([10])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1716": "```\ndef totalMoney(n):\n    total = 0\n    for i in range(1, n+1):\n        total += i + (i-1)\n    return total\n\ndef main():\n    print(totalMoney(4))  # Expected output: 18\n    print(totalMoney(10))  # Expected output: 45\n    print(totalMoney(20))  # Expected output: 210\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1715": "```\ndef countApplesAndOranges(s, t, a, b, apples):\n    for i in range(len(apples)):\n        if s <= (a + apples[i]) <= t:\n            print(f\"Apple {i+1} falls at position {(a + apples[i])}.\")\n        elif s <= (b + apples[i]) <= t:\n            print(f\"Apple {i+1} falls at position {(b + apples[i])}.\")\n\nif __name__ == \"__main__\":\n    main()\n\ndef main():\n    s = 7\n    t = 11\n    a = 5\n    b = 15\n    apples = [-2, 2, 1]\n    countApplesAndOranges(s, t, a, b, apples)\n    \n    print(\"\\nTest Case 2:\")\n    apples = [1,-2,1]\n    countApplesAndOranges(s, t, a, b, apples)\n    \n    print(\"\\nTest Case 3:\")\n    apples = [5]\n    countApplesAndOranges(s, t, a, b, apples)\n```",
  "1717": "```\ndef maximumScore(s: str) -> int:\n    n = len(s)\n    last_zero = -1\n    first_one = -1\n    score = 0\n    for i in range(n):\n        if s[i] == '0':\n            last_zero = i\n        elif s[i] == '1' and (first_one < 0 or i < first_one):\n            first_one = i\n    for i in range(last_zero, -1, -1):\n        score += 1\n    score += n - last_zero - 1\n    return score\n\ndef main():\n    print(maximumScore(\"011106\")) \n    print(maximumScore(\"0010\")) \n    print(maximumScore(\"11111\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1718": "```\ndef maxValidSequence(nums):\n    def backtrack(start, path, k):\n        if len(path) == k:\n            return [path]\n        result = []\n        for i in range(start, len(nums)):\n            if nums[i] > path[-1] + 1 or (not path and k <= 1):\n                new_path = path + [nums[i]]\n                valid_paths = backtrack(i, new_path, k)\n                if valid_paths:\n                    result.extend(valid_paths)\n        return result\n\n    k = int(input(\"Enter the length of the sequence: \"))\n    nums = list(map(int, input(\"Enter the array of numbers: \").split()))\n    nums.sort()\n    max_paths = backtrack(0, [], k)\n\n    for path in sorted(max_paths):\n        print(''.join(map(str, path)))\n\n\ndef main():\n    # Test case 1\n    nums = [10, 12]\n    k = 3\n    print(\"Expected output: 12, 12, 10\")\n    maxValidSequence(nums)\n    \n    # Test case 2\n    nums = [3, 4, 7, 5]\n    k = 2\n    print(\"Expected output: 5, 7\")\n    maxValidSequence(nums)\n\n    # Test case 3\n    nums = [10, 12, 20, 30]\n    k = 1\n    print(\"Expected output: 30\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1719": "```\nclass Solution:\n    def numWays(self, cpPairs: List[List[int]]) -> int:\n        # Your code here\n        pass\n\ndef main():\n    solution = Solution()\n\n    print(\"Test case 1:\")\n    cpPairs = [[1,2],[1,3]]\n    result = solution.numWays(cpPairs)\n    print(result)  # Expected output: 2\n\n    print(\"\\nTest case 2:\")\n    cpPairs = [[1,2],[2,3],[3,4],[1,3],[1,4]]\n    result = solution.numWays(cpPairs)\n    print(result)  # Expected output: 5\n\n    print(\"\\nTest case 3:\")\n    cpPairs = []\n    result = solution.numWays(cpPairs)\n    print(result)  # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1720": "```\ndef xorOperation(n, m):\n    result = [0] * n\n    for i in range(n):\n        result[i] = (m ^ (i << 1)) if i % 2 == 0 else (m ^ ((n - 1) - i))\n    return result\n\ndef main():\n    print(\"Test case 1:\")\n    print(xorOperation(5, 2)) \n    # Expected output: [3, 1]\n    \n    print(\"\\nTest case 2:\")\n    print(xorOperation(4, 3)) \n    # Expected output: [8, 4, 2]\n\n    print(\"\\nTest case 3:\")\n    print(xorOperation(10, 5)) \n    # Expected output: [11, 7, 6, 5, 5, 4, 4, 3]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1721": "```\ndef swapNodes(head, k):\n    if not head:\n        return None\n\n    dummy = ListNode(0)\n    dummy.next = head\n    pre1 = dummy\n    cur1 = dummy\n\n    for _ in range(k - 1):\n        cur1 = cur1.next\n        if not cur1:\n            return None\n\n    pre2 = cur1\n    cur2 = cur1.next\n\n    while cur2:\n        pre2 = pre2.next\n        cur2 = cur2.next\n\n    pre1.next = cur2\n    cur2.prev = pre1\n\n    cur1.next = cur2.next\n    if cur2.next:\n        cur2.next.prev = cur1\n    else:\n        cur2.next = None\n\n    return dummy.next\n\n\nclass ListNode:\n    def __init__(self, val=0, prev=None, next=None):\n        self.val = val\n        self.prev = prev\n        self.next = next\n\n\ndef main():\n    # Test case 1: Swap nodes at positions 1 and 2\n    head1 = ListNode(1)\n    head1.next = ListNode(2)\n    head1.next.next = ListNode(3)\n    print(\"Before swapping:\", end=\" \")\n    while head1:\n        print(head1.val, end=\" \")\n        head1 = head1.next\n    print()\n    head1 = swapNodes(head1, 2)\n    print(\"After swapping:\", end=\" \")\n    while head1:\n        print(head1.val, end=\" \")\n        head1 = head1.next\n    print()\n\n    # Test case 2: Swap nodes at positions 3 and 4\n    head2 = ListNode(5)\n    head2.next = ListNode(6)\n    head2.next.next = ListNode(7)\n    head2.next.next.next = ListNode(8)\n    print(\"Before swapping:\", end=\" \")\n    while head2:\n        print(head2.val, end=\" \")\n        head2 = head2.next\n    print()\n    head2 = swapNodes(head2, 4)\n    print(\"After swapping:\", end=\" \")\n    while head2:\n        print(head2.val, end=\" \")\n        head2 = head2.next\n    print()\n\n    # Test case 3: Swap nodes at positions 1 and 5 (edge case)\n    head3 = ListNode(9)\n    head3.next = ListNode(10)\n    head3.next.next = ListNode(11)\n    head3.next.next.next = ListNode(12)\n    print(\"Before swapping:\", end=\" \")\n    while head3:\n        print(head3.val, end=\" \")\n        head3 = head3.next\n    print()\n    head3 = swapNodes(head3, 5)\n    print(\"After swapping:\", end=\" \")\n    while head3:\n        print(head3.val, end=\" \")\n        head3 = head3.next\n    print()\n\n\nif __name__ == \"__main__\":\n    main()\n\n```",
  "1722": "```\ndef minHammingDistance(nums):\n    n = len(nums)\n    parent = list(range(n))\n    rank = [0] * n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            else:\n                parent[rootX] = rootY\n                if rank[rootX] == rank[rootY]: rank[rootY] += 1\n\n    ans = n - max([sum((nums[i] ^ nums[j]) for j in range(n)) for i in range(n)])\n    return ans\n\ndef main():\n    print(minHammingDistance([3,5,2,4]))\n    print(minHammingDistance([10,2]))\n    print(minHammingDistance([1,2,3,7]))\n\nmain()\n```",
  "1723": "```\ndef minTimeToFinishJobs(jobs, start, end):\n    ...\n\ndef main():\n    # Test case 1\n    jobs = [10,20,30,40]\n    start = 0\n    end = 1000000\n    print(minTimeToFinishJobs(jobs, start, end))\n    \n    # Test case 2\n    jobs = [3,2,7,9]\n    start = 500\n    end = 1500\n    print(minTimeToFinishJobs(jobs, start, end))\n    \n    # Test case 3\n    jobs = [5,4,6,1]\n    start = 1000\n    end = 3000\n    print(minTimeToFinishJobs(jobs, start, end))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1724": "```\ndef hasValidPath(grid):\n    m, n = len(grid), len(grid[0])\n    parent = {i: i for i in range(m * n)}\n    rank = [0] * (m * n)\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            if rank[rootX] > rank[rootY]:\n                parent[rootY] = rootX\n            else:\n                parent[rootX] = rootY\n                if rank[rootX] == rank[rootY]:\n                    rank[rootY] += 1\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 'B':\n                union(i * n + j, (m - 1) * n + (n - 1))\n            elif grid[i][j] == 'E':\n                parent[i * n + j] = i * n + (n - 1)\n\n    return find(0) == find((m - 1) * n + (n - 1))\n\ndef main():\n    test_case_1 = [\n        [\"0\",\"1\",\"0\",\"0\",\"0\",\"0\"],\n        [\"1\",\"1\",\"1\",\"0\",\"1\",\"0\"],\n        [\"0\",\"1\",\"0\",\"0\",\"1\",\"1\"],\n        [\"0\",\"0\",\"0\",\"1\",\"1\",\"6\"],\n        [\"0\",\"1\",\"1\",\"1\",\"5\",\"1\"],\n        [\"0\",\"1\",\"1\",\"5\",\"1\",\"2\"]\n    ]\n    print(hasValidPath(test_case_1))\n\n    test_case_2 = [\n        [\"0\",\"0\",\"0\",\"0\",\"0\",\"0\"],\n        [\"1\",\"1\",\"0\",\"0\",\"0\",\"0\"],\n        [\"0\",\"0\",\"1\",\"0\",\"0\",\"0\"],\n        [\"0\",\"0\",\"0\",\"1\",\"1\",\"6\"],\n        [\"0\",\"1\",\"1\",\"5\",\"5\",\"5\"],\n        [\"0\",\"2\",\"2\",\"2\",\"2\",\"4\"]\n    ]\n    print(hasValidPath(test_case_2))\n\n    test_case_3 = [\n        [\"0\",\"0\",\"0\",\"0\",\"0\",\"0\"],\n        [\"0\",\"0\",\"0\",\"0\",\"0\",\"1\"],\n        [\"0\",\"0\",\"0\",\"0\",\"1\",\"1\"],\n        [\"0\",\"0\",\"0\",\"1\",\"5\",\"6\"],\n        [\"0\",\"0\",\"1\",\"5\",\"5\",\"3\"],\n        [\"0\",\"1\",\"2\",\"3\",\"4\",\"7\"]\n    ]\n    print(hasValidPath(test_case_3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1725": "```\ndef countGoodRectangles(rectangles):\n    max_len = min(len(r) for r in rectangles)\n    best_len = -1\n    count = 0\n    for len_ in range(1, max_len + 1):\n        cols = [len([r for r in rectangles if len(r) == len_]) for _ in range(len_)]\n        good_len = min(i for i, col in enumerate(cols) if all(col[i] == col[0] for j in range(len_)))\n        count += sum(1 for col in cols if any(len_ == k and col[k] == 0 for k in range(len_)))\n        best_len = max(best_len, good_len)\n    return min(count // (best_len ** 2) + (count % (best_len ** 2) > 0), len(rectangles))\n\ndef main():\n    print(countGoodRectangles([[5,8,9,6],[1,3,4,10,6,7],[8,10]])\n    print(countGoodRectangles([[30,20,100,10,60,30]])\n    print(countGoodRectangles([]))\n    \nif __name__ == \"__main__\":\n    main()\n```",
  "1726": "```\ndef findDuplicate(nums):\n    seen = set()\n    for num in nums:\n        if num in seen:\n            return num\n        seen.add(num)\n\ndef main():\n    print(findDuplicate([1, 2, 3, 4, 5])) # Expected output: None\n    print(findDuplicate([1, 2, 3, 4, 4])) # Expected output: 4\n    print(findDuplicate([2, 2, 3, 5])) # Expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1727": "```\ndef maximal_square(grid):\n    if not grid:\n        return 0\n    \n    m, n = len(grid), len(grid[0])\n    max_side = 0\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if grid[i-1][j-1] == '1':\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n    \n    return max_side ** 2\n\ndef main():\n    print(maximal_square([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]])) # expected output: 4\n    print(maximal_square([[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1,\"\"1\"\",\"1\"\",\"1\"\",\"1\"\"]])) # expected output: 9\n    print(maximal_square([[\"0\",\"1\",\"0\",\"0\",\"1\"],[\"0\",\"1\",\"0\",\"0\",\"1\"],[\"0\",\"1\",\"1\",\"1\",\"1\"],[\"0\",\"0\",\"0\",\"1\",\"0\"]])) # expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1728": "```\ndef minimumHours(cookedRounds, totalRound):\n    if not cookedRounds:\n        return totalRound\n    m = len(cookedRounds)\n    dp = [[float('inf')] * (totalRound + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, m + 1):\n        for j in range(totalRound + 1):\n            if j >= cookedRounds[i - 1]:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - cookedRounds[i - 1]] + 1)\n            dp[i][j] = min(dp[i][j], dp[i][j])\n\n    return dp[m][totalRound]\n\ndef main():\n    print(minimumHours([10,20,30],40)) # Expected: 3\n    print(minimumHours([5,5],7)) # Expected: 2\n    print(minimumHours([],8)) # Expected: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1729": "```\ndef count_followers(queries):\n    followers = {}\n    for query in queries:\n        id1, id2 = map(int, query.split())\n        if id1 not in followers:\n            followers[id1] = set()\n        if id2 not in followers:\n            followers[id2] = set()\n        followers[id1].add(id2)\n        followers[id2].add(id1)\n\n    return [len(followers[i]) for i in followers]\n\ndef main():\n    queries = [[\"John\", \"Alice\"], [\"Alice\", \"Bob\"], [\"Bob\", \"John\"]]\n    result = count_followers(queries)\n    print(result)  # Output: [1, 2, 1]\n\n    queries = [[\"A\", \"B\"], [\"C\", \"D\"], [\"E\", \"F\"]]\n    result = count_followers(queries)\n    print(result)  # Output: [1, 1]\n\n    queries = [[\"0\", \"1\"], [\"1\", \"2\"], [\"2\", \"3\"], [\"3\", \"0\"]]\n    result = count_followers(queries)\n    print(result)  # Output: [2, 2, 2, 2]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1730": "```\ndef BFS(grid, start):\n    m, n = len(grid), len(grid[0])\n    directions = [(0,1),(0,-1),(1,0),(-1,0)]\n    visited = set()\n    queue = [start]\n    visited.add(start)\n    shortest_paths = {start: 0}\n\n    while queue:\n        x, y = queue.pop(0)\n        for dx, dy in directions:\n            nx, ny = x+dx, y+dy\n            if (1 <= nx < m) and (1 <= ny < n) and grid[nx][ny] == 1 and (nx, ny) not in visited:\n                queue.append((nx, ny))\n                visited.add((nx, ny))\n                shortest_paths[(nx, ny)] = shortest_paths.get(start, 0) + 1\n    return min(shortest_paths.values())\n\ndef main():\n    grid1 = [[1,0,1],[1,0,1],[0,0,0]]\n    print(BFS(grid1, (0,0))) # Expected: 4\n\n    grid2 = [[0,0,1],[0,0,0],[0,0,0]]\n    print(BFS(grid2, (2,2))) # Expected: 3\n\n    grid3 = [[1,0,0],[1,1,0],[9,0,1]]\n    print(BFS(grid3, (1,0))) # Expected: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1731": "```\ndef numDirectReports(n: int) -> dict:\n    def dfs(node):\n        if node not in tree:\n            return 0\n        count = 1\n        for child in tree[node]:\n            count += dfs(child)\n        return count\n\n    tree = {}\n    for employee_id, reports_to in data.items():\n        if reports_to not in tree:\n            tree[reports_to] = []\n        tree[employee_id] = [reports_to]\n    \n    return {emp: dfs(emp) for emp in tree}\n\ndef main():\n    data = {\n        1: None,\n        2: 1,\n        3: 1,\n        4: 2,\n        5: 2,\n        6: 3,\n        7: 3\n    }\n    \n    print(numDirectReports(4))  # Output: {1: 3, 2: 2, 3: 2}\n    print(numDirectReports(3))  # Output: {1: 2, 2: 2, 3: 2}\n    print(numDirectReports(7))  # Output: {1: 4, 2: 2, 3: 2}\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1732": "```\ndef highestAltitude(logs):\n    max_alt = 0\n    min_alt = 0\n    for i in range(len(logs)):\n        if logs[i][1] > min_alt:\n            min_alt = logs[i][1]\n        else:\n            min_alt = logs[i][1]\n        max_alt += logs[i][1] - logs[i][2]\n    return max_alt\n\ndef main():\n    test_cases = [\n        [[5, 3], [5, 2], [10, 1]], \n        [[3, 1], [4, 2], [2, 1]], \n        [[0, 0], [2, 1], [2, 1]]\n    ]\n    \n    for test_case in test_cases:\n        logs = [(x[1], x[0]) for x in test_case]\n        print(f\"Highest Altitude for {logs} is {highestAltitude(logs)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1733": "```\ndef minimumTeaches(n: int, teachers: List[int], students: List[int]) -> int:\n    teacher_count = {}\n    for student in students:\n        if student not in teacher_count:\n            teacher_count[student] = next((teacher for teacher in teachers if teacher <= student), None)\n    \n    return len(set(teacher_count.values()))\n\ndef main():\n    print(minimumTeaches(3, [1, 2], [1, 2, 3])) # Output: 1\n    print(minimumTeaches(5, [4], [1, 8, 2, 6, 3, 9])) # Output: 2\n    print(minimumTeaches(7, [10, 11, 12], [1, 2, 3, 4, 5, 6, 7])) # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1734": "```\ndef decode(xorPermutation):\n    n = len(xorPermutation)\n    permutation = [0] * (1 << n)\n    for i in range(1 << n):\n        for j in range(n):\n            permutation[i ^ (1 << j)] ^= xorPermutation[j]\n    return permutation\n\ndef main():\n    print(\"Test Case 1:\")\n    print(decode([3,1,4,2]))\n    \n    print(\"\\nTest Case 2:\")\n    print(decode([1,2,3]))\n\n    print(\"\\nTest Case 3:\")\n    print(decode([6,5,4,3,2,1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1735": "```\ndef numWays(n, m):\n    MOD = 10**9 + 7\n    dp = [[0] * (m+1) for _ in range(n+1)]\n    dp[0][0] = 1\n    for i in range(1, n+1):\n        for j in range(1, min(i+1, m+1)):\n            if i % j == 0:\n                dp[i][j] = (dp[i-1][j]+dp[i][j-1]) % MOD\n            else:\n                dp[i][j] = dp[i-1][j]\n    return sum(dp[-1])\n\ndef main():\n    print(numWays(3, 5)) # Test case 1: n=3, m=5\n    print(numWays(6, 3)) # Test case 2: n=6, m=3\n    print(numWays(10, 4)) # Test case 3: n=10, m=4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1736": "```\ndef maximumTime(time: str) -> int:\n    time = list(time)\n    for i in range(2):\n        if time[i] == '?':\n            if i == 0:\n                time[i] = '9' if time[1] <= '3' else '1'\n            elif time[i] == '?':\n                time[i] = '9'\n    return int(''.join(time)) * 100 + int(time[3]) * 60 + int(time[4:]) * 1\n\n\ndef main():\n    print(maximumTime(\"2?:0?\"))  # Output: 201900\n    print(maximumTime(\"0?:3?\"))  # Output: 093900\n    print(maximumTime(\"1?:22\"))   # Output: 122220\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1737": "```\ndef countDays(spans):\n    n = len(spans)\n    total_days = sum([end - start for start, end in spans]) * 2\n    days_in_condition = [1] * (n + 1)\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if not (spans[j][0] <= spans[i-1][0] and spans[i-1][0] < spans[j][1]):\n                days_in_condition[i] = max(days_in_condition[i], days_in_condition[j])\n\n    return total_days - min(days_in_condition)\n\ndef main():\n    print(countDays([[1,4],[2,3]])) \n    print(countDays([[1,5],[2,3]]))\n    print(countDays([[1,10],[2,6],[8,11],[12,16]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1738": "```\ndef kthLargestValue(matrix, K):\n    m, n = len(matrix), len(matrix[0])\n    xor_values = []\n    \n    for i in range(m):\n        for j in range(n):\n            if i == 0 or j == 0:\n                xor_values.append(matrix[i][j])\n            else:\n                xor_values.append(matrix[i][j] ^ matrix[i-1][j] ^ matrix[i][j-1] ^ matrix[i-1][j-1])\n    \n    xor_values.sort(reverse=True)\n    return xor_values[K-1]\n\ndef main():\n    test_case1 = [[0, 1], [1, 0]]\n    print(kthLargestValue(test_case1, 3))\n    \n    test_case2 = [[1, 1], [0, 0]]\n    print(kthLargestValue(test_case2, 2))\n    \n    test_case3 = [[5, 2], [1, 9]]\n    print(kthLargestValue(test_case3, 5))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1739": "```\ndef maxBoxes(int length):\n    if length < 1:\n        return 0\n    \n    boxes = []\n    \n    while length > 0:\n        if len(boxes) == 0 or boxes[-1] + 5 <= length:\n            boxes.append(5)\n            length -= 5\n        else:\n            prevBoxSize = boxes.pop()\n            boxes.append(prevBoxSize + 5)\n            length -= (prevBoxSize + 5)\n    \n    return len(boxes)\n\ndef main():\n    print(\"Test case 1: \", maxBoxes(10))\n    print(\"Test case 2: \", maxBoxes(15))\n    print(\"Test case 3: \", maxBoxes(20))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1740": "```\ndef findDistance(root, p, q):\n    parent_map = {root: None}\n    queue = [root]\n    \n    while queue:\n        node = queue.pop(0)\n        \n        if node.left:\n            parent_map[node.left] = node\n            queue.append(node.left)\n        if node.right:\n            parent_map[node.right] = node\n            queue.append(node.right)\n            \n    pq_dist = []\n    pq_dist.append(findDistanceFromNode(root, p, q, parent_map, pq_dist))\n    \n    return max(pq_dist)\n\ndef findDistanceFromNode(node, p, q, parent_map, pq_dist):\n    if node is None:\n        return 0\n    \n    if node == p or node == q:\n        return 1\n    \n    left_dist = findDistanceFromNode(node.left, p, q, parent_map, pq_dist)\n    right_dist = findDistanceFromNode(node.right, p, q, parent_map, pq_dist)\n    \n    if left_dist > 0 and right_dist > 0:\n        return max(left_dist, right_dist) + 1\n    \n    if node == parent_map[p]:\n        return left_dist + 1\n    elif node == parent_map[q]:\n        return right_dist + 1\n    \n    return min(left_dist, right_dist) + 1\n\n\ndef main():\n    class TreeNode:\n        def __init__(self, x):\n            self.val = x\n            self.left = None\n            self.right = None\n\n    root = TreeNode(3)\n    root.left = TreeNode(5)\n    root.right = TreeNode(1)\n    root.left.left = TreeNode(6)\n    root.left.right = TreeNode(2)\n    root.right.left = TreeNode(0)\n    root.right.right = TreeNode(8)\n    root.left.right.left = TreeNode(7)\n    root.left.right.right = TreeNode(4)\n\n    print(findDistance(root, root.left.right, root.right))  # Expected output: 3\n    print(findDistance(root, root.right, root.left.right.left))  # Expected output: 2\n    print(findDistance(root, root.left, root.left.right))  # Expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1741": "```\ndef total_time_spent(logs):\n    employee_times = {}\n    for log in logs:\n        employee, start_time, end_time = log\n        if employee not in employee_times:\n            employee_times[employee] = [0]\n        else:\n            employee_times[employee].append(end_time - start_time)\n    return {employee: sum(time) for employee, time in employee_times.items()}\n\ndef main():\n    logs1 = [(\"John\", 3600, 7200), (\"Jane\", 5400, 10800)]\n    print(total_time_spent(logs1))  # Output: {'John': 3600, 'Jane': 5400}\n\n    logs2 = [(\"Alice\", 9000, 14400), (\"Bob\", 10800, 21600), (\"Charlie\", 12600, 25200)]\n    print(total_time_spent(logs2))  # Output: {'Alice': 5400, 'Bob': 10800, 'Charlie': 12600}\n\n    logs3 = [(\"David\", 0, 3600), (\"Eve\", 7200, 14400), (\"Frank\", 10800, 21600)]\n    print(total_time_spent(logs3))  # Output: {'David': 3600, 'Eve': 7200, 'Frank': 10800}\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1742": "```\ndef numBalls(n, indexA, indexB):\n    return ((indexA + 1) * (indexA + 2)) // 2 - ((n - indexB - 1) * n // 2)\n\ndef main():\n    print(numBalls(10, 3, 4)) # Test case 1\n    print(numBalls(5, 1, 0))   # Test case 2\n    print(numBalls(8, 2, 6))   # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1743": "```\ndef restoreArray(nums):\n    n = len(nums)\n    if nums[0] == nums[-1]:\n        return [nums[0]] * (n - 2) + [nums[0], nums[n-1]]\n\n    start, end = float('inf'), float('-inf')\n    for num in nums:\n        start = min(start, num)\n        end = max(end, num)\n\n    res = []\n    i, j = 0, n - 1\n    while i < j:\n        if nums[i] == start:\n            res.append(nums[i])\n            i += 1\n        elif nums[j] == end:\n            res.append(nums[j])\n            j -= 1\n        else:\n            mid = (start + end) // 2\n            if nums[i] > mid and nums[j] > mid:\n                end, mid = mid, start\n            elif nums[i] < mid and nums[j] < mid:\n                start, mid = mid, end\n            if nums[i] == mid:\n                res.append(nums[i])\n                i += 1\n            else:\n                res.append(nums[j])\n                j -= 1\n\n    return res\n\n\ndef main():\n    test_cases = [\n        ([100, 4, 200, 1, 3, 2], [1, 4, 2, 3, 4, 2]),\n        ([1, 2, 3], [1, 1, 1]),\n        ([1000000000, 1000000000, 1], [1, 1000000000, 1000000000])\n    ]\n\n    for nums, expected in test_cases:\n        result = restoreArray(nums)\n        print(f\"Expected: {expected}, Got: {result}\")\n        if result == expected:\n            print(\"Test Case Passed\")\n        else:\n            print(\"Test Case Failed\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1744": "```\ndef canEatCandy(candies, days):\n    total = sum(candies)\n    if total % (sum(range(1, len(days) + 1)) * max(days)) != 0:\n        return False\n    for i in range(len(days)):\n        if candies[i] < days[i]:\n            return False\n    return True\n\ndef main():\n    test_cases = [\n        ([2, 3, 5, 4], [2, 3]), \n        ([7, 8, 9], [1, 2]), \n        ([10, 11, 12], [1, 2, 3])\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Test case: {test_case} - Can eat candy? {canEatCandy(*test_case)}\")\n        \nif __name__ == \"__main__\":\n    main()\n```",
  "1745": "```\ndef checkPartition(s):\n    n = len(s)\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n + 1):\n            if s[i:j].count('a') % 2 == 0:\n                dp[i][j] = (s[i:j].lower() == s[i:j].replace(\" \", \"\").replace(\",\", \"\").replace(\".\", \"\").replace(\"!\", \"\").replace(\"?\", \"\").reverse())\n            else:\n                dp[i][j] = False\n\n    return any(any(dp[i][j] for j in range(n + 1)) for i in range(n))\n\ndef main():\n    print(checkPartition(\"add\")) # Expected: True\n    print(checkPartition(\"abc\")) # Expected: False\n    print(checkPartition(\"a man a plan a canal panama\")) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1746": "```\ndef maxSumAfterOperation(nums):\n    n = len(nums)\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        if i == 1:\n            dp[i] = nums[0]\n        else:\n            dp[i] = max(dp[i-1], nums[i-1])\n    \n    return max(abs(nums[0] - dp[n]) + dp[n], abs(nums[-1] - dp[-2]) + dp[-1])\n\ndef main():\n    test_cases = [\n        [3, 8, -6, 2],\n        [-1, -4, 5, 7, 10],\n        [1, 4, -9, 8]\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Maximum Subarray Sum After One Operation: {maxSumAfterOperation(test_case)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1747": "```\ndef find_accounts(nums):\n    banned = set([str(i) for i in nums])\n    return [[i for i in accounts if str(i) not in banned] for accounts in accounts]\n\naccounts = [[\"John\", \"Mary\"], [\"John\"], [\"Jane\", \"Bob\", \"John\", \"Mary\"]]\nnums = [1, 4]\nprint(find_accounts(nums))\n\naccounts = [[\"John\", \"Mary\"], [\"John\", \"Jane\"], []]\nnums = [3, 2]\nprint(find_accounts(nums))\n\naccounts = [[], [\"John\", \"Jane\"], [\"John\"]]\nnums = [5, 0, 4]\nprint(find_accounts(nums))\n```",
  "1748": "```\ndef sum_of_unique_elements(nums):\n    return sum(set(nums))\n\ndef main():\n    print(sum_of_unique_elements([1,2,3,2])) \n    print(sum_of_unique_elements([1,1,1,1,5,5,5,5]))  \n    print(sum_of_unique_elements([7, 4, 7]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1750": "```\ndef minimumLengthWordCutByPaste(strs):\n    result = 0\n    for s in strs:\n        i, j = 0, len(s) - 1\n        while i < j:\n            if s[i] == s[j]:\n                break\n            i += 1\n            j -= 1\n        result = max(result, j - i + 1)\n    return result\n\ndef main():\n    print(minimumLengthWordCutByPaste([\"a\", \"ad\", \"adc\"])) \n    print(minimumLengthWordCutByPaste([\"leetcode\", \"love\", \"hello\"])) \n    print(minimumLengthWordCutByPaste([\"aaaa\", \"aa\", \"aaa\"])) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1749": "```\ndef maxAbsoluteSum(nums):\n    if not nums:\n        return 0\n    \n    max_sum = float('-inf')\n    min_sum = float('inf')\n    \n    current_max = 0\n    current_min = 0\n    \n    for num in nums:\n        new_current_max = max(num, current_max + num)\n        new_current_min = min(num, current_min + num)\n        \n        max_sum = max(max_sum, new_current_max)\n        min_sum = min(min_sum, new_current_min)\n        \n        current_max = new_current_max\n        current_min = new_current_min\n    \n    return max(abs(max_sum), abs(min_sum))\n\ndef main():\n    print(\"Test case 1:\")\n    print(maxAbsoluteSum([-3,2,-3,4,-2,5,1,-9,7,1,1,-4,2])) \n    # Output: 8\n\n    print(\"\\nTest case 2:\")\n    print(maxAbsoluteSum([1]))  \n    # Output: 1\n\n    print(\"\\nTest case 3:\")\n    print(maxAbsoluteSum([-7,1]) )   \n    # Output: 7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1751": "```\ndef maxEvents(events):\n    events.sort(key=lambda x: (x[1], x[0]))\n    dp = [0] * len(events)\n    for i in range(len(events)):\n        for j in range(i):\n            if events[j][1] <= events[i][0]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\ndef main():\n    print(maxEvents([[1,4],[2,3],[5,7]])) # Output: 3\n    print(maxEvents([[1,3],[4,5],[8,9],[6,7]])) # Output: 5\n    print(maxEvents([[1,4],[4,4]])) # Output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1752": "```\ndef checkArraySortedAndRotated(nums):\n    if len(nums) < 2:\n        return True\n\n    i = 0\n    while i < len(nums) - 1:\n        if nums[i] > nums[i+1]:\n            return False\n        i += 1\n\n    return True\n\n\ndef main():\n    test_cases = [\n        ([3, 4, 5, 1, 2], True),\n        ([1, 2, 3, 4, 5], True),\n        ([1, 2, 3, 4, 0], False)\n    ]\n\n    for test_case in test_cases:\n        result = checkArraySortedAndRotated(test_case[0])\n        if result == test_case[1]:\n            print(f\"Test case {test_case} passed.\")\n        else:\n            print(f\"Test case {test_case} failed.\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1753": "```\nimport heapq\n\ndef maxScore(nums):\n    stones = sorted((n, i) for i, n in enumerate(nums))\n    heap = []\n    score = 0\n    for stone, _ in stones:\n        if not heap or abs(stone - heap[0][0]) > abs(stone - heap[-1][0]):\n            heapq.heappush(heap, (stone,))\n        else:\n            heapq.heappop(heap)\n        score += sum(abs(stone - x) for x in heap)\n    return score\n\ndef main():\n    print(maxScore([5,4,10,2])) # 7\n    print(maxScore([3,5,1,2,4])) # 6\n    print(maxScore([1,2,3,4,5,100])) # 9\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1754": "```\ndef largestMerge(words):\n    res = \"\"\n    i, j = 0, 0\n    while i < len(words[0]) or j < len(words[1]):\n        if i < len(words[0]) and (j >= len(words[1]) or words[0][i] > words[1][j]):\n            res += words[0][i]\n            i += 1\n        elif j < len(words[1]) and (i >= len(words[0]) or words[0][i] <= words[1][j]):\n            res += words[1][j]\n            j += 1\n    return res\n\ndef main():\n    print(largestMerge([\"abc\",\"def\"])) # Expected Output: \"adbecf\"\n    print(largestMerge([\"cba\",\"abcdef\"])) # Expected Output: \"cbdafbec\"\n    print(largestMerge([\"abcd\",\"abcd\"])) # Expected Output: \"abcdabcd\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1755": "```\ndef sumOfSubseqSizes(nums):\n    n = len(nums)\n    prefixSum = [0] * (n + 1)\n    for i in range(n):\n        prefixSum[i + 1] = prefixSum[i] + nums[i]\n    \n    res, minDiff = float('inf'), float('inf')\n    for left in range(n):\n        for right in range(left, n):\n            curSum = prefixSum[right + 1] - prefixSum[left]\n            diff = abs(curSum) - (curSum > 0)\n            if diff < minDiff:\n                res = curSum\n                minDiff = diff\n    return res\n\ndef main():\n    print(sumOfSubseqSizes([2,-1,2]) == 3)\n    print(sumOfSubseqSizes([-1,3])) == -1)\n    print(sumOfSubseqSizes([0,0])) == 0)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1756": "```\ndef LRUCache(capacity):\n    class Node:\n        def __init__(self, key, value):\n            self.key = key\n            self.value = value\n            self.prev = None\n            self.next = None\n\n    class DoubleLinkedList:\n        def __init__(self):\n            self.head = None\n            self.tail = None\n\n        def add(self, node):\n            if not self.head:\n                self.head = node\n                self.tail = node\n            else:\n                node.next = self.head\n                self.head.prev = node\n                self.head = node\n\n        def remove(self, node):\n            if node.prev:\n                node.prev.next = node.next\n            else:\n                self.head = node.next\n            if node.next:\n                node.next.prev = node.prev\n            else:\n                self.tail = node.prev\n\n    class LRUCache:\n        def __init__(self, capacity):\n            self.capacity = capacity\n            self.cache = {}\n            self.dll = DoubleLinkedList()\n\n        def get(self, key):\n            if key in self.cache:\n                node = self.cache[key]\n                self.dll.remove(node)\n                self.dll.add(node)\n                return node.value\n            return -1\n\n        def put(self, key, value):\n            if key in self.cache:\n                self.dll.remove(self.cache[key])\n            node = Node(key, value)\n            self.cache[key] = node\n            self.dll.add(node)\n            if len(self.cache) > self.capacity:\n                node = self.dll.head\n                self.dll.remove(node)\n                del self.cache[node.key]\n\n    def main():\n        cache1 = LRUCache(2)\n        print(cache1.get(1))  # Returns 1\n        print(cache1.put(1, 1))\n        print(cache1.put(2, 2))\n        print(cache1.get(1))   # returns 1\n        print(cache1.put(3, 3)) \n        print(cache1.get(2))   # returns 2\n        print(cache1.get(3))   # returns 3\n        print(cache1.get(4))   # returns -1 (not found in cache)\n\n        cache2 = LRUCache(1)\n        print(cache2.put(1, 1)) \n        print(cache2.get(1))   # returns 1\n        print(cache2.put(2, 2))\n        print(cache2.get(1))   # returns 1\n        print(cache2.get(2))   # returns 2\n\n        cache3 = LRUCache(5)\n        print(cache3.put(0, 0))\n        print(cache3.get(0))    # returns 0\n        print(cache3.put(1, 1))\n        print(cache3.put(2, 2))\n        print(cache3.get(0))    # returns 0\n        print(cache3.get(1))    # returns 1\n        print(cache3.get(-1))   # returns -1 (not found in cache)\n        print(cache3.put(-1,-1)) \n        print(cache3.get(-1))   # returns -1\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "1757": "```\ndef product_filter(products):\n    return [product for product in products if \"Low Fat\" in product[\"category\"] or product[\"recyclable\"]]\n\ndef main():\n    products = [\n        {\"name\": \"Product A\", \"category\": \"Low Fat Milk\", \"recyclable\": True},\n        {\"name\": \"Product B\", \"category\": \"Regular Cheese\", \"recyclable\": False},\n        {\"name\": \"Product C\", \"category\": \"Low Fat Yogurt\", \"recyclable\": True},\n        {\"name\": \"Product D\", \"category\": \"High Fat Butter\", \"recyclable\": True}\n    ]\n\n    low_fat_recyclable_products = product_filter(products)\n\n    print(\"Low fat and recyclable products:\")\n    for product in low_fat_recyclable_products:\n        print(product[\"name\"])\n\nif __name__ == \"__main__\":\n    main()\n\ntest_cases = [\n    {\"products\": [{\"name\": \"Product E\", \"category\": \"Low Fat Milk\", \"recyclable\": True}, \n                  {\"name\": \"Product F\", \"category\": \"Regular Cheese\", \"recyclable\": False},\n                  {\"name\": \"Product G\", \"category\": \"Low Fat Yogurt\", \"recyclable\": True}],\n     \"expected_output\": [\"Product E\", \"Product G\"]},\n\n    {\"products\": [{\"name\": \"Product H\", \"category\": \"High Fat Butter\", \"recyclable\": True}, \n                  {\"name\": \"Product I\", \"category\": \"Low Fat Milk\", \"recyclable\": False},\n                  {\"name\": \"Product J\", \"category\": \"Regular Cheese\", \"recyclable\": True}],\n     \"expected_output\": []},\n\n    {\"products\": [{\"name\": \"Product K\", \"category\": \"Low Fat Yogurt\", \"recyclable\": True}, \n                  {\"name\": \"Product L\", \"category\": \"Low Fat Milk\", \"recyclable\": True},\n                  {\"name\": \"Product M\", \"category\": \"Regular Cheese\", \"recyclable\": False}],\n     \"expected_output\": [\"Product K\", \"Product L\"]}\n]\n\nfor test_case in test_cases:\n    products = test_case[\"products\"]\n    expected_output = test_case[\"expected_output\"]\n    actual_output = product_filter(products)\n    \n    if actual_output == expected_output:\n        print(\"Test case passed: \")\n        for product in products:\n            print(product[\"name\"])\n        print()\n    else:\n        print(f\"Test case failed. Expected {expected_output}, got {actual_output}.\")\n        for product in products:\n            print(product[\"name\"])\n        print()\n```",
  "1758": "```\ndef minChanges(s):\n    n = len(s)\n    res = 0\n    for i in range(1, n):\n        if (s[i-1] == s[i]):\n            res += 1\n    return res\n\n\ndef main():\n    print(minChanges(\"0102\"))  # Expected: 2\n    print(minChanges(\"0324\"))  # Expected: 2\n    print(minChanges(\"001\"))   # Expected: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1759": "```\ndef countHomogenous(s):\n    if not s:\n        return 0\n    \n    count = 0\n    i = 1\n    while i < len(s):\n        if s[i] == s[0]:\n            count += 1\n            i += 1\n        else:\n            break\n\n    return count + 1\n\n\ndef main():\n    test_cases = [\n        (\"bbbaaaba\", 4),\n        (\"abcbddddd\", 5),\n        (\"aaaaaaa\", 8)\n    ]\n\n    for test_case in test_cases:\n        input_string, expected_output = test_case\n        actual_output = countHomogenous(input_string)\n        if actual_output == expected_output:\n            print(\"Test Case Passed: \", input_string)\n        else:\n            print(\"Test Case Failed: \", input_string)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1760": "```\ndef minEarnings(time, speed):\n    n = len(time)\n    earnings = [0] * (n + 1)\n\n    for i in range(n):\n        if i > 0:\n            earnings[i + 1] = max(earnings[i], time[i] // speed + earnings[max(0, i - (time[i] // speed))]\n        else:\n            earnings[1] = time[0]\n\n    return earnings[-1]\n\n\ndef main():\n    print(minEarnings([10, 20], 2))  \n    print(minEarnings([5, 15, 25], 3))    \n    print(minEarnings([1, 2, 5], 1))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1761": "```\ndef minTrioDegree(graph):\n    graph = [list(x) for x in graph]\n    n = len(graph)\n    res = []\n    for i in range(n):\n        count = sum(1 for j in range(n) if graph[i][j] == 1 and (i != j))\n        if count >= 2:\n            for j in range(count):\n                k = next((k for k in range(n) if graph[i][k] == 1 and i != k), None)\n                res.append(min([graph[i].count(1) + graph[j].count(1) + graph[k].count(1)]))\n    return res\n\ndef main():\n    test_cases = [\n        [[3,1,4,2,5],[1,5,2,3,4,4,1,5,5,1,1,1], 2],\n        [[1,2,3,4,5,6,7,8,9,10,11],[1,2,3,1,2,4,3,5,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22], 0],\n        [[1,2,3],[1,2,3], 3]\n    ]\n\n    for test_case in test_cases:\n        graph = [list(map(int, x)) for x in test_case[1]]\n        result = minTrioDegree(graph)\n        if result == test_case[2]:\n            print(f\"Test case {test_case} passed!\")\n        else:\n            print(f\"Test case {test_case} failed. Expected: {test_case[2]}, got: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1762": "```\ndef findBuildings(heights):\n    stack = []\n    max_height = 0\n    result = []\n\n    for i, height in enumerate(heights):\n        while stack and heights[stack[-1]] <= height:\n            top = stack.pop()\n            while stack and heights[stack[-1]] == heights[top]:\n                stack.pop()\n        if not stack:\n            max_height = height\n        else:\n            max_height = heights[stack[-1]]\n        result.append(i)\n        stack.append(i)\n\n    return result\n\ndef main():\n    print(findBuildings([4,2,3,1,6,5]))\n    print(findBuildings([1,2,3,2,1,1,0]))\n    print(findBuildings([9,8,7,6,5]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1764": "```\ndef formArray(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if not arr1[i] + str(arr2[i]) in ''.join(map(str, arr1)):\n            return False\n    return True\n\ndef main():\n    print(formArray([\"ab\", \"cd\"], [\"ad\",\"bd\",\"xyzda\"])) \n    print(formArray([\"a\", \"b\"], [\"e\", \"f\"]))\n    print(formArray([\"abc\", \"cde\", \"fg\"], [\"abcd\", \"cdef\", \"ghij\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1763": "```\ndef longestNiceSubstring(s):\n    n = len(s)\n    max_length = 0\n    max_substring = \"\"\n    \n    for i in range(n):\n        for j in range(i+1, n+1):\n            substring = s[i:j]\n            if all((c.upper() == c.lower() and (ord(c.upper()) - ord('A') + 26) % 2 == 0) or (c.lower() != c) for c in substring):\n                max_length = max(max_length, len(substring))\n                max_substring = substring\n    return max_substring\n\ndef main():\n    print(longestNiceSubstring(\"YazaAxnY\")) # \"Axa\"\n    print(longestNiceSubstring(\"Bb\")) # \"Bb\"\n    print(longestNiceSubstring(\"acaab\")) # \"aca\"\n\nmain()\n```",
  "1766": "```\ndef mostCoprimeNumbers(root):\n    def dfs(node):\n        if not node:\n            return []\n        \n        res = [node.val]\n        left, right = dfs(node.left), dfs(node.right)\n        res += left\n        res += right\n        return res\n    \n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    max_coprime = 0\n    for num in dfs(root):\n        count = 0\n        for i in range(2, int(num**0.5) + 1):\n            if gcd(i, num) == 1:\n                count += 1\n        max_coprime = max(max_coprime, count)\n    \n    return max_coprime\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef main():\n    root = TreeNode(7)\n    root.left = TreeNode(6)\n    root.right = TreeNode(5)\n    root.left.left = TreeNode(4)\n    root.left.right = TreeNode(3)\n    root.right.left = TreeNode(2)\n    root.right.right = TreeNode(1)\n\n    print(mostCoprimeNumbers(root))  # Output: 4\n\n    root = TreeNode(15)\n    root.left = TreeNode(14)\n    root.right = TreeNode(13)\n    root.left.left = TreeNode(12)\n    root.left.right = TreeNode(11)\n    root.right.left = TreeNode(10)\n    root.right.right = TreeNode(9)\n\n    print(mostCoprimeNumbers(root))  # Output: 5\n\n    root = TreeNode(1)\n    print(mostCoprimeNumbers(root))  # Output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1765": "```\ndef highestPeak(grid):\n    m, n = len(grid), len(grid[0])\n    res = [[0]*n for _ in range(m)]\n    directions = [(0,1),(1,0),(0,-1),(-1,0)]\n\n    def dfs(i, j):\n        if i<0 or j<0 or i>=m or j>=n:\n            return 0\n        if res[i][j] > 0:\n            return res[i][j]\n        \n        for dx, dy in directions:\n            ni, nj = i+dx, j+dy\n            if grid[ni][nj] == '1':\n                res[i][j] = max(res[i][j], dfs(ni, nj)+1)\n        \n        return res[i][j]\n\n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                res[i][j] = dfs(i, j)\n\n    return res\n\ndef main():\n    test_cases = [\n        {\"grid\": [[\"0\", \"1\"], [\"0\", \"0\"]], \"expected_result\": [[0, 1]]},\n        {\"grid\": [[\"0\",\"1\",\"2\",\"3\"],[\"4\",\"5\",\"6\",\"7\"],[\"8\",\"9\",\"10\",\"11\"],[\"12\",\"13\",\"14\",\"15\"]], \n         \"expected_result\": [[-1,-1,-1,-1],[1,1,1,1],[7,7,7,7],[7,7,7,7]]},\n        {\"grid\": [[\"0\", \"0\", \"0\"], [\"0\", \"1\", \"0\"], [\"0\", \"0\", \"0\"]], \n         \"expected_result\": [[-1, 0, -1], [-1, 1, -1], [-1, -1, -1]]}\n    ]\n\n    for test_case in test_cases:\n        result = highestPeak(test_case[\"grid\"])\n        if result != test_case[\"expected_result\"]:\n            print(\"Test case failed. Expected: \", test_case[\"expected_result\"], \" Got: \", result)\n        else:\n            print(\"Test case passed.\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1767": "```\ndef findUnfinishedSubtasks(timeToFinishTasks, tasksAndTimeFinished):\n    unfinished_subtasks = []\n    for task, time in tasksAndTimeFinished:\n        if time < task['timeToFinish']:\n            unfinished_subtasks.append(task)\n    return unfinished_subtasks\n\n\ndef main():\n    test_cases = [\n        {\n            \"timeToFinishTasks\": [{\"id\": 1, \"timeToFinish\": 10}, {\"id\": 2, \"timeToFinish\": 20}],\n            \"tasksAndTimeFinished\": [(\"Task A\", 5), (\"Task B\", 15)],\n            \"expected_result\": [{\"id\": 1, \"name\": \"Task A\"}]\n        },\n        {\n            \"timeToFinishTasks\": [{\"id\": 1, \"timeToFinish\": 10}, {\"id\": 2, \"timeToFinish\": 20}],\n            \"tasksAndTimeFinished\": [(\"Task A\", 5), (\"Task B\", 25)],\n            \"expected_result\": []\n        },\n        {\n            \"timeToFinishTasks\": [{\"id\": 1, \"timeToFinish\": 10}, {\"id\": 2, \"timeToFinish\": 20}],\n            \"tasksAndTimeFinished\": [(\"Task A\", 15), (\"Task B\", 18)],\n            \"expected_result\": [{\"id\": 1, \"name\": \"Task C\"}]\n        }\n    ]\n\n    for test_case in test_cases:\n        result = findUnfinishedSubtasks(test_case[\"timeToFinishTasks\"], [(task[\"id\"], time) for task, time in test_case[\"tasksAndTimeFinished\"]])\n        if result == test_case[\"expected_result\"]:\n            print(\"Test case passed\")\n        else:\n            print(f\"Test case failed: expected {test_case['expected_result']}, got {result}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1768": "```\ndef mergeAlternates(str1, str2):\n    result = \"\"\n    i, j = 0, 0\n    while i < len(str1) or j < len(str2):\n        if i < len(str1) and j < len(str2):\n            result += str1[i]\n            i += 1\n            result += str2[j]\n            j += 1\n        elif i < len(str1):\n            result += str1[i]\n            i += 1\n        else:\n            result += str2[j]\n            j += 1\n    return result\n\ndef main():\n    print(mergeAlternates(\"abc\", \"pqr\") == \"apbqcr\")\n    print(mergeAlternates(\"ab\", \"pqrs\") == \"abpqsr\")\n    print(mergeAlternates(\"\", \"\") == \"\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1769": "```\ndef minOperations(n):\n    res = []\n    for i in range(1, n+1):\n        res.append(min(i-1, n-i))\n    return sum(res)\n\ndef main():\n    print(minOperations(5))  # Expected output: 8\n    print(minOperations(10))  # Expected output: 20\n    print(minOperations(3))   # Expected output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1770": "```\ndef maxScore(nums):\n    n = len(nums)\n    dp = [0] * (n + 1)\n    \n    for i in range(1, n + 1):\n        dp[i] = nums[i - 1]\n        for j in range(i - 1, -1, -1):\n            if nums[j] > nums[i - 1]:\n                dp[i] = max(dp[i], dp[j] * nums[i - 1])\n    \n    return dp[n]\n\ndef main():\n    test_cases = [\n        ([2,2,2],), # Test case 1\n        ([4,3,2,5],), # Test case 2\n        ([3,6,7,10],) # Test case 3\n    ]\n\n    for nums in test_cases:\n        result = maxScore(nums)\n        print(f\"Input: {nums}, Output: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1771": "```\ndef maxPalindromes(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    i_max = 0\n    for i in range(n - 1, -1, -1):\n        for j in range(i, n + 1):\n            if s[i] == s[j - 1]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n                i_max = max(i_max, dp[i][j])\n    return i_max\n\ndef main():\n    print(maxPalindromes(\"abccccdd\")) # Expected: 7\n    print(maxPalindromes(\"a\")) # Expected: 1\n    print(maxPalindromes(\"\")) # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1772": "```\ndef sortFeatures(features):\n    featureMap = {}\n    for feature in features:\n        if feature in featureMap:\n            featureMap[feature] += 1\n        else:\n            featureMap[feature] = 1\n    \n    sortedFeatures = sorted(featureMap.items(), key=lambda x: x[1], reverse=True)\n    \n    return [item[0] for item in sortedFeatures]\n\ndef main():\n    testCases = [\n        {\"features\": [\"a\", \"b\", \"c\", \"d\"], \"expected\": [\"d\", \"c\", \"b\", \"a\"]},\n        {\"features\": [\"dog\", \"cat\", \"fish\", \"bird\"], \"expected\": [\"fish\", \"bird\", \"dog\", \"cat\"]},\n        {\"features\": [\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"], \"expected\": [\"elderberry\", \"cherry\", \"date\", \"banana\", \"apple\"]}\n    ]\n    \n    for testCase in testCases:\n        result = sortFeatures(testCase[\"features\"])\n        print(f\"Input: {testCase['features']}, Expected: {testCase['expected']}, Result: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1773": "```\ndef countMatches(.rules, items):\n    ans = 0\n    for i in range(len(items)):\n        if rules[0][i%3] == items[i][0]:\n            if rules[1][i%3] == items[i][1]:\n                if rules[2][i%3] == items[i][2]:\n                    ans += 1\n    return ans\n\ndef main():\n    test_case1 = [[\"head\",\"tail\"], [\"head\", \"tail\"], [\"red\", \"green\"], [\"red\", \"blue\"], [\"blue\", \"green\"]]\n    print(countMatches([\"head:cow,tail:cat\", \"head:cow,tail:dog\", \"head:mouse,tail:cat\", \"head:mouse,tail:dog\", \"head:mouse,tail:cat\"], test_case1))\n    \n    test_case2 = [[\"top\",\"bottom\"], [\"left\",\"right\"], [\"blue\",\"white\"], [\"green\",\"black\"]]\n    print(countMatches([\"top:shirt,bottom:jeans\", \"left:right,left:red\"], test_case2))\n\n    test_case3 = [[\"head\",\"tail\"], [\"head\",\"tail\"],[\"red\",\"green\"],[\"red\",\"blue\"],[\"blue\",\"green\"]]\n    print(countMatches([\"head:cow,tail:cat,head:mouse,tail:dog,head:mouse,tail:cat\"], test_case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1774": "```\ndef maxAmount(time, costs):\n    dp = [0] * (time + 1)\n    for i in range(1, time + 1):\n        temp = dp[i - 1]\n        for j in range(i):\n            if j > 0:\n                temp = max(temp, dp[j] + min(costs[i], costs[j]))\n        dp[i] = temp\n    return dp[-1]\n\ndef main():\n    print(maxAmount(10, [3,4,2,6,8,5]))  # Expected output: 30\n    print(maxAmount(20, [7,6,5,4,3,2]))  # Expected output: 22\n    print(maxAmount(50, [100,500,400,300,200,150]))  # Expected output: 550\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1775": "```\ndef minOperations(intervals):\n    intervals.sort()\n    operations = []\n    for i in range(len(intervals)):\n        if i == len(intervals) - 1:\n            break\n        else:\n            diff = abs(intervals[i] + intervals[-1] - 2 * intervals[i+1])\n            operations.append(diff)\n    return min(operations)\n\ndef main():\n    print(minOperations([1,3,5])) # Expected output: 0\n    print(minOperations([6,9,14,17])) # Expected output: 2\n    print(minOperations([8,10])) # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1776": "```\ndef trimTireDistance(distance):\n    stack = []\n    result = []\n\n    for i in range(len(distance) - 1):\n        while len(stack) > 0 and distance[stack[-1]] < distance[i] - (distance[i] - distance[stack[-1]]) // 2:\n            lastpos = stack.pop()\n            if len(stack) == 0 or distance[i] - distance[lastpos] >= distance[stack[-1]] - distance[lastpos]:\n                result.append(i - lastpos)\n        stack.append(i)\n\n    while len(stack):\n        lastpos = stack.pop()\n        result.append(len(distance) - 1 - lastpos)\n\n    return result\n\ndef main():\n    print(trimTireDistance([10, 6, 4, 5, 8]))  # [3]\n    print(trimTireDistance([3, 7, 5, 2, 8, 9, 6, 1, 4, 10]))  # [5, 2, 1]\n    print(trimTireDistance([1, 3, 2]))  # []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1777": "```\ndef productPricePerStore(prices):\n    result = {}\n    for price in prices:\n        store_id, store_price = price.split()\n        store_id = int(store_id)\n        store_price = float(store_price)\n        if store_id not in result:\n            result[store_id] = []\n        result[store_id].append(store_price)\n    return {k: sum(v) / len(v) for k, v in result.items()}\n\ndef main():\n    test_cases = [\n        {\"prices\": [\"1 2.0\", \"1 3.0\", \"1 4.0\", \"2 5.0\", \"2 6.0\"]},\n        {\"prices\": [\"10 100.0\", \"11 110.0\", \"12 120.0\", \"13 130.0\", \"14 140.0\"]},\n        {\"prices\": [\"1 50.0\", \"2 60.0\", \"3 70.0\", \"4 80.0\", \"5 90.0\"]}\n    ]\n    \n    for test_case in test_cases:\n        prices = [price.split() for price in test_case[\"prices\"]]\n        result = productPricePerStore([item for sublist in prices for item in sublist])\n        print(f\"Test case: {test_case}\")\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1778": "```\ndef hasValidPath(grid):\n    if not grid or not grid[0]:\n        return False\n    R, C = len(grid), len(grid[0])\n    visited = [[False]*C for _ in range(R)]\n    \n    def dfs(r, c):\n        if r < 0 or c < 0 or r >= R or c >= C:\n            return False\n        if visited[r][c]:\n            return True\n        \n        if grid[r][c] == '1':\n            return True\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        for dr, dc in directions:\n            nr, nc = r+dr, c+dc\n            if dfs(nr, nc):\n                return True\n        \n        return False\n    \n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '1':\n                visited[i][j] = True\n                if dfs(i, j):\n                    return True\n    return False\n\ndef main():\n    test_cases = [\n        {\"grid\": [\"0\", \"0\", \"0\"], \"expected_result\": False},\n        {\"grid\": [\"0\", \"1\", \"0\"], \"expected_result\": True},\n        {\"grid\": [\"1\", \"1\", \"1\"], \"expected_result\": True}\n    ]\n\n    for test_case in test_cases:\n        grid = [list(test_case[\"grid\"])]\n        result = hasValidPath(grid)\n        if result == test_case[\"expected_result\"]:\n            print(\"Test case passed: \")\n        else:\n            print(\"Test case failed: \")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1779": "```\ndef nearestValidPoint(x1, y1, x2, y2, x3, y3):\n    distance = float('inf')\n    result = (-1, -1)\n    \n    if (x1 == x2 or y1 == y2) and ((x3 - x1) ** 2 + (y3 - y1) ** 2 < distance ** 2):\n        distance = ((x3 - x1) ** 2 + (y3 - y1) ** 2) ** 0.5\n        result = (x1, y1)\n    \n    if (x2 == x3 or y2 == y3) and ((x3 - x2) ** 2 + (y3 - y2) ** 2 < distance ** 2):\n        distance = ((x3 - x2) ** 2 + (y3 - y2) ** 2) ** 0.5\n        result = (x2, y2)\n    \n    return result\n\ndef main():\n    print(nearestValidPoint(1, 1, 1, 1, 4, 6))  # Output: (1, 1)\n    print(nearestValidPoint(3, 1, 3, 5, -2, 6))  # Output: (-2, 6)\n    print(nearestValidPoint(-1, 0, 0, 4, 2, 1))  # Output: (0, 4)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1780": "```\ndef is_sum_of_powers_of_three(n):\n    if n < 1:\n        return False\n    for i in range(int(math.log(n, 3)), -1, -1):\n        if pow(3, i) > n:\n            break\n        while n >= pow(3, i):\n            j = int(math.log(n - pow(3, i), 3))\n            if j == i:\n                return True\n            n -= pow(3, i)\n    return False\n\ndef main():\n    print(is_sum_of_powers_of_three(12)) # Test case 1: Expected output is True.\n    print(is_sum_of_powers_of_three(15)) # Test case 2: Expected output is False.\n    print(is_sum_of_powers_of_three(81)) # Test case 3: Expected output is True.\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1781": "```\ndef beautySum(s):\n    n = len(s)\n    res = 0\n    for i in range(n):\n        left, right = [ord(c) - ord('a') for c in s[:i]], [ord(c) - ord('a') for c in s[i+1:]]\n        count = [0] * 26\n        for char in left:\n            count[char] += 1\n        for char in right:\n            count[25 - char] += 1\n        res += sum((count[i] - min(count)) * (max(count) - count[i]) for i in range(26))\n    return res\n\ndef main():\n    print(beautySum(\"aabcbaba\")) \n    print(beautySum(\"aabbccc\"))  \n    print(beautySum(\"abcabcabc\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1782": "```\ndef countPairs(root):\n    ...\n\ndef main():\n    root1 = [1,2,4,4,7]\n    root2 = [1,1,1,1,1]\n    root3 = [0]\n\n    print(countPairs(root1))  # Expected output: 8\n    print(countPairs(root2))  # Expected output: 10\n    print(countPairs(root3))  # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1783": "```\ndef numberOfWays(players, levels):\n    n = len(players)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n        dp[i][i] = 1\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length\n            dp[i][j] = (dp[i][j-1] if j > i else 0) + (dp[j-1][j] if j > i else 0)\n\n    res = 0\n    for i in range(n):\n        res += dp[players[i]][n-1]\n\n    return res\n\ndef main():\n    print(numberOfWays([2,3,4], 10)) # Expected: 7\n    print(numberOfWays([1,3,5], 20)) # Expected: 12\n    print(numberOfWays([6,7,8], 15)) # Expected: 9\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1784": "```\ndef hasAtMostOneSegment(s):\n    ones = 0\n    for c in s:\n        if c == '1':\n            ones += 1\n        else:\n            if ones > 1:\n                return False\n            ones = 0\n    return ones <= 1\n\n\ndef main():\n    print(hasAtMostOneSegment(\"100001110011\") == True)\n    print(hasAtMostOneSegment(\"00000111\") == False)\n    print(hasAtMostOneSegment(\"111\") == True)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1785": "```\ndef minElements(nums, total):\n    if not nums:\n        return -1\n    max_val = max(nums)\n    remaining_sum = total - sum(nums)\n    return (remaining_sum + max_val - 1) // (max_val - 1)\n\ndef main():\n    print(minElements([18], 2)) # Expected output: 2\n    print(minElements([5,15,40,90], 95)) # Expected output: 1\n    print(minElements([4,5,9,1,21,45,80,108], 136)) # Expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1786": "```\ndef restrictedPathCount(edges, maxCitizens):\n    graph = {}\n    for edge in edges:\n        if edge[0] not in graph:\n            graph[edge[0]] = []\n        if edge[1] not in graph:\n            graph[edge[1]] = []\n        graph[edge[0]].append(edge[1])\n    visited = set()\n    def dfs(node, maxCitizens):\n        if node not in graph:\n            return 1\n        if node in visited:\n            return 0\n        visited.add(node)\n        totalPaths = 1\n        for neighbor in graph[node]:\n            if len(graph[neighbor]) > maxCitizens:\n                continue\n            totalPaths += dfs(neighbor, maxCitizens)\n        return totalPaths\n\n    return dfs(0, maxCitizens)\n\ndef main():\n    print(restrictedPathCount([[0,1],[2,3],[1,3]], 3)) # Expected output: 6\n    print(restrictedPathCount([[0,1],[2,3],[1,3],[4,5]], 3)) # Expected output: 7\n    print(restrictedPathCount([[1,0],[0,2},{3,3},{3,4},{2,1},{2,3},{4,5},{5,6]}, 4)) # Expected output: 13\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1787": "```\ndef equal_function(matrix):\n    m = len(matrix)\n    n = len(matrix[0])\n    prefix_xor = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            prefix_xor[i][j] = matrix[i - 1][j - 1] ^ prefix_xor[i - 1][j] ^ prefix_xor[i][j - 1]\n    \n    result = [0] * (m + m)\n    for i in range(m):\n        for j in range(n):\n            result[i + j] ^= matrix[i][j]\n    return prefix_xor[m][n] == 0 and all(xor_val ^ prefix_xor[j][i] for j in range(m) for xor_val in result)\n\ndef main():\n    print(equal_function([[0,1],[1,1]]))\n    print(equal_function([[0,1,0],[1,1,1],[0,1,1]]))\n    print(equal_function([[0,0,0],[0,0,1]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1788": "```\ndef totalBeauty(arr):\n    n = len(arr)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + arr[i]\n    \n    max_beauty = float('-inf')\n    for left in range(n):\n        for right in range(left, n):\n            if right - left > 0:\n                beauty = (prefix_sum[right + 1] - prefix_sum[left]) ** 2\n                if beauty > max_beauty:\n                    max_beauty = beauty\n    return max_beauty\n\ndef main():\n    test_cases = [\n        ([1, 3, 5, 8], 9),\n        ([11, 2, 5, 7], 14),\n        ([0, 0, 0, 0, 0, 0], 0)\n    ]\n\n    for case in test_cases:\n        arr = case[0]\n        expected = case[1]\n        result = totalBeauty(arr)\n        if result == expected:\n            print(f\"Test case {case} passed\")\n        else:\n            print(f\"Test case {case} failed: Expected {expected}, but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1789": "```\ndef findPrimaryDepartment(employees):\n    department_count = {}\n    for employee in employees:\n        if employee[1] not in department_count:\n            department_count[employee[1]] = 0\n        department_count[employee[1]] += 1\n    \n    primary_departments = []\n    max_department_size = 0\n    for department, size in department_count.items():\n        if size > max_department_size:\n            max_department_size = size\n            primary_departments = [department]\n        elif size == max_department_size:\n            primary_departments.append(department)\n    \n    return primary_departments\n\ndef main():\n    employees = [[\"John\", \"Sales\"], [\"Lisa\", \"Marketing\"], [\"Mark\", \"IT\"], \n                 [\"Lucy\", \"Sales\"], [\"Luke\", \"Sales\"]]\n    print(findPrimaryDepartment(employees))\n\n    employees = [[\"Alice\", \"HR\"], [\"Bob\", \"Finance\"], [\"Eve\", \"HR\"], \n                 [\"Frank\", \"HR\"], [\"George\", \"Finance\"]]\n    print(findPrimaryDepartment(employees))\n\n    employees = [[\"Sarah\", \"IT\"], [\"Tom\", \"IT\"], [\"Mary\", \"Sales\"], \n                 [\"Kevin\", \"Marketing\"], [\"Emily\", \"IT\"]]\n    print(findPrimaryDepartment(employees))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1790": "```\ndef canBeEqual(target: str, s: str) -> bool:\n    target_count = {}\n    for c in target:\n        if c in target_count:\n            target_count[c] += 1\n        else:\n            target_count[c] = 1\n\n    for i in range(len(s)):\n        if s[i] not in target_count or target_count[s[i]] == 0:\n            return False\n        target_count[s[i]] -= 1\n\n    return True\n\n\ndef main():\n    print(canBeEqual(\"abc\", \"badc\")) # Expected: True\n    print(canBeEqual(\"ab\", \"ba\")) # Expected: False\n    print(canBeEqual(\"aaabbsssccc\", \"aaaabssscscc\")) # Expected: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1791": "```\ndef findCenter(emails):\n    res = {}\n    for email in emails:\n        node1, node2 = email.split('@')[0].split('.')\n        if node1 not in res:\n            res[node1] = 0\n        if node2 not in res:\n            res[node2] = 0\n        res[node1] += 1\n        res[node2] += 1\n    for key, value in res.items():\n        if value == 3:\n            return int(key)\n    return None\n\ndef main():\n    print(findCenter([\"john.newark@ciudad.ro\", \"johnny.bravo@leetcode.com\", \"john.newark@ciudad.ro\"])) \n    print(findCenter([\"joe.khan@bl.co\", \"ahmed.jara@bl.co\", \"nancy.smith@bl.com\"])) \n    print(findCenter([\"w.art@le.tcode.com\", \"m.layalay@le.tcode.com\", \"b.richter@le.tcode.com\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1792": "```\nimport heapq\n\ndef averagePassRatio(students):\n    student_scores = [sum(score) for score in students]\n    min_heap = []\n    for score in student_scores:\n        if not min_heap or score < -min_heap[0]:\n            heapq.heappush(min_heap, -score)\n        else:\n            heapq.heappushpop(min_heap, -score)\n\n    return sum(-heapq.nsmallest(len(students), min_heap)) / len(students)\n\n\ndef main():\n    test_cases = [\n        ([[1, 2], [3, 4]], 0.5),\n        ([[1, 1, 1], [1, 1, 1], [1, 1, 1]], 1.0),\n        ([[10, 20, 30], [40, 50, 60], [70, 80, 90]], 0.6666666666666666)\n    ]\n\n    for students, expected_average_pass_ratio in test_cases:\n        average_pass_ratio = averagePassRatio(students)\n        if average_pass_ratio == expected_average_pass_ratio:\n            print(f\"Test case passed: {students} -> {average_pass_ratio}\")\n        else:\n            print(f\"Test case failed: {students} expected {expected_average_pass_ratio}, got {average_pass_ratio}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1793": "```\ndef maxGoodness(nums):\n    n = len(nums)\n    ans = 0\n    left = 0\n    for right in range(n):\n        while nums[right] > '0' and (left == 0 or nums[left-1] <= '0'):\n            left += 1\n        ans = max(ans, int(nums[left-1]) - int(nums[right]))\n    return ans\n\ndef main():\n    print(maxGoodness([\"23\",\"7\", \"-4\", \"10\", \"6\"])) # Test case 1\n    print(maxGoodness([ \"9\", \"13\", \"0\", \"5\", \"7\" ])) # Test case 2\n    print(maxGoodness([-7, 7, -8, 3, 0])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1794": "```\ndef minMaliciousStrangulations(s: str) -> int:\n    n = len(s)\n    prefix_sum = {0: -1}\n    current_sum = 0\n    res = 0\n\n    for i in range(n):\n        if s[i] == '1':\n            current_sum += 1\n        else:\n            current_sum -= 1\n        if current_sum not in prefix_sum:\n            prefix_sum[current_sum] = i\n        if current_sum > 0 and (current_sum - 1) in prefix_sum:\n            res += min(i, n-1) - prefix_sum[current_sum - 1]\n    return res\n\ndef main():\n    print(minMaliciousStrangulations(\"01110\")) # expected output: 9\n    print(minMaliciousStrangulations(\"11\")) # expected output: 2\n    print(minMaliciousStrangulations(\"1010101\")) # expected output: 4",
  "1795": "```\ndef productExceptSelf(products):\n    n = len(products)\n    answer = [1]*n\n    left_product = 1\n    for i in range(n):\n        answer[i] *= left_product\n        left_product *= products[i]\n    right_product = 1\n    for i in reversed(range(n)):\n        answer[i] *= right_product\n        right_product *= products[i]\n    return answer\n\ndef main():\n    test_cases = [\n        {\"products\": [1,2,3,4], \"expected\": [12,24,36,24]},\n        {\"products\": [-1,1,-1,1], \"expected\": [1,-1,1,-1]},\n        {\"products\": [0, 8, 0, 7], \"expected\": [8, 0, 0, 56]}\n    ]\n    \n    for test_case in test_cases:\n        products = test_case[\"products\"]\n        expected = test_case[\"expected\"]\n        \n        result = productExceptSelf(products)\n        \n        if result == expected:\n            print(\"Test case passed: \" + str(test_case))\n        else:\n            print(\"Test case failed: \" + str(test_case))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1796": "```\ndef secondHighest(s):\n    s = set(map(int, filter(str.isdigit, s)))\n    if len(s) < 2:\n        return -1\n    s = list(sorted(s))\n    return str(s[-2])\n\ndef main():\n    print(secondHighest(\"dfa12345afd\")) # Test Case 1\n    print(secondHighest(\"abc11010xyz\")) # Test Case 2\n    print(secondHighest(\"4258901245\")) # Test Case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1798": "```\ndef maxConsecutive(nums):\n    if not nums:\n        return 0\n\n    nums.sort()\n    max_count = 1\n    current_count = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] - nums[i-1] == 1:\n            current_count += 1\n        else:\n            max_count = max(max_count, current_count)\n            current_count = 1\n\n    return max(max_count, current_count)\n\n\ndef main():\n    print(maxConsecutive([2,3,4,5])) # expected output: 4\n    print(maxConsecutive([1,2,3,5,7])) # expected output: 3\n    print(maxConsecutive([1,9,10,11,15])) # expected output: 4\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1797": "```\nclass AuthenticationManager:\n    def __init__(self, timeToLive):\n        self.users = {}\n        self.time_to_live = timeToLive\n\n    def generateSecret(self, userId: str, duration: int) -> str:\n        if userId not in self.users:\n            self.users[userId] = {'secret': f'secret_{userId}', 'time': time.time() + duration}\n        return self.users[userId]['secret']\n\n    def getSecret(self, userId: str) -> str:\n        if userId in self.users and time.time() - self.users[userId]['time'] < self.time_to_live:\n            return self.users[userId]['secret']\n        return ''\n\ndef main():\n    manager = AuthenticationManager(5)\n    \n    print(\"Test Case 1:\")\n    print(manager.generateSecret(\"user1\", 3)) # \"secret_user1\"\n    print(manager.getSecret(\"user1\")) # \"secret_user1\"\n    print()\n\n    print(\"Test Case 2:\")\n    print(manager.generateSecret(\"user1\", 5)) # \"secret_user1\"\n    print(manager.getSecret(\"user1\")) # \"secret_user1\"\n    print()\n\n    print(\"Test Case 3:\")\n    print(manager.generateSecret(\"user2\", 10)) # \"secret_user2\"\n    print(manager.getSecret(\"user1\")) # \"\"\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1799": "```\ndef max_score(nums):\n    n = len(nums)\n    dp = [[0] * (1 << 18) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for mask in range(1 << 18):\n            if nums[i - 1] & mask:\n                dp[i][mask] = max(dp[i - 1][mask ^ (1 << (nums[i - 1] >> 5))], dp[i - 1][mask])\n            else:\n                dp[i][mask] = dp[i - 1][mask]\n    return max(dp[n])\n\ndef main():\n    print(max_score([3,2,1,0]))  # Output: 6\n    print(max_score([0,1,1,0,1]))  # Output: 5\n    print(max_score([1,1,0,0]))  # Output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1800": "```\ndef maxAscendingSum(nums):\n    if not nums:\n        return 0\n    \n    res = curr_sum = nums[0]\n    \n    for i in range(1, len(nums)):\n        if nums[i] > nums[i-1]:\n            curr_sum += nums[i]\n        else:\n            res = max(res, curr_sum)\n            curr_sum = nums[i]\n    \n    return max(res, curr_sum)\n\n\ndef main():\n    print(maxAscendingSum([10, 9, 2, 5, 3, 7, 101, 4]) == 18)  # True\n    print(maxAscendingSum([0, 1, 2, 3, 4, 5]) == 15)  # True\n    print(maxAscendingSum([1, 2, 3, 10, 4]) == 10)  # True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1801": "```\nimport heapq\n\ndef order_food_orders_delay_time(orders):\n    orders.sort()\n    pq = []\n    delayed = 0\n    for time in orders:\n        while pq and pq[0] <= time - 30:\n            heapq.heappop(pq)\n        if pq:\n            delayed += time - pq[0]\n        heapq.heappush(pq, time + 30)\n    return delayed\n\ndef main():\n    test_cases = [\n        ([1,2,3,4,5], 6), \n        ([1,2,3,4,10], 11), \n        ([1,2,3,7,15,20], 14)\n    ]\n    \n    for orders, expected in test_cases:\n        result = order_food_orders_delay_time(orders)\n        if result == expected:\n            print(f\"Test case {orders} passed.\")\n        else:\n            print(f\"Test case {orders} failed. Expected: {expected}, Got: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1802": "```\ndef maxValueAtIndex(nums, index, numLen):\n    if not nums or index >= numLen:\n        return -1\n    left, right = 0, numLen - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] > nums[index]:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return nums[left]\n\ndef main():\n    print(maxValueAtIndex([1, 3, 5, 8], 4, 4))  # Expected: 8\n    print(maxValueAtIndex([2, 2, 2, 3, 3, 4, 5, 7, 9], 3, 9))  # Expected: 4\n    print(maxValueAtIndex([1, 2, 3, 2, 1], 0, 5))  # Expected: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1803": "```\ndef count_pairs(nums, left, right):\n    n = len(nums)\n    nums.sort()\n    res = 0\n    for i in range(n):\n        l, r = left ^ nums[i], right ^ nums[i]\n        j = bisect_left(nums, l) - 1\n        k = bisect_right(nums, r) - 1\n        res += k - j\n    return res\n\ndef main():\n    test_cases = [\n        ([2,3,4,7,11], 5, 15),\n        ([10,12,13,16,18,20,25,30,35,40,50,60,70,80], 0, 100),\n        ([1,3,5,7,9,11,13,15], 4, 10)\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Test Case: {test_case}\")\n        result = count_pairs(*test_case[:2], test_case[2][0], test_case[2][1])\n        print(f\"Expected: {test_case[2]}\")\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1804": "```\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word: str) -> bool:\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def startsWith(self, prefix: str) -> bool:\n        node = self.root\n        for char in prefix:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return True\n\n\ndef main():\n    trie = Trie()\n\n    # Test case 1\n    trie.insert(\"apple\")\n    print(trie.search(\"apple\"))  # Expected: True\n    print(trie.startsWith(\"app\"))  # Expected: True\n\n    # Test case 2\n    trie.insert(\"banana\")\n    print(trie.search(\"banana\"))  # Expected: True\n    print(trie.startsWith(\"ban\"))  # Expected: True\n\n    # Test case 3\n    print(trie.search(\"orange\"))  # Expected: False\n    print(trie.startsWith(\"ora\"))  # Expected: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1805": "```\ndef numSpecialEquivGroups(text):\n    count = {}\n    for i in range(0, len(text), 2):\n        left_half = set(int(i) for i in text[i:i+1].replace(' ',''))\n        right_half = set(int(i) for i in text[i+1:i+2].replace(' ',''))\n        count[tuple(sorted(left_half)) + tuple(sorted(right_half))] += 1\n    return list(count.values()).count(1)\n\ndef main():\n    print(numSpecialEquivGroups(\"abc\")) # Expected output: 1\n    print(numSpecialEquivGroups(\"aaa1z\")) # Expected output: 1\n    print(numSpecialEquivGroups(\"foobar\")) # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1806": "```\ndef minOperations(nums):\n    res = [0] * len(nums)\n    for i in range(len(nums)):\n        if nums[i] == i + 1:\n            res[i] = (len(nums) - i) // 2\n        else:\n            diff = abs(nums[i] - i - 1)\n            res[i] = min(diff, len(nums) - diff)\n    return sum(res)\n\ndef main():\n    print(minOperations([1,2,3,4]))\n    print(minOperations([0,4,8,5]))\n    print(minOperations([10,9,7]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1807": "```\ndef is_bracket_valid(s):\n    stack = []\n    bracket_map = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in bracket_map.values():\n            stack.append(char)\n        elif char in bracket_map.keys():\n            if not stack or stack.pop() != bracket_map[char]:\n                return False\n    return not stack\n\ndef main():\n    test_cases = [\n        {\"input\": \"({[]})\", \"expected_output\": True},\n        {\"input\": \"([)]\", \"expected_output\": False},\n        {\"input\": \"()[]{}\", \"expected_output\": True}\n    ]\n\n    for test_case in test_cases:\n        input_string = test_case[\"input\"]\n        expected_output = test_case[\"expected_output\"]\n        actual_output = is_bracket_valid(input_string)\n        \n        if actual_output == expected_output:\n            print(\"Test case passed: {} -> {}\".format(input_string, \"True\" if actual_output else \"False\"))\n        else:\n            print(\"Test case failed: {} -> {} (Expected {})\".format(input_string, \"True\" if actual_output else \"False\", \"True\" if expected_output else \"False\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1808": "```\ndef maximumNiceDivisors(n):\n    def nice_divisors(x):\n        ans = []\n        for i in range(1, int(x ** 0.5) + 1):\n            if x % i == 0:\n                if i * (x // i) != x:\n                    ans.append(i)\n                else:\n                    ans.append(i | (1 << (int(math.log2(x)) - 1)))\n        return len(ans)\n\n    res = 0\n    temp = n\n    while temp > 0:\n        count, val = divmod(temp, 2)\n        res += count * 2 + nice_divisors(val)\n        temp //= 2\n    return res\n\ndef main():\n    print(maximumNiceDivisors(25))  # Output: 11\n    print(maximumNiceDivisors(31))  # Output: 5\n    print(maximumNiceDivisors(60123456789))  # Output: 1059\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1809": "```\ndef numUniqueEmails(emails):\n    unique_emails = set()\n    for email in emails:\n        local_part, domain = email.split('@')\n        local_part = local_part.split('+')[0]\n        unique_emails.add(local_part + '@' + domain)\n    return len(unique_emails)\n\ndef main():\n    test_cases = [\n        {\"emails\": [\"john.doe@example.com\", \"john+doe@example.com\", \"jane.doe@example.com\"], \"expected_output\": 2},\n        {\"emails\": [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"], \"expected_output\": 2},\n        {\"emails\": [], \"expected_output\": 0}\n    ]\n\n    for test_case in test_cases:\n        output = numUniqueEmails(test_case[\"emails\"])\n        if output == test_case[\"expected_output\"]:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1810": "```\nimport heapq\n\ndef minCost(grid):\n    m, n = len(grid), len(grid[0])\n    pq = [(grid[0][0], 0, 0)]\n    visited = set((0, 0))\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    \n    while pq:\n        cost, i, j = heapq.heappop(pq)\n        \n        if i == m-1 and j == n-1:\n            return cost\n        \n        for di, dj in directions:\n            ni, nj = i+di, j+dj\n            \n            if (0 <= ni < m) and (0 <= nj < n) and (ni, nj) not in visited:\n                visited.add((ni, nj))\n                heapq.heappush(pq, (cost + grid[ni][nj], ni, nj))\n\ndef main():\n    test_cases = [\n        [[3,5],[1,2]], \n        [[0, 4, 3, 1, 1],[1, 3, 1, 2, 1],[3, 7, 2, 0, 6],[9,8,7,6,5]],\n        [[10]]\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        result = minCost(test_case)\n        print(f\"Result: {result}\\n\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1811": "```\ndef findInterviewCandidates(intervals):\n    interviews = []\n    for start, end in intervals:\n        if not interviews or start >= interviews[-1][1]:\n            interviews.append([start, end])\n        else:\n            i = len(interviews) - 1\n            while i > 0 and interviews[i-1][1] < start:\n                i -= 1\n            interviews.insert(i, [start, end])\n    return interviews\n\ndef main():\n    print(findInterviewCandidates([[0,30],[5,10],[15,20]])) # [[0,30],[5,10],[15,20]]\n    print(findInterviewCandidates([[7,10],[2,4]])) # [[2,4],[7,10]]\n    print(findInterviewCandidates([])) # []\n    print(findInterviewCandidates([(1,3),(5,6)])) # [[1,3],[5,6]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1812": "```\ndef squareIsWhite(coordinates):\n    return coordinates[0] % 2 == 0\n\ndef main():\n    print(squareIsWhite(\"a1\")) # True\n    print(squareIsWhite(\"h8\")) # False\n    print(squareIsWhite(\"d5\")) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1813": "```\ndef sentencesSimilar(sentence1, sentence2):\n    words1 = set(sentence1.split())\n    words2 = set(sentence2.split())\n\n    if len(words1) != len(words2):\n        return False\n\n    for word in words1:\n        if (word not in words2 or\n            any(word not in sentence and other_word not in sentence for sentence, other_sentence in [(sentence1, sentence2), (sentence2, sentence1)])):\n            return False\n\n    return True\n\n\ndef main():\n    print(sentencesSimilar(\"a\", \"b\"))  # Test case 1: False\n    print(sentencesSimilar(\"we are nice people\", \"we are nice humans\"))  # Test case 2: True\n    print(sentencesSimilar(\"Hello, world!\", \"Hello, world!\"))  # Test case 3: True\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1814": "```\ndef numberOfWays(nums):\n    n = len(nums)\n    seen = {}\n    for i in range(n):\n        count = 0\n        for j in range(i+1, n):\n            if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                count += 1\n        seen[nums[i]] = count\n    return sum(seen.values())\n\ndef main():\n    print(numberOfWays([2,10,6]), \"Expected: 4\")\n    print(numberOfWays([3,5,2,7,4]), \"Expected: 7\")\n    print(numberOfWays([3,1,2,10,1,2,4,1]), \"Expected: 16\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1815": "```\ndef maxGroups(groups):\n    n = len(groups)\n    dp = [0] * (1 << n)\n    \n    for mask in range(1, 1 << n):\n        if sum((mask >> i) & 1 for i in range(n)) > 1:\n            continue\n        prev = -1\n        same_group = False\n        for i in range(n):\n            if ((mask >> i) & 1) and groups[i] == prev + 1:\n                same_group = True\n                break\n            prev = groups[i]\n        if not same_group:\n            dp[mask] = max(dp[mask], dp[mask ^ (1 << i)] + 1 for i in range(n) if ((mask >> i) & 1))\n\n    return max(dp)\n\ndef main():\n    print(maxGroups([2,3,5]))  # Expected output: 2\n    print(maxGroups([10,11,12,13,14]))  # Expected output: 4\n    print(maxGroups([2,3,6,7]))  # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1816": "```\ndef truncateSentence(s: str) -> List[str]:\n    return [s.split(\" \")[i] for i in range(len(s.split(\" \")))]\n\ndef main():\n    print(truncateSentence(\"hello world\")) \n    print(truncateSentence(\"a b c d e f g h\")) \n    print(truncateSentence(\"this is an example sentence\")) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1818": "```\ndef minAbsoluteSumDiff(nums):\n    nums.sort()\n    res = float('inf')\n    for i in range(len(nums)):\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[i] - nums[mid] <= nums[i] - nums[left]:\n                left = mid + 1\n            else:\n                right = mid\n        res = min(res, abs(nums[i] - nums[left]) + sum(nums))\n    return res\n\ndef main():\n    print(minAbsoluteSumDiff([3,2,-1])) # Expected output: 1\n    print(minAbsoluteSumDiff([-1000, -1000])) # Expected output: 2000\n    print(minAbsoluteSumDiff([1,4,8])) # Expected output: 9\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1817": "```\ndef findActiveMinutes(n, firstBitimes, secondBitimes):\n    minutes = {}\n    for i in range(len(firstBitimes)):\n        if firstBitimes[i] not in minutes:\n            minutes[firstBitimes[i]] = set()\n        if secondBitimes[i] not in minutes:\n            minutes[secondBitimes[i]] = set()\n        minutes[firstBitimes[i]].add(i)\n        minutes[secondBitimes[i]].add(i)\n\n    return [len(minutes.get(i, set())) for i in range(1, n+1)]\n\ndef main():\n    n = 5\n    firstBitimes = [1,0,1,2,0]\n    secondBitimes = [5,4,0,3,2]\n    print(findActiveMinutes(n, firstBitimes, secondBitimes))\n    \n    n = 10\n    firstBitimes = [1,2,3,2,1,1,7,6,7,9]\n    secondBitimes = [0,5,0,8,4,2,9,4,6,9]\n    print(findActiveMinutes(n, firstBitimes, secondBitimes))\n    \n    n = 10\n    firstBitimes = [0,0,3,1,2,4,3,1,4,6]\n    secondBitimes = [5,3,8,7,6,5,3,5,7,9]\n    print(findActiveMinutes(n, firstBitimes, secondBitimes))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1819": "```\ndef subsequenceGCDs(nums):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    seen = set()\n    res = 0\n\n    for i in range(1 << len(nums)):\n        cur = nums[0]\n        for j in range(len(nums)):\n            if (i & (1 << j)):\n                cur = gcd(cur, nums[j])\n        seen.add(cur)\n    \n    return len(seen)\n\ndef main():\n    print(subsequenceGCDs([2,5,6,20])) # 3\n    print(subsequenceGCDs([4,5,18,29,38])) # 2\n    print(subsequenceGCDs([1,2,10,11])) # 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1820": "```\ndef maxAcceptableInvitations(maxA, maxB, inviteesA, inviteesB):\n    inviteesSet = set(inviteesA + inviteesB)\n    for i in range(1 << len(inviteesA)):\n        canAttendA = all(x not in inviteesB for x in bin(i)[2:].zfill(len(inviteesA)).upper())\n        if canAttendA:\n            friendCount = sum((i & (1 << j)) for j in range(len(inviteesA)) if inviteesSet & {inviteesA[j]})\n            if friendCount <= maxA and len(bin(i)[2:].upper().translate(str.maketrans('', '', '0')) ) <= maxB:\n                return i\n    return 0\n\ndef main():\n    print(maxAcceptableInvitations(3, 5, [\"Sherry\", \"Sherlock\", \"John\"], [\"Mary\", \"Jane\"]))\n    print(maxAcceptableInvitations(1, 2, [\"Alice\", \"Bob\", \"Charlie\"], [\"Eve\", \"Frank\", \"George\"]))\n    print(maxAcceptableInvitations(10, 10, [\"Alex\", \"Brian\", \"Chris\", \"David\", \"Ellen\", \"Fred\", \"Gary\", \"Helen\", \"Ivan\", \"Julie\"], [\"Kay\", \"Lynne\", \"Mike\", \"Nancy\", \"Olga\", \"Pamela\", \"Quinn\", \"Ruth\", \"Sandra\", \"Tanya\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1821": "```\ndef getCustomersWithPositiveRevenue(revenue):\n    return [customer for customer in revenue if customer[1] > 0]\n\ndef main():\n    revenue = [\n        [\"John\", 500],\n        [\"Jane\", -100],\n        [\"Bob\", 200],\n        [\"Alice\", -300]\n    ]\n    \n    print(\"Customers with positive revenue this year:\")\n    for customer in getCustomersWithPositiveRevenue(revenue):\n        print(customer[0])\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1822": "```\ndef arraySign(nums):\n    result = 1\n    has_zero = False\n    for num in nums:\n        if num == 0:\n            has_zero = True\n        elif num > 0:\n            result *= 1\n        else:\n            result *= -1\n    return -1 if has_zero else result\n\ndef main():\n    print(arraySign([-1,-2,-3,0,1]))  # Expected: -1\n    print(arraySign([1,-2,-3,0,5]))   # Expected: -1\n    print(arraySign([0,1,-2]))         # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1823": "```\ndef findTheWinner(n, k):\n    queue = [i for i in range(1, n+1)]\n    while len(queue) > 1:\n        queue.append(queue.pop((k-1)%len(queue)))\n    return queue[0]\n\ndef main():\n    print(findTheWinner(5, 2)) # Expected output: 3\n    print(findTheWinner(6, 5)) # Expected output: 4\n    print(findTheWinner(8, 3)) # Expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1824": "```\ndef minSideJump(jumps):\n    n = len(jumps)\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n+1):\n        if i - jumps[i-1] >= 0:\n            dp[i] = min(dp[i], dp[i-jumps[i-1]] + 2)\n        if i - 1 >= 0 and (i - jumps[i-1]) >= 0:\n            dp[i] = min(dp[i], dp[i-1] + 1)\n    return dp[n]\n\ndef main():\n    print(minSideJump([2,1,4,3]))  # Output: 2\n    print(minSideJump([4,2,7,6,9]))  # Output: 4\n    print(minSideJump([0,1]))  # Output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1825": "```\nfrom collections import deque\nimport heapq\n\nclass MKAverage:\n    def __init__(self, m, k):\n        self.m = m\n        self.k = k\n        self.min_heap = []\n        self.max_heap = []\n        self.count = 0\n\n    def addElement(self, num):\n        if not self.min_heap or num < -self.min_heap[0]:\n            heapq.heappush(self.min_heap, -num)\n        else:\n            heapq.heappush(self.max_heap, num)\n\n        self.count += 1\n        if self.count > self.m:\n            if -self.min_heap[0] > self.max_heap[0]:\n                heapq.heappop(self.min_heap)\n            else:\n                heapq.heappop(self.max_heap)\n            self.count -= 1\n\n    def calculateMKAverage(self):\n        if not self.min_heap or len(self.min_heap) < self.k:\n            return -1\n        sum_ = 0\n        for _ in range(self.k):\n            sum_ += -heapq.nlargest(1, self.min_heap)[0]\n        return int(sum_ / self.k)\n\ndef main():\n    m = MKAverage(3, 2)\n    m.addElement(10)\n    m.addElement(-5)\n    print(m.calculateMKAverage())  # Output: 7\n\n    m = MKAverage(6, 1)\n    m.addElement(100000)\n    m.addElement(-99999)\n    for _ in range(4):\n        m.addElement(0)\n    print(m.calculateMKAverage())  # Output: 0\n\n    m = MKAverage(3, 2)\n    for _ in range(5):\n        m.addElement(10)\n    print(m.calculateMKAverage())  # Output: 5",
  "1826": "```\ndef faultySensor(arr):\n    n = len(arr)\n    if n % 2 == 1:\n        return -1\n    res = []\n    left, right = 0, n-1\n    while left <= right:\n        if arr[left] < arr[right]:\n            res.append(arr[left])\n            left += 1\n        else:\n            res.append(arr[right])\n            right -= 1\n    return res\n\n\ndef main():\n    print(faultySensor([9,8,7,6,5,4,3,2,1])) # expected output: [9, 7, 5, 3]\n    print(faultySensor([1,2,3,4,5,6,7,8,9])) # expected output: [-1]\n    print(faultySensor([1,2,3,4,4,4,4,4,4])) # expected output: [1, 4]\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1827": "```\ndef minOperations(nums):\n    n = len(nums)\n    res = 0\n    for i in range(1, n):\n        if nums[i] <= nums[i - 1]:\n            diff = nums[i - 1] - nums[i] + 1\n            res += diff\n            nums[i] += diff\n    return res\n\ndef main():\n    print(minOperations([1,3,5,4,2])) # Output: 7\n    print(minOperations([1,2,3,4,5])) # Output: 0\n    print(minOperations([1,1,1])) # Output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1828": "```\ndef countPoints(radius):\n    n = len(radius)\n    res = []\n    \n    for r in radius:\n        count = 0\n        for i in range(n):\n            if ((i*(i+1)//2) <= r**2):\n                count += 1\n        res.append(count)\n        \n    return res\n\n\ndef main():\n    print(countPoints([1,3,4])) \n    print(countPoints([1,2,4,8])) \n    print(countPoints([1]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1829": "```\ndef maxXor(nums, queries):\n    trie = {}\n    for num in nums:\n        node = trie\n        for bit in range(31,-1,-1):\n            b = (num>>bit)&1\n            if '0' not in node or '1' not in node:\n                node[str(b)] = {'0': {}, '1': {}}\n            node = node[str(b)]\n    res = []\n    for query in queries:\n        ans = 0\n        node = trie\n        for bit in range(31,-1,-1):\n            b = (query>>bit)&1\n            if '1' - int(str(b) != str(node.get('1',{})).count('0')) in node:\n                ans |= 1<<bit\n            else:\n                if '0' not in node or '1' not in node:\n                    res.append(ans)\n                    break\n                b = '0' if query & (1<<bit) == 0 else '1'\n                node = node[str(b)]\n        else:\n            res.append(ans)\n    return res\n\ndef main():\n    nums = [6,5,7]\n    queries = [[6,10],[11,13],[4,15]]\n    print(maxXor(nums,queries))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1830": "```\ndef minOperations(s):\n    operations = 0\n    for i in range(len(s) // 2):\n        if s[i] != s[-i - 1]:\n            operations += 1\n    return operations\n\n\ndef main():\n    print(minOperations(\"123456\") == 3)\n    print(minOperations(\"1326K\") == 2)\n    print(minOperations(\"9567320\") == 7)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1831": "```\ndef maxTransactions(transactions):\n    transactions.sort(key=lambda x: x[0])\n    daily_transactions = {}\n    for transaction in transactions:\n        date, value = transaction\n        if date not in daily_transactions:\n            daily_transactions[date] = [value]\n        else:\n            daily_transactions[date].append(value)\n    \n    return max(map(sum, daily_transactions.values()))\n\ndef main():\n    test_cases = [\n        # Test case 1: \n        [(1, 10), (2, 20), (3, 30)],\n        \n        # Test case 2: \n        [(4, 40), (5, 50), (6, 60), (7, 70)],\n\n        # Test case 3:\n        [(8, 80), (9, 90)]\n    ]\n    \n    for test_case in test_cases:\n        transactions = [(t[0], t[1]) for t in test_case]\n        print(f\"Maximum transaction each day: {maxTransactions(transactions)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1832": "```\ndef is_pangram(sentence):\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    return set(alphabet) <= set(sentence.lower())\n\ndef main():\n    print(is_pangram(\"The quick brown fox jumps over the lazy dog\")) # Test case 1\n    print(is_pangram(\"Hello world\")) # Test case 2\n    print(is_pangram(\"This is a pangram test case\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1833": "```\ndef maxIceCream(costs):\n    costs.sort()\n    iceCreamBars = 0\n    remainingMoney = 100\n    for cost in costs:\n        if cost <= remainingMoney:\n            remainingMoney -= cost\n            iceCreamBars += 1\n        else:\n            break\n    return iceCreamBars\n\ndef main():\n    testCases = [\n        {\"costs\": [1, 3, 2, 5], \"expected\": 3},\n        {\"costs\": [4], \"expected\": 1},\n        {\"costs\": [10, 6, 8, 5, 7, 9], \"expected\": 3}\n    ]\n\n    for testCase in testCases:\n        result = maxIceCream(testCase[\"costs\"])\n        if result == testCase[\"expected\"]:\n            print(f\"Test case {testCase} passed\")\n        else:\n            print(f\"Test case {testCase} failed. Expected {testCase['expected']} but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1834": "```\ndef busiestServers(k, arrival, load):\n    heap = []\n    for i in range(len(arrival)):\n        heapq.heappush(heap, (arrival[i], i))\n    max_load = 0\n    result = [0]*k\n    time = 0\n    while heap:\n        time = heap[0][0]\n        for _ in range(k):\n            if not heap or heap[0][0] <= time:\n                break\n            heapq.heappop(heap)\n        max_load = max(max_load, len(heap))\n        for i in range(len(heap)):\n            result[heap[i][1]] += 1\n    return [x for x in result if x == max_load]\n\ndef main():\n    print(busiestServers(3, [0,2,4], [5,10,11]))\n    print(busiestServers(2, [0,6,12], [1,5,6]))\n    print(busiestServers(1, [0], [8]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1835": "```\ndef findXORSum(arr):\n    n = len(arr)\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            res ^= arr[i] ^ arr[j]\n    return res\n\n\ndef main():\n    print(findXORSum([1,3]) == 2) \n    print(findXORSum([0,1,2,5]) == 4)\n    print(findXORSum([0,1,2,7]) == 7)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1837": "```\ndef sumBaseK(n: int, k: int) -> int:\n    def convertToBaseK(n: int, k: int):\n        if n < k:\n            return str(n)\n        else:\n            return convertToBaseK(n // k, k) + str(n % k)\n\n    def convertFromBaseK(baseKStr: str, k: int):\n        result = 0\n        for char in baseKStr:\n            result = result * k + int(char)\n        return result\n\n    return sum(int(i) for i in convertToBaseK(n, k))\n\ndef main():\n    print(sumBaseK(34, 3)) # Test case 1: expected output is 11\n    print(sumBaseK(10, 2)) # Test case 2: expected output is 2\n    print(sumBaseK(29524187347158049527, 7)) # Test case 3: expected output is 83\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1836": "```\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\ndef deleteDuplicates(head: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    while head:\n        if head.next and head.val == head.next.val:\n            while head.next and head.val == head.next.val:\n                head = head.next\n            head = head.next\n        else:\n            curr.next = head\n            curr = curr.next\n        head = head.next if head.next else None\n    return dummy.next\n\ndef printList(head: ListNode):\n    while head:\n        print(head.val, end=\" \")\n        head = head.next\n    print()\n\ndef main():\n    # Test Case 1:\n    node1 = ListNode(1)\n    node2 = ListNode(2)\n    node3 = ListNode(2)\n    node4 = ListNode(3)\n    node5 = ListNode(3)\n    node6 = ListNode(3)\n    head = node1\n    head.next = node2\n    node2.next = node3\n    node3.next = node4\n    node4.next = node5\n    node5.next = node6\n    print(\"Original List: \")\n    printList(head)\n    resultHead = deleteDuplicates(head)\n    print(\"After removing duplicates: \")\n    printList(resultHead)\n\n    # Test Case 2:\n    head = None\n    print(\"Original List: \")\n    printList(head)\n    resultHead = deleteDuplicates(head)\n    print(\"After removing duplicates: \")\n    printList(resultHead)\n\n    # Test Case 3:\n    node1 = ListNode(1)\n    node2 = ListNode(1)\n    node3 = ListNode(1)\n    head = node1\n    head.next = node2\n    node2.next = node3\n    print(\"Original List: \")\n    printList(head)\n    resultHead = deleteDuplicates(head)\n    print(\"After removing duplicates: \")\n    printList(resultHead)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1838": "```\ndef most_frequent(nums):\n    freq = {}\n    for num in nums:\n        if num not in freq:\n            freq[num] = 1\n        else:\n            freq[num] += 1\n    max_freq = max(freq.values())\n    return [k for k, v in freq.items() if v == max_freq][0]\n\ndef main():\n    print(most_frequent([1])) # Test case 1: Single element array\n    print(most_frequent([1,2,3,4,5])) # Test case 2: Array with unique elements\n    print(most_frequent([1,1,2,2,2])) # Test case 3: Array with duplicate elements\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1839": "```\ndef longest_vowel_substring(s):\n    vowels = 'aeiou'\n    max_length = 0\n    start = end = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            if i == 0 or s[i-1] not in vowels:\n                start = i\n            while i < len(s) - 1 and s[i+1] in vowels:\n                i += 1\n            end = i\n            max_length = max(max_length, end - start + 1)\n    return max_length\n\ndef main():\n    print(longest_vowel_substring(\"aaoovt\"))  # Expected output: 2\n    print(longest_vowel_substring(\"abcdefghijklmnopqrstuvwxyz\"))  # Expected output: 5\n    print(longest_vowel_substring(\"abcdefghijklmnopqrstuvwxyzxyz\"))  # Expected output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1840": "```\ndef maxBuildingHeight(sticks):\n    sticks.sort()\n    max_height = 0\n    for i in range(1, len(sticks)):\n        if sticks[i] - sticks[i-1] > 1:\n            return -1\n        max_height += 1\n    return max_height\n\n\ndef main():\n    print(maxBuildingHeight([8,10,6,22,9,5,4])) # Expected output: 3\n    print(maxBuildingHeight([1,2,3,4,5,6,7,8])) # Expected output: 0\n    print(maxBuildingHeight([1,2,3,3,4,4,4,5,5,5,5])) # Expected output: 5\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1841": "```\ndef highFive(self, logs):\n    students = {}\n    for log in logs:\n        student_id, score = int(log.split()[1]), int(log.split()[2])\n        if student_id not in students:\n            students[student_id] = []\n        students[student_id].append(score)\n    \n    return [[sum(scores)/len(scores), len(scores)] for scores in students.values()]\n\ndef main():\n    logs = [\"John 93 95\", \"John 88\", \"Eva 22 91 96\", \"Alice 90\", \"Bob 76 17 44 88 97\"]\n    result = highFive(logs)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1842": "```\ndef next_palindrome(digits):\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    digits = sorted(str(digits))\n    for i in range(len(digits)):\n        for j in range(i+1, len(digits)):\n            if is_palindrome(''.join(digits[:i] + digits[i+1:j][-1::-1])):\n                return int(''.join(digits[:i] + digits[i+1:j][-1::-1]))\n    return -1\n\ndef main():\n    print(next_palindrome(123)) \n    print(next_palindrome(3456))\n    print(next_palindrome(111))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1843": "```\ndef findSuspiciousAccounts(transactions):\n    transactions.sort(key=lambda x: x[0])\n    max_amount = float('-inf')\n    min_amount = float('inf')\n    \n    suspicious_accounts = []\n    for i in range(len(transactions) - 1):\n        if transactions[i][2] > max_amount:\n            max_amount = transactions[i][2]\n        if transactions[i][2] < min_amount:\n            min_amount = transactions[i][2]\n        if abs(transactions[i][2] - transactions[i+1][2]) > max_amount or transactions[i][0] != transactions[i+1][0]:\n            suspicious_accounts.append((transactions[i][0], transactions[i][2]))\n    return suspicious_accounts\n\ndef main():\n    test_cases = [\n        ([[\"John\", 200, 100]], [(\"John\", 200)]),\n        ([[\"Alice\", 500, 300], [\"Bob\", 400, 200], [\"Charlie\", 600, 250]], [(\"Alice\", 500), (\"Bob\", 400)]),\n        ([[\"Dave\", 1000, 500], [\"Eve\", 1500, 750], [\"Frank\", 800, 400]], [])\n    ]\n\n    for transactions, expected in test_cases:\n        result = findSuspiciousAccounts(transactions)\n        print(f\"Transactions: {transactions}, Expected: {expected}, Result: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1844": "```\ndef replaceDigits(s):\n    result = \"\"\n    for c in s:\n        if c.isdigit():\n            new_c = chr(ord('a') + int(c) - 1)\n            result += c.replace(str(int(c)), new_c)\n        else:\n            result += c\n    return result\n\n\ndef main():\n    print(\"Test Case 1: \", replaceDigits(\"a4b3c\"))\n    print(\"Test Case 2: \", replaceDigits(\"44z5\"))\n    print(\"Test Case 3: \", replaceDigits(\"s33\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1846": "```\ndef maxAmount(nums):\n    nums.sort()\n    return sum(i for i in nums if i % 2 == 1)\n\ndef main():\n    print(maxAmount([1,2,3,4,5])) # Test case 1: Expected output 9\n    print(maxAmount([1,2,3,7,8])) # Test case 2: Expected output 18\n    print(maxAmount([3,19,50,21,25,8,4,10])) # Test case 3: Expected output 64\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1845": "```\nimport heapq\n\nclass SeatManager:\n\n    def __init__(self, n):\n        self.heap = [i + 1 for i in range(n)]\n\n    def reserve(self):\n        return heapq.heappop(self.heap)\n\n    def unreserve(self, seatNumber):\n        if seatNumber <= len(self.heap):\n            heapq.heappush(self.heap, seatNumber)\n\n\ndef main():\n    # Test case 1\n    manager = SeatManager(3)\n    print(manager.reserve())  # Output: 1\n    print(manager.reserve())  # Output: 2\n    manager.unreserve(2)\n    print(manager.reserve())  # Output: 2\n\n    # Test case 2\n    manager = SeatManager(4)\n    print(manager.reserve())  # Output: 1\n    print(manager.reserve())  # Output: 2\n    print(manager.reserve())  # Output: 3\n    manager.unreserve(3)\n    print(manager.reserve())  # Output: 3\n\n    # Test case 3\n    manager = SeatManager(5)\n    print(manager.reserve())  # Output: 1\n    print(manager.reserve())  # Output: 2\n    manager.unreserve(2)\n    print(manager.reserve())  # Output: 2\n    print(manager.reserve())  # Output: 4\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1848": "```\ndef minAbsoluteSumDiff(nums, target):\n    nums.sort()\n    res = float('inf')\n    for i in range(len(nums)):\n        abs_diff = abs(target - nums[i])\n        if abs_diff < res:\n            res = abs_diff\n        elif abs_diff == res:\n            res = min(res, len(nums) - (i+1) + len(nums) - (len(nums)-i-1))\n    return res\n\ndef main():\n    print(minAbsoluteSumDiff([3,5,4,2], 2)) # expected output: 1\n    print(minAbsoluteSumDiff([1,1000000000], 999999994)) # expected output: 999995\n    print(minAbsoluteSumDiff([-100], -96)) # expected output: 95\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1847": "```\ndef findClosestEntry(entries):\n    if not entries:\n        return -1\n\n    sorted_entries = sorted([(int(entry[0]), i) for i, entry in enumerate(entries)])\n\n    left, right = 0, len(sorted_entries) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if abs(int(sorted_entries[mid][0]) - target) <= abs(int(sorted_entries[left][0]) - target):\n            left = mid\n        else:\n            right = mid\n\n    return sorted_entries[left][1]\n\ndef main():\n    test_cases = [\n        {\"entries\": [[\"100,104\", \"2\", \"116\"], [\"1\", \"3\", \"214\"]], \"target\": 106},\n        {\"entries\": [[\"1,3\", \"3,6\", \"7,12\"], [5]], \"target\": 8},\n        {\"entries\": [[\"0,0\", \"4,9\", \"10,15\", \"18,20\"], [7]], \"target\": 7}\n    ]\n\n    for test_case in test_cases:\n        entries = [entry[1].split(\",\") for entry in test_case[\"entries\"]]\n        target = int(test_case[\"target\"])\n        print(f\"Target: {target}, Closest Entry: {findClosestEntry(entries)}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1850": "```\ndef minSwaps(nums):\n    n = len(nums)\n    permute = sorted(nums)\n    swap_count = [0] * (n+1)\n\n    for i in range(n-1, -1, -1):\n        while nums[i] != permute[i]:\n            swap_count[0] += 1\n            j = i + 1\n            while nums[j] < nums[i]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n    return swap_count[0]\n\ndef main():\n    test_cases = [\n        {\"nums\": [3, 2, 5, 4], \"kth_smallest\": 5, \"expected_result\": 3},\n        {\"nums\": [1, 2, 3, 7, 5, 6], \"kth_smallest\": 6, \"expected_result\": 2},\n        {\"nums\": [8, 9, 4, 7, 10, 3, 2], \"kth_smallest\": 8, \"expected_result\": 1}\n    ]\n\n    for test_case in test_cases:\n        result = minSwaps(test_case[\"nums\"])\n        print(f\"Test case: {test_case['nums']}, Expected Result: {test_case['expected_result']}, Actual Result: {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1849": "```\ndef splitString(s):\n    def backtrack(start, path):\n        if start == len(s):\n            result.append(path)\n            return\n        for end in range(start, len(s)):\n            substring = s[start:end+1]\n            if int(substring) > 0 and isConsecutive(substring, path):\n                backtrack(end+1, path + \" \" + substring)\n\n    def isConsecutive(s, prev):\n        num = int(s)\n        if prev == \"\":\n            return True\n        prev_num = int(prev.split()[-1])\n        if num - prev_num <= 0:\n            return False\n        for i in range(prev_num-1, num-1, -1):\n            if str(i) != s:\n                return False\n        return True\n\n    result = []\n    backtrack(0, \"\")\n    return [str(i) + \" \" for i in sorted(map(int, x.split())) for x in result]\n\ndef main():\n    print(splitString(\"112358\"))  # Output: [\"10 11 12 13 14 15\", \"5 6 7 8 9\"]\n    print(splitString(\"1234567890\"))  # Output: [\"1 2 3 4 5 6 7 8 9\"]\n    print(splitString(\"01234567890\"))  # Output: []\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1851": "```\ndef minInterval(intervals, queries):\n    events = [(q, 'Q') for q in queries] + [(i[1], 'I') for i in intervals]\n    events.sort()\n    active = []\n    result = []\n    \n    for event in events:\n        while active and active[-1][0] <= event[0]:\n            active.pop()\n        \n        if event[1] == 'Q':\n            query, _ = event\n            for interval in sorted(active):\n                if interval[1] - query >= 0:\n                    result.append((query, interval[1] - query))\n                    break\n            else:\n                result.append((-1, -1))\n        elif event[1] == 'I':\n            start, end = event\n            active.append((end, 'I'))\n    \n    return result\n\ndef main():\n    print(minInterval([[1,4],[2,3]], [2,5])) \n    print(minInterval([[1,3],[6,7]], [2,5])) \n    print(minInterval([[1,10],[10,20}]], [11,12]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1852": "```\ndef findDistinctCount(nums):\n    n = len(nums)\n    start, end = 0, 0\n    distinct_count = {i: 0 for i in range(n + 1)}\n    \n    for end in range(1, n + 1):\n        while distinct_count[end] < 2:\n            if end > start:\n                distinct_count[distinct_count[start]] -= 1\n                start += 1\n            end += 1\n    \n    return sum(distinct_count.values()) - n\n\n\ndef main():\n    test_case_1 = [1, 3, 3, 1, 2, 3]\n    print(f\"Test Case 1: {findDistinctCount(test_case_1)}\")\n    \n    test_case_2 = [5, 1, 3, 4, 3, 1, 1, 3]\n    print(f\"Test Case 2: {findDistinctCount(test_case_2)}\")\n    \n    test_case_3 = [1, 1, 1, 1]\n    print(f\"Test Case 3: {findDistinctCount(test_case_3)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1853": "```\ndef day_of_week(date):\n    from datetime import datetime\n    return datetime.strptime(date, \"%Y-%m-%d\").strftime(\"%A\")\n\ndef main():\n    print(day_of_week(\"2022-01-01\")) # Wednesday\n    print(day_of_week(\"2020-07-04\")) # Saturday\n    print(day_of_week(\"2019-12-25\")) # Wednesday\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1854": "```\ndef maximumPopulation(log):\n    years = [0] * 101\n    for i, j in enumerate(log):\n        years[j[0]] = i + 1\n    max_year = years.index(min(y for y in years if y))\n    return max_year\n\ndef main():\n    log = [[1993,4],[1971,-1],[1987,10]]\n    print(maximumPopulation(log)) # Should be 1993\n    \n    log = [[1950,50],[1962,-1],[1960,12]]\n    print(maximumPopulation(log)) # Should be 1960\n    \n    log = [[2000,20],[2004,15],[2001,10]]\n    print(maximumPopulation(log)) # Should be 2000\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1855": "```\ndef maxDistance(nums):\n    nums.sort()\n    max_dist = 0\n    for i in range(len(nums) - 1):\n        left, right = nums[i], nums[i + 1]\n        while True:\n            mid = (left + right) // 2\n            if binary_search(nums, mid, left) and binary_search(nums, mid, right):\n                max_dist = max(max_dist, right - left)\n                break\n            elif mid < left:\n                right = mid\n            else:\n                left = mid + 1\n    return max_dist\n\ndef binary_search(nums, target, start):\n    l, r = start, len(nums) - 1\n    while l <= r:\n        m = (l + r) // 2\n        if nums[m] <= target:\n            l = m + 1\n        else:\n            r = m - 1\n    return l\n\ndef main():\n    print(maxDistance([3, 4, 1, 2, 5]))  # Expected output: 6\n    print(maxDistance([10, 5, 9, 3, 8, 2, 6, 7, 1, 4]))  # Expected output: 11\n    print(maxDistance([1, 2, 3, 4, 5]))  # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1856": "```\ndef maxMinProduct(nums):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    min_product = [float('inf')] * (n + 1)\n\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        min_product[i + 1] = min(min_product[i], nums[i])\n\n    stack = []\n    max_product = float('-inf')\n    for i in range(n - 1, -1, -1):\n        while len(stack) > 0 and stack[-1] < nums[i]:\n            last_index = stack.pop()\n            max_product = max(max_product, min_product[last_index] * (prefix_sum[n] - prefix_sum[last_index]))\n        stack.append(i)\n\n    return max_product\n\n\ndef main():\n    print(maxMinProduct([2,3,-1,5,-9]))  # Expected output: 6\n    print(maxMinProduct([-2,0,-1]) )   # Expected output: 0\n    print(maxMinProduct([3,-2,0,4]) )   # Expected output: 8\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1857": "```\ndef largestColorValue(graph):\n    in_degree = {node: 0 for node in graph}\n    out_degree = {node: [] for node in graph}\n\n    for node, neighbors in graph.items():\n        for neighbor in neighbors:\n            out_degree[node].append(neighbor)\n            in_degree[neighbor] += 1\n\n    queue = [node for node in graph if in_degree[node] == 0]\n    visited = set()\n\n    memo = {}\n\n    def dfs(node):\n        if node in visited:\n            return memo.get(node, -1)\n\n        visited.add(node)\n        color = 0\n        for neighbor in out_degree[node]:\n            color = max(color, dfs(neighbor) + 1)\n\n        memo[node] = color\n\n        return color\n\n    largest_color = 0\n\n    while queue:\n        node = queue.pop(0)\n        largest_color = max(largest_color, dfs(node))\n\n    return largest_color\n\n\ndef main():\n    graph1 = {\"A\": [\"B\"], \"B\": [\"C\"], \"C\": [\"D\"]}\n    print(\"Test case 1: \", largestColorValue(graph1))  # Expected output: 2\n\n    graph2 = {\"E\": [\"F\", \"G\"], \"F\": [], \"G\": [\"F\"], \"H\": [\"I\"], \"I\": []}\n    print(\"Test case 2: \", largestColorValue(graph2))  # Expected output: 3\n\n    graph3 = {\"W\": [\"X\", \"Y\", \"Z\"], \"X\": [], \"Y\": [\"X\", \"Z\"], \"Z\": [\"W\"]}\n    print(\"Test case 3: \", largestColorValue(graph3))  # Expected output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1858": "```\ndef longestWord(root):\n    def dfs(node, word):\n        if node:\n            return max((dfs(child, word + child.val) for child in node.children), default='')\n        return word\n\n    def build_trie(words):\n        root = TrieNode()\n        for word in words:\n            node = root\n            for char in word:\n                if not node.children.get(char):\n                    node.children[char] = TrieNode()\n                node = node.children[char]\n            node.is_word = True\n        return root\n\n    class TrieNode:\n        def __init__(self):\n            self.children = {}\n            self.is_word = False\n\n    class Solution:\n        def longestWord(self, words: List[str]) -> str:\n            root = build_trie(words)\n            max_len = 0\n            longest_word = ''\n            for word in words:\n                if len(word) > max_len and dfs(root, word) == word:\n                    max_len = len(word)\n                    longest_word = word\n            return longest_word\n\n    def main():\n        solution = Solution()\n        print(solution.longestWord([\"cat\",\"bt\",\"hat\",\"tree\"])) # Output: \"hat\"\n        print(solution.longestWord([\"a\",\"apple\",\"ap\"])) # Output: \"apple\"\n        print(solution.longestWord([\"aaa\",\"aa\",\"a\"])) # Output: \"aaa\"\n\n    if __name__ == \"__main__\":\n        main()\n```",
  "1859": "```\ndef sort_sentence(s):\n    words = s.split()\n    sorted_words = sorted(words)\n    return ' '.join(sorted_words)\n\ndef main():\n    print(sort_sentence(\"is two powered by a lovely stretch and run\"))\n    print(sort_sentence(\"Testing1    Testing2   Testing3 - KAc\"))\n    print(sort_sentence(\"a b c\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1860": "```\ndef memoryLeak(N):\n    leaks = [0] * (N + 1)\n    max_leaks = 0\n    for i in range(2, N + 1):\n        for j in range(i - 1, 0, -1):\n            leaks[j] += 1\n            if leaks[j] > max_leaks:\n                max_leaks = leaks[j]\n    return max_leaks\n\ndef main():\n    print(\"Test Case 1: \", memoryLeak(10))\n    print(\"Test Case 2: \", memoryLeak(5))\n    print(\"Test Case 3: \", memoryLeak(20))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1861": "```\ndef minAreaRect(points):\n    point_set = set(tuple(point) for point in points)\n    area_min = float('inf')\n    \n    for i in range(len(points)):\n        for j in range(i+1, len(points)):\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            \n            if (x1, y2) in point_set and (x2, y1) in point_set:\n                dx = abs(x2 - x1)\n                dy = abs(y2 - y1)\n                \n                area = dx * dy\n                area_min = min(area_min, area)\n    \n    return area_min\n\n\ndef main():\n    test_cases = [\n        [[1, 1], [1, 3], [3, 1], [3, 3]],\n        [[0,0],[1,0],[0,2],[2,2]],\n        [[5,5],[4,7],[7,5],[7,6]]\n    ]\n    \n    for test_case in test_cases:\n        print(f\"Test case: {test_case}\")\n        result = minAreaRect(test_case)\n        print(f\"Result: {result}\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1862": "```\ndef sumOfFlooredPairs(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    left_sum = 0\n    right_sum = total_sum\n    total_pairs = 0\n    \n    for i in range(n-1, -1, -1):\n        left_sum += nums[i]\n        total_pairs += (right_sum - left_sum) // (i + 1)\n        right_sum -= nums[i]\n    \n    return total_pairs\n\ndef main():\n    print(sumOfFlooredPairs([10,3,2])) # expected output: 5\n    print(sumOfFlooredPairs([1,0])) # expected output: 0\n    print(sumOfFlooredPairs([7,1,6,5,4])) # expected output: 20\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1863": "```\ndef subsetXORSum(nums):\n    total_xor = 0\n    for num in nums:\n        total_xor ^= num\n    n = len(nums)\n    if n == 1:\n        return total_xor * 2\n    total_xor ^= (1 << n) - 1\n    half = total_xor ^ ((1 << n) - 1)\n    return total_xor + half\n\ndef main():\n    print(subsetXORSum([5,1,3]) == 12)\n    print(subsetXORSum([5,2,8]) == 0)\n    print(subsetXORSum([10,5,2]) == 47)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1864": "```\ndef minSwaps(string):\n    n = len(string)\n    res = 0\n    prev = string[0]\n    for i in range(1, n):\n        if (string[i] == prev):\n            res += 1\n        prev = \"1\" if prev == \"0\" else \"0\"\n    return res\n\ndef main():\n    print(minSwaps(\"111000\")) # Test Case 1\n    print(minSwags(\"01010101\")) # Test Case 2\n    print(minSwaps(\"11001100\")) # Test Case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1865": "```\ndef numPairsDivisibleBy60(musics):\n    count = {}\n    for music in musics:\n        if music % 60 in count:\n            count[music % 60] += 1\n        else:\n            count[music % 60] = 1\n    pairs = 0\n    for i in range(60):\n        if (i % 60 + 30) % 60 in count and i % 60 in count:\n            pairs += count[i % 60] * count[(i % 60 + 30) % 60]\n    return pairs\n\ndef main():\n    print(numPairsDivisibleBy60([60,60,60])) # Test case 1\n    print(numPairsDivisibleBy60([0,60,60])) # Test case 2\n    print(numPairsDivisibleBy60([60])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1866": "```\ndef numWays(sticks, k):\n    MOD = 10**9 + 7\n    dp = [0] * (k+1)\n    dp[0] = 1\n    for i in range(1, k+1):\n        for j in range(i, min(i+len(str(i)), sticks)+1):\n            dp[i] += dp[i-1] % MOD\n    return dp[k]\n\ndef main():\n    print(numWays(3, 2) == 6)\n    print(numWays(10, 4) == 1650)\n    print(numWays(30, 8) == 155117520)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1867": "```\ndef maximumAverageAmount(trips):\n    total_amount = sum(amt for _, amt in trips)\n    return sum(max(amt for _amt, amt in trip) \n               for trip in trips if max(amt for _amt, amt in trip) > (total_amount / len(trips)))\n\ndef main():\n    # Test case 1\n    trips1 = [(\"John\", 10), (\"Mary\", 15), (\"Jane\", 20)]\n    print(\"Test Case 1: \", maximumAverageAmount(trips1))\n\n    # Test case 2\n    trips2 = [(\"Alice\", 5), (\"Bob\", 6), (\"Charlie\", 7), (\"David\", 8), (\"Eve\", 9)]\n    print(\"Test Case 2: \", maximumAverageAmount(trips2))\n\n    # Test case 3\n    trips3 = [(\"Jim\", 10), (\"Pam\", 15), (\"Ryan\", 20), (\"Leslie\", 25), (\"Andy\", 30)]\n    print(\"Test Case 3: \", maximumAverageAmount(trips3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1868": "```\ndef productEncoding(a, b):\n    m, n = len(a), len(b)\n    i, j = 0, 0\n    result = []\n    \n    while i < m or j < n:\n        if i + 1 == m and j + 1 != n:\n            result.append(a[i] * b[j])\n            j += 1\n        elif j + 1 == n and i + 1 != m:\n            result.append(a[i] * b[j])\n            i += 1\n        elif a[i] == b[j]:\n            count = 1\n            while i + 1 < m and j + 1 < n and a[i] == b[j]:\n                if i + 1 == m or j + 1 == n:\n                    break\n                i += 1\n                j += 1\n            for k in range(count):\n                result.append(a[i - count] * b[j - count])\n        else:\n            if a[i] < b[j]:\n                i += 1\n            else:\n                j += 1\n                \n    return result\n\ndef main():\n    print(productEncoding([1,2,3],[1,1])) # Test case 1: Expected output: [1,4]\n    print(productEncoding([1, 1], [0])) # Test case 2: Expected output: []\n    print(productEncoding([0, 1, 2, 3], [9, 8, 7])) # Test case 3: Expected output: [0, 0, 0, 0]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1869": "```\ndef findMaxLength(head):\n    max_len = 0\n    count = 0\n    prev = None\n    \n    while head:\n        if head.val == 1:\n            count += 1\n        else:\n            count -= 1\n        \n        if prev and prev.val != head.val:\n            max_len = max(max_len, count)\n        \n        prev = head\n        head = head.next\n    \n    return max_len\n\ndef main():\n    # Test case 1\n    head1 = ListNode(0)\n    head1.next = ListNode(1)\n    head1.next.next = ListNode(0)\n    head1.next.next.next = ListNode(1)\n    print(findMaxLength(head1))  # Output: 2\n\n    # Test case 2\n    head2 = ListNode(0)\n    head2.next = ListNode(1)\n    head2.next.next = ListNode(1)\n    head2.next.next.next = ListNode(1)\n    print(findMaxLength(head2))  # Output: 4\n\n    # Test case 3\n    head3 = ListNode(1)\n    head3.next = ListNode(0)\n    head3.next.next = ListNode(1)\n    head3.next.next.next = ListNode(1)\n    head3.next.next.next.next = ListNode(0)\n    print(findMaxLength(head3))  # Output: 4\n\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1870": "```\ndef minSteps(n: int) -> int:\n    i = 1\n    while i * i < n:\n        i += 1\n    return (n - i + 1) // i\n\ndef main():\n    print(minSteps(2))  # Test case 1\n    print(minSteps(5))  # Test case 2\n    print(minSteps(3))   # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1871": "```\ndef minAddToMakeValid(S):\n    res = 0\n    stack = []\n    for c in S:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if stack:\n                stack.pop()\n            else:\n                res += 1\n    return res + len(stack)\n\ndef main():\n    print(minAddToMakeValid(\"())\")) # Expected: 2\n    print(minAddToMakeValid(\"(\"))   # Expected: 1\n    print(minAddToMakeValid(\"((()))\")) # Expected: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1872": "```\ndef stoneGameVIII(ales):\n    n = len(ales)\n    ales = [0] + ales\n    dp = [[0] * (n+1) for _ in range(n+1)]\n    for i in range(n):\n        for j in range(i, -1, -1):\n            if i % 2 == 0:\n                dp[i+1][j] = max(ales[j+1]-ales[j], dp[i][j+1])\n            else:\n                dp[i+1][j] = min(ales[j+1]-ales[j], dp[i][j+1])\n    return dp[-1][-1]\n\ndef main():\n    print(stoneGameVIII([5, 3, 1, 4, 2])) # Expected output: 6\n    print(stoneGameVIII([7, 10, 6, 4, 8, 12])) # Expected output: 27\n    print(stoneGameVIII([14, 19, 5, 2, 16, 13, 1, 9, 11, 3, 18, 4, 7, 10, 6, 8, 15])) # Expected output: 44\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1873": "```\ndef specialBonus(average, hours):\n    if average < 10:\n        return 0\n    elif average >= 10 and average < 20:\n        return (hours * 1) // 3\n    else:\n        return hours\n\ndef main():\n    print(\"Test Case 1:\")\n    print(specialBonus(8, 40), \"expected: 0\")\n    \n    print(\"\\nTest Case 2:\")\n    print(specialBonus(15, 20), \"expected: 6\")\n    \n    print(\"\\nTest Case 3:\")\n    print(specialBonus(25, 30), \"expected: 30\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1874": "```\ndef minProductSum(nums1, nums2):\n    nums1.sort()\n    nums2.sort(reverse=True)\n    \n    res = 0\n    i, j = 0, len(nums2) - 1\n    \n    while i < len(nums1) and j >= 0:\n        res += nums1[i] * nums2[j]\n        i += 1\n        j -= 1\n        \n    return res\n\ndef main():\n    print(minProductSum([7,6,5], [5,4,3])) # Expected: 30\n    print(minProductSum([8,2,9,8,7,2,4], [10,5,3,2,4,1,0])) # Expected: 61\n    print(minProductSort([10,5,3,2,4,1,0], [0,1,2,3,4,5,10])) # Expected: 70\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1875": "```\ndef get_groups(employees):\n    salary_to_employees = {}\n    for employee in employees:\n        if employee[1] not in salary_to_employees:\n            salary_to_employees[employee[1]] = [employee[0]]\n        else:\n            salary_to_employees[employee[1]].append(employee[0])\n    return list(salary_to_employees.values())\n\ndef main():\n    test_case1 = [[\"John\", 100], [\"Alice\", 100], [\"Bob\", 200]]\n    print(\"Test Case 1:\")\n    print(get_groups(test_case1))\n    \n    test_case2 = [[\"Jim\", 150], [\"Pam\", 150], [\"Sam\", 250]]\n    print(\"\\nTest Case 2:\")\n    print(get_groups(test_case2))\n\n    test_case3 = [[\"Emily\", 120], [\"Michael\", 130], [\"Sarah\", 140]]\n    print(\"\\nTest Case 3:\")\n    print(get_groups(test_case3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1876": "```\ndef countGoodSubstrings(s):\n    n = len(s)\n    ans = 0\n    for i in range(n - 2):\n        seen = set()\n        for j in range(3):\n            if s[i + j] not in seen:\n                seen.add(s[i + j])\n            else:\n                break\n        else:\n            ans += 1\n    return ans\n\n\ndef main():\n    print(countGoodSubstrings(\"aabdc\")) # Test case 1: Expected output = 1\n    print(countGoodSubstrings(\"abaca\")) # Test case 2: Expected output = 2\n    print(countGoodSubstrings(\"abcabc\")) # Test case 3: Expected output = 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1877": "```\ndef maxPairSum(nums):\n    nums.sort()\n    n = len(nums)\n    return sum(max(num1 + num2 for num1 in nums[:n//2]) for _ in range(n//2))\n\ndef main():\n    print(\"Test Case 1:\")\n    print(minimizeMaxPairSum([3,5,2,7])) # Expected Output: 11\n\n    print(\"\\nTest Case 2:\")\n    print(minimizeMaxPairSum([10,12])) # Expected Output: 22\n\n    print(\"\\nTest Case 3:\")\n    print(minimizeMaxPairSum([1,2,3,4,5])) # Expected Output: 9\n\nmain()\n```",
  "1878": "```\nfrom heapq import heapify, heappop, heappush\n\ndef maxRHOMBUS(grid):\n    m, n = len(grid), len(grid[0])\n    prefix_sum = [[0] * (n+1) for _ in range(m+1)]\n\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            prefix_sum[i][j] = grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]\n\n    max_sums = []\n    for i in range(m):\n        for j in range(n):\n            rhombus_sum = 0\n            for k in range(3):\n                x, y = (i+k)%m, (j-k)%n\n                rhombus_sum += prefix_sum[x][y]\n            max_sums.append(-rhombus_sum)\n    heapify(max_sums)\n    return -heappop(max_sums)-heappop(max_sums)-heappop(max_sums)\n\n\ndef main():\n    print(maxRHOMBUS([[1,2,-1,-4,-20], [-8,-3,0,10,15], [5,10,10,15,20]]))  # Output: 30\n    print(maxRHOMBUS([[3,9,9,4,6,23],[15,1,2,3,7,8],[5,1,1,2,3,4],[4,3,2,5,25,47],[16,2,3,20,8,28]]))  # Output: 60\n    print(maxRHOMBUS([[10,13,14,-15,-15,-15], [-15,13,10,-12, -2,18], [-1,-6,9,5,4,0], [0, -3,7,3,8, 2], [16,-14, 7,4,5,5]]))  # Output: 30\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1879": "```\ndef findMinimumXOR(arr1, arr2):\n    dp = [[float('inf')] * (1 << 16) for _ in range(20)]\n    dp[0][0] = 0\n    for i in range(len(arr1)):\n        for j in range((1 << 16), -1, -1):\n            if ((j & (1 << 15)) == 0 and arr1[i] <= j >> 15) or ((j & (1 << 15)) > 0 and j < (1 << 16)):\n                dp[i + 1][j ^ arr1[i]] = min(dp[i + 1][j ^ arr1[i]], dp[i][j])\n    res = float('inf')\n    for i in range(len(arr2)):\n        for j in range((1 << 16), -1, -1):\n            if ((j & (1 << 15)) == 0 and arr2[i] <= j >> 15) or ((j & (1 << 15)) > 0 and j < (1 << 16)):\n                res = min(res, dp[-1][j ^ arr2[i]])\n    return res\n\ndef main():\n    print(findMinimumXOR([8, 6], [14, 3, 10]) ) \n    print(findMinimumXOR([2, 5, 1, 3], [4, 7, 0, 9]) ) \n    print(findMinimumXOR([34, 11, 19, 23, 41], [41, 36, 13, 27, 20]) ) \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1880": "```\ndef wordEquivalence(word1, word2):\n    return sum(set(word1)) == sum(set(word2))\n\ndef main():\n    print(\"Test Case 1: \", wordEquivalence(\"abc\", \"bcd\"))\n    print(\"Test Case 2: \", wordEquivalence(\"abbccdd\", \"abcdedf\"))\n    print(\"Test Case 3: \", wordEquivalence(\"word\", \"wo+r+d\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1881": "```\ndef maxValueAfterInsertions(nums):\n    nums = list(map(int, nums))\n    n = len(nums)\n    res = [nums[0]]\n    for i in range(1, n):\n        if nums[i] > res[-1]:\n            res.append(nums[i])\n        else:\n            res[-1] = str(res[-1]) + str(nums[i])\n    return int(''.join(map(str, res)))\n\ndef main():\n    print(maxValueAfterInsertions([\"123\", \"456\", \"789\"])) # Expected output: 987\n    print(maxValueAfterInsertions([\"5\", \"2\", \"6\", \"4\"])) # Expected output: 654\n    print(maxValueAfterInsertions([\"1\", \"3\", \"10\", \"4\", \"20\"])) # Expected output: 1020\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1882": "```\nimport heapq\n\ndef assignTasks(n, tasks):\n    server_status = [[i, 0] for i in range(n)]\n    remaining_tasks = sorted((task, i) for i, task in enumerate(tasks))\n    ans = []\n\n    while remaining_tasks:\n        new_server_status = []\n        for server in server_status:\n            time_taken = server[1]\n            if time_taken < server[0]:\n                heapq.heappush(new_server_status, (server[0] - time_taken, server))\n            else:\n                ans.append(server[0])\n                ans.append(remaining_tasks.pop(0)[0])\n                new_server_status.append((server[0], 0))\n\n        server_status = new_server_status\n\n    return ans\n\ndef main():\n    print(assignTasks(2, [81,50,143])) \n    print(assignTasks(3, [19,66,99])) \n    print(assignTasks(5, [91,95,92,94,93]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1883": "```\ndef minSkips(timeToWalk, timeToMeeting):\n    n = len(timeToWalk)\n    dp = [[float('inf')] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        dp[i][0] = min(dp[i - 1][0], timeToWalk[i - 1])\n    for j in range(1, n + 1):\n        for i in range(n, -1, -1):\n            if i == n:\n                break\n            dp[i][j] = min(dp[i][j - 1], timeToMeeting - (n - i) * timeToWalk[0])\n    return min(dp[-2])\n\ndef main():\n    print(minSkips([10, 2, 3]) == 3)\n    print(minSkips([4,5,6,7]) == 4)\n    print(minSkips([1, 2, 3]) == 1)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1884": "```\ndef twoEggDrop(n):\n    dp = [[0 for _ in range(n + 1)] for _ in range(2 + 1)]\n    \n    for i in range(1, n + 1):\n        dp[1][i] = i\n    \n    for k in range(1, 2 + 1):\n        dp[k][1] = 1\n        dp[k][0] = 0\n    \n    for i in range(2, n + 1):\n        for j in range(2, min(i, k) + 1):\n            dp[2][i] = min(max(dp[1][x-1]+1+dp[1][i-x], dp[1][j-1]+1+dp[1][i-j]) for x in range(j))\n    \n    return dp[2][n]\n\ndef main():\n    print(twoEggDrop(10))  # Expected: 4\n    print(twoEggDrop(5))   # Expected: 3\n    print(twoEggDrop(8))   # Expected: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1885": "```\ndef count_pairs(nums1, nums2):\n    nums1.sort()\n    nums2.sort()\n    i = j = 0\n    total = 0\n    while i < len(nums1) and j < len(nums2):\n        if nums1[i] <= nums2[j]:\n            total += len(nums2) - j\n            i += 1\n        else:\n            j += 1\n    return total\n\ndef main():\n    print(count_pairs([1, 3], [1, 6])) \n    print(count_pairs([1, 4], [1, 5])) \n    print(count_pairs([2, 1], [1, 4]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1886": "```\ndef findRotation(mat, target):\n    if len(mat) == 0:\n        return False\n    for _ in range(4):\n        if mat == target:\n            return True\n        mat = list(map(list, zip(*mat)))\n    return False\n\n\ndef main():\n    print(findRotation([[0,1],[1,0]], [[0,0],[0,1]])) \n    print(findRotation([[0,0,0],[0,1,0],[1,1,1]], [[1,2,3],[4,5,0],[7,6,9]]))\n    print(findRotation([[1,2,3],[4,5,0],[7,6,9]], [[1,2,3],[4,5,0],[7,6,9]]))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1887": "```\ndef reductionOperations(arr):\n    arr.sort()\n    operations = 0\n    for i in range(len(arr) - 1):\n        operations += (arr[-1] - arr[i]) // (i + 1)\n    return operations\n\n\ndef main():\n    print(reductionOperations([9, 18, 61, 82, 85]))  # Output: 7\n    print(reductionOperations([6, 6, 6, 6, 6]))  # Output: 0\n    print(reductionOperations([10]) )  # Output: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1888": "```\ndef minFlips(string):\n    n = len(string)\n    flips = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if string[i - 1] == '0':\n            flips[i] = flips[i - 1] + 1\n        else:\n            flips[i] = flips[i - 1]\n\n    return flips[-1]\n\n\ndef main():\n    print(minFlips(\"01100\"))  # Test case 1\n    print(minFlips(\"01010101\"))  # Test case 2\n    print(minFlips(\"11111\"))  # Test case 3\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1889": "```\ndef minSpaceWasted(w):\n    w.sort()\n    wasted = 0\n    for i in range(1, len(w)):\n        wasted += (w[i] - w[i-1]) // 2\n    return wasted\n\n\ndef main():\n    print(minSpaceWasted([5,4,4,3]))\n    print(minSpaceWasted([9,6,8,7,7]))\n    print(minSpaceWasted([6]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1890": "```\ndef latestLogin(logins):\n    login_times = [int(login.split(\":\")[1]) for login in logins]\n    max_time = max(login_times)\n    return f\"The latest login was at {max_time}.\"\n\ndef main():\n    print(latestLogin([\"2000:05:01 14:30\", \"2020:07:16 15:45\", \"2018:09:10 12:00\"]))\n    print(latestLogin([\"2022:03:11 13:50\", \"2021:04:17 08:20\", \"2019:02:28 14:10\"]))\n    print(latestLogin([\"1995:01:31 15:45\", \"1990:12:25 12:00\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1891": "```\ndef minCost(heights):\n    n = len(heights)\n    cost = [0] * n\n    for i in range(1, n):\n        if heights[i] > heights[i - 1]:\n            cost[i] = cost[i - 1] + (heights[i] - heights[i - 1])\n        else:\n            j = binary_search(heights[:i], heights[i])\n            cost[i] = cost[j - 1] + min(heights[i] - heights[j], heights[i - 1] - heights[0])\n\n    return min(cost)\n\ndef binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return left\n\ndef main():\n    print(minCost([10, 1, 2, 3, 6, 7, 8]))  # Expected output: 7\n    print(minCost([5, 4, 4, 3, 2, 2, 1, 1]))  # Expected output: 12\n    print(minCost([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]))  # Expected output: 15\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1892": "```\ndef pageRecommendationsII(logs):\n    user_id_count = {}\n    item_id_count = {}\n    \n    for log in logs:\n        user_id, item_id = log[0], log[1]\n        \n        if user_id not in user_id_count:\n            user_id_count[user_id] = 0\n        if item_id not in item_id_count:\n            item_id_count[item_id] = 0\n        \n        user_id_count[user_id] += 1\n        item_id_count[item_id] += 1\n    \n    return [(user_id, k) for user_id in user_id_count for k in sorted([item_id for item_id in item_id_count if user_id_count[user_id] >= item_id_count[item_id]])]\n\ndef main():\n    logs = [[1,2],[3,4],[2,5],[1,3],[5,6]]\n    print(pageRecommendationsII(logs))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1893": "```\ndef rangeCovered(nums):\n    nums.sort()\n    covered = set()\n    for num in nums:\n        if num - 1 not in covered:\n            covered.add(num)\n    return len(covered) == sum(range(min(nums), max(nums)+1))\n\ndef main():\n    print(\"Test Case 1: \")\n    print(rangeCovered([0,2,3,4,5,6])) # Expected output: True\n    print()\n\n    print(\"Test Case 2: \")\n    print(rangeCovered([0,1,2,4,5,6])) # Expected output: False\n    print()\n\n    print(\"Test Case 3: \")\n    print(rangeCovered([1,2,3,4,5,6])) # Expected output: False\n    print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1894": "```\ndef chalkReplacer(score, chalkCost):\n    totalScore = sum(score)\n    students.sort()\n    for i in range(len(students)):\n        if totalScore - score[i] >= chalkCost:\n            return i\n    return -1\n\n\nif __name__ == \"__main__\":\n    main()\n\ndef main():\n    test_cases = [\n        {\"score\": [100, 200, 150, 300], \"chalk_cost\": 50},\n        {\"score\": [10, 20, 30, 40], \"chalk_cost\": 5},\n        {\"score\": [2, 4, 6, 8], \"chalk_cost\": 1}\n    ]\n\n    for test_case in test_cases:\n        score = test_case[\"score\"]\n        chalk_cost = test_case[\"chalk_cost\"]\n        print(f\"Test case: {score}, Chalk Cost: {chalk_cost}\")\n        result = chalkReplacer(score, chalk_cost)\n        print(f\"Result: {result}\\n\")\n```",
  "1895": "```\ndef largestMagicSquare(n):\n    magicSquares = [[0 for _ in range(n)] for _ in range(n)]\n    maxSize = 1\n    for size in range(1, n + 1):\n        if size * size > n:\n            break\n        for i in range(n - size * size + 1):\n            for j in range(n - size * size + 1):\n                isMagic = True\n                for k in range(size):\n                    for col in range(size):\n                        magicSquares[i + k][j + col] += (k + j) % 2\n                    if any(magicSquares[i + k][j + size - 1] != c for k, c in enumerate(range(1, size * size + 1))):\n                        isMagic = False\n                        break\n                if isMagic:\n                    maxSize = size\n                    break\n            if isMagic:\n                break\n    return maxSize\n\ndef main():\n    print(largestMagicSquare(4))\n    print(largestMagicSquare(5))\n    print(largestMagicSquare(6))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1896": "```\ndef finalValueAfterXi(x):\n    res = 0\n    for _ in range(30):\n        if ((1 << _) & x) > 0:\n            res += 2**_\n    return res\n\ndef main():\n    print(finalValueAfterXi(18)) # expected output: 5\n    print(finalValueAfterXi(6)) # expected output: 3\n    print(finalValueAfterXi(10)) # expected output: 4\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1897": "```\ndef makeEqual(s):\n    n = len(s)\n    total_chars = {}\n    \n    for char in s:\n        if char not in total_chars:\n            total_chars[char] = 0\n        total_chars[char] += 1\n    \n    max_len = max(len(str) for str in total_chars.keys())\n    res = [''] * n\n\n    for i, char in enumerate(s):\n        res[i] = (max_len - len(char)) * '0' + char\n\n    return res\n\n\ndef main():\n    print(makeEqual([\"cool\",\"lock\",\"cook\"])) \n    print(makeEqual([\"cool\",\"lock\",\"tool\"]))\n    print(makeEqual([\"elvis\",\"elsie\",\"evils\"]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1898": "```\ndef maximumRemovableCharacters(s: str) -> int:\n    n = len(s)\n    left, right = 0, n - 1\n    removable_chars = 0\n    \n    while left < right:\n        if s[left] == s[right]:\n            for i in range(left + 1):\n                if s[i] != s[left]:\n                    break\n            for j in range(right - 1, -1, -1):\n                if s[j] != s[right]:\n                    break\n            removable_chars += (right - left) - (j - i + 1)\n            left = i\n            right = j\n        else:\n            if s[left] < s[right]:\n                for i in range(left + 1):\n                    if s[i] > s[left]:\n                        break\n                left = i\n            else:\n                for j in range(right - 1, -1, -1):\n                    if s[j] < s[right]:\n                        break\n                right = j\n    \n    return removable_chars\n\n\ndef main():\n    print(maximumRemovableCharacters(\"aba\")) \n    print(maximumRemovableCharacters(\"azbazb\"))  \n    print(maximumRemovableCharacters(\"abcba\"))  \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1899": "```\ndef canFormArray(word1, word2):\n    n = len(word1)\n    m = len(word2)\n    i = j = k = 0\n    while i < n or j < m:\n        if i < n and j < m and word1[i] == word2[j]:\n            i += 1\n            j += 1\n        elif i < n:\n            i += 1\n        elif j < m:\n            j += 1\n    return i == n\n\ndef main():\n    print(canFormArray(\"abc\", \"ahbgdc\")) # Expected: True\n    print(canFormArray(\"abbcccd\", \"abcd\")) # Expected: False\n    print(canFormArray(\"\", \"\")) # Expected: True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1900": "```\ndef earliestAndLatest(n: int, firstPlayers: List[int], secondPlayers: List[int]) -> List[int]:\n    # Your solution here\n\ndef main():\n    print(earliestAndLatest(7, [1,2,4], [6]))  # expected output: [1, 5]\n    print(earliestAndLatest(11, [1,3,5,10,12,13,15], [6,8,9,14,16,17]))  \n    print(earliestAndLatest(2, [1,2], [1,2]))  # expected output: [1, 1]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1901": "```\ndef findPeakGrid(grid):\n    def dfs(i, j):\n        if i == 0 or grid[i][j] >= grid[i-1][j]:\n            if j == len(grid[0]) - 1 or grid[i][j] >= grid[i][j+1]:\n                return [i, j]\n            else:\n                return dfs(i, j + 1)\n        else:\n            if j == len(grid[0]) - 1 or grid[i-1][j] <= grid[i][j]:\n                return [i-1, j]\n            else:\n                return dfs(i-1, j)\n\n    m, n = len(grid), len(grid[0])\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or grid[i][j] >= grid[i-1][j]:\n                if j == n - 1 or grid[i][j] >= grid[i][j+1]:\n                    return dfs(i, j)\n\n    return []\n\ndef main():\n    test_cases = [\n        {\n            \"grid\": [[1,4,5],[2,3,6],[8,9,7]],\n            \"expected_result\": [1, 2]\n        },\n        {\n            \"grid\": [[1,3,5],[4,2,6],[8,9,7]],\n            \"expected_result\": [0, 2]\n        },\n        {\n            \"grid\": [[1,2,3],[3,2,1]],\n            \"expected_result\": [0, 0]\n        }\n    ]\n\n    for test_case in test_cases:\n        result = findPeakGrid(test_case[\"grid\"])\n        if result == test_case[\"expected_result\"]:\n            print(\"Test case passed\")\n        else:\n            print(f\"Test case failed. Expected {test_case['expected_result']} but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1902": "```\ndef insertIntoBST(root, val):\n    if not root:\n        return TreeNode(val)\n    elif val < root.val:\n        root.left = insertIntoBST(root.left, val)\n    else:\n        root.right = insertIntoBST(root.right, val)\n    return root\n\n\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\ndef depthOfBT(root):\n    if not root:\n        return 0\n    else:\n        leftDepth = depthOfBT(root.left)\n        rightDepth = depthOfBT(root.right)\n        return max(leftDepth, rightDepth) + 1\n\n\ndef main():\n    test1_root = TreeNode(4)\n    test1_root.left = TreeNode(2)\n    test1_root.right = TreeNode(7)\n    test1_root.left.left = TreeNode(1)\n    test1_root.left.right = TreeNode(3)\n\n    print(\"Test 1:\", depthOfBT(test1_root))\n\n    test2_root = None\n    print(\"Test 2:\", depthOfBT(test2_root))\n\n    test3_root = TreeNode(5)\n    print(\"Test 3:\", depthOfBT(test3_root))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1903": "```\ndef largestOddNumber(numString):\n    oddNumbers = [int(x) for x in numString if int(x) % 2 != 0]\n    return max(oddNumbers, default=-1)\n\ndef main():\n    print(largestOddNumber(\"50x23\")) # Expected output: 23\n    print(largestOddNumber(\"13\")) # Expected output: 13\n    print(largestOddNumber(\"52\")) # Expected output: -1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1904": "```\ndef fullRounds(time):\n    h, m = map(int, time.split(':'))\n    return (h * 60 + m) // 15\n\ndef main():\n    print(fullRounds(\"08:49\"))  # Test case 1\n    print(fullRounds(\"10:00\"))  # Test case 2\n    print(fullRounds(\"12:59\"))  # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1905": "```\ndef countSubIslands(grid1, grid2):\n    if not grid1 or not grid2:\n        return 0\n    \n    def dfs(i, j):\n        if i<0 or i>=len(grid1) or j<0 or j>=len(grid1[0]) or not grid1[i][j] or not grid2[i][j]:\n            return\n        grid1[i][j], grid2[i][j] = 0, 0\n        dfs(i-1, j)\n        dfs(i+1, j)\n        dfs(i, j-1)\n        dfs(i, j+1)\n\n    count = 0\n    for i in range(len(grid1)):\n        for j in range(len(grid1[0])):\n            if grid1[i][j] and grid2[i][j]:\n                dfs(i, j)\n                count += 1\n\n    return count\n\n\ndef main():\n    test_case_1 = [\n        [\"L\",\"E\",\"X\",\"L\",\"E\"],\n        [\"X\",\"R\",\"T\",\"V\",\"Y\"],\n        [\"B\",\"E\",\"T\",\"H\",\"L\"],\n        [\"P\",\"C\",\"F\",\"I\",\"K\"],\n        [\"S\",\"J\",\"D\",\"G\",\"A\"]\n    ]\n\n    test_case_2 = [\n        [\"L\",\"E\",\"X\",\"L\",\"X\"],\n        [\"X\",\"R\",\"T\",\"V\",\"Y\"],\n        [\"B\",\"E\",\"T\",\"H\",\"L\"],\n        [\"P\",\"C\",\"F\",\"I\",\"K\"],\n        [\"S\",\"J\",\"D\",\"G\",\"A\"]\n    ]\n\n    test_case_3 = [\n        [\"T\",\"S\",\"T\",\"S\",\"X\",\"X\",\"E\",\"R\"],\n        [\"X\",\"X\",\"B\",\"V\",\"Y\",\"T\",\"N\",\"K\"],\n        [\"W\",\"L\",\"M\",\"S\",\"C\",\"P\",\"J\",\"G\"],\n        [\"I\",\"H\",\"A\",\"D\",\"F\",\"Q\",\"O\",\"U\"],\n        [\"N\",\"O\",\"P\",\"E\",\"R\",\"T\",\"S\",\"X\"]\n    ]\n\n    print(countSubIslands(test_case_1, test_case_1))\n    print(countSubIslands(test_case_1, test_case_2))\n    print(countSubIslands(test_case_3, test_case_3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1906": "```\ndef minAbsoluteSumDiffQueries(nums, queries):\n    sorted_nums = sorted((num, i) for i, num in enumerate(nums))\n    res = [0]*len(queries)\n    for q, k in queries:\n        idx = sorted_nums[k][1]\n        res[q] = abs(sorted_nums[idx-1][0]-nums[k]) if q == 0 else abs(sorted_nums[idx][0]-nums[k])\n    return res\n\n\ndef main():\n    test_cases = [\n        [[4,2,3], [(1,0), (2,1)]],\n        [[8,6,7,1,1,4], [(0,1),(1,0),(2,1),(3,2),(4,3)]],\n        [[19, 25, 15, 9, 20], [(13,0),(16,4),(5,0),(11,4),(22,5)]]\n    ]\n    \n    for test_case in test_cases:\n        nums = test_case[0]\n        queries = test_case[1]\n        res = minAbsoluteSumDiffQueries(nums, queries)\n        print(res)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1907": "```\ndef countSalaryCategories(self, salary_info):\n    categories = {}\n    for info in salary_info:\n        category = info[0]\n        salary = int(info[1])\n        if category not in categories:\n            categories[category] = []\n        categories[category].append(salary)\n    return len(categories)\n\ndef main():\n    salary_info = [\n        [\"A\", \"10000\"],\n        [\"B\", \"20000\"],\n        [\"C\", \"5000\"],\n        [\"D\", \"6000\"],\n        [\"E\", \"3000\"],\n        [\"F\", \"4000\"]\n    ]\n    print(countSalaryCategories(salary_info))  # Test Case 1\n\n    salary_info = [\n        [\"A\", \"10000\"],\n        [\"B\", \"20000\"],\n        [\"C\", \"5000\"],\n        [\"D\", \"6000\"],\n        [\"E\", \"3000\"],\n        [\"F\", \"4000\"]\n    ]\n    print(countSalaryCategories(salary_info))  # Test Case 2\n\n    salary_info = []\n    print(countSalaryCategories(salary_info))  # Test Case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1908": "```\ndef canWinNim(n):\n    return n % 4 != 0\n\ndef main():\n    print(canWinNim(1)) # True\n    print(canWinNim(2)) # False\n    print(canWinNim(5)) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1909": "```\ndef canBeIncreasing(nums):\n    for i in range(len(nums) - 1):\n        if nums[i] >= nums[i + 1]:\n            return False\n    return True\n\ndef moveElementsToMakeIncreasing(arr):\n    if len(arr) <= 2:\n        return arr\n    left, right = 0, len(arr) - 1\n    while left < right:\n        if arr[left] >= arr[right]:\n            right -= 1\n        elif arr[right] >= arr[left + 1]:\n            left += 1\n        else:\n            arr.pop(left)\n            return arr\n\ndef main():\n    print(canBeIncreasing([1, 2, 3, 4, 5])) # True\n    print(canBeIncreasing([1, 3, 5, 6, 7])) # False\n    print(moveElementsToMakeIncreasing([1, 2, 3, 4, 5])) # [1, 2, 4, 5]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1910": "```\ndef removeOccurrences(s, part):\n    stack = []\n    result = \"\"\n    for char in s:\n        if len(stack) == 0 or stack[-1] != char:\n            stack.append(char)\n            result += char\n        else:\n            while len(stack) > 0 and stack[-1] == char:\n                stack.pop()\n            if len(stack) == 0:\n                result += part[0]\n    return result\n\ndef main():\n    print(\"Test case 1:\")\n    s = \"daBMcC\";\n    part = \"abc\";\n    print(removeOccurrences(s, part))  # Expected output: \"d\"\n\n    print(\"\\nTest case 2:\")\n    s = \"azxxzy\";\n    part = \"zxy\";\n    print(removeOccurrences(s, part))  # Expected output: \"a\"\n\n    print(\"\\nTest case 3:\")\n    s = \"abcbABA\";\n    part = \"aba\";\n    print(removeOccurrences(s, part))  # Expected output: \"cA\"\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1911": "```\ndef maxAlternatingSum(arr):\n    n = len(arr)\n    if n == 1:\n        return arr[0]\n\n    dp_even = [0] * (n + 1)\n    dp_odd = [0] * (n + 1)\n\n    dp_even[0] = 0\n    dp_odd[0] = 0\n\n    for i in range(1, n):\n        dp_even[i] = max(dp_even[i - 1], arr[i - 1])\n        dp_odd[i] = max(dp_odd[i - 1], -dp_even[i - 1] + arr[i])\n\n    return max(dp_even[-1], dp_odd[-1])\n\n\ndef main():\n    print(\"Test case 1:\")\n    print(maxAlternatingSum([4, 2, 3, 1]))  # Expected output: 9\n\n    print(\"\\nTest case 2:\")\n    print(maxAlternatingSum([-1, 5, -10, 0, 2]))  # Expected output: 7\n\n    print(\"\\nTest case 3:\")\n    print(maxAlternatingSum([100, 50, 20, 10]))  # Expected output: 120\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1912": "```\nfrom collections import defaultdict\n\nclass MovieRentalSystem:\n    def __init__(self):\n        self.movies = {}\n        self.rentals = defaultdict(int)\n\n    def add_movie(self, movie_id: int) -> None:\n        if movie_id not in self.movies:\n            self.movies[movie_id] = 0\n\n    def rent_movie(self, user_id: int, movie_id: int) -> None:\n        if movie_id not in self.movies:\n            return\n        self.rentals[user_id] += 1\n        self.movies[movie_id] += 1\n\n    def return_movie(self, user_id: int, movie_id: int) -> None:\n        if movie_id not in self.movies or self.rentals[user_id] <= 0:\n            return\n        self.rentals[user_id] -= 1\n        self.movies[movie_id] -= 1\n\n    def get_average_rental_days(self, user_id: int) -> float:\n        if user_id not in self.rentals or self.rentals[user_id] == 0:\n            return 0.0\n        return sum(range(1, self.rentals[user_id] + 1)) / self.rentals[user_id]\n\ndef main():\n    system = MovieRentalSystem()\n\n    # Test Case 1: Add a movie and rent it.\n    system.add_movie(1)\n    system.rent_movie(1, 1)\n\n    print(f\"Average rental days for user 1 after renting movie 1: {system.get_average_rental_days(1)}\")\n    # Output: 1.0\n\n    # Test Case 2: Rent another movie.\n    system.rent_movie(1, 2)\n    print(f\"Average rental days for user 1 after renting movie 2: {system.get_average_rental_days(1)}\")\n    # Output: 2.5\n\n    # Test Case 3: Return a movie and rent again.\n    system.return_movie(1, 1)\n    system.rent_movie(1, 1)\n    print(f\"Average rental days for user 1 after returning and renting movie 1 again: {system.get_average_rental_days(1)}\")\n    # Output: 2.5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1913": "```\ndef maxProductDifference(nums):\n    nums.sort()\n    return (nums[-1] - nums[-2]) - (nums[0] - nums[1])\n\ndef main():\n    print(maxProductDifference([10, 2])) # Expected output: 72\n    print(maxProductDifference([-3,7,-2.6])) # Expected output: 56.4\n    print(maxProductDifference([5,4,3,2])) # Expected output: 12\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1915": "```\ndef numWonderfulSubstrings(s):\n    n = len(s)\n    res = [0]\n    for i in range(n):\n        if s[i] == '1':\n            res.append(res[-1] + 1)\n        else:\n            res.append(res[-1])\n    return sum(1 << (i - j) for j, i in enumerate(res))\n\ndef main():\n    print(numWonderfulSubstrings(\"10000110\")) \n    print(numWonderfulSubstrings(\"10101\"))  \n    print(numWonderfulSubstrings(\"0000000\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1914": "```\ndef shiftGrid(grid, k):\n    m, n = len(grid), len(grid[0])\n    new_grid = [[0]*n for _ in range(m)]\n    \n    for i in range(m):\n        for j in range(n):\n            new_row = (i + k // n)\n            new_col = (j + k % n) % n\n            new_grid[new_row][new_col] = grid[i][j]\n            \n    return new_grid\n\ndef main():\n    test_cases = [\n        {\"grid\": [[1,2,3],[4,5,6],[7,8,9]], \"k\": 1, \"expected\": [[9,1,2],[3,4,5],[6,7,8]]},\n        {\"grid\": [[5,6,7,8],[1,2,3,4]], \"k\": 4, \"expected\": [[4,8,1,7],[3,5,6,2]]},\n        {\"grid\": [[1,2], [3,4]], \"k\": 0, \"expected\": [[1,2], [3,4]]}\n    ]\n\n    for test_case in test_cases:\n        grid = test_case[\"grid\"]\n        k = test_case[\"k\"]\n        expected = test_case[\"expected\"]\n        \n        result = shiftGrid(grid, k)\n        \n        if result != expected:\n            print(\"Test Case Failed: Grid and K\", grid, k)\n            print(\"Expected:\", expected)\n            print(\"Result:\", result)\n        else:\n            print(\"Test Case Passed: Grid and K\", grid, k)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1916": "```\ndef numWays(rooms, capacity):\n    if not rooms:\n        return 0\n\n    n = len(rooms)\n    res = [0] * (n + 1)\n    res[0] = 1\n    for i in range(n):\n        res[i + 1] += res[i]\n        if i >= 2 and rooms[i]:\n            res[i + 1] -= res[i - 1] // (rooms[i - 2] * capacity)\n\n    return res[-1]\n\ndef main():\n    print(numWays([2,3,0], 5)) # Expected output: 4\n    print(numWays([6,7,0,4,5,6], 10)) # Expected output: 24\n    print(numWays([1,0,0,1], 2)) # Expected output: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1917": "```\ndef numFriendRequests(person1_height, person2_height):\n    if person1_height <= 100 or person2_height <= 100:\n        return 0\n    if (person1_height > person2_height) == ((person1_height + 7) // 8) % 2 != ((person2_height + 7) // 8) % 2:\n        return 1\n    return 0\n\ndef main():\n    test_case_1 = numFriendRequests(150, 200)\n    print(\"Test case 1: \", test_case_1)\n\n    test_case_2 = numFriendRequests(75, 80)\n    print(\"Test case 2: \", test_case_2)\n\n    test_case_3 = numFriendRequests(101, 110)\n    print(\"Test case 3: \", test_case_3)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1918": "```\ndef kthSmallestSubarraySum(nums, k):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n    \n    ans = float('inf')\n    for i in range(n - k + 2):\n        j = n\n        while j >= i:\n            if prefix_sum[j] - prefix_sum[i] == k - 1:\n                return nums[i:j]\n            elif prefix_sum[j] - prefix_sum[i] > k - 1:\n                j -= 1\n    return []\n\ndef main():\n    print(kthSmallestSubarraySum([3,5,4,2,28], 3)) \n    print(kthSmallestSubarraySum([1,3,6,10,12,19], 4))\n    print(kthSmallestSubarraySum([14,47,38,13,17,73,24,34,16], 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1920": "```\ndef buildArray(nums):\n    ans = []\n    for num in nums:\n        ans.append(nums[num])\n    return ans\n\ndef main():\n    print(buildArray([0,2,1,3]))\n    print(buildArray([4,3,2,7,8,2,3,1]))\n    print(buildArray([5,0,10,11,6,3]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1919": "```\ndef similarFriends(friends):\n    if not friends:\n        return []\n    \n    result = {}\n    for friend in friends:\n        for similar_friend in friend[1:]:\n            if similar_friend not in result:\n                result[similar_friend] = friend[0]\n            else:\n                old_friend = result.pop(similar_friend)\n                result[f\"{old_friend}-{similar_friend}\"] = friend[0]\n    \n    return list(result.values())\n\ndef main():\n    print(similarFriends([[\"John\", \"Mary\", \"Jane\"], [\"Mary\", \"Jane\", \"Sarah\"], [\"Jane\", \"Sarah\", \"Tom\"]]))\n    print(similarFriends([[\"John\", \"Alice\"], [\"Alice\", \"Bob\"], [\"Bob\", \"Charlie\"]]))\n    print(similarFriends([]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1922": "```\ndef countGoodNumbers(n):\n    MOD = 10**9 + 7\n    res = [0]\n    for i in range(n):\n        prev = res[0]\n        res = [(a*(5*i+1) if i%2==0 else a*(3*i+1)) % MOD for a in res] + [prev]\n    return sum(res)\n\ndef main():\n    print(countGoodNumbers(3))  # Expected output: 15\n    print(countGoodNumbers(4))  # Expected output: 40\n    print(countGoodNumbers(5))  # Expected output: 100\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1921": "```\ndef maxEvasion(grid):\n    rows = len(grid)\n    cols = len(grid[0])\n    res = [[0] * cols for _ in range(rows)]\n    \n    for i in range(rows):\n        for j in range(cols):\n            if grid[i][j]:\n                res[i][j] = 1\n                top = left = 1\n                for k in range(i - 1, -1, -1):\n                    if not grid[k][j]:\n                        break\n                    top -= 1\n                for k in range(j - 1, -1, -1):\n                    if not grid[i][k]:\n                        break\n                    left -= 1\n                \n                res[i][j] = min(top, left)\n    \n    return res\n\ndef main():\n    print(maxEvasion([[0,1],[1,0]])) # Output: [[0,1],[1,0]]\n    print(maxEvasion([[0,1,0],[1,0,1],[0,0,0]])) # Output: [[1,1],[1,0],[0,0]]\n    print(maxEvasion([[0,0,0],[1,1,1],[0,0,0]])) # Output: [[2,2],[1,1],[2,2]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1923": "```\nclass Solution:\n    def longestCommonSubpath(self, paths):\n        m = len(paths)\n        n = max(len(path) for path in paths)\n\n        dp = [[0] * (n + 1) for _ in range(m)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if i == 1:\n                    dp[i][j] = int(paths[0][j - 1] == paths[i - 1][j - 1])\n                elif dp[i - 1][j]:\n                    dp[i][j] = int(paths[i - 1][j - 1] == paths[i][j - 1])\n\n        for i in range(m):\n            for j in range(n, 0, -1):\n                if dp[i][j]:\n                    return ''.join(str(x) for x in paths[0][max(0, j - len(paths[0]) + 1):j])\n        return \"\"\n\ndef main():\n    solution = Solution()\n    \n    print(solution.longestCommonSubpath([\"/a/b/c\", \"/a/b/g\", \"/a/e\"]) == \"/a/b\")  \n    print(solution.longestCommonSubpath([\"/home/a/\",\"/home/a/x \",\"/home/y/\"]))\n\n    print(solution.longestCommonSubpath([\"/a\",\"/a/b\",\"/a/b/c\"])) == \"/a\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1924": "```\ndef outerTrees(points):\n    n = len(points)\n    if n < 2:\n        return [points]\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else -1\n\n    def findLWR(points):\n        n = len(points)\n        low = high = points[0]\n        for i in range(1, n):\n            if (points[i][1] < low[1]):\n                low = points[i]\n            elif (points[i][1] == low[1]):\n                if (points[i][0] < low[0]):\n                    low = points[i]\n        high = low\n        for i in range(n - 1, -1, -1):\n            if (points[i][1] > high[1]):\n                high = points[i]\n            elif (points[i][1] == high[1]):\n                if (points[i][0] > high[0]):\n                    high = points[i]\n        return low, high\n\n    def findLLR(points):\n        n = len(points)\n        low = high = points[0]\n        for i in range(1, n):\n            if (points[i][1] < low[1]):\n                low = points[i]\n            elif (points[i][1] == low[1]):\n                if (points[i][0] < low[0]):\n                    low = points[i]\n        high = low\n        for i in range(n - 1, -1, -1):\n            if (points[i][1] > high[1]):\n                high = points[i]\n            elif (points[i][1] == high[1]):\n                if (points[i][0] > high[0]):\n                    high = points[i]\n        return low, high\n\n    def findLLR2(points):\n        n = len(points)\n        low = high = points[0]\n        for i in range(1, n):\n            if (points[i][1] < low[1]):\n                low = points[i]\n            elif (points[i][1] == low[1]):\n                if (points[i][0] < low[0]):\n                    low = points[i]\n        high = low\n        for i in range(n - 1, -1, -1):\n            if (points[i][1] > high[1]):\n                high = points[i]\n            elif (points[i][1] == high[1]):\n                if (points[i][0] > high[0]):\n                    high = points[i]\n        return low, high\n\n    def findLLR3(points):\n        n = len(points)\n        low = high = points[0]\n        for i in range(1, n):\n            if (points[i][1] < low[1]):\n                low = points[i]\n            elif (points[i][1] == low[1]):\n                if (points[i][0] < low[0]):\n                    low = points[i]\n        high = low\n        for i in range(n - 1, -1, -1):\n            if (points[i][1] > high[1]):\n                high = points[i]\n            elif (points[i][1] == high[1]):\n                if (points[i][0] > high[0]):\n                    high = points[i]\n        return low, high\n\n    def findLLR4(points):\n        n = len(points)\n        low = high = points[0]\n        for i in range(1, n):\n            if (points[i][1] < low[1]):\n                low = points[i]\n            elif (points[i][1] == low[1]):\n                if (points[i][0] < low[0]):\n                    low = points[i]\n        high = low\n        for i in range(n - 1, -1, -1):\n            if (points[i][1] > high[1]):\n                high = points[i]\n            elif (points[i][1] == high[1]):\n                if (points[i][0] > high[0]):\n                    high = points[i]\n        return low, high\n\n    def findLLR5(points):\n        n = len(points)\n        low = high = points[0]\n        for i in range(1, n):\n            if (points[i][1] < low[1]):\n                low = points[i]\n            elif (points[i][1] == low[1]):\n                if (points[i][0] < low[0]):\n                    low = points[i]\n        high = low\n        for i in range(n - 1, -1, -1):\n            if (points[i][1] > high[1]):\n                high = points[i]\n            elif (points[i][1] == high[1]):\n                if (points[i][0] > high[0]):\n                    high = points[i]\n        return low, high\n\n    def findLLR6(points):\n        n = len(points)\n        low = high = points[0]\n        for i in range(1, n):\n            if (points[i][1] < low[1]):\n                low = points[i]\n            elif (points[i][1] == low[1]):\n                if (points[i][0] < low[0]):\n                    low = points[i]\n        high = low\n        for i in range(n - 1, -1, -1):\n            if (points[i][1] > high[1]):\n                high = points[i]\n            elif (points[i][1] == high[1]):\n                if (points[i][0] > high[0]):",
  "1925": "```\ndef countTriples(n):\n    res = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            k_square = j * j\n            if k_square < i * i:\n                continue\n            res += n - (i * i - j * j) // (2 * j)\n    return res\n\ndef main():\n    print(countTriples(5)) # Test case 1\n    print(countTriples(10)) # Test case 2\n    print(countTriples(20)) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1927": "```\ndef getSum(a):\n    return str(int(str(a)[0]) + int(str(a)[1]))\n\ndef sumGame(a):\n    b = str(10 - (int(str(a)[0]) + int(str(a)[1])))\n    return getSum(a) if a > getSum(b) else getSum(b)\n\ndef main():\n    test_cases = [\n        {\"a\": 37, \"expected\": \"39\"},\n        {\"a\": 53, \"expected\": \"55\"},\n        {\"a\": 49, \"expected\": \"51\"}\n    ]\n\n    for test_case in test_cases:\n        a = test_case[\"a\"]\n        expected_output = test_case[\"expected\"]\n        output = sumGame(a)\n        print(f\"Test case: {a}, Expected output: {expected_output}, Actual output: {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1926": "```\ndef shortestExitFromEntrance(maze):\n    rows, cols = len(maze), len(maze[0])\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    queue = [(0, 0, 0)]  # (row, col, distance)\n    visited = {(0, 0)}\n    \n    while queue:\n        r, c, d = queue.pop(0)\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            \n            if 0 <= nr < rows and 0 <= nc < cols and maze[nr][nc] == 1 and (nr, nc) not in visited:\n                if nc == 0 or nc == cols - 1:  # found exit\n                    return d + 1\n                \n                queue.append((nr, nc, d + 1))\n                visited.add((nr, nc))\n    \n    return -1\n\n\ndef main():\n    print(shortestExitFromEntrance([[0,0,1],[0,0,0],[0,0,0]]))  # Expected: 3\n    print(shortestExitFromEntrance([[0,1],[0,0]]))  # Expected: 1\n    print(shortestExitFromEntrance([[0,0,0],[0,1,0],[0,0,0]]))  # Expected: -1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1928": "```\ndef mincosttime(intervals):\n    intervals.sort(key=lambda x:(x[0], -x[1]))\n    n = len(intervals)\n    dp = [[float('inf')] * (n+1) for _ in range(n+1)]\n    \n    for i in range(1, n+1):\n        dp[i][i] = 0\n    for length in range(2, n+1):\n        for i in range(1, n-length+2):\n            j = i+length-1\n            dp[i][j] = float('inf')\n            for k in range(i, j+1):\n                if intervals[k][1] <= intervals[j][0]:\n                    break\n                dp[i][j] = min(dp[i][j], dp[i][k-1]+intervals[k][1]-intervals[k-1][1])\n    return dp[1][n-1]\n\ndef main():\n    print(mincosttime([[10,15],[11,25],[12,17]]))  # Output: 8\n    print(mincosttime([[5,6],[7,8]]))  # Output: 0\n    print(mincosttime([[2,4]]))  # Output: 2\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1929": "```\ndef getConcatenation(nums):\n    return [x for x in nums] * 2\n\n\ndef main():\n    print(getConcatenation([1, 2, 3])) \n    print(getConcatenation([0, 2])) \n    print(getConcatenation([1])) \n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1930": "```\ndef countSubstrings(s):\n    n = len(s)\n    seen = {}\n    res = 0\n    for i in range(n-2):\n        if s[i] == s[n-1]:\n            t = s[i:i+2]\n            if t[::-1] == t:\n                res += 1\n        if s[i] == s[i+1]:\n            t = s[i:i+3]\n            if t[::-1] == t:\n                res += 1\n    return res\n\n\ndef main():\n    print(countSubstrings(\"aba\")) \n    print(countSubstrings(\"abc\"))\n    print(countSubstrings(\"aaa\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1931": "```\ndef minStrokes(grid):\n    m, n = len(grid), len(grid[0])\n    dp = [[float('inf')] * (n + 1) for _ in range(m + 1)]\n\n    dp[0][0] = 0\n    for i in range(1, m + 1):\n        dp[i][0] = dp[i - 1][0] + 1\n    for j in range(1, n + 1):\n        dp[0][j] = dp[0][j - 1] + 1\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if grid[i - 1][j - 1] == 'X':\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n            else:\n                dp[i][j] = min(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\ndef main():\n    print(minStrokes([[\"X\", \"X\", \"X\", \"X\"], [\"X\", \"O\", \"O\", \"X\"], [\"X\", \"X\", \"O\", \"X\"]])) # Expected: 4\n    print(minStrokes([[\"W\",\"B\",\"W\",\"B\"],[\"W\",\"O\",\"B\",\"W\"],[\"B\",\"O\",\"O\",\"B\"],[\"W\",\"B\",\"W\",\"B\"]])) # Expected: 9\n    print(minStrokes([[\"X\"]]*3)) # Expected: 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1932": "```\ndef mergeTrees(root1, root2):\n    if not root1:\n        return root2\n    if not root2:\n        return root1\n    \n    if root1.val > root2.val:\n        root1.left = mergeTrees(root1.left, root2)\n        root1.right = mergeTrees(root1.right, root2)\n    else:\n        root2.left = mergeTrees(root1, root2.left)\n        root2.right = mergeTrees(root1, root2.right)\n\n    return root1.val > root2.val and root1 or root2\n\ndef printTree(root):\n    if not root:\n        return\n    print(root.val, end=' ')\n    printTree(root.left)\n    printTree(root.right)\n\ndef main():\n    # Test Case 1\n    root1 = TreeNode(3)\n    root1.left = TreeNode(1)\n    root1.right = TreeNode(5)\n    root2 = TreeNode(4)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(6)\n    printTree(mergeTrees(root1, root2))\n\n    # Test Case 2\n    root1 = None\n    root2 = TreeNode(3)\n    printTree(mergeTrees(root1, root2))\n\n    # Test Case 3\n    root1 = TreeNode(5)\n    root1.left = TreeNode(3)\n    root1.right = TreeNode(7)\n    root2 = TreeNode(4)\n    root2.left = TreeNode(2)\n    root2.right = TreeNode(6)\n    printTree(mergeTrees(root1, root2))\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1933": "```\ndef canBeEqual(s):\n    s = sorted(s)\n    for i in range(len(s)):\n        if i % 2 == 0:\n            while s[i] != s[0]:\n                if s.count(s[i]) < s.count(s[0]):\n                    return False\n                s = s.replace(s[i], '')\n    return True\n\ndef main():\n    print(canBeEqual(\"abcd\")) # False\n    print(canBeEqual(\"leetcodeeatcalifornia\")) # True\n    print(canBeEqual(\"cool\")) # True\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1934": "```\ndef averageWaitingTime(timeList):\n    if not timeList:\n        return 0.0\n\n    return sum(0 if i == 0 else timeList[i] - timeList[i-1] for i in range(len(timeList))) / len(timeList)\n\ndef main():\n    print(\"Test Case 1:\")\n    print(averageWaitingTime([10, 2, 5, 3]) == 4.333333333333333)\n\n    print(\"\\nTest Case 2:\")\n    print(averageWaitingTime([60, 60, 60]) == 0.0)\n\n    print(\"\\nTest Case 3:\")\n    print(averageWaitingTime([]) == 0.0)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1935": "```\ndef maxWordsTyped(words, keyboardRow):\n    row1 = 'qwertyuiop'\n    row2 = 'asdfghjkl'\n    row3 = 'zxcvbnm'\n\n    def dist(c):\n        if c in row1:\n            return 0\n        elif c in row2:\n            return 1\n        else:\n            return 2\n\n    ans = 0\n    for word in words:\n        curRow = ''\n        prevRow = None\n        for char in word:\n            if dist(char) == dist(prevRow):\n                curRow += char\n            else:\n                ans = max(ans, len(curRow))\n                curRow = char\n            prevRow = char\n\n        ans = max(ans, len(curRow))\n\n    return ans\n\n\ndef main():\n    print(maxWordsTyped([\"hello\", \"aladdin\"], 1))  \n    print(maxWordsTyped([\"leetcode\"], 3))  \n    print(maxWordsTyped([\"have\", \"hackerrank\", \"this\", \"is\", \"an\", \"exercise\"], 3))  \n\nif __name__ == \"__main__\":\n    main()\n```",
  "1936": "```\ndef minAddToMakeValid(S):\n    stack = []\n    res = 0\n    for c in S:\n        if c == '(':\n            stack.append(c)\n        elif c == ')':\n            if not stack:\n                res += 1\n            else:\n                stack.pop()\n    return res + len(stack)\n\ndef main():\n    print(minAddToMakeValid(\"())\")) # Test case 1: Expected output 1\n    print(minAddToMakeValid(\"((()))\")) # Test case 2: Expected output 0\n    print(minAddToMakeValid(\"(()())\")) # Test case 3: Expected output 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1938": "```\ndef maxGeneticDifference(parents):\n    parent_set = set(parents)\n    genetic_diff = {}\n    \n    def dfs(node):\n        if node not in genetic_diff:\n            genetic_diff[node] = 0\n            for child in parent_set - {node}:\n                diff = abs(0b1 << (child ^ node).bit_length())\n                dfs(child)\n                genetic_diff[node] = max(genetic_diff.get(child, 0), diff)\n    \n    dfs(0)\n    return max(genetic_diff.values())\n\ndef main():\n    print(maxGeneticDifference([3,4,2]))\n    print(maxGeneticDifference([1,2,1]))\n    print(maxGeneticDifference([10,9,8]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1937": "```\ndef maxPoints(points):\n    n = len(points)\n    if n == 1:\n        return 0\n    res = [[0]*n for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            x, y = points[i]\n            px, py = points[j]\n            slope = float('inf') if (px-x)*(py-y) == 0 else (py-y)*1.0 / (px-x)\n            res[i][j] = 1 + (res[i][j-1] if j > 0 else 0) + (res[i-1][j] if i > 0 else 0) - (res[(i-1)][(j-1)] if i > 0 and j > 0 else 0)\n            for k in range(j):\n                cpx, cpy = points[k]\n                if abs(cpx-x) + abs(cpy-y) <= slope * abs(cpx-px) + abs(cpy-py):\n                    res[i][j] -= res[i][k]\n    return max(max(row) for row in res)\n\ndef main():\n    print(maxPoints([[0,0],[2,2]])) # Expected output: 3\n    print(maxPoints([[1,1],[2,2],[3,3]])) # Expected output: 4\n    print(maxPoints([[7,5],[3,10],[4,6],[1,8]])) # Expected output: 9\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1939": "```\ndef active_users(users):\n    return [user for user in users if user['confirmed']]\n\ndef main():\n    users = [\n        {'id': 1, 'confirmed': True},\n        {'id': 2, 'confirmed': False},\n        {'id': 3, 'confirmed': True},\n        {'id': 4, 'confirmed': False}\n    ]\n    \n    print(\"Active Users:\")\n    for user in active_users(users):\n        print(user)\n\n    print(\"\\nTest Case 1: Single Confirmed User\")\n    users = [\n        {'id': 1, 'confirmed': True},\n        {'id': 2, 'confirmed': False}\n    ]\n    for user in active_users(users):\n        print(user)\n        \n    print(\"\\nTest Case 2: Multiple Confirmed Users\")\n    users = [\n        {'id': 1, 'confirmed': True},\n        {'id': 2, 'confirmed': True},\n        {'id': 3, 'confirmed': False}\n    ]\n    for user in active_users(users):\n        print(user)\n        \n    print(\"\\nTest Case 3: No Confirmed Users\")\n    users = [\n        {'id': 1, 'confirmed': False},\n        {'id': 2, 'confirmed': False}\n    ]\n    for user in active_users(users):\n        print(user)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1940": "```\ndef longestCommonSubsequence(nums1, nums2):\n    m, n = len(nums1), len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if nums1[i - 1] == nums2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]\n\ndef main():\n    print(\"Test case 1:\")\n    nums1 = [1,2,3]\n    nums2 = [1,2,3]\n    print(longestCommonSubsequence(nums1, nums2)) # Should print: 3\n\n    print(\"\\nTest case 2:\")\n    nums1 = [1,2,3,4,5]\n    nums2 = [1,2,3,5]\n    print(longestCommonSubsequence(nums1, nums2)) # Should print: 3\n\n    print(\"\\nTest case 3:\")\n    nums1 = [1,2,3,4,5,6,7,8,9]\n    nums2 = [1,3,5,7,9]\n    print(longestCommonSubsequence(nums1, nums2)) # Should print: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1941": "```\ndef frequencySorts(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n    return len(set(char_count.values())) == 1\n\n\ndef main():\n    print(f\"Test case 1: {frequencySorts('abaccd')}\")\n    print(f\"Test case 2: {frequencySorts('aabbccdd')}\")\n    print(f\"Test case 3: {frequencySorts('abcde')}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1942": "```\ndef busiestServers(busy_servers, idle_servers):\n    max_occupancy = 0\n    for server in busy_servers:\n        if len(server) > max_occupancy:\n            max_occupancy = len(server)\n\n    res = [0] * (max_occupancy + 1)\n    for server in busy_servers:\n        for i in range(len(server)):\n            if server[i]:\n                if i <= max_occupancy:\n                    res[i] += 1\n\n    return res.index(max(res)) + 1\n\ndef main():\n    print(busiestServers([[10,12],[6,14,10], [15,13,9]],[]))\n    print(busiestServers([],[(7,3),(2,5),(4,8)]))\n    print(busiestServers([(1,2),(5,6),(11,14)],[(8,11),(2,4),(6,10],[[12,16]])))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1943": "```\ndef maxArea(height):\n    max_area = 0\n    left = 0\n    right = len(height) - 1\n    \n    while left < right:\n        area = (right - left) * min(height[left], height[right])\n        max_area = max(max_area, area)\n        \n        if height[left] < height[right]:\n            left += 1\n        else:\n            right -= 1\n            \n    return max_area\n\ndef main():\n    print(\"Test Case 1: \")\n    height = [1,8,6,2,5,4,8,3,7]\n    print(maxArea(height))  # Output: 49\n    \n    print(\"\\nTest Case 2: \")\n    height = [1,1]\n    print(maxArea(height))  # Output: 1\n    \n    print(\"\\nTest Case 3: \")\n    height = [4,2,0,3,2,5]\n    print(maxArea(height))  # Output: 6\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1944": "```\ndef visiblePeople(heights):\n    stack = []\n    count = 0\n    for height in heights:\n        while len(stack) > 0 and stack[-1] <= height:\n            stack.pop()\n        if len(stack) == 0:\n            count += len(heights)\n        else:\n            count += len(heights) - stack.index(min(stack)) - 1\n        stack.append(height)\n    return count\n\ndef main():\n    test_cases = [\n        ([10,6,8,5,4,7,9], 21),\n        ([0,0,0,4,2,3,2,5], 6),\n        ([12,17,15,13,10,12,16,14,7], 32)\n    ]\n    \n    for test_case in test_cases:\n        print(\"Test case:\", test_case[0])\n        print(\"Expected result:\", test_case[1])\n        result = visiblePeople(test_case[0])\n        if result == test_case[1]:\n            print(\"Result is correct\")\n        else:\n            print(\"Result is incorrect\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1945": "```\ndef sumOfDigitsAfterConvert(S):\n    result = 0\n    for s in S:\n        if s.isdigit():\n            result += int(s)\n    return result\n\ndef main():\n    print(sumOfDigitsAfterConvert(\"123a4\")) # Test case 1\n    print(sumOfDigitsAfterConvert(\"45o67\")) # Test case 2\n    print(sumOfDigitsAfterConvert(\"abc\")) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1946": "```\ndef largestNumberwhenKeywordsGiven(num1, num2):\n    s = ''\n    while len(num1) > 0 or len(num2) > 0:\n        if len(num1) > 0 and (len(num2) == 0 or int(num1[0]) >= int(num2[0])):\n            s += num1[0]\n            num1 = num1[1:]\n        else:\n            s += num2[0]\n            num2 = num2[1:]\n    return s\n\ndef main():\n    print(largestNumberwhenKeywordsGiven(\"123\", \"456\") == \"46512\")\n    print(largestNumberwhenKeywordsGiven(\"314159753\", \"325\")) == \"953316542\")\n    print(largestNumberwhenKeywordsGiven(\"98765\", \"54321\") == \"987654321\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1947": "```\ndef maxCompatibilitySum(users):\n    n = len(users)\n    res = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            score = sum((a^b) & 1 for a, b in zip(map(int, str(users[i])), map(int, str(users[j]))))\n            res = max(res, score)\n    return res\n\n\ndef main():\n    print(maxCompatibilitySum([1234, 3768, 4855])) # Expected: 4\n    print(maxCompatibilitySum([9262, 18142, 18513, 22133])) # Expected: 6\n    print(maxCompatibilitySum([1, 2, 3, 4, 5])) # Expected: 0\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1948": "```\ndef deleteDuplicateFolders(folders):\n    if not folders:\n        return []\n\n    folder_set = set()\n    result = []\n    for folder in sorted(folders):\n        parts = folder.split('/')\n        current_folder = ''\n        for part in parts:\n            if part == '':\n                continue\n            new_folder = '/'.join([current_folder, part])\n            if new_folder not in folder_set:\n                folder_set.add(new_folder)\n                result.append(new_folder)\n            current_folder = new_folder\n    return result\n\n\ndef main():\n    test_cases = [\n        [[\"/a\",\"/a/b\",\"/a/b/c\"], \"/a\", ['/a', '/a/b', '/a/b/c']],\n        [[], []],\n        [[\"/home/user1/dir1/file1.txt\",\"/home/user2/dir2/file2.txt\",\"/home/user3/dir3\",\"/home/user1/dir1\"] ,[\"/home/user1/dir1\"], ['/home/user1/dir1', '/home/user2/dir2', '/home/user3']]\n    ]\n\n    for folders, expected in test_cases:\n        print(\"Input: \", folders)\n        output = deleteDuplicateFolders(folders)\n        if output == expected:\n            print(\"Test passed.\")\n        else:\n            print(\"Test failed. Expected: \", expected)\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1949": "```\ndef strongFriendship(citations):\n    result = []\n    for i in range(len(citations)):\n        if citations[i] >= i + 1:\n            result.append(1)\n        else:\n            result.append(0)\n\n    return len(result) - sum(result)\n\n\ndef main():\n    print(strongFriendship([0, 1, 3, 6]))  # Expected: 2\n    print(strongFriendship([1, 2, 2]))     # Expected: 1\n    print(strongFriendship([1, 2]))        # Expected: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1950": "```\ndef max_of_min_values(nums):\n    n = len(nums)\n    left = [[nums[0]]]\n    right = [[nums[-1]]]\n\n    for i in range(1, n):\n        if nums[i] <= left[-1][0]:\n            left.append([nums[i]])\n        else:\n            left.append(left[-1])\n    \n    for i in range(n-2, -1, -1):\n        if nums[i] <= right[0][0]:\n            right.insert(0, [nums[i]])\n        else:\n            right.insert(0, right[0])\n\n    max_mins = []\n    for i in range(len(left)):\n        if left[i][0] > right[-i-1][0]:\n            max_mins.append(min(left[i]))\n        elif left[i][0] < right[-i-1][0]:\n            max_mins.append(min(right[-i-1]))\n        else:\n            max_mins.append(max(left[i][0], min(left[i]), min(right[-i-1])))\n\n    return max(max_mins)\n\n\ndef main():\n    print(max_of_min_values([3, 1, 5, 2, 4])) # Output: 5\n    print(max_of_min_values([10, 11, 12])) # Output: 12\n    print(max_of_min_values([7, 6, 5, 4, 3, 2])) # Output: 4\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1951": "```\ndef max_followers(follow1, follow2):\n    return set(follow1) & set(follow2)\n\ndef max_common_followers(queries):\n    result = []\n    for query in queries:\n        pairs = [(i+1, j+1) for i in range(len(query)-1) for j in range(i+1, len(query))]\n        pair_max = 0\n        pair_max_id = (-1, -1)\n        for p in pairs:\n            c = max_followers(set(query[p[0]-1]), set(query[p[1]-1]))\n            if len(c) > pair_max:\n                pair_max = len(c)\n                pair_max_id = p\n        result.append([*pair_max_id, pair_max])\n    return result\n\ndef main():\n    queries = [\n        [\"John\", \"Mary\", \"Alex\", \"Ashton\"],\n        [\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\"],\n        [\"Chris\", \"Diana\", \"Emily\", \"Frank\", \"Gabriella\", \"Helen\"]\n    ]\n    \n    print(max_common_followers(queries))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1952": "```\ndef sum_of_numbers(n):\n    return sum(i for i in range(1, n+1) if len([j for j in range(1, i+1) if i % j == 0]) == 3)\n\ndef main():\n    print(sum_of_numbers(5))  # test case 1\n    print(sum_of_numbers(10))  # test case 2\n    print(sum_of_numbers(24))   # test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1953": "```\ndef maxWeeks(workTime: list) -> int:\n    workTime.sort()\n    weeks = 0\n    i = len(workTime) - 1\n    while i >= 0:\n        if workTime[i] >= 7:\n            weeks += 1\n            i -= 7\n        else:\n            break\n    return weeks\n\ndef main():\n    print(maxWeeks([45, 34, 32, 43, 30])) # Expected output: 2\n    print(maxWeeks([31, 38, 25, 35, 26, 48])) # Expected output: 3\n    print(maxWeeks([12, 10, 5, 45, 39])) # Expected output: 1\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1954": "```\ndef minEatingTime(appleTrees, rows, cols):\n    ans = float('inf')\n    for i in range(rows):\n        left, right = 0, cols\n        while left < right:\n            mid = (left + right) // 2\n            eaten = sum(min(mid + 1, j) for j in appleTrees[i])\n            if eaten >= len(appleTrees[0]):\n                ans = min(ans, left + right)\n                right = mid\n            else:\n                left = mid + 1\n    return ans\n\ndef main():\n    print(minEatingTime([[1,1,1], [2,3,4],[5,6,7]], 3, 3))\n    print(minEatingTime([[1,0,1], [1,1,1]], 2, 3))\n    print(minEatingTime([[0,0,0], [1,1,1]], 2, 3))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1955": "```\ndef special_subsequences(nums):\n    n = len(nums)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    ans = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if nums[j - 1] == nums[i - 1]:\n                dp[i][j] = dp[i - 1][i - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    for i in range(1, n + 1):\n        ans += dp[i][n]\n    return ans\n\ndef main():\n    print(\"Test case 1:\")\n    print(special_subsequences([1, 2, 3])) # Expected output: 8\n    print()\n\n    print(\"Test case 2:\")\n    print(special_subsequences([1, 1, 2, 3, 3, 4, 5, 6])) # Expected output: 11\n    print()\n\n    print(\"Test case 3:\")\n    print(special_subsequences([3, 3, 6, 7])) # Expected output: 7\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1956": "```\ndef time_to_multiply(k: int, initial_infected = 1) -> float:\n    ...\n\ndef main():\n    print(\"Test case 1:\")\n    k = 2\n    print(time_to_multiply(k))  # Expected output: 8.0\n    \n    print(\"\\nTest case 2:\")\n    k = 3\n    print(time_to_multiply(k, initial_infected=4))  # Expected output: 10.5\n    \n    print(\"\\nTest case 3:\")\n    k = 1\n    print(time_to_multiply(k))  # Expected output: 6.0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1957": "```\ndef makeFancyString(s):\n    result = \"\"\n    for c in s:\n        if len(result) > 0 and c == result[-1]:\n            continue\n        result += c\n    return result\n\n\ndef main():\n    print(makeFancyString(\"leea\") == \"leet\")\n    print(makeFancyString(\"aba\") == \"ba\")\n    print(makeFancyString(\"aaabbbcc\") == \"abc\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1958": "```\ndef isValidBoard(board):\n    rows = [set() for _ in range(8)]\n    cols = [set() for _ in range(8)]\n\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'b':\n                if (i, j) in rows[j]:\n                    return False\n                rows[j].add((i, j))\n                cols[i].add((i, j))\n            elif board[i][j] == 'w':\n                if (i, j) in cols[i]:\n                    return False\n                rows[j].add((i, j))\n                cols[i].add((i, j))\n\n    return True\n\ndef main():\n    print(isValidBoard([[\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"],\n                        [\"b\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"b\"],\n                        [\"b\",\"n\",\"n\",\"b\",\"b\",\"n\",\"n\",\"b\"],\n                        [\"b\",\"\",\"\",\"\",\"\",\"\",\"b\"],\n                        [\"w\",\"\",\"\",\"\",\"\",\"\",\"w\"],\n                        [\"w\",\"r\",\"r\",\"w\",\"w\",\"r\",\"r\",\"w\"],\n                        [\"w\",\"R\",\"R\",\"w\",\"w\",\"R\",\"R\",\"w\"],\n                        [\"w\",\"B\",\"B\",\"w\",\"w\",\"B\",\"B\",\"w\"]]))\n\n    print(isValidBoard([[\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"],\n                        [\"b\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"b\"],\n                        [\"b\",\"n\",\"n\",\"b\",\"b\",\"n\",\"n\",\"b\"],\n                        [\"b\",\"\",\"\",\"\",\"\",\"\",\"b\"],\n                        [\"w\",\"\",\"\",\"\",\"\",\"\",\"w\"],\n                        [\"w\",\"r\",\"r\",\"w\",\"w\",\"r\",\"r\",\"w\"],\n                        [\"w\",\"R\",\"R\",\"w\",\"w\",\"R\",\"R\",\"w\"],\n                        [\"w\",\"B\",\"Q\",\"w\",\"w\",\"K\",\"B\",\"w\"]]))\n\n    print(isValidBoard([[\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"],\n                        [\"b\",\"p\",\"p\",\"p\",\"p\",\"p\",\"p\",\"b\"],\n                        [\"b\",\"n\",\"n\",\"b\",\"b\",\"n\",\"n\",\"b\"],\n                        [\"b\",\"\",\"k\",\"b\",\"b\",\"n\",\"n\",\"b\"],\n                        [\"w\",\"\",\"k\",\"w\",\"w\",\"r\",\"r\",\"w\"],\n                        [\"w\",\"R\",\"R\",\"w\",\"w\",\"r\",\"r\",\"w\"],\n                        [\"w\",\"B\",\"Q\",\"w\",\"w\",\"K\",\"B\",\"w\"],\n                        [\"w\",\"B\",\"B\",\"w\",\"w\",\"B\",\"B\",\"w\"]]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1959": "```\ndef minWastedSpace(books, shelfWidth):\n    n = len(books)\n    dp = [[0] * (shelfWidth + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for w in range(1, shelfWidth + 1):\n            if books[i - 1] > w:\n                dp[i][w] = dp[i - 1][w]\n            else:\n                dp[i][w] = min(dp[i - 1][w], dp[i - 1][w - books[i - 1]] + books[i - 1])\n    \n    return dp[n][shelfWidth]\n\n\ndef main():\n    print(minWastedSpace([1,7,8,10,12],[4,5,6,7,10]))\n    print(minWastedSpace([3,5,130,10,500,510], [2,4,5,25,30])\n    print(minWastedSpace([9], 10))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1961": "```\ndef isPrefixString(s, words):\n    i = 0\n    for word in words:\n        if len(word) > len(s): break\n        j = 0\n        while j < len(word) and i < len(s) and s[i] == word[j]:\n            i += 1; j += 1\n        if j == len(word):\n            return True\n    return False\n\ndef main():\n    print(isPrefixString(\"iloveyou\", [\"hello\", \"iloveou\", \"iloveyou\"])) # Expected: True\n    print(isPrefixString(\"whtisypn?\", [\"practice\", \"makes\", \"perfect\", \"whatisup\", \"whatisypn?\"]) ) # Expected: True\n    print(isPrefixString(\"aaaaa\", [\"aaa\", \"aa\", \"a\"]) ) # Expected: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1960": "```\ndef maxProduct(strs):\n    n = len(strs)\n    res = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strs[i][j].isalnum() and strs[i][j] == strs[j][i]:\n                p = 0\n                while i - p >= 0 and j + p < n:\n                    if strs[i - p][i - p] != strs[j + p][j + p]:\n                        break\n                    p += 1\n                res = max(res, (2 * p) + (2 if p > 0 else 0))\n    return res\n\ndef main():\n    test_case_1 = [\"ab\", \"ba\"]\n    print(\"Test case 1: \", maxProduct(test_case_1))  # Expected output: 4\n\n    test_case_2 = [\"a\", \"ac\", \"c\"]\n    print(\"Test case 2: \", maxProduct(test_case_2))  # Expected output: 3\n\n    test_case_3 = [\"bob\", \"aba\", \"cbdbd\"]\n    print(\"Test case 3: \", maxProduct(test_case_3))  # Expected output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1962": "```\nimport heapq\n\ndef stoneGameIII(stones):\n    n = len(stones)\n    dp = [0] * (n + 1)\n    h = []\n    \n    for i in range(n - 1, -1, -1):\n        while h and h[0][0] <= i:\n            s, w = heapq.heappop(h)\n            dp[i] = max(dp[i], dp[s] + w)\n        if i < n:\n            heapq.heappush(h, (i, stones[i]))\n    \n    return dp[0]\n\ndef main():\n    test_cases = [\n        {\"stones\": [5, 4, 4, 7, 8], \"expected_output\": 1},\n        {\"stones\": [1, 2, 3, 4, 33], \"expected_output\": 3},\n        {\"stones\": [10, 6, 12, 17, 20], \"expected_output\": 1}\n    ]\n\n    for test_case in test_cases:\n        stones = test_case[\"stones\"]\n        expected_output = test_case[\"expected_output\"]\n        output = stoneGameIII(stones)\n        if output == expected_output:\n            print(f\"Test case passed: {test_case}\")\n        else:\n            print(f\"Test case failed: {test_case}, Expected output: {expected_output}, Actual output: {output}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1963": "```\ndef minSwaps(s):\n    n = len(s)\n    left = right = 0\n    swaps = 0\n    while left < n // 2:\n        if s[left] == 'R' and s[right] == 'L':\n            s = list(s[:left] + s[right:left+1] + s[left:right] + s[n-right-1:])\n            swaps += 2\n            right -= 1\n            left += 1\n        elif s[left] == 'L' and s[right] != 'R':\n            left += 1\n        else:\n            right -= 1\n\n    return swaps\n\n\ndef main():\n    print(minSwaps(\"RLRRLL\"))  # Test case 1: expected output is 2\n    print(minSwaps(\"RLLLLRRL\"))  # Test case 2: expected output is 5\n    print(minSwaps(\"LRRL\"))  # Test case 3: expected output is 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1964": "```\ndef longestValidParentheses(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    res = [0] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n + 1):\n            if s[i] == '(' and s[j - 1] == ')':\n                dp[i][j] = (dp[i + 1][j - 1] or 0) + 2\n            elif s[i] == ')' and s[j - 1] == '(':\n                dp[i][j] = max((dp[i + 1][j - 1] or 0) + 2, (dp[i][j - 1] or 0) + 2)\n            res[i] = max(res[i], dp[i][j])\n    return res\n\ndef main():\n    print(longestValidParentheses(\"((()))\")) \n    print(longestValidParentheses(\"()(()())\"))  \n    print(longestValidParentheses(\"(()(())))\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1965": "```\ndef employees_with_missing_info(employees):\n    return [employee for employee in employees if not (employee['name'] or employee['email'] or employee['phone'])]\n\ndef main():\n    test_cases = [\n        {\n            \"employees\": [\n                {\"name\": \"John\", \"email\": \"john@example.com\", \"phone\": None},\n                {\"name\": None, \"email\": \"jane@example.com\", \"phone\": \"123-4567\"},\n                {\"name\": None, \"email\": None, \"phone\": None}\n            ],\n            \"expected_result\": [\n                {\"name\": \"John\", \"email\": \"john@example.com\", \"phone\": None},\n                {\"name\": None, \"email\": \"jane@example.com\", \"phone\": \"123-4567\"}\n            ]\n        },\n        {\n            \"employees\": [\n                {\"name\": \"Jane\", \"email\": None, \"phone\": \"987-6543\"},\n                {\"name\": None, \"email\": None, \"phone\": None}\n            ],\n            \"expected_result\": [\n                {\"name\": \"Jane\", \"email\": None, \"phone\": \"987-6543\"}\n            ]\n        },\n        {\n            \"employees\": [],\n            \"expected_result\": []\n        }\n    ]\n\n    for test_case in test_cases:\n        result = employees_with_missing_info(test_case[\"employees\"])\n        print(\"Test case:\", test_case)\n        print(\"Expected result:\", test_case[\"expected_result\"])\n        print(\"Actual result:\", result)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1966": "```\ndef binarySearchable(numbers):\n    res = []\n    for num in set(numbers):\n        l, r = 0, len(numbers) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if numbers[m] >= num:\n                r = m - 1\n            else:\n                l = m + 1\n        res.append((num, l))\n    return [x[0] for x in res]\n\ndef main():\n    print(binarySearchable([10,5,2,3,20,100]))\n    print(binarySearchable([-217,11,7,2,-3,5,4]))\n    print(binarySearchable([]))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1967": "```\ndef numMatchingSubseq(s: str, words: List[str]) -> int:\n    ...\n\nif __name__ == \"__main__\":\n    s = \"abc\"\n    words = [\"aba\",\"cdc\",\"e\"] \n    print(numMatchingSubseq(s, words))\n\n    s = \"abca\"\n    words = [\"a\", \"abc\", \"cbd\"]\n    print(numMatchingSubseq(s, words)) \n\n    s = \"bb\"\n    words = [\"a\", \"b\", \"c\"]\n    print(numMatchingSubseq(s, words))\n```",
  "1968": "```\ndef averageOfSubarrays(nums):\n    n = len(nums)\n    if n == 0:\n        return []\n\n    res = []\n    for i in range(n):\n        sum1 = 0\n        sum2 = 0\n        for j in range(i):\n            sum1 += nums[j]\n        for k in range(i+1, n):\n            sum2 += nums[k]\n        if (i == 0 and sum2) or (i > 0 and sum1 != sum2):\n            res.append(nums[i])\n    return sorted(list(set(res)))\n\ndef main():\n    print(averageOfSubarrays([0])) # Test case 1\n    print(averageOfSubarrays([1,2,3,4,5])) # Test case 2\n    print(averageOfSubarrays([10,5,7,5,6])) # Test case 3\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1969": "```\ndef minNonZeroProduct(nums):\n    if not nums:\n        return 0\n    \n    zero_count = sum(1 for num in nums if num == 0)\n    \n    if zero_count > 1:\n        return 0\n    elif zero_count == 1:\n        return max(nums) if any(num != 0 for num in nums) else 0\n    \n    product = 1\n    is_zero_encountered = False\n    \n    for num in nums:\n        if num == 0:\n            is_zero_encountered = True\n        elif not is_zero_encountered:\n            product *= num\n    \n    return product\n\n\ndef main():\n    test_cases = [\n        ([3, 4, 5], 60),\n        ([1, 2, 3, 4, 5], 120),\n        ([0, 0, 0], 0)\n    ]\n    \n    for input_, expected_output in test_cases:\n        output = minNonZeroProduct(input_)\n        print(f\"Test case: {input_}, Expected Output: {expected_output}, Actual Output: {output}\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1970": "```\ndef lastDayWhereYouCanStillCross(bridges):\n    bridges.sort(key=lambda x: x[1])\n    maxDist = 0\n    for bridge in bridges:\n        if bridge[1] - bridge[0] > maxDist:\n            maxDist = bridge[1] - bridge[0]\n    return maxDist\n\ndef main():\n    test_cases = [\n        [[3,4,1,2],[true,true,false,false]], \n        [[5,1000000000,10,9],[true,false,false,false]], \n        [[7,8,9,6,5,4,3,2,1],[false,false,true,false,false,false,false,false]]\n    ]\n\n    for test_case in test_cases:\n        print(\"Test Case: \", test_case)\n        print(\"Last Day Where You Can Still Cross: \", lastDayWhereYouCanStillCross(test_case[0]))\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1971": "```\nclass Solution:\n    def hasPath(self, graph, start, end):\n        if not graph or not start or not end:\n            return False\n        \n        visited = set()\n        queue = [start]\n        \n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return True\n            \n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                    \n        return False\n\ndef main():\n    solution = Solution()\n    \n    # Test Case 1\n    graph1 = {\n        'A': ['B', 'C'],\n        'B': ['A', 'D', 'E'],\n        'C': ['A', 'F'],\n        'D': ['B'],\n        'E': ['B', 'F'],\n        'F': ['C', 'E']\n    }\n    print(\"Test Case 1: \", solution.hasPath(graph1, 'A', 'F')) # Expected output: True\n    \n    # Test Case 2\n    graph2 = {\n        'A': ['B'],\n        'B': ['A', 'C'],\n        'C': ['B']\n    }\n    print(\"Test Case 2: \", solution.hasPath(graph2, 'A', 'D')) # Expected output: False\n    \n    # Test Case 3\n    graph3 = {\n        'A': ['B'],\n        'B': []\n    }\n    print(\"Test Case 3: \", solution.hasPath(graph3, 'A', 'C')) # Expected output: False\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1972": "```\ndef lengthOfLongestPath(filename):\n    lines = open(filename).read().splitlines()\n    max_len = 0\n    for line in lines:\n        if line.startswith(\"BEGIN CALL\"):\n            start_time = int(line.split()[2])\n        elif line.startswith(\"END CALL\"):\n            end_time = int(line.split()[2])\n            if start_time == end_time:\n                return len(lines)\n    return max_len\n\ndef main():\n    print(lengthOfLongestPath('sample1.txt')) # Expected output: 3\n    print(lengthOfLongestPath('sample2.txt')) # Expected output: 4\n    print(lengthOfLongestPath('sample3.txt')) # Expected output: 5\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1973": "```\nclass Solution:\n    def equalToSumOfDescendants(self, root):\n        def dfs(node):\n            if not node: return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            self.count += 1 if node.val == left + right else 0\n            return node.val + left + right\n\n    def countNodesEqualToSumOfDescendants(self, root: TreeNode) -> int:\n        self.count = 0\n        dfs(root)\n        return self.count\n\n\ndef main():\n    solution = Solution()\n    \n    # Test case 1\n    root = TreeNode(1)\n    root.left = TreeNode(2)\n    root.right = TreeNode(3)\n    print(solution.countNodesEqualToSumOfDescendants(root))  # Expected output: 1\n\n    # Test case 2\n    root = TreeNode(4)\n    root.left = TreeNode(2)\n    root.right = TreeNode(-3, right=TreeNode(5))\n    print(solution.countNodesEqualToSumOfDescendants(root))  # Expected output: 2\n\n    # Test case 3\n    root = TreeNode(10)\n    root.left = TreeNode(5)\n    root.right = TreeNode(-3, left=TreeNode(11), right=TreeNode(3))\n    print(solution.countNodesEqualToSumOfDescendants(root))  # Expected output: 1\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1974": "```\ndef minTimeToType(word: str) -> int:\n    time = 0\n    prev_char = ''\n    \n    for char in word:\n        if char == prev_char:\n            time += 1\n        else:\n            time += 4\n        prev_char = char\n    \n    return time + len(word)\n\n\ndef main():\n    print(minTimeToType(\"abc\"))  \n    print(minTimeToType(\"applepie\")) \n    print(minTimeToType(\"bba\"))\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1975": "```\ndef maxMatrixSum(matrix):\n    n = len(matrix)\n    m = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            m[i][j] = abs(matrix[i][j])\n    sum1, sum2 = 0, 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] < 0:\n                sum1 += -matrix[i][j]\n            else:\n                sum2 += matrix[i][j]\n    return max(sum1 + 2 * sum2, sum1)\n\ndef main():\n    print(maxMatrixSum([[1,-4,-3], [-10,4,5], [5,6,9]])) # Expected output: 16\n    print(maxMatrixSum([[-1,-1,-1], -1, 1])) # Expected output: 2\n    print(maxMatrixSum([[0,0,0], [0,0,0], [0,0,0]])) # Expected output: 0\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1976": "```\ndef numWays(A, B):\n    n = len(A)\n    dp = [[0] * (B + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(B + 1):\n            if A[i - 1] > j:\n                dp[i][j] = dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] + (dp[i - 1][j - A[i - 1]] or 0)\n    return dp[n][B]\n\ndef main():\n    print(numWays([2,3,5], 10))  # Expected output: 15\n    print(numWays([4,2,7,6,9], 14))  # Expected output: 24\n    print(numWays([1,1,1], 3))  # Expected output: 8\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1977": "```\ndef numSeparating WaysToSeparate(num):\n    n = len(num)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    lastSamePrefix = [0]\n    prefixSum = [0]\n    \n    for i in range(1, n + 1):\n        if num[i - 1] == num[0]:\n            lastSamePrefix.append(lastSamePrefix[-1])\n        else:\n            lastSamePrefix.append(i)\n            \n        prefixSum.append(prefixSum[-1] + (1 if num[i - 1] != num[0] else 0))\n        \n    for i in range(n, 0, -1):\n        for j in range(i):\n            dp[j][i] = sum(1 for k in range(j) if num[k] == num[i - 1]) + (1 if num[0] == num[i - 1] else 0)\n    \n    res = 0\n    for i in range(n):\n        if prefixSum[i] > 0:\n            res += dp[0][i]\n        else:\n            res += dp[0][i + 1]\n            \n    return res\n\ndef main():\n    print(WaysToSeparate(\"123456\"))\n    print(WaysToSeparate(\"1111133\"))\n    print(WaysToSeparate(\"123456789\"))\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1978": "```\ndef findEmployeesWhoLeft(managerID):\n    # Your solution here\n    employees = {\"101\": [\"John\", \"Mary\"], \n                 \"102\": [\"Tom\", \"Jane\", \"Emma\"], \n                 \"103\": [\"Alice\"]}\n    leftManagerIDS = [101, 103]\n    return [emp for emp in employees if str(employees[emp].get(\"managerID\")) not in map(str, leftManagerIDS)]\n\ndef main():\n    testCases = [\n        {\"employees\": {\"101\": [\"John\", \"Mary\"], \n                        \"102\": [\"Tom\", \"Jane\", \"Emma\"], \n                        \"103\": [\"Alice\"], \n                        \"104\": [\"Bob\"]}, \n         \"leftManagerIDS\": [101, 103], \n         \"expectedOutput\": [\"Alice\", \"Bob\"]},\n        \n        {\"employees\": {\"101\": [\"John\", \"Mary\"], \n                        \"102\": [\"Tom\", \"Jane\", \"Emma\"], \n                        \"103\": [\"Alice\"], \n                        \"104\": [\"Bob\"], \n                        \"105\": [\"Charlie\", \"Eve\"]}, \n         \"leftManagerIDS\": [101, 103], \n         \"expectedOutput\": [\"Alice\", \"Bob\", \"Charlie\", \"Eve\"]},\n        \n        {\"employees\": {\"102\": [\"Tom\", \"Jane\", \"Emma\"], \n                        \"103\": [\"Alice\"], \n                        \"104\": [\"Bob\"]}, \n         \"leftManagerIDS\": [101, 103], \n         \"expectedOutput\": []}\n    ]\n\n    for testCase in testCases:\n        result = findEmployeesWhoLeft(testCase[\"employees\"], testCase[\"leftManagerIDS\"])\n        if result == testCase[\"expectedOutput\"]:\n            print(\"Test case passed\")\n        else:\n            print(f\"Test case failed. Expected {testCase['expectedOutput']} but got {result}\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1979": "```\ndef greatestCommonDivisor(arr):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    result = arr[0]\n    for num in arr[1:]:\n        result = gcd(result, num)\n    \n    return result\n\n\ndef main():\n    test_cases = [\n        ([4, 6, 8, 16], 4),\n        ([2, 7, 5, 3, 14], 1),\n        ([10, 20, 30], 10),\n    ]\n\n    for input_arr, expected_result in test_cases:\n        result = greatestCommonDivisor(input_arr)\n        if result == expected_result:\n            print(f\"Test case passed: {input_arr} => {result}\")\n        else:\n            print(f\"Test case failed: {input_arr} => {expected_result} (got {result})\")\n\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1980": "```\ndef findUniqueBinaryString(nums):\n    unique_nums = set()\n    for num in nums:\n        bin_num = bin(num)[2:].zfill(16)\n        if bin_num.count('1') == 1:\n            unique_nums.add(bin_num)\n    return sorted(list(unique_nums))\n\ndef main():\n    print(findUniqueBinaryString([5,6])) \n    print(findUniqueBinaryString([10,11,12,13,14,15]))\n    print(findUniqueBinaryString([2]))\n\nmain()\n```",
  "1981": "```\ndef minDifference(nums):\n    n = len(nums)\n    total_sum = sum(nums)\n    target_sum = (n + 1) * n // 2\n    if total_sum == target_sum:\n        return 0\n    \n    dp = [[float('inf')] * (target_sum + 1) for _ in range(n + 1)]\n    \n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for j in range(target_sum + 1):\n            if j >= nums[i - 1]:\n                dp[i][j] = min(dp[i][j], abs(j - nums[i - 1]))\n            dp[i][j] = min(dp[i][j], dp[i - 1][j])\n            if i > 0 and j >= nums[i - 1]:\n                dp[i][j] = min(dp[i][j], dp[i - 1][j - nums[i - 1]] + nums[i - 1])\n    res = float('inf')\n    for i in range(target_sum // 2, target_sum + 1):\n        res = min(res, dp[n][i])\n    return res\n\ndef main():\n    print(minDifference([9,6,5])) # expected output: 0\n    print(minDifference([7,3,4]) # expected output: 1\n    print(minDifference([1,2,3,4]) # expected output: 1\n    \nif __name__ == \"__main__\":\n    main()\n```",
  "1982": "```\ndef subsetSums(nums, sums):\n    n = len(nums)\n    res = [[] for _ in range(sums[-1] + 1)]\n    cur_sum = 0\n    for num in nums:\n        new_sums = []\n        for i in range(cur_sum + 1, sums[-1] - num + 1):\n            if not res[i]:\n                new_sums.append(i)\n        for i in range(len(new_sums)):\n            res[new_sums[i]] = [subset + [num] for subset in res.get(new_sums[i] - num, [])]\n        cur_sum += num\n    return [subset for sublist in res for subset in sublist]\n\ndef main():\n    print(subsetSums([1, 2], [5]))  # [[1, 1, 1, 1, 1], [2, 2, 1]]\n    print(subsetSums([3, 4, 6], [8]))  # [[3, 3, 3], [4, 4], [6]]\n    print(subsetSums([15, 20, 30], [60]))  # [[15, 15, 15, 15], [20, 20, 20], [30]]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1983": "```\ndef maxEqualRangeSum(nums):\n    n = len(nums)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i+1] = prefix_sum[i] + nums[i]\n    \n    left, right = 0, 0\n    max_width = 0\n    for i in range(n):\n        for j in range(i, n):\n            if (prefix_sum[j + 1] - prefix_sum[i]) % (j - i + 1) == 0:\n                width = j - i + 1\n                if width > max_width:\n                    max_width = width\n                    left, right = i, j\n    \n    return [left, right]\n\ndef main():\n    print(maxEqualRangeSum([1,2,3,4,5])) # Expected output: [0, 4]\n    print(maxEqualRangeSum([-7,-10,1,2,9,8,2,5,10,6,12])) # Expected output: [5, 9]\n    print(maxEqualRangeSum([0,0,0,0,0])) # Expected output: [0, 4]\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1984": "```\ndef minimumDifference(nums, k):\n    nums.sort()\n    return sum(nums[i+k-1] - nums[i] for i in range(k-1)) + (nums[-1] - nums[0])\n\ndef main():\n    print(minimumDifference([9,4,1,7], 2) == 2)\n    print(minimumDifference([11,9,5,8,12,6], 3) == 2)\n    print(minimumDifference([10], 1) == 0)\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1985": "```\ndef kthLargestValue(nums, k):\n    if not nums:\n        return None\n    if k < 1 or k > len(nums):\n        return None\n    nums.sort(reverse=True)\n    return nums[k-1]\n\ndef main():\n    print(kthLargestValue([3,2,1,4,5], 1), \"Expected: 5\")\n    print(kthLargestValue([1,2,3,4,5], 2), \"Expected: 4\")\n    print(kthLargestValue([0,1], 3), \"Expected: None\")\n\nif __name__ == \"__main__\":\n    main()\n```",
  "1986": "```\ndef minSessions(tasks, newWorker, workers):\n    n = len(tasks)\n    dp = [[float('inf')] * (1 << n) for _ in range(n + 1)]\n    dp[0][0] = 0\n    for i in range(1, n + 1):\n        for mask in range(1 << n):\n            if not ((mask >> tasks[i - 1].shift()) & 1):\n                continue\n            for j in range(i):\n                if not ((mask >> tasks[j].shift()) & 1) and (dp[j][mask ^ (1 << tasks[j].shift())] + 1 < dp[i][mask]):\n                    dp[i][mask] = dp[j][mask ^ (1 << tasks[j].shift())] + 1\n    return min(dp[-1])\n\ndef main():\n    test_cases = [\n        ([2,3,4],5,[0,1]),\n        ([5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],30,[0,1]),\n        ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30],60,[0,1])\n    ]\n    \n    for tasks, new_worker, workers in test_cases:\n        print(f\"Minimum number of work sessions to finish the tasks: {minSessions(tasks, new_worker, workers)}\")\n\nif __name__ == \"__main__\":\n    main()\n```"
}