---
title: "Two Sum"
slug: "two-sum"
difficulty: "Easy"
tags: ["Array", "HashMap"]
---

## Explanation

We use a **hash map** to store numbers we've seen so far and their indices. For each element `nums[i]`, we check if `target - nums[i]` (the complement) is already in the map. If it is, we return the current index and the index of the complement.

This approach ensures **O(n)** time complexity, where *n* is the length of the array, because each lookup and insert in the map is done in constant time.

### Time Complexity

- **Best Case**: **O(1)** - If the solution is found in the first few iterations.
- **Worst Case**: **O(n)** - When we iterate through the entire array without finding the solution.

### Space Complexity

- **O(n)** - The hash map can store up to *n* elements in the worst case, where *n* is the length of the input array.

### Visual Representation

Below is a step-by-step illustration of how the algorithm works:

1. **Initial State**:
    - Input array: `[2, 7, 11, 15]`
    - Target: `9`
    - Hash map: `{}` (empty)

2. **Step 1**:
    - Current number: `2`
    - Complement: `9 - 2 = 7`
    - Hash map: `{}` (complement not found)
    - Add `2` to the hash map: `{2: 0}`

3. **Step 2**:
    - Current number: `7`
    - Complement: `9 - 7 = 2`
    - Hash map: `{2: 0}` (complement found at index `0`)
    - Return indices: `[0, 1]`

### Key Points:
- The hash map stores each number as a key and its index as the value.
- The algorithm stops as soon as the complement is found, ensuring efficiency.

---

```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    return new int[] {};
}
```

---

```cpp
#include <unordered_map>
#include <vector>
using namespace std;

vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (map.count(complement)) {
            return { map[complement], i };
        }
        map[nums[i]] = i;
    }
    return {};
}
```

---

```python
from typing import List

def twoSum(nums: List[int], target: int) -> List[int]:
    seen = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []
```

---
