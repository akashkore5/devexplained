---
id: "996"
title: "Number of Squareful Arrays"
companyTags: "Unknown"
slug: "number-of-squareful-arrays"
difficulty: "Hard"
tags: ["Array", "Hash Table", "Math", "Dynamic Programming", "Backtracking", "Bit Manipulation", "Bitmask"]
---

### Explanation:
To solve this problem, we can use backtracking to generate all permutations of the given array `nums`. We will keep track of the count of squareful permutations and check whether each permutation satisfies the squareful condition or not. We can use a helper function to check if the sum of two elements is a perfect square.

#### Algorithm:
1. Initialize a count variable to store the number of squareful permutations.
2. Sort the input array `nums`.
3. Implement a helper function `isSquareful` to check if the sum of two elements is a perfect square.
4. Implement a recursive backtracking function `permute` to generate all permutations.
5. In the `permute` function:
   - Base case: If the current permutation's length is equal to the length of `nums`, check if it is squareful and increment the count if true.
   - Iterate through the remaining elements and swap them with the current index to generate permutations.
   - Ensure no duplicate permutations are generated by skipping swapping with elements that have been swapped before.
6. Return the count of squareful permutations.

#### Time Complexity:
The time complexity of this approach is O(N!), where N is the length of the input array `nums`.

#### Space Complexity:
The space complexity is O(N), where N is the length of the input array `nums`.

```java
class Solution {
    public int numSquarefulPerms(int[] nums) {
        Arrays.sort(nums);
        return permute(nums, 0, new boolean[nums.length], -1);
    }
    
    private int permute(int[] nums, int count, boolean[] visited, int prev) {
        if (count == nums.length) {
            return 1;
        }
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {
                continue;
            }
            if (prev == -1 || isSquareful(nums[i] + prev)) {
                visited[i] = true;
                res += permute(nums, count + 1, visited, nums[i]);
                visited[i] = false;
            }
        }
        return res;
    }
    
    private boolean isSquareful(int num) {
        int root = (int)Math.sqrt(num);
        return root * root == num;
    }
}
```

#### C++
```cpp
class Solution {
public:
    int numSquarefulPerms(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return permute(nums, 0, vector<bool>(nums.size()), -1);
    }
    
    int permute(vector<int>& nums, int count, vector<bool>& visited, int prev) {
        if (count == nums.size()) {
            return 1;
        }
        int res = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1])) {
                continue;
            }
            if (prev == -1 || isSquareful(nums[i] + prev)) {
                visited[i] = true;
                res += permute(nums, count + 1, visited, nums[i]);
                visited[i] = false;
            }
        }
        return res;
    }
    
    bool isSquareful(int num) {
        int root = sqrt(num);
        return root * root == num;
    }
};
```

#### Python
```python
class Solution:
    def numSquarefulPerms(self, nums: List[int]) -> int:
        nums.sort()
        return self.permute(nums, 0, [False] * len(nums), -1)
    
    def permute(self, nums, count, visited, prev):
        if count == len(nums):
            return 1
        res = 0
        for i in range(len(nums)):
            if visited[i] or (i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]):
                continue
            if prev == -1 or self.isSquareful(nums[i] + prev):
                visited[i] = True
                res += self.permute(nums, count + 1, visited, nums[i])
                visited[i] = False
        return res
    
    def isSquareful(self, num):
        root = int(num ** 0.5)
        return root * root == num
```